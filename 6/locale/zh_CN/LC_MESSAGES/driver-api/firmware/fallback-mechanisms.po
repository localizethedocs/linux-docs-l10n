# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-25 09:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/firmware/fallback-mechanisms.rst:3
msgid "Fallback mechanisms"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:5
msgid ""
"A fallback mechanism is supported to allow to overcome failures to do a "
"direct filesystem lookup on the root filesystem or when the firmware simply "
"cannot be installed for practical reasons on the root filesystem. The kernel "
"configuration options related to supporting the firmware fallback mechanism "
"are:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:10
msgid ""
"CONFIG_FW_LOADER_USER_HELPER: enables building the firmware fallback "
"mechanism. Most distributions enable this option today. If enabled but "
"CONFIG_FW_LOADER_USER_HELPER_FALLBACK is disabled, only the custom fallback "
"mechanism is available and for the request_firmware_nowait() call."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:14
msgid ""
"CONFIG_FW_LOADER_USER_HELPER_FALLBACK: force enables each request to enable "
"the kobject uevent fallback mechanism on all firmware API calls except "
"request_firmware_direct(). Most distributions disable this option today. The "
"call request_firmware_nowait() allows for one alternative fallback "
"mechanism: if this kconfig option is enabled and your second argument to "
"request_firmware_nowait(), uevent, is set to false you are informing the "
"kernel that you have a custom fallback mechanism and it will manually load "
"the firmware. Read below for more details."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:23
msgid "Note that this means when having this configuration:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:25
msgid "CONFIG_FW_LOADER_USER_HELPER=y CONFIG_FW_LOADER_USER_HELPER_FALLBACK=n"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:28
msgid ""
"the kobject uevent fallback mechanism will never take effect even for "
"request_firmware_nowait() when uevent is set to true."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:32
msgid "Justifying the firmware fallback mechanism"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:34
msgid ""
"Direct filesystem lookups may fail for a variety of reasons. Known reasons "
"for this are worth itemizing and documenting as it justifies the need for "
"the fallback mechanism:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:38
msgid "Race against access with the root filesystem upon bootup."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:40
msgid ""
"Races upon resume from suspend. This is resolved by the firmware cache, but "
"the firmware cache is only supported if you use uevents, and its not "
"supported for request_firmware_into_buf()."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:44
msgid "Firmware is not accessible through typical means:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:46
msgid "It cannot be installed into the root filesystem"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:47
msgid ""
"The firmware provides very unique device specific data tailored for the unit "
"gathered with local information. An example is calibration data for WiFi "
"chipsets for mobile devices. This calibration data is not common to all "
"units, but tailored per unit.  Such information may be installed on a "
"separate flash partition other than where the root filesystem is provided."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:55
msgid "Types of fallback mechanisms"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:57
msgid ""
"There are really two fallback mechanisms available using one shared sysfs "
"interface as a loading facility:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:60
msgid "Kobject uevent fallback mechanism"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:61
msgid "Custom fallback mechanism"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:63
msgid "First lets document the shared sysfs loading facility."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:66
msgid "Firmware sysfs loading facility"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:68
msgid ""
"In order to help device drivers upload firmware using a fallback mechanism "
"the firmware infrastructure creates a sysfs interface to enable userspace to "
"load and indicate when firmware is ready. The sysfs directory is created via "
"fw_create_instance(). This call creates a new struct device named after the "
"firmware requested, and establishes it in the device hierarchy by "
"associating the device used to make the request as the device's parent. The "
"sysfs directory's file attributes are defined and controlled through the new "
"device's class (firmware_class) and group (fw_dev_attr_groups). This is "
"actually where the original firmware_class module name came from, given that "
"originally the only firmware loading mechanism available was the mechanism "
"we now use as a fallback mechanism, which registers a struct class "
"firmware_class. Because the attributes exposed are part of the module name, "
"the module name firmware_class cannot be renamed in the future, to ensure "
"backward compatibility with old userspace."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:83
msgid ""
"To load firmware using the sysfs interface we expose a loading indicator, "
"and a file upload firmware into:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:86
msgid "/sys/$DEVPATH/loading"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:87
msgid "/sys/$DEVPATH/data"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:89
msgid ""
"To upload firmware you will echo 1 onto the loading file to indicate you are "
"loading firmware. You then write the firmware into the data file, and you "
"notify the kernel the firmware is ready by echo'ing 0 onto the loading file."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:94
msgid ""
"The firmware device used to help load firmware using sysfs is only created "
"if direct firmware loading fails and if the fallback mechanism is enabled "
"for your firmware request, this is set up with :c:func:"
"`firmware_fallback_sysfs`. It is important to re-iterate that no device is "
"created if a direct filesystem lookup succeeded."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:100
msgid "Using::"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:104
msgid ""
"Will clean any previous partial load at once and make the firmware API "
"return an error. When loading firmware the firmware_class grows a buffer for "
"the firmware in PAGE_SIZE increments to hold the image as it comes in."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:108
msgid ""
"firmware_data_read() and firmware_loading_show() are just provided for the "
"test_firmware driver for testing, they are not called in normal use or "
"expected to be used regularly by userspace."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:113
msgid "firmware_fallback_sysfs"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:203
msgid "use the fallback mechanism to find firmware"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:207
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:209
msgid "``struct firmware *fw``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:204
msgid "pointer to firmware image"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:206
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:205
msgid "name of firmware file to look for"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:207
msgid "``struct device *device``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:206
msgid "device for which firmware is being loaded"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:208
msgid "``u32 opt_flags``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:207
msgid ""
"options to control firmware loading behaviour, as defined by :c:type:`enum "
"fw_opt <fw_opt>`"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:210
msgid "``int ret``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:209
msgid "return value from direct lookup which triggered the fallback mechanism"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:211
msgid "**Description**"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:114:
#: drivers/base/firmware_loader/fallback.c:210
msgid ""
"This function is called if direct lookup for the firmware failed, it enables "
"a fallback mechanism through userspace by exposing a sysfs loading "
"interface. Userspace is in charge of loading the firmware through the sysfs "
"loading interface. This sysfs fallback mechanism may be disabled completely "
"on a system by setting the proc sysctl value ignore_sysfs_fallback to true. "
"If this is false we check if the internal API caller set the "
"**FW_OPT_NOFALLBACK_SYSFS** flag, if so it would also disable the fallback "
"mechanism. A system may want to enforce the sysfs fallback mechanism at all "
"times, it can do this by setting ignore_sysfs_fallback to false and "
"force_sysfs_fallback to true. Enabling force_sysfs_fallback is functionally "
"equivalent to build a kernel with CONFIG_FW_LOADER_USER_HELPER_FALLBACK."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:118
msgid "Firmware kobject uevent fallback mechanism"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:120
msgid ""
"Since a device is created for the sysfs interface to help load firmware as a "
"fallback mechanism userspace can be informed of the addition of the device "
"by relying on kobject uevents. The addition of the device into the device "
"hierarchy means the fallback mechanism for firmware loading has been "
"initiated. For details of implementation refer to fw_load_sysfs_fallback(), "
"in particular on the use of dev_set_uevent_suppress() and kobject_uevent()."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:127
msgid ""
"The kernel's kobject uevent mechanism is implemented in lib/kobject_uevent."
"c, it issues uevents to userspace. As a supplement to kobject uevents Linux "
"distributions could also enable CONFIG_UEVENT_HELPER_PATH, which makes use "
"of core kernel's usermode helper (UMH) functionality to call out to a "
"userspace helper for kobject uevents. In practice though no standard "
"distribution has ever used the CONFIG_UEVENT_HELPER_PATH. If "
"CONFIG_UEVENT_HELPER_PATH is enabled this binary would be called each time "
"kobject_uevent_env() gets called in the kernel for each kobject uevent "
"triggered."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:136
msgid ""
"Different implementations have been supported in userspace to take advantage "
"of this fallback mechanism. When firmware loading was only possible using "
"the sysfs mechanism the userspace component \"hotplug\" provided the "
"functionality of monitoring for kobject events. Historically this was "
"superseded be systemd's udev, however firmware loading support was removed "
"from udev as of systemd commit be2ea723b1d0 (\"udev: remove userspace "
"firmware loading support\") as of v217 on August, 2014. This means most "
"Linux distributions today are not using or taking advantage of the firmware "
"fallback mechanism provided by kobject uevents. This is specially "
"exacerbated due to the fact that most distributions today disable "
"CONFIG_FW_LOADER_USER_HELPER_FALLBACK."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:147
msgid ""
"Refer to do_firmware_uevent() for details of the kobject event variables "
"setup. The variables currently passed to userspace with a \"kobject add\" "
"event are:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:151
msgid "FIRMWARE=firmware name"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:152
msgid "TIMEOUT=timeout value"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:153
msgid "ASYNC=whether or not the API request was asynchronous"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:155
msgid ""
"By default DEVPATH is set by the internal kernel kobject infrastructure. "
"Below is an example simple kobject uevent script::"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:165
msgid "Firmware custom fallback mechanism"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:167
msgid ""
"Users of the request_firmware_nowait() call have yet another option "
"available at their disposal: rely on the sysfs fallback mechanism but "
"request that no kobject uevents be issued to userspace. The original logic "
"behind this was that utilities other than udev might be required to lookup "
"firmware in non-traditional paths -- paths outside of the listing documented "
"in the section 'Direct filesystem lookup'. This option is not available to "
"any of the other API calls as uevents are always forced for them."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:175
msgid ""
"Since uevents are only meaningful if the fallback mechanism is enabled in "
"your kernel it would seem odd to enable uevents with kernels that do not "
"have the fallback mechanism enabled in their kernels. Unfortunately we also "
"rely on the uevent flag which can be disabled by request_firmware_nowait() "
"to also setup the firmware cache for firmware requests. As documented above, "
"the firmware cache is only set up if uevent is enabled for an API call. "
"Although this can disable the firmware cache for request_firmware_nowait() "
"calls, users of this API should not use it for the purposes of disabling the "
"cache as that was not the original purpose of the flag. Not setting the "
"uevent flag means you want to opt-in for the firmware fallback mechanism but "
"you want to suppress kobject uevents, as you have a custom solution which "
"will monitor for your device addition into the device hierarchy somehow and "
"load firmware for you through a custom path."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:190
msgid "Firmware fallback timeout"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:192
msgid ""
"The firmware fallback mechanism has a timeout. If firmware is not loaded "
"onto the sysfs interface by the timeout value an error is sent to the "
"driver. By default the timeout is set to 60 seconds if uevents are "
"desirable, otherwise MAX_JIFFY_OFFSET is used (max timeout possible). The "
"logic behind using MAX_JIFFY_OFFSET for non-uevents is that a custom "
"solution will have as much time as it needs to load firmware."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:199
msgid ""
"You can customize the firmware timeout by echo'ing your desired timeout into "
"the following file:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:202
msgid "/sys/class/firmware/timeout"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:204
msgid ""
"If you echo 0 into it means MAX_JIFFY_OFFSET will be used. The data type for "
"the timeout is an int."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:208
msgid "EFI embedded firmware fallback mechanism"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:210
msgid ""
"On some devices the system's EFI code / ROM may contain an embedded copy of "
"firmware for some of the system's integrated peripheral devices and the "
"peripheral's Linux device-driver needs to access this firmware."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:214
msgid ""
"Device drivers which need such firmware can use the "
"firmware_request_platform() function for this, note that this is a separate "
"fallback mechanism from the other fallback mechanisms and this does not use "
"the sysfs interface."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:219
msgid ""
"A device driver which needs this can describe the firmware it needs using an "
"efi_embedded_fw_desc struct:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:22
msgid ""
"This struct is used by the EFI embedded-fw code to search for embedded "
"firmwares."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:26
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:35
msgid "**Members**"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:25
msgid "``name``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:26
msgid "Name to register the firmware with if found"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:26
msgid "``prefix``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:27
msgid "First 8 bytes of the firmware"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:27
msgid "``length``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:28
msgid "Length of the firmware in bytes including prefix"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:28
msgid "``sha256``"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms:222:
#: include/linux/efi_embedded_fw.h:29
msgid "SHA256 of the firmware"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:225
msgid ""
"The EFI embedded-fw code works by scanning all EFI_BOOT_SERVICES_CODE memory "
"segments for an eight byte sequence matching prefix; if the prefix is found "
"it then does a sha256 over length bytes and if that matches makes a copy of "
"length bytes and adds that to its list with found firmwares."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:230
msgid ""
"To avoid doing this somewhat expensive scan on all systems, dmi matching is "
"used. Drivers are expected to export a dmi_system_id array, with each "
"entries' driver_data pointing to an efi_embedded_fw_desc."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:234
msgid ""
"To register this array with the efi-embedded-fw code, a driver needs to:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:236
msgid ""
"Always be builtin to the kernel or store the dmi_system_id array in a "
"separate object file which always gets builtin."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:239
msgid ""
"Add an extern declaration for the dmi_system_id array to include/linux/"
"efi_embedded_fw.h."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:242
msgid ""
"Add the dmi_system_id array to the embedded_fw_table in drivers/firmware/efi/"
"embedded-firmware.c wrapped in a #ifdef testing that the driver is being "
"builtin."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:246
msgid "Add \"select EFI_EMBEDDED_FIRMWARE if EFI_STUB\" to its Kconfig entry."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:248
msgid ""
"The firmware_request_platform() function will always first try to load "
"firmware with the specified name directly from the disk, so the EFI embedded-"
"fw can always be overridden by placing a file under /lib/firmware."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:252
msgid "Note that:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:254
msgid ""
"The code scanning for EFI embedded-firmware runs near the end of "
"start_kernel(), just before calling rest_init(). For normal drivers and "
"subsystems using subsys_initcall() to register themselves this does not "
"matter. This means that code running earlier cannot use EFI embedded-"
"firmware."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:260
msgid ""
"At the moment the EFI embedded-fw code assumes that firmwares always start "
"at an offset which is a multiple of 8 bytes, if this is not true for your "
"case send in a patch to fix this."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:264
msgid ""
"At the moment the EFI embedded-fw code only works on x86 because other archs "
"free EFI_BOOT_SERVICES_CODE before the EFI embedded-fw code gets a chance to "
"scan it."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:268
msgid ""
"The current brute-force scanning of EFI_BOOT_SERVICES_CODE is an ad-hoc "
"brute-force solution. There has been discussion to use the UEFI Platform "
"Initialization (PI) spec's Firmware Volume protocol. This has been rejected "
"because the FV Protocol relies on *internal* interfaces of the PI spec, and: "
"1. The PI spec does not define peripheral firmware at all 2. The internal "
"interfaces of the PI spec do not guarantee any backward compatibility. Any "
"implementation details in FV may be subject to change, and may vary system "
"to system. Supporting the FV Protocol would be difficult as it is purposely "
"ambiguous."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:279
msgid "Example how to check for and extract embedded firmware"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:281
msgid ""
"To check for, for example Silead touchscreen controller embedded firmware, "
"do the following:"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:284
msgid "Boot the system with efi=debug on the kernel commandline"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:286
msgid "cp /sys/kernel/debug/efi/boot_services_code? to your home dir"
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:288
msgid ""
"Open the boot_services_code? files in a hex-editor, search for the magic "
"prefix for Silead firmware: F0 00 00 00 02 00 00 00, this gives you the "
"beginning address of the firmware inside the boot_services_code? file."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:292
msgid ""
"The firmware has a specific pattern, it starts with a 8 byte page-address, "
"typically F0 00 00 00 02 00 00 00 for the first page followed by 32-bit word-"
"address + 32-bit value pairs. With the word-address incrementing 4 bytes (1 "
"word) for each pair until a page is complete. A complete page is followed by "
"a new page-address, followed by more word + value pairs. This leads to a "
"very distinct pattern. Scroll down until this pattern stops, this gives you "
"the end of the firmware inside the boot_services_code? file."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:300
msgid ""
"\"dd if=boot_services_code? of=firmware bs=1 skip=<begin-addr> count=<len>\" "
"will extract the firmware for you. Inspect the firmware file in a hexeditor "
"to make sure you got the dd parameters correct."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:304
msgid "Copy it to /lib/firmware under the expected name to test it."
msgstr ""

#: ../../../driver-api/firmware/fallback-mechanisms.rst:306
msgid ""
"If the extracted firmware works, you can use the found info to fill an "
"efi_embedded_fw_desc struct to describe it, run \"sha256sum firmware\" to "
"get the sha256sum to put in the sha256 field."
msgstr ""
