# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/dmaengine/provider.rst:3
msgid "DMAengine controller documentation"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:6
msgid "Hardware Introduction"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:8
msgid ""
"Most of the Slave DMA controllers have the same general principles of "
"operations."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:11
msgid ""
"They have a given number of channels to use for the DMA transfers, and a "
"given number of requests lines."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:14
msgid ""
"Requests and channels are pretty much orthogonal. Channels can be used to "
"serve several to any requests. To simplify, channels are the entities that "
"will be doing the copy, and requests what endpoints are involved."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:19
msgid ""
"The request lines actually correspond to physical lines going from the DMA-"
"eligible devices to the controller itself. Whenever the device will want to "
"start a transfer, it will assert a DMA request (DRQ) by asserting that "
"request line."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:24
msgid ""
"A very simple DMA controller would only take into account a single "
"parameter: the transfer size. At each clock cycle, it would transfer a byte "
"of data from one buffer to another, until the transfer size has been reached."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:29
msgid ""
"That wouldn't work well in the real world, since slave devices might require "
"a specific number of bits to be transferred in a single cycle. For example, "
"we may want to transfer as much data as the physical bus allows to maximize "
"performances when doing a simple memory copy operation, but our audio device "
"could have a narrower FIFO that requires data to be written exactly 16 or 24 "
"bits at a time. This is why most if not all of the DMA controllers can "
"adjust this, using a parameter called the transfer width."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:38
msgid ""
"Moreover, some DMA controllers, whenever the RAM is used as a source or "
"destination, can group the reads or writes in memory into a buffer, so "
"instead of having a lot of small memory accesses, which is not really "
"efficient, you'll get several bigger transfers. This is done using a "
"parameter called the burst size, that defines how many single reads/writes "
"it's allowed to do without the controller splitting the transfer into "
"smaller sub-transfers."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:46
msgid ""
"Our theoretical DMA controller would then only be able to do transfers that "
"involve a single contiguous block of data. However, some of the transfers we "
"usually have are not, and want to copy data from non-contiguous buffers to a "
"contiguous buffer, which is called scatter-gather."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:52
msgid ""
"DMAEngine, at least for mem2dev transfers, require support for scatter-"
"gather. So we're left with two cases here: either we have a quite simple DMA "
"controller that doesn't support it, and we'll have to implement it in "
"software, or we have a more advanced DMA controller, that implements in "
"hardware scatter-gather."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:58
msgid ""
"The latter are usually programmed using a collection of chunks to transfer, "
"and whenever the transfer is started, the controller will go over that "
"collection, doing whatever we programmed there."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:62
msgid ""
"This collection is usually either a table or a linked list. You will then "
"push either the address of the table and its number of elements, or the "
"first item of the list to one channel of the DMA controller, and whenever a "
"DRQ will be asserted, it will go through the collection to know where to "
"fetch the data from."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:68
msgid ""
"Either way, the format of this collection is completely dependent on your "
"hardware. Each DMA controller will require a different structure, but all of "
"them will require, for every chunk, at least the source and destination "
"addresses, whether it should increment these addresses or not and the three "
"parameters we saw earlier: the burst size, the transfer width and the "
"transfer size."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:75
msgid ""
"The one last thing is that usually, slave devices won't issue DRQ by "
"default, and you have to enable this in your slave device driver first "
"whenever you're willing to use DMA."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:79
msgid ""
"These were just the general memory-to-memory (also called mem2mem) or memory-"
"to-device (mem2dev) kind of transfers. Most devices often support other kind "
"of transfers or memory operations that dmaengine support and will be "
"detailed later in this document."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:85
msgid "DMA Support in Linux"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:87
msgid ""
"Historically, DMA controller drivers have been implemented using the async "
"TX API, to offload operations such as memory copy, XOR, cryptography, etc., "
"basically any memory to memory operation."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:91
msgid ""
"Over time, the need for memory to device transfers arose, and dmaengine was "
"extended. Nowadays, the async TX API is written as a layer on top of "
"dmaengine, and acts as a client. Still, dmaengine accommodates that API in "
"some cases, and made some design choices to ensure that it stayed compatible."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:97
msgid ""
"For more information on the Async TX API, please look the relevant "
"documentation file in Documentation/crypto/async-tx-api.rst."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:101
msgid "DMAEngine APIs"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:104
msgid "``struct dma_device`` Initialization"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:106
msgid ""
"Just like any other kernel framework, the whole DMAEngine registration "
"relies on the driver filling a structure and registering against the "
"framework. In our case, that structure is dma_device."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:110
msgid ""
"The first thing you need to do in your driver is to allocate this structure. "
"Any of the usual memory allocators will do, but you'll also need to "
"initialize a few fields in there:"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:114
msgid ""
"``channels``: should be initialized as a list using the INIT_LIST_HEAD macro "
"for example"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:117
msgid ""
"``src_addr_widths``: should contain a bitmask of the supported source "
"transfer width"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:120
msgid ""
"``dst_addr_widths``: should contain a bitmask of the supported destination "
"transfer width"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:123
msgid ""
"``directions``: should contain a bitmask of the supported slave directions "
"(i.e. excluding mem2mem transfers)"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:127
msgid ""
"``residue_granularity``: granularity of the transfer residue reported to "
"dma_set_residue. This can be either:"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:131
msgid ""
"Descriptor: your device doesn't support any kind of residue reporting. The "
"framework will only know that a particular transaction descriptor is done."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:136
msgid ""
"Segment: your device is able to report which chunks have been transferred"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:139
msgid "Burst: your device is able to report which burst have been transferred"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:142
msgid ""
"``dev``: should hold the pointer to the ``struct device`` associated to your "
"current driver instance."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:146
msgid "Supported transaction types"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:148
msgid ""
"The next thing you need is to set which transaction types your device (and "
"driver) supports."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:151
msgid ""
"Our ``dma_device structure`` has a field called cap_mask that holds the "
"various types of transaction supported, and you need to modify this mask "
"using the dma_cap_set function, with various flags depending on transaction "
"types you support as an argument."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:156
msgid ""
"All those capabilities are defined in the ``dma_transaction_type enum``, in "
"``include/linux/dmaengine.h``"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:159
msgid "Currently, the types available are:"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:161
msgid "DMA_MEMCPY"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:163
msgid "The device is able to do memory to memory copies"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:165
msgid ""
"No matter what the overall size of the combined chunks for source and "
"destination is, only as many bytes as the smallest of the two will be "
"transmitted. That means the number and size of the scatter-gather buffers in "
"both lists need not be the same, and that the operation functionally is "
"equivalent to a ``strncpy`` where the ``count`` argument equals the smallest "
"total size of the two scatter-gather list buffers."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:172
msgid ""
"It's usually used for copying pixel data between host memory and memory-"
"mapped GPU device memory, such as found on modern PCI video graphics cards. "
"The most immediate example is the OpenGL API function ``glReadPixels()``, "
"which might require a verbatim copy of a huge framebuffer from local device "
"memory onto host memory."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:178
msgid "DMA_XOR"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:180
msgid "The device is able to perform XOR operations on memory areas"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:182
msgid "Used to accelerate XOR intensive tasks, such as RAID5"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:184
msgid "DMA_XOR_VAL"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:186
msgid ""
"The device is able to perform parity check using the XOR algorithm against a "
"memory buffer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:189
msgid "DMA_PQ"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:191
msgid ""
"The device is able to perform RAID6 P+Q computations, P being a simple XOR, "
"and Q being a Reed-Solomon algorithm."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:194
msgid "DMA_PQ_VAL"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:196
msgid ""
"The device is able to perform parity check using RAID6 P+Q algorithm against "
"a memory buffer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:199
msgid "DMA_MEMSET"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:201
msgid "The device is able to fill memory with the provided pattern"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:203
msgid "The pattern is treated as a single byte signed value."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:205
msgid "DMA_INTERRUPT"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:207
msgid ""
"The device is able to trigger a dummy transfer that will generate periodic "
"interrupts"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:210
msgid ""
"Used by the client drivers to register a callback that will be called on a "
"regular basis through the DMA controller interrupt"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:213
msgid "DMA_PRIVATE"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:215
msgid ""
"The devices only supports slave transfers, and as such isn't available for "
"async transfers."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:218
msgid "DMA_ASYNC_TX"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:220
msgid ""
"The device supports asynchronous memory-to-memory operations, including "
"memcpy, memset, xor, pq, xor_val, and pq_val."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:223
msgid ""
"This capability is automatically set by the DMA engine framework and must "
"not be configured manually by device drivers."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:227
msgid "DMA_SLAVE"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:229
msgid ""
"The device can handle device to memory transfers, including scatter-gather "
"transfers."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:232
msgid ""
"While in the mem2mem case we were having two distinct types to deal with a "
"single chunk to copy or a collection of them, here, we just have a single "
"transaction type that is supposed to handle both."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:237
msgid ""
"If you want to transfer a single contiguous memory buffer, simply build a "
"scatter list with only one item."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:240
msgid "DMA_CYCLIC"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:242
msgid "The device can handle cyclic transfers."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:244
msgid ""
"A cyclic transfer is a transfer where the chunk collection will loop over "
"itself, with the last item pointing to the first."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:247
msgid ""
"It's usually used for audio transfers, where you want to operate on a single "
"ring buffer that you will fill with your audio data."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:250
msgid "DMA_INTERLEAVE"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:252
msgid "The device supports interleaved transfer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:254
msgid ""
"These transfers can transfer data from a non-contiguous buffer to a non-"
"contiguous buffer, opposed to DMA_SLAVE that can transfer data from a non-"
"contiguous data set to a continuous destination buffer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:259
msgid ""
"It's usually used for 2d content transfers, in which case you want to "
"transfer a portion of uncompressed data directly to the display to print it"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:263
msgid "DMA_COMPLETION_NO_ORDER"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:265
msgid "The device does not support in order completion."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:267
msgid ""
"The driver should return DMA_OUT_OF_ORDER for device_tx_status if the device "
"is setting this capability."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:270
msgid ""
"All cookie tracking and checking API should be treated as invalid if the "
"device exports this capability."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:273
msgid "At this point, this is incompatible with polling option for dmatest."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:275
msgid ""
"If this cap is set, the user is recommended to provide an unique identifier "
"for each descriptor sent to the DMA device in order to properly track the "
"completion."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:279
msgid "DMA_REPEAT"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:281
msgid ""
"The device supports repeated transfers. A repeated transfer, indicated by "
"the DMA_PREP_REPEAT transfer flag, is similar to a cyclic transfer in that "
"it gets automatically repeated when it ends, but can additionally be "
"replaced by the client."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:286
msgid ""
"This feature is limited to interleaved transfers, this flag should thus not "
"be set if the DMA_INTERLEAVE flag isn't set. This limitation is based on the "
"current needs of DMA clients, support for additional transfer types should "
"be added in the future if and when the need arises."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:291
msgid "DMA_LOAD_EOT"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:293
msgid ""
"The device supports replacing repeated transfers at end of transfer (EOT) by "
"queuing a new transfer with the DMA_PREP_LOAD_EOT flag set."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:296
msgid ""
"Support for replacing a currently running transfer at another point (such as "
"end of burst instead of end of transfer) will be added in the future based "
"on DMA clients needs, if and when the need arises."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:300
msgid ""
"These various types will also affect how the source and destination "
"addresses change over time."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:303
msgid ""
"Addresses pointing to RAM are typically incremented (or decremented) after "
"each transfer. In case of a ring buffer, they may loop (DMA_CYCLIC). "
"Addresses pointing to a device's register (e.g. a FIFO) are typically fixed."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:309
msgid "Per descriptor metadata support"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:310
msgid ""
"Some data movement architecture (DMA controller and peripherals) uses "
"metadata associated with a transaction. The DMA controller role is to "
"transfer the payload and the metadata alongside. The metadata itself is not "
"used by the DMA engine itself, but it contains parameters, keys, vectors, "
"etc for peripheral or from the peripheral."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:316
msgid ""
"The DMAengine framework provides a generic ways to facilitate the metadata "
"for descriptors. Depending on the architecture the DMA driver can implement "
"either or both of the methods and it is up to the client driver to choose "
"which one to use."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:321
msgid "DESC_METADATA_CLIENT"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:323
msgid ""
"The metadata buffer is allocated/provided by the client driver and it is "
"attached (via the dmaengine_desc_attach_metadata() helper to the descriptor."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:326
#: ../../../driver-api/dmaengine/provider.rst:348
msgid "From the DMA driver the following is expected for this mode:"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:328
msgid "DMA_MEM_TO_DEV / DEV_MEM_TO_MEM"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:330
msgid ""
"The data from the provided metadata buffer should be prepared for the DMA "
"controller to be sent alongside of the payload data. Either by copying to a "
"hardware descriptor, or highly coupled packet."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:334
msgid "DMA_DEV_TO_MEM"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:336
msgid ""
"On transfer completion the DMA driver must copy the metadata to the client "
"provided metadata buffer before notifying the client about the completion. "
"After the transfer completion, DMA drivers must not touch the metadata "
"buffer provided by the client."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:341
msgid "DESC_METADATA_ENGINE"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:343
msgid ""
"The metadata buffer is allocated/managed by the DMA driver. The client "
"driver can ask for the pointer, maximum size and the currently used size of "
"the metadata and can directly update or read it. "
"dmaengine_desc_get_metadata_ptr() and dmaengine_desc_set_metadata_len() is "
"provided as helper functions."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:350
msgid "get_metadata_ptr()"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:352
msgid ""
"Should return a pointer for the metadata buffer, the maximum size of the "
"metadata buffer and the currently used / valid (if any) bytes in the buffer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:355
msgid "set_metadata_len()"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:357
msgid ""
"It is called by the clients after it have placed the metadata to the buffer "
"to let the DMA driver know the number of valid bytes provided."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:360
msgid ""
"Note: since the client will ask for the metadata pointer in the completion "
"callback (in DMA_DEV_TO_MEM case) the DMA driver must ensure that the "
"descriptor is not freed up prior the callback is called."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:365
msgid "Device operations"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:367
msgid ""
"Our dma_device structure also requires a few function pointers in order to "
"implement the actual logic, now that we described what operations we were "
"able to perform."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:371
msgid ""
"The functions that we have to fill in there, and hence have to implement, "
"obviously depend on the transaction types you reported as supported."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:375
msgid "``device_alloc_chan_resources``"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:377
msgid "``device_free_chan_resources``"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:379
msgid ""
"These functions will be called whenever a driver will call "
"``dma_request_channel`` or ``dma_release_channel`` for the first/last time "
"on the channel associated to that driver."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:383
msgid ""
"They are in charge of allocating/freeing all the needed resources in order "
"for that channel to be useful for your driver."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:386
msgid "These functions can sleep."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:388
msgid "``device_prep_dma_*``"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:390
msgid ""
"These functions are matching the capabilities you registered previously."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:393
msgid ""
"These functions all take the buffer or the scatterlist relevant for the "
"transfer being prepared, and should create a hardware descriptor or a list "
"of hardware descriptors from it"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:397
msgid "These functions can be called from an interrupt context"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:399
msgid ""
"Any allocation you might do should be using the GFP_NOWAIT flag, in order "
"not to potentially sleep, but without depleting the emergency pool either."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:403
msgid ""
"Drivers should try to pre-allocate any memory they might need during the "
"transfer setup at probe time to avoid putting to much pressure on the nowait "
"allocator."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:407
msgid ""
"It should return a unique instance of the ``dma_async_tx_descriptor "
"structure``, that further represents this particular transfer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:411
msgid ""
"This structure can be initialized using the function "
"``dma_async_tx_descriptor_init``."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:414
msgid "You'll also need to set two fields in this structure:"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:416
msgid ""
"flags: TODO: Can it be modified by the driver itself, or should it be always "
"the flags passed in the arguments"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:420
msgid ""
"tx_submit: A pointer to a function you have to implement, that is supposed "
"to push the current transaction descriptor to a pending queue, waiting for "
"issue_pending to be called."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:424
msgid ""
"In this structure the function pointer callback_result can be initialized in "
"order for the submitter to be notified that a transaction has completed. In "
"the earlier code the function pointer callback has been used. However it "
"does not provide any status to the transaction and will be deprecated. The "
"result structure defined as ``dmaengine_result`` that is passed in to "
"callback_result has two fields:"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:432
msgid ""
"result: This provides the transfer result defined by "
"``dmaengine_tx_result``. Either success or some error condition."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:435
msgid ""
"residue: Provides the residue bytes of the transfer for those that support "
"residue."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:438
msgid "``device_prep_peripheral_dma_vec``"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:440
msgid ""
"Similar to ``device_prep_slave_sg``, but it takes a pointer to a array of "
"``dma_vec`` structures, which (in the long run) will replace scatterlists."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:444
msgid "``device_issue_pending``"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:446
msgid ""
"Takes the first transaction descriptor in the pending queue, and starts the "
"transfer. Whenever that transfer is done, it should move to the next "
"transaction in the list."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:450
msgid "This function can be called in an interrupt context"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:452
msgid "``device_tx_status``"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:454
msgid "Should report the bytes left to go over on the given channel"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:456
msgid ""
"Should only care about the transaction descriptor passed as argument, not "
"the currently active one on a given channel"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:459
msgid "The tx_state argument might be NULL"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:461
msgid "Should use dma_set_residue to report it"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:463
msgid ""
"In the case of a cyclic transfer, it should only take into account the total "
"size of the cyclic buffer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:466
msgid ""
"Should return DMA_OUT_OF_ORDER if the device does not support in order "
"completion and is completing the operation out of order."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:469
msgid "This function can be called in an interrupt context."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:471
msgid "device_config"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:473
msgid "Reconfigures the channel with the configuration given as argument"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:475
msgid ""
"This command should NOT perform synchronously, or on any currently queued "
"transfers, but only on subsequent ones"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:478
msgid ""
"In this case, the function will receive a ``dma_slave_config`` structure "
"pointer as an argument, that will detail which configuration to use."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:482
msgid ""
"Even though that structure contains a direction field, this field is "
"deprecated in favor of the direction argument given to the prep_* functions"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:486
msgid ""
"This call is mandatory for slave operations only. This should NOT be set or "
"expected to be set for memcpy operations. If a driver support both, it "
"should use this call for slave operations only and not for memcpy ones."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:491
msgid "device_pause"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:493
msgid "Pauses a transfer on the channel"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:495
msgid ""
"This command should operate synchronously on the channel, pausing right away "
"the work of the given channel"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:498
msgid "device_resume"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:500
msgid "Resumes a transfer on the channel"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:502
msgid ""
"This command should operate synchronously on the channel, resuming right "
"away the work of the given channel"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:505
msgid "device_terminate_all"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:507
msgid "Aborts all the pending and ongoing transfers on the channel"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:509
msgid "For aborted transfers the complete callback should not be called"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:511
msgid ""
"Can be called from atomic context or from within a complete callback of a "
"descriptor. Must not sleep. Drivers must be able to handle this correctly."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:515
msgid ""
"Termination may be asynchronous. The driver does not have to wait until the "
"currently active transfer has completely stopped. See device_synchronize."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:519
msgid "device_synchronize"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:521
msgid "Must synchronize the termination of a channel to the current context."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:524
msgid ""
"Must make sure that memory for previously submitted descriptors is no longer "
"accessed by the DMA controller."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:527
msgid ""
"Must make sure that all complete callbacks for previously submitted "
"descriptors have finished running and none are scheduled to run."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:531
msgid "May sleep."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:535
msgid "Misc notes"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:537
msgid ""
"(stuff that should be documented, but don't really know where to put them)"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:540
msgid "``dma_run_dependencies``"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:542
msgid ""
"Should be called at the end of an async TX transfer, and can be ignored in "
"the slave transfers case."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:545
msgid ""
"Makes sure that dependent operations are run before marking it as complete."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:548
msgid "dma_cookie_t"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:550
msgid "it's a DMA transaction ID that will increment over time."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:552
msgid ""
"Not really relevant any more since the introduction of ``virt-dma`` that "
"abstracts it away."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:555
msgid "dma_vec"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:557
msgid "A small structure that contains a DMA address and length."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:559
msgid "DMA_CTRL_ACK"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:561
msgid ""
"If clear, the descriptor cannot be reused by provider until the client "
"acknowledges receipt, i.e. has a chance to establish any dependency chains"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:565
msgid "This can be acked by invoking async_tx_ack()"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:567
msgid "If set, does not mean descriptor can be reused"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:569
msgid "DMA_CTRL_REUSE"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:571
msgid ""
"If set, the descriptor can be reused after being completed. It should not be "
"freed by provider if this flag is set."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:574
msgid ""
"The descriptor should be prepared for reuse by invoking "
"``dmaengine_desc_set_reuse()`` which will set DMA_CTRL_REUSE."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:577
msgid ""
"``dmaengine_desc_set_reuse()`` will succeed only when channel support "
"reusable descriptor as exhibited by capabilities"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:580
msgid ""
"As a consequence, if a device driver wants to skip the ``dma_map_sg()`` and "
"``dma_unmap_sg()`` in between 2 transfers, because the DMA'd data wasn't "
"used, it can resubmit the transfer right after its completion."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:585
msgid "Descriptor can be freed in few ways"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:587
msgid ""
"Clearing DMA_CTRL_REUSE by invoking ``dmaengine_desc_clear_reuse()`` and "
"submitting for last txn"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:590
msgid ""
"Explicitly invoking ``dmaengine_desc_free()``, this can succeed only when "
"DMA_CTRL_REUSE is already set"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:593
msgid "Terminating the channel"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:595
msgid "DMA_PREP_CMD"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:597
msgid ""
"If set, the client driver tells DMA controller that passed data in DMA API "
"is command data."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:600
msgid ""
"Interpretation of command data is DMA controller specific. It can be used "
"for issuing commands to other peripherals/register reads/register writes for "
"which the descriptor should be in different format from normal data "
"descriptors."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:605
msgid "DMA_PREP_REPEAT"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:607
msgid ""
"If set, the transfer will be automatically repeated when it ends until a new "
"transfer is queued on the same channel with the DMA_PREP_LOAD_EOT flag. If "
"the next transfer to be queued on the channel does not have the "
"DMA_PREP_LOAD_EOT flag set, the current transfer will be repeated until the "
"client terminates all transfers."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:613
msgid ""
"This flag is only supported if the channel reports the DMA_REPEAT capability."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:616
msgid "DMA_PREP_LOAD_EOT"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:618
msgid ""
"If set, the transfer will replace the transfer currently being executed at "
"the end of the transfer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:621
msgid ""
"This is the default behaviour for non-repeated transfers, specifying "
"DMA_PREP_LOAD_EOT for non-repeated transfers will thus make no difference."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:624
msgid ""
"When using repeated transfers, DMA clients will usually need to set the "
"DMA_PREP_LOAD_EOT flag on all transfers, otherwise the channel will keep "
"repeating the last repeated transfer and ignore the new transfers being "
"queued. Failure to set DMA_PREP_LOAD_EOT will appear as if the channel was "
"stuck on the previous transfer."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:630
msgid ""
"This flag is only supported if the channel reports the DMA_LOAD_EOT "
"capability."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:634
msgid "General Design Notes"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:636
msgid ""
"Most of the DMAEngine drivers you'll see are based on a similar design that "
"handles the end of transfer interrupts in the handler, but defer most work "
"to a tasklet, including the start of a new transfer whenever the previous "
"transfer ended."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:641
msgid ""
"This is a rather inefficient design though, because the inter-transfer "
"latency will be not only the interrupt latency, but also the scheduling "
"latency of the tasklet, which will leave the channel idle in between, which "
"will slow down the global transfer rate."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:646
msgid ""
"You should avoid this kind of practice, and instead of electing a new "
"transfer in your tasklet, move that part to the interrupt handler in order "
"to have a shorter idle window (that we can't really avoid anyway)."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:652
msgid "Glossary"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:654
msgid ""
"Burst: A number of consecutive read or write operations that can be queued "
"to buffers before being flushed to memory."
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:657
msgid "Chunk: A contiguous collection of bursts"
msgstr ""

#: ../../../driver-api/dmaengine/provider.rst:659
msgid "Transfer: A collection of chunks (be it contiguous or not)"
msgstr ""
