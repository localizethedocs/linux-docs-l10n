# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/dmaengine/client.rst:3
msgid "DMA Engine API Guide"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:5
msgid "Vinod Koul <vinod dot koul at intel.com>"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:7
msgid ""
"For DMA Engine usage in async_tx please see: ``Documentation/crypto/async-tx-"
"api.rst``"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:11
msgid ""
"Below is a guide to device driver writers on how to use the Slave-DMA API of "
"the DMA Engine. This is applicable only for slave DMA usage only."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:15
msgid "DMA usage"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:17
msgid "The slave DMA usage consists of following steps:"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:19
#: ../../../driver-api/dmaengine/client.rst:31
msgid "Allocate a DMA slave channel"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:21
#: ../../../driver-api/dmaengine/client.rst:51
msgid "Set slave and controller specific parameters"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:23
#: ../../../driver-api/dmaengine/client.rst:76
msgid "Get a descriptor for transaction"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:25
#: ../../../driver-api/dmaengine/client.rst:260
msgid "Submit the transaction"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:27
msgid "Issue pending requests and wait for callback notification"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:29
msgid "The details of these operations are:"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:33
msgid ""
"Channel allocation is slightly different in the slave DMA context, client "
"drivers typically need a channel from a particular DMA controller only and "
"even in some cases a specific channel is desired. To request a channel "
"dma_request_chan() API is used."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:38
#: ../../../driver-api/dmaengine/client.rst:64
#: ../../../driver-api/dmaengine/client.rst:100
#: ../../../driver-api/dmaengine/client.rst:265
#: ../../../driver-api/dmaengine/client.rst:294
msgid "Interface:"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:44
msgid ""
"Which will find and return the ``name`` DMA channel associated with the "
"'dev' device. The association is done via DT, ACPI or board file based "
"dma_slave_map matching table."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:48
msgid ""
"A channel allocated via this interface is exclusive to the caller, until "
"dma_release_channel() is called."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:53
msgid ""
"Next step is always to pass some specific information to the DMA driver. "
"Most of the generic information which a slave DMA can use is in struct "
"dma_slave_config. This allows the clients to specify DMA direction, DMA "
"addresses, bus widths, DMA burst lengths etc for the peripheral."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:59
msgid ""
"If some DMA controllers have more parameters to be sent then they should try "
"to embed struct dma_slave_config in their controller specific structure. "
"That gives flexibility to client to pass more parameters, if required."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:71
msgid ""
"Please see the dma_slave_config structure definition in dmaengine.h for a "
"detailed explanation of the struct members. Please note that the 'direction' "
"member will be going away as it duplicates the direction given in the "
"prepare call."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:78
msgid ""
"For slave usage the various modes of slave transfers supported by the DMA-"
"engine are:"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:81
msgid "slave_sg: DMA a list of scatter gather buffers from/to a peripheral"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:83
msgid ""
"peripheral_dma_vec: DMA an array of scatter gather buffers from/to a "
"peripheral. Similar to slave_sg, but uses an array of dma_vec structures "
"instead of a scatterlist."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:87
msgid ""
"dma_cyclic: Perform a cyclic DMA operation from/to a peripheral till the "
"operation is explicitly stopped."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:90
msgid ""
"interleaved_dma: This is common to Slave as well as M2M clients. For slave "
"address of devices' fifo could be already known to the driver. Various types "
"of operations could be expressed by setting appropriate values to the "
"'dma_interleaved_template' members. Cyclic interleaved DMA transfers are "
"also possible if supported by the channel by setting the DMA_PREP_REPEAT "
"transfer flag."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:97
msgid ""
"A non-NULL return of this transfer API represents a \"descriptor\" for the "
"given transaction."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:122
msgid ""
"The peripheral driver is expected to have mapped the scatterlist for the DMA "
"operation prior to calling dmaengine_prep_slave_sg(), and must keep the "
"scatterlist mapped until the DMA operation has completed. The scatterlist "
"must be mapped using the DMA struct device. If a mapping needs to be "
"synchronized later, dma_sync_*_for_*() must be called using the DMA struct "
"device, too. So, normal setup should look like this:"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:140
msgid ""
"Once a descriptor has been obtained, the callback information can be added "
"and the descriptor must then be submitted. Some DMA engine drivers may hold "
"a spinlock between a successful preparation and submission so it is "
"important that these two operations are closely paired."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:148
msgid ""
"Although the async_tx API specifies that completion callback routines cannot "
"submit any new operations, this is not the case for slave/cyclic DMA."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:152
msgid ""
"For slave DMA, the subsequent transaction may not be available for "
"submission prior to callback function being invoked, so slave DMA callbacks "
"are permitted to prepare and submit a new transaction."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:157
msgid ""
"For cyclic DMA, a callback function may wish to terminate the DMA via "
"dmaengine_terminate_async()."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:160
msgid ""
"Therefore, it is important that DMA engine drivers drop any locks before "
"calling the callback function which may cause a deadlock."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:164
msgid ""
"Note that callbacks will always be invoked from the DMA engines tasklet, "
"never from interrupt context."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:167
msgid "**Optional: per descriptor metadata**"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:169
msgid "DMAengine provides two ways for metadata support."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:171
#: ../../../driver-api/dmaengine/client.rst:212
msgid "DESC_METADATA_CLIENT"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:173
msgid ""
"The metadata buffer is allocated/provided by the client driver and it is "
"attached to the descriptor."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:181
#: ../../../driver-api/dmaengine/client.rst:231
msgid "DESC_METADATA_ENGINE"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:183
msgid ""
"The metadata buffer is allocated/managed by the DMA driver. The client "
"driver can ask for the pointer, maximum size and the currently used size of "
"the metadata and can directly update or read it."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:187
msgid ""
"Because the DMA driver manages the memory area containing the metadata, "
"clients must make sure that they do not try to access or get the pointer "
"after their transfer completion callback has run for the descriptor. If no "
"completion callback has been defined for the transfer, then the metadata "
"must not be accessed after issue_pending. In other words: if the aim is to "
"read back metadata after the transfer is completed, then the client must use "
"completion callback."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:203
msgid "Client drivers can query if a given mode is supported with:"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:210
msgid "Depending on the used mode client drivers must follow different flow."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:214
#: ../../../driver-api/dmaengine/client.rst:233
msgid "DMA_MEM_TO_DEV / DEV_MEM_TO_MEM:"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:216
msgid ""
"prepare the descriptor (dmaengine_prep_*) construct the metadata in the "
"client's buffer"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:218
#: ../../../driver-api/dmaengine/client.rst:225
msgid ""
"use dmaengine_desc_attach_metadata() to attach the buffer to the descriptor"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:220
#: ../../../driver-api/dmaengine/client.rst:227
#: ../../../driver-api/dmaengine/client.rst:241
#: ../../../driver-api/dmaengine/client.rst:246
msgid "submit the transfer"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:222
#: ../../../driver-api/dmaengine/client.rst:243
msgid "DMA_DEV_TO_MEM:"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:224
#: ../../../driver-api/dmaengine/client.rst:235
#: ../../../driver-api/dmaengine/client.rst:245
msgid "prepare the descriptor (dmaengine_prep_*)"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:228
msgid ""
"when the transfer is completed, the metadata should be available in the "
"attached buffer"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:236
msgid ""
"use dmaengine_desc_get_metadata_ptr() to get the pointer to the engine's "
"metadata area"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:238
msgid "update the metadata at the pointer"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:239
msgid ""
"use dmaengine_desc_set_metadata_len()  to tell the DMA engine the amount of "
"data the client has placed into the metadata buffer"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:247
msgid ""
"on transfer completion, use dmaengine_desc_get_metadata_ptr() to get the "
"pointer to the engine's metadata area"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:249
msgid "read out the metadata from the pointer"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:253
msgid ""
"When DESC_METADATA_ENGINE mode is used the metadata area for the descriptor "
"is no longer valid after the transfer has been completed (valid up to the "
"point when the completion callback returns if used)."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:257
msgid ""
"Mixed use of DESC_METADATA_CLIENT / DESC_METADATA_ENGINE is not allowed, "
"client drivers must use either of the modes per descriptor."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:262
msgid ""
"Once the descriptor has been prepared and the callback information added, it "
"must be placed on the DMA engine drivers pending queue."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:271
msgid ""
"This returns a cookie can be used to check the progress of DMA engine "
"activity via other DMA engine calls not covered in this document."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:274
msgid ""
"dmaengine_submit() will not start the DMA operation, it merely adds it to "
"the pending queue. For this, see step 5, dma_async_issue_pending."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:279
msgid ""
"After calling ``dmaengine_submit()`` the submitted transfer descriptor "
"(``struct dma_async_tx_descriptor``) belongs to the DMA engine. "
"Consequently, the client must consider invalid the pointer to that "
"descriptor."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:284
msgid "Issue pending DMA requests and wait for callback notification"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:286
msgid ""
"The transactions in the pending queue can be activated by calling the "
"issue_pending API. If channel is idle then the first transaction in queue is "
"started and subsequent ones queued up."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:290
msgid ""
"On completion of each DMA operation, the next in queue is started and a "
"tasklet triggered. The tasklet will then call the client driver completion "
"callback routine for notification, if set."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:301
msgid "Further APIs"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:303
msgid "Terminate APIs"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:311
msgid ""
"This causes all activity for the DMA channel to be stopped, and may discard "
"data in the DMA FIFO which hasn't been fully transferred. No callback "
"functions will be called for any incomplete transfers."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:315
msgid "Two variants of this function are available."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:317
msgid ""
"dmaengine_terminate_async() might not wait until the DMA has been fully "
"stopped or until any running complete callbacks have finished. But it is "
"possible to call dmaengine_terminate_async() from atomic context or from "
"within a complete callback. dmaengine_synchronize() must be called before it "
"is safe to free the memory accessed by the DMA transfer or free resources "
"accessed from within the complete callback."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:324
msgid ""
"dmaengine_terminate_sync() will wait for the transfer and any running "
"complete callbacks to finish before it returns. But the function must not be "
"called from atomic context or from within a complete callback."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:328
msgid ""
"dmaengine_terminate_all() is deprecated and should not be used in new code."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:330
msgid "Pause API"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:336
msgid "This pauses activity on the DMA channel without data loss."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:338
msgid "Resume API"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:344
msgid ""
"Resume a previously paused DMA channel. It is invalid to resume a channel "
"which is not currently paused."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:347
msgid "Check Txn complete"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:354
msgid ""
"This can be used to check the status of the channel. Please see the "
"documentation in include/linux/dmaengine.h for a more complete description "
"of this API."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:358
msgid ""
"This can be used in conjunction with dma_async_is_complete() and the cookie "
"returned from dmaengine_submit() to check for completion of a specific DMA "
"transaction."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:364
msgid ""
"Not all DMA engine drivers can return reliable information for a running DMA "
"channel. It is recommended that DMA engine users pause or stop (via "
"dmaengine_terminate_all()) the channel before using this API."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:369
msgid "Synchronize termination API"
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:375
msgid "Synchronize the termination of the DMA channel to the current context."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:377
msgid ""
"This function should be used after dmaengine_terminate_async() to "
"synchronize the termination of the DMA channel to the current context. The "
"function will wait for the transfer and any running complete callbacks to "
"finish before it returns."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:382
msgid ""
"If dmaengine_terminate_async() is used to stop the DMA channel this function "
"must be called before it is safe to free memory accessed by previously "
"submitted descriptors or to free any resources accessed within the complete "
"callback of previously submitted descriptors."
msgstr ""

#: ../../../driver-api/dmaengine/client.rst:387
msgid ""
"The behavior of this function is undefined if dma_async_issue_pending() has "
"been called between dmaengine_terminate_async() and this function."
msgstr ""
