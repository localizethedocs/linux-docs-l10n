# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/driver-model/driver.rst:3
msgid "Device Drivers"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:5
msgid "See the kerneldoc for the struct device_driver."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:8
msgid "Allocation"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:10
msgid ""
"Device drivers are statically allocated structures. Though there may be "
"multiple devices in a system that a driver supports, struct device_driver "
"represents the driver as a whole (not a particular device instance)."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:16
msgid "Initialization"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:18
msgid ""
"The driver must initialize at least the name and bus fields. It should also "
"initialize the devclass field (when it arrives), so it may obtain the proper "
"linkage internally. It should also initialize as many of the callbacks as "
"possible, though each is optional."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:24
msgid "Declaration"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:26
msgid ""
"As stated above, struct device_driver objects are statically allocated. "
"Below is an example declaration of the eepro100 driver. This declaration is "
"hypothetical only; it relies on the driver being converted completely to the "
"new model::"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:41
msgid ""
"Most drivers will not be able to be converted completely to the new model "
"because the bus they belong to has a bus-specific structure with bus-"
"specific fields that cannot be generalized."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:45
msgid ""
"The most common example of this are device ID structures. A driver typically "
"defines an array of device IDs that it supports. The format of these "
"structures and the semantics for comparing device IDs are completely bus-"
"specific. Defining them as bus-specific entities would sacrifice type-"
"safety, so we keep bus-specific structures around."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:51
msgid ""
"Bus-specific drivers should include a generic struct device_driver in the "
"definition of the bus-specific driver. Like this::"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:59
msgid ""
"A definition that included bus-specific fields would look like (using the "
"eepro100 driver again)::"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:74
msgid ""
"Some may find the syntax of embedded struct initialization awkward or even a "
"bit ugly. So far, it's the best way we've found to do what we want..."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:78
msgid "Registration"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:84
msgid ""
"The driver registers the structure on startup. For drivers that have no bus-"
"specific fields (i.e. don't have a bus-specific driver structure), they "
"would use driver_register and pass a pointer to their struct device_driver "
"object."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:89
msgid ""
"Most drivers, however, will have a bus-specific structure and will need to "
"register with the bus using something like pci_driver_register."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:92
msgid ""
"It is important that drivers register their driver structure as early as "
"possible. Registration with the core initializes several fields in the "
"struct device_driver object, including the reference count and the lock. "
"These fields are assumed to be valid at all times and may be used by the "
"device model core or the bus driver."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:100
msgid "Transition Bus Drivers"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:102
msgid ""
"By defining wrapper functions, the transition to the new model can be made "
"easier. Drivers can ignore the generic structure altogether and let the bus "
"wrapper fill in the fields. For the callbacks, the bus can define generic "
"callbacks that forward the call to the bus-specific callbacks of the drivers."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:108
msgid ""
"This solution is intended to be only temporary. In order to get class "
"information in the driver, the drivers must be modified anyway. Since "
"converting drivers to the new model should reduce some infrastructural "
"complexity and code size, it is recommended that they are converted as class "
"information is added."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:115
msgid "Access"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:117
msgid ""
"Once the object has been registered, it may access the common fields of the "
"object, like the lock and the list of devices::"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:123
msgid ""
"The devices field is a list of all the devices that have been bound to the "
"driver. The LDM core provides a helper function to operate on all the "
"devices a driver controls. This helper locks the driver on each node access, "
"and does proper reference counting on each device as it accesses it."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:131
msgid "sysfs"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:133
msgid ""
"When a driver is registered, a sysfs directory is created in its bus's "
"directory. In this directory, the driver can export an interface to "
"userspace to control operation of the driver on a global basis; e.g. "
"toggling debugging output in the driver."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:138
msgid ""
"A future feature of this directory will be a 'devices' directory. This "
"directory will contain symlinks to the directories of devices it supports."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:145
msgid "Callbacks"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:151
msgid ""
"The probe() entry is called in task context, with the bus's rwsem locked and "
"the driver partially bound to the device.  Drivers commonly use "
"container_of() to convert \"dev\" to a bus-specific type, both in probe() "
"and other routines.  That type often provides device resource data, such as "
"pci_dev.resource[] or platform_device.resources, which is used in addition "
"to dev->platform_data to initialize the driver."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:158
msgid ""
"This callback holds the driver-specific logic to bind the driver to a given "
"device.  That includes verifying that the device is present, that it's a "
"version the driver can handle, that driver data structures can be allocated "
"and initialized, and that any hardware can be initialized. Drivers often "
"store a pointer to their state with dev_set_drvdata(). When the driver has "
"successfully bound itself to that device, then probe() returns zero and the "
"driver model code will finish its part of binding the driver to that device."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:167
msgid ""
"A driver's probe() may return a negative errno value to indicate that the "
"driver did not bind to this device, in which case it should have released "
"all resources it allocated."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:171
msgid ""
"Optionally, probe() may return -EPROBE_DEFER if the driver depends on "
"resources that are not yet available (e.g., supplied by a driver that hasn't "
"initialized yet).  The driver core will put the device onto the deferred "
"probe list and will try to call it again later. If a driver must defer, it "
"should return -EPROBE_DEFER as early as possible to reduce the amount of "
"time spent on setup work that will need to be unwound and reexecuted at a "
"later time."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:180
msgid ""
"-EPROBE_DEFER must not be returned if probe() has already created child "
"devices, even if those child devices are removed again in a cleanup path. If "
"-EPROBE_DEFER is returned after a child device has been registered, it may "
"result in an infinite loop of .probe() calls to the same driver."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:190
msgid ""
"sync_state is called only once for a device. It's called when all the "
"consumer devices of the device have successfully probed. The list of "
"consumers of the device is obtained by looking at the device links "
"connecting that device to its consumer devices."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:195
msgid ""
"The first attempt to call sync_state() is made during late_initcall_sync() "
"to give firmware and drivers time to link devices to each other. During the "
"first attempt at calling sync_state(), if all the consumers of the device at "
"that point in time have already probed successfully, sync_state() is called "
"right away. If there are no consumers of the device during the first "
"attempt, that too is considered as \"all consumers of the device have "
"probed\" and sync_state() is called right away."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:203
msgid ""
"If during the first attempt at calling sync_state() for a device, there are "
"still consumers that haven't probed successfully, the sync_state() call is "
"postponed and reattempted in the future only when one or more consumers of "
"the device probe successfully. If during the reattempt, the driver core "
"finds that there are one or more consumers of the device that haven't probed "
"yet, then sync_state() call is postponed again."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:210
msgid ""
"A typical use case for sync_state() is to have the kernel cleanly take over "
"management of devices from the bootloader. For example, if a device is left "
"on and at a particular hardware configuration by the bootloader, the "
"device's driver might need to keep the device in the boot configuration "
"until all the consumers of the device have probed. Once all the consumers of "
"the device have probed, the device's driver can synchronize the hardware "
"state of the device to match the aggregated software state requested by all "
"the consumers. Hence the name sync_state()."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:219
msgid ""
"While obvious examples of resources that can benefit from sync_state() "
"include resources such as regulator, sync_state() can also be useful for "
"complex resources like IOMMUs. For example, IOMMUs with multiple consumers "
"(devices whose addresses are remapped by the IOMMU) might need to keep their "
"mappings fixed at (or additive to) the boot configuration until all its "
"consumers have probed."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:226
msgid ""
"While the typical use case for sync_state() is to have the kernel cleanly "
"take over management of devices from the bootloader, the usage of "
"sync_state() is not restricted to that. Use it whenever it makes sense to "
"take an action after all the consumers of a device have probed::"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:233
msgid ""
"remove is called to unbind a driver from a device. This may be called if a "
"device is physically removed from the system, if the driver module is being "
"unloaded, during a reboot sequence, or in other cases."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:238
msgid ""
"It is up to the driver to determine if the device is present or not. It "
"should free any resources allocated specifically for the device; i.e. "
"anything in the device's driver_data field."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:242
msgid ""
"If the device is still present, it should quiesce the device and place it "
"into a supported low-power state."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:249
msgid "suspend is called to put the device in a low power state."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:255
msgid "Resume is used to bring a device back from a low power state."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:259
msgid "Attributes"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:269
msgid ""
"Device drivers can export attributes via their sysfs directories. Drivers "
"can declare attributes using a DRIVER_ATTR_RW and DRIVER_ATTR_RO macro that "
"works identically to the DEVICE_ATTR_RW and DEVICE_ATTR_RO macros."
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:274
msgid "Example::"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:278
msgid "This is equivalent to declaring::"
msgstr ""

#: ../../../driver-api/driver-model/driver.rst:282
msgid ""
"This can then be used to add and remove the attribute from the driver's "
"directory using::"
msgstr ""
