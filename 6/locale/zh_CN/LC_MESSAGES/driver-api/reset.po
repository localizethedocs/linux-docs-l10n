# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-11 08:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/reset.rst:5
msgid "Reset controller API"
msgstr ""

#: ../../../driver-api/reset.rst:8
msgid "Introduction"
msgstr ""

#: ../../../driver-api/reset.rst:10
msgid ""
"Reset controllers are central units that control the reset signals to "
"multiple peripherals. The reset controller API is split into two parts: the "
"`consumer driver interface <#consumer-driver-interface>`__ (`API reference "
"<#reset-consumer-api>`__), which allows peripheral drivers to request "
"control over their reset input signals, and the `reset controller driver "
"interface <#reset-controller-driver-interface>`__ (`API reference <#reset-"
"controller-driver-api>`__), which is used by drivers for reset controller "
"devices to register their reset controls to provide them to the consumers."
msgstr ""

#: ../../../driver-api/reset.rst:21
msgid ""
"While some reset controller hardware units also implement system restart "
"functionality, restart handlers are out of scope for the reset controller "
"API."
msgstr ""

#: ../../../driver-api/reset.rst:25
msgid "Glossary"
msgstr ""

#: ../../../driver-api/reset.rst:27
msgid "The reset controller API uses these terms with a specific meaning:"
msgstr ""

#: ../../../driver-api/reset.rst:29
msgid "Reset line"
msgstr ""

#: ../../../driver-api/reset.rst:31
msgid ""
"Physical reset line carrying a reset signal from a reset controller hardware "
"unit to a peripheral module."
msgstr ""

#: ../../../driver-api/reset.rst:34
msgid "Reset control"
msgstr ""

#: ../../../driver-api/reset.rst:36
msgid ""
"Control method that determines the state of one or multiple reset lines. "
"Most commonly this is a single bit in reset controller register space that "
"either allows direct control over the physical state of the reset line, or "
"is self-clearing and can be used to trigger a predetermined pulse on the "
"reset line. In more complicated reset controls, a single trigger action can "
"launch a carefully timed sequence of pulses on multiple reset lines."
msgstr ""

#: ../../../driver-api/reset.rst:44
msgid "Reset controller"
msgstr ""

#: ../../../driver-api/reset.rst:46
msgid ""
"A hardware module that provides a number of reset controls to control a "
"number of reset lines."
msgstr ""

#: ../../../driver-api/reset.rst:49
msgid "Reset consumer"
msgstr ""

#: ../../../driver-api/reset.rst:51
msgid ""
"Peripheral module or external IC that is put into reset by the signal on a "
"reset line."
msgstr ""

#: ../../../driver-api/reset.rst:55
msgid "Consumer driver interface"
msgstr ""

#: ../../../driver-api/reset.rst:57
msgid ""
"This interface provides an API that is similar to the kernel clock "
"framework. Consumer drivers use get and put operations to acquire and "
"release reset controls. Functions are provided to assert and deassert the "
"controlled reset lines, trigger reset pulses, or to query reset line status."
msgstr ""

#: ../../../driver-api/reset.rst:63
msgid ""
"When requesting reset controls, consumers can use symbolic names for their "
"reset inputs, which are mapped to an actual reset control on an existing "
"reset controller device by the core."
msgstr ""

#: ../../../driver-api/reset.rst:67
msgid ""
"A stub version of this API is provided when the reset controller framework "
"is not in use in order to minimize the need to use ifdefs."
msgstr ""

#: ../../../driver-api/reset.rst:71
msgid "Shared and exclusive resets"
msgstr ""

#: ../../../driver-api/reset.rst:73
msgid ""
"The reset controller API provides either reference counted deassertion and "
"assertion or direct, exclusive control. The distinction between shared and "
"exclusive reset controls is made at the time the reset control is requested, "
"either via devm_reset_control_get_shared() or via "
"devm_reset_control_get_exclusive(). This choice determines the behavior of "
"the API calls made with the reset control."
msgstr ""

#: ../../../driver-api/reset.rst:81
msgid ""
"Shared resets behave similarly to clocks in the kernel clock framework. They "
"provide reference counted deassertion, where only the first deassert, which "
"increments the deassertion reference count to one, and the last assert which "
"decrements the deassertion reference count back to zero, have a physical "
"effect on the reset line."
msgstr ""

#: ../../../driver-api/reset.rst:87
msgid ""
"Exclusive resets on the other hand guarantee direct control. That is, an "
"assert causes the reset line to be asserted immediately, and a deassert "
"causes the reset line to be deasserted immediately."
msgstr ""

#: ../../../driver-api/reset.rst:92
msgid "Assertion and deassertion"
msgstr ""

#: ../../../driver-api/reset.rst:94
msgid ""
"Consumer drivers use the reset_control_assert() and reset_control_deassert() "
"functions to assert and deassert reset lines. For shared reset controls, "
"calls to the two functions must be balanced."
msgstr ""

#: ../../../driver-api/reset.rst:98
msgid ""
"Note that since multiple consumers may be using a shared reset control, "
"there is no guarantee that calling reset_control_assert() on a shared reset "
"control will actually cause the reset line to be asserted. Consumer drivers "
"using shared reset controls should assume that the reset line may be kept "
"deasserted at all times. The API only guarantees that the reset line can not "
"be asserted as long as any consumer has requested it to be deasserted."
msgstr ""

#: ../../../driver-api/reset.rst:107
msgid "Triggering"
msgstr ""

#: ../../../driver-api/reset.rst:109
msgid ""
"Consumer drivers use reset_control_reset() to trigger a reset pulse on a "
"self-deasserting reset control. In general, these resets can not be shared "
"between multiple consumers, since requesting a pulse from any consumer "
"driver will reset all connected peripherals."
msgstr ""

#: ../../../driver-api/reset.rst:115
msgid ""
"The reset controller API allows requesting self-deasserting reset controls "
"as shared, but for those only the first trigger request causes an actual "
"pulse to be issued on the reset line. All further calls to this function "
"have no effect until all consumers have called reset_control_rearm(). For "
"shared reset controls, calls to the two functions must be balanced. This "
"allows devices that only require an initial reset at any point before the "
"driver is probed or resumed to share a pulsed reset line."
msgstr ""

#: ../../../driver-api/reset.rst:125
msgid "Querying"
msgstr ""

#: ../../../driver-api/reset.rst:127
msgid ""
"Only some reset controllers support querying the current status of a reset "
"line, via reset_control_status(). If supported, this function returns a "
"positive non-zero value if the given reset line is asserted. The "
"reset_control_status() function does not accept a `reset control array "
"<#reset-control-arrays>`__ handle as its input parameter."
msgstr ""

#: ../../../driver-api/reset.rst:135
msgid "Optional resets"
msgstr ""

#: ../../../driver-api/reset.rst:137
msgid ""
"Often peripherals require a reset line on some platforms but not on others. "
"For this, reset controls can be requested as optional using "
"devm_reset_control_get_optional_exclusive() or "
"devm_reset_control_get_optional_shared(). These functions return a NULL "
"pointer instead of an error when the requested reset control is not "
"specified in the device tree. Passing a NULL pointer to the reset_control "
"functions causes them to return quietly without an error."
msgstr ""

#: ../../../driver-api/reset.rst:147
msgid "Reset control arrays"
msgstr ""

#: ../../../driver-api/reset.rst:149
msgid ""
"Some drivers need to assert a bunch of reset lines in no particular order. "
"devm_reset_control_array_get() returns an opaque reset control handle that "
"can be used to assert, deassert, or trigger all specified reset controls at "
"once. The reset control API does not guarantee the order in which the "
"individual controls therein are handled."
msgstr ""

#: ../../../driver-api/reset.rst:156
msgid "Reset controller driver interface"
msgstr ""

#: ../../../driver-api/reset.rst:158
msgid ""
"Drivers for reset controller modules provide the functionality necessary to "
"assert or deassert reset signals, to trigger a reset pulse on a reset line, "
"or to query its current state. All functions are optional."
msgstr ""

#: ../../../driver-api/reset.rst:164
msgid "Initialization"
msgstr ""

#: ../../../driver-api/reset.rst:166
msgid ""
"Drivers fill a struct :c:type:`reset_controller_dev` and register it with "
"reset_controller_register() in their probe function. The actual "
"functionality is implemented in callback functions via a struct :c:type:"
"`reset_control_ops`."
msgstr ""

#: ../../../driver-api/reset.rst:172
msgid "API reference"
msgstr ""

#: ../../../driver-api/reset.rst:174
msgid ""
"The reset controller API is documented here in two parts: the `reset "
"consumer API <#reset-consumer-api>`__ and the `reset controller driver API "
"<#reset-controller-driver-api>`__."
msgstr ""

#: ../../../driver-api/reset.rst:179
msgid "Reset consumer API"
msgstr ""

#: ../../../driver-api/reset.rst:181
msgid ""
"Reset consumers can control a reset line using an opaque reset control "
"handle, which can be obtained from devm_reset_control_get_exclusive() or "
"devm_reset_control_get_shared(). Given the reset control, consumers can call "
"reset_control_assert() and reset_control_deassert(), trigger a reset pulse "
"using reset_control_reset(), or query the reset line status using "
"reset_control_status()."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:14
msgid "Data used for bulk reset control operations."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:18
#: ../../../driver-api/reset:213: include/linux/reset-controller.h:14
#: include/linux/reset-controller.h:34 include/linux/reset-controller.h:59
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:25
#: ../../../driver-api/reset:213: include/linux/reset-controller.h:23
#: include/linux/reset-controller.h:44 include/linux/reset-controller.h:74
msgid "**Members**"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:16
msgid "``id``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:17
msgid "reset control consumer ID"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:17
msgid "``rstc``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:18
msgid "struct reset_control * to store the associated reset control"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:21
#: include/linux/reset.h:274 include/linux/reset.h:296
#: include/linux/reset.h:313 include/linux/reset.h:335
#: include/linux/reset.h:356 include/linux/reset.h:376
#: include/linux/reset.h:405 include/linux/reset.h:420
#: include/linux/reset.h:439 include/linux/reset.h:457
#: include/linux/reset.h:476 include/linux/reset.h:495
#: include/linux/reset.h:511 include/linux/reset.h:531
#: include/linux/reset.h:557 include/linux/reset.h:574
#: include/linux/reset.h:601 include/linux/reset.h:621
#: include/linux/reset.h:640 include/linux/reset.h:660
#: include/linux/reset.h:680 include/linux/reset.h:700
#: include/linux/reset.h:720 include/linux/reset.h:739
#: include/linux/reset.h:756 include/linux/reset.h:775
#: include/linux/reset.h:796 include/linux/reset.h:816
#: include/linux/reset.h:835 include/linux/reset.h:854
#: include/linux/reset.h:874 include/linux/reset.h:893
#: include/linux/reset.h:912 include/linux/reset.h:931
#: include/linux/reset.h:949 ../../../driver-api/reset:191:
#: drivers/reset/core.c:344 drivers/reset/core.c:416 drivers/reset/core.c:456
#: drivers/reset/core.c:549 drivers/reset/core.c:650 drivers/reset/core.c:736
#: drivers/reset/core.c:1395 drivers/reset/core.c:1419
#: drivers/reset/core.c:1466 drivers/reset/core.c:1525
#: ../../../driver-api/reset:216: drivers/reset/core.c:105
#: drivers/reset/core.c:165
msgid "**Description**"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:18
msgid ""
"The reset APIs provide a series of reset_control_bulk_*() API calls as a "
"convenience to consumers which require multiple reset controls. This "
"structure is used to manage data for these calls."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:34
msgid ""
"Flags that can be passed to the reset_control_get functions to determine the "
"type of reset control. These values cannot be OR'd."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:38
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:40
msgid "``RESET_CONTROL_EXCLUSIVE``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:41
msgid "exclusive, acquired,"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:43
msgid "``RESET_CONTROL_EXCLUSIVE_DEASSERTED``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:44
msgid "exclusive, acquired, deasserted"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:46
msgid "``RESET_CONTROL_EXCLUSIVE_RELEASED``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:47
msgid "exclusive, released,"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:49
msgid "``RESET_CONTROL_SHARED``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:50
msgid "shared"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:52
msgid "``RESET_CONTROL_SHARED_DEASSERTED``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:53
msgid "shared, deasserted"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:55
msgid "``RESET_CONTROL_OPTIONAL_EXCLUSIVE``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:56
msgid "optional, exclusive, acquired"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:58
msgid "``RESET_CONTROL_OPTIONAL_EXCLUSIVE_DEASSERTED``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:59
msgid "optional, exclusive, acquired, deasserted"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:61
msgid "``RESET_CONTROL_OPTIONAL_EXCLUSIVE_RELEASED``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:62
msgid "optional, exclusive, released"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:64
msgid "``RESET_CONTROL_OPTIONAL_SHARED``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:65
msgid "optional, shared"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:67
msgid "``RESET_CONTROL_OPTIONAL_SHARED_DEASSERTED``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:68
msgid "optional, shared, deasserted"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:269
#: include/linux/reset.h:490
msgid "Lookup and obtain an exclusive reference to a reset controller."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:273
#: include/linux/reset.h:294 include/linux/reset.h:311
#: include/linux/reset.h:332 include/linux/reset.h:353
#: include/linux/reset.h:375 include/linux/reset.h:403
#: include/linux/reset.h:420 include/linux/reset.h:437
#: include/linux/reset.h:457 include/linux/reset.h:474
#: include/linux/reset.h:494 include/linux/reset.h:510
#: include/linux/reset.h:530 include/linux/reset.h:555
#: include/linux/reset.h:572 include/linux/reset.h:600
#: include/linux/reset.h:619 include/linux/reset.h:638
#: include/linux/reset.h:659 include/linux/reset.h:678
#: include/linux/reset.h:699 include/linux/reset.h:718
#: include/linux/reset.h:739 include/linux/reset.h:754
#: include/linux/reset.h:773 include/linux/reset.h:793
#: include/linux/reset.h:815 include/linux/reset.h:833
#: include/linux/reset.h:852 include/linux/reset.h:873
#: include/linux/reset.h:891 include/linux/reset.h:910
#: include/linux/reset.h:930 include/linux/reset.h:948
#: ../../../driver-api/reset:191: drivers/reset/core.c:345
#: drivers/reset/core.c:417 drivers/reset/core.c:457 drivers/reset/core.c:550
#: drivers/reset/core.c:630 drivers/reset/core.c:651 drivers/reset/core.c:737
#: drivers/reset/core.c:1205 drivers/reset/core.c:1395
#: drivers/reset/core.c:1417 drivers/reset/core.c:1465
#: drivers/reset/core.c:1525 ../../../driver-api/reset:216:
#: drivers/reset/core.c:105 drivers/reset/core.c:124 drivers/reset/core.c:148
#: drivers/reset/core.c:165 drivers/reset/core.c:198
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:275
#: include/linux/reset.h:296 include/linux/reset.h:313
#: include/linux/reset.h:334 include/linux/reset.h:355
#: include/linux/reset.h:377 include/linux/reset.h:405
#: include/linux/reset.h:422 include/linux/reset.h:439
#: include/linux/reset.h:459 include/linux/reset.h:476
#: include/linux/reset.h:602 include/linux/reset.h:621
#: include/linux/reset.h:640 include/linux/reset.h:661
#: include/linux/reset.h:680 include/linux/reset.h:701
#: include/linux/reset.h:720 include/linux/reset.h:741
#: include/linux/reset.h:756 include/linux/reset.h:775
#: include/linux/reset.h:795 include/linux/reset.h:817
#: include/linux/reset.h:835 include/linux/reset.h:854
#: include/linux/reset.h:875 include/linux/reset.h:893
#: include/linux/reset.h:912 include/linux/reset.h:932
#: include/linux/reset.h:950 ../../../driver-api/reset:191:
#: drivers/reset/core.c:1467 drivers/reset/core.c:1527
#: ../../../driver-api/reset:216: drivers/reset/core.c:167
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:271
#: include/linux/reset.h:292 include/linux/reset.h:310
#: include/linux/reset.h:331 include/linux/reset.h:352
#: include/linux/reset.h:373 include/linux/reset.h:401
#: include/linux/reset.h:417 include/linux/reset.h:435
#: include/linux/reset.h:454 include/linux/reset.h:472
#: include/linux/reset.h:492 include/linux/reset.h:508
#: include/linux/reset.h:528 include/linux/reset.h:554
#: include/linux/reset.h:571 include/linux/reset.h:598
#: include/linux/reset.h:618 include/linux/reset.h:636
#: include/linux/reset.h:657 include/linux/reset.h:676
#: include/linux/reset.h:697 include/linux/reset.h:716
#: include/linux/reset.h:736 include/linux/reset.h:753
#: include/linux/reset.h:771 include/linux/reset.h:792
#: include/linux/reset.h:813 include/linux/reset.h:832
#: include/linux/reset.h:850 include/linux/reset.h:871
#: include/linux/reset.h:890 include/linux/reset.h:908
#: include/linux/reset.h:928 include/linux/reset.h:946
msgid "device to be reset by the controller"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:273
#: include/linux/reset.h:312 include/linux/reset.h:375
#: include/linux/reset.h:419 include/linux/reset.h:456
#: include/linux/reset.h:494 include/linux/reset.h:510
#: include/linux/reset.h:530 include/linux/reset.h:600
#: include/linux/reset.h:620 include/linux/reset.h:659
#: include/linux/reset.h:699 include/linux/reset.h:738
#: include/linux/reset.h:755 include/linux/reset.h:815
#: include/linux/reset.h:834 include/linux/reset.h:873
#: include/linux/reset.h:892
msgid "``const char *id``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:272
#: include/linux/reset.h:311 include/linux/reset.h:374
#: include/linux/reset.h:418 include/linux/reset.h:455
#: include/linux/reset.h:493 include/linux/reset.h:509
#: include/linux/reset.h:529 include/linux/reset.h:599
#: include/linux/reset.h:619 include/linux/reset.h:658
#: include/linux/reset.h:698 include/linux/reset.h:737
#: include/linux/reset.h:754 include/linux/reset.h:814
#: include/linux/reset.h:833 include/linux/reset.h:872
#: include/linux/reset.h:891
msgid "reset line name"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:273
msgid ""
"Returns a struct reset_control or IS_ERR() condition containing errno. If "
"this function is called more than once for the same reset_control it will "
"return -EBUSY."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:277
msgid ""
"See reset_control_get_shared() for details on shared references to reset-"
"controls."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:280
#: include/linux/reset.h:317 include/linux/reset.h:389
#: include/linux/reset.h:496 include/linux/reset.h:516
#: include/linux/reset.h:541
msgid "Use of id names is optional."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:290
msgid "Lookup and obtain exclusive references to multiple reset controllers."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:294
#: include/linux/reset.h:333 include/linux/reset.h:354
#: include/linux/reset.h:403 include/linux/reset.h:437
#: include/linux/reset.h:474 include/linux/reset.h:638
#: include/linux/reset.h:678 include/linux/reset.h:718
#: include/linux/reset.h:773 include/linux/reset.h:794
#: include/linux/reset.h:852 include/linux/reset.h:910
msgid "``int num_rstcs``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:293
#: include/linux/reset.h:332 include/linux/reset.h:353
#: include/linux/reset.h:402 include/linux/reset.h:436
#: include/linux/reset.h:473 include/linux/reset.h:637
#: include/linux/reset.h:677 include/linux/reset.h:717
#: include/linux/reset.h:772 include/linux/reset.h:793
#: include/linux/reset.h:851 include/linux/reset.h:909
msgid "number of entries in rstcs array"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:295
#: include/linux/reset.h:334 include/linux/reset.h:355
#: include/linux/reset.h:404 include/linux/reset.h:438
#: include/linux/reset.h:475 include/linux/reset.h:639
#: include/linux/reset.h:679 include/linux/reset.h:719
#: include/linux/reset.h:774 include/linux/reset.h:795
#: include/linux/reset.h:853 include/linux/reset.h:911
msgid "``struct reset_control_bulk_data *rstcs``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:294
#: include/linux/reset.h:333 include/linux/reset.h:354
#: include/linux/reset.h:403 include/linux/reset.h:437
#: include/linux/reset.h:474 include/linux/reset.h:638
#: include/linux/reset.h:678 include/linux/reset.h:718
#: include/linux/reset.h:773 include/linux/reset.h:794
#: include/linux/reset.h:852 include/linux/reset.h:910
msgid "array of struct reset_control_bulk_data with reset line names set"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:295
msgid ""
"Fills the rstcs array with pointers to exclusive reset controls and returns "
"0, or an IS_ERR() condition containing errno."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:307
msgid ""
"Lookup and obtain a temoprarily exclusive reference to a reset controller."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:312
msgid ""
"Returns a struct reset_control or IS_ERR() condition containing errno. reset-"
"controls returned by this function must be acquired via "
"reset_control_acquire() before they can be used and should be released via "
"reset_control_release() afterwards."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:328
msgid ""
"Lookup and obtain temporarily exclusive references to multiple reset "
"controllers."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:334
msgid ""
"Fills the rstcs array with pointers to exclusive reset controls and returns "
"0, or an IS_ERR() condition containing errno. reset-controls returned by "
"this function must be acquired via reset_control_bulk_acquire() before they "
"can be used and should be released via reset_control_bulk_release() "
"afterwards."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:349
msgid ""
"Lookup and obtain optional temporarily exclusive references to multiple "
"reset controllers."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:355
msgid ""
"Optional variant of reset_control_bulk_get_exclusive_released(). If the "
"requested reset is not specified in the device tree, this function returns 0 "
"instead of an error and missing rtsc is set to NULL."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:359
#: include/linux/reset.h:683
msgid "See reset_control_bulk_get_exclusive_released() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:371
#: include/linux/reset.h:526
msgid "Lookup and obtain a shared reference to a reset controller."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:375
msgid ""
"Returns a struct reset_control or IS_ERR() condition containing errno. This "
"function is intended for use with reset-controls which are shared between "
"hardware blocks."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:379
#: include/linux/reset.h:530 include/linux/reset.h:573
msgid ""
"When a reset-control is shared, the behavior of reset_control_assert / "
"deassert is changed, the reset-core will keep track of a deassert_count and "
"only (re-)assert the reset after reset_control_assert has been called as "
"many times as reset_control_deassert was called. Also see the remark about "
"shared reset-controls in the reset_control_assert docs."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:385
msgid ""
"Calling reset_control_assert without first calling reset_control_deassert is "
"not allowed on a shared reset control. Calling reset_control_reset is also "
"not allowed on a shared reset control."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:399
msgid "Lookup and obtain shared references to multiple reset controllers."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:404
msgid ""
"Fills the rstcs array with pointers to shared reset controls and returns 0, "
"or an IS_ERR() condition containing errno."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:416
msgid "optional reset_control_get_exclusive()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:419
msgid ""
"Optional variant of reset_control_get_exclusive(). If the requested reset is "
"not specified in the device tree, this function returns NULL instead of an "
"error."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:423
#: include/linux/reset.h:604 include/linux/reset.h:624
#: include/linux/reset.h:934
msgid "See reset_control_get_exclusive() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:433
msgid "optional reset_control_bulk_get_exclusive()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:438
msgid ""
"Optional variant of reset_control_bulk_get_exclusive(). If any of the "
"requested resets are not specified in the device tree, this function sets "
"them to NULL instead of returning an error."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:442
#: include/linux/reset.h:643
msgid "See reset_control_bulk_get_exclusive() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:453
msgid "optional reset_control_get_shared()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:456
msgid ""
"Optional variant of reset_control_get_shared(). If the requested reset is "
"not specified in the device tree, this function returns NULL instead of an "
"error."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:460
msgid "See reset_control_get_shared() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:470
msgid "optional reset_control_bulk_get_shared()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:475
msgid ""
"Optional variant of reset_control_bulk_get_shared(). If the requested resets "
"are not specified in the device tree, this function sets them to NULL "
"instead of returning an error."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:479
#: include/linux/reset.h:778
msgid "See reset_control_bulk_get_shared() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:496
#: include/linux/reset.h:512 include/linux/reset.h:532
#: include/linux/reset.h:557 include/linux/reset.h:574
#: ../../../driver-api/reset:191: drivers/reset/core.c:1397
msgid "``struct device_node *node``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:494
#: include/linux/reset.h:514
msgid "Returns a struct reset_control or IS_ERR() condition containing errno."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:506
msgid ""
"Lookup and obtain an optional exclusive reference to a reset controller."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:510
msgid ""
"Optional variant of of_reset_control_get_exclusive(). If the requested reset "
"is not specified in the device tree, this function returns NULL instead of "
"an error."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:536
#: include/linux/reset.h:579
msgid ""
"Calling reset_control_assert without first calling reset_control_deassert is "
"not allowed on a shared reset control. Calling reset_control_reset is also "
"not allowed on a shared reset control. Returns a struct reset_control or "
"IS_ERR() condition containing errno."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:551
msgid ""
"Lookup and obtain an exclusive reference to a reset controller by index."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:556
#: include/linux/reset.h:573 include/linux/reset.h:930
#: include/linux/reset.h:948
msgid "``int index``"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:555
#: include/linux/reset.h:572 include/linux/reset.h:929
#: include/linux/reset.h:947
msgid "index of the reset controller"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:556
#: include/linux/reset.h:584
msgid ""
"This is to be used to perform a list of resets for a device or power domain "
"in whatever order. Returns a struct reset_control or IS_ERR() condition "
"containing errno."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:568
msgid "Lookup and obtain a shared reference to a reset controller by index."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:596
#: include/linux/reset.h:926
msgid "resource managed reset_control_get_exclusive()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:600
#: include/linux/reset.h:930
msgid ""
"Managed reset_control_get_exclusive(). For reset controllers returned from "
"this function, reset_control_put() is called automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:615
msgid ""
"resource managed reset_control_get_exclusive() + reset_control_deassert()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:620
msgid ""
"Managed reset_control_get_exclusive() + reset_control_deassert(). For reset "
"controllers returned from this function, reset_control_assert() + "
"reset_control_put() is called automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:634
msgid "resource managed reset_control_bulk_get_exclusive()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:639
msgid ""
"Managed reset_control_bulk_get_exclusive(). For reset controllers returned "
"from this function, reset_control_put() is called automatically on driver "
"detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:655
msgid "resource managed reset_control_get_exclusive_released()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:659
msgid ""
"Managed reset_control_get_exclusive_released(). For reset controllers "
"returned from this function, reset_control_put() is called automatically on "
"driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:663
#: include/linux/reset.h:703
msgid "See reset_control_get_exclusive_released() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:674
msgid "resource managed reset_control_bulk_get_exclusive_released()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:679
msgid ""
"Managed reset_control_bulk_get_exclusive_released(). For reset controllers "
"returned from this function, reset_control_put() is called automatically on "
"driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:695
msgid "resource managed reset_control_get_optional_exclusive_released()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:699
msgid ""
"Managed-and-optional variant of reset_control_get_exclusive_released(). For "
"reset controllers returned from this function, reset_control_put() is called "
"automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:714
msgid "resource managed reset_control_bulk_optional_get_exclusive_released()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:719
msgid ""
"Managed reset_control_bulk_optional_get_exclusive_released(). For reset "
"controllers returned from this function, reset_control_put() is called "
"automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:723
msgid ""
"See reset_control_bulk_optional_get_exclusive_released() for more "
"information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:735
msgid "resource managed reset_control_get_shared()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:738
#: include/linux/reset.h:948
msgid ""
"Managed reset_control_get_shared(). For reset controllers returned from this "
"function, reset_control_put() is called automatically on driver detach. See "
"reset_control_get_shared() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:750
msgid "resource managed reset_control_get_shared() + reset_control_deassert()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:755
msgid ""
"Managed reset_control_get_shared() + reset_control_deassert(). For reset "
"controllers returned from this function, reset_control_assert() + "
"reset_control_put() is called automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:759
msgid "See devm_reset_control_get_shared() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:769
msgid "resource managed reset_control_bulk_get_shared()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:774
msgid ""
"Managed reset_control_bulk_get_shared(). For reset controllers returned from "
"this function, reset_control_put() is called automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:789
msgid ""
"resource managed reset_control_bulk_get_shared() + "
"reset_control_bulk_deassert()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:795
msgid ""
"Managed reset_control_bulk_get_shared() + reset_control_bulk_deassert(). For "
"reset controllers returned from this function, reset_control_bulk_assert() + "
"reset_control_bulk_put() are called automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:799
msgid "See devm_reset_control_bulk_get_shared() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:811
msgid "resource managed reset_control_get_optional_exclusive()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:815
msgid ""
"Managed reset_control_get_optional_exclusive(). For reset controllers "
"returned from this function, reset_control_put() is called automatically on "
"driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:819
msgid "See reset_control_get_optional_exclusive() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:829
msgid ""
"resource managed reset_control_get_optional_exclusive() + "
"reset_control_deassert()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:834
msgid ""
"Managed reset_control_get_optional_exclusive() + reset_control_deassert(). "
"For reset controllers returned from this function, reset_control_assert() + "
"reset_control_put() is called automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:838
msgid "See devm_reset_control_get_optional_exclusive() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:848
msgid "resource managed reset_control_bulk_get_optional_exclusive()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:853
msgid ""
"Managed reset_control_bulk_get_optional_exclusive(). For reset controllers "
"returned from this function, reset_control_put() is called automatically on "
"driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:857
msgid "See reset_control_bulk_get_optional_exclusive() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:869
msgid "resource managed reset_control_get_optional_shared()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:873
msgid ""
"Managed reset_control_get_optional_shared(). For reset controllers returned "
"from this function, reset_control_put() is called automatically on driver "
"detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:877
msgid "See reset_control_get_optional_shared() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:887
msgid ""
"resource managed reset_control_get_optional_shared() + "
"reset_control_deassert()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:892
msgid ""
"Managed reset_control_get_optional_shared() + reset_control_deassert(). For "
"reset controllers returned from this function, reset_control_assert() + "
"reset_control_put() is called automatically on driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:896
msgid "See devm_reset_control_get_optional_shared() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:906
msgid "resource managed reset_control_bulk_get_optional_shared()"
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:911
msgid ""
"Managed reset_control_bulk_get_optional_shared(). For reset controllers "
"returned from this function, reset_control_put() is called automatically on "
"driver detach."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:915
msgid "See reset_control_bulk_get_optional_shared() for more information."
msgstr ""

#: ../../../driver-api/reset:188: include/linux/reset.h:944
msgid "resource managed reset_control_get_shared"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:341
msgid "reset the controlled device"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:347
#: drivers/reset/core.c:419 drivers/reset/core.c:459 drivers/reset/core.c:552
#: drivers/reset/core.c:632 drivers/reset/core.c:653 drivers/reset/core.c:739
#: drivers/reset/core.c:1207
msgid "``struct reset_control *rstc``"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:342
#: drivers/reset/core.c:414 drivers/reset/core.c:454 drivers/reset/core.c:547
#: drivers/reset/core.c:629 drivers/reset/core.c:1202
msgid "reset controller"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:343
msgid ""
"On a shared reset line the actual reset pulse is only triggered once for the "
"lifetime of the reset_control instance: for all but the first caller this is "
"a no-op. Consumers must not use reset_control_(de)assert on shared reset "
"lines when reset_control_reset has been used."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:349
#: drivers/reset/core.c:464 drivers/reset/core.c:552
msgid ""
"If rstc is NULL it is an optional reset and the function will just return 0."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:413
msgid "allow shared reset line to be re-triggered\""
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:415
msgid ""
"On a shared reset line the actual reset pulse is only triggered once for the "
"lifetime of the reset_control instance, except if this call is used."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:418
msgid ""
"Calls to this function must be balanced with calls to reset_control_reset, a "
"warning is thrown in case triggered_count ever dips below 0."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:421
msgid ""
"Consumers must not use reset_control_(de)assert on shared reset lines when "
"reset_control_reset or reset_control_rearm have been used."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:424
msgid "If rstc is NULL the function will just return 0."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:453
msgid "asserts the reset line"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:455
msgid ""
"Calling this on an exclusive reset controller guarantees that the reset will "
"be asserted. When called on a shared reset controller the line may still be "
"deasserted, as long as other users keep it so."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:459
msgid ""
"For shared reset controls a driver cannot expect the hw's registers and "
"internal state to be reset, but must be prepared for this to happen. "
"Consumers must not use reset_control_reset on shared reset lines when "
"reset_control_(de)assert has been used."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:546
msgid "deasserts the reset line"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:548
msgid ""
"After calling this function, the reset is guaranteed to be deasserted. "
"Consumers must not use reset_control_reset on shared reset lines when "
"reset_control_(de)assert has been used."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:626
msgid ""
"returns a negative errno if not supported, a positive value if the reset "
"line is asserted, or zero if the reset line is not asserted or if the desc "
"is NULL (optional reset)."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:647
msgid "acquires a reset control for exclusive use"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:648
#: drivers/reset/core.c:734
msgid "reset control"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:649
msgid ""
"This is used to explicitly acquire a reset control for exclusive use. Note "
"that exclusive resets are requested as acquired by default. In order for a "
"second consumer to be able to control the reset, the first consumer has to "
"release it first. Typically the easiest way to achieve this is to call the "
"reset_control_get_exclusive_released() to obtain an instance of the reset "
"control. Such reset controls are not acquired by default."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:656
msgid ""
"Consumers implementing shared access to an exclusive reset need to follow a "
"specific protocol in order to work together. Before consumers can change a "
"reset they must acquire exclusive access using reset_control_acquire(). "
"After they are done operating the reset, they must release exclusive access "
"with a call to reset_control_release(). Consumers are not granted exclusive "
"access to the reset as long as another consumer hasn't released a reset."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:663
msgid "See also: reset_control_release()"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:733
msgid "releases exclusive access to a reset control"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:735
msgid ""
"Releases exclusive access right to a reset control previously obtained by a "
"call to reset_control_acquire(). Until a consumer calls this function, no "
"other consumers will be granted exclusive access."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:739
msgid "See also: reset_control_acquire()"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1201
msgid "free the reset controller"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1391
#: drivers/reset/core.c:1521
msgid "Count number of resets available with a device"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1393
msgid "device node that contains 'resets'."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1394
#: drivers/reset/core.c:1524
msgid ""
"Returns positive reset count on success, or error number on failure and on "
"count being zero."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1413
msgid "Get a list of reset controls using device node."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1419
msgid "``struct device_node *np``"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1416
msgid "device node for the device that requests the reset controls array"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1418
#: drivers/reset/core.c:1465
msgid "``enum reset_control_flags flags``"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1417
#: drivers/reset/core.c:1464
msgid "whether reset controls are shared, optional, acquired"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1418
#: drivers/reset/core.c:1469
msgid ""
"Returns pointer to allocated reset_control on success or error on failure"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1461
msgid "Resource managed reset control array get"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1463
msgid "device that requests the list of reset controls"
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1465
msgid ""
"The reset control array APIs are intended for a list of resets that just "
"have to be asserted or deasserted, without any requirements on the order."
msgstr ""

#: ../../../driver-api/reset:191: drivers/reset/core.c:1523
msgid "device for which to return the number of resets"
msgstr ""

#: ../../../driver-api/reset.rst:206
msgid "Reset controller driver API"
msgstr ""

#: ../../../driver-api/reset.rst:208
msgid ""
"Reset controller drivers are supposed to implement the necessary functions "
"in a static constant structure :c:type:`reset_control_ops`, allocate and "
"fill out a struct :c:type:`reset_controller_dev`, and register it using "
"devm_reset_controller_register()."
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:10
msgid "reset controller driver callbacks"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:12
msgid "``reset``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:13
msgid ""
"for self-deasserting resets, does all necessary things to reset the device"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:14
msgid "``assert``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:15
msgid "manually assert the reset line, if supported"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:15
msgid "``deassert``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:16
msgid "manually deassert the reset line, if supported"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:16
msgid "``status``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:17
msgid "return the status of the reset line, if supported"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:30
msgid "represents a single lookup entry"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:32
#: include/linux/reset-controller.h:59
msgid "``list``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:33
msgid "internal list of all reset lookup entries"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:33
msgid "``provider``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:34
msgid "name of the reset controller device controlling this reset line"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:34
msgid "``index``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:35
msgid "ID of the reset controller in the reset controller device"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:35
msgid "``dev_id``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:36
msgid "name of the device associated with this reset line"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:36
msgid "``con_id``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:37
msgid "name of the reset line (can be NULL)"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:55
msgid "reset controller entity that might provide multiple reset controls"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:57
msgid "``ops``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:58
msgid "a pointer to device specific struct reset_control_ops"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:58
msgid "``owner``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:59
msgid "kernel module of the reset controller driver"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:60
msgid "internal list of reset controller devices"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:60
msgid "``reset_control_head``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:61
msgid "head of internal list of requested reset controls"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:61
msgid "``dev``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:62
msgid "corresponding driver model device struct"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:62
msgid "``of_node``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:63
msgid "corresponding device tree node as phandle target"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:63
msgid "``of_args``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:64
msgid ""
"for reset-gpios controllers: corresponding phandle args with of_node and "
"GPIO number complementing of_node; either this or of_node should be present"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:66
msgid "``of_reset_n_cells``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:67
msgid "number of cells in reset line specifiers"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:67
msgid "``of_xlate``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:68
msgid ""
"translation function to translate from specifier as found in the device tree "
"to id as given to the reset control ops, defaults to :c:func:"
"`of_reset_simple_xlate`."
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:70
msgid "``nr_resets``"
msgstr ""

#: ../../../driver-api/reset:213: include/linux/reset-controller.h:71
msgid "number of reset controls in this reset controller device"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:101
msgid "translate reset_spec to the reset line number"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:107
#: drivers/reset/core.c:126 drivers/reset/core.c:150 drivers/reset/core.c:164
msgid "``struct reset_controller_dev *rcdev``"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:102
#: drivers/reset/core.c:145
msgid "a pointer to the reset controller device"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:104
msgid "``const struct of_phandle_args *reset_spec``"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:103
msgid "reset line specifier as found in the device tree"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:104
msgid ""
"This static translation function is used by default if of_xlate in :c:type:"
"`reset_controller_dev` is not set. It is useful for all reset controllers "
"with 1:1 mapping, where reset lines can be indexed by number without gaps."
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:120
msgid "register a reset controller device"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:121
#: drivers/reset/core.c:163
msgid "a pointer to the initialized reset controller device"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:144
msgid "unregister a reset controller device"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:161
msgid "resource managed reset_controller_register()"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:162
msgid "device that is registering this reset controller"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:164
msgid ""
"Managed reset_controller_register(). For reset controllers registered by "
"this function, reset_controller_unregister() is automatically called on "
"driver detach. See reset_controller_register() for more information."
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:194
msgid "register a set of lookup entries"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:200
msgid "``struct reset_control_lookup *lookup``"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:195
msgid "array of reset lookup entries"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:197
msgid "``unsigned int num_entries``"
msgstr ""

#: ../../../driver-api/reset:216: drivers/reset/core.c:196
msgid "number of entries in the lookup array"
msgstr ""
