# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/ioctl.rst:3
msgid "ioctl based interfaces"
msgstr ""

#: ../../../driver-api/ioctl.rst:5
msgid ""
"ioctl() is the most common way for applications to interface with device "
"drivers. It is flexible and easily extended by adding new commands and can "
"be passed through character devices, block devices as well as sockets and "
"other special file descriptors."
msgstr ""

#: ../../../driver-api/ioctl.rst:10
msgid ""
"However, it is also very easy to get ioctl command definitions wrong, and "
"hard to fix them later without breaking existing applications, so this "
"documentation tries to help developers get it right."
msgstr ""

#: ../../../driver-api/ioctl.rst:15
msgid "Command number definitions"
msgstr ""

#: ../../../driver-api/ioctl.rst:17
msgid ""
"The command number, or request number, is the second argument passed to the "
"ioctl system call. While this can be any 32-bit number that uniquely "
"identifies an action for a particular driver, there are a number of "
"conventions around defining them."
msgstr ""

#: ../../../driver-api/ioctl.rst:22
msgid ""
"``include/uapi/asm-generic/ioctl.h`` provides four macros for defining ioctl "
"commands that follow modern conventions: ``_IO``, ``_IOR``, ``_IOW``, and "
"``_IOWR``. These should be used for all new commands, with the correct "
"parameters:"
msgstr ""

#: ../../../driver-api/ioctl.rst:27
msgid "_IO/_IOR/_IOW/_IOWR"
msgstr ""

#: ../../../driver-api/ioctl.rst:28
msgid ""
"The macro name specifies how the argument will be used.  It may be a pointer "
"to data to be passed into the kernel (_IOW), out of the kernel (_IOR), or "
"both (_IOWR).  _IO can indicate either commands with no argument or those "
"passing an integer value instead of a pointer. It is recommended to only use "
"_IO for commands without arguments, and use pointers for passing data."
msgstr ""

#: ../../../driver-api/ioctl.rst:35
msgid "type"
msgstr ""

#: ../../../driver-api/ioctl.rst:36
msgid ""
"An 8-bit number, often a character literal, specific to a subsystem or "
"driver, and listed in Documentation/userspace-api/ioctl/ioctl-number.rst"
msgstr ""

#: ../../../driver-api/ioctl.rst:39
msgid "nr"
msgstr ""

#: ../../../driver-api/ioctl.rst:40
msgid ""
"An 8-bit number identifying the specific command, unique for a give value of "
"'type'"
msgstr ""

#: ../../../driver-api/ioctl.rst:43
msgid "data_type"
msgstr ""

#: ../../../driver-api/ioctl.rst:44
msgid ""
"The name of the data type pointed to by the argument, the command number "
"encodes the ``sizeof(data_type)`` value in a 13-bit or 14-bit integer, "
"leading to a limit of 8191 bytes for the maximum size of the argument. Note: "
"do not pass sizeof(data_type) type into _IOR/_IOW/IOWR, as that will lead to "
"encoding sizeof(sizeof(data_type)), i.e. sizeof(size_t). _IO does not have a "
"data_type parameter."
msgstr ""

#: ../../../driver-api/ioctl.rst:53
msgid "Interface versions"
msgstr ""

#: ../../../driver-api/ioctl.rst:55
msgid ""
"Some subsystems use version numbers in data structures to overload commands "
"with different interpretations of the argument."
msgstr ""

#: ../../../driver-api/ioctl.rst:58
msgid ""
"This is generally a bad idea, since changes to existing commands tend to "
"break existing applications."
msgstr ""

#: ../../../driver-api/ioctl.rst:61
msgid ""
"A better approach is to add a new ioctl command with a new number. The old "
"command still needs to be implemented in the kernel for compatibility, but "
"this can be a wrapper around the new implementation."
msgstr ""

#: ../../../driver-api/ioctl.rst:66
msgid "Return code"
msgstr ""

#: ../../../driver-api/ioctl.rst:68
msgid ""
"ioctl commands can return negative error codes as documented in errno(3); "
"these get turned into errno values in user space. On success, the return "
"code should be zero. It is also possible but not recommended to return a "
"positive 'long' value."
msgstr ""

#: ../../../driver-api/ioctl.rst:73
msgid ""
"When the ioctl callback is called with an unknown command number, the "
"handler returns either -ENOTTY or -ENOIOCTLCMD, which also results in -"
"ENOTTY being returned from the system call. Some subsystems return -ENOSYS "
"or -EINVAL here for historic reasons, but this is wrong."
msgstr ""

#: ../../../driver-api/ioctl.rst:78
msgid ""
"Prior to Linux 5.5, compat_ioctl handlers were required to return -"
"ENOIOCTLCMD in order to use the fallback conversion into native commands. As "
"all subsystems are now responsible for handling compat mode themselves, this "
"is no longer needed, but it may be important to consider when backporting "
"bug fixes to older kernels."
msgstr ""

#: ../../../driver-api/ioctl.rst:85
msgid "Timestamps"
msgstr ""

#: ../../../driver-api/ioctl.rst:87
msgid ""
"Traditionally, timestamps and timeout values are passed as ``struct "
"timespec`` or ``struct timeval``, but these are problematic because of "
"incompatible definitions of these structures in user space after the move to "
"64-bit time_t."
msgstr ""

#: ../../../driver-api/ioctl.rst:92
msgid ""
"The ``struct __kernel_timespec`` type can be used instead to be embedded in "
"other data structures when separate second/nanosecond values are desired, or "
"passed to user space directly. This is still not ideal though, as the "
"structure matches neither the kernel's timespec64 nor the user space "
"timespec exactly. The get_timespec64() and put_timespec64() helper functions "
"can be used to ensure that the layout remains compatible with user space and "
"the padding is treated correctly."
msgstr ""

#: ../../../driver-api/ioctl.rst:100
msgid ""
"As it is cheap to convert seconds to nanoseconds, but the opposite requires "
"an expensive 64-bit division, a simple __u64 nanosecond value can be simpler "
"and more efficient."
msgstr ""

#: ../../../driver-api/ioctl.rst:104
msgid ""
"Timeout values and timestamps should ideally use CLOCK_MONOTONIC time, as "
"returned by ktime_get_ns() or ktime_get_ts64().  Unlike CLOCK_REALTIME, this "
"makes the timestamps immune from jumping backwards or forwards due to leap "
"second adjustments and clock_settime() calls."
msgstr ""

#: ../../../driver-api/ioctl.rst:109
msgid ""
"ktime_get_real_ns() can be used for CLOCK_REALTIME timestamps that need to "
"be persistent across a reboot or between multiple machines."
msgstr ""

#: ../../../driver-api/ioctl.rst:113
msgid "32-bit compat mode"
msgstr ""

#: ../../../driver-api/ioctl.rst:115
msgid ""
"In order to support 32-bit user space running on a 64-bit machine, each "
"subsystem or driver that implements an ioctl callback handler must also "
"implement the corresponding compat_ioctl handler."
msgstr ""

#: ../../../driver-api/ioctl.rst:119
msgid ""
"As long as all the rules for data structures are followed, this is as easy "
"as setting the .compat_ioctl pointer to a helper function such as "
"compat_ptr_ioctl() or blkdev_compat_ptr_ioctl()."
msgstr ""

#: ../../../driver-api/ioctl.rst:124
msgid "compat_ptr()"
msgstr ""

#: ../../../driver-api/ioctl.rst:126
msgid ""
"On the s390 architecture, 31-bit user space has ambiguous representations "
"for data pointers, with the upper bit being ignored. When running such a "
"process in compat mode, the compat_ptr() helper must be used to clear the "
"upper bit of a compat_uptr_t and turn it into a valid 64-bit pointer.  On "
"other architectures, this macro only performs a cast to a ``void __user *`` "
"pointer."
msgstr ""

#: ../../../driver-api/ioctl.rst:133
msgid ""
"In an compat_ioctl() callback, the last argument is an unsigned long, which "
"can be interpreted as either a pointer or a scalar depending on the command. "
"If it is a scalar, then compat_ptr() must not be used, to ensure that the 64-"
"bit kernel behaves the same way as a 32-bit kernel for arguments with the "
"upper bit set."
msgstr ""

#: ../../../driver-api/ioctl.rst:139
msgid ""
"The compat_ptr_ioctl() helper can be used in place of a custom compat_ioctl "
"file operation for drivers that only take arguments that are pointers to "
"compatible data structures."
msgstr ""

#: ../../../driver-api/ioctl.rst:144
msgid "Structure layout"
msgstr ""

#: ../../../driver-api/ioctl.rst:146
msgid ""
"Compatible data structures have the same layout on all architectures, "
"avoiding all problematic members:"
msgstr ""

#: ../../../driver-api/ioctl.rst:149
msgid ""
"``long`` and ``unsigned long`` are the size of a register, so they can be "
"either 32-bit or 64-bit wide and cannot be used in portable data structures. "
"Fixed-length replacements are ``__s32``, ``__u32``, ``__s64`` and ``__u64``."
msgstr ""

#: ../../../driver-api/ioctl.rst:154
msgid ""
"Pointers have the same problem, in addition to requiring the use of "
"compat_ptr(). The best workaround is to use ``__u64`` in place of pointers, "
"which requires a cast to ``uintptr_t`` in user space, and the use of "
"u64_to_user_ptr() in the kernel to convert it back into a user pointer."
msgstr ""

#: ../../../driver-api/ioctl.rst:160
msgid ""
"On the x86-32 (i386) architecture, the alignment of 64-bit variables is only "
"32-bit, but they are naturally aligned on most other architectures including "
"x86-64. This means a structure like::"
msgstr ""

#: ../../../driver-api/ioctl.rst:170
msgid ""
"has four bytes of padding between a and b on x86-64, plus another four bytes "
"of padding at the end, but no padding on i386, and it needs a compat_ioctl "
"conversion handler to translate between the two formats."
msgstr ""

#: ../../../driver-api/ioctl.rst:174
msgid ""
"To avoid this problem, all structures should have their members naturally "
"aligned, or explicit reserved fields added in place of the implicit padding. "
"The ``pahole`` tool can be used for checking the alignment."
msgstr ""

#: ../../../driver-api/ioctl.rst:179
msgid ""
"On ARM OABI user space, structures are padded to multiples of 32-bit, making "
"some structs incompatible with modern EABI kernels if they do not end on a "
"32-bit boundary."
msgstr ""

#: ../../../driver-api/ioctl.rst:183
msgid ""
"On the m68k architecture, struct members are not guaranteed to have an "
"alignment greater than 16-bit, which is a problem when relying on implicit "
"padding."
msgstr ""

#: ../../../driver-api/ioctl.rst:187
msgid ""
"Bitfields and enums generally work as one would expect them to, but some "
"properties of them are implementation-defined, so it is better to avoid them "
"completely in ioctl interfaces."
msgstr ""

#: ../../../driver-api/ioctl.rst:191
msgid ""
"``char`` members can be either signed or unsigned, depending on the "
"architecture, so the __u8 and __s8 types should be used for 8-bit integer "
"values, though char arrays are clearer for fixed-length strings."
msgstr ""

#: ../../../driver-api/ioctl.rst:196
msgid "Information leaks"
msgstr ""

#: ../../../driver-api/ioctl.rst:198
msgid ""
"Uninitialized data must not be copied back to user space, as this can cause "
"an information leak, which can be used to defeat kernel address space layout "
"randomization (KASLR), helping in an attack."
msgstr ""

#: ../../../driver-api/ioctl.rst:202
msgid ""
"For this reason (and for compat support) it is best to avoid any implicit "
"padding in data structures.  Where there is implicit padding in an existing "
"structure, kernel drivers must be careful to fully initialize an instance of "
"the structure before copying it to user space.  This is usually done by "
"calling memset() before assigning to individual members."
msgstr ""

#: ../../../driver-api/ioctl.rst:210
msgid "Subsystem abstractions"
msgstr ""

#: ../../../driver-api/ioctl.rst:212
msgid ""
"While some device drivers implement their own ioctl function, most "
"subsystems implement the same command for multiple drivers.  Ideally the "
"subsystem has an .ioctl() handler that copies the arguments from and to user "
"space, passing them into subsystem specific callback functions through "
"normal kernel pointers."
msgstr ""

#: ../../../driver-api/ioctl.rst:218
msgid "This helps in various ways:"
msgstr ""

#: ../../../driver-api/ioctl.rst:220
msgid ""
"Applications written for one driver are more likely to work for another one "
"in the same subsystem if there are no subtle differences in the user space "
"ABI."
msgstr ""

#: ../../../driver-api/ioctl.rst:224
msgid ""
"The complexity of user space access and data structure layout is done in one "
"place, reducing the potential for implementation bugs."
msgstr ""

#: ../../../driver-api/ioctl.rst:227
msgid ""
"It is more likely to be reviewed by experienced developers that can spot "
"problems in the interface when the ioctl is shared between multiple drivers "
"than when it is only used in a single driver."
msgstr ""

#: ../../../driver-api/ioctl.rst:232
msgid "Alternatives to ioctl"
msgstr ""

#: ../../../driver-api/ioctl.rst:234
msgid ""
"There are many cases in which ioctl is not the best solution for a problem. "
"Alternatives include:"
msgstr ""

#: ../../../driver-api/ioctl.rst:237
msgid ""
"System calls are a better choice for a system-wide feature that is not tied "
"to a physical device or constrained by the file system permissions of a "
"character device node"
msgstr ""

#: ../../../driver-api/ioctl.rst:241
msgid ""
"netlink is the preferred way of configuring any network related objects "
"through sockets."
msgstr ""

#: ../../../driver-api/ioctl.rst:244
msgid ""
"debugfs is used for ad-hoc interfaces for debugging functionality that does "
"not need to be exposed as a stable interface to applications."
msgstr ""

#: ../../../driver-api/ioctl.rst:247
msgid ""
"sysfs is a good way to expose the state of an in-kernel object that is not "
"tied to a file descriptor."
msgstr ""

#: ../../../driver-api/ioctl.rst:250
msgid "configfs can be used for more complex configuration than sysfs"
msgstr ""

#: ../../../driver-api/ioctl.rst:252
msgid ""
"A custom file system can provide extra flexibility with a simple user "
"interface but adds a lot of complexity to the implementation."
msgstr ""
