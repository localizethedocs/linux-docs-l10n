# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/md/md-cluster.rst:3
msgid "MD Cluster"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:5
msgid ""
"The cluster MD is a shared-device RAID for a cluster, it supports two "
"levels: raid1 and raid10 (limited support)."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:10
msgid "1. On-disk format"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:12
msgid ""
"Separate write-intent-bitmaps are used for each cluster node. The bitmaps "
"record all writes that may have been started on that node, and may not yet "
"have finished. The on-disk layout is::"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:23
msgid ""
"During \"normal\" functioning we assume the filesystem ensures that only one "
"node writes to any given block at a time, so a write request will"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:26
msgid "set the appropriate bit (if not already set)"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:27
msgid "commit the write to all mirrors"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:28
msgid "schedule the bit to be cleared after a timeout."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:30
msgid ""
"Reads are just handled normally. It is up to the filesystem to ensure one "
"node doesn't read from a location where another node (or the same node) is "
"writing."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:36
msgid "2. DLM Locks for management"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:38
msgid "There are three groups of locks for managing the device:"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:41
msgid "2.1 Bitmap lock resource (bm_lockres)"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:43
msgid ""
"The bm_lockres protects individual node bitmaps. They are named in the form "
"bitmap000 for node 1, bitmap001 for node 2 and so on. When a node joins the "
"cluster, it acquires the lock in PW mode and it stays so during the lifetime "
"the node is part of the cluster. The lock resource number is based on the "
"slot number returned by the DLM subsystem. Since DLM starts node count from "
"one and bitmap slots start from zero, one is subtracted from the DLM slot "
"number to arrive at the bitmap slot number."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:52
msgid ""
"The LVB of the bitmap lock for a particular node records the range of "
"sectors that are being re-synced by that node.  No other node may write to "
"those sectors.  This is used when a new nodes joins the cluster."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:58
msgid "2.2 Message passing locks"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:60
msgid ""
"Each node has to communicate with other nodes when starting or ending "
"resync, and for metadata superblock updates.  This communication is managed "
"through three locks: \"token\", \"message\", and \"ack\", together with the "
"Lock Value Block (LVB) of one of the \"message\" lock."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:66
msgid "2.3 new-device management"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:68
msgid ""
"A single lock: \"no-new-dev\" is used to coordinate the addition of new "
"devices - this must be synchronized across the array. Normally all nodes "
"hold a concurrent-read lock on this device."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:73
msgid "3. Communication"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:75
msgid ""
"Messages can be broadcast to all nodes, and the sender waits for all other "
"nodes to acknowledge the message before proceeding.  Only one message can be "
"processed at a time."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:80
msgid "3.1 Message Types"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:82
msgid "There are six types of messages which are passed:"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:85
msgid "3.1.1 METADATA_UPDATED"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:87
msgid ""
"informs other nodes that the metadata has been updated, and the node must re-"
"read the md superblock. This is performed synchronously. It is primarily "
"used to signal device failure."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:93
msgid "3.1.2 RESYNCING"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:94
msgid ""
"informs other nodes that a resync is initiated or ended so that each node "
"may suspend or resume the region.  Each RESYNCING message identifies a range "
"of the devices that the sending node is about to resync. This overrides any "
"previous notification from that node: only one ranged can be resynced at a "
"time per-node."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:102
msgid "3.1.3 NEWDISK"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:104
msgid ""
"informs other nodes that a device is being added to the array. Message "
"contains an identifier for that device.  See below for further details."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:109
msgid "3.1.4 REMOVE"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:111
msgid ""
"A failed or spare device is being removed from the array. The slot-number of "
"the device is included in the message."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:114
msgid "3.1.5 RE_ADD:"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:116
msgid ""
"A failed device is being re-activated - the assumption is that it has been "
"determined to be working again."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:119
msgid "3.1.6 BITMAP_NEEDS_SYNC:"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:121
msgid ""
"If a node is stopped locally but the bitmap isn't clean, then another node "
"is informed to take the ownership of resync."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:126
msgid "3.2 Communication mechanism"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:128
msgid ""
"The DLM LVB is used to communicate within nodes of the cluster. There are "
"three resources used for the purpose:"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:132
msgid "3.2.1 token"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:133
msgid ""
"The resource which protects the entire communication system. The node having "
"the token resource is allowed to communicate."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:138
msgid "3.2.2 message"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:139
msgid "The lock resource which carries the data to communicate."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:142
msgid "3.2.3 ack"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:144
msgid ""
"The resource, acquiring which means the message has been acknowledged by all "
"nodes in the cluster. The BAST of the resource is used to inform the "
"receiving node that a node wants to communicate."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:149
msgid "The algorithm is:"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:151
msgid "receive status - all nodes have concurrent-reader lock on \"ack\"::"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:156
msgid "sender get EX on \"token\", sender get EX on \"message\"::"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:164
msgid ""
"Sender checks that it still needs to send a message. Messages received or "
"other events that happened while waiting for the \"token\" may have made "
"this message inappropriate or redundant."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:168
msgid "sender writes LVB"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:170
msgid "sender down-convert \"message\" from EX to CW"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:172
msgid "sender try to get EX of \"ack\""
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:191
msgid ""
"triggered by grant of EX on \"ack\" (indicating all receivers have processed "
"message)"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:194
msgid "sender down-converts \"ack\" from EX to CR"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:196
msgid "sender releases \"message\""
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:198
msgid "sender releases \"token\""
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:211
msgid "4. Handling Failures"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:214
msgid "4.1 Node Failure"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:216
msgid ""
"When a node fails, the DLM informs the cluster with the slot number. The "
"node starts a cluster recovery thread. The cluster recovery thread:"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:220
msgid "acquires the bitmap<number> lock of the failed node"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:221
msgid "opens the bitmap"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:222
msgid "reads the bitmap of the failed node"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:223
msgid "copies the set bitmap to local node"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:224
msgid "cleans the bitmap of the failed node"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:225
msgid "releases bitmap<number> lock of the failed node"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:226
msgid ""
"initiates resync of the bitmap on the current node md_check_recovery is "
"invoked within recover_bitmaps, then md_check_recovery -> "
"metadata_update_start/finish, it will lock the communication by lock_comm. "
"Which means when one node is resyncing it blocks all other nodes from "
"writing anywhere on the array."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:233
msgid ""
"The resync process is the regular md resync. However, in a clustered "
"environment when a resync is performed, it needs to tell other nodes of the "
"areas which are suspended. Before a resync starts, the node send out "
"RESYNCING with the (lo,hi) range of the area which needs to be suspended. "
"Each node maintains a suspend_list, which contains the list of ranges which "
"are currently suspended. On receiving RESYNCING, the node adds the range to "
"the suspend_list. Similarly, when the node performing resync finishes, it "
"sends RESYNCING with an empty range to other nodes and other nodes remove "
"the corresponding entry from the suspend_list."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:244
msgid ""
"A helper function, ->area_resyncing() can be used to check if a particular I/"
"O range should be suspended or not."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:248
msgid "4.2 Device Failure"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:250
msgid ""
"Device failures are handled and communicated with the metadata update "
"routine.  When a node detects a device failure it does not allow any further "
"writes to that device until the failure has been acknowledged by all other "
"nodes."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:256
msgid "5. Adding a new Device"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:258
msgid ""
"For adding a new device, it is necessary that all nodes \"see\" the new "
"device to be added. For this, the following algorithm is used:"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:261
msgid ""
"Node 1 issues mdadm --manage /dev/mdX --add /dev/sdYY which issues "
"ioctl(ADD_NEW_DISK with disc.state set to MD_DISK_CLUSTER_ADD)"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:263
msgid "Node 1 sends a NEWDISK message with uuid and slot number"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:264
msgid ""
"Other nodes issue kobject_uevent_env with uuid and slot number (Steps 4,5 "
"could be a udev rule)"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:266
msgid ""
"In userspace, the node searches for the disk, perhaps using blkid -t "
"SUB_UUID=\"\""
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:268
msgid ""
"Other nodes issue either of the following depending on whether the disk was "
"found: ioctl(ADD_NEW_DISK with disc.state set to MD_DISK_CANDIDATE and disc."
"number set to slot number) ioctl(CLUSTERED_DISK_NACK)"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:273
msgid "Other nodes drop lock on \"no-new-devs\" (CR) if device is found"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:274
msgid "Node 1 attempts EX lock on \"no-new-dev\""
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:275
msgid ""
"If node 1 gets the lock, it sends METADATA_UPDATED after unmarking the disk "
"as SpareLocal"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:277
msgid ""
"If not (get \"no-new-dev\" lock), it fails the operation and sends "
"METADATA_UPDATED."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:279
msgid ""
"Other nodes get the information whether a disk is added or not by the "
"following METADATA_UPDATED."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:283
msgid "6. Module interface"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:285
msgid ""
"There are 17 call-backs which the md core can make to the cluster module.  "
"Understanding these can give a good overview of the whole process."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:290
msgid "6.1 join(nodes) and leave()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:292
msgid ""
"These are called when an array is started with a clustered bitmap, and when "
"the array is stopped.  join() ensures the cluster is available and "
"initializes the various resources. Only the first 'nodes' nodes in the "
"cluster can use the array."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:298
msgid "6.2 slot_number()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:300
msgid ""
"Reports the slot number advised by the cluster infrastructure. Range is from "
"0 to nodes-1."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:304
msgid "6.3 resync_info_update()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:306
msgid ""
"This updates the resync range that is stored in the bitmap lock. The "
"starting point is updated as the resync progresses.  The end point is always "
"the end of the array. It does *not* send a RESYNCING message."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:312
msgid "6.4 resync_start(), resync_finish()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:314
msgid ""
"These are called when resync/recovery/reshape starts or stops. They update "
"the resyncing range in the bitmap lock and also send a RESYNCING message.  "
"resync_start reports the whole array as resyncing, resync_finish reports "
"none of it."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:319
msgid ""
"resync_finish() also sends a BITMAP_NEEDS_SYNC message which allows some "
"other node to take over."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:323
msgid ""
"6.5 metadata_update_start(), metadata_update_finish(), "
"metadata_update_cancel()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:325
msgid ""
"metadata_update_start is used to get exclusive access to the metadata.  If a "
"change is still needed once that access is gained, metadata_update_finish() "
"will send a METADATA_UPDATE message to all other nodes, otherwise "
"metadata_update_cancel() can be used to release the lock."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:332
msgid "6.6 area_resyncing()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:334
msgid "This combines two elements of functionality."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:336
msgid ""
"Firstly, it will check if any node is currently resyncing anything in a "
"given range of sectors.  If any resync is found, then the caller will avoid "
"writing or read-balancing in that range."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:341
msgid ""
"Secondly, while node recovery is happening it reports that all areas are "
"resyncing for READ requests.  This avoids races between the cluster-"
"filesystem and the cluster-RAID handling a node failure."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:347
msgid "6.7 add_new_disk_start(), add_new_disk_finish(), new_disk_ack()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:349
msgid ""
"These are used to manage the new-disk protocol described above. When a new "
"device is added, add_new_disk_start() is called before it is bound to the "
"array and, if that succeeds, add_new_disk_finish() is called the device is "
"fully added."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:354
msgid ""
"When a device is added in acknowledgement to a previous request, or when the "
"device is declared \"unavailable\", new_disk_ack() is called."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:359
msgid "6.8 remove_disk()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:361
msgid ""
"This is called when a spare or failed device is removed from the array.  It "
"causes a REMOVE message to be send to other nodes."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:365
msgid "6.9 gather_bitmaps()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:367
msgid ""
"This sends a RE_ADD message to all other nodes and then gathers bitmap "
"information from all bitmaps.  This combined bitmap is then used to recovery "
"the re-added device."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:372
msgid "6.10 lock_all_bitmaps() and unlock_all_bitmaps()"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:374
msgid ""
"These are called when change bitmap to none. If a node plans to clear the "
"cluster raid's bitmap, it need to make sure no other nodes are using the "
"raid which is achieved by lock all bitmap locks within the cluster, and also "
"those locks are unlocked accordingly."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:381
msgid "7. Unsupported features"
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:383
msgid "There are somethings which are not supported by cluster MD yet."
msgstr ""

#: ../../../driver-api/md/md-cluster.rst:385
msgid "change array_sectors."
msgstr ""
