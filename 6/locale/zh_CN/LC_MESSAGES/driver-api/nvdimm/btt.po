# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/nvdimm/btt.rst:3
msgid "BTT - Block Translation Table"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:7
msgid "1. Introduction"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:9
msgid ""
"Persistent memory based storage is able to perform IO at byte (or more "
"accurately, cache line) granularity. However, we often want to expose such "
"storage as traditional block devices. The block drivers for persistent "
"memory will do exactly this. However, they do not provide any atomicity "
"guarantees. Traditional SSDs typically provide protection against torn "
"sectors in hardware, using stored energy in capacitors to complete in-flight "
"block writes, or perhaps in firmware. We don't have this luxury with "
"persistent memory - if a write is in progress, and we experience a power "
"failure, the block will contain a mix of old and new data. Applications may "
"not be prepared to handle such a scenario."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:19
msgid ""
"The Block Translation Table (BTT) provides atomic sector update semantics "
"for persistent memory devices, so that applications that rely on sector "
"writes not being torn can continue to do so. The BTT manifests itself as a "
"stacked block device, and reserves a portion of the underlying storage for "
"its metadata. At the heart of it, is an indirection table that re-maps all "
"the blocks on the volume. It can be thought of as an extremely simple file "
"system that only provides atomic sector updates."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:29
msgid "2. Static Layout"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:31
msgid ""
"The underlying storage on which a BTT can be laid out is not limited in any "
"way. The BTT, however, splits the available space into chunks of up to 512 "
"GiB, called \"Arenas\"."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:35
msgid ""
"Each arena follows the same layout for its metadata, and all references in "
"an arena are internal to it (with the exception of one field that points to "
"the next arena). The following depicts the \"On-disk\" metadata layout::"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:73
msgid "3. Theory of Operation"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:77
msgid "a. The BTT Map"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:79
msgid ""
"The map is a simple lookup/indirection table that maps an LBA to an internal "
"block. Each map entry is 32 bits. The two most significant bits are special "
"flags, and the remaining form the internal block number."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:84
msgid "Bit"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:84
msgid "Description"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:86
msgid "31 - 30"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:86
msgid "Error and Zero flags - Used in the following way::"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:97
msgid "29 - 0"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:97
msgid "Mappings to internal 'postmap' blocks"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:101
msgid "Some of the terminology that will be subsequently used:"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:104
msgid "External LBA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:104
msgid "LBA as made visible to upper layers."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:105
msgid "ABA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:105
msgid "Arena Block Address - Block offset/number within an arena"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:106
msgid "Premap ABA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:106
msgid ""
"The block offset into an arena, which was decided upon by range checking the "
"External LBA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:108
msgid "Postmap ABA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:108
msgid ""
"The block number in the \"Data Blocks\" area obtained after indirection from "
"the map"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:110
msgid "nfree"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:110
msgid ""
"The number of free blocks that are maintained at any given time. This is the "
"number of concurrent writes that can happen to the arena."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:116
msgid ""
"For example, after adding a BTT, we surface a disk of 1024G. We get a read "
"for the external LBA at 768G. This falls into the second arena, and of the "
"512G worth of blocks that this arena contributes, this block is at 256G. "
"Thus, the premap ABA is 256G. We now refer to the map, and find out the "
"mapping for block 'X' (256G) points to block 'Y', say '64'. Thus the postmap "
"ABA is 64."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:124
msgid "b. The BTT Flog"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:126
msgid ""
"The BTT provides sector atomicity by making every write an \"allocating "
"write\", i.e. Every write goes to a \"free\" block. A running list of free "
"blocks is maintained in the form of the BTT flog. 'Flog' is a combination of "
"the words \"free list\" and \"log\". The flog contains 'nfree' entries, and "
"an entry contains:"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:132
msgid "lba"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:132
msgid "The premap ABA that is being written to"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:133
msgid "old_map"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:133
msgid ""
"The old postmap ABA - after 'this' write completes, this will be a free "
"block."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:135
msgid "new_map"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:135
msgid ""
"The new postmap ABA. The map will up updated to reflect this lba-"
">postmap_aba mapping, but we log it here in case we have to recover."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:138
msgid "seq"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:138
msgid ""
"Sequence number to mark which of the 2 sections of this flog entry is valid/"
"newest. It cycles between 01->10->11->01 (binary) under normal operation, "
"with 00 indicating an uninitialized state."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:141
msgid "lba'"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:141
msgid "alternate lba entry"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:142
msgid "old_map'"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:142
msgid "alternate old postmap entry"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:143
msgid "new_map'"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:143
msgid "alternate new postmap entry"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:144
msgid "seq'"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:144
msgid "alternate sequence number."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:147
msgid ""
"Each of the above fields is 32-bit, making one entry 32 bytes. Entries are "
"also padded to 64 bytes to avoid cache line sharing or aliasing. Flog "
"updates are done such that for any entry being written, it: a. overwrites "
"the 'old' section in the entry based on sequence numbers b. writes the 'new' "
"section such that the sequence number is written last."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:155
msgid "c. The concept of lanes"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:157
msgid ""
"While 'nfree' describes the number of concurrent IOs an arena can process "
"concurrently, 'nlanes' is the number of IOs the BTT device as a whole can "
"process::"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:163
msgid ""
"A lane number is obtained at the start of any IO, and is used for indexing "
"into all the on-disk and in-memory data structures for the duration of the "
"IO. If there are more CPUs than the max number of available lanes, than "
"lanes are protected by spinlocks."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:170
msgid "d. In-memory data structure: Read Tracking Table (RTT)"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:172
msgid ""
"Consider a case where we have two threads, one doing reads and the other, "
"writes. We can hit a condition where the writer thread grabs a free block to "
"do a new IO, but the (slow) reader thread is still reading from it. In other "
"words, the reader consulted a map entry, and started reading the "
"corresponding block. A writer started writing to the same external LBA, and "
"finished the write updating the map for that external LBA to point to its "
"new postmap ABA. At this point the internal, postmap block that the reader "
"is (still) reading has been inserted into the list of free blocks. If "
"another write comes in for the same LBA, it can grab this free block, and "
"start writing to it, causing the reader to read incorrect data. To prevent "
"this, we introduce the RTT."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:183
msgid ""
"The RTT is a simple, per arena table with 'nfree' entries. Every reader "
"inserts into rtt[lane_number], the postmap ABA it is reading, and clears it "
"after the read is complete. Every writer thread, after grabbing a free "
"block, checks the RTT for its presence. If the postmap free block is in the "
"RTT, it waits till the reader clears the RTT entry, and only then starts "
"writing to it."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:191
msgid "e. In-memory data structure: map locks"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:193
msgid ""
"Consider a case where two writer threads are writing to the same LBA. There "
"can be a race in the following sequence of steps::"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:199
msgid ""
"Both threads can update their respective free[lane] with the same old, freed "
"postmap_aba. This has made the layout inconsistent by losing a free entry, "
"and at the same time, duplicating another free entry for two lanes."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:203
msgid ""
"To solve this, we could have a single map lock (per arena) that has to be "
"taken before performing the above sequence, but we feel that could be too "
"contentious. Instead we use an array of (nfree) map_locks that is indexed by "
"(premap_aba modulo nfree)."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:210
msgid "f. Reconstruction from the Flog"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:212
msgid ""
"On startup, we analyze the BTT flog to create our list of free blocks. We "
"walk through all the entries, and for each lane, of the set of two possible "
"'sections', we always look at the most recent one only (based on the "
"sequence number). The reconstruction rules/steps are simple:"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:217
msgid "Read map[log_entry.lba]."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:218
msgid "If log_entry.new matches the map entry, then log_entry.old is free."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:219
msgid ""
"If log_entry.new does not match the map entry, then log_entry.new is free. "
"(This case can only be caused by power-fails/unsafe shutdowns)"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:224
msgid "g. Summarizing - Read and Write flows"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:226
msgid "Read:"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:228
msgid "Convert external LBA to arena number + pre-map ABA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:229
#: ../../../driver-api/nvdimm/btt.rst:241
msgid "Get a lane (and take lane_lock)"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:230
msgid "Read map to get the entry for this pre-map ABA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:231
msgid "Enter post-map ABA into RTT[lane]"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:232
msgid "If TRIM flag set in map, return zeroes, and end IO (go to step 8)"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:233
msgid "If ERROR flag set in map, end IO with EIO (go to step 8)"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:234
msgid "Read data from this block"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:235
msgid "Remove post-map ABA entry from RTT[lane]"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:236
#: ../../../driver-api/nvdimm/btt.rst:251
msgid "Release lane (and lane_lock)"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:238
msgid "Write:"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:240
msgid "Convert external LBA to Arena number + pre-map ABA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:242
msgid ""
"Use lane to index into in-memory free list and obtain a new block, next flog "
"index, next sequence number"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:244
msgid "Scan the RTT to check if free block is present, and spin/wait if it is."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:245
msgid "Write data to this free block"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:246
msgid "Read map to get the existing post-map ABA entry for this pre-map ABA"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:247
msgid ""
"Write flog entry: [premap_aba / old postmap_aba / new postmap_aba / seq_num]"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:248
msgid "Write new post-map ABA into map."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:249
msgid "Write old post-map entry into the free list"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:250
msgid "Calculate next sequence number and write into the free list entry"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:255
msgid "4. Error Handling"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:257
msgid ""
"An arena would be in an error state if any of the metadata is corrupted "
"irrecoverably, either due to a bug or a media error. The following "
"conditions indicate an error:"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:261
msgid ""
"Info block checksum does not match (and recovering from the copy also fails)"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:262
msgid ""
"All internal available blocks are not uniquely and entirely addressed by the "
"sum of mapped blocks and free blocks (from the BTT flog)."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:264
msgid ""
"Rebuilding free list from the flog reveals missing/duplicate/impossible "
"entries"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:266
msgid "A map entry is out of bounds"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:268
msgid ""
"If any of these error conditions are encountered, the arena is put into a "
"read only state using a flag in the info block."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:273
msgid "5. Usage"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:275
msgid ""
"The BTT can be set up on any disk (namespace) exposed by the libnvdimm "
"subsystem (pmem, or blk mode). The easiest way to set up such a namespace is "
"using the 'ndctl' utility [1]:"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:279
msgid ""
"For example, the ndctl command line to setup a btt with a 4k sector size is::"
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:283
msgid "See ndctl create-namespace --help for more options."
msgstr ""

#: ../../../driver-api/nvdimm/btt.rst:285
msgid "[1]: https://github.com/pmem/ndctl"
msgstr ""
