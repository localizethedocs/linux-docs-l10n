# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/f2fs.rst:5
msgid "WHAT IS Flash-Friendly File System (F2FS)?"
msgstr ""

#: ../../../filesystems/f2fs.rst:7
msgid ""
"NAND flash memory-based storage devices, such as SSD, eMMC, and SD cards, "
"have been equipped on a variety systems ranging from mobile to server "
"systems. Since they are known to have different characteristics from the "
"conventional rotating disks, a file system, an upper layer to the storage "
"device, should adapt to the changes from the sketch in the design level."
msgstr ""

#: ../../../filesystems/f2fs.rst:13
msgid ""
"F2FS is a file system exploiting NAND flash memory-based storage devices, "
"which is based on Log-structured File System (LFS). The design has been "
"focused on addressing the fundamental issues in LFS, which are snowball "
"effect of wandering tree and high cleaning overhead."
msgstr ""

#: ../../../filesystems/f2fs.rst:18
msgid ""
"Since a NAND flash memory-based storage device shows different "
"characteristic according to its internal geometry or flash memory management "
"scheme, namely FTL, F2FS and its tools support various parameters not only "
"for configuring on-disk layout, but also for selecting allocation and "
"cleaning algorithms."
msgstr ""

#: ../../../filesystems/f2fs.rst:23
msgid ""
"The following git tree provides the file system formatting tool (mkfs.f2fs), "
"a consistency checking tool (fsck.f2fs), and a debugging tool (dump.f2fs)."
msgstr ""

#: ../../../filesystems/f2fs.rst:26
msgid "git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs-tools.git"
msgstr ""

#: ../../../filesystems/f2fs.rst:28
msgid "For sending patches, please use the following mailing list:"
msgstr ""

#: ../../../filesystems/f2fs.rst:30
msgid "linux-f2fs-devel@lists.sourceforge.net"
msgstr ""

#: ../../../filesystems/f2fs.rst:32
msgid "For reporting bugs, please use the following f2fs bug tracker link:"
msgstr ""

#: ../../../filesystems/f2fs.rst:34
msgid ""
"https://bugzilla.kernel.org/enter_bug.cgi?"
"product=File%20System&component=f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:37
msgid "Background and Design issues"
msgstr ""

#: ../../../filesystems/f2fs.rst:40
msgid "Log-structured File System (LFS)"
msgstr ""

#: ../../../filesystems/f2fs.rst:41
msgid ""
"\"A log-structured file system writes all modifications to disk sequentially "
"in a log-like structure, thereby speeding up  both file writing and crash "
"recovery. The log is the only structure on disk; it contains indexing "
"information so that files can be read back from the log efficiently. In "
"order to maintain large free areas on disk for fast writing, we divide  the "
"log into segments and use a segment cleaner to compress the live information "
"from heavily fragmented segments.\" from Rosenblum, M. and Ousterhout, J. "
"K., 1992, \"The design and implementation of a log-structured file system\", "
"ACM Trans. Computer Systems 10, 1, 26–52."
msgstr ""

#: ../../../filesystems/f2fs.rst:52 ../../../filesystems/f2fs.rst:92
msgid "Wandering Tree Problem"
msgstr ""

#: ../../../filesystems/f2fs.rst:53
msgid ""
"In LFS, when a file data is updated and written to the end of log, its "
"direct pointer block is updated due to the changed location. Then the "
"indirect pointer block is also updated due to the direct pointer block "
"update. In this manner, the upper index structures such as inode, inode map, "
"and checkpoint block are also updated recursively. This problem is called as "
"wandering tree problem [1], and in order to enhance the performance, it "
"should eliminate or relax the update propagation as much as possible."
msgstr ""

#: ../../../filesystems/f2fs.rst:61
msgid ""
"[1] Bityutskiy, A. 2005. JFFS3 design issues. http://www.linux-mtd.infradead."
"org/"
msgstr ""

#: ../../../filesystems/f2fs.rst:64 ../../../filesystems/f2fs.rst:98
msgid "Cleaning Overhead"
msgstr ""

#: ../../../filesystems/f2fs.rst:65
msgid ""
"Since LFS is based on out-of-place writes, it produces so many obsolete "
"blocks scattered across the whole storage. In order to serve new empty log "
"space, it needs to reclaim these obsolete blocks seamlessly to users. This "
"job is called as a cleaning process."
msgstr ""

#: ../../../filesystems/f2fs.rst:70
msgid "The process consists of three operations as follows."
msgstr ""

#: ../../../filesystems/f2fs.rst:72
msgid "A victim segment is selected through referencing segment usage table."
msgstr ""

#: ../../../filesystems/f2fs.rst:73
msgid ""
"It loads parent index structures of all the data in the victim identified by "
"segment summary blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:75
msgid ""
"It checks the cross-reference between the data and its parent index "
"structure."
msgstr ""

#: ../../../filesystems/f2fs.rst:76
msgid "It moves valid data selectively."
msgstr ""

#: ../../../filesystems/f2fs.rst:78
msgid ""
"This cleaning job may cause unexpected long delays, so the most important "
"goal is to hide the latencies to users. And also definitely, it should "
"reduce the amount of valid data to be moved, and move them quickly as well."
msgstr ""

#: ../../../filesystems/f2fs.rst:83
msgid "Key Features"
msgstr ""

#: ../../../filesystems/f2fs.rst:86
msgid "Flash Awareness"
msgstr ""

#: ../../../filesystems/f2fs.rst:87
msgid ""
"Enlarge the random write area for better performance, but provide the high "
"spatial locality"
msgstr ""

#: ../../../filesystems/f2fs.rst:89
msgid ""
"Align FS data structures to the operational units in FTL as best efforts"
msgstr ""

#: ../../../filesystems/f2fs.rst:93
msgid ""
"Use a term, “node”, that represents inodes as well as various pointer blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:94
msgid ""
"Introduce Node Address Table (NAT) containing the locations of all the "
"“node” blocks; this will cut off the update propagation."
msgstr ""

#: ../../../filesystems/f2fs.rst:99
msgid "Support a background cleaning process"
msgstr ""

#: ../../../filesystems/f2fs.rst:100
msgid ""
"Support greedy and cost-benefit algorithms for victim selection policies"
msgstr ""

#: ../../../filesystems/f2fs.rst:101
msgid "Support multi-head logs for static/dynamic hot and cold data separation"
msgstr ""

#: ../../../filesystems/f2fs.rst:102
msgid "Introduce adaptive logging for efficient block allocation"
msgstr ""

#: ../../../filesystems/f2fs.rst:105
msgid "Mount Options"
msgstr ""

#: ../../../filesystems/f2fs.rst:109
msgid "background_gc=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:109
msgid ""
"Turn on/off cleaning operations, namely garbage collection, triggered in "
"background when I/O subsystem is idle. If background_gc=on, it will turn on "
"the garbage collection and if background_gc=off, garbage collection will be "
"turned off. If background_gc=sync, it will turn on synchronous garbage "
"collection running in background. Default value for this option is on. So "
"garbage collection is on by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:117
msgid "gc_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:117
msgid ""
"When background_gc is on, this option can be enabled to let background GC "
"thread to handle foreground GC requests, it can eliminate the sluggish issue "
"caused by slow foreground GC operation when GC is triggered from a process "
"with limited I/O and CPU resources."
msgstr ""

#: ../../../filesystems/f2fs.rst:122
msgid "nogc_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:122
msgid "Disable GC merge feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:123
msgid "disable_roll_forward"
msgstr ""

#: ../../../filesystems/f2fs.rst:123
msgid "Disable the roll-forward recovery routine"
msgstr ""

#: ../../../filesystems/f2fs.rst:124
msgid "norecovery"
msgstr ""

#: ../../../filesystems/f2fs.rst:124
msgid ""
"Disable the roll-forward recovery routine, mounted read- only (i.e., -o ro,"
"disable_roll_forward)"
msgstr ""

#: ../../../filesystems/f2fs.rst:126
msgid "discard/nodiscard"
msgstr ""

#: ../../../filesystems/f2fs.rst:126
msgid ""
"Enable/disable real-time discard in f2fs, if discard is enabled, f2fs will "
"issue discard/TRIM commands when a segment is cleaned."
msgstr ""

#: ../../../filesystems/f2fs.rst:129
msgid "heap/no_heap"
msgstr ""

#: ../../../filesystems/f2fs.rst:129
msgid "Deprecated."
msgstr ""

#: ../../../filesystems/f2fs.rst:130
msgid "nouser_xattr"
msgstr ""

#: ../../../filesystems/f2fs.rst:130
msgid ""
"Disable Extended User Attributes. Note: xattr is enabled by default if "
"CONFIG_F2FS_FS_XATTR is selected."
msgstr ""

#: ../../../filesystems/f2fs.rst:132
msgid "noacl"
msgstr ""

#: ../../../filesystems/f2fs.rst:132
msgid ""
"Disable POSIX Access Control List. Note: acl is enabled by default if "
"CONFIG_F2FS_FS_POSIX_ACL is selected."
msgstr ""

#: ../../../filesystems/f2fs.rst:134
msgid "active_logs=%u"
msgstr ""

#: ../../../filesystems/f2fs.rst:134
msgid ""
"Support configuring the number of active logs. In the current design, f2fs "
"supports only 2, 4, and 6 logs. Default number is 6."
msgstr ""

#: ../../../filesystems/f2fs.rst:137
msgid "disable_ext_identify"
msgstr ""

#: ../../../filesystems/f2fs.rst:137
msgid ""
"Disable the extension list configured by mkfs, so f2fs is not aware of cold "
"files such as media files."
msgstr ""

#: ../../../filesystems/f2fs.rst:139
msgid "inline_xattr"
msgstr ""

#: ../../../filesystems/f2fs.rst:139
msgid "Enable the inline xattrs feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:140
msgid "noinline_xattr"
msgstr ""

#: ../../../filesystems/f2fs.rst:140
msgid "Disable the inline xattrs feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:141
msgid "inline_xattr_size=%u"
msgstr ""

#: ../../../filesystems/f2fs.rst:141
msgid ""
"Support configuring inline xattr size, it depends on flexible inline xattr "
"feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:143
msgid "inline_data"
msgstr ""

#: ../../../filesystems/f2fs.rst:143
msgid ""
"Enable the inline data feature: Newly created small (<~3.4k) files can be "
"written into inode block."
msgstr ""

#: ../../../filesystems/f2fs.rst:145
msgid "inline_dentry"
msgstr ""

#: ../../../filesystems/f2fs.rst:145
msgid ""
"Enable the inline dir feature: data in newly created directory entries can "
"be written into inode block. The space of inode block which is used to store "
"inline dentries is limited to ~3.4k."
msgstr ""

#: ../../../filesystems/f2fs.rst:149
msgid "noinline_dentry"
msgstr ""

#: ../../../filesystems/f2fs.rst:149
msgid "Disable the inline dentry feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:150
msgid "flush_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:150
msgid ""
"Merge concurrent cache_flush commands as much as possible to eliminate "
"redundant command issues. If the underlying device handles the cache_flush "
"command relatively slowly, recommend to enable this option."
msgstr ""

#: ../../../filesystems/f2fs.rst:154
msgid "nobarrier"
msgstr ""

#: ../../../filesystems/f2fs.rst:154
msgid ""
"This option can be used if underlying storage guarantees its cached data "
"should be written to the novolatile area. If this option is set, no "
"cache_flush commands are issued but f2fs still guarantees the write ordering "
"of all the data writes."
msgstr ""

#: ../../../filesystems/f2fs.rst:159
msgid "barrier"
msgstr ""

#: ../../../filesystems/f2fs.rst:159
msgid "If this option is set, cache_flush commands are allowed to be issued."
msgstr ""

#: ../../../filesystems/f2fs.rst:161
msgid "fastboot"
msgstr ""

#: ../../../filesystems/f2fs.rst:161
msgid ""
"This option is used when a system wants to reduce mount time as much as "
"possible, even though normal performance can be sacrificed."
msgstr ""

#: ../../../filesystems/f2fs.rst:164
msgid "extent_cache"
msgstr ""

#: ../../../filesystems/f2fs.rst:164
msgid ""
"Enable an extent cache based on rb-tree, it can cache as many as extent "
"which map between contiguous logical address and physical address per inode, "
"resulting in increasing the cache hit ratio. Set by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:168
msgid "noextent_cache"
msgstr ""

#: ../../../filesystems/f2fs.rst:168
msgid ""
"Disable an extent cache based on rb-tree explicitly, see the above "
"extent_cache mount option."
msgstr ""

#: ../../../filesystems/f2fs.rst:170
msgid "noinline_data"
msgstr ""

#: ../../../filesystems/f2fs.rst:170
msgid ""
"Disable the inline data feature, inline data feature is enabled by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:172
msgid "data_flush"
msgstr ""

#: ../../../filesystems/f2fs.rst:172
msgid ""
"Enable data flushing before checkpoint in order to persist data of regular "
"and symlink."
msgstr ""

#: ../../../filesystems/f2fs.rst:174
msgid "reserve_root=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:174
msgid ""
"Support configuring reserved space which is used for allocation from a "
"privileged user with specified uid or gid, unit: 4KB, the default limit is "
"0.2% of user blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:177
msgid "resuid=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:177
msgid "The user ID which may use the reserved blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:178
msgid "resgid=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:178
msgid "The group ID which may use the reserved blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:179
msgid "fault_injection=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:179
msgid ""
"Enable fault injection in all supported types with specified injection rate."
msgstr ""

#: ../../../filesystems/f2fs.rst:181
msgid "fault_type=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:181
msgid ""
"Support configuring fault injection type, should be enabled with "
"fault_injection option, fault type value is shown below, it supports single "
"or combined type."
msgstr ""

#: ../../../filesystems/f2fs.rst:186
msgid "Type_Name"
msgstr ""

#: ../../../filesystems/f2fs.rst:186
msgid "Type_Value"
msgstr ""

#: ../../../filesystems/f2fs.rst:188
msgid "FAULT_KMALLOC"
msgstr ""

#: ../../../filesystems/f2fs.rst:188
msgid "0x00000001"
msgstr ""

#: ../../../filesystems/f2fs.rst:189
msgid "FAULT_KVMALLOC"
msgstr ""

#: ../../../filesystems/f2fs.rst:189
msgid "0x00000002"
msgstr ""

#: ../../../filesystems/f2fs.rst:190
msgid "FAULT_PAGE_ALLOC"
msgstr ""

#: ../../../filesystems/f2fs.rst:190
msgid "0x00000004"
msgstr ""

#: ../../../filesystems/f2fs.rst:191
msgid "FAULT_PAGE_GET"
msgstr ""

#: ../../../filesystems/f2fs.rst:191
msgid "0x00000008"
msgstr ""

#: ../../../filesystems/f2fs.rst:192
msgid "FAULT_ALLOC_BIO"
msgstr ""

#: ../../../filesystems/f2fs.rst:192
msgid "0x00000010 (obsolete)"
msgstr ""

#: ../../../filesystems/f2fs.rst:193
msgid "FAULT_ALLOC_NID"
msgstr ""

#: ../../../filesystems/f2fs.rst:193
msgid "0x00000020"
msgstr ""

#: ../../../filesystems/f2fs.rst:194
msgid "FAULT_ORPHAN"
msgstr ""

#: ../../../filesystems/f2fs.rst:194
msgid "0x00000040"
msgstr ""

#: ../../../filesystems/f2fs.rst:195
msgid "FAULT_BLOCK"
msgstr ""

#: ../../../filesystems/f2fs.rst:195
msgid "0x00000080"
msgstr ""

#: ../../../filesystems/f2fs.rst:196
msgid "FAULT_DIR_DEPTH"
msgstr ""

#: ../../../filesystems/f2fs.rst:196
msgid "0x00000100"
msgstr ""

#: ../../../filesystems/f2fs.rst:197
msgid "FAULT_EVICT_INODE"
msgstr ""

#: ../../../filesystems/f2fs.rst:197
msgid "0x00000200"
msgstr ""

#: ../../../filesystems/f2fs.rst:198
msgid "FAULT_TRUNCATE"
msgstr ""

#: ../../../filesystems/f2fs.rst:198
msgid "0x00000400"
msgstr ""

#: ../../../filesystems/f2fs.rst:199
msgid "FAULT_READ_IO"
msgstr ""

#: ../../../filesystems/f2fs.rst:199
msgid "0x00000800"
msgstr ""

#: ../../../filesystems/f2fs.rst:200
msgid "FAULT_CHECKPOINT"
msgstr ""

#: ../../../filesystems/f2fs.rst:200
msgid "0x00001000"
msgstr ""

#: ../../../filesystems/f2fs.rst:201
msgid "FAULT_DISCARD"
msgstr ""

#: ../../../filesystems/f2fs.rst:201
msgid "0x00002000"
msgstr ""

#: ../../../filesystems/f2fs.rst:202
msgid "FAULT_WRITE_IO"
msgstr ""

#: ../../../filesystems/f2fs.rst:202
msgid "0x00004000"
msgstr ""

#: ../../../filesystems/f2fs.rst:203
msgid "FAULT_SLAB_ALLOC"
msgstr ""

#: ../../../filesystems/f2fs.rst:203
msgid "0x00008000"
msgstr ""

#: ../../../filesystems/f2fs.rst:204
msgid "FAULT_DQUOT_INIT"
msgstr ""

#: ../../../filesystems/f2fs.rst:204
msgid "0x00010000"
msgstr ""

#: ../../../filesystems/f2fs.rst:205
msgid "FAULT_LOCK_OP"
msgstr ""

#: ../../../filesystems/f2fs.rst:205
msgid "0x00020000"
msgstr ""

#: ../../../filesystems/f2fs.rst:206
msgid "FAULT_BLKADDR_VALIDITY"
msgstr ""

#: ../../../filesystems/f2fs.rst:206
msgid "0x00040000"
msgstr ""

#: ../../../filesystems/f2fs.rst:207
msgid "FAULT_BLKADDR_CONSISTENCE"
msgstr ""

#: ../../../filesystems/f2fs.rst:207
msgid "0x00080000"
msgstr ""

#: ../../../filesystems/f2fs.rst:208
msgid "FAULT_NO_SEGMENT"
msgstr ""

#: ../../../filesystems/f2fs.rst:208
msgid "0x00100000"
msgstr ""

#: ../../../filesystems/f2fs.rst:209
msgid "FAULT_INCONSISTENT_FOOTER"
msgstr ""

#: ../../../filesystems/f2fs.rst:209
msgid "0x00200000"
msgstr ""

#: ../../../filesystems/f2fs.rst:210
msgid "FAULT_TIMEOUT"
msgstr ""

#: ../../../filesystems/f2fs.rst:210
msgid "0x00400000 (1000ms)"
msgstr ""

#: ../../../filesystems/f2fs.rst:211
msgid "FAULT_VMALLOC"
msgstr ""

#: ../../../filesystems/f2fs.rst:211
msgid "0x00800000"
msgstr ""

#: ../../../filesystems/f2fs.rst:213
msgid "mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:213
msgid ""
"Control block allocation mode which supports \"adaptive\" and \"lfs\". In "
"\"lfs\" mode, there should be no random writes towards main area. \"fragment:"
"segment\" and \"fragment:block\" are newly added here. These are developer "
"options for experiments to simulate filesystem fragmentation/after-GC "
"situation itself. The developers use these modes to understand filesystem "
"fragmentation/after-GC condition well, and eventually get some insights to "
"handle them better. In \"fragment:segment\", f2fs allocates a new segment in "
"random position. With this, we can simulate the after-GC condition. In "
"\"fragment:block\", we can scatter block allocation with "
"\"max_fragment_chunk\" and \"max_fragment_hole\" sysfs nodes. We added some "
"randomness to both chunk and hole size to make it close to realistic IO "
"pattern. So, in this mode, f2fs will allocate 1..<max_fragment_chunk> blocks "
"in a chunk and make a hole in the length of 1..<max_fragment_hole> by turns. "
"With this, the newly allocated blocks will be scattered throughout the whole "
"partition. Note that \"fragment:block\" implicitly enables \"fragment:"
"segment\" option for more randomness. Please, use these options for your "
"experiments and we strongly recommend to re-format the filesystem after "
"using these options."
msgstr ""

#: ../../../filesystems/f2fs.rst:234
msgid "usrquota"
msgstr ""

#: ../../../filesystems/f2fs.rst:234 ../../../filesystems/f2fs.rst:244
msgid "Enable plain user disk quota accounting."
msgstr ""

#: ../../../filesystems/f2fs.rst:235
msgid "grpquota"
msgstr ""

#: ../../../filesystems/f2fs.rst:235
msgid "Enable plain group disk quota accounting."
msgstr ""

#: ../../../filesystems/f2fs.rst:236
msgid "prjquota"
msgstr ""

#: ../../../filesystems/f2fs.rst:236
msgid "Enable plain project quota accounting."
msgstr ""

#: ../../../filesystems/f2fs.rst:237
msgid "usrjquota=<file>"
msgstr ""

#: ../../../filesystems/f2fs.rst:237
msgid "Appoint specified file and type during mount, so that quota"
msgstr ""

#: ../../../filesystems/f2fs.rst:238
msgid "grpjquota=<file>"
msgstr ""

#: ../../../filesystems/f2fs.rst:238
msgid "information can be properly updated during recovery flow,"
msgstr ""

#: ../../../filesystems/f2fs.rst:239
msgid "prjjquota=<file>"
msgstr ""

#: ../../../filesystems/f2fs.rst:239
msgid "<quota file>: must be in root directory;"
msgstr ""

#: ../../../filesystems/f2fs.rst:240
msgid "jqfmt=<quota type>"
msgstr ""

#: ../../../filesystems/f2fs.rst:240
msgid "<quota type>: [vfsold,vfsv0,vfsv1]."
msgstr ""

#: ../../../filesystems/f2fs.rst:241
msgid "usrjquota="
msgstr ""

#: ../../../filesystems/f2fs.rst:241
msgid "Turn off user journalled quota."
msgstr ""

#: ../../../filesystems/f2fs.rst:242
msgid "grpjquota="
msgstr ""

#: ../../../filesystems/f2fs.rst:242
msgid "Turn off group journalled quota."
msgstr ""

#: ../../../filesystems/f2fs.rst:243
msgid "prjjquota="
msgstr ""

#: ../../../filesystems/f2fs.rst:243
msgid "Turn off project journalled quota."
msgstr ""

#: ../../../filesystems/f2fs.rst:244
msgid "quota"
msgstr ""

#: ../../../filesystems/f2fs.rst:245
msgid "noquota"
msgstr ""

#: ../../../filesystems/f2fs.rst:245
msgid "Disable all plain disk quota option."
msgstr ""

#: ../../../filesystems/f2fs.rst:246
msgid "alloc_mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:246
msgid ""
"Adjust block allocation policy, which supports \"reuse\" and \"default\"."
msgstr ""

#: ../../../filesystems/f2fs.rst:248
msgid "fsync_mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:248
msgid ""
"Control the policy of fsync. Currently supports \"posix\", \"strict\", and "
"\"nobarrier\". In \"posix\" mode, which is default, fsync will follow POSIX "
"semantics and does a light operation to improve the filesystem performance. "
"In \"strict\" mode, fsync will be heavy and behaves in line with xfs, ext4 "
"and btrfs, where xfstest generic/342 will pass, but the performance will "
"regress. \"nobarrier\" is based on \"posix\", but doesn't issue flush "
"command for non-atomic files likewise \"nobarrier\" mount option."
msgstr ""

#: ../../../filesystems/f2fs.rst:257
msgid "test_dummy_encryption"
msgstr ""

#: ../../../filesystems/f2fs.rst:258
msgid "test_dummy_encryption=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:259
msgid ""
"Enable dummy encryption, which provides a fake fscrypt context. The fake "
"fscrypt context is used by xfstests. The argument may be either \"v1\" or "
"\"v2\", in order to select the corresponding fscrypt policy version."
msgstr ""

#: ../../../filesystems/f2fs.rst:263
msgid "checkpoint=%s[:%u[%]]"
msgstr ""

#: ../../../filesystems/f2fs.rst:263
msgid ""
"Set to \"disable\" to turn off checkpointing. Set to \"enable\" to re-enable "
"checkpointing. Is enabled by default. While disabled, any unmounting or "
"unexpected shutdowns will cause the filesystem contents to appear as they "
"did when the filesystem was mounted with that option. While mounting with "
"checkpoint=disable, the filesystem must run garbage collection to ensure "
"that all available space can be used. If this takes too much time, the mount "
"may return EAGAIN. You may optionally add a value to indicate how much of "
"the disk you would be willing to temporarily give up to avoid additional "
"garbage collection. This can be given as a number of blocks, or as a "
"percent. For instance, mounting with checkpoint=disable:100% would always "
"succeed, but it may hide up to all remaining free space. The actual space "
"that would be unusable can be viewed at /sys/fs/f2fs/<disk>/unusable This "
"space is reclaimed once checkpoint=enable."
msgstr ""

#: ../../../filesystems/f2fs.rst:279
msgid "checkpoint_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:279
msgid ""
"When checkpoint is enabled, this can be used to create a kernel daemon and "
"make it to merge concurrent checkpoint requests as much as possible to "
"eliminate redundant checkpoint issues. Plus, we can eliminate the sluggish "
"issue caused by slow checkpoint operation when the checkpoint is done in a "
"process context in a cgroup having low i/o budget and cpu shares. To make "
"this do better, we set the default i/o priority of the kernel daemon to "
"\"3\", to give one higher priority than other kernel threads. This is the "
"same way to give a I/O priority to the jbd2 journaling thread of ext4 "
"filesystem."
msgstr ""

#: ../../../filesystems/f2fs.rst:289
msgid "nocheckpoint_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:289
msgid "Disable checkpoint merge feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:290
msgid "compress_algorithm=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:290
msgid ""
"Control compress algorithm, currently f2fs supports \"lzo\", \"lz4\", "
"\"zstd\" and \"lzo-rle\" algorithm."
msgstr ""

#: ../../../filesystems/f2fs.rst:292
msgid "compress_algorithm=%s:%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:292
msgid ""
"Control compress algorithm and its compress level, now, only \"lz4\" and "
"\"zstd\" support compress level config. algorithm      level range "
"lz4            3 - 16 zstd           1 - 22"
msgstr ""

#: ../../../filesystems/f2fs.rst:297
msgid "compress_log_size=%u"
msgstr ""

#: ../../../filesystems/f2fs.rst:297
msgid ""
"Support configuring compress cluster size. The size will be 4KB * (1 << %u). "
"The default and minimum sizes are 16KB."
msgstr ""

#: ../../../filesystems/f2fs.rst:299
msgid "compress_extension=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:299
msgid ""
"Support adding specified extension, so that f2fs can enable compression on "
"those corresponding files, e.g. if all files with '.ext' has high "
"compression rate, we can set the '.ext' on compression extension list and "
"enable compression on these file by default rather than to enable it via "
"ioctl. For other files, we can still enable compression via ioctl. Note "
"that, there is one reserved special extension '*', it can be set to enable "
"compression for all files."
msgstr ""

#: ../../../filesystems/f2fs.rst:307
msgid "nocompress_extension=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:307
msgid ""
"Support adding specified extension, so that f2fs can disable compression on "
"those corresponding files, just contrary to compression extension. If you "
"know exactly which files cannot be compressed, you can use this. The same "
"extension name can't appear in both compress and nocompress extension at the "
"same time. If the compress extension specifies all files, the types "
"specified by the nocompress extension will be treated as special cases and "
"will not be compressed. Don't allow use '*' to specifie all file in "
"nocompress extension. After add nocompress_extension, the priority should "
"be: dir_flag < comp_extention,nocompress_extension < comp_file_flag,"
"no_comp_file_flag. See more in compression sections."
msgstr ""

#: ../../../filesystems/f2fs.rst:319
msgid "compress_chksum"
msgstr ""

#: ../../../filesystems/f2fs.rst:319
msgid "Support verifying chksum of raw data in compressed cluster."
msgstr ""

#: ../../../filesystems/f2fs.rst:320
msgid "compress_mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:320
msgid ""
"Control file compression mode. This supports \"fs\" and \"user\" modes. In "
"\"fs\" mode (default), f2fs does automatic compression on the compression "
"enabled files. In \"user\" mode, f2fs disables the automaic compression and "
"gives the user discretion of choosing the target file and the timing. The "
"user can do manual compression/decompression on the compression enabled "
"files using ioctls."
msgstr ""

#: ../../../filesystems/f2fs.rst:327
msgid "compress_cache"
msgstr ""

#: ../../../filesystems/f2fs.rst:327
msgid ""
"Support to use address space of a filesystem managed inode to cache "
"compressed block, in order to improve cache hit ratio of random read."
msgstr ""

#: ../../../filesystems/f2fs.rst:330
msgid "inlinecrypt"
msgstr ""

#: ../../../filesystems/f2fs.rst:330
msgid ""
"When possible, encrypt/decrypt the contents of encrypted files using the blk-"
"crypto framework rather than filesystem-layer encryption. This allows the "
"use of inline encryption hardware. The on-disk format is unaffected. For "
"more details, see Documentation/block/inline-encryption.rst."
msgstr ""

#: ../../../filesystems/f2fs.rst:336
msgid "atgc"
msgstr ""

#: ../../../filesystems/f2fs.rst:336
msgid ""
"Enable age-threshold garbage collection, it provides high effectiveness and "
"efficiency on background GC."
msgstr ""

#: ../../../filesystems/f2fs.rst:338
msgid "discard_unit=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:338
msgid ""
"Control discard unit, the argument can be \"block\", \"segment\" and "
"\"section\", issued discard command's offset/size will be aligned to the "
"unit, by default, \"discard_unit=block\" is set, so that small discard "
"functionality is enabled. For blkzoned device, \"discard_unit=section\" will "
"be set by default, it is helpful for large sized SMR or ZNS devices to "
"reduce memory cost by getting rid of fs metadata supports small discard."
msgstr ""

#: ../../../filesystems/f2fs.rst:346
msgid "memory=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:346
msgid ""
"Control memory mode. This supports \"normal\" and \"low\" modes. \"low\" "
"mode is introduced to support low memory devices. Because of the nature of "
"low memory devices, in this mode, f2fs will try to save memory sometimes by "
"sacrificing performance. \"normal\" mode is the default mode and same as "
"before."
msgstr ""

#: ../../../filesystems/f2fs.rst:351
msgid "age_extent_cache"
msgstr ""

#: ../../../filesystems/f2fs.rst:351
msgid ""
"Enable an age extent cache based on rb-tree. It records data block update "
"frequency of the extent per inode, in order to provide better temperature "
"hints for data block allocation."
msgstr ""

#: ../../../filesystems/f2fs.rst:355
msgid "errors=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:355
msgid ""
"Specify f2fs behavior on critical errors. This supports modes: \"panic\", "
"\"continue\" and \"remount-ro\", respectively, trigger panic immediately, "
"continue without doing anything, and remount the partition in read-only "
"mode. By default it uses \"continue\" mode. ====================== "
"=============== =============== ======== mode                   "
"continue        remount-ro      panic ====================== =============== "
"=============== ======== access ops             normal          "
"normal          N/A syscall errors         -EIO            -EROFS          N/"
"A mount option           rw              ro              N/A pending dir "
"write      keep            keep            N/A pending non-dir write  "
"drop            keep            N/A pending node write     drop            "
"keep            N/A pending meta write     keep            keep            N/"
"A ====================== =============== =============== ========"
msgstr ""

#: ../../../filesystems/f2fs.rst:371
msgid "nat_bits"
msgstr ""

#: ../../../filesystems/f2fs.rst:371
msgid ""
"Enable nat_bits feature to enhance full/empty nat blocks access, by default "
"it's disabled."
msgstr ""

#: ../../../filesystems/f2fs.rst:376
msgid "Debugfs Entries"
msgstr ""

#: ../../../filesystems/f2fs.rst:378
msgid ""
"/sys/kernel/debug/f2fs/ contains information about all the partitions "
"mounted as f2fs. Each file shows the whole f2fs information."
msgstr ""

#: ../../../filesystems/f2fs.rst:381
msgid "/sys/kernel/debug/f2fs/status includes:"
msgstr ""

#: ../../../filesystems/f2fs.rst:383
msgid "major file system information managed by f2fs currently"
msgstr ""

#: ../../../filesystems/f2fs.rst:384
msgid "average SIT information about whole segments"
msgstr ""

#: ../../../filesystems/f2fs.rst:385
msgid "current memory footprint consumed by f2fs."
msgstr ""

#: ../../../filesystems/f2fs.rst:388
msgid "Sysfs Entries"
msgstr ""

#: ../../../filesystems/f2fs.rst:390
msgid ""
"Information about mounted f2fs file systems can be found in /sys/fs/f2fs.  "
"Each mounted filesystem will have a directory in /sys/fs/f2fs based on its "
"device name (i.e., /sys/fs/f2fs/sda). The files in each per-device directory "
"are shown in table below."
msgstr ""

#: ../../../filesystems/f2fs.rst:395
msgid ""
"Files in /sys/fs/f2fs/<devname> (see also Documentation/ABI/testing/sysfs-fs-"
"f2fs)"
msgstr ""

#: ../../../filesystems/f2fs.rst:399
msgid "Usage"
msgstr ""

#: ../../../filesystems/f2fs.rst:401
msgid "Download userland tools and compile them."
msgstr ""

#: ../../../filesystems/f2fs.rst:403
msgid ""
"Skip, if f2fs was compiled statically inside kernel. Otherwise, insert the "
"f2fs.ko module::"
msgstr ""

#: ../../../filesystems/f2fs.rst:408
msgid "Create a directory to use when mounting::"
msgstr ""

#: ../../../filesystems/f2fs.rst:412
msgid "Format the block device, and then mount as f2fs::"
msgstr ""

#: ../../../filesystems/f2fs.rst:418
msgid "mkfs.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:419
msgid ""
"The mkfs.f2fs is for the use of formatting a partition as the f2fs "
"filesystem, which builds a basic on-disk layout."
msgstr ""

#: ../../../filesystems/f2fs.rst:422
msgid "The quick options consist of:"
msgstr ""

#: ../../../filesystems/f2fs.rst:425
msgid "``-l [label]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:425
msgid "Give a volume label, up to 512 unicode name."
msgstr ""

#: ../../../filesystems/f2fs.rst:426
msgid "``-a [0 or 1]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:426
msgid "Split start location of each area for heap-based allocation."
msgstr ""

#: ../../../filesystems/f2fs.rst:428
msgid "1 is set by default, which performs this."
msgstr ""

#: ../../../filesystems/f2fs.rst:429
msgid "``-o [int]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:429
msgid "Set overprovision ratio in percent over volume size."
msgstr ""

#: ../../../filesystems/f2fs.rst:431
msgid "5 is set by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:432
msgid "``-s [int]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:432
msgid "Set the number of segments per section."
msgstr ""

#: ../../../filesystems/f2fs.rst:434 ../../../filesystems/f2fs.rst:437
msgid "1 is set by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:435
msgid "``-z [int]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:435
msgid "Set the number of sections per zone."
msgstr ""

#: ../../../filesystems/f2fs.rst:438
msgid "``-e [str]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:438
msgid "Set basic extension list. e.g. \"mp3,gif,mov\""
msgstr ""

#: ../../../filesystems/f2fs.rst:439
msgid "``-t [0 or 1]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:439
msgid "Disable discard command or not."
msgstr ""

#: ../../../filesystems/f2fs.rst:441
msgid "1 is set by default, which conducts discard."
msgstr ""

#: ../../../filesystems/f2fs.rst:444
msgid ""
"Note: please refer to the manpage of mkfs.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:447
msgid "fsck.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:448
msgid ""
"The fsck.f2fs is a tool to check the consistency of an f2fs-formatted "
"partition, which examines whether the filesystem metadata and user-made data "
"are cross-referenced correctly or not. Note that, initial version of the "
"tool does not fix any inconsistency."
msgstr ""

#: ../../../filesystems/f2fs.rst:453
msgid "The quick options consist of::"
msgstr ""

#: ../../../filesystems/f2fs.rst:457
msgid ""
"Note: please refer to the manpage of fsck.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:460
msgid "dump.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:461
msgid ""
"The dump.f2fs shows the information of specific inode and dumps SSA and SIT "
"to file. Each file is dump_ssa and dump_sit."
msgstr ""

#: ../../../filesystems/f2fs.rst:464
msgid ""
"The dump.f2fs is used to debug on-disk data structures of the f2fs "
"filesystem. It shows on-disk inode information recognized by a given inode "
"number, and is able to dump all the SSA and SIT entries into predefined "
"files, ./dump_ssa and ./dump_sit respectively."
msgstr ""

#: ../../../filesystems/f2fs.rst:469
msgid "The options consist of::"
msgstr ""

#: ../../../filesystems/f2fs.rst:476
msgid "Examples::"
msgstr ""

#: ../../../filesystems/f2fs.rst:482
msgid ""
"Note: please refer to the manpage of dump.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:485
msgid "sload.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:486
msgid ""
"The sload.f2fs gives a way to insert files and directories in the existing "
"disk image. This tool is useful when building f2fs images given compiled "
"files."
msgstr ""

#: ../../../filesystems/f2fs.rst:489
msgid ""
"Note: please refer to the manpage of sload.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:492
msgid "resize.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:493
msgid ""
"The resize.f2fs lets a user resize the f2fs-formatted disk image, while "
"preserving all the files and directories stored in the image."
msgstr ""

#: ../../../filesystems/f2fs.rst:496
msgid ""
"Note: please refer to the manpage of resize.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:499
msgid "defrag.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:500
msgid ""
"The defrag.f2fs can be used to defragment scattered written data as well as "
"filesystem metadata across the disk. This can improve the write speed by "
"giving more free consecutive space."
msgstr ""

#: ../../../filesystems/f2fs.rst:504
msgid ""
"Note: please refer to the manpage of defrag.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:507
msgid "f2fs_io"
msgstr ""

#: ../../../filesystems/f2fs.rst:508
msgid ""
"The f2fs_io is a simple tool to issue various filesystem APIs as well as "
"f2fs-specific ones, which is very useful for QA tests."
msgstr ""

#: ../../../filesystems/f2fs.rst:511
msgid ""
"Note: please refer to the manpage of f2fs_io(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:514
msgid "Design"
msgstr ""

#: ../../../filesystems/f2fs.rst:517
msgid "On-disk Layout"
msgstr ""

#: ../../../filesystems/f2fs.rst:519
msgid ""
"F2FS divides the whole volume into a number of segments, each of which is "
"fixed to 2MB in size. A section is composed of consecutive segments, and a "
"zone consists of a set of sections. By default, section and zone sizes are "
"set to one segment size identically, but users can easily modify the sizes "
"by mkfs."
msgstr ""

#: ../../../filesystems/f2fs.rst:524
msgid ""
"F2FS splits the entire volume into six areas, and all the areas except "
"superblock consist of multiple segments as described below::"
msgstr ""

#: ../../../filesystems/f2fs.rst:546
msgid "Superblock (SB)"
msgstr ""

#: ../../../filesystems/f2fs.rst:547
msgid ""
"It is located at the beginning of the partition, and there exist two copies "
"to avoid file system crash. It contains basic partition information and some "
"default parameters of f2fs."
msgstr ""

#: ../../../filesystems/f2fs.rst:551
msgid "Checkpoint (CP)"
msgstr ""

#: ../../../filesystems/f2fs.rst:552
msgid ""
"It contains file system information, bitmaps for valid NAT/SIT sets, orphan "
"inode lists, and summary entries of current active segments."
msgstr ""

#: ../../../filesystems/f2fs.rst:555
msgid "Segment Information Table (SIT)"
msgstr ""

#: ../../../filesystems/f2fs.rst:556
msgid ""
"It contains segment information such as valid block count and bitmap for the "
"validity of all the blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:559
msgid "Node Address Table (NAT)"
msgstr ""

#: ../../../filesystems/f2fs.rst:560
msgid ""
"It is composed of a block address table for all the node blocks stored in "
"Main area."
msgstr ""

#: ../../../filesystems/f2fs.rst:563
msgid "Segment Summary Area (SSA)"
msgstr ""

#: ../../../filesystems/f2fs.rst:564
msgid ""
"It contains summary entries which contains the owner information of all the "
"data and node blocks stored in Main area."
msgstr ""

#: ../../../filesystems/f2fs.rst:567
msgid "Main Area"
msgstr ""

#: ../../../filesystems/f2fs.rst:568
msgid "It contains file and directory data including their indices."
msgstr ""

#: ../../../filesystems/f2fs.rst:570
msgid ""
"In order to avoid misalignment between file system and flash-based storage, "
"F2FS aligns the start block address of CP with the segment size. Also, it "
"aligns the start block address of Main area with the zone size by reserving "
"some segments in SSA area."
msgstr ""

#: ../../../filesystems/f2fs.rst:575
msgid ""
"Reference the following survey for additional technical details. https://"
"wiki.linaro.org/WorkingGroups/Kernel/Projects/FlashCardSurvey"
msgstr ""

#: ../../../filesystems/f2fs.rst:579
msgid "File System Metadata Structure"
msgstr ""

#: ../../../filesystems/f2fs.rst:581
msgid ""
"F2FS adopts the checkpointing scheme to maintain file system consistency. At "
"mount time, F2FS first tries to find the last valid checkpoint data by "
"scanning CP area. In order to reduce the scanning time, F2FS uses only two "
"copies of CP. One of them always indicates the last valid data, which is "
"called as shadow copy mechanism. In addition to CP, NAT and SIT also adopt "
"the shadow copy mechanism."
msgstr ""

#: ../../../filesystems/f2fs.rst:587
msgid ""
"For file system consistency, each CP points to which NAT and SIT copies are "
"valid, as shown as below::"
msgstr ""

#: ../../../filesystems/f2fs.rst:604
msgid "Index Structure"
msgstr ""

#: ../../../filesystems/f2fs.rst:606
msgid ""
"The key data structure to manage the data locations is a \"node\". Similar "
"to traditional file structures, F2FS has three types of node: inode, direct "
"node, indirect node. F2FS assigns 4KB to an inode block which contains 923 "
"data block indices, two direct node pointers, two indirect node pointers, "
"and one double indirect node pointer as described below. One direct node "
"block contains 1018 data blocks, and one indirect node block contains also "
"1018 node blocks. Thus, one inode block (i.e., a file) covers::"
msgstr ""

#: ../../../filesystems/f2fs.rst:628
msgid ""
"Note that all the node blocks are mapped by NAT which means the location of "
"each node is translated by the NAT table. In the consideration of the "
"wandering tree problem, F2FS is able to cut off the propagation of node "
"updates caused by leaf data writes."
msgstr ""

#: ../../../filesystems/f2fs.rst:634
msgid "Directory Structure"
msgstr ""

#: ../../../filesystems/f2fs.rst:636
msgid ""
"A directory entry occupies 11 bytes, which consists of the following "
"attributes."
msgstr ""

#: ../../../filesystems/f2fs.rst:638
msgid "hash          hash value of the file name"
msgstr ""

#: ../../../filesystems/f2fs.rst:639
msgid "ino           inode number"
msgstr ""

#: ../../../filesystems/f2fs.rst:640
msgid "len           the length of file name"
msgstr ""

#: ../../../filesystems/f2fs.rst:641
msgid "type          file type such as directory, symlink, etc"
msgstr ""

#: ../../../filesystems/f2fs.rst:643
msgid ""
"A dentry block consists of 214 dentry slots and file names. Therein a bitmap "
"is used to represent whether each dentry is valid or not. A dentry block "
"occupies 4KB with the following composition."
msgstr ""

#: ../../../filesystems/f2fs.rst:670
msgid ""
"F2FS implements multi-level hash tables for directory structure. Each level "
"has a hash table with dedicated number of hash buckets as shown below. Note "
"that \"A(2B)\" means a bucket includes 2 data blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:692
msgid "The number of blocks and buckets are determined by::"
msgstr ""

#: ../../../filesystems/f2fs.rst:704
msgid ""
"When F2FS finds a file name in a directory, at first a hash value of the "
"file name is calculated. Then, F2FS scans the hash table in level #0 to find "
"the dentry consisting of the file name and its inode number. If not found, "
"F2FS scans the next hash table in level #1. In this way, F2FS scans hash "
"tables in each levels incrementally from 1 to N. In each level F2FS needs to "
"scan only one bucket determined by the following equation, which shows "
"O(log(# of files)) complexity::"
msgstr ""

#: ../../../filesystems/f2fs.rst:714
msgid ""
"In the case of file creation, F2FS finds empty consecutive slots that cover "
"the file name. F2FS searches the empty slots in the hash tables of whole "
"levels from 1 to N in the same way as the lookup operation."
msgstr ""

#: ../../../filesystems/f2fs.rst:718
msgid "The following figure shows an example of two cases holding children::"
msgstr ""

#: ../../../filesystems/f2fs.rst:733
msgid "Default Block Allocation"
msgstr ""

#: ../../../filesystems/f2fs.rst:735
msgid ""
"At runtime, F2FS manages six active logs inside \"Main\" area: Hot/Warm/Cold "
"node and Hot/Warm/Cold data."
msgstr ""

#: ../../../filesystems/f2fs.rst:738
msgid "Hot node      contains direct node blocks of directories."
msgstr ""

#: ../../../filesystems/f2fs.rst:739
msgid "Warm node     contains direct node blocks except hot node blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:740
msgid "Cold node     contains indirect node blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:741
msgid "Hot data      contains dentry blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:742
msgid "Warm data     contains data blocks except hot and cold data blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:743
msgid "Cold data     contains multimedia data or migrated data blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:745
msgid ""
"LFS has two schemes for free space management: threaded log and copy-and-"
"compac- tion. The copy-and-compaction scheme which is known as cleaning, is "
"well-suited for devices showing very good sequential write performance, "
"since free segments are served all the time for writing new data. However, "
"it suffers from cleaning overhead under high utilization. Contrarily, the "
"threaded log scheme suffers from random writes, but no cleaning process is "
"needed. F2FS adopts a hybrid scheme where the copy-and-compaction scheme is "
"adopted by default, but the policy is dynamically changed to the threaded "
"log scheme according to the file system status."
msgstr ""

#: ../../../filesystems/f2fs.rst:755
msgid ""
"In order to align F2FS with underlying flash-based storage, F2FS allocates a "
"segment in a unit of section. F2FS expects that the section size would be "
"the same as the unit size of garbage collection in FTL. Furthermore, with "
"respect to the mapping granularity in FTL, F2FS allocates each section of "
"the active logs from different zones as much as possible, since FTL can "
"write the data in the active logs into one allocation unit according to its "
"mapping granularity."
msgstr ""

#: ../../../filesystems/f2fs.rst:763
msgid "Cleaning process"
msgstr ""

#: ../../../filesystems/f2fs.rst:765
msgid ""
"F2FS does cleaning both on demand and in the background. On-demand cleaning "
"is triggered when there are not enough free segments to serve VFS calls. "
"Background cleaner is operated by a kernel thread, and triggers the cleaning "
"job when the system is idle."
msgstr ""

#: ../../../filesystems/f2fs.rst:770
msgid ""
"F2FS supports two victim selection policies: greedy and cost-benefit "
"algorithms. In the greedy algorithm, F2FS selects a victim segment having "
"the smallest number of valid blocks. In the cost-benefit algorithm, F2FS "
"selects a victim segment according to the segment age and the number of "
"valid blocks in order to address log block thrashing problem in the greedy "
"algorithm. F2FS adopts the greedy algorithm for on-demand cleaner, while "
"background cleaner adopts cost-benefit algorithm."
msgstr ""

#: ../../../filesystems/f2fs.rst:778
msgid ""
"In order to identify whether the data in the victim segment are valid or "
"not, F2FS manages a bitmap. Each bit represents the validity of a block, and "
"the bitmap is composed of a bit stream covering whole blocks in main area."
msgstr ""

#: ../../../filesystems/f2fs.rst:783
msgid "Write-hint Policy"
msgstr ""

#: ../../../filesystems/f2fs.rst:785
msgid "F2FS sets the whint all the time with the below policy."
msgstr ""

#: ../../../filesystems/f2fs.rst:788
msgid "User"
msgstr ""

#: ../../../filesystems/f2fs.rst:788
msgid "F2FS"
msgstr ""

#: ../../../filesystems/f2fs.rst:788
msgid "Block"
msgstr ""

#: ../../../filesystems/f2fs.rst:790 ../../../filesystems/f2fs.rst:791
#: ../../../filesystems/f2fs.rst:792 ../../../filesystems/f2fs.rst:793
#: ../../../filesystems/f2fs.rst:798 ../../../filesystems/f2fs.rst:799
#: ../../../filesystems/f2fs.rst:800
msgid "N/A"
msgstr ""

#: ../../../filesystems/f2fs.rst:790
msgid "META"
msgstr ""

#: ../../../filesystems/f2fs.rst:790
msgid "WRITE_LIFE_NONE|REQ_META"
msgstr ""

#: ../../../filesystems/f2fs.rst:791
msgid "HOT_NODE"
msgstr ""

#: ../../../filesystems/f2fs.rst:791 ../../../filesystems/f2fs.rst:806
msgid "WRITE_LIFE_NONE"
msgstr ""

#: ../../../filesystems/f2fs.rst:792
msgid "WARM_NODE"
msgstr ""

#: ../../../filesystems/f2fs.rst:792 ../../../filesystems/f2fs.rst:807
msgid "WRITE_LIFE_MEDIUM"
msgstr ""

#: ../../../filesystems/f2fs.rst:793
msgid "COLD_NODE"
msgstr ""

#: ../../../filesystems/f2fs.rst:793 ../../../filesystems/f2fs.rst:808
msgid "WRITE_LIFE_LONG"
msgstr ""

#: ../../../filesystems/f2fs.rst:794
msgid "ioctl(COLD)"
msgstr ""

#: ../../../filesystems/f2fs.rst:794 ../../../filesystems/f2fs.rst:798
#: ../../../filesystems/f2fs.rst:803
msgid "COLD_DATA"
msgstr ""

#: ../../../filesystems/f2fs.rst:794 ../../../filesystems/f2fs.rst:798
#: ../../../filesystems/f2fs.rst:803
msgid "WRITE_LIFE_EXTREME"
msgstr ""

#: ../../../filesystems/f2fs.rst:795
msgid "extension list"
msgstr ""

#: ../../../filesystems/f2fs.rst:795 ../../../filesystems/f2fs.rst:806
#: ../../../filesystems/f2fs.rst:807 ../../../filesystems/f2fs.rst:808
msgid "\""
msgstr ""

#: ../../../filesystems/f2fs.rst:797
msgid "-- buffered io"
msgstr ""

#: ../../../filesystems/f2fs.rst:799 ../../../filesystems/f2fs.rst:804
msgid "HOT_DATA"
msgstr ""

#: ../../../filesystems/f2fs.rst:799 ../../../filesystems/f2fs.rst:804
msgid "WRITE_LIFE_SHORT"
msgstr ""

#: ../../../filesystems/f2fs.rst:800 ../../../filesystems/f2fs.rst:805
msgid "WARM_DATA"
msgstr ""

#: ../../../filesystems/f2fs.rst:800 ../../../filesystems/f2fs.rst:805
msgid "WRITE_LIFE_NOT_SET"
msgstr ""

#: ../../../filesystems/f2fs.rst:802
msgid "-- direct io"
msgstr ""

#: ../../../filesystems/f2fs.rst:812
msgid "Fallocate(2) Policy"
msgstr ""

#: ../../../filesystems/f2fs.rst:814
msgid "The default policy follows the below POSIX rule."
msgstr ""

#: ../../../filesystems/f2fs.rst:816
msgid "Allocating disk space"
msgstr ""

#: ../../../filesystems/f2fs.rst:817
msgid ""
"The default operation (i.e., mode is zero) of fallocate() allocates the disk "
"space within the range specified by offset and len.  The file size (as "
"reported by stat(2)) will be changed if offset+len is greater than the file "
"size.  Any subregion within the range specified by offset and len that did "
"not contain data before the call will be initialized to zero.  This default "
"behavior closely resembles the behavior of the posix_fallocate(3) library "
"function, and is intended as a method of optimally implementing that "
"function."
msgstr ""

#: ../../../filesystems/f2fs.rst:826
msgid ""
"However, once F2FS receives ioctl(fd, F2FS_IOC_SET_PIN_FILE) in prior to "
"fallocate(fd, DEFAULT_MODE), it allocates on-disk block addresses having "
"zero or random data, which is useful to the below scenario where:"
msgstr ""

#: ../../../filesystems/f2fs.rst:830
msgid "create(fd)"
msgstr ""

#: ../../../filesystems/f2fs.rst:831
msgid "ioctl(fd, F2FS_IOC_SET_PIN_FILE)"
msgstr ""

#: ../../../filesystems/f2fs.rst:832
msgid "fallocate(fd, 0, 0, size)"
msgstr ""

#: ../../../filesystems/f2fs.rst:833
msgid "address = fibmap(fd, offset)"
msgstr ""

#: ../../../filesystems/f2fs.rst:834
msgid "open(blkdev)"
msgstr ""

#: ../../../filesystems/f2fs.rst:835
msgid "write(blkdev, address)"
msgstr ""

#: ../../../filesystems/f2fs.rst:838
msgid "Compression implementation"
msgstr ""

#: ../../../filesystems/f2fs.rst:840
msgid ""
"New term named cluster is defined as basic unit of compression, file can be "
"divided into multiple clusters logically. One cluster includes 4 << n (n >= "
"0) logical pages, compression size is also cluster size, each of cluster can "
"be compressed or not."
msgstr ""

#: ../../../filesystems/f2fs.rst:845
msgid ""
"In cluster metadata layout, one special block address is used to indicate a "
"cluster is a compressed one or normal one; for compressed cluster, following "
"metadata maps cluster to [1, 4 << n - 1] physical blocks, in where f2fs "
"stores data including compress header and compressed data."
msgstr ""

#: ../../../filesystems/f2fs.rst:850
msgid ""
"In order to eliminate write amplification during overwrite, F2FS only "
"support compression on write-once file, data can be compressed only when all "
"logical blocks in cluster contain valid data and compress ratio of cluster "
"data is lower than specified threshold."
msgstr ""

#: ../../../filesystems/f2fs.rst:855
msgid "To enable compression on regular inode, there are four ways:"
msgstr ""

#: ../../../filesystems/f2fs.rst:857
msgid "chattr +c file"
msgstr ""

#: ../../../filesystems/f2fs.rst:858
msgid "chattr +c dir; touch dir/file"
msgstr ""

#: ../../../filesystems/f2fs.rst:859
msgid "mount w/ -o compress_extension=ext; touch file.ext"
msgstr ""

#: ../../../filesystems/f2fs.rst:860
msgid "mount w/ -o compress_extension=*; touch any_file"
msgstr ""

#: ../../../filesystems/f2fs.rst:862
msgid "To disable compression on regular inode, there are two ways:"
msgstr ""

#: ../../../filesystems/f2fs.rst:864
msgid "chattr -c file"
msgstr ""

#: ../../../filesystems/f2fs.rst:865
msgid "mount w/ -o nocompress_extension=ext; touch file.ext"
msgstr ""

#: ../../../filesystems/f2fs.rst:867
msgid "Priority in between FS_COMPR_FL, FS_NOCOMP_FS, extensions:"
msgstr ""

#: ../../../filesystems/f2fs.rst:869
msgid ""
"compress_extension=so; nocompress_extension=zip; chattr +c dir; touch dir/"
"foo.so; touch dir/bar.zip; touch dir/baz.txt; then foo.so and baz.txt should "
"be compresse, bar.zip should be non-compressed. chattr +c dir/bar.zip can "
"enable compress on bar.zip."
msgstr ""

#: ../../../filesystems/f2fs.rst:873
msgid ""
"compress_extension=so; nocompress_extension=zip; chattr -c dir; touch dir/"
"foo.so; touch dir/bar.zip; touch dir/baz.txt; then foo.so should be "
"compresse, bar.zip and baz.txt should be non-compressed. chattr+c dir/bar."
"zip; chattr+c dir/baz.txt; can enable compress on bar.zip and baz.txt."
msgstr ""

#: ../../../filesystems/f2fs.rst:879
msgid ""
"At this point, compression feature doesn't expose compressed space to user "
"directly in order to guarantee potential data updates later to the space. "
"Instead, the main goal is to reduce data writes to flash disk as much as "
"possible, resulting in extending disk life time as well as relaxing IO "
"congestion. Alternatively, we've added "
"ioctl(F2FS_IOC_RELEASE_COMPRESS_BLOCKS) interface to reclaim compressed "
"space and show it to user after setting a special flag to the inode. Once "
"the compressed space is released, the flag will block writing data to the "
"file until either the compressed space is reserved via "
"ioctl(F2FS_IOC_RESERVE_COMPRESS_BLOCKS) or the file size is truncated to "
"zero."
msgstr ""

#: ../../../filesystems/f2fs.rst:890
msgid "Compress metadata layout::"
msgstr ""

#: ../../../filesystems/f2fs.rst:910
msgid "Compression mode"
msgstr ""

#: ../../../filesystems/f2fs.rst:912
msgid ""
"f2fs supports \"fs\" and \"user\" compression modes with "
"\"compression_mode\" mount option. With this option, f2fs provides a choice "
"to select the way how to compress the compression enabled files (refer to "
"\"Compression implementation\" section for how to enable compression on a "
"regular inode)."
msgstr ""

#: ../../../filesystems/f2fs.rst:917
msgid ""
"1) compress_mode=fs This is the default option. f2fs does automatic "
"compression in the writeback of the compression enabled files."
msgstr ""

#: ../../../filesystems/f2fs.rst:921
msgid ""
"2) compress_mode=user This disables the automatic compression and gives the "
"user discretion of choosing the target file and the timing. The user can do "
"manual compression/decompression on the compression enabled files using "
"F2FS_IOC_DECOMPRESS_FILE and F2FS_IOC_COMPRESS_FILE ioctls like the below."
msgstr ""

#: ../../../filesystems/f2fs.rst:927
msgid "To decompress a file,"
msgstr ""

#: ../../../filesystems/f2fs.rst:929
msgid ""
"fd = open(filename, O_WRONLY, 0); ret = ioctl(fd, F2FS_IOC_DECOMPRESS_FILE);"
msgstr ""

#: ../../../filesystems/f2fs.rst:932
msgid "To compress a file,"
msgstr ""

#: ../../../filesystems/f2fs.rst:934
msgid ""
"fd = open(filename, O_WRONLY, 0); ret = ioctl(fd, F2FS_IOC_COMPRESS_FILE);"
msgstr ""

#: ../../../filesystems/f2fs.rst:938
msgid "NVMe Zoned Namespace devices"
msgstr ""

#: ../../../filesystems/f2fs.rst:940
msgid ""
"ZNS defines a per-zone capacity which can be equal or less than the zone-"
"size. Zone-capacity is the number of usable blocks in the zone. F2FS checks "
"if zone-capacity is less than zone-size, if it is, then any segment which "
"starts after the zone-capacity is marked as not-free in the free segment "
"bitmap at initial mount time. These segments are marked as permanently used "
"so they are not allocated for writes and consequently are not needed to be "
"garbage collected. In case the zone-capacity is not aligned to default "
"segment size(2MB), then a segment can start before the zone-capacity and "
"span across zone-capacity boundary. Such spanning segments are also "
"considered as usable segments. All blocks past the zone-capacity are "
"considered unusable in these segments."
msgstr ""

#: ../../../filesystems/f2fs.rst:953
msgid "Device aliasing feature"
msgstr ""

#: ../../../filesystems/f2fs.rst:955
msgid ""
"f2fs can utilize a special file called a \"device aliasing file.\" This file "
"allows the entire storage device to be mapped with a single, large extent, "
"not using the usual f2fs node structures. This mapped area is pinned and "
"primarily intended for holding the space."
msgstr ""

#: ../../../filesystems/f2fs.rst:960
msgid ""
"Essentially, this mechanism allows a portion of the f2fs area to be "
"temporarily reserved and used by another filesystem or for different "
"purposes. Once that external usage is complete, the device aliasing file can "
"be deleted, releasing the reserved space back to F2FS for its own use."
msgstr ""

#: ../../../filesystems/f2fs.rst:965
msgid "<use-case>"
msgstr ""

#: ../../../filesystems/f2fs.rst:967
msgid ""
"# ls /dev/vd* /dev/vdb (32GB) /dev/vdc (32GB) # mkfs.ext4 /dev/vdc # mkfs."
"f2fs -c /dev/vdc@vdc.file /dev/vdb # mount /dev/vdb /mnt/f2fs # ls -l /mnt/"
"f2fs vdc.file # df -h /dev/vdb                            64G   33G   32G  "
"52% /mnt/f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:977
msgid ""
"# mount -o loop /dev/vdc /mnt/ext4 # df -h /dev/"
"vdb                            64G   33G   32G  52% /mnt/f2fs /dev/"
"loop7                          32G   24K   30G   1% /mnt/ext4 # umount /mnt/"
"ext4"
msgstr ""

#: ../../../filesystems/f2fs.rst:983
msgid ""
"# f2fs_io getflags /mnt/f2fs/vdc.file get a flag on /mnt/f2fs/vdc.file "
"ret=0, flags=nocow(pinned),immutable # f2fs_io setflags noimmutable /mnt/"
"f2fs/vdc.file get a flag on noimmutable ret=0, flags=800010 set a flag on /"
"mnt/f2fs/vdc.file ret=0, flags=noimmutable # rm /mnt/f2fs/vdc.file # df -h /"
"dev/vdb                            64G  753M   64G   2% /mnt/f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:992
msgid ""
"So, the key idea is, user can do any file operations on /dev/vdc, and "
"reclaim the space after the use, while the space is counted as /data. That "
"doesn't require modifying partition size and filesystem format."
msgstr ""
