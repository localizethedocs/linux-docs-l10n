# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/inotify.rst:5
msgid "Inotify - A Powerful yet Simple File Change Notification System"
msgstr ""

#: ../../../filesystems/inotify.rst:9
msgid "Document started 15 Mar 2005 by Robert Love <rml@novell.com>"
msgstr ""

#: ../../../filesystems/inotify.rst:11
msgid "Document updated 4 Jan 2015 by Zhang Zhen <zhenzhang.zhang@huawei.com>"
msgstr ""

#: ../../../filesystems/inotify.rst:13
msgid "Deleted obsoleted interface, just refer to manpages for user interface."
msgstr ""

#: ../../../filesystems/inotify.rst:15
msgid "Rationale"
msgstr ""

#: ../../../filesystems/inotify.rst:17 ../../../filesystems/inotify.rst:28
#: ../../../filesystems/inotify.rst:77
msgid "Q:"
msgstr ""

#: ../../../filesystems/inotify.rst:18
msgid ""
"What is the design decision behind not tying the watch to the open fd of the "
"watched object?"
msgstr ""

#: ../../../filesystems/inotify.rst:21 ../../../filesystems/inotify.rst:32
#: ../../../filesystems/inotify.rst:80
msgid "A:"
msgstr ""

#: ../../../filesystems/inotify.rst:22
msgid ""
"Watches are associated with an open inotify device, not an open file. This "
"solves the primary problem with dnotify: keeping the file open pins the file "
"and thus, worse, pins the mount.  Dnotify is therefore infeasible for use on "
"a desktop system with removable media as the media cannot be unmounted.  "
"Watching a file should not require that it be open."
msgstr ""

#: ../../../filesystems/inotify.rst:29
msgid ""
"What is the design decision behind using an-fd-per-instance as opposed to an "
"fd-per-watch?"
msgstr ""

#: ../../../filesystems/inotify.rst:33
msgid ""
"An fd-per-watch quickly consumes more file descriptors than are allowed, "
"more fd's than are feasible to manage, and more fd's than are optimally "
"select()-able.  Yes, root can bump the per-process fd limit and yes, users "
"can use epoll, but requiring both is a silly and extraneous requirement. A "
"watch consumes less memory than an open file, separating the number spaces "
"is thus sensible.  The current design is what user-space developers want: "
"Users initialize inotify, once, and add n watches, requiring but one fd and "
"no twiddling with fd limits.  Initializing an inotify instance two thousand "
"times is silly.  If we can implement user-space's preferences cleanly--and "
"we can, the idr layer makes stuff like this trivial--then we should."
msgstr ""

#: ../../../filesystems/inotify.rst:45
msgid ""
"There are other good arguments.  With a single fd, there is a single item to "
"block on, which is mapped to a single queue of events.  The single fd "
"returns all watch events and also any potential out-of-band data.  If every "
"fd was a separate watch,"
msgstr ""

#: ../../../filesystems/inotify.rst:50
msgid ""
"There would be no way to get event ordering.  Events on file foo and file "
"bar would pop poll() on both fd's, but there would be no way to tell which "
"happened first.  A single queue trivially gives you ordering.  Such ordering "
"is crucial to existing applications such as Beagle.  Imagine \"mv a b ; mv b "
"a\" events without ordering."
msgstr ""

#: ../../../filesystems/inotify.rst:56
msgid ""
"We'd have to maintain n fd's and n internal queues with state, versus just "
"one.  It is a lot messier in the kernel.  A single, linear queue is the data "
"structure that makes sense."
msgstr ""

#: ../../../filesystems/inotify.rst:60
msgid ""
"User-space developers prefer the current API.  The Beagle guys, for example, "
"love it.  Trust me, I asked.  It is not a surprise: Who'd want to manage and "
"block on 1000 fd's via select?"
msgstr ""

#: ../../../filesystems/inotify.rst:64
msgid "No way to get out of band data."
msgstr ""

#: ../../../filesystems/inotify.rst:66
msgid "1024 is still too low.  ;-)"
msgstr ""

#: ../../../filesystems/inotify.rst:68
msgid ""
"When you talk about designing a file change notification system that scales "
"to 1000s of directories, juggling 1000s of fd's just does not seem the right "
"interface.  It is too heavy."
msgstr ""

#: ../../../filesystems/inotify.rst:72
msgid ""
"Additionally, it _is_ possible to  more than one instance  and juggle more "
"than one queue and thus more than one associated fd.  There need not be a "
"one-fd-per-process mapping; it is one-fd-per-queue and a process can easily "
"want more than one queue."
msgstr ""

#: ../../../filesystems/inotify.rst:78
msgid "Why the system call approach?"
msgstr ""

#: ../../../filesystems/inotify.rst:81
msgid ""
"The poor user-space interface is the second biggest problem with dnotify. "
"Signals are a terrible, terrible interface for file notification.  Or for "
"anything, for that matter.  The ideal solution, from all perspectives, is a "
"file descriptor-based one that allows basic file I/O and poll/select. "
"Obtaining the fd and managing the watches could have been done either via a "
"device file or a family of new system calls.  We decided to implement a "
"family of system calls because that is the preferred approach for new kernel "
"interfaces.  The only real difference was whether we wanted to use open(2) "
"and ioctl(2) or a couple of new system calls.  System calls beat ioctls."
msgstr ""
