# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/fuse-passthrough.rst:5
msgid "FUSE Passthrough"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:8
msgid "Introduction"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:10
msgid ""
"FUSE (Filesystem in Userspace) passthrough is a feature designed to improve "
"the performance of FUSE filesystems for I/O operations. Typically, FUSE "
"operations involve communication between the kernel and a userspace FUSE "
"daemon, which can incur overhead. Passthrough allows certain operations on a "
"FUSE file to bypass the userspace daemon and be executed directly by the "
"kernel on an underlying \"backing file\"."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:17
msgid ""
"This is achieved by the FUSE daemon registering a file descriptor (pointing "
"to the backing file on a lower filesystem) with the FUSE kernel module. The "
"kernel then receives an identifier (``backing_id``) for this registered "
"backing file. When a FUSE file is subsequently opened, the FUSE daemon can, "
"in its response to the ``OPEN`` request, include this ``backing_id`` and set "
"the ``FOPEN_PASSTHROUGH`` flag. This establishes a direct link for specific "
"operations."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:25
msgid ""
"Currently, passthrough is supported for operations like ``read(2)``/"
"``write(2)`` (via ``read_iter``/``write_iter``), ``splice(2)``, and "
"``mmap(2)``."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:29
msgid "Enabling Passthrough"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:31
msgid "To use FUSE passthrough:"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:33
msgid ""
"The FUSE filesystem must be compiled with ``CONFIG_FUSE_PASSTHROUGH`` "
"enabled."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:35
msgid ""
"The FUSE daemon, during the ``FUSE_INIT`` handshake, must negotiate the "
"``FUSE_PASSTHROUGH`` capability and specify its desired ``max_stack_depth``."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:38
msgid ""
"The (privileged) FUSE daemon uses the ``FUSE_DEV_IOC_BACKING_OPEN`` ioctl on "
"its connection file descriptor (e.g., ``/dev/fuse``) to register a backing "
"file descriptor and obtain a ``backing_id``."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:41
msgid ""
"When handling an ``OPEN`` or ``CREATE`` request for a FUSE file, the daemon "
"replies with the ``FOPEN_PASSTHROUGH`` flag set in ``fuse_open_out::"
"open_flags`` and provides the corresponding ``backing_id`` in "
"``fuse_open_out::backing_id``."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:45
msgid ""
"The FUSE daemon should eventually call ``FUSE_DEV_IOC_BACKING_CLOSE`` with "
"the ``backing_id`` to release the kernel's reference to the backing file "
"when it's no longer needed for passthrough setups."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:50
msgid "Privilege Requirements"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:52
msgid ""
"Setting up passthrough functionality currently requires the FUSE daemon to "
"possess the ``CAP_SYS_ADMIN`` capability. This requirement stems from "
"several security and resource management considerations that are actively "
"being discussed and worked on. The primary reasons for this restriction are "
"detailed below."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:59
msgid "Resource Accounting and Visibility"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:61
msgid ""
"The core mechanism for passthrough involves the FUSE daemon opening a file "
"descriptor to a backing file and registering it with the FUSE kernel module "
"via the ``FUSE_DEV_IOC_BACKING_OPEN`` ioctl. This ioctl returns a "
"``backing_id`` associated with a kernel-internal ``struct fuse_backing`` "
"object, which holds a reference to the backing ``struct file``."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:67
msgid ""
"A significant concern arises because the FUSE daemon can close its own file "
"descriptor to the backing file after registration. The kernel, however, will "
"still hold a reference to the ``struct file`` via the ``struct "
"fuse_backing`` object as long as it's associated with a ``backing_id`` (or "
"subsequently, with an open FUSE file in passthrough mode)."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:73
msgid "This behavior leads to two main issues for unprivileged FUSE daemons:"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:75
msgid ""
"**Invisibility to lsof and other inspection tools**: Once the FUSE daemon "
"closes its file descriptor, the open backing file held by the kernel becomes "
"\"hidden.\" Standard tools like ``lsof``, which typically inspect process "
"file descriptor tables, would not be able to identify that this file is "
"still open by the system on behalf of the FUSE filesystem. This makes it "
"difficult for system administrators to track resource usage or debug issues "
"related to open files (e.g., preventing unmounts)."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:83
msgid ""
"**Bypassing RLIMIT_NOFILE**: The FUSE daemon process is subject to resource "
"limits, including the maximum number of open file descriptors "
"(``RLIMIT_NOFILE``). If an unprivileged daemon could register backing files "
"and then close its own FDs, it could potentially cause the kernel to hold an "
"unlimited number of open ``struct file`` references without these being "
"accounted against the daemon's ``RLIMIT_NOFILE``. This could lead to a "
"denial-of-service (DoS) by exhausting system-wide file resources."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:91
msgid ""
"The ``CAP_SYS_ADMIN`` requirement acts as a safeguard against these issues, "
"restricting this powerful capability to trusted processes."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:94
msgid ""
"**NOTE**: ``io_uring`` solves this similar issue by exposing its \"fixed "
"files\", which are visible via ``fdinfo`` and accounted under the "
"registering user's ``RLIMIT_NOFILE``."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:99
msgid "Filesystem Stacking and Shutdown Loops"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:101
msgid ""
"Another concern relates to the potential for creating complex and "
"problematic filesystem stacking scenarios if unprivileged users could set up "
"passthrough. A FUSE passthrough filesystem might use a backing file that "
"resides:"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:105
msgid "On the *same* FUSE filesystem."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:106
msgid ""
"On another filesystem (like OverlayFS) which itself might have an upper or "
"lower layer that is a FUSE filesystem."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:109
msgid ""
"These configurations could create dependency loops, particularly during "
"filesystem shutdown or unmount sequences, leading to deadlocks or system "
"instability. This is conceptually similar to the risks associated with the "
"``LOOP_SET_FD`` ioctl, which also requires ``CAP_SYS_ADMIN``."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:114
msgid ""
"To mitigate this, FUSE passthrough already incorporates checks based on "
"filesystem stacking depth (``sb->s_stack_depth`` and ``fc-"
">max_stack_depth``). For example, during the ``FUSE_INIT`` handshake, the "
"FUSE daemon can negotiate the ``max_stack_depth`` it supports. When a "
"backing file is registered via ``FUSE_DEV_IOC_BACKING_OPEN``, the kernel "
"checks if the backing file's filesystem stack depth is within the allowed "
"limit."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:121
msgid ""
"The ``CAP_SYS_ADMIN`` requirement provides an additional layer of security, "
"ensuring that only privileged users can create these potentially complex "
"stacking arrangements."
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:126
msgid "General Security Posture"
msgstr ""

#: ../../../filesystems/fuse-passthrough.rst:128
msgid ""
"As a general principle for new kernel features that allow userspace to "
"instruct the kernel to perform direct operations on its behalf based on user-"
"provided file descriptors, starting with a higher privilege requirement "
"(like ``CAP_SYS_ADMIN``) is a conservative and common security practice. "
"This allows the feature to be used and tested while further security "
"implications are evaluated and addressed."
msgstr ""
