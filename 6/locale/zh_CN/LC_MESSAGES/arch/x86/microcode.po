# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/microcode.rst:5
msgid "The Linux Microcode Loader"
msgstr ""

#: ../../../arch/x86/microcode.rst:0
msgid "Authors"
msgstr ""

#: ../../../arch/x86/microcode.rst:7
msgid "Fenghua Yu <fenghua.yu@intel.com>"
msgstr ""

#: ../../../arch/x86/microcode.rst:8
msgid "Borislav Petkov <bp@suse.de>"
msgstr ""

#: ../../../arch/x86/microcode.rst:9
msgid "Ashok Raj <ashok.raj@intel.com>"
msgstr ""

#: ../../../arch/x86/microcode.rst:11
msgid ""
"The kernel has a x86 microcode loading facility which is supposed to provide "
"microcode loading methods in the OS. Potential use cases are updating the "
"microcode on platforms beyond the OEM End-Of-Life support, and updating the "
"microcode on long-running systems without rebooting."
msgstr ""

#: ../../../arch/x86/microcode.rst:16
msgid "The loader supports three loading methods:"
msgstr ""

#: ../../../arch/x86/microcode.rst:19
msgid "Early load microcode"
msgstr ""

#: ../../../arch/x86/microcode.rst:21
msgid ""
"The kernel can update microcode very early during boot. Loading microcode "
"early can fix CPU issues before they are observed during kernel boot time."
msgstr ""

#: ../../../arch/x86/microcode.rst:25
msgid ""
"The microcode is stored in an initrd file. During boot, it is read from it "
"and loaded into the CPU cores."
msgstr ""

#: ../../../arch/x86/microcode.rst:28
msgid ""
"The format of the combined initrd image is microcode in (uncompressed) cpio "
"format followed by the (possibly compressed) initrd image. The loader parses "
"the combined initrd image during boot."
msgstr ""

#: ../../../arch/x86/microcode.rst:32
msgid "The microcode files in cpio name space are:"
msgstr ""

#: ../../../arch/x86/microcode.rst:34
msgid "on Intel:"
msgstr ""

#: ../../../arch/x86/microcode.rst:35
msgid "kernel/x86/microcode/GenuineIntel.bin"
msgstr ""

#: ../../../arch/x86/microcode.rst:36
msgid "on AMD  :"
msgstr ""

#: ../../../arch/x86/microcode.rst:37
msgid "kernel/x86/microcode/AuthenticAMD.bin"
msgstr ""

#: ../../../arch/x86/microcode.rst:39
msgid ""
"During BSP (BootStrapping Processor) boot (pre-SMP), the kernel scans the "
"microcode file in the initrd. If microcode matching the CPU is found, it "
"will be applied in the BSP and later on in all APs (Application Processors)."
msgstr ""

#: ../../../arch/x86/microcode.rst:44
msgid ""
"The loader also saves the matching microcode for the CPU in memory. Thus, "
"the cached microcode patch is applied when CPUs resume from a sleep state."
msgstr ""

#: ../../../arch/x86/microcode.rst:48
msgid ""
"Here's a crude example how to prepare an initrd with microcode (this is "
"normally done automatically by the distribution, when recreating the initrd, "
"so you don't really have to do it yourself. It is documented here for future "
"reference only). ::"
msgstr ""

#: ../../../arch/x86/microcode.rst:88
msgid ""
"The system needs to have the microcode packages installed into /lib/firmware "
"or you need to fixup the paths above if yours are somewhere else and/or "
"you've downloaded them directly from the processor vendor's site."
msgstr ""

#: ../../../arch/x86/microcode.rst:94
msgid "Late loading"
msgstr ""

#: ../../../arch/x86/microcode.rst:96
msgid ""
"You simply install the microcode packages your distro supplies and run::"
msgstr ""

#: ../../../arch/x86/microcode.rst:101
msgid "as root."
msgstr ""

#: ../../../arch/x86/microcode.rst:103
msgid ""
"The loading mechanism looks for microcode blobs in /lib/firmware/{intel-"
"ucode,amd-ucode}. The default distro installation packages already put them "
"there."
msgstr ""

#: ../../../arch/x86/microcode.rst:107
msgid "Since kernel 5.19, late loading is not enabled by default."
msgstr ""

#: ../../../arch/x86/microcode.rst:109
msgid "The /dev/cpu/microcode method has been removed in 5.19."
msgstr ""

#: ../../../arch/x86/microcode.rst:112
msgid "Why is late loading dangerous?"
msgstr ""

#: ../../../arch/x86/microcode.rst:115
msgid "Synchronizing all CPUs"
msgstr ""

#: ../../../arch/x86/microcode.rst:117
msgid ""
"The microcode engine which receives the microcode update is shared between "
"the two logical threads in a SMT system. Therefore, when the update is "
"executed on one SMT thread of the core, the sibling \"automatically\" gets "
"the update."
msgstr ""

#: ../../../arch/x86/microcode.rst:122
msgid ""
"Since the microcode can \"simulate\" MSRs too, while the microcode update is "
"in progress, those simulated MSRs transiently cease to exist. This can "
"result in unpredictable results if the SMT sibling thread happens to be in "
"the middle of an access to such an MSR. The usual observation is that such "
"MSR accesses cause #GPs to be raised to signal that former are not present."
msgstr ""

#: ../../../arch/x86/microcode.rst:129
msgid ""
"The disappearing MSRs are just one common issue which is being observed. Any "
"other instruction that's being patched and gets concurrently executed by the "
"other SMT sibling, can also result in similar, unpredictable behavior."
msgstr ""

#: ../../../arch/x86/microcode.rst:134
msgid ""
"To eliminate this case, a stop_machine()-based CPU synchronization was "
"introduced as a way to guarantee that all logical CPUs will not execute any "
"code but just wait in a spin loop, polling an atomic variable."
msgstr ""

#: ../../../arch/x86/microcode.rst:138
msgid ""
"While this took care of device or external interrupts, IPIs including LVT "
"ones, such as CMCI etc, it cannot address other special interrupts that "
"can't be shut off. Those are Machine Check (#MC), System Management (#SMI) "
"and Non-Maskable interrupts (#NMI)."
msgstr ""

#: ../../../arch/x86/microcode.rst:144
msgid "Machine Checks"
msgstr ""

#: ../../../arch/x86/microcode.rst:146
msgid ""
"Machine Checks (#MC) are non-maskable. There are two kinds of MCEs. Fatal un-"
"recoverable MCEs and recoverable MCEs. While un-recoverable errors are "
"fatal, recoverable errors can also happen in kernel context are also treated "
"as fatal by the kernel."
msgstr ""

#: ../../../arch/x86/microcode.rst:151
msgid ""
"On certain Intel machines, MCEs are also broadcast to all threads in a "
"system. If one thread is in the middle of executing WRMSR, a MCE will be "
"taken at the end of the flow. Either way, they will wait for the thread "
"performing the wrmsr(0x79) to rendezvous in the MCE handler and shutdown "
"eventually if any of the threads in the system fail to check in to the MCE "
"rendezvous."
msgstr ""

#: ../../../arch/x86/microcode.rst:158
msgid ""
"To be paranoid and get predictable behavior, the OS can choose to set "
"MCG_STATUS.MCIP. Since MCEs can be at most one in a system, if an MCE was "
"signaled, the above condition will promote to a system reset automatically. "
"OS can turn off MCIP at the end of the update for that core."
msgstr ""

#: ../../../arch/x86/microcode.rst:165
msgid "System Management Interrupt"
msgstr ""

#: ../../../arch/x86/microcode.rst:167
msgid ""
"SMIs are also broadcast to all CPUs in the platform. Microcode update "
"requests exclusive access to the core before writing to MSR 0x79. So if it "
"does happen such that, one thread is in WRMSR flow, and the 2nd got an SMI, "
"that thread will be stopped in the first instruction in the SMI handler."
msgstr ""

#: ../../../arch/x86/microcode.rst:173
msgid ""
"Since the secondary thread is stopped in the first instruction in SMI, there "
"is very little chance that it would be in the middle of executing an "
"instruction being patched. Plus OS has no way to stop SMIs from happening."
msgstr ""

#: ../../../arch/x86/microcode.rst:179
msgid "Non-Maskable Interrupts"
msgstr ""

#: ../../../arch/x86/microcode.rst:181
msgid ""
"When thread0 of a core is doing the microcode update, if thread1 is pulled "
"into NMI, that can cause unpredictable behavior due to the reasons above."
msgstr ""

#: ../../../arch/x86/microcode.rst:185
msgid ""
"OS can choose a variety of methods to avoid running into this situation."
msgstr ""

#: ../../../arch/x86/microcode.rst:189
msgid "Is the microcode suitable for late loading?"
msgstr ""

#: ../../../arch/x86/microcode.rst:191
msgid ""
"Late loading is done when the system is fully operational and running real "
"workloads. Late loading behavior depends on what the base patch on the CPU "
"is before upgrading to the new patch."
msgstr ""

#: ../../../arch/x86/microcode.rst:195
msgid "This is true for Intel CPUs."
msgstr ""

#: ../../../arch/x86/microcode.rst:197
msgid ""
"Consider, for example, a CPU has patch level 1 and the update is to patch "
"level 3."
msgstr ""

#: ../../../arch/x86/microcode.rst:200
msgid ""
"Between patch1 and patch3, patch2 might have deprecated a software-visible "
"feature."
msgstr ""

#: ../../../arch/x86/microcode.rst:203
msgid ""
"This is unacceptable if software is even potentially using that feature. For "
"instance, say MSR_X is no longer available after an update, accessing that "
"MSR will cause a #GP fault."
msgstr ""

#: ../../../arch/x86/microcode.rst:207
msgid ""
"Basically there is no way to declare a new microcode update suitable for "
"late-loading. This is another one of the problems that caused late loading "
"to be not enabled by default."
msgstr ""

#: ../../../arch/x86/microcode.rst:212
msgid "Builtin microcode"
msgstr ""

#: ../../../arch/x86/microcode.rst:214
msgid ""
"The loader supports also loading of a builtin microcode supplied through the "
"regular builtin firmware method CONFIG_EXTRA_FIRMWARE. Only 64-bit is "
"currently supported."
msgstr ""

#: ../../../arch/x86/microcode.rst:218
msgid "Here's an example::"
msgstr ""

#: ../../../arch/x86/microcode.rst:223
msgid "This basically means, you have the following tree structure locally::"
msgstr ""

#: ../../../arch/x86/microcode.rst:235
msgid ""
"so that the build system can find those files and integrate them into the "
"final kernel image. The early loader finds them and applies them."
msgstr ""

#: ../../../arch/x86/microcode.rst:238
msgid ""
"Needless to say, this method is not the most flexible one because it "
"requires rebuilding the kernel each time updated microcode from the CPU "
"vendor is available."
msgstr ""
