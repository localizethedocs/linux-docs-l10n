# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/amd-memory-encryption.rst:5
msgid "AMD Memory Encryption"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:7
msgid ""
"Secure Memory Encryption (SME) and Secure Encrypted Virtualization (SEV) are "
"features found on AMD processors."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:10
msgid ""
"SME provides the ability to mark individual pages of memory as encrypted "
"using the standard x86 page tables.  A page that is marked encrypted will be "
"automatically decrypted when read from DRAM and encrypted when written to "
"DRAM.  SME can therefore be used to protect the contents of DRAM from "
"physical attacks on the system."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:16
msgid ""
"SEV enables running encrypted virtual machines (VMs) in which the code and "
"data of the guest VM are secured so that a decrypted version is available "
"only within the VM itself. SEV guest VMs have the concept of private and "
"shared memory. Private memory is encrypted with the guest-specific key, "
"while shared memory may be encrypted with hypervisor key. When SME is "
"enabled, the hypervisor key is the same key which is used in SME."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:23
msgid ""
"A page is encrypted when a page table entry has the encryption bit set (see "
"below on how to determine its position).  The encryption bit can also be "
"specified in the cr3 register, allowing the PGD table to be encrypted. Each "
"successive level of page tables can also be encrypted by setting the "
"encryption bit in the page table entry that points to the next table. This "
"allows the full page table hierarchy to be encrypted. Note, this means that "
"just because the encryption bit is set in cr3, doesn't imply the full "
"hierarchy is encrypted. Each page table entry in the hierarchy needs to have "
"the encryption bit set to achieve that. So, theoretically, you could have "
"the encryption bit set in cr3 so that the PGD is encrypted, but not set the "
"encryption bit in the PGD entry for a PUD which results in the PUD pointed "
"to by that entry to not be encrypted."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:36
msgid ""
"When SEV is enabled, instruction pages and guest page tables are always "
"treated as private. All the DMA operations inside the guest must be "
"performed on shared memory. Since the memory encryption bit is controlled by "
"the guest OS when it is operating in 64-bit or 32-bit PAE mode, in all other "
"modes the SEV hardware forces the memory encryption bit to 1."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:42
msgid ""
"Support for SME and SEV can be determined through the CPUID instruction. The "
"CPUID function 0x8000001f reports information related to SME::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:56
msgid ""
"If support for SME is present, MSR 0xc00100010 (MSR_AMD64_SYSCFG) can be "
"used to determine if SME is enabled and/or to enable memory encryption::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:63
msgid ""
"If SEV is supported, MSR 0xc0010131 (MSR_AMD64_SEV) can be used to determine "
"if SEV is active::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:70
msgid ""
"Linux relies on BIOS to set this bit if BIOS has determined that the "
"reduction in the physical address space as a result of enabling memory "
"encryption (see CPUID information above) will not conflict with the address "
"space resource requirements for the system.  If this bit is not set upon "
"Linux startup then Linux itself will not set it and memory encryption will "
"not be possible."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:76
msgid "The state of SME in the Linux kernel can be documented as follows:"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:78
msgid "Supported: The CPU supports SME (determined through CPUID instruction)."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:81
msgid "Enabled: Supported and bit 23 of MSR_AMD64_SYSCFG is set."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:84
msgid ""
"Active: Supported, Enabled and the Linux kernel is actively applying the "
"encryption bit to page table entries (the SME mask in the kernel is non-"
"zero)."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:89
msgid ""
"SME can also be enabled and activated in the BIOS. If SME is enabled and "
"activated in the BIOS, then all memory accesses will be encrypted and it "
"will not be necessary to activate the Linux memory encryption support."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:93
msgid ""
"If the BIOS merely enables SME (sets bit 23 of the MSR_AMD64_SYSCFG), then "
"memory encryption can be enabled by supplying mem_encrypt=on on the kernel "
"command line.  However, if BIOS does not enable SME, then Linux will not be "
"able to activate memory encryption, even if configured to do so by default "
"or the mem_encrypt=on command line parameter is specified."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:100
msgid "Secure Nested Paging (SNP)"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:102
msgid ""
"SEV-SNP introduces new features (SEV_FEATURES[1:63]) which can be enabled by "
"the hypervisor for security enhancements. Some of these features need guest "
"side implementation to function correctly. The below table lists the "
"expected guest behavior with various possible scenarios of guest/hypervisor "
"SNP feature support."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:109
msgid "Feature Enabled by the HV"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:109
msgid "Guest needs implementation"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:109
msgid "Guest has implementation"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:109
msgid "Guest boot behaviour"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:112
#: ../../../arch/x86/amd-memory-encryption.rst:115
#: ../../../arch/x86/amd-memory-encryption.rst:118
#: ../../../arch/x86/amd-memory-encryption.rst:121
#: ../../../arch/x86/amd-memory-encryption.rst:124
msgid "No"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:112
#: ../../../arch/x86/amd-memory-encryption.rst:115
#: ../../../arch/x86/amd-memory-encryption.rst:118
msgid "Boot"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:115
#: ../../../arch/x86/amd-memory-encryption.rst:118
#: ../../../arch/x86/amd-memory-encryption.rst:121
#: ../../../arch/x86/amd-memory-encryption.rst:124
#: ../../../arch/x86/amd-memory-encryption.rst:127
msgid "Yes"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:121
#: ../../../arch/x86/amd-memory-encryption.rst:127
msgid "Boot with feature enabled"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:124
msgid "Graceful boot failure"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:131
msgid "More details in AMD64 APM[1] Vol 2: 15.34.10 SEV_STATUS MSR"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:134
msgid "Reverse Map Table (RMP)"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:136
msgid ""
"The RMP is a structure in system memory that is used to ensure a one-to-one "
"mapping between system physical addresses and guest physical addresses. Each "
"page of memory that is potentially assignable to guests has one entry within "
"the RMP."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:141
msgid ""
"The RMP table can be either contiguous in memory or a collection of segments "
"in memory."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:145
msgid "Contiguous RMP"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:147
msgid ""
"Support for this form of the RMP is present when support for SEV-SNP is "
"present, which can be determined using the CPUID instruction::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:153
msgid ""
"The location of the RMP is identified to the hardware through two MSRs::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:161
msgid ""
"Hardware requires that RMP_BASE and (RPM_END + 1) be 8KB aligned, but SEV "
"firmware increases the alignment requirement to require a 1MB alignment."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:164
msgid ""
"The RMP consists of a 16KB region used for processor bookkeeping followed by "
"the RMP entries, which are 16 bytes in size. The size of the RMP determines "
"the range of physical memory that the hypervisor can assign to SEV-SNP "
"guests. The RMP covers the system physical address from::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:171
msgid ""
"The current Linux support relies on BIOS to allocate/reserve the memory for "
"the RMP and to set RMP_BASE and RMP_END appropriately. Linux uses the MSR "
"values to locate the RMP and determine the size of the RMP. The RMP must "
"cover all of system memory in order for Linux to enable SEV-SNP."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:177
msgid "Segmented RMP"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:179
msgid ""
"Segmented RMP support is a new way of representing the layout of an RMP. "
"Initial RMP support required the RMP table to be contiguous in memory. RMP "
"accesses from a NUMA node on which the RMP doesn't reside can take longer "
"than accesses from a NUMA node on which the RMP resides. Segmented RMP "
"support allows the RMP entries to be located on the same node as the memory "
"the RMP is covering, potentially reducing latency associated with accessing "
"an RMP entry associated with the memory. Each RMP segment covers a specific "
"range of system physical addresses."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:188
msgid ""
"Support for this form of the RMP can be determined using the CPUID "
"instruction::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:194
msgid ""
"If supported, segmented RMP attributes can be found using the CPUID "
"instruction::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:206
msgid "To enable a segmented RMP, a new MSR is available::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:213
msgid ""
"The RMP segment size defined in the RMP_CFG MSR applies to all segments of "
"the RMP. Therefore each RMP segment covers a specific range of system "
"physical addresses. For example, if the RMP_CFG MSR value is 0x2401, then "
"the RMP segment coverage value is 0x24 => 36, meaning the size of memory "
"covered by an RMP segment is 64GB (1 << 36). So the first RMP segment covers "
"physical addresses from 0 to 0xF_FFFF_FFFF, the second RMP segment covers "
"physical addresses from 0x10_0000_0000 to 0x1F_FFFF_FFFF, etc."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:221
msgid ""
"When a segmented RMP is enabled, RMP_BASE points to the RMP bookkeeping area "
"as it does today (16K in size). However, instead of RMP entries beginning "
"immediately after the bookkeeping area, there is a 4K RMP segment table "
"(RST). Each entry in the RST is 8-bytes in size and represents an RMP "
"segment::"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:236
msgid ""
"The RST can hold 512 segment entries but can be limited in size to the "
"number of cacheable RMP segments (CPUID 0x80000025_EBX[9:0]) if the number "
"of cacheable RMP segments is a hard limit (CPUID 0x80000025_EBX[10])."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:240
msgid ""
"The current Linux support relies on BIOS to allocate/reserve the memory for "
"the segmented RMP (the bookkeeping area, RST, and all segments), build the "
"RST and to set RMP_BASE, RMP_END, and RMP_CFG appropriately. Linux uses the "
"MSR values to locate the RMP and determine the size and location of the RMP "
"segments. The RMP must cover all of system memory in order for Linux to "
"enable SEV-SNP."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:247
msgid ""
"More details in the AMD64 APM Vol 2, section \"15.36.3 Reverse Map Table\", "
"docID: 24593."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:251
msgid "Secure VM Service Module (SVSM)"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:253
msgid ""
"SNP provides a feature called Virtual Machine Privilege Levels (VMPL) which "
"defines four privilege levels at which guest software can run. The most "
"privileged level is 0 and numerically higher numbers have lesser privileges. "
"More details in the AMD64 APM Vol 2, section \"15.35.7 Virtual Machine "
"Privilege Levels\", docID: 24593."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:259
msgid ""
"When using that feature, different services can run at different protection "
"levels, apart from the guest OS but still within the secure SNP environment. "
"They can provide services to the guest, like a vTPM, for example."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:263
msgid ""
"When a guest is not running at VMPL0, it needs to communicate with the "
"software running at VMPL0 to perform privileged operations or to interact "
"with secure services. An example fur such a privileged operation is "
"PVALIDATE which is *required* to be executed at VMPL0."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:268
msgid ""
"In this scenario, the software running at VMPL0 is usually called a Secure "
"VM Service Module (SVSM). Discovery of an SVSM and the API used to "
"communicate with it is documented in \"Secure VM Service Module for SEV-SNP "
"Guests\", docID: 58019."
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:273
msgid ""
"(Latest versions of the above-mentioned documents can be found by using a "
"search engine like duckduckgo.com and typing in:"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:276
msgid ""
"site:amd.com \"Secure VM Service Module for SEV-SNP Guests\", docID: 58019"
msgstr ""

#: ../../../arch/x86/amd-memory-encryption.rst:278
msgid "for example.)"
msgstr ""
