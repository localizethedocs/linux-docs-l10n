# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm/nwfpe/todo.rst:2
msgid "TODO LIST"
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:20
msgid ""
"These are not implemented.  They are not currently issued by the compiler, "
"and are handled by routines in libc.  These are not implemented by the FPA11 "
"hardware, but are handled by the floating point support code.  They should "
"be implemented in future versions."
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:25
msgid ""
"There are a couple of ways to approach the implementation of these.  One "
"method would be to use accurate table methods for these routines.  I have a "
"couple of papers by S. Gal from IBM's research labs in Haifa, Israel that "
"seem to promise extreme accuracy (in the order of 99.8%) and reasonable "
"speed. These methods are used in GLIBC for some of the transcendental "
"functions."
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:31
msgid ""
"Another approach, which I know little about is CORDIC.  This stands for "
"Coordinate Rotation Digital Computer, and is a method of computing "
"transcendental functions using mostly shifts and adds and a few "
"multiplications and divisions.  The ARM excels at shifts and adds, so such a "
"method could be promising, but requires more research to determine if it is "
"feasible."
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:39
msgid "Rounding Methods"
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:41
msgid ""
"The IEEE standard defines 4 rounding modes.  Round to nearest is the "
"default, but rounding to + or - infinity or round to zero are also allowed. "
"Many architectures allow the rounding mode to be specified by modifying bits "
"in a control register.  Not so with the ARM FPA11 architecture.  To change "
"the rounding mode one must specify it with each instruction."
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:47
msgid ""
"This has made porting some benchmarks difficult.  It is possible to "
"introduce such a capability into the emulator.  The FPCR contains bits "
"describing the rounding mode.  The emulator could be altered to examine a "
"flag, which if set forced it to ignore the rounding mode in the instruction, "
"and use the mode specified in the bits in the FPCR."
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:53
msgid ""
"This would require a method of getting/setting the flag, and the bits in the "
"FPCR.  This requires a kernel call in ArmLinux, as WFC/RFC are supervisor "
"only instructions.  If anyone has any ideas or comments I would like to hear "
"them."
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:58
msgid "NOTE:"
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:59
msgid ""
"pulled out from some docs on ARM floating point, specifically for the Acorn "
"FPE, but not limited to it:"
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:62
msgid ""
"The floating point control register (FPCR) may only be present in some "
"implementations: it is there to control the hardware in an implementation- "
"specific manner, for example to disable the floating point system.  The user "
"mode of the ARM is not permitted to use this register (since the right is "
"reserved to alter it between implementations) and the WFC and RFC "
"instructions will trap if tried in user mode."
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:69
msgid ""
"Hence, the answer is yes, you could do this, but then you will run a high "
"risk of becoming isolated if and when hardware FP emulation comes out"
msgstr ""

#: ../../../arch/arm/nwfpe/todo.rst:72
msgid "-- Russell."
msgstr ""
