# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/powerpc/imc.rst:6
msgid "IMC (In-Memory Collection Counters)"
msgstr ""

#: ../../../arch/powerpc/imc.rst:8
msgid "Anju T Sudhakar, 10 May 2019"
msgstr ""

#: ../../../arch/powerpc/imc.rst:12
msgid "Contents"
msgstr ""

#: ../../../arch/powerpc/imc.rst:15
msgid "Basic overview"
msgstr ""

#: ../../../arch/powerpc/imc.rst:17
msgid ""
"IMC (In-Memory collection counters) is a hardware monitoring facility that "
"collects large numbers of hardware performance events at Nest level (these "
"are on-chip but off-core), Core level and Thread level."
msgstr ""

#: ../../../arch/powerpc/imc.rst:21
msgid ""
"The Nest PMU counters are handled by a Nest IMC microcode which runs in the "
"OCC (On-Chip Controller) complex. The microcode collects the counter data "
"and moves the nest IMC counter data to memory."
msgstr ""

#: ../../../arch/powerpc/imc.rst:25
msgid ""
"The Core and Thread IMC PMU counters are handled in the core. Core level PMU "
"counters give us the IMC counters' data per core and thread level PMU "
"counters give us the IMC counters' data per CPU thread."
msgstr ""

#: ../../../arch/powerpc/imc.rst:29
msgid ""
"OPAL obtains the IMC PMU and supported events information from the IMC "
"Catalog and passes on to the kernel via the device tree. The event's "
"information contains:"
msgstr ""

#: ../../../arch/powerpc/imc.rst:33
msgid "Event name"
msgstr ""

#: ../../../arch/powerpc/imc.rst:34
msgid "Event Offset"
msgstr ""

#: ../../../arch/powerpc/imc.rst:35
msgid "Event description"
msgstr ""

#: ../../../arch/powerpc/imc.rst:37
msgid "and possibly also:"
msgstr ""

#: ../../../arch/powerpc/imc.rst:39
msgid "Event scale"
msgstr ""

#: ../../../arch/powerpc/imc.rst:40
msgid "Event unit"
msgstr ""

#: ../../../arch/powerpc/imc.rst:42
msgid ""
"Some PMUs may have a common scale and unit values for all their supported "
"events. For those cases, the scale and unit properties for those events must "
"be inherited from the PMU."
msgstr ""

#: ../../../arch/powerpc/imc.rst:46
msgid ""
"The event offset in the memory is where the counter data gets accumulated."
msgstr ""

#: ../../../arch/powerpc/imc.rst:48
msgid "IMC catalog is available at:"
msgstr ""

#: ../../../arch/powerpc/imc.rst:49
msgid "https://github.com/open-power/ima-catalog"
msgstr ""

#: ../../../arch/powerpc/imc.rst:51
msgid ""
"The kernel discovers the IMC counters information in the device tree at the "
"`imc-counters` device node which has a compatible field `ibm,opal-in-memory-"
"counters`. From the device tree, the kernel parses the PMUs and their "
"event's information and register the PMU and its attributes in the kernel."
msgstr ""

#: ../../../arch/powerpc/imc.rst:58
msgid "IMC example usage"
msgstr ""

#: ../../../arch/powerpc/imc.rst:73
msgid "To see per chip data for nest_mcs0/PM_MCS_DOWN_128B_DATA_XFER_MC0/:"
msgstr ""

#: ../../../arch/powerpc/imc.rst:79
msgid "To see non-idle instructions for core 0:"
msgstr ""

#: ../../../arch/powerpc/imc.rst:85
msgid "To see non-idle instructions for a \"make\":"
msgstr ""

#: ../../../arch/powerpc/imc.rst:93
msgid "IMC Trace-mode"
msgstr ""

#: ../../../arch/powerpc/imc.rst:95
msgid ""
"POWER9 supports two modes for IMC which are the Accumulation mode and Trace "
"mode. In Accumulation mode, event counts are accumulated in system Memory. "
"Hypervisor then reads the posted counts periodically or when requested. In "
"IMC Trace mode, the 64 bit trace SCOM value is initialized with the event "
"information. The CPMCxSEL and CPMC_LOAD in the trace SCOM, specifies the "
"event to be monitored and the sampling duration. On each overflow in the "
"CPMCxSEL, hardware snapshots the program counter along with event counts and "
"writes into memory pointed by LDBAR."
msgstr ""

#: ../../../arch/powerpc/imc.rst:104
msgid ""
"LDBAR is a 64 bit special purpose per thread register, it has bits to "
"indicate whether hardware is configured for accumulation or trace mode."
msgstr ""

#: ../../../arch/powerpc/imc.rst:108
msgid "LDBAR Register Layout"
msgstr ""

#: ../../../arch/powerpc/imc.rst:111
msgid "0"
msgstr ""

#: ../../../arch/powerpc/imc.rst:111
msgid "Enable/Disable"
msgstr ""

#: ../../../arch/powerpc/imc.rst:113
msgid "1"
msgstr ""

#: ../../../arch/powerpc/imc.rst:113
msgid "0: Accumulation Mode"
msgstr ""

#: ../../../arch/powerpc/imc.rst:115
msgid "1: Trace Mode"
msgstr ""

#: ../../../arch/powerpc/imc.rst:117
msgid "2:3"
msgstr ""

#: ../../../arch/powerpc/imc.rst:117 ../../../arch/powerpc/imc.rst:121
#: ../../../arch/powerpc/imc.rst:125
msgid "Reserved"
msgstr ""

#: ../../../arch/powerpc/imc.rst:119
msgid "4-6"
msgstr ""

#: ../../../arch/powerpc/imc.rst:119
msgid "PB scope"
msgstr ""

#: ../../../arch/powerpc/imc.rst:121
msgid "7"
msgstr ""

#: ../../../arch/powerpc/imc.rst:123
msgid "8:50"
msgstr ""

#: ../../../arch/powerpc/imc.rst:123
msgid "Counter Address"
msgstr ""

#: ../../../arch/powerpc/imc.rst:125 ../../../arch/powerpc/imc.rst:142
msgid "51:63"
msgstr ""

#: ../../../arch/powerpc/imc.rst:129
msgid "TRACE_IMC_SCOM bit representation"
msgstr ""

#: ../../../arch/powerpc/imc.rst:132
msgid "0:1"
msgstr ""

#: ../../../arch/powerpc/imc.rst:132
msgid "SAMPSEL"
msgstr ""

#: ../../../arch/powerpc/imc.rst:134
msgid "2:33"
msgstr ""

#: ../../../arch/powerpc/imc.rst:134
msgid "CPMC_LOAD"
msgstr ""

#: ../../../arch/powerpc/imc.rst:136
msgid "34:40"
msgstr ""

#: ../../../arch/powerpc/imc.rst:136
msgid "CPMC1SEL"
msgstr ""

#: ../../../arch/powerpc/imc.rst:138
msgid "41:47"
msgstr ""

#: ../../../arch/powerpc/imc.rst:138
msgid "CPMC2SEL"
msgstr ""

#: ../../../arch/powerpc/imc.rst:140
msgid "48:50"
msgstr ""

#: ../../../arch/powerpc/imc.rst:140
msgid "BUFFERSIZE"
msgstr ""

#: ../../../arch/powerpc/imc.rst:142
msgid "RESERVED"
msgstr ""

#: ../../../arch/powerpc/imc.rst:145
msgid ""
"CPMC_LOAD contains the sampling duration. SAMPSEL and CPMCxSEL determines "
"the event to count. BUFFERSIZE indicates the memory range. On each overflow, "
"hardware snapshots the program counter along with event counts and updates "
"the memory and reloads the CMPC_LOAD value for the next sampling duration. "
"IMC hardware does not support exceptions, so it quietly wraps around if "
"memory buffer reaches the end."
msgstr ""

#: ../../../arch/powerpc/imc.rst:152
msgid "*Currently the event monitored for trace-mode is fixed as cycle.*"
msgstr ""

#: ../../../arch/powerpc/imc.rst:155
msgid "Trace IMC example usage"
msgstr ""

#: ../../../arch/powerpc/imc.rst:163
msgid "To record an application/process with trace-imc event:"
msgstr ""

#: ../../../arch/powerpc/imc.rst:171
msgid "The `perf.data` generated, can be read using perf report."
msgstr ""

#: ../../../arch/powerpc/imc.rst:174
msgid "Benefits of using IMC trace-mode"
msgstr ""

#: ../../../arch/powerpc/imc.rst:176
msgid ""
"PMI (Performance Monitoring Interrupts) interrupt handling is avoided, since "
"IMC trace mode snapshots the program counter and updates to the memory. And "
"this also provide a way for the operating system to do instruction sampling "
"in real time without PMI processing overhead."
msgstr ""

#: ../../../arch/powerpc/imc.rst:181
msgid "Performance data using `perf top` with and without trace-imc event."
msgstr ""

#: ../../../arch/powerpc/imc.rst:183
msgid ""
"PMI interrupts count when `perf top` command is executed without trace-imc "
"event."
msgstr ""

#: ../../../arch/powerpc/imc.rst:199
msgid ""
"That is, the PMI interrupt counts do not increment when using the "
"`trace_imc` event."
msgstr ""
