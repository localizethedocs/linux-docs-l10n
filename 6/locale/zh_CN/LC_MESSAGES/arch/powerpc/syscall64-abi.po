# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/powerpc/syscall64-abi.rst:3
msgid "Power Architecture 64-bit Linux system call ABI"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:6
msgid "syscall"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:9
#: ../../../arch/powerpc/syscall64-abi.rst:146
msgid "Invocation"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:10
msgid ""
"The syscall is made with the sc instruction, and returns with execution "
"continuing at the instruction following the sc instruction."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:13
msgid ""
"If PPC_FEATURE2_SCV appears in the AT_HWCAP2 ELF auxiliary vector, the scv 0 "
"instruction is an alternative that may provide better performance, with some "
"differences to calling sequence."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:17
msgid ""
"syscall calling sequence\\ [1]_ matches the Power Architecture 64-bit ELF "
"ABI specification C function calling sequence, including register "
"preservation rules, with the following differences."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:21
msgid ""
"Some syscalls (typically low-level management functions) may have different "
"calling sequences (e.g., rt_sigreturn)."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:25
msgid "Parameters"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:26
msgid "The system call number is specified in r0."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:28
msgid ""
"There is a maximum of 6 integer parameters to a syscall, passed in r3-r8."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:31
msgid "Return value"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:32
msgid ""
"For the sc instruction, both a value and an error condition are returned. "
"cr0.SO is the error condition, and r3 is the return value. When cr0.SO is "
"clear, the syscall succeeded and r3 is the return value. When cr0.SO is set, "
"the syscall failed and r3 is the error value (that normally corresponds to "
"errno)."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:38
msgid ""
"For the scv 0 instruction, the return value indicates failure if it is "
"-4095..-1 (i.e., it is >= -MAX_ERRNO (-4095) as an unsigned comparison), in "
"which case the error value is the negated return value."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:43
#: ../../../arch/powerpc/syscall64-abi.rst:133
msgid "Stack"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:44
msgid ""
"System calls do not modify the caller's stack frame. For example, the "
"caller's stack frame LR and CR save fields are not used."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:48
#: ../../../arch/powerpc/syscall64-abi.rst:137
msgid "Register preservation rules"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:49
msgid ""
"Register preservation rules match the ELF ABI calling sequence with some "
"differences."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:52
msgid ""
"For the sc instruction, the differences from the ELF ABI are as follows:"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:55
#: ../../../arch/powerpc/syscall64-abi.rst:73
msgid "Register"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:55
#: ../../../arch/powerpc/syscall64-abi.rst:73
msgid "Preservation Rules"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:55
#: ../../../arch/powerpc/syscall64-abi.rst:73
msgid "Purpose"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:57
#: ../../../arch/powerpc/syscall64-abi.rst:75
#: ../../../arch/powerpc/syscall64-abi.rst:140
msgid "r0"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:57
#: ../../../arch/powerpc/syscall64-abi.rst:59
#: ../../../arch/powerpc/syscall64-abi.rst:61
#: ../../../arch/powerpc/syscall64-abi.rst:63
#: ../../../arch/powerpc/syscall64-abi.rst:75
#: ../../../arch/powerpc/syscall64-abi.rst:77
#: ../../../arch/powerpc/syscall64-abi.rst:79
#: ../../../arch/powerpc/syscall64-abi.rst:140
#: ../../../arch/powerpc/syscall64-abi.rst:141
#: ../../../arch/powerpc/syscall64-abi.rst:142
msgid "Volatile"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:57
#: ../../../arch/powerpc/syscall64-abi.rst:75
msgid "(System call number.)"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:59
#: ../../../arch/powerpc/syscall64-abi.rst:77
msgid "r3"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:59
#: ../../../arch/powerpc/syscall64-abi.rst:77
msgid "(Parameter 1, and return value.)"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:61
#: ../../../arch/powerpc/syscall64-abi.rst:79
msgid "r4-r8"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:61
#: ../../../arch/powerpc/syscall64-abi.rst:79
msgid "(Parameters 2-6.)"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:63
msgid "cr0"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:63
msgid "(cr0.SO is the return error condition.)"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:65
#: ../../../arch/powerpc/syscall64-abi.rst:141
msgid "cr1, cr5-7"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:65
#: ../../../arch/powerpc/syscall64-abi.rst:67
msgid "Nonvolatile"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:67
#: ../../../arch/powerpc/syscall64-abi.rst:142
msgid "lr"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:70
msgid ""
"For the scv 0 instruction, the differences from the ELF ABI are as follows:"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:82
msgid ""
"All floating point and vector data registers as well as control and status "
"registers are nonvolatile."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:86
#: ../../../arch/powerpc/syscall64-abi.rst:151
msgid "Transactional Memory"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:87
msgid ""
"Syscall behavior can change if the processor is in transactional or "
"suspended transaction state, and the syscall can affect the behavior of the "
"transaction."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:90
msgid ""
"If the processor is in suspended state when a syscall is made, the syscall "
"will be performed as normal, and will return as normal. The syscall will be "
"performed in suspended state, so its side effects will be persistent "
"according to the usual transactional memory semantics. A syscall may or may "
"not result in the transaction being doomed by hardware."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:96
msgid ""
"If the processor is in transactional state when a syscall is made, then the "
"behavior depends on the presence of PPC_FEATURE2_HTM_NOSC in the AT_HWCAP2 "
"ELF auxiliary vector."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:100
msgid ""
"If present, which is the case for newer kernels, then the syscall will not "
"be performed and the transaction will be doomed by the kernel with the "
"failure code TM_CAUSE_SYSCALL | TM_CAUSE_PERSISTENT in the TEXASR SPR."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:104
msgid ""
"If not present (older kernels), then the kernel will suspend the "
"transactional state and the syscall will proceed as in the case of a "
"suspended state syscall, and will resume the transactional state before "
"returning to the caller. This case is not well defined or supported, so this "
"behavior should not be relied upon."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:110
msgid "scv 0 syscalls will always behave as PPC_FEATURE2_HTM_NOSC."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:113
msgid "ptrace"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:114
msgid ""
"When ptracing system calls (PTRACE_SYSCALL), the pt_regs.trap value contains "
"the system call type that can be used to distinguish between sc and scv 0 "
"system calls, and the different register conventions can be accounted for."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:118
msgid ""
"If the value of (pt_regs.trap & 0xfff0) is 0xc00 then the system call was "
"performed with the sc instruction, if it is 0x3000 then the system call was "
"performed with the scv 0 instruction."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:123
msgid "vsyscall"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:125
msgid ""
"vsyscall calling sequence matches the syscall calling sequence, with the "
"following differences. Some vsyscalls may have different calling sequences."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:129
msgid "Parameters and return value"
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:130
msgid "r0 is not used as an input. The vsyscall is selected by its address."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:134
msgid "The vsyscall may or may not use the caller's stack frame save areas."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:147
msgid ""
"The vsyscall is performed with a branch-with-link instruction to the "
"vsyscall function address."
msgstr ""

#: ../../../arch/powerpc/syscall64-abi.rst:152
msgid ""
"vsyscalls will run in the same transactional state as the caller. A vsyscall "
"may or may not result in the transaction being doomed by hardware."
msgstr ""
