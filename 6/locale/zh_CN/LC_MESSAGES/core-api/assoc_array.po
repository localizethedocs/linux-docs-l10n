# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/assoc_array.rst:3
msgid "Generic Associative Array Implementation"
msgstr ""

#: ../../../core-api/assoc_array.rst:6
msgid "Overview"
msgstr ""

#: ../../../core-api/assoc_array.rst:8
msgid ""
"This associative array implementation is an object container with the "
"following properties:"
msgstr ""

#: ../../../core-api/assoc_array.rst:11
msgid ""
"Objects are opaque pointers.  The implementation does not care where they "
"point (if anywhere) or what they point to (if anything)."
msgstr ""

#: ../../../core-api/assoc_array.rst:16
msgid "Pointers to objects _must_ be zero in the least significant bit."
msgstr ""

#: ../../../core-api/assoc_array.rst:18
msgid ""
"Objects do not need to contain linkage blocks for use by the array.  This "
"permits an object to be located in multiple arrays simultaneously. Rather, "
"the array is made up of metadata blocks that point to objects."
msgstr ""

#: ../../../core-api/assoc_array.rst:22
msgid "Objects require index keys to locate them within the array."
msgstr ""

#: ../../../core-api/assoc_array.rst:24
msgid ""
"Index keys must be unique.  Inserting an object with the same key as one "
"already in the array will replace the old object."
msgstr ""

#: ../../../core-api/assoc_array.rst:27
msgid "Index keys can be of any length and can be of different lengths."
msgstr ""

#: ../../../core-api/assoc_array.rst:29
msgid ""
"Index keys should encode the length early on, before any variation due to "
"length is seen."
msgstr ""

#: ../../../core-api/assoc_array.rst:32
msgid "Index keys can include a hash to scatter objects throughout the array."
msgstr ""

#: ../../../core-api/assoc_array.rst:34
msgid ""
"The array can iterated over.  The objects will not necessarily come out in "
"key order."
msgstr ""

#: ../../../core-api/assoc_array.rst:37
msgid ""
"The array can be iterated over while it is being modified, provided the RCU "
"readlock is being held by the iterator.  Note, however, under these "
"circumstances, some objects may be seen more than once.  If this is a "
"problem, the iterator should lock against modification.  Objects will not be "
"missed, however, unless deleted."
msgstr ""

#: ../../../core-api/assoc_array.rst:43
msgid "Objects in the array can be looked up by means of their index key."
msgstr ""

#: ../../../core-api/assoc_array.rst:45
msgid ""
"Objects can be looked up while the array is being modified, provided the RCU "
"readlock is being held by the thread doing the look up."
msgstr ""

#: ../../../core-api/assoc_array.rst:48
msgid ""
"The implementation uses a tree of 16-pointer nodes internally that are "
"indexed on each level by nibbles from the index key in the same manner as in "
"a radix tree.  To improve memory efficiency, shortcuts can be emplaced to "
"skip over what would otherwise be a series of single-occupancy nodes.  "
"Further, nodes pack leaf object pointers into spare space in the node rather "
"than making an extra branch until as such time an object needs to be added "
"to a full node."
msgstr ""

#: ../../../core-api/assoc_array.rst:57
msgid "The Public API"
msgstr ""

#: ../../../core-api/assoc_array.rst:59
msgid ""
"The public API can be found in ``<linux/assoc_array.h>``.  The associative "
"array is rooted on the following structure::"
msgstr ""

#: ../../../core-api/assoc_array.rst:66
msgid "The code is selected by enabling ``CONFIG_ASSOCIATIVE_ARRAY`` with::"
msgstr ""

#: ../../../core-api/assoc_array.rst:72
msgid "Edit Script"
msgstr ""

#: ../../../core-api/assoc_array.rst:74
msgid ""
"The insertion and deletion functions produce an 'edit script' that can later "
"be applied to effect the changes without risking ``ENOMEM``. This retains "
"the preallocated metadata blocks that will be installed in the internal tree "
"and keeps track of the metadata blocks that will be removed from the tree "
"when the script is applied."
msgstr ""

#: ../../../core-api/assoc_array.rst:80
msgid ""
"This is also used to keep track of dead blocks and dead objects after the "
"script has been applied so that they can be freed later.  The freeing is "
"done after an RCU grace period has passed - thus allowing access functions "
"to proceed under the RCU read lock."
msgstr ""

#: ../../../core-api/assoc_array.rst:85
msgid "The script appears as outside of the API as a pointer of the type::"
msgstr ""

#: ../../../core-api/assoc_array.rst:89
msgid "There are two functions for dealing with the script:"
msgstr ""

#: ../../../core-api/assoc_array.rst:91
msgid "Apply an edit script::"
msgstr ""

#: ../../../core-api/assoc_array.rst:95
msgid ""
"This will perform the edit functions, interpolating various write barriers "
"to permit accesses under the RCU read lock to continue.  The edit script "
"will then be passed to ``call_rcu()`` to free it and any dead stuff it "
"points to."
msgstr ""

#: ../../../core-api/assoc_array.rst:100
msgid "Cancel an edit script::"
msgstr ""

#: ../../../core-api/assoc_array.rst:104
msgid ""
"This frees the edit script and all preallocated memory immediately. If this "
"was for insertion, the new object is _not_ released by this function, but "
"must rather be released by the caller."
msgstr ""

#: ../../../core-api/assoc_array.rst:108
msgid "These functions are guaranteed not to fail."
msgstr ""

#: ../../../core-api/assoc_array.rst:112
msgid "Operations Table"
msgstr ""

#: ../../../core-api/assoc_array.rst:114
msgid "Various functions take a table of operations::"
msgstr ""

#: ../../../core-api/assoc_array.rst:120
msgid "This points to a number of methods, all of which need to be provided:"
msgstr ""

#: ../../../core-api/assoc_array.rst:122
msgid "Get a chunk of index key from caller data::"
msgstr ""

#: ../../../core-api/assoc_array.rst:126
msgid ""
"This should return a chunk of caller-supplied index key starting at the "
"*bit* position given by the level argument.  The level argument will be a "
"multiple of ``ASSOC_ARRAY_KEY_CHUNK_SIZE`` and the function should return "
"``ASSOC_ARRAY_KEY_CHUNK_SIZE bits``.  No error is possible."
msgstr ""

#: ../../../core-api/assoc_array.rst:132
msgid "Get a chunk of an object's index key::"
msgstr ""

#: ../../../core-api/assoc_array.rst:136
msgid ""
"As the previous function, but gets its data from an object in the array "
"rather than from a caller-supplied index key."
msgstr ""

#: ../../../core-api/assoc_array.rst:140
msgid "See if this is the object we're looking for::"
msgstr ""

#: ../../../core-api/assoc_array.rst:144
msgid ""
"Compare the object against an index key and return ``true`` if it matches "
"and ``false`` if it doesn't."
msgstr ""

#: ../../../core-api/assoc_array.rst:148
msgid "Diff the index keys of two objects::"
msgstr ""

#: ../../../core-api/assoc_array.rst:152
msgid ""
"Return the bit position at which the index key of the specified object "
"differs from the given index key or -1 if they are the same."
msgstr ""

#: ../../../core-api/assoc_array.rst:156
msgid "Free an object::"
msgstr ""

#: ../../../core-api/assoc_array.rst:160
msgid ""
"Free the specified object.  Note that this may be called an RCU grace period "
"after ``assoc_array_apply_edit()`` was called, so ``synchronize_rcu()`` may "
"be necessary on module unloading."
msgstr ""

#: ../../../core-api/assoc_array.rst:166
msgid "Manipulation Functions"
msgstr ""

#: ../../../core-api/assoc_array.rst:168
msgid "There are a number of functions for manipulating an associative array:"
msgstr ""

#: ../../../core-api/assoc_array.rst:170
msgid "Initialise an associative array::"
msgstr ""

#: ../../../core-api/assoc_array.rst:174
msgid ""
"This initialises the base structure for an associative array.  It can't fail."
msgstr ""

#: ../../../core-api/assoc_array.rst:177
msgid "Insert/replace an object in an associative array::"
msgstr ""

#: ../../../core-api/assoc_array.rst:185
msgid ""
"This inserts the given object into the array.  Note that the least "
"significant bit of the pointer must be zero as it's used to type-mark "
"pointers internally."
msgstr ""

#: ../../../core-api/assoc_array.rst:189
msgid ""
"If an object already exists for that key then it will be replaced with the "
"new object and the old one will be freed automatically."
msgstr ""

#: ../../../core-api/assoc_array.rst:192 ../../../core-api/assoc_array.rst:211
msgid ""
"The ``index_key`` argument should hold index key information and is passed "
"to the methods in the ops table when they are called."
msgstr ""

#: ../../../core-api/assoc_array.rst:195 ../../../core-api/assoc_array.rst:231
msgid ""
"This function makes no alteration to the array itself, but rather returns an "
"edit script that must be applied.  ``-ENOMEM`` is returned in the case of an "
"out-of-memory error."
msgstr ""

#: ../../../core-api/assoc_array.rst:199 ../../../core-api/assoc_array.rst:219
#: ../../../core-api/assoc_array.rst:235
msgid ""
"The caller should lock exclusively against other modifiers of the array."
msgstr ""

#: ../../../core-api/assoc_array.rst:202
msgid "Delete an object from an associative array::"
msgstr ""

#: ../../../core-api/assoc_array.rst:209
msgid "This deletes an object that matches the specified data from the array."
msgstr ""

#: ../../../core-api/assoc_array.rst:214
msgid ""
"This function makes no alteration to the array itself, but rather returns an "
"edit script that must be applied.  ``-ENOMEM`` is returned in the case of an "
"out-of-memory error.  ``NULL`` will be returned if the specified object is "
"not found within the array."
msgstr ""

#: ../../../core-api/assoc_array.rst:222
msgid "Delete all objects from an associative array::"
msgstr ""

#: ../../../core-api/assoc_array.rst:228
msgid ""
"This deletes all the objects from an associative array and leaves it "
"completely empty."
msgstr ""

#: ../../../core-api/assoc_array.rst:238
msgid "Destroy an associative array, deleting all objects::"
msgstr ""

#: ../../../core-api/assoc_array.rst:243
msgid ""
"This destroys the contents of the associative array and leaves it completely "
"empty.  It is not permitted for another thread to be traversing the array "
"under the RCU read lock at the same time as this function is destroying it "
"as no RCU deferral is performed on memory release - something that would "
"require memory to be allocated."
msgstr ""

#: ../../../core-api/assoc_array.rst:249
msgid ""
"The caller should lock exclusively against other modifiers and accessors of "
"the array."
msgstr ""

#: ../../../core-api/assoc_array.rst:253
msgid "Garbage collect an associative array::"
msgstr ""

#: ../../../core-api/assoc_array.rst:260
msgid ""
"This iterates over the objects in an associative array and passes each one "
"to ``iterator()``.  If ``iterator()`` returns ``true``, the object is kept.  "
"If it returns ``false``, the object will be freed.  If the ``iterator()`` "
"function returns ``true``, it must perform any appropriate refcount "
"incrementing on the object before returning."
msgstr ""

#: ../../../core-api/assoc_array.rst:266
msgid ""
"The internal tree will be packed down if possible as part of the iteration "
"to reduce the number of nodes in it."
msgstr ""

#: ../../../core-api/assoc_array.rst:269
msgid ""
"The ``iterator_data`` is passed directly to ``iterator()`` and is otherwise "
"ignored by the function."
msgstr ""

#: ../../../core-api/assoc_array.rst:272
msgid ""
"The function will return ``0`` if successful and ``-ENOMEM`` if there wasn't "
"enough memory."
msgstr ""

#: ../../../core-api/assoc_array.rst:275
msgid ""
"It is possible for other threads to iterate over or search the array under "
"the RCU read lock while this function is in progress.  The caller should "
"lock exclusively against other modifiers of the array."
msgstr ""

#: ../../../core-api/assoc_array.rst:281
msgid "Access Functions"
msgstr ""

#: ../../../core-api/assoc_array.rst:283
msgid "There are two functions for accessing an associative array:"
msgstr ""

#: ../../../core-api/assoc_array.rst:285
msgid "Iterate over all the objects in an associative array::"
msgstr ""

#: ../../../core-api/assoc_array.rst:292
msgid ""
"This passes each object in the array to the iterator callback function. "
"``iterator_data`` is private data for that function."
msgstr ""

#: ../../../core-api/assoc_array.rst:295
msgid ""
"This may be used on an array at the same time as the array is being "
"modified, provided the RCU read lock is held.  Under such circumstances, it "
"is possible for the iteration function to see some objects twice.  If this "
"is a problem, then modification should be locked against.  The iteration "
"algorithm should not, however, miss any objects."
msgstr ""

#: ../../../core-api/assoc_array.rst:301
msgid ""
"The function will return ``0`` if no objects were in the array or else it "
"will return the result of the last iterator function called.  Iteration "
"stops immediately if any call to the iteration function results in a non-"
"zero return."
msgstr ""

#: ../../../core-api/assoc_array.rst:307
msgid "Find an object in an associative array::"
msgstr ""

#: ../../../core-api/assoc_array.rst:313
msgid ""
"This walks through the array's internal tree directly to the object "
"specified by the index key.."
msgstr ""

#: ../../../core-api/assoc_array.rst:316
msgid ""
"This may be used on an array at the same time as the array is being "
"modified, provided the RCU read lock is held."
msgstr ""

#: ../../../core-api/assoc_array.rst:319
msgid ""
"The function will return the object if found (and set ``*_type`` to the "
"object type) or will return ``NULL`` if the object was not found."
msgstr ""

#: ../../../core-api/assoc_array.rst:324
msgid "Index Key Form"
msgstr ""

#: ../../../core-api/assoc_array.rst:326
msgid ""
"The index key can be of any form, but since the algorithms aren't told how "
"long the key is, it is strongly recommended that the index key includes its "
"length very early on before any variation due to the length would have an "
"effect on comparisons."
msgstr ""

#: ../../../core-api/assoc_array.rst:331
msgid ""
"This will cause leaves with different length keys to scatter away from each "
"other - and those with the same length keys to cluster together."
msgstr ""

#: ../../../core-api/assoc_array.rst:334
msgid ""
"It is also recommended that the index key begin with a hash of the rest of "
"the key to maximise scattering throughout keyspace."
msgstr ""

#: ../../../core-api/assoc_array.rst:337
msgid ""
"The better the scattering, the wider and lower the internal tree will be."
msgstr ""

#: ../../../core-api/assoc_array.rst:339
msgid ""
"Poor scattering isn't too much of a problem as there are shortcuts and nodes "
"can contain mixtures of leaves and metadata pointers."
msgstr ""

#: ../../../core-api/assoc_array.rst:342
msgid ""
"The index key is read in chunks of machine word.  Each chunk is subdivided "
"into one nibble (4 bits) per level, so on a 32-bit CPU this is good for 8 "
"levels and on a 64-bit CPU, 16 levels.  Unless the scattering is really "
"poor, it is unlikely that more than one word of any particular index key "
"will have to be used."
msgstr ""

#: ../../../core-api/assoc_array.rst:350
msgid "Internal Workings"
msgstr ""

#: ../../../core-api/assoc_array.rst:352
msgid ""
"The associative array data structure has an internal tree.  This tree is "
"constructed of two types of metadata blocks: nodes and shortcuts."
msgstr ""

#: ../../../core-api/assoc_array.rst:355
msgid "A node is an array of slots.  Each slot can contain one of four things:"
msgstr ""

#: ../../../core-api/assoc_array.rst:357
msgid "A NULL pointer, indicating that the slot is empty."
msgstr ""

#: ../../../core-api/assoc_array.rst:358
msgid "A pointer to an object (a leaf)."
msgstr ""

#: ../../../core-api/assoc_array.rst:359
msgid "A pointer to a node at the next level."
msgstr ""

#: ../../../core-api/assoc_array.rst:360
msgid "A pointer to a shortcut."
msgstr ""

#: ../../../core-api/assoc_array.rst:364
msgid "Basic Internal Tree Layout"
msgstr ""

#: ../../../core-api/assoc_array.rst:366
msgid ""
"Ignoring shortcuts for the moment, the nodes form a multilevel tree.  The "
"index key space is strictly subdivided by the nodes in the tree and nodes "
"occur on fixed levels.  For example::"
msgstr ""

#: ../../../core-api/assoc_array.rst:400
msgid ""
"In the above example, there are 7 nodes (A-G), each with 16 slots (0-f). "
"Assuming no other meta data nodes in the tree, the key space is divided "
"thusly::"
msgstr ""

#: ../../../core-api/assoc_array.rst:414
msgid ""
"So, for instance, keys with the following example index keys will be found "
"in the appropriate nodes::"
msgstr ""

#: ../../../core-api/assoc_array.rst:432
msgid ""
"To save memory, if a node can hold all the leaves in its portion of "
"keyspace, then the node will have all those leaves in it and will not have "
"any metadata pointers - even if some of those leaves would like to be in the "
"same slot."
msgstr ""

#: ../../../core-api/assoc_array.rst:436
msgid ""
"A node can contain a heterogeneous mix of leaves and metadata pointers. "
"Metadata pointers must be in the slots that match their subdivisions of key "
"space.  The leaves can be in any slot not occupied by a metadata pointer.  "
"It is guaranteed that none of the leaves in a node will match a slot "
"occupied by a metadata pointer.  If the metadata pointer is there, any leaf "
"whose key matches the metadata key prefix must be in the subtree that the "
"metadata pointer points to."
msgstr ""

#: ../../../core-api/assoc_array.rst:444
msgid "In the above example list of index keys, node A will contain::"
msgstr ""

#: ../../../core-api/assoc_array.rst:454
msgid "and node B::"
msgstr ""

#: ../../../core-api/assoc_array.rst:461
msgid "Shortcuts"
msgstr ""

#: ../../../core-api/assoc_array.rst:463
msgid ""
"Shortcuts are metadata records that jump over a piece of keyspace.  A "
"shortcut is a replacement for a series of single-occupancy nodes ascending "
"through the levels.  Shortcuts exist to save memory and to speed up "
"traversal."
msgstr ""

#: ../../../core-api/assoc_array.rst:467
msgid ""
"It is possible for the root of the tree to be a shortcut - say, for example, "
"the tree contains at least 17 nodes all with key prefix ``1111``.  The "
"insertion algorithm will insert a shortcut to skip over the ``1111`` "
"keyspace in a single bound and get to the fourth level where these actually "
"become different."
msgstr ""

#: ../../../core-api/assoc_array.rst:475
msgid "Splitting And Collapsing Nodes"
msgstr ""

#: ../../../core-api/assoc_array.rst:477
msgid ""
"Each node has a maximum capacity of 16 leaves and metadata pointers.  If the "
"insertion algorithm finds that it is trying to insert a 17th object into a "
"node, that node will be split such that at least two leaves that have a "
"common key segment at that level end up in a separate node rooted on that "
"slot for that common key segment."
msgstr ""

#: ../../../core-api/assoc_array.rst:483
msgid ""
"If the leaves in a full node and the leaf that is being inserted are "
"sufficiently similar, then a shortcut will be inserted into the tree."
msgstr ""

#: ../../../core-api/assoc_array.rst:486
msgid ""
"When the number of objects in the subtree rooted at a node falls to 16 or "
"fewer, then the subtree will be collapsed down to a single node - and this "
"will ripple towards the root if possible."
msgstr ""

#: ../../../core-api/assoc_array.rst:492
msgid "Non-Recursive Iteration"
msgstr ""

#: ../../../core-api/assoc_array.rst:494
msgid ""
"Each node and shortcut contains a back pointer to its parent and the number "
"of slot in that parent that points to it.  None-recursive iteration uses "
"these to proceed rootwards through the tree, going to the parent node, slot "
"N + 1 to make sure progress is made without the need for a stack."
msgstr ""

#: ../../../core-api/assoc_array.rst:499
msgid ""
"The backpointers, however, make simultaneous alteration and iteration tricky."
msgstr ""

#: ../../../core-api/assoc_array.rst:503
msgid "Simultaneous Alteration And Iteration"
msgstr ""

#: ../../../core-api/assoc_array.rst:505
msgid "There are a number of cases to consider:"
msgstr ""

#: ../../../core-api/assoc_array.rst:507
msgid ""
"Simple insert/replace.  This involves simply replacing a NULL or old "
"matching leaf pointer with the pointer to the new leaf after a barrier. The "
"metadata blocks don't change otherwise.  An old leaf won't be freed until "
"after the RCU grace period."
msgstr ""

#: ../../../core-api/assoc_array.rst:512
msgid ""
"Simple delete.  This involves just clearing an old matching leaf.  The "
"metadata blocks don't change otherwise.  The old leaf won't be freed until "
"after the RCU grace period."
msgstr ""

#: ../../../core-api/assoc_array.rst:516
msgid ""
"Insertion replacing part of a subtree that we haven't yet entered.  This may "
"involve replacement of part of that subtree - but that won't affect the "
"iteration as we won't have reached the pointer to it yet and the ancestry "
"blocks are not replaced (the layout of those does not change)."
msgstr ""

#: ../../../core-api/assoc_array.rst:521
msgid ""
"Insertion replacing nodes that we're actively processing.  This isn't a "
"problem as we've passed the anchoring pointer and won't switch onto the new "
"layout until we follow the back pointers - at which point we've already "
"examined the leaves in the replaced node (we iterate over all the leaves in "
"a node before following any of its metadata pointers)."
msgstr ""

#: ../../../core-api/assoc_array.rst:527
msgid ""
"We might, however, re-see some leaves that have been split out into a new "
"branch that's in a slot further along than we were at."
msgstr ""

#: ../../../core-api/assoc_array.rst:530
msgid ""
"Insertion replacing nodes that we're processing a dependent branch of. This "
"won't affect us until we follow the back pointers.  Similar to (4)."
msgstr ""

#: ../../../core-api/assoc_array.rst:533
msgid ""
"Deletion collapsing a branch under us.  This doesn't affect us because the "
"back pointers will get us back to the parent of the new node before we could "
"see the new node.  The entire collapsed subtree is thrown away unchanged - "
"and will still be rooted on the same slot, so we shouldn't process it a "
"second time as we'll go back to slot + 1."
msgstr ""

#: ../../../core-api/assoc_array.rst:541
msgid ""
"Under some circumstances, we need to simultaneously change the parent "
"pointer and the parent slot pointer on a node (say, for example, we inserted "
"another node before it and moved it up a level).  We cannot do this without "
"locking against a read - so we have to replace that node too."
msgstr ""

#: ../../../core-api/assoc_array.rst:546
msgid ""
"However, when we're changing a shortcut into a node this isn't a problem as "
"shortcuts only have one slot and so the parent slot number isn't used when "
"traversing backwards over one.  This means that it's okay to change the slot "
"number first - provided suitable barriers are used to make sure the parent "
"slot number is read after the back pointer."
msgstr ""

#: ../../../core-api/assoc_array.rst:552
msgid ""
"Obsolete blocks and leaves are freed up after an RCU grace period has "
"passed, so as long as anyone doing walking or iteration holds the RCU read "
"lock, the old superstructure should not go away on them."
msgstr ""
