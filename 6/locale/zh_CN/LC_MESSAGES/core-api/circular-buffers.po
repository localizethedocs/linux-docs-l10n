# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/circular-buffers.rst:3
msgid "Circular Buffers"
msgstr ""

#: ../../../core-api/circular-buffers.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/circular-buffers.rst:5
msgid "David Howells <dhowells@redhat.com>"
msgstr ""

#: ../../../core-api/circular-buffers.rst:6
msgid "Paul E. McKenney <paulmck@linux.ibm.com>"
msgstr ""

#: ../../../core-api/circular-buffers.rst:9
msgid ""
"Linux provides a number of features that can be used to implement circular "
"buffering.  There are two sets of such features:"
msgstr ""

#: ../../../core-api/circular-buffers.rst:12
msgid ""
"Convenience functions for determining information about power-of-2 sized "
"buffers."
msgstr ""

#: ../../../core-api/circular-buffers.rst:15
msgid ""
"Memory barriers for when the producer and the consumer of objects in the "
"buffer don't want to share a lock."
msgstr ""

#: ../../../core-api/circular-buffers.rst:18
msgid ""
"To use these facilities, as discussed below, there needs to be just one "
"producer and just one consumer.  It is possible to handle multiple producers "
"by serialising them, and to handle multiple consumers by serialising them."
msgstr ""

#: ../../../core-api/circular-buffers.rst:36
msgid "What is a circular buffer?"
msgstr ""

#: ../../../core-api/circular-buffers.rst:38
msgid ""
"First of all, what is a circular buffer?  A circular buffer is a buffer of "
"fixed, finite size into which there are two indices:"
msgstr ""

#: ../../../core-api/circular-buffers.rst:41
msgid ""
"A 'head' index - the point at which the producer inserts items into the "
"buffer."
msgstr ""

#: ../../../core-api/circular-buffers.rst:44
msgid ""
"A 'tail' index - the point at which the consumer finds the next item in the "
"buffer."
msgstr ""

#: ../../../core-api/circular-buffers.rst:47
msgid ""
"Typically when the tail pointer is equal to the head pointer, the buffer is "
"empty; and the buffer is full when the head pointer is one less than the "
"tail pointer."
msgstr ""

#: ../../../core-api/circular-buffers.rst:51
msgid ""
"The head index is incremented when items are added, and the tail index when "
"items are removed.  The tail index should never jump the head index, and "
"both indices should be wrapped to 0 when they reach the end of the buffer, "
"thus allowing an infinite amount of data to flow through the buffer."
msgstr ""

#: ../../../core-api/circular-buffers.rst:56
msgid ""
"Typically, items will all be of the same unit size, but this isn't strictly "
"required to use the techniques below.  The indices can be increased by more "
"than 1 if multiple items or variable-sized items are to be included in the "
"buffer, provided that neither index overtakes the other.  The implementer "
"must be careful, however, as a region more than one unit in size may wrap "
"the end of the buffer and be broken into two segments."
msgstr ""

#: ../../../core-api/circular-buffers.rst:64
msgid "Measuring power-of-2 buffers"
msgstr ""

#: ../../../core-api/circular-buffers.rst:66
msgid ""
"Calculation of the occupancy or the remaining capacity of an arbitrarily "
"sized circular buffer would normally be a slow operation, requiring the use "
"of a modulus (divide) instruction.  However, if the buffer is of a power-"
"of-2 size, then a much quicker bitwise-AND instruction can be used instead."
msgstr ""

#: ../../../core-api/circular-buffers.rst:71
msgid ""
"Linux provides a set of macros for handling power-of-2 circular buffers.  "
"These can be made use of by::"
msgstr ""

#: ../../../core-api/circular-buffers.rst:76
msgid "The macros are:"
msgstr ""

#: ../../../core-api/circular-buffers.rst:78
msgid "Measure the remaining capacity of a buffer::"
msgstr ""

#: ../../../core-api/circular-buffers.rst:82
msgid ""
"This returns the amount of space left in the buffer[1] into which items can "
"be inserted."
msgstr ""

#: ../../../core-api/circular-buffers.rst:86
msgid "Measure the maximum consecutive immediate space in a buffer::"
msgstr ""

#: ../../../core-api/circular-buffers.rst:90
msgid ""
"This returns the amount of consecutive space left in the buffer[1] into "
"which items can be immediately inserted without having to wrap back to the "
"beginning of the buffer."
msgstr ""

#: ../../../core-api/circular-buffers.rst:95
msgid "Measure the occupancy of a buffer::"
msgstr ""

#: ../../../core-api/circular-buffers.rst:99
msgid "This returns the number of items currently occupying a buffer[2]."
msgstr ""

#: ../../../core-api/circular-buffers.rst:102
msgid "Measure the non-wrapping occupancy of a buffer::"
msgstr ""

#: ../../../core-api/circular-buffers.rst:106
msgid ""
"This returns the number of consecutive items[2] that can be extracted from "
"the buffer without having to wrap back to the beginning of the buffer."
msgstr ""

#: ../../../core-api/circular-buffers.rst:110
msgid ""
"Each of these macros will nominally return a value between 0 and "
"buffer_size-1, however:"
msgstr ""

#: ../../../core-api/circular-buffers.rst:113
msgid ""
"CIRC_SPACE*() are intended to be used in the producer.  To the producer they "
"will return a lower bound as the producer controls the head index, but the "
"consumer may still be depleting the buffer on another CPU and moving the "
"tail index."
msgstr ""

#: ../../../core-api/circular-buffers.rst:118
msgid ""
"To the consumer it will show an upper bound as the producer may be busy "
"depleting the space."
msgstr ""

#: ../../../core-api/circular-buffers.rst:121
msgid ""
"CIRC_CNT*() are intended to be used in the consumer.  To the consumer they "
"will return a lower bound as the consumer controls the tail index, but the "
"producer may still be filling the buffer on another CPU and moving the head "
"index."
msgstr ""

#: ../../../core-api/circular-buffers.rst:126
msgid ""
"To the producer it will show an upper bound as the consumer may be busy "
"emptying the buffer."
msgstr ""

#: ../../../core-api/circular-buffers.rst:129
msgid ""
"To a third party, the order in which the writes to the indices by the "
"producer and consumer become visible cannot be guaranteed as they are "
"independent and may be made on different CPUs - so the result in such a "
"situation will merely be a guess, and may even be negative."
msgstr ""

#: ../../../core-api/circular-buffers.rst:135
msgid "Using memory barriers with circular buffers"
msgstr ""

#: ../../../core-api/circular-buffers.rst:137
msgid ""
"By using memory barriers in conjunction with circular buffers, you can avoid "
"the need to:"
msgstr ""

#: ../../../core-api/circular-buffers.rst:140
msgid ""
"use a single lock to govern access to both ends of the buffer, thus allowing "
"the buffer to be filled and emptied at the same time; and"
msgstr ""

#: ../../../core-api/circular-buffers.rst:143
msgid "use atomic counter operations."
msgstr ""

#: ../../../core-api/circular-buffers.rst:145
msgid ""
"There are two sides to this: the producer that fills the buffer, and the "
"consumer that empties it.  Only one thing should be filling a buffer at any "
"one time, and only one thing should be emptying a buffer at any one time, "
"but the two sides can operate simultaneously."
msgstr ""

#: ../../../core-api/circular-buffers.rst:152
msgid "The producer"
msgstr ""

#: ../../../core-api/circular-buffers.rst:154
msgid "The producer will look something like this::"
msgstr ""

#: ../../../core-api/circular-buffers.rst:178
msgid ""
"This will instruct the CPU that the contents of the new item must be written "
"before the head index makes it available to the consumer and then instructs "
"the CPU that the revised head index must be written before the consumer is "
"woken."
msgstr ""

#: ../../../core-api/circular-buffers.rst:182
msgid ""
"Note that wake_up() does not guarantee any sort of barrier unless something "
"is actually awakened.  We therefore cannot rely on it for ordering.  "
"However, there is always one element of the array left empty.  Therefore, "
"the producer must produce two elements before it could possibly corrupt the "
"element currently being read by the consumer.  Therefore, the unlock-lock "
"pair between consecutive invocations of the consumer provides the necessary "
"ordering between the read of the index indicating that the consumer has "
"vacated a given element and the write by the producer to that same element."
msgstr ""

#: ../../../core-api/circular-buffers.rst:193
msgid "The Consumer"
msgstr ""

#: ../../../core-api/circular-buffers.rst:195
msgid "The consumer will look something like this::"
msgstr ""

#: ../../../core-api/circular-buffers.rst:217
msgid ""
"This will instruct the CPU to make sure the index is up to date before "
"reading the new item, and then it shall make sure the CPU has finished "
"reading the item before it writes the new tail pointer, which will erase the "
"item."
msgstr ""

#: ../../../core-api/circular-buffers.rst:221
msgid ""
"Note the use of READ_ONCE() and smp_load_acquire() to read the opposition "
"index.  This prevents the compiler from discarding and reloading its cached "
"value.  This isn't strictly needed if you can be sure that the opposition "
"index will _only_ be used the once. The smp_load_acquire() additionally "
"forces the CPU to order against subsequent memory references.  Similarly, "
"smp_store_release() is used in both algorithms to write the thread's index.  "
"This documents the fact that we are writing to something that can be read "
"concurrently, prevents the compiler from tearing the store, and enforces "
"ordering against previous accesses."
msgstr ""

#: ../../../core-api/circular-buffers.rst:234
msgid "Further reading"
msgstr ""

#: ../../../core-api/circular-buffers.rst:236
msgid ""
"See also Documentation/memory-barriers.txt for a description of Linux's "
"memory barrier facilities."
msgstr ""
