# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/protection-keys.rst:5
msgid "Memory Protection Keys"
msgstr ""

#: ../../../core-api/protection-keys.rst:7
msgid ""
"Memory Protection Keys provide a mechanism for enforcing page-based "
"protections, but without requiring modification of the page tables when an "
"application changes protection domains."
msgstr ""

#: ../../../core-api/protection-keys.rst:11
msgid "Pkeys Userspace (PKU) is a feature which can be found on:"
msgstr ""

#: ../../../core-api/protection-keys.rst:12
msgid "Intel server CPUs, Skylake and later"
msgstr ""

#: ../../../core-api/protection-keys.rst:13
msgid "Intel client CPUs, Tiger Lake (11th Gen Core) and later"
msgstr ""

#: ../../../core-api/protection-keys.rst:14
msgid "Future AMD CPUs"
msgstr ""

#: ../../../core-api/protection-keys.rst:15
msgid "arm64 CPUs implementing the Permission Overlay Extension (FEAT_S1POE)"
msgstr ""

#: ../../../core-api/protection-keys.rst:18
msgid "x86_64"
msgstr ""

#: ../../../core-api/protection-keys.rst:19
msgid ""
"Pkeys work by dedicating 4 previously Reserved bits in each page table entry "
"to a \"protection key\", giving 16 possible keys."
msgstr ""

#: ../../../core-api/protection-keys.rst:22
msgid ""
"Protections for each key are defined with a per-CPU user-accessible register "
"(PKRU).  Each of these is a 32-bit register storing two bits (Access Disable "
"and Write Disable) for each of 16 keys."
msgstr ""

#: ../../../core-api/protection-keys.rst:26
msgid ""
"Being a CPU register, PKRU is inherently thread-local, potentially giving "
"each thread a different set of protections from every other thread."
msgstr ""

#: ../../../core-api/protection-keys.rst:29
msgid ""
"There are two instructions (RDPKRU/WRPKRU) for reading and writing to the "
"register.  The feature is only available in 64-bit mode, even though there "
"is theoretically space in the PAE PTEs.  These permissions are enforced on "
"data access only and have no effect on instruction fetches."
msgstr ""

#: ../../../core-api/protection-keys.rst:35
msgid "arm64"
msgstr ""

#: ../../../core-api/protection-keys.rst:37
msgid ""
"Pkeys use 3 bits in each page table entry, to encode a \"protection key "
"index\", giving 8 possible keys."
msgstr ""

#: ../../../core-api/protection-keys.rst:40
msgid ""
"Protections for each key are defined with a per-CPU user-writable system "
"register (POR_EL0).  This is a 64-bit register encoding read, write and "
"execute overlay permissions for each protection key index."
msgstr ""

#: ../../../core-api/protection-keys.rst:44
msgid ""
"Being a CPU register, POR_EL0 is inherently thread-local, potentially giving "
"each thread a different set of protections from every other thread."
msgstr ""

#: ../../../core-api/protection-keys.rst:47
msgid ""
"Unlike x86_64, the protection key permissions also apply to instruction "
"fetches."
msgstr ""

#: ../../../core-api/protection-keys.rst:51
msgid "Syscalls"
msgstr ""

#: ../../../core-api/protection-keys.rst:53
msgid "There are 3 system calls which directly interact with pkeys::"
msgstr ""

#: ../../../core-api/protection-keys.rst:60
msgid ""
"Before a pkey can be used, it must first be allocated with pkey_alloc().  An "
"application writes to the architecture specific CPU register directly in "
"order to change access permissions to memory covered with a key.  In this "
"example this is wrapped by a C function called pkey_set(). ::"
msgstr ""

#: ../../../core-api/protection-keys.rst:72
msgid ""
"Now, if the application needs to update the data at 'ptr', it can gain "
"access, do the update, then remove its write access::"
msgstr ""

#: ../../../core-api/protection-keys.rst:79
msgid ""
"Now when it frees the memory, it will also free the pkey since it is no "
"longer in use::"
msgstr ""

#: ../../../core-api/protection-keys.rst:85
msgid ""
"pkey_set() is a wrapper around writing to the CPU register. Example "
"implementations can be found in tools/testing/selftests/mm/pkey-{arm64,"
"powerpc,x86}.h"
msgstr ""

#: ../../../core-api/protection-keys.rst:90
msgid "Behavior"
msgstr ""

#: ../../../core-api/protection-keys.rst:92
msgid ""
"The kernel attempts to make protection keys consistent with the behavior of "
"a plain mprotect().  For instance if you do this::"
msgstr ""

#: ../../../core-api/protection-keys.rst:98
msgid "you can expect the same effects with protection keys when doing this::"
msgstr ""

#: ../../../core-api/protection-keys.rst:104
msgid ""
"That should be true whether something() is a direct access to 'ptr' like::"
msgstr ""

#: ../../../core-api/protection-keys.rst:109
msgid ""
"or when the kernel does the access on the application's behalf like with a "
"read()::"
msgstr ""

#: ../../../core-api/protection-keys.rst:114
msgid ""
"The kernel will send a SIGSEGV in both cases, but si_code will be set to "
"SEGV_PKERR when violating protection keys versus SEGV_ACCERR when the plain "
"mprotect() permissions are violated."
msgstr ""

#: ../../../core-api/protection-keys.rst:118
msgid ""
"Note that kernel accesses from a kthread (such as io_uring) will use a "
"default value for the protection key register and so will not be consistent "
"with userspace's value of the register or mprotect()."
msgstr ""
