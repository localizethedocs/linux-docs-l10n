# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/dma-isa-lpc.rst:3
msgid "DMA with ISA and LPC devices"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:5
msgid "Pierre Ossman <drzeus@drzeus.cx>"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:7
msgid ""
"This document describes how to do DMA transfers using the old ISA DMA "
"controller. Even though ISA is more or less dead today the LPC bus uses the "
"same DMA system so it will be around for quite some time."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:12
msgid "Headers and dependencies"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:14
msgid "To do ISA style DMA you need to include two headers::"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:19
msgid ""
"The first is the generic DMA API used to convert virtual addresses to bus "
"addresses (see Documentation/core-api/dma-api.rst for details)."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:22
msgid ""
"The second contains the routines specific to ISA DMA transfers. Since this "
"is not present on all platforms make sure you construct your Kconfig to be "
"dependent on ISA_DMA_API (not ISA) so that nobody tries to build your driver "
"on unsupported platforms."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:28
msgid "Buffer allocation"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:30
msgid ""
"The ISA DMA controller has some very strict requirements on which memory it "
"can access so extra care must be taken when allocating buffers."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:34
msgid ""
"(You usually need a special buffer for DMA transfers instead of transferring "
"directly to and from your normal data structures.)"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:37
msgid ""
"The DMA-able address space is the lowest 16 MB of _physical_ memory. Also "
"the transfer block may not cross page boundaries (which are 64 or 128 KiB "
"depending on which channel you use)."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:41
msgid ""
"In order to allocate a piece of memory that satisfies all these requirements "
"you pass the flag GFP_DMA to kmalloc."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:44
msgid ""
"Unfortunately the memory available for ISA DMA is scarce so unless you "
"allocate the memory during boot-up it's a good idea to also pass "
"__GFP_RETRY_MAYFAIL and __GFP_NOWARN to make the allocator try a bit harder."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:48
msgid ""
"(This scarcity also means that you should allocate the buffer as early as "
"possible and not release it until the driver is unloaded.)"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:52
msgid "Address translation"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:54
msgid ""
"To translate the virtual address to a bus address, use the normal DMA API. "
"Do _not_ use isa_virt_to_bus() even though it does the same thing. The "
"reason for this is that the function isa_virt_to_bus() will require a "
"Kconfig dependency to ISA, not just ISA_DMA_API which is really all you "
"need. Remember that even though the DMA controller has its origins in ISA it "
"is used elsewhere."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:61
msgid ""
"Note: x86_64 had a broken DMA API when it came to ISA but has since been "
"fixed. If your arch has problems then fix the DMA API instead of reverting "
"to the ISA functions."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:66
msgid "Channels"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:68
msgid ""
"A normal ISA DMA controller has 8 channels. The lower four are for 8-bit "
"transfers and the upper four are for 16-bit transfers."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:71
msgid ""
"(Actually the DMA controller is really two separate controllers where "
"channel 4 is used to give DMA access for the second controller (0-3). This "
"means that of the four 16-bits channels only three are usable.)"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:75
msgid "You allocate these in a similar fashion as all basic resources:"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:77
msgid ""
"extern int request_dma(unsigned int dmanr, const char * device_id); extern "
"void free_dma(unsigned int dmanr);"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:80
msgid ""
"The ability to use 16-bit or 8-bit transfers is _not_ up to you as a driver "
"author but depends on what the hardware supports. Check your specs or test "
"different channels."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:85
msgid "Transfer data"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:87
msgid "Now for the good stuff, the actual DMA transfer. :)"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:89
msgid ""
"Before you use any ISA DMA routines you need to claim the DMA lock using "
"claim_dma_lock(). The reason is that some DMA operations are not atomic so "
"only one driver may fiddle with the registers at a time."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:94
msgid ""
"The first time you use the DMA controller you should call clear_dma_ff(). "
"This clears an internal register in the DMA controller that is used for the "
"non-atomic operations. As long as you (and everyone else) uses the locking "
"functions then you only need to reset this once."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:100
msgid ""
"Next, you tell the controller in which direction you intend to do the "
"transfer using set_dma_mode(). Currently you have the options DMA_MODE_READ "
"and DMA_MODE_WRITE."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:104
msgid ""
"Set the address from where the transfer should start (this needs to be 16-"
"bit aligned for 16-bit transfers) and how many bytes to transfer. Note that "
"it's _bytes_. The DMA routines will do all the required translation to "
"values that the DMA controller understands."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:109
msgid "The final step is enabling the DMA channel and releasing the DMA lock."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:112
msgid ""
"Once the DMA transfer is finished (or timed out) you should disable the "
"channel again. You should also check get_dma_residue() to make sure that all "
"data has been transferred."
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:116
msgid "Example::"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:146
msgid "Suspend/resume"
msgstr ""

#: ../../../core-api/dma-isa-lpc.rst:148
msgid ""
"It is the driver's responsibility to make sure that the machine isn't "
"suspended while a DMA transfer is in progress. Also, all DMA settings are "
"lost when the system suspends so if your driver relies on the DMA controller "
"being in a certain state then you have to restore these registers upon "
"resume."
msgstr ""
