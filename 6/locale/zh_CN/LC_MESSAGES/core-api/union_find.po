# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/union_find.rst:5
msgid "Union-Find in Linux"
msgstr ""

#: ../../../core-api/union_find.rst:0
msgid "Date"
msgstr ""

#: ../../../core-api/union_find.rst:8
msgid "June 21, 2024"
msgstr ""

#: ../../../core-api/union_find.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/union_find.rst:9
msgid "Xavier <xavier_qy@163.com>"
msgstr ""

#: ../../../core-api/union_find.rst:12
msgid "What is union-find, and what is it used for?"
msgstr ""

#: ../../../core-api/union_find.rst:14
msgid ""
"Union-find is a data structure used to handle the merging and querying of "
"disjoint sets. The primary operations supported by union-find are:"
msgstr ""

#: ../../../core-api/union_find.rst:17
msgid "Initialization: Resetting each element as an individual set, with"
msgstr ""

#: ../../../core-api/union_find.rst:18
msgid "each set's initial parent node pointing to itself."
msgstr ""

#: ../../../core-api/union_find.rst:20
msgid "Find: Determine which set a particular element belongs to, usually by"
msgstr ""

#: ../../../core-api/union_find.rst:21
msgid ""
"returning a “representative element” of that set. This operation is used to "
"check if two elements are in the same set."
msgstr ""

#: ../../../core-api/union_find.rst:24
msgid "Union: Merge two sets into one."
msgstr ""

#: ../../../core-api/union_find.rst:26
msgid ""
"As a data structure used to maintain sets (groups), union-find is commonly "
"utilized to solve problems related to offline queries, dynamic connectivity, "
"and graph theory. It is also a key component in Kruskal's algorithm for "
"computing the minimum spanning tree, which is crucial in scenarios like "
"network routing. Consequently, union-find is widely referenced. "
"Additionally, union-find has applications in symbolic computation, register "
"allocation, and more."
msgstr ""

#: ../../../core-api/union_find.rst:34
msgid "Space Complexity: O(n), where n is the number of nodes."
msgstr ""

#: ../../../core-api/union_find.rst:36
msgid ""
"Time Complexity: Using path compression can reduce the time complexity of "
"the find operation, and using union by rank can reduce the time complexity "
"of the union operation. These optimizations reduce the average time "
"complexity of each find and union operation to O(α(n)), where α(n) is the "
"inverse Ackermann function. This can be roughly considered a constant time "
"complexity for practical purposes."
msgstr ""

#: ../../../core-api/union_find.rst:43
msgid ""
"This document covers use of the Linux union-find implementation.  For more "
"information on the nature and implementation of union-find,  see:"
msgstr ""

#: ../../../core-api/union_find.rst:46
msgid "Wikipedia entry on union-find"
msgstr ""

#: ../../../core-api/union_find.rst:47
msgid "https://en.wikipedia.org/wiki/Disjoint-set_data_structure"
msgstr ""

#: ../../../core-api/union_find.rst:50
msgid "Linux implementation of union-find"
msgstr ""

#: ../../../core-api/union_find.rst:52
msgid ""
"Linux's union-find implementation resides in the file \"lib/union_find.c\". "
"To use it, \"#include <linux/union_find.h>\"."
msgstr ""

#: ../../../core-api/union_find.rst:55
msgid "The union-find data structure is defined as follows::"
msgstr ""

#: ../../../core-api/union_find.rst:62
msgid ""
"In this structure, parent points to the parent node of the current node. The "
"rank field represents the height of the current tree. During a union "
"operation, the tree with the smaller rank is attached under the tree with "
"the larger rank to maintain balance."
msgstr ""

#: ../../../core-api/union_find.rst:68
msgid "Initializing union-find"
msgstr ""

#: ../../../core-api/union_find.rst:70
msgid ""
"You can complete the initialization using either static or initialization "
"interface. Initialize the parent pointer to point to itself and set the rank "
"to 0. Example::"
msgstr ""

#: ../../../core-api/union_find.rst:77
msgid "or"
msgstr ""

#: ../../../core-api/union_find.rst:79
msgid "uf_node_init(&my_node);"
msgstr ""

#: ../../../core-api/union_find.rst:82
msgid "Find the Root Node of union-find"
msgstr ""

#: ../../../core-api/union_find.rst:84
msgid ""
"This operation is mainly used to determine whether two nodes belong to the "
"same set in the union-find. If they have the same root, they are in the same "
"set. During the find operation, path compression is performed to improve the "
"efficiency of subsequent find operations. Example::"
msgstr ""

#: ../../../core-api/union_find.rst:99
msgid "Union Two Sets in union-find"
msgstr ""

#: ../../../core-api/union_find.rst:101
msgid ""
"To union two sets in the union-find, you first find their respective root "
"nodes and then link the smaller node to the larger node based on the rank of "
"the root nodes. Example::"
msgstr ""
