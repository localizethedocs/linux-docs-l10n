# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/verifier.rst:4
msgid "eBPF verifier"
msgstr ""

#: ../../../bpf/verifier.rst:6
msgid "The safety of the eBPF program is determined in two steps."
msgstr ""

#: ../../../bpf/verifier.rst:8
msgid ""
"First step does DAG check to disallow loops and other CFG validation. In "
"particular it will detect programs that have unreachable instructions. "
"(though classic BPF checker allows them)"
msgstr ""

#: ../../../bpf/verifier.rst:12
msgid ""
"Second step starts from the first insn and descends all possible paths. It "
"simulates execution of every insn and observes the state change of registers "
"and stack."
msgstr ""

#: ../../../bpf/verifier.rst:16
msgid ""
"At the start of the program the register R1 contains a pointer to context "
"and has type PTR_TO_CTX. If verifier sees an insn that does R2=R1, then R2 "
"has now type PTR_TO_CTX as well and can be used on the right hand side of "
"expression. If R1=PTR_TO_CTX and insn is R2=R1+R1, then R2=SCALAR_VALUE, "
"since addition of two valid pointers makes invalid pointer. (In 'secure' "
"mode verifier will reject any type of pointer arithmetic to make sure that "
"kernel addresses don't leak to unprivileged users)"
msgstr ""

#: ../../../bpf/verifier.rst:25
msgid "If register was never written to, it's not readable::"
msgstr ""

#: ../../../bpf/verifier.rst:30
msgid "will be rejected, since R2 is unreadable at the start of the program."
msgstr ""

#: ../../../bpf/verifier.rst:32
msgid ""
"After kernel function call, R1-R5 are reset to unreadable and R0 has a "
"return type of the function."
msgstr ""

#: ../../../bpf/verifier.rst:35
msgid "Since R6-R9 are callee saved, their state is preserved across the call."
msgstr ""

#: ../../../bpf/verifier.rst:44
msgid ""
"is a correct program. If there was R1 instead of R6, it would have been "
"rejected."
msgstr ""

#: ../../../bpf/verifier.rst:47
msgid ""
"load/store instructions are allowed only with registers of valid types, "
"which are PTR_TO_CTX, PTR_TO_MAP, PTR_TO_STACK. They are bounds and "
"alignment checked. For example::"
msgstr ""

#: ../../../bpf/verifier.rst:56
msgid ""
"will be rejected, since R1 doesn't have a valid pointer type at the time of "
"execution of instruction bpf_xadd."
msgstr ""

#: ../../../bpf/verifier.rst:59
msgid ""
"At the start R1 type is PTR_TO_CTX (a pointer to generic ``struct "
"bpf_context``) A callback is used to customize verifier to restrict eBPF "
"program access to only certain fields within ctx structure with specified "
"size and alignment."
msgstr ""

#: ../../../bpf/verifier.rst:63
msgid "For example, the following insn::"
msgstr ""

#: ../../../bpf/verifier.rst:67
msgid ""
"intends to load a word from address R6 + 8 and store it into R0 If "
"R6=PTR_TO_CTX, via is_valid_access() callback the verifier will know that "
"offset 8 of size 4 bytes can be accessed for reading, otherwise the verifier "
"will reject the program. If R6=PTR_TO_STACK, then access should be aligned "
"and be within stack bounds, which are [-MAX_BPF_STACK, 0). In this example "
"offset is 8, so it will fail verification, since it's out of bounds."
msgstr ""

#: ../../../bpf/verifier.rst:75
msgid ""
"The verifier will allow eBPF program to read data from stack only after it "
"wrote into it."
msgstr ""

#: ../../../bpf/verifier.rst:78
msgid ""
"Classic BPF verifier does similar check with M[0-15] memory slots. For "
"example::"
msgstr ""

#: ../../../bpf/verifier.rst:84
msgid ""
"is invalid program. Though R10 is correct read-only register and has type "
"PTR_TO_STACK and R10 - 4 is within stack bounds, there were no stores into "
"that location."
msgstr ""

#: ../../../bpf/verifier.rst:88
msgid ""
"Pointer register spill/fill is tracked as well, since four (R6-R9) callee "
"saved registers may not be enough for some programs."
msgstr ""

#: ../../../bpf/verifier.rst:91
msgid ""
"Allowed function calls are customized with bpf_verifier_ops-"
">get_func_proto() The eBPF verifier will check that registers match argument "
"constraints. After the call register R0 will be set to return type of the "
"function."
msgstr ""

#: ../../../bpf/verifier.rst:95
msgid ""
"Function calls is a main mechanism to extend functionality of eBPF programs. "
"Socket filters may let programs to call one set of functions, whereas "
"tracing filters may allow completely different set."
msgstr ""

#: ../../../bpf/verifier.rst:99
msgid ""
"If a function made accessible to eBPF program, it needs to be thought "
"through from safety point of view. The verifier will guarantee that the "
"function is called with valid arguments."
msgstr ""

#: ../../../bpf/verifier.rst:103
msgid ""
"seccomp vs socket filters have different security restrictions for classic "
"BPF. Seccomp solves this by two stage verifier: classic BPF verifier is "
"followed by seccomp verifier. In case of eBPF one configurable verifier is "
"shared for all use cases."
msgstr ""

#: ../../../bpf/verifier.rst:108
msgid "See details of eBPF verifier in kernel/bpf/verifier.c"
msgstr ""

#: ../../../bpf/verifier.rst:111
msgid "Register value tracking"
msgstr ""

#: ../../../bpf/verifier.rst:113
msgid ""
"In order to determine the safety of an eBPF program, the verifier must track "
"the range of possible values in each register and also in each stack slot. "
"This is done with ``struct bpf_reg_state``, defined in include/linux/ "
"bpf_verifier.h, which unifies tracking of scalar and pointer values.  Each "
"register state has a type, which is either NOT_INIT (the register has not "
"been written to), SCALAR_VALUE (some value which is not usable as a "
"pointer), or a pointer type.  The types of pointers describe their base, as "
"follows:"
msgstr ""

#: ../../../bpf/verifier.rst:122
msgid "PTR_TO_CTX"
msgstr ""

#: ../../../bpf/verifier.rst:123
msgid "Pointer to bpf_context."
msgstr ""

#: ../../../bpf/verifier.rst:124
msgid "CONST_PTR_TO_MAP"
msgstr ""

#: ../../../bpf/verifier.rst:125
msgid ""
"Pointer to struct bpf_map.  \"Const\" because arithmetic on these pointers "
"is forbidden."
msgstr ""

#: ../../../bpf/verifier.rst:127
msgid "PTR_TO_MAP_VALUE"
msgstr ""

#: ../../../bpf/verifier.rst:128
msgid "Pointer to the value stored in a map element."
msgstr ""

#: ../../../bpf/verifier.rst:129
msgid "PTR_TO_MAP_VALUE_OR_NULL"
msgstr ""

#: ../../../bpf/verifier.rst:130
msgid ""
"Either a pointer to a map value, or NULL; map accesses (see maps.rst) return "
"this type, which becomes a PTR_TO_MAP_VALUE when checked != NULL. Arithmetic "
"on these pointers is forbidden."
msgstr ""

#: ../../../bpf/verifier.rst:134
msgid "PTR_TO_STACK"
msgstr ""

#: ../../../bpf/verifier.rst:135
msgid "Frame pointer."
msgstr ""

#: ../../../bpf/verifier.rst:136
msgid "PTR_TO_PACKET"
msgstr ""

#: ../../../bpf/verifier.rst:137
msgid "skb->data."
msgstr ""

#: ../../../bpf/verifier.rst:138
msgid "PTR_TO_PACKET_END"
msgstr ""

#: ../../../bpf/verifier.rst:139
msgid "skb->data + headlen; arithmetic forbidden."
msgstr ""

#: ../../../bpf/verifier.rst:140
msgid "PTR_TO_SOCKET"
msgstr ""

#: ../../../bpf/verifier.rst:141
msgid "Pointer to struct bpf_sock_ops, implicitly refcounted."
msgstr ""

#: ../../../bpf/verifier.rst:142
msgid "PTR_TO_SOCKET_OR_NULL"
msgstr ""

#: ../../../bpf/verifier.rst:143
msgid ""
"Either a pointer to a socket, or NULL; socket lookup returns this type, "
"which becomes a PTR_TO_SOCKET when checked != NULL. PTR_TO_SOCKET is "
"reference-counted, so programs must release the reference through the socket "
"release function before the end of the program. Arithmetic on these pointers "
"is forbidden."
msgstr ""

#: ../../../bpf/verifier.rst:150
msgid ""
"However, a pointer may be offset from this base (as a result of pointer "
"arithmetic), and this is tracked in two parts: the 'fixed offset' and "
"'variable offset'.  The former is used when an exactly-known value (e.g. an "
"immediate operand) is added to a pointer, while the latter is used for "
"values which are not exactly known.  The variable offset is also used in "
"SCALAR_VALUEs, to track the range of possible values in the register."
msgstr ""

#: ../../../bpf/verifier.rst:157
msgid "The verifier's knowledge about the variable offset consists of:"
msgstr ""

#: ../../../bpf/verifier.rst:159
msgid "minimum and maximum values as unsigned"
msgstr ""

#: ../../../bpf/verifier.rst:160
msgid "minimum and maximum values as signed"
msgstr ""

#: ../../../bpf/verifier.rst:162
msgid ""
"knowledge of the values of individual bits, in the form of a 'tnum': a u64 "
"'mask' and a u64 'value'.  1s in the mask represent bits whose value is "
"unknown; 1s in the value represent bits known to be 1.  Bits known to be 0 "
"have 0 in both mask and value; no bit should ever be 1 in both.  For "
"example, if a byte is read into a register from memory, the register's top "
"56 bits are known zero, while the low 8 are unknown - which is represented "
"as the tnum (0x0; 0xff).  If we then OR this with 0x40, we get (0x40; 0xbf), "
"then if we add 1 we get (0x0; 0x1ff), because of potential carries."
msgstr ""

#: ../../../bpf/verifier.rst:171
msgid ""
"Besides arithmetic, the register state can also be updated by conditional "
"branches.  For instance, if a SCALAR_VALUE is compared > 8, in the 'true' "
"branch it will have a umin_value (unsigned minimum value) of 9, whereas in "
"the 'false' branch it will have a umax_value of 8.  A signed compare (with "
"BPF_JSGT or BPF_JSGE) would instead update the signed minimum/maximum "
"values.  Information from the signed and unsigned bounds can be combined; "
"for instance if a value is first tested < 8 and then tested s> 4, the "
"verifier will conclude that the value is also > 4 and s< 8, since the bounds "
"prevent crossing the sign boundary."
msgstr ""

#: ../../../bpf/verifier.rst:180
msgid ""
"PTR_TO_PACKETs with a variable offset part have an 'id', which is common to "
"all pointers sharing that same variable offset.  This is important for "
"packet range checks: after adding a variable to a packet pointer register A, "
"if you then copy it to another register B and then add a constant 4 to A, "
"both registers will share the same 'id' but the A will have a fixed offset "
"of +4.  Then if A is bounds-checked and found to be less than a "
"PTR_TO_PACKET_END, the register B is now known to have a safe range of at "
"least 4 bytes.  See 'Direct packet access', below, for more on PTR_TO_PACKET "
"ranges."
msgstr ""

#: ../../../bpf/verifier.rst:189
msgid ""
"The 'id' field is also used on PTR_TO_MAP_VALUE_OR_NULL, common to all "
"copies of the pointer returned from a map lookup.  This means that when one "
"copy is checked and found to be non-NULL, all copies can become "
"PTR_TO_MAP_VALUEs. As well as range-checking, the tracked information is "
"also used for enforcing alignment of pointer accesses.  For instance, on "
"most systems the packet pointer is 2 bytes after a 4-byte alignment.  If a "
"program adds 14 bytes to that to jump over the Ethernet header, then reads "
"IHL and adds (IHL * 4), the resulting pointer will have a variable offset "
"known to be 4n+2 for some n, so adding the 2 bytes (NET_IP_ALIGN) gives a 4-"
"byte alignment and so word-sized accesses through that pointer are safe. The "
"'id' field is also used on PTR_TO_SOCKET and PTR_TO_SOCKET_OR_NULL, common "
"to all copies of the pointer returned from a socket lookup. This has similar "
"behaviour to the handling for PTR_TO_MAP_VALUE_OR_NULL->PTR_TO_MAP_VALUE, "
"but it also handles reference tracking for the pointer. PTR_TO_SOCKET "
"implicitly represents a reference to the corresponding ``struct sock``. To "
"ensure that the reference is not leaked, it is imperative to NULL-check the "
"reference and in the non-NULL case, and pass the valid reference to the "
"socket release function."
msgstr ""

#: ../../../bpf/verifier.rst:208
msgid "Direct packet access"
msgstr ""

#: ../../../bpf/verifier.rst:210
msgid ""
"In cls_bpf and act_bpf programs the verifier allows direct access to the "
"packet data via skb->data and skb->data_end pointers. Ex::"
msgstr ""

#: ../../../bpf/verifier.rst:222
msgid ""
"this 2byte load from the packet is safe to do, since the program author did "
"check ``if (skb->data + 14 > skb->data_end) goto err`` at insn #5 which "
"means that in the fall-through case the register R3 (which points to skb-"
">data) has at least 14 directly accessible bytes. The verifier marks it as "
"R3=pkt(id=0,off=0,r=14). id=0 means that no additional variables were added "
"to the register. off=0 means that no additional constants were added. r=14 "
"is the range of safe access which means that bytes [R3, R3 + 14) are ok. "
"Note that R5 is marked as R5=pkt(id=0,off=14,r=14). It also points to the "
"packet data, but constant 14 was added to the register, so it now points to "
"``skb->data + 14`` and accessible range is [R5, R5 + 14 - 14) which is zero "
"bytes."
msgstr ""

#: ../../../bpf/verifier.rst:235
msgid "More complex packet access may look like::"
msgstr ""

#: ../../../bpf/verifier.rst:255
msgid ""
"The state of the register R3 is R3=pkt(id=2,off=0,r=8) id=2 means that two "
"``r3 += rX`` instructions were seen, so r3 points to some offset within a "
"packet and since the program author did ``if (r3 + 8 > r1) goto err`` at "
"insn #18, the safe range is [R3, R3 + 8). The verifier only allows "
"'add'/'sub' operations on packet registers. Any other operation will set the "
"register state to 'SCALAR_VALUE' and it won't be available for direct packet "
"access."
msgstr ""

#: ../../../bpf/verifier.rst:263
msgid ""
"Operation ``r3 += rX`` may overflow and become less than original skb->data, "
"therefore the verifier has to prevent that.  So when it sees ``r3 += rX`` "
"instruction and rX is more than 16-bit value, any subsequent bounds-check of "
"r3 against skb->data_end will not give us 'range' information, so attempts "
"to read through the pointer will give \"invalid access to packet\" error."
msgstr ""

#: ../../../bpf/verifier.rst:269
msgid ""
"Ex. after insn ``r4 = *(u8 *)(r3 +12)`` (insn #7 above) the state of r4 is "
"R4=inv(id=0,umax_value=255,var_off=(0x0; 0xff)) which means that upper 56 "
"bits of the register are guaranteed to be zero, and nothing is known about "
"the lower 8 bits. After insn ``r4 *= 14`` the state becomes R4=inv(id=0,"
"umax_value=3570,var_off=(0x0; 0xfffe)), since multiplying an 8-bit value by "
"constant 14 will keep upper 52 bits as zero, also the least significant bit "
"will be zero as 14 is even.  Similarly ``r2 >>= 48`` will make R2=inv(id=0,"
"umax_value=65535,var_off=(0x0; 0xffff)), since the shift is not sign "
"extending.  This logic is implemented in adjust_reg_min_max_vals() function, "
"which calls adjust_ptr_min_max_vals() for adding pointer to scalar (or vice "
"versa) and adjust_scalar_min_max_vals() for operations on two scalars."
msgstr ""

#: ../../../bpf/verifier.rst:281
msgid ""
"The end result is that bpf program author can access packet directly using "
"normal C code as::"
msgstr ""

#: ../../../bpf/verifier.rst:299
msgid ""
"which makes such programs easier to write comparing to LD_ABS insn and "
"significantly faster."
msgstr ""

#: ../../../bpf/verifier.rst:303
msgid "Pruning"
msgstr ""

#: ../../../bpf/verifier.rst:305
msgid ""
"The verifier does not actually walk all possible paths through the program.  "
"For each new branch to analyse, the verifier looks at all the states it's "
"previously been in when at this instruction.  If any of them contain the "
"current state as a subset, the branch is 'pruned' - that is, the fact that "
"the previous state was accepted implies the current state would be as well.  "
"For instance, if in the previous state, r1 held a packet-pointer, and in the "
"current state, r1 holds a packet-pointer with a range as long or longer and "
"at least as strict an alignment, then r1 is safe.  Similarly, if r2 was "
"NOT_INIT before then it can't have been used by any path from that point, so "
"any value in r2 (including another NOT_INIT) is safe.  The implementation is "
"in the function regsafe(). Pruning considers not only the registers but also "
"the stack (and any spilled registers it may hold).  They must all be safe "
"for the branch to be pruned. This is implemented in states_equal()."
msgstr ""

#: ../../../bpf/verifier.rst:319
msgid ""
"Some technical details about state pruning implementation could be found "
"below."
msgstr ""

#: ../../../bpf/verifier.rst:322
msgid "Register liveness tracking"
msgstr ""

#: ../../../bpf/verifier.rst:324
msgid ""
"In order to make state pruning effective, liveness state is tracked for each "
"register and stack slot. The basic idea is to track which registers and "
"stack slots are actually used during subseqeuent execution of the program, "
"until program exit is reached. Registers and stack slots that were never "
"used could be removed from the cached state thus making more states "
"equivalent to a cached state. This could be illustrated by the following "
"program::"
msgstr ""

#: ../../../bpf/verifier.rst:339
msgid ""
"Suppose that a state cache entry is created at instruction #4 (such entries "
"are also called \"checkpoints\" in the text below). The verifier could reach "
"the instruction with one of two possible register states:"
msgstr ""

#: ../../../bpf/verifier.rst:343
msgid "r0 = 1, r1 = 0"
msgstr ""

#: ../../../bpf/verifier.rst:344
msgid "r0 = 0, r1 = 0"
msgstr ""

#: ../../../bpf/verifier.rst:346
msgid ""
"However, only the value of register ``r1`` is important to successfully "
"finish verification. The goal of the liveness tracking algorithm is to spot "
"this fact and figure out that both states are actually equivalent."
msgstr ""

#: ../../../bpf/verifier.rst:351
msgid "Data structures"
msgstr ""

#: ../../../bpf/verifier.rst:353
msgid "Liveness is tracked using the following data structures::"
msgstr ""

#: ../../../bpf/verifier.rst:389
msgid ""
"``REG_LIVE_NONE`` is an initial value assigned to ``->live`` fields upon new "
"verifier state creation;"
msgstr ""

#: ../../../bpf/verifier.rst:392
msgid ""
"``REG_LIVE_WRITTEN`` means that the value of the register (or stack slot) is "
"defined by some instruction verified between this verifier state's parent "
"and verifier state itself;"
msgstr ""

#: ../../../bpf/verifier.rst:396
msgid ""
"``REG_LIVE_READ{32,64}`` means that the value of the register (or stack "
"slot) is read by a some child state of this verifier state;"
msgstr ""

#: ../../../bpf/verifier.rst:399
msgid ""
"``REG_LIVE_DONE`` is a marker used by ``clean_verifier_state()`` to avoid "
"processing same verifier state multiple times and for some sanity checks;"
msgstr ""

#: ../../../bpf/verifier.rst:402
msgid ""
"``->live`` field values are formed by combining ``enum bpf_reg_liveness`` "
"values using bitwise or."
msgstr ""

#: ../../../bpf/verifier.rst:406
msgid "Register parentage chains"
msgstr ""

#: ../../../bpf/verifier.rst:408
msgid ""
"In order to propagate information between parent and child states, a "
"*register parentage chain* is established. Each register or stack slot is "
"linked to a corresponding register or stack slot in its parent state via a "
"``->parent`` pointer. This link is established upon state creation in "
"``is_state_visited()`` and might be modified by ``set_callee_state()`` "
"called from ``__check_func_call()``."
msgstr ""

#: ../../../bpf/verifier.rst:415
msgid ""
"The rules for correspondence between registers / stack slots are as follows:"
msgstr ""

#: ../../../bpf/verifier.rst:417
msgid ""
"For the current stack frame, registers and stack slots of the new state are "
"linked to the registers and stack slots of the parent state with the same "
"indices."
msgstr ""

#: ../../../bpf/verifier.rst:421
msgid ""
"For the outer stack frames, only callee saved registers (r6-r9) and stack "
"slots are linked to the registers and stack slots of the parent state with "
"the same indices."
msgstr ""

#: ../../../bpf/verifier.rst:425
msgid ""
"When function call is processed a new ``struct bpf_func_state`` instance is "
"allocated, it encapsulates a new set of registers and stack slots. For this "
"new frame, parent links for r6-r9 and stack slots are set to nil, parent "
"links for r1-r5 are set to match caller r1-r5 parent links."
msgstr ""

#: ../../../bpf/verifier.rst:430
msgid ""
"This could be illustrated by the following diagram (arrows stand for ``-"
">parent`` pointers)::"
msgstr ""

#: ../../../bpf/verifier.rst:483
msgid "Liveness marks tracking"
msgstr ""

#: ../../../bpf/verifier.rst:485
msgid ""
"For each processed instruction, the verifier tracks read and written "
"registers and stack slots. The main idea of the algorithm is that read marks "
"propagate back along the state parentage chain until they hit a write mark, "
"which 'screens off' earlier states from the read. The information about "
"reads is propagated by function ``mark_reg_read()`` which could be "
"summarized as follows::"
msgstr ""

#: ../../../bpf/verifier.rst:502
msgid "Notes:"
msgstr ""

#: ../../../bpf/verifier.rst:504
msgid ""
"The read marks are applied to the **parent** state while write marks are "
"applied to the **current** state. The write mark on a register or stack slot "
"means that it is updated by some instruction in the straight-line code "
"leading from the parent state to the current state."
msgstr ""

#: ../../../bpf/verifier.rst:509
msgid "Details about REG_LIVE_READ32 are omitted."
msgstr ""

#: ../../../bpf/verifier.rst:511
msgid ""
"Function ``propagate_liveness()`` (see section :ref:"
"`read_marks_for_cache_hits`) might override the first parent link. Please "
"refer to the comments in the ``propagate_liveness()`` and "
"``mark_reg_read()`` source code for further details."
msgstr ""

#: ../../../bpf/verifier.rst:516
msgid ""
"Because stack writes could have different sizes ``REG_LIVE_WRITTEN`` marks "
"are applied conservatively: stack slots are marked as written only if write "
"size corresponds to the size of the register, e.g. see function "
"``save_register_state()``."
msgstr ""

#: ../../../bpf/verifier.rst:520
msgid "Consider the following example::"
msgstr ""

#: ../../../bpf/verifier.rst:528
msgid ""
"As stated above, the write at (1) does not count as ``REG_LIVE_WRITTEN``. "
"Should it be otherwise, the algorithm above wouldn't be able to propagate "
"the read mark from (3) to checkpoint #0."
msgstr ""

#: ../../../bpf/verifier.rst:532
msgid ""
"Once the ``BPF_EXIT`` instruction is reached ``update_branch_counts()`` is "
"called to update the ``->branches`` counter for each verifier state in a "
"chain of parent verifier states. When the ``->branches`` counter reaches "
"zero the verifier state becomes a valid entry in a set of cached verifier "
"states."
msgstr ""

#: ../../../bpf/verifier.rst:537
msgid ""
"Each entry of the verifier states cache is post-processed by a function "
"``clean_live_states()``. This function marks all registers and stack slots "
"without ``REG_LIVE_READ{32,64}`` marks as ``NOT_INIT`` or ``STACK_INVALID``. "
"Registers/stack slots marked in this way are ignored in function "
"``stacksafe()`` called from ``states_equal()`` when a state cache entry is "
"considered for equivalence with a current state."
msgstr ""

#: ../../../bpf/verifier.rst:544
msgid ""
"Now it is possible to explain how the example from the beginning of the "
"section works::"
msgstr ""

#: ../../../bpf/verifier.rst:555
msgid ""
"At instruction #2 branching point is reached and state ``{ r0 == 0, r1 == 0, "
"pc == 4 }`` is pushed to states processing queue (pc stands for program "
"counter)."
msgstr ""

#: ../../../bpf/verifier.rst:558
msgid "At instruction #4:"
msgstr ""

#: ../../../bpf/verifier.rst:560
msgid ""
"``checkpoint[0]`` states cache entry is created: ``{ r0 == 1, r1 == 0, pc == "
"4 }``;"
msgstr ""

#: ../../../bpf/verifier.rst:561
msgid "``checkpoint[0].r0`` is marked as written;"
msgstr ""

#: ../../../bpf/verifier.rst:562
msgid "``checkpoint[0].r1`` is marked as read;"
msgstr ""

#: ../../../bpf/verifier.rst:564
msgid ""
"At instruction #5 exit is reached and ``checkpoint[0]`` can now be processed "
"by ``clean_live_states()``. After this processing ``checkpoint[0].r1`` has a "
"read mark and all other registers and stack slots are marked as ``NOT_INIT`` "
"or ``STACK_INVALID``"
msgstr ""

#: ../../../bpf/verifier.rst:569
msgid ""
"The state ``{ r0 == 0, r1 == 0, pc == 4 }`` is popped from the states queue "
"and is compared against a cached state ``{ r1 == 0, pc == 4 }``, the states "
"are considered equivalent."
msgstr ""

#: ../../../bpf/verifier.rst:576
msgid "Read marks propagation for cache hits"
msgstr ""

#: ../../../bpf/verifier.rst:578
msgid ""
"Another point is the handling of read marks when a previously verified state "
"is found in the states cache. Upon cache hit verifier must behave in the "
"same way as if the current state was verified to the program exit. This "
"means that all read marks, present on registers and stack slots of the "
"cached state, must be propagated over the parentage chain of the current "
"state. Example below shows why this is important. Function "
"``propagate_liveness()`` handles this case."
msgstr ""

#: ../../../bpf/verifier.rst:585
msgid ""
"Consider the following state parentage chain (S is a starting state, A-E are "
"derived states, -> arrows show which state is derived from which)::"
msgstr ""

#: ../../../bpf/verifier.rst:602
msgid "Chain of states ``S -> A -> B -> exit`` is verified first."
msgstr ""

#: ../../../bpf/verifier.rst:604
msgid ""
"While ``B -> exit`` is verified, register ``r1`` is read and this read mark "
"is propagated up to state ``A``."
msgstr ""

#: ../../../bpf/verifier.rst:607
msgid ""
"When chain of states ``C -> D`` is verified the state ``D`` turns out to be "
"equivalent to state ``B``."
msgstr ""

#: ../../../bpf/verifier.rst:610
msgid ""
"The read mark for ``r1`` has to be propagated to state ``C``, otherwise "
"state ``C`` might get mistakenly marked as equivalent to state ``E`` even "
"though values for register ``r1`` differ between ``C`` and ``E``."
msgstr ""

#: ../../../bpf/verifier.rst:615
msgid "Understanding eBPF verifier messages"
msgstr ""

#: ../../../bpf/verifier.rst:617
msgid ""
"The following are few examples of invalid eBPF programs and verifier error "
"messages as seen in the log:"
msgstr ""

#: ../../../bpf/verifier.rst:620
msgid "Program with unreachable instructions::"
msgstr ""

#: ../../../bpf/verifier.rst:627 ../../../bpf/verifier.rst:636
#: ../../../bpf/verifier.rst:646 ../../../bpf/verifier.rst:657
#: ../../../bpf/verifier.rst:670 ../../../bpf/verifier.rst:687
#: ../../../bpf/verifier.rst:707 ../../../bpf/verifier.rst:729
#: ../../../bpf/verifier.rst:756 ../../../bpf/verifier.rst:786
#: ../../../bpf/verifier.rst:813
msgid "Error::"
msgstr ""

#: ../../../bpf/verifier.rst:631
msgid "Program that reads uninitialized register::"
msgstr ""

#: ../../../bpf/verifier.rst:641
msgid "Program that doesn't initialize R0 before exiting::"
msgstr ""

#: ../../../bpf/verifier.rst:652
msgid "Program that accesses stack out of bounds::"
msgstr ""

#: ../../../bpf/verifier.rst:662
msgid ""
"Program that doesn't initialize stack before passing its address into "
"function::"
msgstr ""

#: ../../../bpf/verifier.rst:678
msgid ""
"Program that uses invalid map_fd=0 while calling to map_lookup_elem() "
"function::"
msgstr ""

#: ../../../bpf/verifier.rst:696
msgid ""
"Program that doesn't check return value of map_lookup_elem() before "
"accessing map element::"
msgstr ""

#: ../../../bpf/verifier.rst:717
msgid ""
"Program that correctly checks map_lookup_elem() returned value for NULL, but "
"accesses the memory with incorrect alignment::"
msgstr ""

#: ../../../bpf/verifier.rst:741
msgid ""
"Program that correctly checks map_lookup_elem() returned value for NULL and "
"accesses memory with correct alignment in one side of 'if' branch, but fails "
"to do so in the other side of 'if' branch::"
msgstr ""

#: ../../../bpf/verifier.rst:772
msgid ""
"Program that performs a socket lookup then sets the pointer to NULL without "
"checking it::"
msgstr ""

#: ../../../bpf/verifier.rst:800
msgid ""
"Program that performs a socket lookup but does not NULL-check the returned "
"value::"
msgstr ""
