# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/map_lpm_trie.rst:6
msgid "BPF_MAP_TYPE_LPM_TRIE"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:9
msgid "``BPF_MAP_TYPE_LPM_TRIE`` was introduced in kernel version 4.11"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:11
msgid ""
"``BPF_MAP_TYPE_LPM_TRIE`` provides a longest prefix match algorithm that can "
"be used to match IP addresses to a stored set of prefixes. Internally, data "
"is stored in an unbalanced trie of nodes that uses ``prefixlen,data`` pairs "
"as its keys. The ``data`` is interpreted in network byte order, i.e. big "
"endian, so ``data[0]`` stores the most significant byte."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:18
msgid ""
"LPM tries may be created with a maximum prefix length that is a multiple of "
"8, in the range from 8 to 2048. The key used for lookup and update "
"operations is a ``struct bpf_lpm_trie_key_u8``, extended by "
"``max_prefixlen/8`` bytes."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:23
msgid "For IPv4 addresses the data length is 4 bytes"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:24
msgid "For IPv6 addresses the data length is 16 bytes"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:26
msgid "The value type stored in the LPM trie can be any user defined type."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:29
msgid ""
"When creating a map of type ``BPF_MAP_TYPE_LPM_TRIE`` you must set the "
"``BPF_F_NO_PREALLOC`` flag."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:33
msgid "Usage"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:36 ../../../bpf/map_lpm_trie.rst:116
msgid "Kernel BPF"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:39
msgid "bpf_map_lookup_elem()"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:45
msgid ""
"The longest prefix entry for a given data value can be found using the "
"``bpf_map_lookup_elem()`` helper. This helper returns a pointer to the value "
"associated with the longest matching ``key``, or ``NULL`` if no entry was "
"found."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:50
msgid ""
"The ``key`` should have ``prefixlen`` set to ``max_prefixlen`` when "
"performing longest prefix lookups. For example, when searching for the "
"longest prefix match for an IPv4 address, ``prefixlen`` should be set to "
"``32``."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:56
msgid "bpf_map_update_elem()"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:62
msgid ""
"Prefix entries can be added or updated using the ``bpf_map_update_elem()`` "
"helper. This helper replaces existing elements atomically."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:65
msgid ""
"``bpf_map_update_elem()`` returns ``0`` on success, or negative error in "
"case of failure."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:69
msgid ""
"The flags parameter must be one of BPF_ANY, BPF_NOEXIST or BPF_EXIST, but "
"the value is ignored, giving BPF_ANY semantics."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:73
msgid "bpf_map_delete_elem()"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:79
msgid ""
"Prefix entries can be deleted using the ``bpf_map_delete_elem()`` helper. "
"This helper will return 0 on success, or negative error in case of failure."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:84 ../../../bpf/map_lpm_trie.rst:154
msgid "Userspace"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:86
msgid ""
"Access from userspace uses libbpf APIs with the same names as above, with "
"the map identified by ``fd``."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:90
msgid "bpf_map_get_next_key()"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:96
msgid ""
"A userspace program can iterate through the entries in an LPM trie using "
"libbpf's ``bpf_map_get_next_key()`` function. The first key can be fetched "
"by calling ``bpf_map_get_next_key()`` with ``cur_key`` set to ``NULL``. "
"Subsequent calls will fetch the next key that follows the current key. "
"``bpf_map_get_next_key()`` returns ``0`` on success, ``-ENOENT`` if "
"``cur_key`` is the last key in the trie, or negative error in case of "
"failure."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:104
msgid ""
"``bpf_map_get_next_key()`` will iterate through the LPM trie elements from "
"leftmost leaf first. This means that iteration will return more specific "
"keys before less specific ones."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:109
msgid "Examples"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:111
msgid ""
"Please see ``tools/testing/selftests/bpf/test_lpm_map.c`` for examples of "
"LPM trie usage from userspace. The code snippets below demonstrate API usage."
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:118
msgid ""
"The following BPF code snippet shows how to declare a new LPM trie for IPv4 "
"address prefixes:"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:139
msgid "The following BPF code snippet shows how to lookup by IPv4 address:"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:156
msgid ""
"The following snippet shows how to insert an IPv4 prefix entry into an LPM "
"trie:"
msgstr ""

#: ../../../bpf/map_lpm_trie.rst:170
msgid ""
"The following snippet shows a userspace program walking through the entries "
"of an LPM trie:"
msgstr ""
