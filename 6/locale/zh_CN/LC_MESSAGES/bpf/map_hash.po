# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/map_hash.rst:7
msgid "BPF_MAP_TYPE_HASH, with PERCPU and LRU Variants"
msgstr ""

#: ../../../bpf/map_hash.rst:10
msgid "``BPF_MAP_TYPE_HASH`` was introduced in kernel version 3.19"
msgstr ""

#: ../../../bpf/map_hash.rst:11
msgid "``BPF_MAP_TYPE_PERCPU_HASH`` was introduced in version 4.6"
msgstr ""

#: ../../../bpf/map_hash.rst:12
msgid ""
"Both ``BPF_MAP_TYPE_LRU_HASH`` and ``BPF_MAP_TYPE_LRU_PERCPU_HASH`` were "
"introduced in version 4.10"
msgstr ""

#: ../../../bpf/map_hash.rst:15
msgid ""
"``BPF_MAP_TYPE_HASH`` and ``BPF_MAP_TYPE_PERCPU_HASH`` provide general "
"purpose hash map storage. Both the key and the value can be structs, "
"allowing for composite keys and values."
msgstr ""

#: ../../../bpf/map_hash.rst:19
msgid ""
"The kernel is responsible for allocating and freeing key/value pairs, up to "
"the max_entries limit that you specify. Hash maps use pre-allocation of hash "
"table elements by default. The ``BPF_F_NO_PREALLOC`` flag can be used to "
"disable pre-allocation when it is too memory expensive."
msgstr ""

#: ../../../bpf/map_hash.rst:24
msgid ""
"``BPF_MAP_TYPE_PERCPU_HASH`` provides a separate value slot per CPU. The per-"
"cpu values are stored internally in an array."
msgstr ""

#: ../../../bpf/map_hash.rst:27
msgid ""
"The ``BPF_MAP_TYPE_LRU_HASH`` and ``BPF_MAP_TYPE_LRU_PERCPU_HASH`` variants "
"add LRU semantics to their respective hash tables. An LRU hash will "
"automatically evict the least recently used entries when the hash table "
"reaches capacity. An LRU hash maintains an internal LRU list that is used to "
"select elements for eviction. This internal LRU list is shared across CPUs "
"but it is possible to request a per CPU LRU list with the "
"``BPF_F_NO_COMMON_LRU`` flag when calling ``bpf_map_create``.  The following "
"table outlines the properties of LRU maps depending on the a map type and "
"the flags used to create the map."
msgstr ""

#: ../../../bpf/map_hash.rst:38
msgid "Flag"
msgstr ""

#: ../../../bpf/map_hash.rst:38
msgid "``BPF_MAP_TYPE_LRU_HASH``"
msgstr ""

#: ../../../bpf/map_hash.rst:38
msgid "``BPF_MAP_TYPE_LRU_PERCPU_HASH``"
msgstr ""

#: ../../../bpf/map_hash.rst:40
msgid "**BPF_F_NO_COMMON_LRU**"
msgstr ""

#: ../../../bpf/map_hash.rst:40
msgid "Per-CPU LRU, global map"
msgstr ""

#: ../../../bpf/map_hash.rst:40
msgid "Per-CPU LRU, per-cpu map"
msgstr ""

#: ../../../bpf/map_hash.rst:41
msgid "**!BPF_F_NO_COMMON_LRU**"
msgstr ""

#: ../../../bpf/map_hash.rst:41
msgid "Global LRU, global map"
msgstr ""

#: ../../../bpf/map_hash.rst:41
msgid "Global LRU, per-cpu map"
msgstr ""

#: ../../../bpf/map_hash.rst:45
msgid "Usage"
msgstr ""

#: ../../../bpf/map_hash.rst:48
msgid "Kernel BPF"
msgstr ""

#: ../../../bpf/map_hash.rst:51
msgid "bpf_map_update_elem()"
msgstr ""

#: ../../../bpf/map_hash.rst:57
msgid ""
"Hash entries can be added or updated using the ``bpf_map_update_elem()`` "
"helper. This helper replaces existing elements atomically. The ``flags`` "
"parameter can be used to control the update behaviour:"
msgstr ""

#: ../../../bpf/map_hash.rst:61
msgid "``BPF_ANY`` will create a new element or update an existing element"
msgstr ""

#: ../../../bpf/map_hash.rst:62
msgid ""
"``BPF_NOEXIST`` will create a new element only if one did not already exist"
msgstr ""

#: ../../../bpf/map_hash.rst:64
msgid "``BPF_EXIST`` will update an existing element"
msgstr ""

#: ../../../bpf/map_hash.rst:66
msgid ""
"``bpf_map_update_elem()`` returns 0 on success, or negative error in case of "
"failure."
msgstr ""

#: ../../../bpf/map_hash.rst:70
msgid "bpf_map_lookup_elem()"
msgstr ""

#: ../../../bpf/map_hash.rst:76
msgid ""
"Hash entries can be retrieved using the ``bpf_map_lookup_elem()`` helper. "
"This helper returns a pointer to the value associated with ``key``, or "
"``NULL`` if no entry was found."
msgstr ""

#: ../../../bpf/map_hash.rst:81
msgid "bpf_map_delete_elem()"
msgstr ""

#: ../../../bpf/map_hash.rst:87
msgid ""
"Hash entries can be deleted using the ``bpf_map_delete_elem()`` helper. This "
"helper will return 0 on success, or negative error in case of failure."
msgstr ""

#: ../../../bpf/map_hash.rst:92
msgid "Per CPU Hashes"
msgstr ""

#: ../../../bpf/map_hash.rst:94
msgid ""
"For ``BPF_MAP_TYPE_PERCPU_HASH`` and ``BPF_MAP_TYPE_LRU_PERCPU_HASH`` the "
"``bpf_map_update_elem()`` and ``bpf_map_lookup_elem()`` helpers "
"automatically access the hash slot for the current CPU."
msgstr ""

#: ../../../bpf/map_hash.rst:99
msgid "bpf_map_lookup_percpu_elem()"
msgstr ""

#: ../../../bpf/map_hash.rst:105
msgid ""
"The ``bpf_map_lookup_percpu_elem()`` helper can be used to lookup the value "
"in the hash slot for a specific CPU. Returns value associated with ``key`` "
"on ``cpu`` , or ``NULL`` if no entry was found or ``cpu`` is invalid."
msgstr ""

#: ../../../bpf/map_hash.rst:111
msgid "Concurrency"
msgstr ""

#: ../../../bpf/map_hash.rst:113
msgid ""
"Values stored in ``BPF_MAP_TYPE_HASH`` can be accessed concurrently by "
"programs running on different CPUs.  Since Kernel version 5.1, the BPF "
"infrastructure provides ``struct bpf_spin_lock`` to synchronise access. See "
"``tools/testing/selftests/bpf/progs/test_spin_lock.c``."
msgstr ""

#: ../../../bpf/map_hash.rst:119
msgid "Userspace"
msgstr ""

#: ../../../bpf/map_hash.rst:122
msgid "bpf_map_get_next_key()"
msgstr ""

#: ../../../bpf/map_hash.rst:128
msgid ""
"In userspace, it is possible to iterate through the keys of a hash using "
"libbpf's ``bpf_map_get_next_key()`` function. The first key can be fetched "
"by calling ``bpf_map_get_next_key()`` with ``cur_key`` set to ``NULL``. "
"Subsequent calls will fetch the next key that follows the current key. "
"``bpf_map_get_next_key()`` returns 0 on success, -ENOENT if cur_key is the "
"last key in the hash, or negative error in case of failure."
msgstr ""

#: ../../../bpf/map_hash.rst:136
msgid ""
"Note that if ``cur_key`` gets deleted then ``bpf_map_get_next_key()`` will "
"instead return the *first* key in the hash table which is undesirable. It is "
"recommended to use batched lookup if there is going to be key deletion "
"intermixed with ``bpf_map_get_next_key()``."
msgstr ""

#: ../../../bpf/map_hash.rst:142
msgid "Examples"
msgstr ""

#: ../../../bpf/map_hash.rst:144
msgid ""
"Please see the ``tools/testing/selftests/bpf`` directory for functional "
"examples.  The code snippets below demonstrates API usage."
msgstr ""

#: ../../../bpf/map_hash.rst:147
msgid ""
"This example shows how to declare an LRU Hash with a struct key and a struct "
"value."
msgstr ""

#: ../../../bpf/map_hash.rst:171
msgid ""
"This example shows how to create or update hash values using atomic "
"instructions:"
msgstr ""

#: ../../../bpf/map_hash.rst:193
msgid "Userspace walking the map elements from the map declared above:"
msgstr ""

#: ../../../bpf/map_hash.rst:221
msgid "Internals"
msgstr ""

#: ../../../bpf/map_hash.rst:223
msgid ""
"This section of the document is targeted at Linux developers and describes "
"aspects of the map implementations that are not considered stable ABI. The "
"following details are subject to change in future versions of the kernel."
msgstr ""

#: ../../../bpf/map_hash.rst:228
msgid "``BPF_MAP_TYPE_LRU_HASH`` and variants"
msgstr ""

#: ../../../bpf/map_hash.rst:230
msgid ""
"Updating elements in LRU maps may trigger eviction behaviour when the "
"capacity of the map is reached. There are various steps that the update "
"algorithm attempts in order to enforce the LRU property which have "
"increasing impacts on other CPUs involved in the following operation "
"attempts:"
msgstr ""

#: ../../../bpf/map_hash.rst:235
msgid "Attempt to use CPU-local state to batch operations"
msgstr ""

#: ../../../bpf/map_hash.rst:236
msgid "Attempt to fetch ``target_free`` free nodes from global lists"
msgstr ""

#: ../../../bpf/map_hash.rst:237
msgid ""
"Attempt to pull any node from a global list and remove it from the hashmap"
msgstr ""

#: ../../../bpf/map_hash.rst:238
msgid ""
"Attempt to pull any node from any CPU's list and remove it from the hashmap"
msgstr ""

#: ../../../bpf/map_hash.rst:240
msgid ""
"The number of nodes to borrow from the global list in a batch, "
"``target_free``, depends on the size of the map. Larger batch size reduces "
"lock contention, but may also exhaust the global structure. The value is "
"computed at map init to avoid exhaustion, by limiting aggregate reservation "
"by all CPUs to half the map size. With a minimum of a single element and "
"maximum budget of 128 at a time."
msgstr ""

#: ../../../bpf/map_hash.rst:246
msgid ""
"This algorithm is described visually in the following diagram. See the "
"description in commit 3a08c2fd7634 (\"bpf: LRU List\") for a full "
"explanation of the corresponding operations:"
msgstr ""

#: ../../../bpf/map_hash.rst:250
msgid "Diagram outlining the LRU eviction steps taken during map update."
msgstr ""

#: ../../../bpf/map_hash.rst:253
msgid ""
"LRU hash eviction during map update for ``BPF_MAP_TYPE_LRU_HASH`` and "
"variants. See the dot file source for kernel function name code references."
msgstr ""

#: ../../../bpf/map_hash.rst:256
msgid ""
"Map updates start from the oval in the top right \"begin "
"``bpf_map_update()``\" and progress through the graph towards the bottom "
"where the result may be either a successful update or a failure with various "
"error codes. The key in the top right provides indicators for which locks "
"may be involved in specific operations. This is intended as a visual hint "
"for reasoning about how map contention may impact update operations, though "
"the map type and flags may impact the actual contention on those locks, "
"based on the logic described in the table above. For instance, if the map is "
"created with type ``BPF_MAP_TYPE_LRU_PERCPU_HASH`` and flags "
"``BPF_F_NO_COMMON_LRU`` then all map properties would be per-cpu."
msgstr ""
