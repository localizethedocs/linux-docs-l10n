# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/ftrace.rst:3
msgid "ftrace - Function Tracer"
msgstr ""

#: ../../../trace/ftrace.rst:5
msgid "Copyright 2008 Red Hat Inc."
msgstr ""

#: ../../../trace/ftrace.rst:0
msgid "Author"
msgstr ""

#: ../../../trace/ftrace.rst:7
msgid "Steven Rostedt <srostedt@redhat.com>"
msgstr ""

#: ../../../trace/ftrace.rst:0
msgid "License"
msgstr ""

#: ../../../trace/ftrace.rst:8
msgid ""
"The GNU Free Documentation License, Version 1.2 (dual licensed under the GPL "
"v2)"
msgstr ""

#: ../../../trace/ftrace.rst:0
msgid "Original Reviewers"
msgstr ""

#: ../../../trace/ftrace.rst:10
msgid ""
"Elias Oltmanns, Randy Dunlap, Andrew Morton, John Kacur, and David Teigland."
msgstr ""

#: ../../../trace/ftrace.rst:13
msgid "Written for: 2.6.28-rc2"
msgstr ""

#: ../../../trace/ftrace.rst:14
msgid "Updated for: 3.10"
msgstr ""

#: ../../../trace/ftrace.rst:15
msgid "Updated for: 4.13 - Copyright 2017 VMware Inc. Steven Rostedt"
msgstr ""

#: ../../../trace/ftrace.rst:16
msgid "Converted to rst format - Changbin Du <changbin.du@intel.com>"
msgstr ""

#: ../../../trace/ftrace.rst:19
msgid "Introduction"
msgstr ""

#: ../../../trace/ftrace.rst:21
msgid ""
"Ftrace is an internal tracer designed to help out developers and designers "
"of systems to find what is going on inside the kernel. It can be used for "
"debugging or analyzing latencies and performance issues that take place "
"outside of user-space."
msgstr ""

#: ../../../trace/ftrace.rst:26
msgid ""
"Although ftrace is typically considered the function tracer, it is really a "
"framework of several assorted tracing utilities. There's latency tracing to "
"examine what occurs between interrupts disabled and enabled, as well as for "
"preemption and from a time a task is woken to the task is actually scheduled "
"in."
msgstr ""

#: ../../../trace/ftrace.rst:32
msgid ""
"One of the most common uses of ftrace is the event tracing. Throughout the "
"kernel are hundreds of static event points that can be enabled via the "
"tracefs file system to see what is going on in certain parts of the kernel."
msgstr ""

#: ../../../trace/ftrace.rst:37 ../../../trace/ftrace.rst:679
#: ../../../trace/ftrace.rst:685 ../../../trace/ftrace.rst:691
msgid "See events.rst for more information."
msgstr ""

#: ../../../trace/ftrace.rst:41
msgid "Implementation Details"
msgstr ""

#: ../../../trace/ftrace.rst:43
msgid ""
"See Documentation/trace/ftrace-design.rst for details for arch porters and "
"such."
msgstr ""

#: ../../../trace/ftrace.rst:47
msgid "The File System"
msgstr ""

#: ../../../trace/ftrace.rst:49
msgid ""
"Ftrace uses the tracefs file system to hold the control files as well as the "
"files to display output."
msgstr ""

#: ../../../trace/ftrace.rst:52
msgid ""
"When tracefs is configured into the kernel (which selecting any ftrace "
"option will do) the directory /sys/kernel/tracing will be created. To mount "
"this directory, you can add to your /etc/fstab file::"
msgstr ""

#: ../../../trace/ftrace.rst:58
msgid "Or you can mount it at run time with::"
msgstr ""

#: ../../../trace/ftrace.rst:62
msgid ""
"For quicker access to that directory you may want to make a soft link to it::"
msgstr ""

#: ../../../trace/ftrace.rst:69
msgid ""
"Before 4.1, all ftrace tracing control files were within the debugfs file "
"system, which is typically located at /sys/kernel/debug/tracing. For "
"backward compatibility, when mounting the debugfs file system, the tracefs "
"file system will be automatically mounted at:"
msgstr ""

#: ../../../trace/ftrace.rst:74
msgid "/sys/kernel/debug/tracing"
msgstr ""

#: ../../../trace/ftrace.rst:76
msgid ""
"All files located in the tracefs file system will be located in that debugfs "
"file system directory as well."
msgstr ""

#: ../../../trace/ftrace.rst:81
msgid ""
"Any selected ftrace option will also create the tracefs file system. The "
"rest of the document will assume that you are in the ftrace directory (cd /"
"sys/kernel/tracing) and will only concentrate on the files within that "
"directory and not distract from the content with the extended \"/sys/kernel/"
"tracing\" path name."
msgstr ""

#: ../../../trace/ftrace.rst:87
msgid "That's it! (assuming that you have ftrace configured into your kernel)"
msgstr ""

#: ../../../trace/ftrace.rst:89
msgid ""
"After mounting tracefs you will have access to the control and output files "
"of ftrace. Here is a list of some of the key files:"
msgstr ""

#: ../../../trace/ftrace.rst:93
msgid "Note: all time values are in microseconds."
msgstr ""

#: ../../../trace/ftrace.rst:95
msgid "current_tracer:"
msgstr ""

#: ../../../trace/ftrace.rst:97
msgid ""
"This is used to set or display the current tracer that is configured. "
"Changing the current tracer clears the ring buffer content as well as the "
"\"snapshot\" buffer."
msgstr ""

#: ../../../trace/ftrace.rst:101
msgid "available_tracers:"
msgstr ""

#: ../../../trace/ftrace.rst:103
msgid ""
"This holds the different types of tracers that have been compiled into the "
"kernel. The tracers listed here can be configured by echoing their name into "
"current_tracer."
msgstr ""

#: ../../../trace/ftrace.rst:108
msgid "tracing_on:"
msgstr ""

#: ../../../trace/ftrace.rst:110
msgid ""
"This sets or displays whether writing to the trace ring buffer is enabled. "
"Echo 0 into this file to disable the tracer or 1 to enable it. Note, this "
"only disables writing to the ring buffer, the tracing overhead may still be "
"occurring."
msgstr ""

#: ../../../trace/ftrace.rst:116
msgid ""
"The kernel function tracing_off() can be used within the kernel to disable "
"writing to the ring buffer, which will set this file to \"0\". User space "
"can re-enable tracing by echoing \"1\" into the file."
msgstr ""

#: ../../../trace/ftrace.rst:121
msgid ""
"Note, the function and event trigger \"traceoff\" will also set this file to "
"zero and stop tracing. Which can also be re-enabled by user space using this "
"file."
msgstr ""

#: ../../../trace/ftrace.rst:125
msgid "trace:"
msgstr ""

#: ../../../trace/ftrace.rst:127
msgid ""
"This file holds the output of the trace in a human readable format "
"(described below). Opening this file for writing with the O_TRUNC flag "
"clears the ring buffer content. Note, this file is not a consumer. If "
"tracing is off (no tracer running, or tracing_on is zero), it will produce "
"the same output each time it is read. When tracing is on, it may produce "
"inconsistent results as it tries to read the entire buffer without consuming "
"it."
msgstr ""

#: ../../../trace/ftrace.rst:136
msgid "trace_pipe:"
msgstr ""

#: ../../../trace/ftrace.rst:138
msgid ""
"The output is the same as the \"trace\" file but this file is meant to be "
"streamed with live tracing. Reads from this file will block until new data "
"is retrieved.  Unlike the \"trace\" file, this file is a consumer. This "
"means reading from this file causes sequential reads to display more current "
"data. Once data is read from this file, it is consumed, and will not be read "
"again with a sequential read. The \"trace\" file is static, and if the "
"tracer is not adding more data, it will display the same information every "
"time it is read."
msgstr ""

#: ../../../trace/ftrace.rst:150
msgid "trace_options:"
msgstr ""

#: ../../../trace/ftrace.rst:152
msgid ""
"This file lets the user control the amount of data that is displayed in one "
"of the above output files. Options also exist to modify how a tracer or "
"events work (stack traces, timestamps, etc)."
msgstr ""

#: ../../../trace/ftrace.rst:157
msgid "options:"
msgstr ""

#: ../../../trace/ftrace.rst:159
msgid ""
"This is a directory that has a file for every available trace option (also "
"in trace_options). Options may also be set or cleared by writing a \"1\" or "
"\"0\" respectively into the corresponding file with the option name."
msgstr ""

#: ../../../trace/ftrace.rst:164
msgid "tracing_max_latency:"
msgstr ""

#: ../../../trace/ftrace.rst:166
msgid ""
"Some of the tracers record the max latency. For example, the maximum time "
"that interrupts are disabled. The maximum time is saved in this file. The "
"max trace will also be stored, and displayed by \"trace\". A new max trace "
"will only be recorded if the latency is greater than the value in this file "
"(in microseconds)."
msgstr ""

#: ../../../trace/ftrace.rst:173
msgid ""
"By echoing in a time into this file, no latency will be recorded unless it "
"is greater than the time in this file."
msgstr ""

#: ../../../trace/ftrace.rst:176
msgid "tracing_thresh:"
msgstr ""

#: ../../../trace/ftrace.rst:178
msgid ""
"Some latency tracers will record a trace whenever the latency is greater "
"than the number in this file. Only active when the file contains a number "
"greater than 0. (in microseconds)"
msgstr ""

#: ../../../trace/ftrace.rst:183
msgid "buffer_percent:"
msgstr ""

#: ../../../trace/ftrace.rst:185
msgid ""
"This is the watermark for how much the ring buffer needs to be filled before "
"a waiter is woken up. That is, if an application calls a blocking read "
"syscall on one of the per_cpu trace_pipe_raw files, it will block until the "
"given amount of data specified by buffer_percent is in the ring buffer "
"before it wakes the reader up. This also controls how the splice system "
"calls are blocked on this file::"
msgstr ""

#: ../../../trace/ftrace.rst:198
msgid "buffer_size_kb:"
msgstr ""

#: ../../../trace/ftrace.rst:200
msgid ""
"This sets or displays the number of kilobytes each CPU buffer holds. By "
"default, the trace buffers are the same size for each CPU. The displayed "
"number is the size of the CPU buffer and not total size of all buffers. The "
"trace buffers are allocated in pages (blocks of memory that the kernel uses "
"for allocation, usually 4 KB in size). A few extra pages may be allocated to "
"accommodate buffer management meta-data. If the last page allocated has room "
"for more bytes than requested, the rest of the page will be used, making the "
"actual allocation bigger than requested or shown. ( Note, the size may not "
"be a multiple of the page size due to buffer management meta-data. )"
msgstr ""

#: ../../../trace/ftrace.rst:213
msgid ""
"Buffer sizes for individual CPUs may vary (see \"per_cpu/cpu0/"
"buffer_size_kb\" below), and if they do this file will show \"X\"."
msgstr ""

#: ../../../trace/ftrace.rst:217
msgid "buffer_total_size_kb:"
msgstr ""

#: ../../../trace/ftrace.rst:219
msgid "This displays the total combined size of all the trace buffers."
msgstr ""

#: ../../../trace/ftrace.rst:221
msgid "buffer_subbuf_size_kb:"
msgstr ""

#: ../../../trace/ftrace.rst:223
msgid ""
"This sets or displays the sub buffer size. The ring buffer is broken up into "
"several same size \"sub buffers\". An event can not be bigger than the size "
"of the sub buffer. Normally, the sub buffer is the size of the "
"architecture's page (4K on x86). The sub buffer also contains meta data at "
"the start which also limits the size of an event.  That means when the sub "
"buffer is a page size, no event can be larger than the page size minus the "
"sub buffer meta data."
msgstr ""

#: ../../../trace/ftrace.rst:231
msgid ""
"Note, the buffer_subbuf_size_kb is a way for the user to specify the minimum "
"size of the subbuffer. The kernel may make it bigger due to the "
"implementation details, or simply fail the operation if the kernel can not "
"handle the request."
msgstr ""

#: ../../../trace/ftrace.rst:236
msgid ""
"Changing the sub buffer size allows for events to be larger than the page "
"size."
msgstr ""

#: ../../../trace/ftrace.rst:239
msgid ""
"Note: When changing the sub-buffer size, tracing is stopped and any data in "
"the ring buffer and the snapshot buffer will be discarded."
msgstr ""

#: ../../../trace/ftrace.rst:242
msgid "free_buffer:"
msgstr ""

#: ../../../trace/ftrace.rst:244
msgid ""
"If a process is performing tracing, and the ring buffer should be shrunk "
"\"freed\" when the process is finished, even if it were to be killed by a "
"signal, this file can be used for that purpose. On close of this file, the "
"ring buffer will be resized to its minimum size. Having a process that is "
"tracing also open this file, when the process exits its file descriptor for "
"this file will be closed, and in doing so, the ring buffer will be \"freed\"."
msgstr ""

#: ../../../trace/ftrace.rst:252
msgid "It may also stop tracing if disable_on_free option is set."
msgstr ""

#: ../../../trace/ftrace.rst:254
msgid "tracing_cpumask:"
msgstr ""

#: ../../../trace/ftrace.rst:256
msgid ""
"This is a mask that lets the user only trace on specified CPUs. The format "
"is a hex string representing the CPUs."
msgstr ""

#: ../../../trace/ftrace.rst:259
msgid "set_ftrace_filter:"
msgstr ""

#: ../../../trace/ftrace.rst:261
msgid ""
"When dynamic ftrace is configured in (see the section below \"dynamic "
"ftrace\"), the code is dynamically modified (code text rewrite) to disable "
"calling of the function profiler (mcount). This lets tracing be configured "
"in with practically no overhead in performance.  This also has a side effect "
"of enabling or disabling specific functions to be traced. Echoing names of "
"functions into this file will limit the trace to only those functions. This "
"influences the tracers \"function\" and \"function_graph\" and thus also "
"function profiling (see \"function_profile_enabled\")."
msgstr ""

#: ../../../trace/ftrace.rst:272
msgid ""
"The functions listed in \"available_filter_functions\" are what can be "
"written into this file."
msgstr ""

#: ../../../trace/ftrace.rst:275
msgid ""
"This interface also allows for commands to be used. See the \"Filter "
"commands\" section for more details."
msgstr ""

#: ../../../trace/ftrace.rst:278
msgid ""
"As a speed up, since processing strings can be quite expensive and requires "
"a check of all functions registered to tracing, instead an index can be "
"written into this file. A number (starting with \"1\") written will instead "
"select the same corresponding at the line position of the "
"\"available_filter_functions\" file."
msgstr ""

#: ../../../trace/ftrace.rst:284
msgid "set_ftrace_notrace:"
msgstr ""

#: ../../../trace/ftrace.rst:286
msgid ""
"This has an effect opposite to that of set_ftrace_filter. Any function that "
"is added here will not be traced. If a function exists in both "
"set_ftrace_filter and set_ftrace_notrace, the function will _not_ be traced."
msgstr ""

#: ../../../trace/ftrace.rst:291
msgid "set_ftrace_pid:"
msgstr ""

#: ../../../trace/ftrace.rst:293
msgid ""
"Have the function tracer only trace the threads whose PID are listed in this "
"file."
msgstr ""

#: ../../../trace/ftrace.rst:296
msgid ""
"If the \"function-fork\" option is set, then when a task whose PID is listed "
"in this file forks, the child's PID will automatically be added to this "
"file, and the child will be traced by the function tracer as well. This "
"option will also cause PIDs of tasks that exit to be removed from the file."
msgstr ""

#: ../../../trace/ftrace.rst:302
msgid "set_ftrace_notrace_pid:"
msgstr ""

#: ../../../trace/ftrace.rst:304
msgid ""
"Have the function tracer ignore threads whose PID are listed in this file."
msgstr ""

#: ../../../trace/ftrace.rst:307
msgid ""
"If the \"function-fork\" option is set, then when a task whose PID is listed "
"in this file forks, the child's PID will automatically be added to this "
"file, and the child will not be traced by the function tracer as well. This "
"option will also cause PIDs of tasks that exit to be removed from the file."
msgstr ""

#: ../../../trace/ftrace.rst:313
msgid ""
"If a PID is in both this file and \"set_ftrace_pid\", then this file takes "
"precedence, and the thread will not be traced."
msgstr ""

#: ../../../trace/ftrace.rst:316
msgid "set_event_pid:"
msgstr ""

#: ../../../trace/ftrace.rst:318
msgid ""
"Have the events only trace a task with a PID listed in this file. Note, "
"sched_switch and sched_wake_up will also trace events listed in this file."
msgstr ""

#: ../../../trace/ftrace.rst:322 ../../../trace/ftrace.rst:335
msgid ""
"To have the PIDs of children of tasks with their PID in this file added on "
"fork, enable the \"event-fork\" option. That option will also cause the PIDs "
"of tasks to be removed from this file when the task exits."
msgstr ""

#: ../../../trace/ftrace.rst:327
msgid "set_event_notrace_pid:"
msgstr ""

#: ../../../trace/ftrace.rst:329
msgid ""
"Have the events not trace a task with a PID listed in this file. Note, "
"sched_switch and sched_wakeup will trace threads not listed in this file, "
"even if a thread's PID is in the file if the sched_switch or sched_wakeup "
"events also trace a thread that should be traced."
msgstr ""

#: ../../../trace/ftrace.rst:340
msgid "set_graph_function:"
msgstr ""

#: ../../../trace/ftrace.rst:342
msgid ""
"Functions listed in this file will cause the function graph tracer to only "
"trace these functions and the functions that they call. (See the section "
"\"dynamic ftrace\" for more details). Note, set_ftrace_filter and "
"set_ftrace_notrace still affects what functions are being traced."
msgstr ""

#: ../../../trace/ftrace.rst:348
msgid "set_graph_notrace:"
msgstr ""

#: ../../../trace/ftrace.rst:350
msgid ""
"Similar to set_graph_function, but will disable function graph tracing when "
"the function is hit until it exits the function. This makes it possible to "
"ignore tracing functions that are called by a specific function."
msgstr ""

#: ../../../trace/ftrace.rst:355
msgid "available_filter_functions:"
msgstr ""

#: ../../../trace/ftrace.rst:357
msgid ""
"This lists the functions that ftrace has processed and can trace. These are "
"the function names that you can pass to \"set_ftrace_filter\", "
"\"set_ftrace_notrace\", \"set_graph_function\", or \"set_graph_notrace\". "
"(See the section \"dynamic ftrace\" below for more details.)"
msgstr ""

#: ../../../trace/ftrace.rst:363
msgid "available_filter_functions_addrs:"
msgstr ""

#: ../../../trace/ftrace.rst:365
msgid ""
"Similar to available_filter_functions, but with address displayed for each "
"function. The displayed address is the patch-site address and can differ "
"from /proc/kallsyms address."
msgstr ""

#: ../../../trace/ftrace.rst:369
msgid "syscall_user_buf_size:"
msgstr ""

#: ../../../trace/ftrace.rst:371
msgid ""
"Some system call trace events will record the data from a user space address "
"that one of the parameters point to. The amount of data per event is "
"limited. This file holds the max number of bytes that will be recorded into "
"the ring buffer to hold this data. The max value is currently 165."
msgstr ""

#: ../../../trace/ftrace.rst:377
msgid "dyn_ftrace_total_info:"
msgstr ""

#: ../../../trace/ftrace.rst:379
msgid ""
"This file is for debugging purposes. The number of functions that have been "
"converted to nops and are available to be traced."
msgstr ""

#: ../../../trace/ftrace.rst:382
msgid "enabled_functions:"
msgstr ""

#: ../../../trace/ftrace.rst:384
msgid ""
"This file is more for debugging ftrace, but can also be useful in seeing if "
"any function has a callback attached to it. Not only does the trace "
"infrastructure use ftrace function trace utility, but other subsystems might "
"too. This file displays all functions that have a callback attached to them "
"as well as the number of callbacks that have been attached. Note, a callback "
"may also call multiple functions which will not be listed in this count."
msgstr ""

#: ../../../trace/ftrace.rst:393
msgid ""
"If the callback registered to be traced by a function with the \"save regs\" "
"attribute (thus even more overhead), an 'R' will be displayed on the same "
"line as the function that is returning registers."
msgstr ""

#: ../../../trace/ftrace.rst:398
msgid ""
"If the callback registered to be traced by a function with the \"ip modify\" "
"attribute (thus the regs->ip can be changed), an 'I' will be displayed on "
"the same line as the function that can be overridden."
msgstr ""

#: ../../../trace/ftrace.rst:403
msgid ""
"If a non-ftrace trampoline is attached (BPF) a 'D' will be displayed. Note, "
"normal ftrace trampolines can also be attached, but only one \"direct\" "
"trampoline can be attached to a given function at a time."
msgstr ""

#: ../../../trace/ftrace.rst:407
msgid ""
"Some architectures can not call direct trampolines, but instead have the "
"ftrace ops function located above the function entry point. In such cases an "
"'O' will be displayed."
msgstr ""

#: ../../../trace/ftrace.rst:411
msgid ""
"If a function had either the \"ip modify\" or a \"direct\" call attached to "
"it in the past, a 'M' will be shown. This flag is never cleared. It is used "
"to know if a function was ever modified by the ftrace infrastructure, and "
"can be used for debugging."
msgstr ""

#: ../../../trace/ftrace.rst:416
msgid ""
"If the architecture supports it, it will also show what callback is being "
"directly called by the function. If the count is greater than 1 it most "
"likely will be ftrace_ops_list_func()."
msgstr ""

#: ../../../trace/ftrace.rst:420
msgid ""
"If the callback of a function jumps to a trampoline that is specific to the "
"callback and which is not the standard trampoline, its address will be "
"printed as well as the function that the trampoline calls."
msgstr ""

#: ../../../trace/ftrace.rst:425
msgid "touched_functions:"
msgstr ""

#: ../../../trace/ftrace.rst:427
msgid ""
"This file contains all the functions that ever had a function callback to it "
"via the ftrace infrastructure. It has the same format as enabled_functions "
"but shows all functions that have ever been traced."
msgstr ""

#: ../../../trace/ftrace.rst:432
msgid ""
"To see any function that has every been modified by \"ip modify\" or a "
"direct trampoline, one can perform the following command:"
msgstr ""

#: ../../../trace/ftrace.rst:435
msgid "grep ' M ' /sys/kernel/tracing/touched_functions"
msgstr ""

#: ../../../trace/ftrace.rst:437
msgid "function_profile_enabled:"
msgstr ""

#: ../../../trace/ftrace.rst:439
msgid ""
"When set it will enable all functions with either the function tracer, or if "
"configured, the function graph tracer. It will keep a histogram of the "
"number of functions that were called and if the function graph tracer was "
"configured, it will also keep track of the time spent in those functions. "
"The histogram content can be displayed in the files:"
msgstr ""

#: ../../../trace/ftrace.rst:446
msgid "trace_stat/function<cpu> ( function0, function1, etc)."
msgstr ""

#: ../../../trace/ftrace.rst:448
msgid "trace_stat:"
msgstr ""

#: ../../../trace/ftrace.rst:450
msgid "A directory that holds different tracing stats."
msgstr ""

#: ../../../trace/ftrace.rst:452
msgid "kprobe_events:"
msgstr ""

#: ../../../trace/ftrace.rst:454
msgid "Enable dynamic trace points. See kprobetrace.rst."
msgstr ""

#: ../../../trace/ftrace.rst:456
msgid "kprobe_profile:"
msgstr ""

#: ../../../trace/ftrace.rst:458
msgid "Dynamic trace points stats. See kprobetrace.rst."
msgstr ""

#: ../../../trace/ftrace.rst:460
msgid "max_graph_depth:"
msgstr ""

#: ../../../trace/ftrace.rst:462
msgid ""
"Used with the function graph tracer. This is the max depth it will trace "
"into a function. Setting this to a value of one will show only the first "
"kernel function that is called from user space."
msgstr ""

#: ../../../trace/ftrace.rst:467
msgid "printk_formats:"
msgstr ""

#: ../../../trace/ftrace.rst:469
msgid ""
"This is for tools that read the raw format files. If an event in the ring "
"buffer references a string, only a pointer to the string is recorded into "
"the buffer and not the string itself. This prevents tools from knowing what "
"that string was. This file displays the string and address for the string "
"allowing tools to map the pointers to what the strings were."
msgstr ""

#: ../../../trace/ftrace.rst:476
msgid "saved_cmdlines:"
msgstr ""

#: ../../../trace/ftrace.rst:478
msgid ""
"Only the pid of the task is recorded in a trace event unless the event "
"specifically saves the task comm as well. Ftrace makes a cache of pid "
"mappings to comms to try to display comms for events. If a pid for a comm is "
"not listed, then \"<...>\" is displayed in the output."
msgstr ""

#: ../../../trace/ftrace.rst:484
msgid ""
"If the option \"record-cmd\" is set to \"0\", then comms of tasks will not "
"be saved during recording. By default, it is enabled."
msgstr ""

#: ../../../trace/ftrace.rst:487
msgid "saved_cmdlines_size:"
msgstr ""

#: ../../../trace/ftrace.rst:489
msgid ""
"By default, 128 comms are saved (see \"saved_cmdlines\" above). To increase "
"or decrease the amount of comms that are cached, echo the number of comms to "
"cache into this file."
msgstr ""

#: ../../../trace/ftrace.rst:493
msgid "saved_tgids:"
msgstr ""

#: ../../../trace/ftrace.rst:495
msgid ""
"If the option \"record-tgid\" is set, on each scheduling context switch the "
"Task Group ID of a task is saved in a table mapping the PID of the thread to "
"its TGID. By default, the \"record-tgid\" option is disabled."
msgstr ""

#: ../../../trace/ftrace.rst:500 ../../../trace/ftrace.rst:3551
msgid "snapshot:"
msgstr ""

#: ../../../trace/ftrace.rst:502
msgid ""
"This displays the \"snapshot\" buffer and also lets the user take a snapshot "
"of the current running trace. See the \"Snapshot\" section below for more "
"details."
msgstr ""

#: ../../../trace/ftrace.rst:506
msgid "stack_max_size:"
msgstr ""

#: ../../../trace/ftrace.rst:508
msgid ""
"When the stack tracer is activated, this will display the maximum stack size "
"it has encountered. See the \"Stack Trace\" section below."
msgstr ""

#: ../../../trace/ftrace.rst:512
msgid "stack_trace:"
msgstr ""

#: ../../../trace/ftrace.rst:514
msgid ""
"This displays the stack back trace of the largest stack that was encountered "
"when the stack tracer is activated. See the \"Stack Trace\" section below."
msgstr ""

#: ../../../trace/ftrace.rst:518
msgid "stack_trace_filter:"
msgstr ""

#: ../../../trace/ftrace.rst:520
msgid ""
"This is similar to \"set_ftrace_filter\" but it limits what functions the "
"stack tracer will check."
msgstr ""

#: ../../../trace/ftrace.rst:523
msgid "trace_clock:"
msgstr ""

#: ../../../trace/ftrace.rst:525
msgid ""
"Whenever an event is recorded into the ring buffer, a \"timestamp\" is "
"added. This stamp comes from a specified clock. By default, ftrace uses the "
"\"local\" clock. This clock is very fast and strictly per CPU, but on some "
"systems it may not be monotonic with respect to other CPUs. In other words, "
"the local clocks may not be in sync with local clocks on other CPUs."
msgstr ""

#: ../../../trace/ftrace.rst:533
msgid "Usual clocks for tracing::"
msgstr ""

#: ../../../trace/ftrace.rst:538
msgid "The clock with the square brackets around it is the one in effect."
msgstr ""

#: ../../../trace/ftrace.rst:540
msgid "local:"
msgstr ""

#: ../../../trace/ftrace.rst:541
msgid "Default clock, but may not be in sync across CPUs"
msgstr ""

#: ../../../trace/ftrace.rst:543
msgid "global:"
msgstr ""

#: ../../../trace/ftrace.rst:544
msgid ""
"This clock is in sync with all CPUs but may be a bit slower than the local "
"clock."
msgstr ""

#: ../../../trace/ftrace.rst:547
msgid "counter:"
msgstr ""

#: ../../../trace/ftrace.rst:548
msgid ""
"This is not a clock at all, but literally an atomic counter. It counts up "
"one by one, but is in sync with all CPUs. This is useful when you need to "
"know exactly the order events occurred with respect to each other on "
"different CPUs."
msgstr ""

#: ../../../trace/ftrace.rst:554
msgid "uptime:"
msgstr ""

#: ../../../trace/ftrace.rst:555
msgid ""
"This uses the jiffies counter and the time stamp is relative to the time "
"since boot up."
msgstr ""

#: ../../../trace/ftrace.rst:558
msgid "perf:"
msgstr ""

#: ../../../trace/ftrace.rst:559
msgid ""
"This makes ftrace use the same clock that perf uses. Eventually perf will be "
"able to read ftrace buffers and this will help out in interleaving the data."
msgstr ""

#: ../../../trace/ftrace.rst:563
msgid "x86-tsc:"
msgstr ""

#: ../../../trace/ftrace.rst:564
msgid ""
"Architectures may define their own clocks. For example, x86 uses its own TSC "
"cycle clock here."
msgstr ""

#: ../../../trace/ftrace.rst:567
msgid "ppc-tb:"
msgstr ""

#: ../../../trace/ftrace.rst:568
msgid ""
"This uses the powerpc timebase register value. This is in sync across CPUs "
"and can also be used to correlate events across hypervisor/guest if "
"tb_offset is known."
msgstr ""

#: ../../../trace/ftrace.rst:573
msgid "mono:"
msgstr ""

#: ../../../trace/ftrace.rst:574
msgid ""
"This uses the fast monotonic clock (CLOCK_MONOTONIC) which is monotonic and "
"is subject to NTP rate adjustments."
msgstr ""

#: ../../../trace/ftrace.rst:577
msgid "mono_raw:"
msgstr ""

#: ../../../trace/ftrace.rst:578
msgid ""
"This is the raw monotonic clock (CLOCK_MONOTONIC_RAW) which is monotonic but "
"is not subject to any rate adjustments and ticks at the same rate as the "
"hardware clocksource."
msgstr ""

#: ../../../trace/ftrace.rst:582
msgid "boot:"
msgstr ""

#: ../../../trace/ftrace.rst:583
msgid ""
"This is the boot clock (CLOCK_BOOTTIME) and is based on the fast monotonic "
"clock, but also accounts for time spent in suspend. Since the clock access "
"is designed for use in tracing in the suspend path, some side effects are "
"possible if clock is accessed after the suspend time is accounted before the "
"fast mono clock is updated. In this case, the clock update appears to happen "
"slightly sooner than it normally would have. Also on 32-bit systems, it's "
"possible that the 64-bit boot offset sees a partial update. These effects "
"are rare and post processing should be able to handle them. See comments in "
"the ktime_get_boot_fast_ns() function for more information."
msgstr ""

#: ../../../trace/ftrace.rst:595
msgid "tai:"
msgstr ""

#: ../../../trace/ftrace.rst:596
msgid ""
"This is the tai clock (CLOCK_TAI) and is derived from the wall- clock time. "
"However, this clock does not experience discontinuities and backwards jumps "
"caused by NTP inserting leap seconds. Since the clock access is designed for "
"use in tracing, side effects are possible. The clock access may yield wrong "
"readouts in case the internal TAI offset is updated e.g., caused by setting "
"the system time or using adjtimex() with an offset. These effects are rare "
"and post processing should be able to handle them. See comments in the "
"ktime_get_tai_fast_ns() function for more information."
msgstr ""

#: ../../../trace/ftrace.rst:607
msgid "To set a clock, simply echo the clock name into this file::"
msgstr ""

#: ../../../trace/ftrace.rst:611
msgid ""
"Setting a clock clears the ring buffer content as well as the \"snapshot\" "
"buffer."
msgstr ""

#: ../../../trace/ftrace.rst:614
msgid "trace_marker:"
msgstr ""

#: ../../../trace/ftrace.rst:616
msgid ""
"This is a very useful file for synchronizing user space with events "
"happening in the kernel. Writing strings into this file will be written into "
"the ftrace buffer."
msgstr ""

#: ../../../trace/ftrace.rst:620
msgid ""
"It is useful in applications to open this file at the start of the "
"application and just reference the file descriptor for the file::"
msgstr ""

#: ../../../trace/ftrace.rst:640
msgid "start::"
msgstr ""

#: ../../../trace/ftrace.rst:644
msgid "Note: Writing into the trace_marker file can also initiate triggers"
msgstr ""

#: ../../../trace/ftrace.rst:645
msgid ""
"that are written into /sys/kernel/tracing/events/ftrace/print/trigger See "
"\"Event triggers\" in Documentation/trace/events.rst and an example in "
"Documentation/trace/histogram.rst (Section 3.)"
msgstr ""

#: ../../../trace/ftrace.rst:649
msgid "trace_marker_raw:"
msgstr ""

#: ../../../trace/ftrace.rst:651
msgid ""
"This is similar to trace_marker above, but is meant for binary data to be "
"written to it, where a tool can be used to parse the data from "
"trace_pipe_raw."
msgstr ""

#: ../../../trace/ftrace.rst:655
msgid "uprobe_events:"
msgstr ""

#: ../../../trace/ftrace.rst:657
msgid "Add dynamic tracepoints in programs. See uprobetracer.rst"
msgstr ""

#: ../../../trace/ftrace.rst:660
msgid "uprobe_profile:"
msgstr ""

#: ../../../trace/ftrace.rst:662
msgid "Uprobe statistics. See uprobetrace.txt"
msgstr ""

#: ../../../trace/ftrace.rst:664
msgid "instances:"
msgstr ""

#: ../../../trace/ftrace.rst:666
msgid ""
"This is a way to make multiple trace buffers where different events can be "
"recorded in different buffers. See \"Instances\" section below."
msgstr ""

#: ../../../trace/ftrace.rst:670
msgid "events:"
msgstr ""

#: ../../../trace/ftrace.rst:672
msgid ""
"This is the trace event directory. It holds event tracepoints (also known as "
"static tracepoints) that have been compiled into the kernel. It shows what "
"event tracepoints exist and how they are grouped by system. There are "
"\"enable\" files at various levels that can enable the tracepoints when a "
"\"1\" is written to them."
msgstr ""

#: ../../../trace/ftrace.rst:681
msgid "set_event:"
msgstr ""

#: ../../../trace/ftrace.rst:683
msgid "By echoing in the event into this file, will enable that event."
msgstr ""

#: ../../../trace/ftrace.rst:687
msgid "available_events:"
msgstr ""

#: ../../../trace/ftrace.rst:689
msgid "A list of events that can be enabled in tracing."
msgstr ""

#: ../../../trace/ftrace.rst:693
msgid "timestamp_mode:"
msgstr ""

#: ../../../trace/ftrace.rst:695
msgid ""
"Certain tracers may change the timestamp mode used when logging trace events "
"into the event buffer.  Events with different modes can coexist within a "
"buffer but the mode in effect when an event is logged determines which "
"timestamp mode is used for that event.  The default timestamp mode is "
"'delta'."
msgstr ""

#: ../../../trace/ftrace.rst:702
msgid "Usual timestamp modes for tracing:"
msgstr ""

#: ../../../trace/ftrace.rst:704
msgid "# cat timestamp_mode [delta] absolute"
msgstr ""

#: ../../../trace/ftrace.rst:707
msgid ""
"The timestamp mode with the square brackets around it is the one in effect."
msgstr ""

#: ../../../trace/ftrace.rst:710
msgid "delta: Default timestamp mode - timestamp is a delta against"
msgstr ""

#: ../../../trace/ftrace.rst:711
msgid "a per-buffer timestamp."
msgstr ""

#: ../../../trace/ftrace.rst:713
msgid "absolute: The timestamp is a full timestamp, not a delta"
msgstr ""

#: ../../../trace/ftrace.rst:714
msgid ""
"against some other value.  As such it takes up more space and is less "
"efficient."
msgstr ""

#: ../../../trace/ftrace.rst:717
msgid "hwlat_detector:"
msgstr ""

#: ../../../trace/ftrace.rst:719
msgid ""
"Directory for the Hardware Latency Detector. See \"Hardware Latency "
"Detector\" section below."
msgstr ""

#: ../../../trace/ftrace.rst:722
msgid "per_cpu:"
msgstr ""

#: ../../../trace/ftrace.rst:724
msgid "This is a directory that contains the trace per_cpu information."
msgstr ""

#: ../../../trace/ftrace.rst:726
msgid "per_cpu/cpu0/buffer_size_kb:"
msgstr ""

#: ../../../trace/ftrace.rst:728
msgid ""
"The ftrace buffer is defined per_cpu. That is, there's a separate buffer for "
"each CPU to allow writes to be done atomically, and free from cache "
"bouncing. These buffers may have different size buffers. This file is "
"similar to the buffer_size_kb file, but it only displays or sets the buffer "
"size for the specific CPU. (here cpu0)."
msgstr ""

#: ../../../trace/ftrace.rst:735
msgid "per_cpu/cpu0/trace:"
msgstr ""

#: ../../../trace/ftrace.rst:737
msgid ""
"This is similar to the \"trace\" file, but it will only display the data "
"specific for the CPU. If written to, it only clears the specific CPU buffer."
msgstr ""

#: ../../../trace/ftrace.rst:741
msgid "per_cpu/cpu0/trace_pipe"
msgstr ""

#: ../../../trace/ftrace.rst:743
msgid ""
"This is similar to the \"trace_pipe\" file, and is a consuming read, but it "
"will only display (and consume) the data specific for the CPU."
msgstr ""

#: ../../../trace/ftrace.rst:747
msgid "per_cpu/cpu0/trace_pipe_raw"
msgstr ""

#: ../../../trace/ftrace.rst:749
msgid ""
"For tools that can parse the ftrace ring buffer binary format, the "
"trace_pipe_raw file can be used to extract the data from the ring buffer "
"directly. With the use of the splice() system call, the buffer data can be "
"quickly transferred to a file or to the network where a server is collecting "
"the data."
msgstr ""

#: ../../../trace/ftrace.rst:756
msgid ""
"Like trace_pipe, this is a consuming reader, where multiple reads will "
"always produce different data."
msgstr ""

#: ../../../trace/ftrace.rst:759
msgid "per_cpu/cpu0/snapshot:"
msgstr ""

#: ../../../trace/ftrace.rst:761
msgid ""
"This is similar to the main \"snapshot\" file, but will only snapshot the "
"current CPU (if supported). It only displays the content of the snapshot for "
"a given CPU, and if written to, only clears this CPU buffer."
msgstr ""

#: ../../../trace/ftrace.rst:766
msgid "per_cpu/cpu0/snapshot_raw:"
msgstr ""

#: ../../../trace/ftrace.rst:768
msgid ""
"Similar to the trace_pipe_raw, but will read the binary format from the "
"snapshot buffer for the given CPU."
msgstr ""

#: ../../../trace/ftrace.rst:771
msgid "per_cpu/cpu0/stats:"
msgstr ""

#: ../../../trace/ftrace.rst:773
msgid "This displays certain stats about the ring buffer:"
msgstr ""

#: ../../../trace/ftrace.rst:775
msgid "entries:"
msgstr ""

#: ../../../trace/ftrace.rst:776
msgid "The number of events that are still in the buffer."
msgstr ""

#: ../../../trace/ftrace.rst:778
msgid "overrun:"
msgstr ""

#: ../../../trace/ftrace.rst:779
msgid "The number of lost events due to overwriting when the buffer was full."
msgstr ""

#: ../../../trace/ftrace.rst:782
msgid "commit overrun:"
msgstr ""

#: ../../../trace/ftrace.rst:783
msgid ""
"Should always be zero. This gets set if so many events happened within a "
"nested event (ring buffer is re-entrant), that it fills the buffer and "
"starts dropping events."
msgstr ""

#: ../../../trace/ftrace.rst:788
msgid "bytes:"
msgstr ""

#: ../../../trace/ftrace.rst:789
msgid "Bytes actually read (not overwritten)."
msgstr ""

#: ../../../trace/ftrace.rst:791
msgid "oldest event ts:"
msgstr ""

#: ../../../trace/ftrace.rst:792
msgid "The oldest timestamp in the buffer"
msgstr ""

#: ../../../trace/ftrace.rst:794
msgid "now ts:"
msgstr ""

#: ../../../trace/ftrace.rst:795
msgid "The current timestamp"
msgstr ""

#: ../../../trace/ftrace.rst:797
msgid "dropped events:"
msgstr ""

#: ../../../trace/ftrace.rst:798
msgid "Events lost due to overwrite option being off."
msgstr ""

#: ../../../trace/ftrace.rst:800
msgid "read events:"
msgstr ""

#: ../../../trace/ftrace.rst:801
msgid "The number of events read."
msgstr ""

#: ../../../trace/ftrace.rst:804
msgid "The Tracers"
msgstr ""

#: ../../../trace/ftrace.rst:806
msgid "Here is the list of current tracers that may be configured."
msgstr ""

#: ../../../trace/ftrace.rst:808
msgid "\"function\""
msgstr ""

#: ../../../trace/ftrace.rst:810
msgid "Function call tracer to trace all kernel functions."
msgstr ""

#: ../../../trace/ftrace.rst:812
msgid "\"function_graph\""
msgstr ""

#: ../../../trace/ftrace.rst:814
msgid ""
"Similar to the function tracer except that the function tracer probes the "
"functions on their entry whereas the function graph tracer traces on both "
"entry and exit of the functions. It then provides the ability to draw a "
"graph of function calls similar to C code source."
msgstr ""

#: ../../../trace/ftrace.rst:821
msgid ""
"Note that the function graph calculates the timings of when the function "
"starts and returns internally and for each instance. If there are two "
"instances that run function graph tracer and traces the same functions, the "
"length of the timings may be slightly off as each read the timestamp "
"separately and not at the same time."
msgstr ""

#: ../../../trace/ftrace.rst:827
msgid "\"blk\""
msgstr ""

#: ../../../trace/ftrace.rst:829
msgid "The block tracer. The tracer used by the blktrace user application."
msgstr ""

#: ../../../trace/ftrace.rst:832
msgid "\"hwlat\""
msgstr ""

#: ../../../trace/ftrace.rst:834
msgid ""
"The Hardware Latency tracer is used to detect if the hardware produces any "
"latency. See \"Hardware Latency Detector\" section below."
msgstr ""

#: ../../../trace/ftrace.rst:838
msgid "\"irqsoff\""
msgstr ""

#: ../../../trace/ftrace.rst:840
msgid ""
"Traces the areas that disable interrupts and saves the trace with the "
"longest max latency. See tracing_max_latency. When a new max is recorded, it "
"replaces the old trace. It is best to view this trace with the latency-"
"format option enabled, which happens automatically when the tracer is "
"selected."
msgstr ""

#: ../../../trace/ftrace.rst:847
msgid "\"preemptoff\""
msgstr ""

#: ../../../trace/ftrace.rst:849
msgid ""
"Similar to irqsoff but traces and records the amount of time for which "
"preemption is disabled."
msgstr ""

#: ../../../trace/ftrace.rst:852
msgid "\"preemptirqsoff\""
msgstr ""

#: ../../../trace/ftrace.rst:854
msgid ""
"Similar to irqsoff and preemptoff, but traces and records the largest time "
"for which irqs and/or preemption is disabled."
msgstr ""

#: ../../../trace/ftrace.rst:858
msgid "\"wakeup\""
msgstr ""

#: ../../../trace/ftrace.rst:860
msgid ""
"Traces and records the max latency that it takes for the highest priority "
"task to get scheduled after it has been woken up. Traces all tasks as an "
"average developer would expect."
msgstr ""

#: ../../../trace/ftrace.rst:865
msgid "\"wakeup_rt\""
msgstr ""

#: ../../../trace/ftrace.rst:867
msgid ""
"Traces and records the max latency that it takes for just RT tasks (as the "
"current \"wakeup\" does). This is useful for those interested in wake up "
"timings of RT tasks."
msgstr ""

#: ../../../trace/ftrace.rst:871
msgid "\"wakeup_dl\""
msgstr ""

#: ../../../trace/ftrace.rst:873
msgid ""
"Traces and records the max latency that it takes for a SCHED_DEADLINE task "
"to be woken (as the \"wakeup\" and \"wakeup_rt\" does)."
msgstr ""

#: ../../../trace/ftrace.rst:877
msgid "\"mmiotrace\""
msgstr ""

#: ../../../trace/ftrace.rst:879
msgid ""
"A special tracer that is used to trace binary modules. It will trace all the "
"calls that a module makes to the hardware. Everything it writes and reads "
"from the I/O as well."
msgstr ""

#: ../../../trace/ftrace.rst:884
msgid "\"branch\""
msgstr ""

#: ../../../trace/ftrace.rst:886
msgid ""
"This tracer can be configured when tracing likely/unlikely calls within the "
"kernel. It will trace when a likely and unlikely branch is hit and if it was "
"correct in its prediction of being correct."
msgstr ""

#: ../../../trace/ftrace.rst:891
msgid "\"nop\""
msgstr ""

#: ../../../trace/ftrace.rst:893
msgid ""
"This is the \"trace nothing\" tracer. To remove all tracers from tracing "
"simply echo \"nop\" into current_tracer."
msgstr ""

#: ../../../trace/ftrace.rst:898
msgid "Error conditions"
msgstr ""

#: ../../../trace/ftrace.rst:900
msgid ""
"For most ftrace commands, failure modes are obvious and communicated using "
"standard return codes."
msgstr ""

#: ../../../trace/ftrace.rst:903
msgid ""
"For other more involved commands, extended error information may be "
"available via the tracing/error_log file.  For the commands that support it, "
"reading the tracing/error_log file after an error will display more detailed "
"information about what went wrong, if information is available.  The tracing/"
"error_log file is a circular error log displaying a small number (currently, "
"8) of ftrace errors for the last (8) failed commands."
msgstr ""

#: ../../../trace/ftrace.rst:911
msgid ""
"The extended error information and usage takes the form shown in this "
"example::"
msgstr ""

#: ../../../trace/ftrace.rst:925
msgid "To clear the error log, echo the empty string into it::"
msgstr ""

#: ../../../trace/ftrace.rst:930
msgid "Examples of using the tracer"
msgstr ""

#: ../../../trace/ftrace.rst:932
msgid ""
"Here are typical examples of using the tracers when controlling them only "
"with the tracefs interface (without using any user-land utilities)."
msgstr ""

#: ../../../trace/ftrace.rst:937
msgid "Output format:"
msgstr ""

#: ../../../trace/ftrace.rst:939
msgid "Here is an example of the output format of the file \"trace\"::"
msgstr ""

#: ../../../trace/ftrace.rst:964
msgid ""
"A header is printed with the tracer name that is represented by the trace. "
"In this case the tracer is \"function\". Then it shows the number of events "
"in the buffer as well as the total number of entries that were written. The "
"difference is the number of entries that were lost due to the buffer filling "
"up (250280 - 140080 = 110200 events lost)."
msgstr ""

#: ../../../trace/ftrace.rst:971
msgid ""
"The header explains the content of the events. Task name \"bash\", the task "
"PID \"1977\", the CPU that it was running on \"000\", the latency format "
"(explained below), the timestamp in <secs>.<usecs> format, the function name "
"that was traced \"sys_close\" and the parent function that called this "
"function \"system_call_fastpath\". The timestamp is the time at which the "
"function was entered."
msgstr ""

#: ../../../trace/ftrace.rst:979
msgid "Latency trace format"
msgstr ""

#: ../../../trace/ftrace.rst:981
msgid ""
"When the latency-format option is enabled or when one of the latency tracers "
"is set, the trace file gives somewhat more information to see why a latency "
"happened. Here is a typical trace::"
msgstr ""

#: ../../../trace/ftrace.rst:1021
msgid ""
"This shows that the current tracer is \"irqsoff\" tracing the time for which "
"interrupts were disabled. It gives the trace version (which never changes) "
"and the version of the kernel upon which this was executed on (3.8). Then it "
"displays the max latency in microseconds (259 us). The number of trace "
"entries displayed and the total number (both are four: #4/4). VP, KP, SP, "
"and HP are always zero and are reserved for later use. #P is the number of "
"online CPUs (#P:4)."
msgstr ""

#: ../../../trace/ftrace.rst:1029
msgid ""
"The task is the process that was running when the latency occurred. (ps pid: "
"6143)."
msgstr ""

#: ../../../trace/ftrace.rst:1032
msgid ""
"The start and stop (the functions in which the interrupts were disabled and "
"enabled respectively) that caused the latencies:"
msgstr ""

#: ../../../trace/ftrace.rst:1035
msgid "__lock_task_sighand is where the interrupts were disabled."
msgstr ""

#: ../../../trace/ftrace.rst:1036
msgid "_raw_spin_unlock_irqrestore is where they were enabled again."
msgstr ""

#: ../../../trace/ftrace.rst:1038
msgid ""
"The next lines after the header are the trace itself. The header explains "
"which is which."
msgstr ""

#: ../../../trace/ftrace.rst:1041
msgid "cmd: The name of the process in the trace."
msgstr ""

#: ../../../trace/ftrace.rst:1043
msgid "pid: The PID of that process."
msgstr ""

#: ../../../trace/ftrace.rst:1045
msgid "CPU#: The CPU which the process was running on."
msgstr ""

#: ../../../trace/ftrace.rst:1047
msgid "irqs-off: 'd' interrupts are disabled. '.' otherwise."
msgstr ""

#: ../../../trace/ftrace.rst:1049
msgid "need-resched:"
msgstr ""

#: ../../../trace/ftrace.rst:1050
msgid ""
"'B' all, TIF_NEED_RESCHED, PREEMPT_NEED_RESCHED and TIF_RESCHED_LAZY is set,"
msgstr ""

#: ../../../trace/ftrace.rst:1051
msgid "'N' both TIF_NEED_RESCHED and PREEMPT_NEED_RESCHED is set,"
msgstr ""

#: ../../../trace/ftrace.rst:1052
msgid "'n' only TIF_NEED_RESCHED is set,"
msgstr ""

#: ../../../trace/ftrace.rst:1053
msgid "'p' only PREEMPT_NEED_RESCHED is set,"
msgstr ""

#: ../../../trace/ftrace.rst:1054
msgid "'L' both PREEMPT_NEED_RESCHED and TIF_RESCHED_LAZY is set,"
msgstr ""

#: ../../../trace/ftrace.rst:1055
msgid "'b' both TIF_NEED_RESCHED and TIF_RESCHED_LAZY is set,"
msgstr ""

#: ../../../trace/ftrace.rst:1056
msgid "'l' only TIF_RESCHED_LAZY is set"
msgstr ""

#: ../../../trace/ftrace.rst:1057
msgid "'.' otherwise."
msgstr ""

#: ../../../trace/ftrace.rst:1059
msgid "hardirq/softirq:"
msgstr ""

#: ../../../trace/ftrace.rst:1060
msgid "'Z' - NMI occurred inside a hardirq"
msgstr ""

#: ../../../trace/ftrace.rst:1061
msgid "'z' - NMI is running"
msgstr ""

#: ../../../trace/ftrace.rst:1062
msgid "'H' - hard irq occurred inside a softirq."
msgstr ""

#: ../../../trace/ftrace.rst:1063
msgid "'h' - hard irq is running"
msgstr ""

#: ../../../trace/ftrace.rst:1064
msgid "'s' - soft irq is running"
msgstr ""

#: ../../../trace/ftrace.rst:1065
msgid "'.' - normal context."
msgstr ""

#: ../../../trace/ftrace.rst:1067
msgid "preempt-depth: The level of preempt_disabled"
msgstr ""

#: ../../../trace/ftrace.rst:1069
msgid "The above is mostly meaningful for kernel developers."
msgstr ""

#: ../../../trace/ftrace.rst:1071
msgid "time:"
msgstr ""

#: ../../../trace/ftrace.rst:1072
msgid ""
"When the latency-format option is enabled, the trace file output includes a "
"timestamp relative to the start of the trace. This differs from the output "
"when latency-format is disabled, which includes an absolute timestamp."
msgstr ""

#: ../../../trace/ftrace.rst:1077
msgid "delay:"
msgstr ""

#: ../../../trace/ftrace.rst:1078
msgid ""
"This is just to help catch your eye a bit better. And needs to be fixed to "
"be only relative to the same CPU. The marks are determined by the difference "
"between this current trace and the next trace."
msgstr ""

#: ../../../trace/ftrace.rst:1083
msgid "'$' - greater than 1 second"
msgstr ""

#: ../../../trace/ftrace.rst:1084
msgid "'@' - greater than 100 millisecond"
msgstr ""

#: ../../../trace/ftrace.rst:1085
msgid "'*' - greater than 10 millisecond"
msgstr ""

#: ../../../trace/ftrace.rst:1086
msgid "'#' - greater than 1000 microsecond"
msgstr ""

#: ../../../trace/ftrace.rst:1087
msgid "'!' - greater than 100 microsecond"
msgstr ""

#: ../../../trace/ftrace.rst:1088
msgid "'+' - greater than 10 microsecond"
msgstr ""

#: ../../../trace/ftrace.rst:1089
msgid "' ' - less than or equal to 10 microsecond."
msgstr ""

#: ../../../trace/ftrace.rst:1091
msgid "The rest is the same as the 'trace' file."
msgstr ""

#: ../../../trace/ftrace.rst:1093
msgid ""
"Note, the latency tracers will usually end with a back trace to easily find "
"where the latency occurred."
msgstr ""

#: ../../../trace/ftrace.rst:1097
msgid "trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:1099
msgid ""
"The trace_options file (or the options directory) is used to control what "
"gets printed in the trace output, or manipulate the tracers. To see what is "
"available, simply cat the file::"
msgstr ""

#: ../../../trace/ftrace.rst:1133
msgid ""
"To disable one of the options, echo in the option prepended with \"no\"::"
msgstr ""

#: ../../../trace/ftrace.rst:1138
msgid "To enable an option, leave off the \"no\"::"
msgstr ""

#: ../../../trace/ftrace.rst:1142
msgid "Here are the available options:"
msgstr ""

#: ../../../trace/ftrace.rst:1144
msgid "print-parent"
msgstr ""

#: ../../../trace/ftrace.rst:1145
msgid ""
"On function traces, display the calling (parent) function as well as the "
"function being traced. ::"
msgstr ""

#: ../../../trace/ftrace.rst:1156
msgid "sym-offset"
msgstr ""

#: ../../../trace/ftrace.rst:1157
msgid ""
"Display not only the function name, but also the offset in the function. For "
"example, instead of seeing just \"ktime_get\", you will see "
"\"ktime_get+0xb/0x20\". ::"
msgstr ""

#: ../../../trace/ftrace.rst:1166
msgid "sym-addr"
msgstr ""

#: ../../../trace/ftrace.rst:1167
msgid ""
"This will also display the function address as well as the function name. ::"
msgstr ""

#: ../../../trace/ftrace.rst:1174
msgid "verbose"
msgstr ""

#: ../../../trace/ftrace.rst:1175
msgid ""
"This deals with the trace file when the latency-format option is enabled. ::"
msgstr ""

#: ../../../trace/ftrace.rst:1182
msgid "raw"
msgstr ""

#: ../../../trace/ftrace.rst:1183
msgid ""
"This will display raw numbers. This option is best for use with user "
"applications that can translate the raw numbers better than having it done "
"in the kernel."
msgstr ""

#: ../../../trace/ftrace.rst:1187
msgid "hex"
msgstr ""

#: ../../../trace/ftrace.rst:1188
msgid "Similar to raw, but the numbers will be in a hexadecimal format."
msgstr ""

#: ../../../trace/ftrace.rst:1190
msgid "bin"
msgstr ""

#: ../../../trace/ftrace.rst:1191
msgid "This will print out the formats in raw binary."
msgstr ""

#: ../../../trace/ftrace.rst:1193
msgid "block"
msgstr ""

#: ../../../trace/ftrace.rst:1194
msgid "When set, reading trace_pipe will not block when polled."
msgstr ""

#: ../../../trace/ftrace.rst:1196
msgid "fields"
msgstr ""

#: ../../../trace/ftrace.rst:1197
msgid ""
"Print the fields as described by their types. This is a better option than "
"using hex, bin or raw, as it gives a better parsing of the content of the "
"event."
msgstr ""

#: ../../../trace/ftrace.rst:1201
msgid "trace_printk"
msgstr ""

#: ../../../trace/ftrace.rst:1202
msgid "Can disable trace_printk() from writing into the buffer."
msgstr ""

#: ../../../trace/ftrace.rst:1204
msgid "trace_printk_dest"
msgstr ""

#: ../../../trace/ftrace.rst:1205
msgid ""
"Set to have trace_printk() and similar internal tracing functions write into "
"this instance. Note, only one trace instance can have this set. By setting "
"this flag, it clears the trace_printk_dest flag of the instance that had it "
"set previously. By default, the top level trace has this set, and will get "
"it set again if another instance has it set then clears it."
msgstr ""

#: ../../../trace/ftrace.rst:1212
msgid ""
"This flag cannot be cleared by the top level instance, as it is the default "
"instance. The only way the top level instance has this flag cleared, is by "
"it being set in another instance."
msgstr ""

#: ../../../trace/ftrace.rst:1216
msgid "copy_trace_marker"
msgstr ""

#: ../../../trace/ftrace.rst:1217
msgid ""
"If there are applications that hard code writing into the top level "
"trace_marker file (/sys/kernel/tracing/trace_marker or trace_marker_raw), "
"and the tooling would like it to go into an instance, this option can be "
"used. Create an instance and set this option, and then all writes into the "
"top level trace_marker file will also be redirected into this instance."
msgstr ""

#: ../../../trace/ftrace.rst:1224
msgid ""
"Note, by default this option is set for the top level instance. If it is "
"disabled, then writes to the trace_marker or trace_marker_raw files will not "
"be written into the top level file. If no instance has this option set, then "
"a write will error with the errno of ENODEV."
msgstr ""

#: ../../../trace/ftrace.rst:1229
msgid "annotate"
msgstr ""

#: ../../../trace/ftrace.rst:1230
msgid ""
"It is sometimes confusing when the CPU buffers are full and one CPU buffer "
"had a lot of events recently, thus a shorter time frame, were another CPU "
"may have only had a few events, which lets it have older events. When the "
"trace is reported, it shows the oldest events first, and it may look like "
"only one CPU ran (the one with the oldest events). When the annotate option "
"is set, it will display when a new CPU buffer started::"
msgstr ""

#: ../../../trace/ftrace.rst:1247
msgid "userstacktrace"
msgstr ""

#: ../../../trace/ftrace.rst:1248
msgid ""
"This option changes the trace. It records a stacktrace of the current user "
"space thread after each trace event."
msgstr ""

#: ../../../trace/ftrace.rst:1252
msgid "sym-userobj"
msgstr ""

#: ../../../trace/ftrace.rst:1253
msgid ""
"when user stacktrace are enabled, look up which object the address belongs "
"to, and print a relative address. This is especially useful when ASLR is on, "
"otherwise you don't get a chance to resolve the address to object/file/line "
"after the app is no longer running"
msgstr ""

#: ../../../trace/ftrace.rst:1260
msgid "The lookup is performed when you read trace,trace_pipe. Example::"
msgstr ""

#: ../../../trace/ftrace.rst:1267
msgid "printk-msg-only"
msgstr ""

#: ../../../trace/ftrace.rst:1268
msgid ""
"When set, trace_printk()s will only show the format and not their parameters "
"(if trace_bprintk() or trace_bputs() was used to save the trace_printk())."
msgstr ""

#: ../../../trace/ftrace.rst:1272
msgid "context-info"
msgstr ""

#: ../../../trace/ftrace.rst:1273
msgid ""
"Show only the event data. Hides the comm, PID, timestamp, CPU, and other "
"useful data."
msgstr ""

#: ../../../trace/ftrace.rst:1276
msgid "latency-format"
msgstr ""

#: ../../../trace/ftrace.rst:1277
msgid ""
"This option changes the trace output. When it is enabled, the trace displays "
"additional information about the latency, as described in \"Latency trace "
"format\"."
msgstr ""

#: ../../../trace/ftrace.rst:1281
msgid "pause-on-trace"
msgstr ""

#: ../../../trace/ftrace.rst:1282
msgid ""
"When set, opening the trace file for read, will pause writing to the ring "
"buffer (as if tracing_on was set to zero). This simulates the original "
"behavior of the trace file. When the file is closed, tracing will be enabled "
"again."
msgstr ""

#: ../../../trace/ftrace.rst:1287
msgid "hash-ptr"
msgstr ""

#: ../../../trace/ftrace.rst:1288
msgid ""
"When set, \"%p\" in the event printk format displays the hashed pointer "
"value instead of real address. This will be useful if you want to find out "
"which hashed value is corresponding to the real value in trace log."
msgstr ""

#: ../../../trace/ftrace.rst:1293
msgid "record-cmd"
msgstr ""

#: ../../../trace/ftrace.rst:1294
msgid ""
"When any event or tracer is enabled, a hook is enabled in the sched_switch "
"trace point to fill comm cache with mapped pids and comms. But this may "
"cause some overhead, and if you only care about pids, and not the name of "
"the task, disabling this option can lower the impact of tracing. See "
"\"saved_cmdlines\"."
msgstr ""

#: ../../../trace/ftrace.rst:1301
msgid "record-tgid"
msgstr ""

#: ../../../trace/ftrace.rst:1302
msgid ""
"When any event or tracer is enabled, a hook is enabled in the sched_switch "
"trace point to fill the cache of mapped Thread Group IDs (TGID) mapping to "
"pids. See \"saved_tgids\"."
msgstr ""

#: ../../../trace/ftrace.rst:1307
msgid "overwrite"
msgstr ""

#: ../../../trace/ftrace.rst:1308
msgid ""
"This controls what happens when the trace buffer is full. If "
"\"1\" (default), the oldest events are discarded and overwritten. If \"0\", "
"then the newest events are discarded. (see per_cpu/cpu0/stats for overrun "
"and dropped)"
msgstr ""

#: ../../../trace/ftrace.rst:1314
msgid "disable_on_free"
msgstr ""

#: ../../../trace/ftrace.rst:1315
msgid ""
"When the free_buffer is closed, tracing will stop (tracing_on set to 0)."
msgstr ""

#: ../../../trace/ftrace.rst:1318
msgid "irq-info"
msgstr ""

#: ../../../trace/ftrace.rst:1319
msgid ""
"Shows the interrupt, preempt count, need resched data. When disabled, the "
"trace looks like::"
msgstr ""

#: ../../../trace/ftrace.rst:1333
msgid "markers"
msgstr ""

#: ../../../trace/ftrace.rst:1334
msgid ""
"When set, the trace_marker is writable (only by root). When disabled, the "
"trace_marker will error with EINVAL on write."
msgstr ""

#: ../../../trace/ftrace.rst:1338
msgid "event-fork"
msgstr ""

#: ../../../trace/ftrace.rst:1339
msgid ""
"When set, tasks with PIDs listed in set_event_pid will have the PIDs of "
"their children added to set_event_pid when those tasks fork. Also, when "
"tasks with PIDs in set_event_pid exit, their PIDs will be removed from the "
"file."
msgstr ""

#: ../../../trace/ftrace.rst:1344
msgid "This affects PIDs listed in set_event_notrace_pid as well."
msgstr ""

#: ../../../trace/ftrace.rst:1346
msgid "function-trace"
msgstr ""

#: ../../../trace/ftrace.rst:1347
msgid ""
"The latency tracers will enable function tracing if this option is enabled "
"(default it is). When it is disabled, the latency tracers do not trace "
"functions. This keeps the overhead of the tracer down when performing "
"latency tests."
msgstr ""

#: ../../../trace/ftrace.rst:1353
msgid "function-fork"
msgstr ""

#: ../../../trace/ftrace.rst:1354
msgid ""
"When set, tasks with PIDs listed in set_ftrace_pid will have the PIDs of "
"their children added to set_ftrace_pid when those tasks fork. Also, when "
"tasks with PIDs in set_ftrace_pid exit, their PIDs will be removed from the "
"file."
msgstr ""

#: ../../../trace/ftrace.rst:1360
msgid "This affects PIDs in set_ftrace_notrace_pid as well."
msgstr ""

#: ../../../trace/ftrace.rst:1362
msgid "display-graph"
msgstr ""

#: ../../../trace/ftrace.rst:1363
msgid ""
"When set, the latency tracers (irqsoff, wakeup, etc) will use function graph "
"tracing instead of function tracing."
msgstr ""

#: ../../../trace/ftrace.rst:1366
msgid "stacktrace"
msgstr ""

#: ../../../trace/ftrace.rst:1367
msgid "When set, a stack trace is recorded after any trace event is recorded."
msgstr ""

#: ../../../trace/ftrace.rst:1370
msgid "branch"
msgstr ""

#: ../../../trace/ftrace.rst:1371
msgid ""
"Enable branch tracing with the tracer. This enables branch tracer along with "
"the currently set tracer. Enabling this with the \"nop\" tracer is the same "
"as just enabling the \"branch\" tracer."
msgstr ""

#: ../../../trace/ftrace.rst:1376
msgid ""
"Some tracers have their own options. They only appear in this file when the "
"tracer is active. They always appear in the options directory."
msgstr ""

#: ../../../trace/ftrace.rst:1381
msgid "Here are the per tracer options:"
msgstr ""

#: ../../../trace/ftrace.rst:1383
msgid "Options for function tracer:"
msgstr ""

#: ../../../trace/ftrace.rst:1385
msgid "func_stack_trace"
msgstr ""

#: ../../../trace/ftrace.rst:1386
msgid ""
"When set, a stack trace is recorded after every function that is recorded. "
"NOTE! Limit the functions that are recorded before enabling this, with "
"\"set_ftrace_filter\" otherwise the system performance will be critically "
"degraded. Remember to disable this option before clearing the function "
"filter."
msgstr ""

#: ../../../trace/ftrace.rst:1393
msgid "Options for function_graph tracer:"
msgstr ""

#: ../../../trace/ftrace.rst:1395
msgid ""
"Since the function_graph tracer has a slightly different output it has its "
"own options to control what is displayed."
msgstr ""

#: ../../../trace/ftrace.rst:1398
msgid "funcgraph-overrun"
msgstr ""

#: ../../../trace/ftrace.rst:1399
msgid ""
"When set, the \"overrun\" of the graph stack is displayed after each "
"function traced. The overrun, is when the stack depth of the calls is "
"greater than what is reserved for each task. Each task has a fixed array of "
"functions to trace in the call graph. If the depth of the calls exceeds "
"that, the function is not traced. The overrun is the number of functions "
"missed due to exceeding this array."
msgstr ""

#: ../../../trace/ftrace.rst:1409
msgid "funcgraph-cpu"
msgstr ""

#: ../../../trace/ftrace.rst:1410
msgid ""
"When set, the CPU number of the CPU where the trace occurred is displayed."
msgstr ""

#: ../../../trace/ftrace.rst:1413
msgid "funcgraph-overhead"
msgstr ""

#: ../../../trace/ftrace.rst:1414
msgid ""
"When set, if the function takes longer than A certain amount, then a delay "
"marker is displayed. See \"delay\" above, under the header description."
msgstr ""

#: ../../../trace/ftrace.rst:1419
msgid "funcgraph-proc"
msgstr ""

#: ../../../trace/ftrace.rst:1420
msgid ""
"Unlike other tracers, the process' command line is not displayed by default, "
"but instead only when a task is traced in and out during a context switch. "
"Enabling this options has the command of each process displayed at every "
"line."
msgstr ""

#: ../../../trace/ftrace.rst:1426
msgid "funcgraph-duration"
msgstr ""

#: ../../../trace/ftrace.rst:1427
msgid ""
"At the end of each function (the return) the duration of the amount of time "
"in the function is displayed in microseconds."
msgstr ""

#: ../../../trace/ftrace.rst:1431
msgid "funcgraph-abstime"
msgstr ""

#: ../../../trace/ftrace.rst:1432
msgid "When set, the timestamp is displayed at each line."
msgstr ""

#: ../../../trace/ftrace.rst:1434
msgid "funcgraph-irqs"
msgstr ""

#: ../../../trace/ftrace.rst:1435
msgid ""
"When disabled, functions that happen inside an interrupt will not be traced."
msgstr ""

#: ../../../trace/ftrace.rst:1438
msgid "funcgraph-tail"
msgstr ""

#: ../../../trace/ftrace.rst:1439
msgid ""
"When set, the return event will include the function that it represents. By "
"default this is off, and only a closing curly bracket \"}\" is displayed for "
"the return of a function."
msgstr ""

#: ../../../trace/ftrace.rst:1444
msgid "funcgraph-retval"
msgstr ""

#: ../../../trace/ftrace.rst:1445
msgid ""
"When set, the return value of each traced function will be printed after an "
"equal sign \"=\". By default this is off."
msgstr ""

#: ../../../trace/ftrace.rst:1449
msgid "funcgraph-retval-hex"
msgstr ""

#: ../../../trace/ftrace.rst:1450
msgid ""
"When set, the return value will always be printed in hexadecimal format. If "
"the option is not set and the return value is an error code, it will be "
"printed in signed decimal format; otherwise it will also be printed in "
"hexadecimal format. By default, this option is off."
msgstr ""

#: ../../../trace/ftrace.rst:1457
msgid "sleep-time"
msgstr ""

#: ../../../trace/ftrace.rst:1458
msgid ""
"When running function graph tracer, to include the time a task schedules out "
"in its function. When enabled, it will account time the task has been "
"scheduled out as part of the function call."
msgstr ""

#: ../../../trace/ftrace.rst:1463
msgid "graph-time"
msgstr ""

#: ../../../trace/ftrace.rst:1464
msgid ""
"When running function profiler with function graph tracer, to include the "
"time to call nested functions. When this is not set, the time reported for "
"the function will only include the time the function itself executed for, "
"not the time for functions that it called."
msgstr ""

#: ../../../trace/ftrace.rst:1470
msgid "Options for blk tracer:"
msgstr ""

#: ../../../trace/ftrace.rst:1472
msgid "blk_classic"
msgstr ""

#: ../../../trace/ftrace.rst:1473
msgid "Shows a more minimalistic output."
msgstr ""

#: ../../../trace/ftrace.rst:1477
msgid "irqsoff"
msgstr ""

#: ../../../trace/ftrace.rst:1479
msgid ""
"When interrupts are disabled, the CPU can not react to any other external "
"event (besides NMIs and SMIs). This prevents the timer interrupt from "
"triggering or the mouse interrupt from letting the kernel know of a new "
"mouse event. The result is a latency with the reaction time."
msgstr ""

#: ../../../trace/ftrace.rst:1485
msgid ""
"The irqsoff tracer tracks the time for which interrupts are disabled. When a "
"new maximum latency is hit, the tracer saves the trace leading up to that "
"latency point so that every time a new maximum is reached, the old saved "
"trace is discarded and the new trace is saved."
msgstr ""

#: ../../../trace/ftrace.rst:1491
msgid ""
"To reset the maximum, echo 0 into tracing_max_latency. Here is an example::"
msgstr ""

#: ../../../trace/ftrace.rst:1541
msgid ""
"Here we see that we had a latency of 16 microseconds (which is very good). "
"The _raw_spin_lock_irq in run_timer_softirq disabled interrupts. The "
"difference between the 16 and the displayed timestamp 25us occurred because "
"the clock was incremented between the time of recording the max latency and "
"the time of recording the function that had that latency."
msgstr ""

#: ../../../trace/ftrace.rst:1548
msgid ""
"Note the above example had function-trace not set. If we set function-trace, "
"we get a much larger output::"
msgstr ""

#: ../../../trace/ftrace.rst:1620
msgid ""
"Here we traced a 71 microsecond latency. But we also see all the functions "
"that were called during that time. Note that by enabling function tracing, "
"we incur an added overhead. This overhead may extend the latency times. But "
"nevertheless, this trace has provided some very helpful debugging "
"information."
msgstr ""

#: ../../../trace/ftrace.rst:1626
msgid ""
"If we prefer function graph output instead of function, we can set display-"
"graph option::"
msgstr ""

#: ../../../trace/ftrace.rst:1680
msgid "preemptoff"
msgstr ""

#: ../../../trace/ftrace.rst:1682
msgid ""
"When preemption is disabled, we may be able to receive interrupts but the "
"task cannot be preempted and a higher priority task must wait for preemption "
"to be enabled again before it can preempt a lower priority task."
msgstr ""

#: ../../../trace/ftrace.rst:1687
msgid ""
"The preemptoff tracer traces the places that disable preemption. Like the "
"irqsoff tracer, it records the maximum latency for which preemption was "
"disabled. The control of preemptoff tracer is much like the irqsoff "
"tracer. ::"
msgstr ""

#: ../../../trace/ftrace.rst:1731
msgid ""
"This has some more changes. Preemption was disabled when an interrupt came "
"in (notice the 'h'), and was enabled on exit. But we also see that "
"interrupts have been disabled when entering the preempt off section and "
"leaving it (the 'd'). We do not know if interrupts were enabled in the mean "
"time or shortly after this was over. ::"
msgstr ""

#: ../../../trace/ftrace.rst:1803
msgid ""
"The above is an example of the preemptoff trace with function-trace set. "
"Here we see that interrupts were not disabled the entire time. The irq_enter "
"code lets us know that we entered an interrupt 'h'. Before that, the "
"functions being traced still show that it is not in an interrupt, but we can "
"see from the functions themselves that this is not the case."
msgstr ""

#: ../../../trace/ftrace.rst:1811
msgid "preemptirqsoff"
msgstr ""

#: ../../../trace/ftrace.rst:1813
msgid ""
"Knowing the locations that have interrupts disabled or preemption disabled "
"for the longest times is helpful. But sometimes we would like to know when "
"either preemption and/or interrupts are disabled."
msgstr ""

#: ../../../trace/ftrace.rst:1818
msgid "Consider the following code::"
msgstr ""

#: ../../../trace/ftrace.rst:1828
msgid ""
"The irqsoff tracer will record the total length of "
"call_function_with_irqs_off() and "
"call_function_with_irqs_and_preemption_off()."
msgstr ""

#: ../../../trace/ftrace.rst:1832
msgid ""
"The preemptoff tracer will record the total length of "
"call_function_with_irqs_and_preemption_off() and "
"call_function_with_preemption_off()."
msgstr ""

#: ../../../trace/ftrace.rst:1836
msgid ""
"But neither will trace the time that interrupts and/or preemption is "
"disabled. This total time is the time that we can not schedule. To record "
"this time, use the preemptirqsoff tracer."
msgstr ""

#: ../../../trace/ftrace.rst:1841
msgid ""
"Again, using this trace is much like the irqsoff and preemptoff tracers. ::"
msgstr ""

#: ../../../trace/ftrace.rst:1898
msgid ""
"The trace_hardirqs_off_thunk is called from assembly on x86 when interrupts "
"are disabled in the assembly code. Without the function tracing, we do not "
"know if interrupts were enabled within the preemption points. We do see that "
"it started with preemption enabled."
msgstr ""

#: ../../../trace/ftrace.rst:1904
msgid "Here is a trace with function-trace set::"
msgstr ""

#: ../../../trace/ftrace.rst:1997
msgid ""
"This is an interesting trace. It started with kworker running and scheduling "
"out and ls taking over. But as soon as ls released the rq lock and enabled "
"interrupts (but not preemption) an interrupt triggered. When the interrupt "
"finished, it started running softirqs. But while the softirq was running, "
"another interrupt triggered. When an interrupt is running inside a softirq, "
"the annotation is 'H'."
msgstr ""

#: ../../../trace/ftrace.rst:2006
msgid "wakeup"
msgstr ""

#: ../../../trace/ftrace.rst:2008
msgid ""
"One common case that people are interested in tracing is the time it takes "
"for a task that is woken to actually wake up. Now for non Real-Time tasks, "
"this can be arbitrary. But tracing it nonetheless can be interesting."
msgstr ""

#: ../../../trace/ftrace.rst:2013
msgid "Without function tracing::"
msgstr ""

#: ../../../trace/ftrace.rst:2044
msgid ""
"The tracer only traces the highest priority task in the system to avoid "
"tracing the normal circumstances. Here we see that the kworker with a nice "
"priority of -20 (not very nice), took just 15 microseconds from the time it "
"woke up, to the time it ran."
msgstr ""

#: ../../../trace/ftrace.rst:2050
msgid ""
"Non Real-Time tasks are not that interesting. A more interesting trace is to "
"concentrate only on Real-Time tasks."
msgstr ""

#: ../../../trace/ftrace.rst:2054
msgid "wakeup_rt"
msgstr ""

#: ../../../trace/ftrace.rst:2056
msgid ""
"In a Real-Time environment it is very important to know the wakeup time it "
"takes for the highest priority task that is woken up to the time that it "
"executes. This is also known as \"schedule latency\". I stress the point "
"that this is about RT tasks. It is also important to know the scheduling "
"latency of non-RT tasks, but the average schedule latency is better for non-"
"RT tasks. Tools like LatencyTop are more appropriate for such measurements."
msgstr ""

#: ../../../trace/ftrace.rst:2065
msgid ""
"Real-Time environments are interested in the worst case latency. That is the "
"longest latency it takes for something to happen, and not the average. We "
"can have a very fast scheduler that may only have a large latency once in a "
"while, but that would not work well with Real-Time tasks.  The wakeup_rt "
"tracer was designed to record the worst case wakeups of RT tasks. Non-RT "
"tasks are not recorded because the tracer only records one worst case and "
"tracing non-RT tasks that are unpredictable will overwrite the worst case "
"latency of RT tasks (just run the normal wakeup tracer for a while to see "
"that effect)."
msgstr ""

#: ../../../trace/ftrace.rst:2076
msgid ""
"Since this tracer only deals with RT tasks, we will run this slightly "
"differently than we did with the previous tracers. Instead of performing an "
"'ls', we will run 'sleep 1' under 'chrt' which changes the priority of the "
"task. ::"
msgstr ""

#: ../../../trace/ftrace.rst:2114
msgid ""
"Running this on an idle system, we see that it only took 5 microseconds to "
"perform the task switch.  Note, since the trace point in the schedule is "
"before the actual \"switch\", we stop the tracing when the recorded task is "
"about to schedule in. This may change if we add a new marker at the end of "
"the scheduler."
msgstr ""

#: ../../../trace/ftrace.rst:2120
msgid ""
"Notice that the recorded task is 'sleep' with the PID of 2389 and it has an "
"rt_prio of 5. This priority is user-space priority and not the internal "
"kernel priority. The policy is 1 for SCHED_FIFO and 2 for SCHED_RR."
msgstr ""

#: ../../../trace/ftrace.rst:2125
msgid "Note, that the trace data shows the internal priority (99 - rtprio). ::"
msgstr ""

#: ../../../trace/ftrace.rst:2130
msgid ""
"The 0:120:R means idle was running with a nice priority of 0 (120 - 120) and "
"in the running state 'R'. The sleep task was scheduled in with 2389: 94:R. "
"That is the priority is the kernel rtprio (99 - 5 = 94) and it too is in the "
"running state."
msgstr ""

#: ../../../trace/ftrace.rst:2135
msgid "Doing the same with chrt -r 5 and function-trace set. ::"
msgstr ""

#: ../../../trace/ftrace.rst:2243
msgid ""
"This isn't that big of a trace, even with function tracing enabled, so I "
"included the entire trace."
msgstr ""

#: ../../../trace/ftrace.rst:2246
msgid ""
"The interrupt went off while when the system was idle. Somewhere before "
"task_woken_rt() was called, the NEED_RESCHED flag was set, this is indicated "
"by the first occurrence of the 'N' flag."
msgstr ""

#: ../../../trace/ftrace.rst:2251
msgid "Latency tracing and events"
msgstr ""

#: ../../../trace/ftrace.rst:2252
msgid ""
"As function tracing can induce a much larger latency, but without seeing "
"what happens within the latency it is hard to know what caused it. There is "
"a middle ground, and that is with enabling events. ::"
msgstr ""

#: ../../../trace/ftrace.rst:2298
msgid "Hardware Latency Detector"
msgstr ""

#: ../../../trace/ftrace.rst:2300
msgid ""
"The hardware latency detector is executed by enabling the \"hwlat\" tracer."
msgstr ""

#: ../../../trace/ftrace.rst:2302
msgid ""
"NOTE, this tracer will affect the performance of the system as it will "
"periodically make a CPU constantly busy with interrupts disabled. ::"
msgstr ""

#: ../../../trace/ftrace.rst:2334
msgid ""
"The above output is somewhat the same in the header. All events will have "
"interrupts disabled 'd'. Under the FUNCTION title there is:"
msgstr ""

#: ../../../trace/ftrace.rst:2337
msgid "#1"
msgstr ""

#: ../../../trace/ftrace.rst:2338
msgid ""
"This is the count of events recorded that were greater than the "
"tracing_threshold (See below)."
msgstr ""

#: ../../../trace/ftrace.rst:2341
msgid "inner/outer(us):   11/11"
msgstr ""

#: ../../../trace/ftrace.rst:2343
msgid ""
"This shows two numbers as \"inner latency\" and \"outer latency\". The test "
"runs in a loop checking a timestamp twice. The latency detected within the "
"two timestamps is the \"inner latency\" and the latency detected after the "
"previous timestamp and the next timestamp in the loop is the \"outer "
"latency\"."
msgstr ""

#: ../../../trace/ftrace.rst:2349
msgid "ts:1581527483.343962693"
msgstr ""

#: ../../../trace/ftrace.rst:2351
msgid ""
"The absolute timestamp that the first latency was recorded in the window."
msgstr ""

#: ../../../trace/ftrace.rst:2353
msgid "count:6"
msgstr ""

#: ../../../trace/ftrace.rst:2355
msgid "The number of times a latency was detected during the window."
msgstr ""

#: ../../../trace/ftrace.rst:2357
msgid "nmi-total:7 nmi-count:1"
msgstr ""

#: ../../../trace/ftrace.rst:2359
msgid ""
"On architectures that support it, if an NMI comes in during the test, the "
"time spent in NMI is reported in \"nmi-total\" (in microseconds)."
msgstr ""

#: ../../../trace/ftrace.rst:2363
msgid ""
"All architectures that have NMIs will show the \"nmi-count\" if an NMI comes "
"in during the test."
msgstr ""

#: ../../../trace/ftrace.rst:2366
msgid "hwlat files:"
msgstr ""

#: ../../../trace/ftrace.rst:2368
msgid "tracing_threshold"
msgstr ""

#: ../../../trace/ftrace.rst:2369
msgid ""
"This gets automatically set to \"10\" to represent 10 microseconds. This is "
"the threshold of latency that needs to be detected before the trace will be "
"recorded."
msgstr ""

#: ../../../trace/ftrace.rst:2373
msgid ""
"Note, when hwlat tracer is finished (another tracer is written into "
"\"current_tracer\"), the original value for tracing_threshold is placed back "
"into this file."
msgstr ""

#: ../../../trace/ftrace.rst:2377
msgid "hwlat_detector/width"
msgstr ""

#: ../../../trace/ftrace.rst:2378
msgid "The length of time the test runs with interrupts disabled."
msgstr ""

#: ../../../trace/ftrace.rst:2380
msgid "hwlat_detector/window"
msgstr ""

#: ../../../trace/ftrace.rst:2381
msgid ""
"The length of time of the window which the test runs. That is, the test will "
"run for \"width\" microseconds per \"window\" microseconds"
msgstr ""

#: ../../../trace/ftrace.rst:2385
msgid "tracing_cpumask"
msgstr ""

#: ../../../trace/ftrace.rst:2386
msgid ""
"When the test is started. A kernel thread is created that runs the test. "
"This thread will alternate between CPUs listed in the tracing_cpumask "
"between each period (one \"window\"). To limit the test to specific CPUs set "
"the mask in this file to only the CPUs that the test should run on."
msgstr ""

#: ../../../trace/ftrace.rst:2394
msgid "function"
msgstr ""

#: ../../../trace/ftrace.rst:2396
msgid ""
"This tracer is the function tracer. Enabling the function tracer can be done "
"from the debug file system. Make sure the ftrace_enabled is set; otherwise "
"this tracer is a nop. See the \"ftrace_enabled\" section below. ::"
msgstr ""

#: ../../../trace/ftrace.rst:2430
msgid ""
"Note: function tracer uses ring buffers to store the above entries. The "
"newest data may overwrite the oldest data. Sometimes using echo to stop the "
"trace is not sufficient because the tracing could have overwritten the data "
"that you wanted to record. For this reason, it is sometimes better to "
"disable tracing directly from a program. This allows you to stop the tracing "
"at the point that you hit the part that you are interested in. To disable "
"the tracing directly from a C program, something like following code snippet "
"can be used::"
msgstr ""

#: ../../../trace/ftrace.rst:2454
msgid "Single thread tracing"
msgstr ""

#: ../../../trace/ftrace.rst:2456
msgid ""
"By writing into set_ftrace_pid you can trace a single thread. For example::"
msgstr ""

#: ../../../trace/ftrace.rst:2489
msgid ""
"If you want to trace a function when executing, you could use something like "
"this simple program. ::"
msgstr ""

#: ../../../trace/ftrace.rst:2577
msgid "Or this simple script! ::"
msgstr ""

#: ../../../trace/ftrace.rst:2591
msgid "function graph tracer"
msgstr ""

#: ../../../trace/ftrace.rst:2593
msgid ""
"This tracer is similar to the function tracer except that it probes a "
"function on its entry and its exit. This is done by using a dynamically "
"allocated stack of return addresses in each task_struct. On function entry "
"the tracer overwrites the return address of each function traced to set a "
"custom probe. Thus the original return address is stored on the stack of "
"return address in the task_struct."
msgstr ""

#: ../../../trace/ftrace.rst:2601
msgid "Probing on both ends of a function leads to special features such as:"
msgstr ""

#: ../../../trace/ftrace.rst:2604
msgid "measure of a function's time execution"
msgstr ""

#: ../../../trace/ftrace.rst:2605
msgid "having a reliable call stack to draw function calls graph"
msgstr ""

#: ../../../trace/ftrace.rst:2607
msgid "This tracer is useful in several situations:"
msgstr ""

#: ../../../trace/ftrace.rst:2609
msgid ""
"you want to find the reason of a strange kernel behavior and need to see "
"what happens in detail on any areas (or specific ones)."
msgstr ""

#: ../../../trace/ftrace.rst:2613
msgid ""
"you are experiencing weird latencies but it's difficult to find its origin."
msgstr ""

#: ../../../trace/ftrace.rst:2616
msgid "you want to find quickly which path is taken by a specific function"
msgstr ""

#: ../../../trace/ftrace.rst:2619
msgid ""
"you just want to peek inside a working kernel and want to see what happens "
"there."
msgstr ""

#: ../../../trace/ftrace.rst:2647
msgid ""
"There are several columns that can be dynamically enabled/disabled. You can "
"use every combination of options you want, depending on your needs."
msgstr ""

#: ../../../trace/ftrace.rst:2651
msgid ""
"The cpu number on which the function executed is default enabled.  It is "
"sometimes better to only trace one cpu (see tracing_cpumask file) or you "
"might sometimes see unordered function calls while cpu tracing switch."
msgstr ""

#: ../../../trace/ftrace.rst:2656
msgid "hide: echo nofuncgraph-cpu > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2657
msgid "show: echo funcgraph-cpu > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2659
msgid ""
"The duration (function's time of execution) is displayed on the closing "
"bracket line of a function or on the same line than the current function in "
"case of a leaf one. It is default enabled."
msgstr ""

#: ../../../trace/ftrace.rst:2664
msgid "hide: echo nofuncgraph-duration > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2665
msgid "show: echo funcgraph-duration > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2667
msgid ""
"The overhead field precedes the duration field in case of reached duration "
"thresholds."
msgstr ""

#: ../../../trace/ftrace.rst:2670
msgid "hide: echo nofuncgraph-overhead > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2671
msgid "show: echo funcgraph-overhead > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2672
msgid "depends on: funcgraph-duration"
msgstr ""

#: ../../../trace/ftrace.rst:2674 ../../../trace/ftrace.rst:2730
#: ../../../trace/ftrace.rst:2754
msgid "ie::"
msgstr ""

#: ../../../trace/ftrace.rst:2714
msgid "Flags::"
msgstr ""

#: ../../../trace/ftrace.rst:2724
msgid ""
"The task/pid field displays the thread cmdline and pid which executed the "
"function. It is default disabled."
msgstr ""

#: ../../../trace/ftrace.rst:2727
msgid "hide: echo nofuncgraph-proc > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2728
msgid "show: echo funcgraph-proc > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2747
msgid ""
"The absolute time field is an absolute timestamp given by the system clock "
"since it started. A snapshot of this time is given on each entry/exit of "
"functions"
msgstr ""

#: ../../../trace/ftrace.rst:2751
msgid "hide: echo nofuncgraph-abstime > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2752
msgid "show: echo funcgraph-abstime > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2774
msgid ""
"The function name is always displayed after the closing bracket for a "
"function if the start of that function is not in the trace buffer."
msgstr ""

#: ../../../trace/ftrace.rst:2778
msgid ""
"Display of the function name after the closing bracket may be enabled for "
"functions whose start is in the trace buffer, allowing easier searching with "
"grep for function durations. It is default disabled."
msgstr ""

#: ../../../trace/ftrace.rst:2783
msgid "hide: echo nofuncgraph-tail > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2784
msgid "show: echo funcgraph-tail > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2786
msgid "Example with nofuncgraph-tail (default)::"
msgstr ""

#: ../../../trace/ftrace.rst:2794
msgid "Example with funcgraph-tail::"
msgstr ""

#: ../../../trace/ftrace.rst:2802
msgid ""
"The return value of each traced function can be displayed after an equal "
"sign \"=\". When encountering system call failures, it can be very helpful "
"to quickly locate the function that first returns an error code."
msgstr ""

#: ../../../trace/ftrace.rst:2807
msgid "hide: echo nofuncgraph-retval > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2808
msgid "show: echo funcgraph-retval > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2810
msgid "Example with funcgraph-retval::"
msgstr ""

#: ../../../trace/ftrace.rst:2824
msgid ""
"The above example shows that the function cpu_cgroup_can_attach returned the "
"error code -22 firstly, then we can read the code of this function to get "
"the root cause."
msgstr ""

#: ../../../trace/ftrace.rst:2828
msgid ""
"When the option funcgraph-retval-hex is not set, the return value can be "
"displayed in a smart way. Specifically, if it is an error code, it will be "
"printed in signed decimal format, otherwise it will printed in hexadecimal "
"format."
msgstr ""

#: ../../../trace/ftrace.rst:2833
msgid "smart: echo nofuncgraph-retval-hex > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2834
msgid "hexadecimal: echo funcgraph-retval-hex > trace_options"
msgstr ""

#: ../../../trace/ftrace.rst:2836
msgid "Example with funcgraph-retval-hex::"
msgstr ""

#: ../../../trace/ftrace.rst:2850
msgid ""
"At present, there are some limitations when using the funcgraph-retval "
"option, and these limitations will be eliminated in the future:"
msgstr ""

#: ../../../trace/ftrace.rst:2853
msgid ""
"Even if the function return type is void, a return value will still be "
"printed, and you can just ignore it."
msgstr ""

#: ../../../trace/ftrace.rst:2856
msgid ""
"Even if return values are stored in multiple registers, only the value "
"contained in the first register will be recorded and printed. To illustrate, "
"in the x86 architecture, eax and edx are used to store a 64-bit return "
"value, with the lower 32 bits saved in eax and the upper 32 bits saved in "
"edx. However, only the value stored in eax will be recorded and printed."
msgstr ""

#: ../../../trace/ftrace.rst:2863
msgid ""
"In certain procedure call standards, such as arm64's AAPCS64, when a type is "
"smaller than a GPR, it is the responsibility of the consumer to perform the "
"narrowing, and the upper bits may contain UNKNOWN values. Therefore, it is "
"advisable to check the code for such cases. For instance, when using a u8 in "
"a 64-bit GPR, bits [63:8] may contain arbitrary values, especially when "
"larger types are truncated, whether explicitly or implicitly. Here are some "
"specific cases to illustrate this point:"
msgstr ""

#: ../../../trace/ftrace.rst:2871
msgid "**Case One**:"
msgstr ""

#: ../../../trace/ftrace.rst:2873
msgid "The function narrow_to_u8 is defined as follows::"
msgstr ""

#: ../../../trace/ftrace.rst:2881
msgid "It may be compiled to::"
msgstr ""

#: ../../../trace/ftrace.rst:2887
msgid ""
"If you pass 0x123456789abcdef to this function and want to narrow it, it may "
"be recorded as 0x123456789abcdef instead of 0xef."
msgstr ""

#: ../../../trace/ftrace.rst:2890
msgid "**Case Two**:"
msgstr ""

#: ../../../trace/ftrace.rst:2892
msgid "The function error_if_not_4g_aligned is defined as follows::"
msgstr ""

#: ../../../trace/ftrace.rst:2902
msgid "It could be compiled to::"
msgstr ""

#: ../../../trace/ftrace.rst:2912
msgid ""
"When passing 0x2_0000_0000 to it, the return value may be recorded as "
"0x2_0000_0000 instead of 0."
msgstr ""

#: ../../../trace/ftrace.rst:2915
msgid ""
"You can put some comments on specific functions by using trace_printk() For "
"example, if you want to put a comment inside the __might_sleep() function, "
"you just have to include <linux/ftrace.h> and call trace_printk() inside "
"__might_sleep()::"
msgstr ""

#: ../../../trace/ftrace.rst:2922
msgid "will produce::"
msgstr ""

#: ../../../trace/ftrace.rst:2929
msgid ""
"You might find other useful features for this tracer in the following "
"\"dynamic ftrace\" section such as tracing only specific functions or tasks."
msgstr ""

#: ../../../trace/ftrace.rst:2934
msgid "dynamic ftrace"
msgstr ""

#: ../../../trace/ftrace.rst:2936
msgid ""
"If CONFIG_DYNAMIC_FTRACE is set, the system will run with virtually no "
"overhead when function tracing is disabled. The way this works is the mcount "
"function call (placed at the start of every kernel function, produced by the "
"-pg switch in gcc), starts of pointing to a simple return. (Enabling FTRACE "
"will include the -pg switch in the compiling of the kernel.)"
msgstr ""

#: ../../../trace/ftrace.rst:2943
msgid ""
"At compile time every C file object is run through the recordmcount program "
"(located in the scripts directory). This program will parse the ELF headers "
"in the C object to find all the locations in the .text section that call "
"mcount. Starting with gcc version 4.6, the -mfentry has been added for x86, "
"which calls \"__fentry__\" instead of \"mcount\". Which is called before the "
"creation of the stack frame."
msgstr ""

#: ../../../trace/ftrace.rst:2951
msgid ""
"Note, not all sections are traced. They may be prevented by either a "
"notrace, or blocked another way and all inline functions are not traced. "
"Check the \"available_filter_functions\" file to see what functions can be "
"traced."
msgstr ""

#: ../../../trace/ftrace.rst:2956
msgid ""
"A section called \"__mcount_loc\" is created that holds references to all "
"the mcount/fentry call sites in the .text section. The recordmcount program "
"re-links this section back into the original object. The final linking stage "
"of the kernel will add all these references into a single table."
msgstr ""

#: ../../../trace/ftrace.rst:2962
msgid ""
"On boot up, before SMP is initialized, the dynamic ftrace code scans this "
"table and updates all the locations into nops. It also records the "
"locations, which are added to the available_filter_functions list.  Modules "
"are processed as they are loaded and before they are executed.  When a "
"module is unloaded, it also removes its functions from the ftrace function "
"list. This is automatic in the module unload code, and the module author "
"does not need to worry about it."
msgstr ""

#: ../../../trace/ftrace.rst:2971
msgid ""
"When tracing is enabled, the process of modifying the function tracepoints "
"is dependent on architecture. The old method is to use kstop_machine to "
"prevent races with the CPUs executing code being modified (which can cause "
"the CPU to do undesirable things, especially if the modified code crosses "
"cache (or page) boundaries), and the nops are patched back to calls. But "
"this time, they do not call mcount (which is just a function stub). They now "
"call into the ftrace infrastructure."
msgstr ""

#: ../../../trace/ftrace.rst:2980
msgid ""
"The new method of modifying the function tracepoints is to place a "
"breakpoint at the location to be modified, sync all CPUs, modify the rest of "
"the instruction not covered by the breakpoint. Sync all CPUs again, and then "
"remove the breakpoint with the finished version to the ftrace call site."
msgstr ""

#: ../../../trace/ftrace.rst:2986
msgid ""
"Some archs do not even need to monkey around with the synchronization, and "
"can just slap the new code on top of the old without any problems with other "
"CPUs executing it at the same time."
msgstr ""

#: ../../../trace/ftrace.rst:2990
msgid ""
"One special side-effect to the recording of the functions being traced is "
"that we can now selectively choose which functions we wish to trace and "
"which ones we want the mcount calls to remain as nops."
msgstr ""

#: ../../../trace/ftrace.rst:2995
msgid ""
"Two files are used, one for enabling and one for disabling the tracing of "
"specified functions. They are:"
msgstr ""

#: ../../../trace/ftrace.rst:2998
msgid "set_ftrace_filter"
msgstr ""

#: ../../../trace/ftrace.rst:3000
msgid "and"
msgstr ""

#: ../../../trace/ftrace.rst:3002
msgid "set_ftrace_notrace"
msgstr ""

#: ../../../trace/ftrace.rst:3004
msgid ""
"A list of available functions that you can add to these files is listed in:"
msgstr ""

#: ../../../trace/ftrace.rst:3007
msgid "available_filter_functions"
msgstr ""

#: ../../../trace/ftrace.rst:3020
msgid "If I am only interested in sys_nanosleep and hrtimer_interrupt::"
msgstr ""

#: ../../../trace/ftrace.rst:3045
msgid "To see which functions are being traced, you can cat the file: ::"
msgstr ""

#: ../../../trace/ftrace.rst:3053
msgid "Perhaps this is not enough. The filters also allow glob(7) matching."
msgstr ""

#: ../../../trace/ftrace.rst:3055
msgid "``<match>*``"
msgstr ""

#: ../../../trace/ftrace.rst:3056
msgid "will match functions that begin with <match>"
msgstr ""

#: ../../../trace/ftrace.rst:3057
msgid "``*<match>``"
msgstr ""

#: ../../../trace/ftrace.rst:3058
msgid "will match functions that end with <match>"
msgstr ""

#: ../../../trace/ftrace.rst:3059
msgid "``*<match>*``"
msgstr ""

#: ../../../trace/ftrace.rst:3060
msgid "will match functions that have <match> in it"
msgstr ""

#: ../../../trace/ftrace.rst:3061
msgid "``<match1>*<match2>``"
msgstr ""

#: ../../../trace/ftrace.rst:3062
msgid "will match functions that begin with <match1> and end with <match2>"
msgstr ""

#: ../../../trace/ftrace.rst:3065
msgid ""
"It is better to use quotes to enclose the wild cards, otherwise the shell "
"may expand the parameters into names of files in the local directory."
msgstr ""

#: ../../../trace/ftrace.rst:3073 ../../../trace/ftrace.rst:3162
msgid "Produces::"
msgstr ""

#: ../../../trace/ftrace.rst:3095
msgid "Notice that we lost the sys_nanosleep. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3117
msgid ""
"This is because the '>' and '>>' act just like they do in bash. To rewrite "
"the filters, use '>' To append to the filters, use '>>'"
msgstr ""

#: ../../../trace/ftrace.rst:3121
msgid "To clear out a filter so that all functions will be recorded again::"
msgstr ""

#: ../../../trace/ftrace.rst:3128
msgid "Again, now we want to append."
msgstr ""

#: ../../../trace/ftrace.rst:3156
msgid "The set_ftrace_notrace prevents those functions from being traced. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3188
msgid "We can see that there's no more lock or preempt tracing."
msgstr ""

#: ../../../trace/ftrace.rst:3191
msgid "Selecting function filters via index"
msgstr ""

#: ../../../trace/ftrace.rst:3193
msgid ""
"Because processing of strings is expensive (the address of the function "
"needs to be looked up before comparing to the string being passed in), an "
"index can be used as well to enable functions. This is useful in the case of "
"setting thousands of specific functions at a time. By passing in a list of "
"numbers, no string processing will occur. Instead, the function at the "
"specific location in the internal array (which corresponds to the functions "
"in the \"available_filter_functions\" file), is selected."
msgstr ""

#: ../../../trace/ftrace.rst:3205
msgid "Will select the first function listed in \"available_filter_functions\""
msgstr ""

#: ../../../trace/ftrace.rst:3224
msgid "Dynamic ftrace with the function graph tracer"
msgstr ""

#: ../../../trace/ftrace.rst:3226
msgid ""
"Although what has been explained above concerns both the function tracer and "
"the function-graph-tracer, there are some special features only available in "
"the function-graph tracer."
msgstr ""

#: ../../../trace/ftrace.rst:3230
msgid ""
"If you want to trace only one function and all of its children, you just "
"have to echo its name into set_graph_function::"
msgstr ""

#: ../../../trace/ftrace.rst:3235
msgid ""
"will produce the following \"expanded\" trace of the __do_fault() function::"
msgstr ""

#: ../../../trace/ftrace.rst:3273
msgid "You can also expand several functions at once::"
msgstr ""

#: ../../../trace/ftrace.rst:3278
msgid ""
"Now if you want to go back to trace all functions you can clear this special "
"filter via::"
msgstr ""

#: ../../../trace/ftrace.rst:3285
msgid "ftrace_enabled"
msgstr ""

#: ../../../trace/ftrace.rst:3287
msgid ""
"Note, the proc sysctl ftrace_enable is a big on/off switch for the function "
"tracer. By default it is enabled (when function tracing is enabled in the "
"kernel). If it is disabled, all function tracing is disabled. This includes "
"not only the function tracers for ftrace, but also for any other uses (perf, "
"kprobes, stack tracing, profiling, etc). It cannot be disabled if there is a "
"callback with FTRACE_OPS_FL_PERMANENT set registered."
msgstr ""

#: ../../../trace/ftrace.rst:3295
msgid "Please disable this with care."
msgstr ""

#: ../../../trace/ftrace.rst:3297
msgid "This can be disable (and enabled) with::"
msgstr ""

#: ../../../trace/ftrace.rst:3309
msgid "Filter commands"
msgstr ""

#: ../../../trace/ftrace.rst:3311
msgid ""
"A few commands are supported by the set_ftrace_filter interface. Trace "
"commands have the following format::"
msgstr ""

#: ../../../trace/ftrace.rst:3316
msgid "The following commands are supported:"
msgstr ""

#: ../../../trace/ftrace.rst:3318
msgid ""
"mod: This command enables function filtering per module. The parameter "
"defines the module. For example, if only the write* functions in the ext3 "
"module are desired, run:"
msgstr ""

#: ../../../trace/ftrace.rst:3323
msgid "echo 'write*:mod:ext3' > set_ftrace_filter"
msgstr ""

#: ../../../trace/ftrace.rst:3325
msgid ""
"This command interacts with the filter in the same way as filtering based on "
"function names. Thus, adding more functions in a different module is "
"accomplished by appending (>>) to the filter file. Remove specific module "
"functions by prepending '!'::"
msgstr ""

#: ../../../trace/ftrace.rst:3333
msgid ""
"Mod command supports module globbing. Disable tracing for all functions "
"except a specific module::"
msgstr ""

#: ../../../trace/ftrace.rst:3338
msgid "Disable tracing for all modules, but still trace kernel::"
msgstr ""

#: ../../../trace/ftrace.rst:3342
msgid "Enable filter only for kernel::"
msgstr ""

#: ../../../trace/ftrace.rst:3346
msgid "Enable filter for module globbing::"
msgstr ""

#: ../../../trace/ftrace.rst:3350
msgid ""
"traceon/traceoff: These commands turn tracing on and off when the specified "
"functions are hit. The parameter determines how many times the tracing "
"system is turned on and off. If unspecified, there is no limit. For example, "
"to disable tracing when a schedule bug is hit the first 5 times, run::"
msgstr ""

#: ../../../trace/ftrace.rst:3359
msgid "To always disable tracing when __schedule_bug is hit::"
msgstr ""

#: ../../../trace/ftrace.rst:3363
msgid ""
"These commands are cumulative whether or not they are appended to "
"set_ftrace_filter. To remove a command, prepend it by '!' and drop the "
"parameter::"
msgstr ""

#: ../../../trace/ftrace.rst:3369
msgid ""
"The above removes the traceoff command for __schedule_bug that have a "
"counter. To remove commands without counters::"
msgstr ""

#: ../../../trace/ftrace.rst:3374
msgid ""
"snapshot: Will cause a snapshot to be triggered when the function is hit. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3380
msgid "To only snapshot once: ::"
msgstr ""

#: ../../../trace/ftrace.rst:3385
msgid "To remove the above commands::"
msgstr ""

#: ../../../trace/ftrace.rst:3390
msgid ""
"enable_event/disable_event: These commands can enable or disable a trace "
"event. Note, because function tracing callbacks are very sensitive, when "
"these commands are registered, the trace point is activated, but disabled in "
"a \"soft\" mode. That is, the tracepoint will be called, but just will not "
"be traced. The event tracepoint stays in this mode as long as there's a "
"command that triggers it. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3402
msgid "The format is::"
msgstr ""

#: ../../../trace/ftrace.rst:3407
msgid "To remove the events commands::"
msgstr ""

#: ../../../trace/ftrace.rst:3414
msgid ""
"dump: When the function is hit, it will dump the contents of the ftrace ring "
"buffer to the console. This is useful if you need to debug something, and "
"want to dump the trace when a certain function is hit. Perhaps it's a "
"function that is called before a triple fault happens and does not allow you "
"to get a regular dump."
msgstr ""

#: ../../../trace/ftrace.rst:3421
msgid ""
"cpudump: When the function is hit, it will dump the contents of the ftrace "
"ring buffer for the current CPU to the console. Unlike the \"dump\" command, "
"it only prints out the contents of the ring buffer for the CPU that executed "
"the function that triggered the dump."
msgstr ""

#: ../../../trace/ftrace.rst:3427
msgid "stacktrace: When the function is hit, a stack trace is recorded."
msgstr ""

#: ../../../trace/ftrace.rst:3431
msgid "trace_pipe"
msgstr ""

#: ../../../trace/ftrace.rst:3433
msgid ""
"The trace_pipe outputs the same content as the trace file, but the effect on "
"the tracing is different. Every read from trace_pipe is consumed. This means "
"that subsequent reads will be different. The trace is live. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3471
msgid ""
"Note, reading the trace_pipe file will block until more input is added. This "
"is contrary to the trace file. If any process opened the trace file for "
"reading, it will actually disable tracing and prevent new entries from being "
"added. The trace_pipe file does not have this limitation."
msgstr ""

#: ../../../trace/ftrace.rst:3478
msgid "trace entries"
msgstr ""

#: ../../../trace/ftrace.rst:3480
msgid ""
"Having too much or not enough data can be troublesome in diagnosing an issue "
"in the kernel. The file buffer_size_kb is used to modify the size of the "
"internal trace buffers. The number listed is the number of entries that can "
"be recorded per CPU. To know the full size, multiply the number of possible "
"CPUs with the number of entries. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3491
msgid "Or simply read buffer_total_size_kb ::"
msgstr ""

#: ../../../trace/ftrace.rst:3497
msgid ""
"To modify the buffer, simple echo in a number (in 1024 byte segments). ::"
msgstr ""

#: ../../../trace/ftrace.rst:3504
msgid ""
"It will try to allocate as much as possible. If you allocate too much, it "
"can cause Out-Of-Memory to trigger. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3513
msgid "The per_cpu buffers can be changed individually as well: ::"
msgstr ""

#: ../../../trace/ftrace.rst:3519
msgid ""
"When the per_cpu buffers are not the same, the buffer_size_kb at the top "
"level will just show an X ::"
msgstr ""

#: ../../../trace/ftrace.rst:3526
msgid "This is where the buffer_total_size_kb is useful: ::"
msgstr ""

#: ../../../trace/ftrace.rst:3532
msgid ""
"Writing to the top level buffer_size_kb will reset all the buffers to be the "
"same again."
msgstr ""

#: ../../../trace/ftrace.rst:3536
msgid "Snapshot"
msgstr ""

#: ../../../trace/ftrace.rst:3537
msgid ""
"CONFIG_TRACER_SNAPSHOT makes a generic snapshot feature available to all non "
"latency tracers. (Latency tracers which record max latency, such as "
"\"irqsoff\" or \"wakeup\", can't use this feature, since those are already "
"using the snapshot mechanism internally.)"
msgstr ""

#: ../../../trace/ftrace.rst:3543
msgid ""
"Snapshot preserves a current trace buffer at a particular point in time "
"without stopping tracing. Ftrace swaps the current buffer with a spare "
"buffer, and tracing continues in the new current (=previous spare) buffer."
msgstr ""

#: ../../../trace/ftrace.rst:3548
msgid "The following tracefs files in \"tracing\" are related to this feature:"
msgstr ""

#: ../../../trace/ftrace.rst:3553
msgid ""
"This is used to take a snapshot and to read the output of the snapshot. Echo "
"1 into this file to allocate a spare buffer and to take a snapshot (swap), "
"then read the snapshot from this file in the same format as "
"\"trace\" (described above in the section \"The File System\"). Both reads "
"snapshot and tracing are executable in parallel. When the spare buffer is "
"allocated, echoing 0 frees it, and echoing else (positive) values clear the "
"snapshot contents. More details are shown in the table below."
msgstr ""

#: ../../../trace/ftrace.rst:3565
msgid "status\\\\input"
msgstr ""

#: ../../../trace/ftrace.rst:3565
msgid "0"
msgstr ""

#: ../../../trace/ftrace.rst:3565
msgid "1"
msgstr ""

#: ../../../trace/ftrace.rst:3565
msgid "else"
msgstr ""

#: ../../../trace/ftrace.rst:3567
msgid "not allocated"
msgstr ""

#: ../../../trace/ftrace.rst:3567
msgid "(do nothing)"
msgstr ""

#: ../../../trace/ftrace.rst:3567
msgid "alloc+swap"
msgstr ""

#: ../../../trace/ftrace.rst:3569
msgid "allocated"
msgstr ""

#: ../../../trace/ftrace.rst:3569
msgid "free"
msgstr ""

#: ../../../trace/ftrace.rst:3569
msgid "swap"
msgstr ""

#: ../../../trace/ftrace.rst:3569
msgid "clear"
msgstr ""

#: ../../../trace/ftrace.rst:3572
msgid "Here is an example of using the snapshot feature. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3611
msgid ""
"If you try to use this snapshot feature when current tracer is one of the "
"latency tracers, you will get the following results. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3623
msgid "Instances"
msgstr ""

#: ../../../trace/ftrace.rst:3624
msgid ""
"In the tracefs tracing directory, there is a directory called \"instances\". "
"This directory can have new directories created inside of it using mkdir, "
"and removing directories with rmdir. The directory created with mkdir in "
"this directory will already contain files and other directories after it is "
"created. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3637
msgid ""
"As you can see, the new directory looks similar to the tracing directory "
"itself. In fact, it is very similar, except that the buffer and events are "
"agnostic from the main directory, or from any other instances that are "
"created."
msgstr ""

#: ../../../trace/ftrace.rst:3642
msgid ""
"The files in the new directory work just like the files with the same name "
"in the tracing directory except the buffer that is used is a separate and "
"new buffer. The files affect that buffer but do not affect the main buffer "
"with the exception of trace_options. Currently, the trace_options affect all "
"instances and the top level buffer the same, but this may change in future "
"releases. That is, options may become specific to the instance they reside "
"in."
msgstr ""

#: ../../../trace/ftrace.rst:3650
msgid ""
"Notice that none of the function tracer files are there, nor is "
"current_tracer and available_tracers. This is because the buffers can "
"currently only have events enabled for them. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3734
msgid ""
"You can see that the trace of the top most trace buffer shows only the "
"function tracing. The foo instance displays wakeups and task switches."
msgstr ""

#: ../../../trace/ftrace.rst:3738
msgid "To remove the instances, simply delete their directories: ::"
msgstr ""

#: ../../../trace/ftrace.rst:3745
msgid ""
"Note, if a process has a trace file open in one of the instance directories, "
"the rmdir will fail with EBUSY."
msgstr ""

#: ../../../trace/ftrace.rst:3750
msgid "Stack trace"
msgstr ""

#: ../../../trace/ftrace.rst:3751
msgid ""
"Since the kernel has a fixed sized stack, it is important not to waste it in "
"functions. A kernel developer must be conscious of what they allocate on the "
"stack. If they add too much, the system can be in danger of a stack "
"overflow, and corruption will occur, usually leading to a system panic."
msgstr ""

#: ../../../trace/ftrace.rst:3757
msgid ""
"There are some tools that check this, usually with interrupts periodically "
"checking usage. But if you can perform a check at every function call that "
"will become very useful. As ftrace provides a function tracer, it makes it "
"convenient to check the stack size at every function call. This is enabled "
"via the stack tracer."
msgstr ""

#: ../../../trace/ftrace.rst:3763
msgid ""
"CONFIG_STACK_TRACER enables the ftrace stack tracing functionality. To "
"enable it, write a '1' into /proc/sys/kernel/stack_tracer_enabled. ::"
msgstr ""

#: ../../../trace/ftrace.rst:3769
msgid ""
"You can also enable it from the kernel command line to trace the stack size "
"of the kernel during boot up, by adding \"stacktrace\" to the kernel command "
"line parameter."
msgstr ""

#: ../../../trace/ftrace.rst:3773
msgid "After running it for a few minutes, the output looks like: ::"
msgstr ""

#: ../../../trace/ftrace.rst:3801
msgid ""
"Note, if -mfentry is being used by gcc, functions get traced before they set "
"up the stack frame. This means that leaf level functions are not tested by "
"the stack tracer when -mfentry is used."
msgstr ""

#: ../../../trace/ftrace.rst:3805
msgid "Currently, -mfentry is used by gcc 4.6.0 and above on x86 only."
msgstr ""

#: ../../../trace/ftrace.rst:3808
msgid "More"
msgstr ""

#: ../../../trace/ftrace.rst:3809
msgid ""
"More details can be found in the source code, in the `kernel/trace/*.c` "
"files."
msgstr ""
