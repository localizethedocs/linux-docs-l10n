# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/mmiotrace.rst:3
msgid "In-kernel memory-mapped I/O tracing"
msgstr ""

#: ../../../trace/mmiotrace.rst:6
msgid "Home page and links to optional user space tools:"
msgstr ""

#: ../../../trace/mmiotrace.rst:8
msgid "https://nouveau.freedesktop.org/wiki/MmioTrace"
msgstr ""

#: ../../../trace/mmiotrace.rst:10
msgid ""
"MMIO tracing was originally developed by Intel around 2003 for their Fault "
"Injection Test Harness. In Dec 2006 - Jan 2007, using the code from Intel, "
"Jeff Muizelaar created a tool for tracing MMIO accesses with the Nouveau "
"project in mind. Since then many people have contributed."
msgstr ""

#: ../../../trace/mmiotrace.rst:15
msgid ""
"Mmiotrace was built for reverse engineering any memory-mapped IO device with "
"the Nouveau project as the first real user. Only x86 and x86_64 "
"architectures are supported."
msgstr ""

#: ../../../trace/mmiotrace.rst:19
msgid ""
"Out-of-tree mmiotrace was originally modified for mainline inclusion and "
"ftrace framework by Pekka Paalanen <pq@iki.fi>."
msgstr ""

#: ../../../trace/mmiotrace.rst:24
msgid "Preparation"
msgstr ""

#: ../../../trace/mmiotrace.rst:26
msgid ""
"Mmiotrace feature is compiled in by the CONFIG_MMIOTRACE option. Tracing is "
"disabled by default, so it is safe to have this set to yes. SMP systems are "
"supported, but tracing is unreliable and may miss events if more than one "
"CPU is on-line, therefore mmiotrace takes all but one CPU off-line during "
"run-time activation. You can re-enable CPUs by hand, but you have been "
"warned, there is no way to automatically detect if you are losing events due "
"to CPUs racing."
msgstr ""

#: ../../../trace/mmiotrace.rst:35
msgid "Usage Quick Reference"
msgstr ""

#: ../../../trace/mmiotrace.rst:48
msgid "Usage"
msgstr ""

#: ../../../trace/mmiotrace.rst:50
msgid ""
"Make sure debugfs is mounted to /sys/kernel/debug. If not (requires root "
"privileges)::"
msgstr ""

#: ../../../trace/mmiotrace.rst:55
msgid "Check that the driver you are about to trace is not loaded."
msgstr ""

#: ../../../trace/mmiotrace.rst:57
msgid "Activate mmiotrace (requires root privileges)::"
msgstr ""

#: ../../../trace/mmiotrace.rst:61
msgid "Start storing the trace::"
msgstr ""

#: ../../../trace/mmiotrace.rst:65
msgid "The 'cat' process should stay running (sleeping) in the background."
msgstr ""

#: ../../../trace/mmiotrace.rst:67
msgid ""
"Load the driver you want to trace and use it. Mmiotrace will only catch MMIO "
"accesses to areas that are ioremapped while mmiotrace is active."
msgstr ""

#: ../../../trace/mmiotrace.rst:70
msgid ""
"During tracing you can place comments (markers) into the trace by $ echo \"X "
"is up\" > /sys/kernel/tracing/trace_marker This makes it easier to see which "
"part of the (huge) trace corresponds to which action. It is recommended to "
"place descriptive markers about what you do."
msgstr ""

#: ../../../trace/mmiotrace.rst:76
msgid "Shut down mmiotrace (requires root privileges)::"
msgstr ""

#: ../../../trace/mmiotrace.rst:80
msgid ""
"The 'cat' process exits. If it does not, kill it by issuing 'fg' command and "
"pressing ctrl+c."
msgstr ""

#: ../../../trace/mmiotrace.rst:83
msgid ""
"Check that mmiotrace did not lose events due to a buffer filling up. Either::"
msgstr ""

#: ../../../trace/mmiotrace.rst:87
msgid "which tells you exactly how many events were lost, or use::"
msgstr ""

#: ../../../trace/mmiotrace.rst:91
msgid ""
"to view your kernel log and look for \"mmiotrace has lost events\" warning. "
"If events were lost, the trace is incomplete. You should enlarge the buffers "
"and try again. Buffers are enlarged by first seeing how large the current "
"buffers are::"
msgstr ""

#: ../../../trace/mmiotrace.rst:98
msgid ""
"gives you a number. Approximately double this number and write it back, for "
"instance::"
msgstr ""

#: ../../../trace/mmiotrace.rst:103
msgid "Then start again from the top."
msgstr ""

#: ../../../trace/mmiotrace.rst:105
msgid ""
"If you are doing a trace for a driver project, e.g. Nouveau, you should also "
"do the following before sending your results::"
msgstr ""

#: ../../../trace/mmiotrace.rst:112
msgid ""
"and then send the .tar.gz file. The trace compresses considerably. Replace "
"\"pciid\" and \"nick\" with the PCI ID or model name of your piece of "
"hardware under investigation and your nickname."
msgstr ""

#: ../../../trace/mmiotrace.rst:118
msgid "How Mmiotrace Works"
msgstr ""

#: ../../../trace/mmiotrace.rst:120
msgid ""
"Access to hardware IO-memory is gained by mapping addresses from PCI bus by "
"calling one of the ioremap_*() functions. Mmiotrace is hooked into the "
"__ioremap() function and gets called whenever a mapping is created. Mapping "
"is an event that is recorded into the trace log. Note that ISA range "
"mappings are not caught, since the mapping always exists and is returned "
"directly."
msgstr ""

#: ../../../trace/mmiotrace.rst:126
msgid ""
"MMIO accesses are recorded via page faults. Just before __ioremap() returns, "
"the mapped pages are marked as not present. Any access to the pages causes a "
"fault. The page fault handler calls mmiotrace to handle the fault. Mmiotrace "
"marks the page present, sets TF flag to achieve single stepping and exits "
"the fault handler. The instruction that faulted is executed and debug trap "
"is entered. Here mmiotrace again marks the page as not present. The "
"instruction is decoded to get the type of operation (read/write), data width "
"and the value read or written. These are stored to the trace log."
msgstr ""

#: ../../../trace/mmiotrace.rst:135
msgid ""
"Setting the page present in the page fault handler has a race condition on "
"SMP machines. During the single stepping other CPUs may run freely on that "
"page and events can be missed without a notice. Re-enabling other CPUs "
"during tracing is discouraged."
msgstr ""

#: ../../../trace/mmiotrace.rst:142
msgid "Trace Log Format"
msgstr ""

#: ../../../trace/mmiotrace.rst:144
msgid ""
"The raw log is text and easily filtered with e.g. grep and awk. One record "
"is one line in the log. A record starts with a keyword, followed by keyword- "
"dependent arguments. Arguments are separated by a space, or continue until "
"the end of line. The format for version 20070824 is as follows:"
msgstr ""

#: ../../../trace/mmiotrace.rst:150
msgid "Explanation     Keyword Space-separated arguments"
msgstr ""

#: ../../../trace/mmiotrace.rst:152
msgid ""
"read event      R       width, timestamp, map id, physical, value, PC, PID "
"write event     W       width, timestamp, map id, physical, value, PC, PID "
"ioremap event   MAP     timestamp, map id, physical, virtual, length, PC, "
"PID iounmap event   UNMAP   timestamp, map id, PC, PID marker          "
"MARK    timestamp, text version         VERSION the string \"20070824\" info "
"for reader LSPCI   one line from lspci -v PCI address map PCIDEV  space-"
"separated /proc/bus/pci/devices data unk. opcode     UNKNOWN timestamp, map "
"id, physical, data, PC, PID"
msgstr ""

#: ../../../trace/mmiotrace.rst:162
msgid ""
"Timestamp is in seconds with decimals. Physical is a PCI bus address, "
"virtual is a kernel virtual address. Width is the data width in bytes and "
"value is the data value. Map id is an arbitrary id number identifying the "
"mapping that was used in an operation. PC is the program counter and PID is "
"process id. PC is zero if it is not recorded. PID is always zero as tracing "
"MMIO accesses originating in user space memory is not yet supported."
msgstr ""

#: ../../../trace/mmiotrace.rst:169
msgid ""
"For instance, the following awk filter will pass all 32-bit writes that "
"target physical addresses in the range [0xfb73ce40, 0xfb800000] ::"
msgstr ""

#: ../../../trace/mmiotrace.rst:178
msgid "Tools for Developers"
msgstr ""

#: ../../../trace/mmiotrace.rst:180
msgid "The user space tools include utilities for:"
msgstr ""

#: ../../../trace/mmiotrace.rst:181
msgid "replacing numeric addresses and values with hardware register names"
msgstr ""

#: ../../../trace/mmiotrace.rst:182
msgid "replaying MMIO logs, i.e., re-executing the recorded writes"
msgstr ""
