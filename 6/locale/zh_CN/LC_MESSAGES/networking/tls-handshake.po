# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/tls-handshake.rst:5
msgid "In-Kernel TLS Handshake"
msgstr ""

#: ../../../networking/tls-handshake.rst:8
msgid "Overview"
msgstr ""

#: ../../../networking/tls-handshake.rst:10
msgid ""
"Transport Layer Security (TLS) is a Upper Layer Protocol (ULP) that runs "
"over TCP. TLS provides end-to-end data integrity and confidentiality in "
"addition to peer authentication."
msgstr ""

#: ../../../networking/tls-handshake.rst:14
msgid ""
"The kernel's kTLS implementation handles the TLS record subprotocol, but "
"does not handle the TLS handshake subprotocol which is used to establish a "
"TLS session. Kernel consumers can use the API described here to request TLS "
"session establishment."
msgstr ""

#: ../../../networking/tls-handshake.rst:19
msgid ""
"There are several possible ways to provide a handshake service in the "
"kernel. The API described here is designed to hide the details of those "
"implementations so that in-kernel TLS consumers do not need to be aware of "
"how the handshake gets done."
msgstr ""

#: ../../../networking/tls-handshake.rst:26
msgid "User handshake agent"
msgstr ""

#: ../../../networking/tls-handshake.rst:28
msgid ""
"As of this writing, there is no TLS handshake implementation in the Linux "
"kernel. To provide a handshake service, a handshake agent (typically in user "
"space) is started in each network namespace where a kernel consumer might "
"require a TLS handshake. Handshake agents listen for events sent from the "
"kernel that indicate a handshake request is waiting."
msgstr ""

#: ../../../networking/tls-handshake.rst:35
msgid ""
"An open socket is passed to a handshake agent via a netlink operation, which "
"creates a socket descriptor in the agent's file descriptor table. If the "
"handshake completes successfully, the handshake agent promotes the socket to "
"use the TLS ULP and sets the session information using the SOL_TLS socket "
"options. The handshake agent returns the socket to the kernel via a second "
"netlink operation."
msgstr ""

#: ../../../networking/tls-handshake.rst:44
msgid "Kernel Handshake API"
msgstr ""

#: ../../../networking/tls-handshake.rst:46
msgid ""
"A kernel TLS consumer initiates a client-side TLS handshake on an open "
"socket by invoking one of the tls_client_hello() functions. First, it fills "
"in a structure that contains the parameters of the request:"
msgstr ""

#: ../../../networking/tls-handshake.rst:65
msgid ""
"The @ta_sock field references an open and connected socket. The consumer "
"must hold a reference on the socket to prevent it from being destroyed while "
"the handshake is in progress. The consumer must also have instantiated a "
"struct file in sock->file."
msgstr ""

#: ../../../networking/tls-handshake.rst:71
msgid ""
"@ta_done contains a callback function that is invoked when the handshake has "
"completed. Further explanation of this function is in the \"Handshake "
"Completion\" sesction below."
msgstr ""

#: ../../../networking/tls-handshake.rst:75
msgid ""
"The consumer can provide a NUL-terminated hostname in the @ta_peername field "
"that is sent as part of ClientHello. If no peername is provided, the DNS "
"hostname associated with the server's IP address is used instead."
msgstr ""

#: ../../../networking/tls-handshake.rst:79
msgid ""
"The consumer can fill in the @ta_timeout_ms field to force the servicing "
"handshake agent to exit after a number of milliseconds. This enables the "
"socket to be fully closed once both the kernel and the handshake agent have "
"closed their endpoints."
msgstr ""

#: ../../../networking/tls-handshake.rst:84
msgid ""
"Authentication material such as x.509 certificates, private certificate "
"keys, and pre-shared keys are provided to the handshake agent in keys that "
"are instantiated by the consumer before making the handshake request. The "
"consumer can provide a private keyring that is linked into the handshake "
"agent's process keyring in the @ta_keyring field to prevent access of those "
"keys by other subsystems."
msgstr ""

#: ../../../networking/tls-handshake.rst:91
msgid ""
"To request an x.509-authenticated TLS session, the consumer fills in the "
"@ta_my_cert and @ta_my_privkey fields with the serial numbers of keys "
"containing an x.509 certificate and the private key for that certificate. "
"Then, it invokes this function:"
msgstr ""

#: ../../../networking/tls-handshake.rst:100
msgid ""
"The function returns zero when the handshake request is under way. A zero "
"return guarantees the callback function @ta_done will be invoked for this "
"socket. The function returns a negative errno if the handshake could not be "
"started. A negative errno guarantees the callback function @ta_done will not "
"be invoked on this socket."
msgstr ""

#: ../../../networking/tls-handshake.rst:107
msgid "To initiate a client-side TLS handshake with a pre-shared key, use:"
msgstr ""

#: ../../../networking/tls-handshake.rst:113
msgid ""
"However, in this case, the consumer fills in the @ta_my_peerids array with "
"serial numbers of keys containing the peer identities it wishes to offer, "
"and the @ta_num_peerids field with the number of array entries it has filled "
"in. The other fields are filled in as above."
msgstr ""

#: ../../../networking/tls-handshake.rst:119
msgid "To initiate an anonymous client-side TLS handshake use:"
msgstr ""

#: ../../../networking/tls-handshake.rst:125
msgid ""
"The handshake agent presents no peer identity information to the remote "
"during this type of handshake. Only server authentication (ie the client "
"verifies the server's identity) is performed during the handshake. Thus the "
"established session uses encryption only."
msgstr ""

#: ../../../networking/tls-handshake.rst:131
msgid "Consumers that are in-kernel servers use:"
msgstr ""

#: ../../../networking/tls-handshake.rst:137
msgid "or"
msgstr ""

#: ../../../networking/tls-handshake.rst:143
msgid "The argument structure is filled in as above."
msgstr ""

#: ../../../networking/tls-handshake.rst:146
msgid ""
"If the consumer needs to cancel the handshake request, say, due to a ^C or "
"other exigent event, the consumer can invoke:"
msgstr ""

#: ../../../networking/tls-handshake.rst:153
msgid ""
"This function returns true if the handshake request associated with @sock "
"has been canceled. The consumer's handshake completion callback will not be "
"invoked. If this function returns false, then the consumer's completion "
"callback has already been invoked."
msgstr ""

#: ../../../networking/tls-handshake.rst:160
msgid "Handshake Completion"
msgstr ""

#: ../../../networking/tls-handshake.rst:162
msgid ""
"When the handshake agent has completed processing, it notifies the kernel "
"that the socket may be used by the consumer again. At this point, the "
"consumer's handshake completion callback, provided in the @ta_done field in "
"the tls_handshake_args structure, is invoked."
msgstr ""

#: ../../../networking/tls-handshake.rst:167
msgid "The synopsis of this function is:"
msgstr ""

#: ../../../networking/tls-handshake.rst:174
msgid ""
"The consumer provides a cookie in the @ta_data field of the "
"tls_handshake_args structure that is returned in the @data parameter of this "
"callback. The consumer uses the cookie to match the callback to the thread "
"waiting for the handshake to complete."
msgstr ""

#: ../../../networking/tls-handshake.rst:179
msgid ""
"The success status of the handshake is returned via the @status parameter:"
msgstr ""

#: ../../../networking/tls-handshake.rst:183
msgid "status"
msgstr ""

#: ../../../networking/tls-handshake.rst:183
msgid "meaning"
msgstr ""

#: ../../../networking/tls-handshake.rst:185
msgid "0"
msgstr ""

#: ../../../networking/tls-handshake.rst:185
msgid "TLS session established successfully"
msgstr ""

#: ../../../networking/tls-handshake.rst:187
msgid "-EACCESS"
msgstr ""

#: ../../../networking/tls-handshake.rst:187
msgid "Remote peer rejected the handshake or authentication failed"
msgstr ""

#: ../../../networking/tls-handshake.rst:190
msgid "-ENOMEM"
msgstr ""

#: ../../../networking/tls-handshake.rst:190
msgid "Temporary resource allocation failure"
msgstr ""

#: ../../../networking/tls-handshake.rst:192
msgid "-EINVAL"
msgstr ""

#: ../../../networking/tls-handshake.rst:192
msgid "Consumer provided an invalid argument"
msgstr ""

#: ../../../networking/tls-handshake.rst:194
msgid "-ENOKEY"
msgstr ""

#: ../../../networking/tls-handshake.rst:194
msgid "Missing authentication material"
msgstr ""

#: ../../../networking/tls-handshake.rst:196
msgid "-EIO"
msgstr ""

#: ../../../networking/tls-handshake.rst:196
msgid "An unexpected fault occurred"
msgstr ""

#: ../../../networking/tls-handshake.rst:199
msgid ""
"The @peerid parameter contains the serial number of a key containing the "
"remote peer's identity or the value TLS_NO_PEERID if the session is not "
"authenticated."
msgstr ""

#: ../../../networking/tls-handshake.rst:203
msgid ""
"A best practice is to close and destroy the socket immediately if the "
"handshake failed."
msgstr ""

#: ../../../networking/tls-handshake.rst:208
msgid "Other considerations"
msgstr ""

#: ../../../networking/tls-handshake.rst:210
msgid ""
"While a handshake is under way, the kernel consumer must alter the socket's "
"sk_data_ready callback function to ignore all incoming data. Once the "
"handshake completion callback function has been invoked, normal receive "
"operation can be resumed."
msgstr ""

#: ../../../networking/tls-handshake.rst:215
msgid ""
"Once a TLS session is established, the consumer must provide a buffer for "
"and then examine the control message (CMSG) that is part of every subsequent "
"sock_recvmsg(). Each control message indicates whether the received message "
"data is TLS record data or session metadata."
msgstr ""

#: ../../../networking/tls-handshake.rst:220
msgid ""
"See tls.rst for details on how a kTLS consumer recognizes incoming "
"(decrypted) application data, alerts, and handshake packets once the socket "
"has been promoted to use the TLS ULP."
msgstr ""
