# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/can_ucan_protocol.rst:3
msgid "The UCAN Protocol"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:5
msgid ""
"UCAN is the protocol used by the microcontroller-based USB-CAN adapter that "
"is integrated on System-on-Modules from Theobroma Systems and that is also "
"available as a standalone USB stick."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:9
msgid ""
"The UCAN protocol has been designed to be hardware-independent. It is "
"modeled closely after how Linux represents CAN devices internally. All multi-"
"byte integers are encoded as Little Endian."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:13
msgid ""
"All structures mentioned in this document are defined in ``drivers/net/can/"
"usb/ucan.c``."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:17
msgid "USB Endpoints"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:19
msgid "UCAN devices use three USB endpoints:"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:21
msgid "CONTROL endpoint"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:22
msgid "The driver sends device management commands on this endpoint"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:24
msgid "IN endpoint"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:25
msgid "The device sends CAN data frames and CAN error frames"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:27
msgid "OUT endpoint"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:28
msgid "The driver sends CAN data frames on the out endpoint"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:32
msgid "CONTROL Messages"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:34
msgid "UCAN devices are configured using vendor requests on the control pipe."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:36
msgid ""
"To support multiple CAN interfaces in a single USB device all configuration "
"commands target the corresponding interface in the USB descriptor."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:40
msgid ""
"The driver uses ``ucan_ctrl_command_in/out`` and ``ucan_device_request_in`` "
"to deliver commands to the device."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:44
msgid "Setup Packet"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:47
msgid "``bmRequestType``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:47
msgid "Direction | Vendor | (Interface or Device)"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:48
msgid "``bRequest``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:48
msgid "Command Number"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:49
msgid "``wValue``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:49
msgid "Subcommand Number (16 Bit) or 0 if not used"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:50
msgid "``wIndex``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:50
msgid "USB Interface Index (0 for device commands)"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:51
msgid "``wLength``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:51
msgid "Host to Device - Number of bytes to transmit"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:52
msgid ""
"Device to Host - Maximum Number of bytes to receive. If the device send "
"less. Common ZLP semantics are used."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:58
msgid "Error Handling"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:60
msgid "The device indicates failed control commands by stalling the pipe."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:64
msgid "Device Commands"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:67
msgid "UCAN_DEVICE_GET_FW_STRING"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:69
msgid "*Dev2Host; optional*"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:71
msgid "Request the device firmware string."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:75
msgid "Interface Commands"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:78
msgid "UCAN_COMMAND_START"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:80
#: ../../../networking/can_ucan_protocol.rst:94
#: ../../../networking/can_ucan_protocol.rst:104
#: ../../../networking/can_ucan_protocol.rst:114
#: ../../../networking/can_ucan_protocol.rst:145
msgid "*Host2Dev; mandatory*"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:82
msgid "Bring the CAN interface up."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:84
#: ../../../networking/can_ucan_protocol.rst:98
#: ../../../networking/can_ucan_protocol.rst:108
#: ../../../networking/can_ucan_protocol.rst:128
#: ../../../networking/can_ucan_protocol.rst:136
#: ../../../networking/can_ucan_protocol.rst:151
msgid "Payload Format"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:85
msgid "``ucan_ctl_payload_t.cmd_start``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:88
msgid "mode"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:88
msgid "or mask of ``UCAN_MODE_*``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:92
msgid "UCAN_COMMAND_STOP"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:96
msgid "Stop the CAN interface"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:99
#: ../../../networking/can_ucan_protocol.rst:109
msgid "*empty*"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:102
msgid "UCAN_COMMAND_RESET"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:106
msgid "Reset the CAN controller (including error counters)"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:112
msgid "UCAN_COMMAND_GET"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:116
msgid "Get Information from the Device"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:119
msgid "Subcommands"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:121
msgid "UCAN_COMMAND_GET_INFO"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:122
msgid ""
"Request the device information structure ``ucan_ctl_payload_t.device_info``."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:124
msgid ""
"See the ``device_info`` field for details, and ``uapi/linux/can/netlink.h`` "
"for an explanation of the ``can_bittiming fields``."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:129
msgid "``ucan_ctl_payload_t.device_info``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:131
msgid "UCAN_COMMAND_GET_PROTOCOL_VERSION"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:133
msgid ""
"Request the device protocol version ``ucan_ctl_payload_t.protocol_version``. "
"The current protocol version is 3."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:137
msgid "``ucan_ctl_payload_t.protocol_version``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:139
msgid ""
"Devices that do not implement this command use the old protocol version 1"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:143
msgid "UCAN_COMMAND_SET_BITTIMING"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:147
msgid ""
"Setup bittiming by sending the structure ``ucan_ctl_payload_t."
"cmd_set_bittiming`` (see ``struct bittiming`` for details)"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:152
msgid "``ucan_ctl_payload_t.cmd_set_bittiming``."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:155
msgid "UCAN_SLEEP/WAKE"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:157
#: ../../../networking/can_ucan_protocol.rst:164
msgid "*Host2Dev; optional*"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:159
msgid "Configure sleep and wake modes. Not yet supported by the driver."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:162
msgid "UCAN_FILTER"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:166
msgid "Setup hardware CAN filters. Not yet supported by the driver."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:169
msgid "Allowed interface commands"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:172
msgid "Legal Device State"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:172
msgid "Command"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:172
msgid "New Device State"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:174
#: ../../../networking/can_ucan_protocol.rst:175
#: ../../../networking/can_ucan_protocol.rst:176
#: ../../../networking/can_ucan_protocol.rst:177
msgid "stopped"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:174
msgid "SET_BITTIMING"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:175
msgid "START"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:175
#: ../../../networking/can_ucan_protocol.rst:176
#: ../../../networking/can_ucan_protocol.rst:178
msgid "started"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:176
#: ../../../networking/can_ucan_protocol.rst:177
msgid "STOP or RESET"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:178
msgid "RESTART"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:179
msgid "any"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:179
msgid "GET"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:179
msgid "*no change*"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:183
msgid "IN Message Format"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:185
msgid ""
"A data packet on the USB IN endpoint contains one or more "
"``ucan_message_in`` values. If multiple messages are batched in a USB data "
"packet, the ``len`` field can be used to jump to the next "
"``ucan_message_in`` value (take care to sanity-check the ``len`` value "
"against the actual data size)."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:194
msgid "``len`` field"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:196
msgid ""
"Each ``ucan_message_in`` must be aligned to a 4-byte boundary (relative to "
"the start of the start of the data buffer). That means that there may be "
"padding bytes between multiple ``ucan_message_in`` values:"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:216
#: ../../../networking/can_ucan_protocol.rst:278
msgid "``type`` field"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:218
msgid "The ``type`` field specifies the type of the message."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:221
msgid "UCAN_IN_RX"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:223
#: ../../../networking/can_ucan_protocol.rst:231
#: ../../../networking/can_ucan_protocol.rst:285
msgid "``subtype``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:224
#: ../../../networking/can_ucan_protocol.rst:232
msgid "zero"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:226
msgid "Data received from the CAN bus (ID + payload)."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:229
msgid "UCAN_IN_TX_COMPLETE"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:234
msgid ""
"The CAN device has sent a message to the CAN bus. It answers with a list of "
"tuples <echo-ids, flags>."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:237
msgid ""
"The echo-id identifies the frame from (echos the id from a previous "
"UCAN_OUT_TX message). The flag indicates the result of the transmission. "
"Whereas a set Bit 0 indicates success. All other bits are reserved and set "
"to zero."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:243
#: ../../../networking/can_ucan_protocol.rst:291
msgid "Flow Control"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:245
msgid ""
"When receiving CAN messages there is no flow control on the USB buffer. The "
"driver has to handle inbound message quickly enough to avoid drops. I case "
"the device buffer overflow the condition is reported by sending "
"corresponding error frames (see :ref:`can_ucan_error_handling`)"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:253
msgid "OUT Message Format"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:255
msgid ""
"A data packet on the USB OUT endpoint contains one or more ``struct "
"ucan_message_out`` values. If multiple messages are batched into one data "
"packet, the device uses the ``len`` field to jump to the next "
"ucan_message_out value. Each ucan_message_out must be aligned to 4 bytes "
"(relative to the start of the data buffer). The mechanism is same as "
"described in :ref:`can_ucan_in_message_len`."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:280
msgid ""
"In protocol version 3 only ``UCAN_OUT_TX`` is defined, others are used only "
"by legacy devices (protocol version 1)."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:284
msgid "UCAN_OUT_TX"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:286
msgid "echo id to be replied within a CAN_IN_TX_COMPLETE message"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:288
msgid "Transmit a CAN frame. (parameters: ``id``, ``data``)"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:293
msgid ""
"When the device outbound buffers are full it starts sending *NAKs* on the "
"*OUT* pipe until more buffers are available. The driver stops the queue when "
"a certain threshold of out packets are incomplete."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:300
msgid "CAN Error Handling"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:302
msgid ""
"If error reporting is turned on the device encodes errors into CAN error "
"frames (see ``uapi/linux/can/error.h``) and sends it using the IN endpoint. "
"The driver updates its error statistics and forwards it."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:307
msgid ""
"Although UCAN devices can suppress error frames completely, in Linux the "
"driver is always interested. Hence, the device is always started with the "
"``UCAN_MODE_BERR_REPORT`` set. Filtering those messages for the user space "
"is done by the driver."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:313
msgid "Bus OFF"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:315
msgid "The device does not recover from bus of automatically."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:316
msgid "Bus OFF is indicated by an error frame (see ``uapi/linux/can/error.h``)"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:317
msgid "Bus OFF recovery is started by ``UCAN_COMMAND_RESTART``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:318
msgid ""
"Once Bus OFF recover is completed the device sends an error frame indicating "
"that it is on ERROR-ACTIVE state."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:320
msgid "During Bus OFF no frames are sent by the device."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:321
msgid ""
"During Bus OFF transmission requests from the host are completed immediately "
"with the success bit left unset."
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:325
msgid "Example Conversation"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:327
msgid "Device is connected to USB"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:328
msgid "Host sends command ``UCAN_COMMAND_RESET``, subcmd 0"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:329
msgid ""
"Host sends command ``UCAN_COMMAND_GET``, subcmd ``UCAN_COMMAND_GET_INFO``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:330
msgid "Device sends ``UCAN_IN_DEVICE_INFO``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:331
msgid "Host sends command ``UCAN_OUT_SET_BITTIMING``"
msgstr ""

#: ../../../networking/can_ucan_protocol.rst:332
msgid ""
"Host sends command ``UCAN_COMMAND_START``, subcmd 0, mode "
"``UCAN_MODE_BERR_REPORT``"
msgstr ""
