# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/tuntap.rst:6
msgid "Universal TUN/TAP device driver"
msgstr ""

#: ../../../networking/tuntap.rst:8
msgid "Copyright |copy| 1999-2000 Maxim Krasnyansky <max_mk@yahoo.com>"
msgstr ""

#: ../../../networking/tuntap.rst:10
msgid ""
"Linux, Solaris drivers Copyright |copy| 1999-2000 Maxim Krasnyansky "
"<max_mk@yahoo.com>"
msgstr ""

#: ../../../networking/tuntap.rst:13
msgid ""
"FreeBSD TAP driver Copyright |copy| 1999-2000 Maksim Yevmenkin "
"<m_evmenkin@yahoo.com>"
msgstr ""

#: ../../../networking/tuntap.rst:16
msgid "Revision of this document 2002 by Florian Thiel <florian.thiel@gmx.net>"
msgstr ""

#: ../../../networking/tuntap.rst:19
msgid "1. Description"
msgstr ""

#: ../../../networking/tuntap.rst:21
msgid ""
"TUN/TAP provides packet reception and transmission for user space programs. "
"It can be seen as a simple Point-to-Point or Ethernet device, which, instead "
"of receiving packets from physical media, receives them from user space "
"program and instead of sending packets via physical media writes them to the "
"user space program."
msgstr ""

#: ../../../networking/tuntap.rst:27
msgid ""
"In order to use the driver a program has to open /dev/net/tun and issue a "
"corresponding ioctl() to register a network device with the kernel. A "
"network device will appear as tunXX or tapXX, depending on the options "
"chosen. When the program closes the file descriptor, the network device and "
"all corresponding routes will disappear."
msgstr ""

#: ../../../networking/tuntap.rst:33
msgid ""
"Depending on the type of device chosen the userspace program has to read/"
"write IP packets (with tun) or ethernet frames (with tap). Which one is "
"being used depends on the flags given with the ioctl()."
msgstr ""

#: ../../../networking/tuntap.rst:37
msgid ""
"The package from http://vtun.sourceforge.net/tun contains two simple "
"examples for how to use tun and tap devices. Both programs work like a "
"bridge between two network interfaces. br_select.c - bridge based on select "
"system call. br_sigio.c  - bridge based on async io and SIGIO signal. "
"However, the best example is VTun http://vtun.sourceforge.net :))"
msgstr ""

#: ../../../networking/tuntap.rst:45
msgid "2. Configuration"
msgstr ""

#: ../../../networking/tuntap.rst:47
msgid "Create device node::"
msgstr ""

#: ../../../networking/tuntap.rst:52
msgid "Set permissions::"
msgstr ""

#: ../../../networking/tuntap.rst:56
msgid ""
"There's no harm in allowing the device to be accessible by non-root users, "
"since CAP_NET_ADMIN is required for creating network devices or for "
"connecting to network devices which aren't owned by the user in question. If "
"you want to create persistent devices and give ownership of them to "
"unprivileged users, then you need the /dev/net/tun device to be usable by "
"those users."
msgstr ""

#: ../../../networking/tuntap.rst:63
msgid "Driver module autoloading"
msgstr ""

#: ../../../networking/tuntap.rst:65
msgid ""
"Make sure that \"Kernel module loader\" - module auto-loading support is "
"enabled in your kernel.  The kernel should load it on first access."
msgstr ""

#: ../../../networking/tuntap.rst:69
msgid "Manual loading"
msgstr ""

#: ../../../networking/tuntap.rst:71
msgid "insert the module by hand::"
msgstr ""

#: ../../../networking/tuntap.rst:75
msgid ""
"If you do it the latter way, you have to load the module every time you need "
"it, if you do it the other way it will be automatically loaded when /dev/net/"
"tun is being opened."
msgstr ""

#: ../../../networking/tuntap.rst:80
msgid "3. Program interface"
msgstr ""

#: ../../../networking/tuntap.rst:83
msgid "3.1 Network device allocation"
msgstr ""

#: ../../../networking/tuntap.rst:85
msgid ""
"``char *dev`` should be the name of the device with a format string (e.g. "
"\"tun%d\"), but (as far as I can see) this can be any valid network device "
"name. Note that the character pointer becomes overwritten with the real "
"device name (e.g. \"tun0\")::"
msgstr ""

#: ../../../networking/tuntap.rst:121
msgid "3.2 Frame format"
msgstr ""

#: ../../../networking/tuntap.rst:123
msgid "If flag IFF_NO_PI is not set each frame format is::"
msgstr ""

#: ../../../networking/tuntap.rst:130
msgid "3.3 Multiqueue tuntap interface"
msgstr ""

#: ../../../networking/tuntap.rst:132
msgid ""
"From version 3.8, Linux supports multiqueue tuntap which can uses multiple "
"file descriptors (queues) to parallelize packets sending or receiving. The "
"device allocation is the same as before, and if user wants to create "
"multiple queues, TUNSETIFF with the same device name must be called many "
"times with IFF_MULTI_QUEUE flag."
msgstr ""

#: ../../../networking/tuntap.rst:138
msgid ""
"``char *dev`` should be the name of the device, queues is the number of "
"queues to be created, fds is used to store and return the file descriptors "
"(queues) created to the caller. Each file descriptor were served as the "
"interface of a queue which could be accessed by userspace."
msgstr ""

#: ../../../networking/tuntap.rst:184
msgid ""
"A new ioctl(TUNSETQUEUE) were introduced to enable or disable a queue. When "
"calling it with IFF_DETACH_QUEUE flag, the queue were disabled. And when "
"calling it with IFF_ATTACH_QUEUE flag, the queue were enabled. The queue "
"were enabled by default after it was created through TUNSETIFF."
msgstr ""

#: ../../../networking/tuntap.rst:189
msgid ""
"fd is the file descriptor (queue) that we want to enable or disable, when "
"enable is true we enable it, otherwise we disable it::"
msgstr ""

#: ../../../networking/tuntap.rst:210
msgid "Universal TUN/TAP device driver Frequently Asked Question"
msgstr ""

#: ../../../networking/tuntap.rst:212
msgid "What platforms are supported by TUN/TAP driver ?"
msgstr ""

#: ../../../networking/tuntap.rst:214
msgid "Currently driver has been written for 3 Unices:"
msgstr ""

#: ../../../networking/tuntap.rst:216
msgid "Linux kernels 2.2.x, 2.4.x"
msgstr ""

#: ../../../networking/tuntap.rst:217
msgid "FreeBSD 3.x, 4.x, 5.x"
msgstr ""

#: ../../../networking/tuntap.rst:218
msgid "Solaris 2.6, 7.0, 8.0"
msgstr ""

#: ../../../networking/tuntap.rst:220
msgid "What is TUN/TAP driver used for?"
msgstr ""

#: ../../../networking/tuntap.rst:222
msgid ""
"As mentioned above, main purpose of TUN/TAP driver is tunneling. It is used "
"by VTun (http://vtun.sourceforge.net)."
msgstr ""

#: ../../../networking/tuntap.rst:225
msgid ""
"Another interesting application using TUN/TAP is pipsecd (http://perso.enst."
"fr/~beyssac/pipsec/), a userspace IPSec implementation that can use complete "
"kernel routing (unlike FreeS/WAN)."
msgstr ""

#: ../../../networking/tuntap.rst:229
msgid "How does Virtual network device actually work ?"
msgstr ""

#: ../../../networking/tuntap.rst:231
msgid ""
"Virtual network device can be viewed as a simple Point-to-Point or Ethernet "
"device, which instead of receiving packets from a physical media, receives "
"them from user space program and instead of sending packets via physical "
"media sends them to the user space program."
msgstr ""

#: ../../../networking/tuntap.rst:236
msgid ""
"Let's say that you configured IPv6 on the tap0, then whenever the kernel "
"sends an IPv6 packet to tap0, it is passed to the application (VTun for "
"example). The application encrypts, compresses and sends it to the other "
"side over TCP or UDP. The application on the other side decompresses and "
"decrypts the data received and writes the packet to the TAP device, the "
"kernel handles the packet like it came from real physical device."
msgstr ""

#: ../../../networking/tuntap.rst:243
msgid "What is the difference between TUN driver and TAP driver?"
msgstr ""

#: ../../../networking/tuntap.rst:245
msgid "TUN works with IP frames. TAP works with Ethernet frames."
msgstr ""

#: ../../../networking/tuntap.rst:247
msgid ""
"This means that you have to read/write IP packets when you are using tun and "
"ethernet frames when using tap."
msgstr ""

#: ../../../networking/tuntap.rst:250
msgid "What is the difference between BPF and TUN/TAP driver?"
msgstr ""

#: ../../../networking/tuntap.rst:252
msgid ""
"BPF is an advanced packet filter. It can be attached to existing network "
"interface. It does not provide a virtual network interface. A TUN/TAP driver "
"does provide a virtual network interface and it is possible to attach BPF to "
"this interface."
msgstr ""

#: ../../../networking/tuntap.rst:257
msgid "Does TAP driver support kernel Ethernet bridging?"
msgstr ""

#: ../../../networking/tuntap.rst:259
msgid "Yes. Linux and FreeBSD drivers support Ethernet bridging."
msgstr ""
