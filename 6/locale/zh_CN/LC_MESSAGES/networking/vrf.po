# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/vrf.rst:5
msgid "Virtual Routing and Forwarding (VRF)"
msgstr ""

#: ../../../networking/vrf.rst:8
msgid "The VRF Device"
msgstr ""

#: ../../../networking/vrf.rst:10
msgid ""
"The VRF device combined with ip rules provides the ability to create virtual "
"routing and forwarding domains (aka VRFs, VRF-lite to be specific) in the "
"Linux network stack. One use case is the multi-tenancy problem where each "
"tenant has their own unique routing tables and in the very least need "
"different default gateways."
msgstr ""

#: ../../../networking/vrf.rst:16
msgid ""
"Processes can be \"VRF aware\" by binding a socket to the VRF device. "
"Packets through the socket then use the routing table associated with the "
"VRF device. An important feature of the VRF device implementation is that it "
"impacts only Layer 3 and above so L2 tools (e.g., LLDP) are not affected "
"(ie., they do not need to be run in each VRF). The design also allows the "
"use of higher priority ip rules (Policy Based Routing, PBR) to take "
"precedence over the VRF device rules directing specific traffic as desired."
msgstr ""

#: ../../../networking/vrf.rst:24
msgid ""
"In addition, VRF devices allow VRFs to be nested within namespaces. For "
"example network namespaces provide separation of network interfaces at the "
"device layer, VLANs on the interfaces within a namespace provide L2 "
"separation and then VRF devices provide L3 separation."
msgstr ""

#: ../../../networking/vrf.rst:30
msgid "Design"
msgstr ""

#: ../../../networking/vrf.rst:31
msgid ""
"A VRF device is created with an associated route table. Network interfaces "
"are then enslaved to a VRF device::"
msgstr ""

#: ../../../networking/vrf.rst:46
msgid ""
"Packets received on an enslaved device and are switched to the VRF device in "
"the IPv4 and IPv6 processing stacks giving the impression that packets flow "
"through the VRF device. Similarly on egress routing rules are used to send "
"packets to the VRF device driver before getting sent out the actual "
"interface. This allows tcpdump on a VRF device to capture all packets into "
"and out of the VRF as a whole\\ [1]_. Similarly, netfilter\\ [2]_ and tc "
"rules can be applied using the VRF device to specify rules that apply to the "
"VRF domain as a whole."
msgstr ""

#: ../../../networking/vrf.rst:55
msgid ""
"Packets in the forwarded state do not flow through the device, so those "
"packets are not seen by tcpdump. Will revisit this limitation in a future "
"release."
msgstr ""

#: ../../../networking/vrf.rst:59
msgid ""
"Iptables on ingress supports PREROUTING with skb->dev set to the real "
"ingress device and both INPUT and PREROUTING rules with skb->dev set to the "
"VRF device. For egress POSTROUTING and OUTPUT rules can be written using "
"either the VRF device or real egress device."
msgstr ""

#: ../../../networking/vrf.rst:65
msgid "Setup"
msgstr ""

#: ../../../networking/vrf.rst:66
msgid "VRF device is created with an association to a FIB table. e.g,::"
msgstr ""

#: ../../../networking/vrf.rst:72
msgid ""
"An l3mdev FIB rule directs lookups to the table associated with the device. "
"A single l3mdev rule is sufficient for all VRFs. The VRF device adds the "
"l3mdev rule for IPv4 and IPv6 when the first device is created with a "
"default preference of 1000. Users may delete the rule if desired and add "
"with a different priority or install per-VRF rules."
msgstr ""

#: ../../../networking/vrf.rst:78
msgid ""
"Prior to the v4.8 kernel iif and oif rules are needed for each VRF device::"
msgstr ""

#: ../../../networking/vrf.rst:83
msgid ""
"Set the default route for the table (and hence default route for the VRF)::"
msgstr ""

#: ../../../networking/vrf.rst:87
msgid ""
"This high metric value ensures that the default unreachable route can be "
"overridden by a routing protocol suite.  FRRouting interprets kernel metrics "
"as a combined admin distance (upper byte) and priority (lower 3 bytes).  "
"Thus the above metric translates to [255/8192]."
msgstr ""

#: ../../../networking/vrf.rst:92
msgid "Enslave L3 interfaces to a VRF device::"
msgstr ""

#: ../../../networking/vrf.rst:96
msgid ""
"Local and connected routes for enslaved devices are automatically moved to "
"the table associated with VRF device. Any additional routes depending on the "
"enslaved device are dropped and will need to be reinserted to the VRF FIB "
"table following the enslavement."
msgstr ""

#: ../../../networking/vrf.rst:101
msgid ""
"The IPv6 sysctl option keep_addr_on_down can be enabled to keep IPv6 global "
"addresses as VRF enslavement changes::"
msgstr ""

#: ../../../networking/vrf.rst:106
msgid "Additional VRF routes are added to associated table::"
msgstr ""

#: ../../../networking/vrf.rst:112
msgid "Applications"
msgstr ""

#: ../../../networking/vrf.rst:113
msgid ""
"Applications that are to work within a VRF need to bind their socket to the "
"VRF device::"
msgstr ""

#: ../../../networking/vrf.rst:118
msgid "or to specify the output device using cmsg and IP_PKTINFO."
msgstr ""

#: ../../../networking/vrf.rst:120
msgid ""
"By default the scope of the port bindings for unbound sockets is limited to "
"the default VRF. That is, it will not be matched by packets arriving on "
"interfaces enslaved to an l3mdev and processes may bind to the same port if "
"they bind to an l3mdev."
msgstr ""

#: ../../../networking/vrf.rst:125
msgid ""
"TCP & UDP services running in the default VRF context (ie., not bound to any "
"VRF device) can work across all VRF domains by enabling the "
"tcp_l3mdev_accept and udp_l3mdev_accept sysctl options::"
msgstr ""

#: ../../../networking/vrf.rst:132
msgid ""
"These options are disabled by default so that a socket in a VRF is only "
"selected for packets in that VRF. There is a similar option for RAW sockets, "
"which is enabled by default for reasons of backwards compatibility. This is "
"so as to specify the output device with cmsg and IP_PKTINFO, but using a "
"socket not bound to the corresponding VRF. This allows e.g. older ping "
"implementations to be run with specifying the device but without executing "
"it in the VRF. This option can be disabled so that packets received in a VRF "
"context are only handled by a raw socket bound to the VRF, and packets in "
"the default VRF are only handled by a socket not bound to any VRF::"
msgstr ""

#: ../../../networking/vrf.rst:144
msgid ""
"netfilter rules on the VRF device can be used to limit access to services "
"running in the default VRF context as well."
msgstr ""

#: ../../../networking/vrf.rst:147
msgid ""
"Using VRF-aware applications (applications which simultaneously create "
"sockets outside and inside VRFs) in conjunction with ``net.ipv4."
"tcp_l3mdev_accept=1`` is possible but may lead to problems in some "
"situations. With that sysctl value, it is unspecified which listening socket "
"will be selected to handle connections for VRF traffic; ie. either a socket "
"bound to the VRF or an unbound socket may be used to accept new connections "
"from a VRF. This somewhat unexpected behavior can lead to problems if "
"sockets are configured with extra options (ex. TCP MD5 keys) with the "
"expectation that VRF traffic will exclusively be handled by sockets bound to "
"VRFs, as would be the case with ``net.ipv4.tcp_l3mdev_accept=0``. Finally "
"and as a reminder, regardless of which listening socket is selected, "
"established sockets will be created in the VRF based on the ingress "
"interface, as documented earlier."
msgstr ""

#: ../../../networking/vrf.rst:163
msgid "Using iproute2 for VRFs"
msgstr ""

#: ../../../networking/vrf.rst:164
msgid ""
"iproute2 supports the vrf keyword as of v4.7. For backwards compatibility "
"this section lists both commands where appropriate -- with the vrf keyword "
"and the older form without it."
msgstr ""

#: ../../../networking/vrf.rst:168
msgid "Create a VRF"
msgstr ""

#: ../../../networking/vrf.rst:170
msgid "To instantiate a VRF device and associate it with a table::"
msgstr ""

#: ../../../networking/vrf.rst:174
msgid ""
"As of v4.8 the kernel supports the l3mdev FIB rule where a single rule "
"covers all VRFs. The l3mdev rule is created for IPv4 and IPv6 on first "
"device create."
msgstr ""

#: ../../../networking/vrf.rst:178
msgid "List VRFs"
msgstr ""

#: ../../../networking/vrf.rst:180
msgid "To list VRFs that have been created::"
msgstr ""

#: ../../../networking/vrf.rst:185 ../../../networking/vrf.rst:221
#: ../../../networking/vrf.rst:234 ../../../networking/vrf.rst:261
#: ../../../networking/vrf.rst:279 ../../../networking/vrf.rst:317
#: ../../../networking/vrf.rst:355 ../../../networking/vrf.rst:375
msgid "For example::"
msgstr ""

#: ../../../networking/vrf.rst:202
msgid "Or in brief output::"
msgstr ""

#: ../../../networking/vrf.rst:211
msgid "Assign a Network Interface to a VRF"
msgstr ""

#: ../../../networking/vrf.rst:213
msgid ""
"Network interfaces are assigned to a VRF by enslaving the netdevice to a VRF "
"device::"
msgstr ""

#: ../../../networking/vrf.rst:218
msgid ""
"On enslavement connected and local routes are automatically moved to the "
"table associated with the VRF device."
msgstr ""

#: ../../../networking/vrf.rst:226
msgid "Show Devices Assigned to a VRF"
msgstr ""

#: ../../../networking/vrf.rst:228
msgid ""
"To show devices that have been assigned to a specific VRF add the master "
"option to the ip command::"
msgstr ""

#: ../../../networking/vrf.rst:245
msgid "Or using the brief output::"
msgstr ""

#: ../../../networking/vrf.rst:253
msgid "Show Neighbor Entries for a VRF"
msgstr ""

#: ../../../networking/vrf.rst:255
msgid ""
"To list neighbor entries associated with devices enslaved to a VRF device "
"add the master option to the ip command::"
msgstr ""

#: ../../../networking/vrf.rst:271
msgid "Show Addresses for a VRF"
msgstr ""

#: ../../../networking/vrf.rst:273
msgid ""
"To show addresses for interfaces associated with a VRF add the master option "
"to the ip command::"
msgstr ""

#: ../../../networking/vrf.rst:301
msgid "Or in brief format::"
msgstr ""

#: ../../../networking/vrf.rst:309
msgid "Show Routes for a VRF"
msgstr ""

#: ../../../networking/vrf.rst:311
msgid ""
"To show routes for a VRF use the ip command to display the table associated "
"with the VRF device::"
msgstr ""

#: ../../../networking/vrf.rst:348
msgid "Route Lookup for a VRF"
msgstr ""

#: ../../../networking/vrf.rst:350
msgid "A test route lookup can be done for a VRF::"
msgstr ""

#: ../../../networking/vrf.rst:365
msgid "Removing Network Interface from a VRF"
msgstr ""

#: ../../../networking/vrf.rst:367
msgid ""
"Network interfaces are removed from a VRF by breaking the enslavement to the "
"VRF device::"
msgstr ""

#: ../../../networking/vrf.rst:372
msgid ""
"Connected routes are moved back to the default table and local entries are "
"moved to the local table."
msgstr ""

#: ../../../networking/vrf.rst:381
msgid "Commands used in this example::"
msgstr ""
