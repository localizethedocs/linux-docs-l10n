# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/operstates.rst:5
msgid "Operational States"
msgstr ""

#: ../../../networking/operstates.rst:9
msgid "1. Introduction"
msgstr ""

#: ../../../networking/operstates.rst:11
msgid ""
"Linux distinguishes between administrative and operational state of an "
"interface. Administrative state is the result of \"ip link set dev <dev> up "
"or down\" and reflects whether the administrator wants to use the device for "
"traffic."
msgstr ""

#: ../../../networking/operstates.rst:16
msgid ""
"However, an interface is not usable just because the admin enabled it - "
"ethernet requires to be plugged into the switch and, depending on a site's "
"networking policy and configuration, an 802.1X authentication to be "
"performed before user data can be transferred. Operational state shows the "
"ability of an interface to transmit this user data."
msgstr ""

#: ../../../networking/operstates.rst:22
msgid ""
"Thanks to 802.1X, userspace must be granted the possibility to influence "
"operational state. To accommodate this, operational state is split into two "
"parts: Two flags that can be set by the driver only, and a RFC2863 "
"compatible state that is derived from these flags, a policy, and changeable "
"from userspace under certain rules."
msgstr ""

#: ../../../networking/operstates.rst:30
msgid "2. Querying from userspace"
msgstr ""

#: ../../../networking/operstates.rst:32
msgid ""
"Both admin and operational state can be queried via the netlink operation "
"RTM_GETLINK. It is also possible to subscribe to RTNLGRP_LINK to be notified "
"of updates while the interface is admin up. This is important for setting "
"from userspace."
msgstr ""

#: ../../../networking/operstates.rst:37
msgid "These values contain interface state:"
msgstr ""

#: ../../../networking/operstates.rst:39
msgid "ifinfomsg::if_flags & IFF_UP:"
msgstr ""

#: ../../../networking/operstates.rst:40
msgid "Interface is admin up"
msgstr ""

#: ../../../networking/operstates.rst:42
msgid "ifinfomsg::if_flags & IFF_RUNNING:"
msgstr ""

#: ../../../networking/operstates.rst:43
msgid ""
"Interface is in RFC2863 operational state UP or UNKNOWN. This is for "
"backward compatibility, routing daemons, dhcp clients can use this flag to "
"determine whether they should use the interface."
msgstr ""

#: ../../../networking/operstates.rst:47
msgid "ifinfomsg::if_flags & IFF_LOWER_UP:"
msgstr ""

#: ../../../networking/operstates.rst:48
msgid "Driver has signaled netif_carrier_on()"
msgstr ""

#: ../../../networking/operstates.rst:50
msgid "ifinfomsg::if_flags & IFF_DORMANT:"
msgstr ""

#: ../../../networking/operstates.rst:51
msgid "Driver has signaled netif_dormant_on()"
msgstr ""

#: ../../../networking/operstates.rst:54
msgid "TLV IFLA_OPERSTATE"
msgstr ""

#: ../../../networking/operstates.rst:56
msgid "contains RFC2863 state of the interface in numeric representation:"
msgstr ""

#: ../../../networking/operstates.rst:58
msgid "IF_OPER_UNKNOWN (0):"
msgstr ""

#: ../../../networking/operstates.rst:59
msgid ""
"Interface is in unknown state, neither driver nor userspace has set "
"operational state. Interface must be considered for user data as setting "
"operational state has not been implemented in every driver."
msgstr ""

#: ../../../networking/operstates.rst:63
msgid "IF_OPER_NOTPRESENT (1):"
msgstr ""

#: ../../../networking/operstates.rst:64
msgid ""
"Unused in current kernel (notpresent interfaces normally disappear), just a "
"numerical placeholder."
msgstr ""

#: ../../../networking/operstates.rst:67
msgid "IF_OPER_DOWN (2):"
msgstr ""

#: ../../../networking/operstates.rst:68
msgid ""
"Interface is unable to transfer data on L1, f.e. ethernet is not plugged or "
"interface is ADMIN down."
msgstr ""

#: ../../../networking/operstates.rst:71
msgid "IF_OPER_LOWERLAYERDOWN (3):"
msgstr ""

#: ../../../networking/operstates.rst:72
msgid ""
"Interfaces stacked on an interface that is IF_OPER_DOWN show this state (f."
"e. VLAN)."
msgstr ""

#: ../../../networking/operstates.rst:75
msgid "IF_OPER_TESTING (4):"
msgstr ""

#: ../../../networking/operstates.rst:76
msgid ""
"Interface is in testing mode, for example executing driver self-tests or "
"media (cable) test. It can't be used for normal traffic until tests complete."
msgstr ""

#: ../../../networking/operstates.rst:80
msgid "IF_OPER_DORMANT (5):"
msgstr ""

#: ../../../networking/operstates.rst:81
msgid ""
"Interface is L1 up, but waiting for an external event, f.e. for a protocol "
"to establish. (802.1X)"
msgstr ""

#: ../../../networking/operstates.rst:84
msgid "IF_OPER_UP (6):"
msgstr ""

#: ../../../networking/operstates.rst:85
msgid "Interface is operational up and can be used."
msgstr ""

#: ../../../networking/operstates.rst:87 ../../../networking/operstates.rst:95
msgid "This TLV can also be queried via sysfs."
msgstr ""

#: ../../../networking/operstates.rst:90
msgid "TLV IFLA_LINKMODE"
msgstr ""

#: ../../../networking/operstates.rst:92
msgid ""
"contains link policy. This is needed for userspace interaction described "
"below."
msgstr ""

#: ../../../networking/operstates.rst:99
msgid "3. Kernel driver API"
msgstr ""

#: ../../../networking/operstates.rst:101
msgid ""
"Kernel drivers have access to two flags that map to IFF_LOWER_UP and "
"IFF_DORMANT. These flags can be set from everywhere, even from interrupts. "
"It is guaranteed that only the driver has write access, however, if "
"different layers of the driver manipulate the same flag, the driver has to "
"provide the synchronisation needed."
msgstr ""

#: ../../../networking/operstates.rst:107
msgid "__LINK_STATE_NOCARRIER, maps to !IFF_LOWER_UP:"
msgstr ""

#: ../../../networking/operstates.rst:109
msgid ""
"The driver uses netif_carrier_on() to clear and netif_carrier_off() to set "
"this flag. On netif_carrier_off(), the scheduler stops sending packets. The "
"name 'carrier' and the inversion are historical, think of it as lower layer."
msgstr ""

#: ../../../networking/operstates.rst:114
msgid ""
"Note that for certain kind of soft-devices, which are not managing any real "
"hardware, it is possible to set this bit from userspace.  One should use TLV "
"IFLA_CARRIER to do so."
msgstr ""

#: ../../../networking/operstates.rst:118
msgid "netif_carrier_ok() can be used to query that bit."
msgstr ""

#: ../../../networking/operstates.rst:120
msgid "__LINK_STATE_DORMANT, maps to IFF_DORMANT:"
msgstr ""

#: ../../../networking/operstates.rst:122
msgid ""
"Set by the driver to express that the device cannot yet be used because some "
"driver controlled protocol establishment has to complete. Corresponding "
"functions are netif_dormant_on() to set the flag, netif_dormant_off() to "
"clear it and netif_dormant() to query."
msgstr ""

#: ../../../networking/operstates.rst:127
msgid ""
"On device allocation, both flags __LINK_STATE_NOCARRIER and "
"__LINK_STATE_DORMANT are cleared, so the effective state is equivalent to "
"netif_carrier_ok() and !netif_dormant()."
msgstr ""

#: ../../../networking/operstates.rst:132
msgid ""
"Whenever the driver CHANGES one of these flags, a workqueue event is "
"scheduled to translate the flag combination to IFLA_OPERSTATE as follows:"
msgstr ""

#: ../../../networking/operstates.rst:136
msgid "!netif_carrier_ok():"
msgstr ""

#: ../../../networking/operstates.rst:137
msgid ""
"IF_OPER_LOWERLAYERDOWN if the interface is stacked, IF_OPER_DOWN otherwise. "
"Kernel can recognise stacked interfaces because their ifindex != iflink."
msgstr ""

#: ../../../networking/operstates.rst:141
msgid "netif_carrier_ok() && netif_dormant():"
msgstr ""

#: ../../../networking/operstates.rst:142
msgid "IF_OPER_DORMANT"
msgstr ""

#: ../../../networking/operstates.rst:144
msgid "netif_carrier_ok() && !netif_dormant():"
msgstr ""

#: ../../../networking/operstates.rst:145
msgid ""
"IF_OPER_UP if userspace interaction is disabled. Otherwise IF_OPER_DORMANT "
"with the possibility for userspace to initiate the IF_OPER_UP transition "
"afterwards."
msgstr ""

#: ../../../networking/operstates.rst:151
msgid "4. Setting from userspace"
msgstr ""

#: ../../../networking/operstates.rst:153
msgid ""
"Applications have to use the netlink interface to influence the RFC2863 "
"operational state of an interface. Setting IFLA_LINKMODE to 1 via "
"RTM_SETLINK instructs the kernel that an interface should go to "
"IF_OPER_DORMANT instead of IF_OPER_UP when the combination "
"netif_carrier_ok() && !netif_dormant() is set by the driver. Afterwards, the "
"userspace application can set IFLA_OPERSTATE to IF_OPER_DORMANT or "
"IF_OPER_UP as long as the driver does not set netif_carrier_off() or "
"netif_dormant_on(). Changes made by userspace are multicasted on the netlink "
"group RTNLGRP_LINK."
msgstr ""

#: ../../../networking/operstates.rst:163
msgid "So basically a 802.1X supplicant interacts with the kernel like this:"
msgstr ""

#: ../../../networking/operstates.rst:165
msgid "subscribe to RTNLGRP_LINK"
msgstr ""

#: ../../../networking/operstates.rst:166
msgid "set IFLA_LINKMODE to 1 via RTM_SETLINK"
msgstr ""

#: ../../../networking/operstates.rst:167
msgid "query RTM_GETLINK once to get initial state"
msgstr ""

#: ../../../networking/operstates.rst:168
msgid ""
"if initial flags are not (IFF_LOWER_UP && !IFF_DORMANT), wait until netlink "
"multicast signals this state"
msgstr ""

#: ../../../networking/operstates.rst:170
msgid "do 802.1X, eventually abort if flags go down again"
msgstr ""

#: ../../../networking/operstates.rst:171
msgid ""
"send RTM_SETLINK to set operstate to IF_OPER_UP if authentication succeeds, "
"IF_OPER_DORMANT otherwise"
msgstr ""

#: ../../../networking/operstates.rst:173
msgid "see how operstate and IFF_RUNNING is echoed via netlink multicast"
msgstr ""

#: ../../../networking/operstates.rst:174
msgid "set interface back to IF_OPER_DORMANT if 802.1X reauthentication fails"
msgstr ""

#: ../../../networking/operstates.rst:176
msgid "restart if kernel changes IFF_LOWER_UP or IFF_DORMANT flag"
msgstr ""

#: ../../../networking/operstates.rst:178
msgid ""
"if supplicant goes down, bring back IFLA_LINKMODE to 0 and IFLA_OPERSTATE to "
"a sane value."
msgstr ""

#: ../../../networking/operstates.rst:181
msgid ""
"A routing daemon or dhcp client just needs to care for IFF_RUNNING or "
"waiting for operstate to go IF_OPER_UP/IF_OPER_UNKNOWN before considering "
"the interface / querying a DHCP address."
msgstr ""

#: ../../../networking/operstates.rst:186
msgid ""
"For technical questions and/or comments please e-mail to Stefan Rompf "
"(stefan at loplof.de)."
msgstr ""
