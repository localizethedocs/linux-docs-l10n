# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/radiotap-headers.rst:5
msgid "How to use radiotap headers"
msgstr ""

#: ../../../networking/radiotap-headers.rst:8
msgid "Pointer to the radiotap include file"
msgstr ""

#: ../../../networking/radiotap-headers.rst:10
msgid ""
"Radiotap headers are variable-length and extensible, you can get most of the "
"information you need to know on them from::"
msgstr ""

#: ../../../networking/radiotap-headers.rst:15
msgid "This document gives an overview and warns on some corner cases."
msgstr ""

#: ../../../networking/radiotap-headers.rst:19
msgid "Structure of the header"
msgstr ""

#: ../../../networking/radiotap-headers.rst:21
msgid ""
"There is a fixed portion at the start which contains a u32 bitmap that "
"defines if the possible argument associated with that bit is present or "
"not.  So if b0 of the it_present member of ieee80211_radiotap_header is set, "
"it means that the header for argument index 0 (IEEE80211_RADIOTAP_TSFT) is "
"present in the argument area."
msgstr ""

#: ../../../networking/radiotap-headers.rst:33
msgid ""
"At the moment there are only 13 possible argument indexes defined, but in "
"case we run out of space in the u32 it_present member, it is defined that "
"b31 set indicates that there is another u32 bitmap following (shown as "
"\"possible argument bitmap extensions...\" above), and the start of the "
"arguments is moved forward 4 bytes each time."
msgstr ""

#: ../../../networking/radiotap-headers.rst:39
msgid ""
"Note also that the it_len member __le16 is set to the total number of bytes "
"covered by the ieee80211_radiotap_header and any arguments following."
msgstr ""

#: ../../../networking/radiotap-headers.rst:44
msgid "Requirements for arguments"
msgstr ""

#: ../../../networking/radiotap-headers.rst:46
msgid ""
"After the fixed part of the header, the arguments follow for each argument "
"index whose matching bit is set in the it_present member of "
"ieee80211_radiotap_header."
msgstr ""

#: ../../../networking/radiotap-headers.rst:50
msgid "the arguments are all stored little-endian!"
msgstr ""

#: ../../../networking/radiotap-headers.rst:52
msgid ""
"the argument payload for a given argument index has a fixed size.  So "
"IEEE80211_RADIOTAP_TSFT being present always indicates an 8-byte argument is "
"present.  See the comments in ./include/net/ieee80211_radiotap.h for a nice "
"breakdown of all the argument sizes"
msgstr ""

#: ../../../networking/radiotap-headers.rst:57
msgid ""
"the arguments must be aligned to a boundary of the argument size using "
"padding.  So a u16 argument must start on the next u16 boundary if it isn't "
"already on one, a u32 must start on the next u32 boundary and so on."
msgstr ""

#: ../../../networking/radiotap-headers.rst:61
msgid ""
"\"alignment\" is relative to the start of the ieee80211_radiotap_header, ie, "
"the first byte of the radiotap header.  The absolute alignment of that first "
"byte isn't defined.  So even if the whole radiotap header is starting at, "
"eg, address 0x00000003, still the first byte of the radiotap header is "
"treated as 0 for alignment purposes."
msgstr ""

#: ../../../networking/radiotap-headers.rst:67
msgid ""
"the above point that there may be no absolute alignment for multibyte "
"entities in the fixed radiotap header or the argument region means that you "
"have to take special evasive action when trying to access these multibyte "
"entities.  Some arches like Blackfin cannot deal with an attempt to "
"dereference, eg, a u16 pointer that is pointing to an odd address.  Instead "
"you have to use a kernel API get_unaligned() to dereference the pointer, "
"which will do it bytewise on the arches that require that."
msgstr ""

#: ../../../networking/radiotap-headers.rst:75
msgid ""
"The arguments for a given argument index can be a compound of multiple types "
"together.  For example IEEE80211_RADIOTAP_CHANNEL has an argument payload "
"consisting of two u16s of total length 4.  When this happens, the padding "
"rule is applied dealing with a u16, NOT dealing with a 4-byte single entity."
msgstr ""

#: ../../../networking/radiotap-headers.rst:82
msgid "Example valid radiotap header"
msgstr ""

#: ../../../networking/radiotap-headers.rst:95
msgid "Using the Radiotap Parser"
msgstr ""

#: ../../../networking/radiotap-headers.rst:97
msgid ""
"If you are having to parse a radiotap struct, you can radically simplify the "
"job by using the radiotap parser that lives in net/wireless/radiotap.c and "
"has its prototypes available in include/net/cfg80211.h.  You use it like "
"this::"
msgstr ""

#: ../../../networking/radiotap-headers.rst:159
msgid "Andy Green <andy@warmcat.com>"
msgstr ""
