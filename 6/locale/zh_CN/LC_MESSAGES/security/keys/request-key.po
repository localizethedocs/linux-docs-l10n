# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../security/keys/request-key.rst:3
msgid "Key Request Service"
msgstr ""

#: ../../../security/keys/request-key.rst:5
msgid ""
"The key request service is part of the key retention service (refer to "
"Documentation/security/keys/core.rst).  This document explains more fully "
"how the requesting algorithm works."
msgstr ""

#: ../../../security/keys/request-key.rst:9
msgid ""
"The process starts by either the kernel requesting a service by calling "
"``request_key*()``::"
msgstr ""

#: ../../../security/keys/request-key.rst:16
#: ../../../security/keys/request-key.rst:23
#: ../../../security/keys/request-key.rst:32
msgid "or::"
msgstr ""

#: ../../../security/keys/request-key.rst:38
msgid "Or by userspace invoking the request_key system call::"
msgstr ""

#: ../../../security/keys/request-key.rst:45
msgid ""
"The main difference between the access points is that the in-kernel "
"interface does not need to link the key to a keyring to prevent it from "
"being immediately destroyed.  The kernel interface returns a pointer "
"directly to the key, and it's up to the caller to destroy the key."
msgstr ""

#: ../../../security/keys/request-key.rst:50
msgid ""
"The request_key_tag() call is like the in-kernel request_key(), except that "
"it also takes a domain tag that allows keys to be separated by namespace and "
"killed off as a group."
msgstr ""

#: ../../../security/keys/request-key.rst:54
msgid ""
"The request_key_with_auxdata() calls is like the request_key_tag() call, "
"except that they permit auxiliary data to be passed to the upcaller (the "
"default is NULL).  This is only useful for those key types that define their "
"own upcall mechanism rather than using /sbin/request-key."
msgstr ""

#: ../../../security/keys/request-key.rst:59
msgid ""
"The request_key_rcu() call is like the request_key_tag() call, except that "
"it doesn't check for keys that are under construction and doesn't attempt to "
"construct missing keys."
msgstr ""

#: ../../../security/keys/request-key.rst:63
msgid ""
"The userspace interface links the key to a keyring associated with the "
"process to prevent the key from going away, and returns the serial number of "
"the key to the caller."
msgstr ""

#: ../../../security/keys/request-key.rst:68
msgid ""
"The following example assumes that the key types involved don't define their "
"own upcall mechanisms.  If they do, then those should be substituted for the "
"forking and execution of /sbin/request-key."
msgstr ""

#: ../../../security/keys/request-key.rst:74
msgid "The Process"
msgstr ""

#: ../../../security/keys/request-key.rst:76
msgid "A request proceeds in the following manner:"
msgstr ""

#: ../../../security/keys/request-key.rst:78
msgid ""
"Process A calls request_key() [the userspace syscall calls the kernel "
"interface]."
msgstr ""

#: ../../../security/keys/request-key.rst:81
msgid ""
"request_key() searches the process's subscribed keyrings to see if there's a "
"suitable key there.  If there is, it returns the key.  If there isn't, and "
"callout_info is not set, an error is returned.  Otherwise the process "
"proceeds to the next step."
msgstr ""

#: ../../../security/keys/request-key.rst:86
msgid ""
"request_key() sees that A doesn't have the desired key yet, so it creates "
"two things:"
msgstr ""

#: ../../../security/keys/request-key.rst:89
msgid "An uninstantiated key U of requested type and description."
msgstr ""

#: ../../../security/keys/request-key.rst:91
msgid ""
"An authorisation key V that refers to key U and notes that process A is the "
"context in which key U should be instantiated and secured, and from which "
"associated key requests may be satisfied."
msgstr ""

#: ../../../security/keys/request-key.rst:95
msgid ""
"request_key() then forks and executes /sbin/request-key with a new session "
"keyring that contains a link to auth key V."
msgstr ""

#: ../../../security/keys/request-key.rst:98
msgid "/sbin/request-key assumes the authority associated with key U."
msgstr ""

#: ../../../security/keys/request-key.rst:100
msgid ""
"/sbin/request-key execs an appropriate program to perform the actual "
"instantiation."
msgstr ""

#: ../../../security/keys/request-key.rst:103
msgid ""
"The program may want to access another key from A's context (say a Kerberos "
"TGT key).  It just requests the appropriate key, and the keyring search "
"notes that the session keyring has auth key V in its bottom level."
msgstr ""

#: ../../../security/keys/request-key.rst:107
msgid ""
"This will permit it to then search the keyrings of process A with the UID, "
"GID, groups and security info of process A as if it was process A, and come "
"up with key W."
msgstr ""

#: ../../../security/keys/request-key.rst:111
msgid ""
"The program then does what it must to get the data with which to instantiate "
"key U, using key W as a reference (perhaps it contacts a Kerberos server "
"using the TGT) and then instantiates key U."
msgstr ""

#: ../../../security/keys/request-key.rst:115
msgid ""
"Upon instantiating key U, auth key V is automatically revoked so that it may "
"not be used again."
msgstr ""

#: ../../../security/keys/request-key.rst:118
msgid ""
"The program then exits 0 and request_key() deletes key V and returns key U "
"to the caller."
msgstr ""

#: ../../../security/keys/request-key.rst:121
msgid ""
"This also extends further.  If key W (step 7 above) didn't exist, key W "
"would be created uninstantiated, another auth key (X) would be created (as "
"per step 3) and another copy of /sbin/request-key spawned (as per step 4); "
"but the context specified by auth key X will still be process A, as it was "
"in auth key V."
msgstr ""

#: ../../../security/keys/request-key.rst:127
msgid ""
"This is because process A's keyrings can't simply be attached to /sbin/"
"request-key at the appropriate places because (a) execve will discard two of "
"them, and (b) it requires the same UID/GID/Groups all the way through."
msgstr ""

#: ../../../security/keys/request-key.rst:133
msgid "Negative Instantiation And Rejection"
msgstr ""

#: ../../../security/keys/request-key.rst:135
msgid ""
"Rather than instantiating a key, it is possible for the possessor of an "
"authorisation key to negatively instantiate a key that's under construction. "
"This is a short duration placeholder that causes any attempt at re-"
"requesting the key while it exists to fail with error ENOKEY if negated or "
"the specified error if rejected."
msgstr ""

#: ../../../security/keys/request-key.rst:141
msgid ""
"This is provided to prevent excessive repeated spawning of /sbin/request-key "
"processes for a key that will never be obtainable."
msgstr ""

#: ../../../security/keys/request-key.rst:144
msgid ""
"Should the /sbin/request-key process exit anything other than 0 or die on a "
"signal, the key under construction will be automatically negatively "
"instantiated for a short amount of time."
msgstr ""

#: ../../../security/keys/request-key.rst:150
msgid "The Search Algorithm"
msgstr ""

#: ../../../security/keys/request-key.rst:152
msgid "A search of any particular keyring proceeds in the following fashion:"
msgstr ""

#: ../../../security/keys/request-key.rst:154
msgid ""
"When the key management code searches for a key (keyring_search_rcu) it "
"firstly calls key_permission(SEARCH) on the keyring it's starting with, if "
"this denies permission, it doesn't search further."
msgstr ""

#: ../../../security/keys/request-key.rst:158
msgid ""
"It considers all the non-keyring keys within that keyring and, if any key "
"matches the criteria specified, calls key_permission(SEARCH) on it to see if "
"the key is allowed to be found.  If it is, that key is returned; if not, the "
"search continues, and the error code is retained if of higher priority than "
"the one currently set."
msgstr ""

#: ../../../security/keys/request-key.rst:164
msgid ""
"It then considers all the keyring-type keys in the keyring it's currently "
"searching.  It calls key_permission(SEARCH) on each keyring, and if this "
"grants permission, it recurses, executing steps (2) and (3) on that keyring."
msgstr ""

#: ../../../security/keys/request-key.rst:169
msgid ""
"The process stops immediately a valid key is found with permission granted "
"to use it.  Any error from a previous match attempt is discarded and the key "
"is returned."
msgstr ""

#: ../../../security/keys/request-key.rst:173
msgid ""
"When request_key() is invoked, if CONFIG_KEYS_REQUEST_CACHE=y, a per-task "
"one-key cache is first checked for a match."
msgstr ""

#: ../../../security/keys/request-key.rst:176
msgid ""
"When search_process_keyrings() is invoked, it performs the following "
"searches until one succeeds:"
msgstr ""

#: ../../../security/keys/request-key.rst:179
msgid "If extant, the process's thread keyring is searched."
msgstr ""

#: ../../../security/keys/request-key.rst:181
msgid "If extant, the process's process keyring is searched."
msgstr ""

#: ../../../security/keys/request-key.rst:183
msgid "The process's session keyring is searched."
msgstr ""

#: ../../../security/keys/request-key.rst:185
msgid ""
"If the process has assumed the authority associated with a request_key() "
"authorisation key then:"
msgstr ""

#: ../../../security/keys/request-key.rst:188
msgid "If extant, the calling process's thread keyring is searched."
msgstr ""

#: ../../../security/keys/request-key.rst:190
msgid "If extant, the calling process's process keyring is searched."
msgstr ""

#: ../../../security/keys/request-key.rst:192
msgid "The calling process's session keyring is searched."
msgstr ""

#: ../../../security/keys/request-key.rst:194
msgid ""
"The moment one succeeds, all pending errors are discarded and the found key "
"is returned.  If CONFIG_KEYS_REQUEST_CACHE=y, then that key is placed in the "
"per-task cache, displacing the previous key.  The cache is cleared on exit "
"or just prior to resumption of userspace."
msgstr ""

#: ../../../security/keys/request-key.rst:199
msgid ""
"Only if all these fail does the whole thing fail with the highest priority "
"error.  Note that several errors may have come from LSM."
msgstr ""

#: ../../../security/keys/request-key.rst:202
msgid "The error priority is::"
msgstr ""

#: ../../../security/keys/request-key.rst:206
msgid ""
"EACCES/EPERM are only returned on a direct search of a specific keyring "
"where the basal keyring does not grant Search permission."
msgstr ""
