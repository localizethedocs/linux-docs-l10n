# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../misc-devices/uacce.rst:4
msgid "Uacce (Unified/User-space-access-intended Accelerator Framework)"
msgstr ""

#: ../../../misc-devices/uacce.rst:7
msgid "Introduction"
msgstr ""

#: ../../../misc-devices/uacce.rst:9
msgid ""
"Uacce (Unified/User-space-access-intended Accelerator Framework) targets to "
"provide Shared Virtual Addressing (SVA) between accelerators and processes. "
"So accelerator can access any data structure of the main cpu. This differs "
"from the data sharing between cpu and io device, which share only data "
"content rather than address. Because of the unified address, hardware and "
"user space of process can share the same virtual address in the "
"communication. Uacce takes the hardware accelerator as a heterogeneous "
"processor, while IOMMU share the same CPU page tables and as a result the "
"same translation from va to pa."
msgstr ""

#: ../../../misc-devices/uacce.rst:45
msgid "Architecture"
msgstr ""

#: ../../../misc-devices/uacce.rst:47
msgid ""
"Uacce is the kernel module, taking charge of iommu and address sharing. The "
"user drivers and libraries are called WarpDrive."
msgstr ""

#: ../../../misc-devices/uacce.rst:50
msgid ""
"The uacce device, built around the IOMMU SVA API, can access multiple "
"address spaces, including the one without PASID."
msgstr ""

#: ../../../misc-devices/uacce.rst:53
msgid ""
"A virtual concept, queue, is used for the communication. It provides a FIFO-"
"like interface. And it maintains a unified address space between the "
"application and all involved hardware."
msgstr ""

#: ../../../misc-devices/uacce.rst:91
msgid "How does it work"
msgstr ""

#: ../../../misc-devices/uacce.rst:93
msgid "Uacce uses mmap and IOMMU to play the trick."
msgstr ""

#: ../../../misc-devices/uacce.rst:95
msgid ""
"Uacce creates a chrdev for every device registered to it. New queue is "
"created when user application open the chrdev. The file descriptor is used "
"as the user handle of the queue. The accelerator device present itself as an "
"Uacce object, which exports as a chrdev to the user space. The user "
"application communicates with the hardware by ioctl (as control path) or "
"share memory (as data path)."
msgstr ""

#: ../../../misc-devices/uacce.rst:102
msgid ""
"The control path to the hardware is via file operation, while data path is "
"via mmap space of the queue fd."
msgstr ""

#: ../../../misc-devices/uacce.rst:105
msgid "The queue file address space:"
msgstr ""

#: ../../../misc-devices/uacce.rst:119
msgid ""
"All regions are optional and differ from device type to type. Each region "
"can be mmapped only once, otherwise -EEXIST returns."
msgstr ""

#: ../../../misc-devices/uacce.rst:122
msgid ""
"The device mmio region is mapped to the hardware mmio space. It is generally "
"used for doorbell or other notification to the hardware. It is not fast "
"enough as data channel."
msgstr ""

#: ../../../misc-devices/uacce.rst:126
msgid ""
"The device user share region is used for share data buffer between user "
"process and device."
msgstr ""

#: ../../../misc-devices/uacce.rst:131
msgid "The Uacce register API"
msgstr ""

#: ../../../misc-devices/uacce.rst:133
msgid "The register API is defined in uacce.h."
msgstr ""

#: ../../../misc-devices/uacce.rst:143
msgid "According to the IOMMU capability, uacce_interface flags can be:"
msgstr ""

#: ../../../misc-devices/uacce.rst:160
msgid "uacce_register results can be:"
msgstr ""

#: ../../../misc-devices/uacce.rst:162
msgid "If uacce module is not compiled, ERR_PTR(-ENODEV)"
msgstr ""

#: ../../../misc-devices/uacce.rst:164
msgid "Succeed with the desired flags"
msgstr ""

#: ../../../misc-devices/uacce.rst:166
msgid "Succeed with the negotiated flags, for example"
msgstr ""

#: ../../../misc-devices/uacce.rst:168
msgid "uacce_interface.flags = UACCE_DEV_SVA but uacce->flags = ~UACCE_DEV_SVA"
msgstr ""

#: ../../../misc-devices/uacce.rst:170
msgid ""
"So user driver need check return value as well as the negotiated uacce-"
">flags."
msgstr ""

#: ../../../misc-devices/uacce.rst:174
msgid "The user driver"
msgstr ""

#: ../../../misc-devices/uacce.rst:176
msgid ""
"The queue file mmap space will need a user driver to wrap the communication "
"protocol. Uacce provides some attributes in sysfs for the user driver to "
"match the right accelerator accordingly. More details in Documentation/ABI/"
"testing/sysfs-driver-uacce."
msgstr ""
