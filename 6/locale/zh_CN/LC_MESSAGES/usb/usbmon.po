# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usb/usbmon.rst:3
msgid "usbmon"
msgstr ""

#: ../../../usb/usbmon.rst:6
msgid "Introduction"
msgstr ""

#: ../../../usb/usbmon.rst:8
msgid ""
"The name \"usbmon\" in lowercase refers to a facility in kernel which is "
"used to collect traces of I/O on the USB bus. This function is analogous to "
"a packet socket used by network monitoring tools such as tcpdump(1) or "
"Ethereal. Similarly, it is expected that a tool such as usbdump or USBMon "
"(with uppercase letters) is used to examine raw traces produced by usbmon."
msgstr ""

#: ../../../usb/usbmon.rst:15
msgid ""
"The usbmon reports requests made by peripheral-specific drivers to Host "
"Controller Drivers (HCD). So, if HCD is buggy, the traces reported by usbmon "
"may not correspond to bus transactions precisely. This is the same situation "
"as with tcpdump."
msgstr ""

#: ../../../usb/usbmon.rst:20
msgid ""
"Two APIs are currently implemented: \"text\" and \"binary\". The binary API "
"is available through a character device in /dev namespace and is an ABI. The "
"text API is deprecated since 2.6.35, but available for convenience."
msgstr ""

#: ../../../usb/usbmon.rst:25
msgid "How to use usbmon to collect raw text traces"
msgstr ""

#: ../../../usb/usbmon.rst:27
msgid ""
"Unlike the packet socket, usbmon has an interface which provides traces in a "
"text format. This is used for two purposes. First, it serves as a common "
"trace exchange format for tools while more sophisticated formats are "
"finalized. Second, humans can read it in case tools are not available."
msgstr ""

#: ../../../usb/usbmon.rst:32
msgid "To collect a raw text trace, execute following steps."
msgstr ""

#: ../../../usb/usbmon.rst:35
msgid "1. Prepare"
msgstr ""

#: ../../../usb/usbmon.rst:37
msgid ""
"Mount debugfs (it has to be enabled in your kernel configuration), and load "
"the usbmon module (if built as module). The second step is skipped if usbmon "
"is built into the kernel::"
msgstr ""

#: ../../../usb/usbmon.rst:45
msgid "Verify that bus sockets are present::"
msgstr ""

#: ../../../usb/usbmon.rst:51
msgid ""
"Now you can choose to either use the socket '0u' (to capture packets on all "
"buses), and skip to step #3, or find the bus used by your device with step "
"#2. This allows to filter away annoying devices that talk continuously."
msgstr ""

#: ../../../usb/usbmon.rst:56
msgid "2. Find which bus connects to the desired device"
msgstr ""

#: ../../../usb/usbmon.rst:58
msgid ""
"Run \"cat /sys/kernel/debug/usb/devices\", and find the T-line which "
"corresponds to the device. Usually you do it by looking for the vendor "
"string. If you have many similar devices, unplug one and compare the two /"
"sys/kernel/debug/usb/devices outputs. The T-line will have a bus number."
msgstr ""

#: ../../../usb/usbmon.rst:63
msgid "Example::"
msgstr ""

#: ../../../usb/usbmon.rst:71
msgid ""
"\"Bus=03\" means it's bus 3. Alternatively, you can look at the output from "
"\"lsusb\" and get the bus number from the appropriate line. Example:"
msgstr ""

#: ../../../usb/usbmon.rst:74
msgid "Bus 003 Device 002: ID 0557:2004 ATEN UC100KM V2.00"
msgstr ""

#: ../../../usb/usbmon.rst:77
msgid "3. Start 'cat'"
msgstr ""

#: ../../../usb/usbmon.rst:83
msgid "to listen on a single bus, otherwise, to listen on all buses, type::"
msgstr ""

#: ../../../usb/usbmon.rst:87
msgid ""
"This process will read until it is killed. Naturally, the output can be "
"redirected to a desirable location. This is preferred, because it is going "
"to be quite long."
msgstr ""

#: ../../../usb/usbmon.rst:92
msgid "4. Perform the desired operation on the USB bus"
msgstr ""

#: ../../../usb/usbmon.rst:94
msgid ""
"This is where you do something that creates the traffic: plug in a flash "
"key, copy files, control a webcam, etc."
msgstr ""

#: ../../../usb/usbmon.rst:98
msgid "5. Kill cat"
msgstr ""

#: ../../../usb/usbmon.rst:100
msgid "Usually it's done with a keyboard interrupt (Control-C)."
msgstr ""

#: ../../../usb/usbmon.rst:102
msgid ""
"At this point the output file (/tmp/1.mon.out in this example) can be saved, "
"sent by e-mail, or inspected with a text editor. In the last case make sure "
"that the file size is not excessive for your favourite editor."
msgstr ""

#: ../../../usb/usbmon.rst:107
msgid "Raw text data format"
msgstr ""

#: ../../../usb/usbmon.rst:109
msgid ""
"Two formats are supported currently: the original, or '1t' format, and the "
"'1u' format. The '1t' format is deprecated in kernel 2.6.21. The '1u' format "
"adds a few fields, such as ISO frame descriptors, interval, etc. It produces "
"slightly longer lines, but otherwise is a perfect superset of '1t' format."
msgstr ""

#: ../../../usb/usbmon.rst:115
msgid ""
"If it is desired to recognize one from the other in a program, look at the "
"\"address\" word (see below), where '1u' format adds a bus number. If 2 "
"colons are present, it's the '1t' format, otherwise '1u'."
msgstr ""

#: ../../../usb/usbmon.rst:119
msgid ""
"Any text format data consists of a stream of events, such as URB submission, "
"URB callback, submission error. Every event is a text line, which consists "
"of whitespace separated words. The number or position of words may depend on "
"the event type, but there is a set of words, common for all types."
msgstr ""

#: ../../../usb/usbmon.rst:124
msgid "Here is the list of words, from left to right:"
msgstr ""

#: ../../../usb/usbmon.rst:126
msgid ""
"URB Tag. This is used to identify URBs, and is normally an in-kernel address "
"of the URB structure in hexadecimal, but can be a sequence number or any "
"other unique string, within reason."
msgstr ""

#: ../../../usb/usbmon.rst:130
msgid ""
"Timestamp in microseconds, a decimal number. The timestamp's resolution "
"depends on available clock, and so it can be much worse than a microsecond "
"(if the implementation uses jiffies, for example)."
msgstr ""

#: ../../../usb/usbmon.rst:134
msgid ""
"Event Type. This type refers to the format of the event, not URB type. "
"Available types are: S - submission, C - callback, E - submission error."
msgstr ""

#: ../../../usb/usbmon.rst:137
msgid ""
"\"Address\" word (formerly a \"pipe\"). It consists of four fields, "
"separated by colons: URB type and direction, Bus number, Device address, "
"Endpoint number. Type and direction are encoded with two bytes in the "
"following manner:"
msgstr ""

#: ../../../usb/usbmon.rst:142
msgid "Ci"
msgstr ""

#: ../../../usb/usbmon.rst:142
msgid "Co"
msgstr ""

#: ../../../usb/usbmon.rst:142
msgid "Control input and output"
msgstr ""

#: ../../../usb/usbmon.rst:143
msgid "Zi"
msgstr ""

#: ../../../usb/usbmon.rst:143
msgid "Zo"
msgstr ""

#: ../../../usb/usbmon.rst:143
msgid "Isochronous input and output"
msgstr ""

#: ../../../usb/usbmon.rst:144
msgid "Ii"
msgstr ""

#: ../../../usb/usbmon.rst:144
msgid "Io"
msgstr ""

#: ../../../usb/usbmon.rst:144
msgid "Interrupt input and output"
msgstr ""

#: ../../../usb/usbmon.rst:145
msgid "Bi"
msgstr ""

#: ../../../usb/usbmon.rst:145
msgid "Bo"
msgstr ""

#: ../../../usb/usbmon.rst:145
msgid "Bulk input and output"
msgstr ""

#: ../../../usb/usbmon.rst:148
msgid ""
"Bus number, Device address, and Endpoint are decimal numbers, but they may "
"have leading zeros, for the sake of human readers."
msgstr ""

#: ../../../usb/usbmon.rst:151
msgid ""
"URB Status word. This is either a letter, or several numbers separated by "
"colons: URB status, interval, start frame, and error count. Unlike the "
"\"address\" word, all fields save the status are optional. Interval is "
"printed only for interrupt and isochronous URBs. Start frame is printed only "
"for isochronous URBs. Error count is printed only for isochronous callback "
"events."
msgstr ""

#: ../../../usb/usbmon.rst:158
msgid ""
"The status field is a decimal number, sometimes negative, which represents a "
"\"status\" field of the URB. This field makes no sense for submissions, but "
"is present anyway to help scripts with parsing. When an error occurs, the "
"field contains the error code."
msgstr ""

#: ../../../usb/usbmon.rst:163
msgid ""
"In case of a submission of a Control packet, this field contains a Setup Tag "
"instead of an group of numbers. It is easy to tell whether the Setup Tag is "
"present because it is never a number. Thus if scripts find a set of numbers "
"in this word, they proceed to read Data Length (except for isochronous "
"URBs). If they find something else, like a letter, they read the setup "
"packet before reading the Data Length or isochronous descriptors."
msgstr ""

#: ../../../usb/usbmon.rst:170
msgid ""
"Setup packet, if present, consists of 5 words: one of each for "
"bmRequestType, bRequest, wValue, wIndex, wLength, as specified by the USB "
"Specification 2.0. These words are safe to decode if Setup Tag was 's'. "
"Otherwise, the setup packet was present, but not captured, and the fields "
"contain filler."
msgstr ""

#: ../../../usb/usbmon.rst:175
msgid ""
"Number of isochronous frame descriptors and descriptors themselves. If an "
"Isochronous transfer event has a set of descriptors, a total number of them "
"in an URB is printed first, then a word per descriptor, up to a total of 5. "
"The word consists of 3 colon-separated decimal numbers for status, offset, "
"and length respectively. For submissions, initial length is reported. For "
"callbacks, actual length is reported."
msgstr ""

#: ../../../usb/usbmon.rst:182
msgid ""
"Data Length. For submissions, this is the requested length. For callbacks, "
"this is the actual length."
msgstr ""

#: ../../../usb/usbmon.rst:185
msgid ""
"Data tag. The usbmon may not always capture data, even if length is nonzero. "
"The data words are present only if this tag is '='."
msgstr ""

#: ../../../usb/usbmon.rst:188
msgid ""
"Data words follow, in big endian hexadecimal format. Notice that they are "
"not machine words, but really just a byte stream split into words to make it "
"easier to read. Thus, the last word may contain from one to four bytes. The "
"length of collected data is limited and can be less than the data length "
"reported in the Data Length word. In the case of an Isochronous input (Zi) "
"completion where the received data is sparse in the buffer, the length of "
"the collected data can be greater than the Data Length value (because Data "
"Length counts only the bytes that were received whereas the Data words "
"contain the entire transfer buffer)."
msgstr ""

#: ../../../usb/usbmon.rst:198
msgid "Examples:"
msgstr ""

#: ../../../usb/usbmon.rst:200
msgid "An input control transfer to get a port status::"
msgstr ""

#: ../../../usb/usbmon.rst:205
msgid ""
"An output bulk transfer to send a SCSI command 0x28 (READ_10) in a 31-byte "
"Bulk wrapper to a storage device at address 5::"
msgstr ""

#: ../../../usb/usbmon.rst:212
msgid "Raw binary format and API"
msgstr ""

#: ../../../usb/usbmon.rst:214
msgid ""
"The overall architecture of the API is about the same as the one above, only "
"the events are delivered in binary format. Each event is sent in the "
"following structure (its name is made up, so that we can refer to it)::"
msgstr ""

#: ../../../usb/usbmon.rst:245
msgid ""
"These events can be received from a character device by reading with "
"read(2), with an ioctl(2), or by accessing the buffer with mmap. However, "
"read(2) only returns first 48 bytes for compatibility reasons."
msgstr ""

#: ../../../usb/usbmon.rst:249
msgid ""
"The character device is usually called /dev/usbmonN, where N is the USB bus "
"number. Number zero (/dev/usbmon0) is special and means \"all buses\". Note "
"that specific naming policy is set by your Linux distribution."
msgstr ""

#: ../../../usb/usbmon.rst:253
msgid ""
"If you create /dev/usbmon0 by hand, make sure that it is owned by root and "
"has mode 0600. Otherwise, unprivileged users will be able to snoop keyboard "
"traffic."
msgstr ""

#: ../../../usb/usbmon.rst:257
msgid "The following ioctl calls are available, with MON_IOC_MAGIC 0x92:"
msgstr ""

#: ../../../usb/usbmon.rst:259
msgid "MON_IOCQ_URB_LEN, defined as _IO(MON_IOC_MAGIC, 1)"
msgstr ""

#: ../../../usb/usbmon.rst:261
msgid ""
"This call returns the length of data in the next event. Note that majority "
"of events contain no data, so if this call returns zero, it does not mean "
"that no events are available."
msgstr ""

#: ../../../usb/usbmon.rst:265
msgid "MON_IOCG_STATS, defined as _IOR(MON_IOC_MAGIC, 3, struct mon_bin_stats)"
msgstr ""

#: ../../../usb/usbmon.rst:267
msgid "The argument is a pointer to the following structure::"
msgstr ""

#: ../../../usb/usbmon.rst:274
msgid ""
"The member \"queued\" refers to the number of events currently queued in the "
"buffer (and not to the number of events processed since the last reset)."
msgstr ""

#: ../../../usb/usbmon.rst:277
msgid ""
"The member \"dropped\" is the number of events lost since the last call to "
"MON_IOCG_STATS."
msgstr ""

#: ../../../usb/usbmon.rst:280
msgid "MON_IOCT_RING_SIZE, defined as _IO(MON_IOC_MAGIC, 4)"
msgstr ""

#: ../../../usb/usbmon.rst:282
msgid ""
"This call sets the buffer size. The argument is the size in bytes. The size "
"may be rounded down to the next chunk (or page). If the requested size is "
"out of [unspecified] bounds for this kernel, the call fails with -EINVAL."
msgstr ""

#: ../../../usb/usbmon.rst:287
msgid "MON_IOCQ_RING_SIZE, defined as _IO(MON_IOC_MAGIC, 5)"
msgstr ""

#: ../../../usb/usbmon.rst:289
msgid "This call returns the current size of the buffer in bytes."
msgstr ""

#: ../../../usb/usbmon.rst:291
msgid ""
"MON_IOCX_GET, defined as _IOW(MON_IOC_MAGIC, 6, struct mon_get_arg) "
"MON_IOCX_GETX, defined as _IOW(MON_IOC_MAGIC, 10, struct mon_get_arg)"
msgstr ""

#: ../../../usb/usbmon.rst:294
msgid ""
"These calls wait for events to arrive if none were in the kernel buffer, "
"then return the first event. The argument is a pointer to the following "
"structure::"
msgstr ""

#: ../../../usb/usbmon.rst:304
msgid ""
"Before the call, hdr, data, and alloc should be filled. Upon return, the "
"area pointed by hdr contains the next event structure, and the data buffer "
"contains the data, if any. The event is removed from the kernel buffer."
msgstr ""

#: ../../../usb/usbmon.rst:308
msgid ""
"The MON_IOCX_GET copies 48 bytes to hdr area, MON_IOCX_GETX copies 64 bytes."
msgstr ""

#: ../../../usb/usbmon.rst:310
msgid ""
"MON_IOCX_MFETCH, defined as _IOWR(MON_IOC_MAGIC, 7, struct mon_mfetch_arg)"
msgstr ""

#: ../../../usb/usbmon.rst:312
msgid ""
"This ioctl is primarily used when the application accesses the buffer with "
"mmap(2). Its argument is a pointer to the following structure::"
msgstr ""

#: ../../../usb/usbmon.rst:321
msgid "The ioctl operates in 3 stages."
msgstr ""

#: ../../../usb/usbmon.rst:323
msgid ""
"First, it removes and discards up to nflush events from the kernel buffer. "
"The actual number of events discarded is returned in nflush."
msgstr ""

#: ../../../usb/usbmon.rst:326
msgid ""
"Second, it waits for an event to be present in the buffer, unless the "
"pseudo- device is open with O_NONBLOCK."
msgstr ""

#: ../../../usb/usbmon.rst:329
msgid ""
"Third, it extracts up to nfetch offsets into the mmap buffer, and stores "
"them into the offvec. The actual number of event offsets is stored into the "
"nfetch."
msgstr ""

#: ../../../usb/usbmon.rst:333
msgid "MON_IOCH_MFLUSH, defined as _IO(MON_IOC_MAGIC, 8)"
msgstr ""

#: ../../../usb/usbmon.rst:335
msgid ""
"This call removes a number of events from the kernel buffer. Its argument is "
"the number of events to remove. If the buffer contains fewer events than "
"requested, all events present are removed, and no error is reported. This "
"works when no events are available too."
msgstr ""

#: ../../../usb/usbmon.rst:340
msgid "FIONBIO"
msgstr ""

#: ../../../usb/usbmon.rst:342
msgid "The ioctl FIONBIO may be implemented in the future, if there's a need."
msgstr ""

#: ../../../usb/usbmon.rst:344
msgid ""
"In addition to ioctl(2) and read(2), the special file of binary API can be "
"polled with select(2) and poll(2). But lseek(2) does not work."
msgstr ""

#: ../../../usb/usbmon.rst:347
msgid "Memory-mapped access of the kernel buffer for the binary API"
msgstr ""

#: ../../../usb/usbmon.rst:349
msgid "The basic idea is simple:"
msgstr ""

#: ../../../usb/usbmon.rst:351
msgid ""
"To prepare, map the buffer by getting the current size, then using mmap(2). "
"Then, execute a loop similar to the one written in pseudo-code below::"
msgstr ""

#: ../../../usb/usbmon.rst:372
msgid "Thus, the main idea is to execute only one ioctl per N events."
msgstr ""

#: ../../../usb/usbmon.rst:374
msgid ""
"Although the buffer is circular, the returned headers and data do not cross "
"the end of the buffer, so the above pseudo-code does not need any gathering."
msgstr ""
