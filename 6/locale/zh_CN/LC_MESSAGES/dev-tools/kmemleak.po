# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../dev-tools/kmemleak.rst:2
msgid "Kernel Memory Leak Detector"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:4
msgid ""
"Kmemleak provides a way of detecting possible kernel memory leaks in a way "
"similar to a `tracing garbage collector <https://en.wikipedia.org/wiki/"
"Tracing_garbage_collection>`_, with the difference that the orphan objects "
"are not freed but only reported via /sys/kernel/debug/kmemleak. A similar "
"method is used by the Valgrind tool (``memcheck --leak-check``) to detect "
"the memory leaks in user-space applications."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:13
msgid "Usage"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:15
msgid ""
"CONFIG_DEBUG_KMEMLEAK in \"Kernel hacking\" has to be enabled. A kernel "
"thread scans the memory every 10 minutes (by default) and prints the number "
"of new unreferenced objects found. If the ``debugfs`` isn't already mounted, "
"mount with::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:22
msgid "To display the details of all the possible scanned memory leaks::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:26
msgid "To trigger an intermediate memory scan::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:30
msgid "To clear the list of all current possible memory leaks::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:34
msgid ""
"New leaks will then come up upon reading ``/sys/kernel/debug/kmemleak`` "
"again."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:37
msgid ""
"Note that the orphan objects are listed in the order they were allocated and "
"one object at the beginning of the list may cause other subsequent objects "
"to be reported as orphan."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:41
msgid ""
"Memory scanning parameters can be modified at run-time by writing to the ``/"
"sys/kernel/debug/kmemleak`` file. The following parameters are supported:"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:44
msgid "off"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:45
msgid "disable kmemleak (irreversible)"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:46
msgid "stack=on"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:47
msgid "enable the task stacks scanning (default)"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:48
msgid "stack=off"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:49
msgid "disable the tasks stacks scanning"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:50
msgid "scan=on"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:51
msgid "start the automatic memory scanning thread (default)"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:52
msgid "scan=off"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:53
msgid "stop the automatic memory scanning thread"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:54
msgid "scan=<secs>"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:55
msgid ""
"set the automatic memory scanning period in seconds (default 600, 0 to stop "
"the automatic scanning)"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:57
msgid "scan"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:58
msgid "trigger a memory scan"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:59
msgid "clear"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:60
msgid ""
"clear list of current memory leak suspects, done by marking all current "
"reported unreferenced objects grey, or free all kmemleak objects if kmemleak "
"has been disabled."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:63
msgid "dump=<addr>"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:64
msgid "dump information about the object found at <addr>"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:66
msgid ""
"Kmemleak can also be disabled at boot-time by passing ``kmemleak=off`` on "
"the kernel command line."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:69
msgid ""
"Memory may be allocated or freed before kmemleak is initialised and these "
"actions are stored in an early log buffer. The size of this buffer is "
"configured via the CONFIG_DEBUG_KMEMLEAK_MEM_POOL_SIZE option."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:73
msgid ""
"If CONFIG_DEBUG_KMEMLEAK_DEFAULT_OFF are enabled, the kmemleak is disabled "
"by default. Passing ``kmemleak=on`` on the kernel command line enables the "
"function."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:77
msgid ""
"If you are getting errors like \"Error while writing to stdout\" or "
"\"write_loop: Invalid argument\", make sure kmemleak is properly enabled."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:81
msgid "Basic Algorithm"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:83
msgid ""
"The memory allocations via :c:func:`kmalloc`, :c:func:`vmalloc`, :c:func:"
"`kmem_cache_alloc` and friends are traced and the pointers, together with "
"additional information like size and stack trace, are stored in a rbtree. "
"The corresponding freeing function calls are tracked and the pointers "
"removed from the kmemleak data structures."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:90
msgid ""
"An allocated block of memory is considered orphan if no pointer to its start "
"address or to any location inside the block can be found by scanning the "
"memory (including saved registers). This means that there might be no way "
"for the kernel to pass the address of the allocated block to a freeing "
"function and therefore the block is considered a memory leak."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:97
msgid "The scanning algorithm steps:"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:99
msgid ""
"mark all objects as white (remaining white objects will later be considered "
"orphan)"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:101
msgid ""
"scan the memory starting with the data section and stacks, checking the "
"values against the addresses stored in the rbtree. If a pointer to a white "
"object is found, the object is added to the gray list"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:105
msgid ""
"scan the gray objects for matching addresses (some white objects can become "
"gray and added at the end of the gray list) until the gray set is finished"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:108
msgid ""
"the remaining white objects are considered orphan and reported via /sys/"
"kernel/debug/kmemleak"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:111
msgid ""
"Some allocated memory blocks have pointers stored in the kernel's internal "
"data structures and they cannot be detected as orphans. To avoid this, "
"kmemleak can also store the number of values pointing to an address inside "
"the block address range that need to be found so that the block is not "
"considered a leak. One example is __vmalloc()."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:118
msgid "Testing specific sections with kmemleak"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:120
msgid ""
"Upon initial bootup your /sys/kernel/debug/kmemleak output page may be quite "
"extensive. This can also be the case if you have very buggy code when doing "
"development. To work around these situations you can use the 'clear' command "
"to clear all reported unreferenced objects from the /sys/kernel/debug/"
"kmemleak output. By issuing a 'scan' after a 'clear' you can find new "
"unreferenced objects; this should help with testing specific sections of "
"code."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:128
msgid "To test a critical section on demand with a clean kmemleak do::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:134
msgid "Then as usual to get your report with::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:139
msgid "Freeing kmemleak internal objects"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:141
msgid ""
"To allow access to previously found memory leaks after kmemleak has been "
"disabled by the user or due to an fatal error, internal kmemleak objects "
"won't be freed when kmemleak is disabled, and those objects may occupy a "
"large part of physical memory."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:146
msgid "In this situation, you may reclaim memory with::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:151
msgid "Kmemleak API"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:153
msgid "See the include/linux/kmemleak.h header for the functions prototype."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:155
msgid "``kmemleak_init``              - initialize kmemleak"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:156
msgid "``kmemleak_alloc``             - notify of a memory block allocation"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:157
msgid ""
"``kmemleak_alloc_percpu``      - notify of a percpu memory block allocation"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:158
msgid ""
"``kmemleak_vmalloc``           - notify of a vmalloc() memory allocation"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:159
msgid "``kmemleak_free``              - notify of a memory block freeing"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:160
msgid ""
"``kmemleak_free_part``         - notify of a partial memory block freeing"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:161
msgid ""
"``kmemleak_free_percpu``       - notify of a percpu memory block freeing"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:162
msgid "``kmemleak_update_trace``      - update object allocation stack trace"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:163
msgid "``kmemleak_not_leak``  - mark an object as not a leak"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:164
msgid "``kmemleak_transient_leak``    - mark an object as a transient leak"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:165
msgid ""
"``kmemleak_ignore``            - do not scan or report an object as leak"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:166
msgid "``kmemleak_scan_area``         - add scan areas inside a memory block"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:167
msgid "``kmemleak_no_scan``   - do not scan a memory block"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:168
msgid ""
"``kmemleak_erase``             - erase an old value in a pointer variable"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:169
msgid ""
"``kmemleak_alloc_recursive`` - as kmemleak_alloc but checks the recursiveness"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:170
msgid ""
"``kmemleak_free_recursive``    - as kmemleak_free but checks the "
"recursiveness"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:172
msgid ""
"The following functions take a physical address as the object pointer and "
"only perform the corresponding action if the address has a lowmem mapping:"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:176
msgid "``kmemleak_alloc_phys``"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:177
msgid "``kmemleak_free_part_phys``"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:178
msgid "``kmemleak_ignore_phys``"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:181
msgid "Dealing with false positives/negatives"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:183
msgid ""
"The false negatives are real memory leaks (orphan objects) but not reported "
"by kmemleak because values found during the memory scanning point to such "
"objects. To reduce the number of false negatives, kmemleak provides the "
"kmemleak_ignore, kmemleak_scan_area, kmemleak_no_scan and kmemleak_erase "
"functions (see above). The task stacks also increase the amount of false "
"negatives and their scanning is not enabled by default."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:190
msgid ""
"The false positives are objects wrongly reported as being memory leaks "
"(orphan). For objects known not to be leaks, kmemleak provides the "
"kmemleak_not_leak function. The kmemleak_ignore could also be used if the "
"memory block is known not to contain other pointers and it will no longer be "
"scanned."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:196
msgid ""
"Some of the reported leaks are only transient, especially on SMP systems, "
"because of pointers temporarily stored in CPU registers or stacks. Kmemleak "
"defines MSECS_MIN_AGE (defaulting to 1000) representing the minimum age of "
"an object to be reported as a memory leak."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:202
msgid "Limitations and Drawbacks"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:204
msgid ""
"The main drawback is the reduced performance of memory allocation and "
"freeing. To avoid other penalties, the memory scanning is only performed "
"when the /sys/kernel/debug/kmemleak file is read. Anyway, this tool is "
"intended for debugging purposes where the performance might not be the most "
"important requirement."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:210
msgid ""
"To keep the algorithm simple, kmemleak scans for values pointing to any "
"address inside a block's address range. This may lead to an increased number "
"of false negatives. However, it is likely that a real memory leak will "
"eventually become visible."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:215
msgid ""
"Another source of false negatives is the data stored in non-pointer values. "
"In a future version, kmemleak could only scan the pointer members in the "
"allocated structures. This feature would solve many of the false negative "
"cases described above."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:220
msgid ""
"The tool can report false positives. These are cases where an allocated "
"block doesn't need to be freed (some cases in the init_call functions), the "
"pointer is calculated by other methods than the usual container_of macro or "
"the pointer is stored in a location not scanned by kmemleak."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:225
msgid "Page allocations and ioremap are not tracked."
msgstr ""

#: ../../../dev-tools/kmemleak.rst:228
msgid "Testing with kmemleak-test"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:230
msgid ""
"To check if you have all set up to use kmemleak, you can use the kmemleak-"
"test module, a module that deliberately leaks memory. Set "
"CONFIG_SAMPLE_KMEMLEAK as module (it can't be used as built-in) and boot the "
"kernel with kmemleak enabled. Load the module and perform a scan with::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:238
msgid ""
"Note that the you may not get results instantly or on the first scanning. "
"When kmemleak gets results, it'll log ``kmemleak: <count of leaks> new "
"suspected memory leaks``. Then read the file to see then::"
msgstr ""

#: ../../../dev-tools/kmemleak.rst:258
msgid ""
"Removing the module with ``rmmod kmemleak_test`` should also trigger some "
"kmemleak results."
msgstr ""
