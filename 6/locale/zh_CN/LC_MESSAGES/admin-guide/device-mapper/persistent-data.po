# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/device-mapper/persistent-data.rst:3
msgid "Persistent data"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:6
msgid "Introduction"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:8
msgid ""
"The more-sophisticated device-mapper targets require complex metadata that "
"is managed in kernel.  In late 2010 we were seeing that various different "
"targets were rolling their own data structures, for example:"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:12
msgid "Mikulas Patocka's multisnap implementation"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:13
msgid "Heinz Mauelshagen's thin provisioning target"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:14
msgid "Another btree-based caching target posted to dm-devel"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:15
msgid "Another multi-snapshot target based on a design of Daniel Phillips"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:17
msgid ""
"Maintaining these data structures takes a lot of work, so if possible we'd "
"like to reduce the number."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:20
msgid ""
"The persistent-data library is an attempt to provide a re-usable framework "
"for people who want to store metadata in device-mapper targets.  It's "
"currently used by the thin-provisioning target and an upcoming hierarchical "
"storage target."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:26
msgid "Overview"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:28
msgid ""
"The main documentation is in the header files which can all be found under "
"drivers/md/persistent-data."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:32
msgid "The block manager"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:34
msgid "dm-block-manager.[hc]"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:36
msgid ""
"This provides access to the data on disk in fixed sized-blocks.  There is a "
"read/write locking interface to prevent concurrent accesses, and keep data "
"that is being used in the cache."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:40
msgid "Clients of persistent-data are unlikely to use this directly."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:43
msgid "The transaction manager"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:45
msgid "dm-transaction-manager.[hc]"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:47
msgid ""
"This restricts access to blocks and enforces copy-on-write semantics. The "
"only way you can get hold of a writable block through the transaction "
"manager is by shadowing an existing block (ie. doing copy-on-write) or "
"allocating a fresh one.  Shadowing is elided within the same transaction so "
"performance is reasonable.  The commit method ensures that all data is "
"flushed before it writes the superblock. On power failure your metadata will "
"be as it was when last committed."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:56
msgid "The Space Maps"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:58
msgid "dm-space-map.h dm-space-map-metadata.[hc] dm-space-map-disk.[hc]"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:62
msgid ""
"On-disk data structures that keep track of reference counts of blocks. Also "
"acts as the allocator of new blocks.  Currently two implementations: a "
"simpler one for managing blocks on a different device (eg. thinly-"
"provisioned data blocks); and one for managing the metadata space.  The "
"latter is complicated by the need to store its own data within the space "
"it's managing."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:70
msgid "The data structures"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:72
msgid "dm-btree.[hc] dm-btree-remove.c dm-btree-spine.c dm-btree-internal.h"
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:77
msgid ""
"Currently there is only one data structure, a hierarchical btree. There are "
"plans to add more.  For example, something with an array-like interface "
"would see a lot of use."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:81
msgid ""
"The btree is 'hierarchical' in that you can define it to be composed of "
"nested btrees, and take multiple keys.  For example, the thin-provisioning "
"target uses a btree with two levels of nesting. The first maps a device id "
"to a mapping tree, and that in turn maps a virtual block to a physical block."
msgstr ""

#: ../../../admin-guide/device-mapper/persistent-data.rst:87
msgid ""
"Values stored in the btrees can have arbitrary size.  Keys are always "
"64bits, although nesting allows you to use multiple keys."
msgstr ""
