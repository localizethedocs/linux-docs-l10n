# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../hid/hid-bpf.rst:5
msgid "HID-BPF"
msgstr ""

#: ../../../hid/hid-bpf.rst:7
msgid ""
"HID is a standard protocol for input devices but some devices may require "
"custom tweaks, traditionally done with a kernel driver fix. Using the eBPF "
"capabilities instead speeds up development and adds new capabilities to the "
"existing HID interfaces."
msgstr ""

#: ../../../hid/hid-bpf.rst:18
msgid "When (and why) to use HID-BPF"
msgstr ""

#: ../../../hid/hid-bpf.rst:20
msgid ""
"There are several use cases when using HID-BPF is better than standard "
"kernel driver fix:"
msgstr ""

#: ../../../hid/hid-bpf.rst:24
msgid "Dead zone of a joystick"
msgstr ""

#: ../../../hid/hid-bpf.rst:26
msgid ""
"Assuming you have a joystick that is getting older, it is common to see it "
"wobbling around its neutral point. This is usually filtered at the "
"application level by adding a *dead zone* for this specific axis."
msgstr ""

#: ../../../hid/hid-bpf.rst:30
msgid ""
"With HID-BPF, we can apply this filtering in the kernel directly so "
"userspace does not get woken up when nothing else is happening on the input "
"controller."
msgstr ""

#: ../../../hid/hid-bpf.rst:33
msgid ""
"Of course, given that this dead zone is specific to an individual device, we "
"can not create a generic fix for all of the same joysticks. Adding a custom "
"kernel API for this (e.g. by adding a sysfs entry) does not guarantee this "
"new kernel API will be broadly adopted and maintained."
msgstr ""

#: ../../../hid/hid-bpf.rst:38
msgid ""
"HID-BPF allows the userspace program to load the program itself, ensuring we "
"only load the custom API when we have a user."
msgstr ""

#: ../../../hid/hid-bpf.rst:42
msgid "Simple fixup of report descriptor"
msgstr ""

#: ../../../hid/hid-bpf.rst:44
msgid ""
"In the HID tree, half of the drivers only fix one key or one byte in the "
"report descriptor. These fixes all require a kernel patch and the subsequent "
"shepherding into a release, a long and painful process for users."
msgstr ""

#: ../../../hid/hid-bpf.rst:48
msgid ""
"We can reduce this burden by providing an eBPF program instead. Once such a "
"program  has been verified by the user, we can embed the source code into "
"the kernel tree and ship the eBPF program and load it directly instead of "
"loading a specific kernel module for it."
msgstr ""

#: ../../../hid/hid-bpf.rst:53
msgid ""
"Note: distribution of eBPF programs and their inclusion in the kernel is not "
"yet fully implemented"
msgstr ""

#: ../../../hid/hid-bpf.rst:57
msgid "Add a new feature that requires a new kernel API"
msgstr ""

#: ../../../hid/hid-bpf.rst:59
msgid ""
"An example for such a feature are the Universal Stylus Interface (USI) pens. "
"Basically, USI pens require a new kernel API because there are new channels "
"of communication that our HID and input stack do not support. Instead of "
"using hidraw or creating new sysfs entries or ioctls, we can rely on eBPF to "
"have the kernel API controlled by the consumer and to not impact the "
"performances by waking up userspace every time there is an event."
msgstr ""

#: ../../../hid/hid-bpf.rst:68
msgid "Morph a device into something else and control that from userspace"
msgstr ""

#: ../../../hid/hid-bpf.rst:70
msgid ""
"The kernel has a relatively static mapping of HID items to evdev bits. It "
"cannot decide to dynamically transform a given device into something else as "
"it does not have the required context and any such transformation cannot be "
"undone (or even discovered) by userspace."
msgstr ""

#: ../../../hid/hid-bpf.rst:75
msgid ""
"However, some devices are useless with that static way of defining devices. "
"For example, the Microsoft Surface Dial is a pushbutton with haptic feedback "
"that is barely usable as of today."
msgstr ""

#: ../../../hid/hid-bpf.rst:79
msgid ""
"With eBPF, userspace can morph that device into a mouse, and convert the "
"dial events into wheel events. Also, the userspace program can set/unset the "
"haptic feedback depending on the context. For example, if a menu is visible "
"on the screen we likely need to have a haptic click every 15 degrees. But "
"when scrolling in a web page the user experience is better when the device "
"emits events at the highest resolution."
msgstr ""

#: ../../../hid/hid-bpf.rst:87
msgid "Firewall"
msgstr ""

#: ../../../hid/hid-bpf.rst:89
msgid ""
"What if we want to prevent other users to access a specific feature of a "
"device? (think a possibly broken firmware update entry point)"
msgstr ""

#: ../../../hid/hid-bpf.rst:92
msgid ""
"With eBPF, we can intercept any HID command emitted to the device and "
"validate it or not."
msgstr ""

#: ../../../hid/hid-bpf.rst:95
msgid ""
"This also allows to sync the state between the userspace and the kernel/bpf "
"program because we can intercept any incoming command."
msgstr ""

#: ../../../hid/hid-bpf.rst:99
msgid "Tracing"
msgstr ""

#: ../../../hid/hid-bpf.rst:101
msgid ""
"The last usage is tracing events and all the fun we can do we BPF to "
"summarize and analyze events."
msgstr ""

#: ../../../hid/hid-bpf.rst:104
msgid ""
"Right now, tracing relies on hidraw. It works well except for a couple of "
"issues:"
msgstr ""

#: ../../../hid/hid-bpf.rst:107
msgid ""
"if the driver doesn't export a hidraw node, we can't trace anything (eBPF "
"will be a \"god-mode\" there, so this may raise some eyebrows)"
msgstr ""

#: ../../../hid/hid-bpf.rst:109
msgid ""
"hidraw doesn't catch other processes' requests to the device, which means "
"that we have cases where we need to add printks to the kernel to understand "
"what is happening."
msgstr ""

#: ../../../hid/hid-bpf.rst:114
msgid "High-level view of HID-BPF"
msgstr ""

#: ../../../hid/hid-bpf.rst:116
msgid ""
"The main idea behind HID-BPF is that it works at an array of bytes level. "
"Thus, all of the parsing of the HID report and the HID report descriptor "
"must be implemented in the userspace component that loads the eBPF program."
msgstr ""

#: ../../../hid/hid-bpf.rst:121
msgid ""
"For example, in the dead zone joystick from above, knowing which fields in "
"the data stream needs to be set to ``0`` needs to be computed by userspace."
msgstr ""

#: ../../../hid/hid-bpf.rst:124
msgid ""
"A corollary of this is that HID-BPF doesn't know about the other subsystems "
"available in the kernel. *You can not directly emit input event through the "
"input API from eBPF*."
msgstr ""

#: ../../../hid/hid-bpf.rst:128
msgid ""
"When a BPF program needs to emit input events, it needs to talk with the HID "
"protocol, and rely on the HID kernel processing to translate the HID data "
"into input events."
msgstr ""

#: ../../../hid/hid-bpf.rst:133
msgid "In-tree HID-BPF programs and ``udev-hid-bpf``"
msgstr ""

#: ../../../hid/hid-bpf.rst:135
msgid ""
"Official device fixes are shipped in the kernel tree as source in the "
"``drivers/hid/bpf/progs`` directory. This allows to add selftests to them in "
"``tools/testing/selftests/hid``."
msgstr ""

#: ../../../hid/hid-bpf.rst:139
msgid ""
"However, the compilation of these objects is not part of a regular kernel "
"compilation given that they need an external tool to be loaded. This tool is "
"currently `udev-hid-bpf <https://libevdev.pages.freedesktop.org/udev-hid-bpf/"
"index.html>`_."
msgstr ""

#: ../../../hid/hid-bpf.rst:143
msgid ""
"For convenience, that external repository duplicates the files from here in "
"``drivers/hid/bpf/progs`` into its own ``src/bpf/stable`` directory. This "
"allows distributions to not have to pull the entire kernel source tree to "
"ship and package those HID-BPF fixes. ``udev-hid-bpf`` also has capabilities "
"of handling multiple objects files depending on the kernel the user is "
"running."
msgstr ""

#: ../../../hid/hid-bpf.rst:150
msgid "Available types of programs"
msgstr ""

#: ../../../hid/hid-bpf.rst:152
msgid ""
"HID-BPF is built \"on top\" of BPF, meaning that we use bpf struct_ops "
"method to declare our programs."
msgstr ""

#: ../../../hid/hid-bpf.rst:155
msgid "HID-BPF has the following attachment types available:"
msgstr ""

#: ../../../hid/hid-bpf.rst:157
msgid ""
"event processing/filtering with ``SEC(\"struct_ops/hid_device_event\")`` in "
"libbpf"
msgstr ""

#: ../../../hid/hid-bpf.rst:158
msgid "actions coming from userspace with ``SEC(\"syscall\")`` in libbpf"
msgstr ""

#: ../../../hid/hid-bpf.rst:159
msgid ""
"change of the report descriptor with ``SEC(\"struct_ops/hid_rdesc_fixup\")`` "
"or ``SEC(\"struct_ops.s/hid_rdesc_fixup\")`` in libbpf"
msgstr ""

#: ../../../hid/hid-bpf.rst:162
msgid ""
"A ``hid_device_event`` is calling a BPF program when an event is received "
"from the device. Thus we are in IRQ context and can act on the data or "
"notify userspace. And given that we are in IRQ context, we can not talk back "
"to the device."
msgstr ""

#: ../../../hid/hid-bpf.rst:166
msgid ""
"A ``syscall`` means that userspace called the syscall ``BPF_PROG_RUN`` "
"facility. This time, we can do any operations allowed by HID-BPF, and "
"talking to the device is allowed."
msgstr ""

#: ../../../hid/hid-bpf.rst:170
msgid ""
"Last, ``hid_rdesc_fixup`` is different from the others as there can be only "
"one BPF program of this type. This is called on ``probe`` from the driver "
"and allows to change the report descriptor from the BPF program. Once a "
"``hid_rdesc_fixup`` program has been loaded, it is not possible to overwrite "
"it unless the program which inserted it allows us by pinning the program and "
"closing all of its fds pointing to it."
msgstr ""

#: ../../../hid/hid-bpf.rst:176
msgid ""
"Note that ``hid_rdesc_fixup`` can be declared as sleepable "
"(``SEC(\"struct_ops.s/hid_rdesc_fixup\")``)."
msgstr ""

#: ../../../hid/hid-bpf.rst:180
msgid "Developer API:"
msgstr ""

#: ../../../hid/hid-bpf.rst:183
msgid "Available ``struct_ops`` for HID-BPF:"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:84
msgid ""
"A BPF struct_ops of callbacks allowing to attach HID-BPF programs to a HID "
"device"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:88
#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:25
msgid "**Definition**::"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:99
#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:36
msgid "**Members**"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:86
msgid "``hid_id``"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:87
msgid ""
"the HID uniq ID to attach to. This is writeable before ``load()``, and "
"cannot be changed after"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:88
msgid "``flags``"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:89
msgid ""
"flags used while attaching the struct_ops to the device. Currently only "
"available value is ``0`` or ``BPF_F_BEFORE``. Writeable only before "
"``load()``"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:105
msgid "``hid_device_event``"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:106
msgid "called whenever an event is coming in from the device"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:108
#: include/linux/hid_bpf.h:125 include/linux/hid_bpf.h:139
#: include/linux/hid_bpf.h:167
msgid "It has the following arguments:"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:110
#: include/linux/hid_bpf.h:127 include/linux/hid_bpf.h:141
#: include/linux/hid_bpf.h:169
msgid ""
"``ctx``: The HID-BPF context as :c:type:`struct hid_bpf_ctx <hid_bpf_ctx>`"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:112
msgid ""
"Return: ``0`` on success and keep processing; a positive value to change the "
"incoming size buffer; a negative error code to interrupt the processing of "
"this event"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:116
msgid "Context: Interrupt context."
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:121
msgid "``hid_rdesc_fixup``"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:122
msgid ""
"called when the probe function parses the report descriptor of the HID device"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:129
msgid ""
"Return: ``0`` on success and keep processing; a positive value to change the "
"incoming size buffer; a negative error code to interrupt the processing of "
"this device"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:135
msgid "``hid_hw_request``"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:136
msgid ""
"called whenever a hid_hw_raw_request() call is emitted on the HID device"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:143
msgid "``reportnum``: the report number, as in hid_hw_raw_request()"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:145
msgid ""
"``rtype``: the report type (``HID_INPUT_REPORT``, ``HID_FEATURE_REPORT``, "
"``HID_OUTPUT_REPORT``)"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:148
msgid "``reqtype``: the request"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:150
#: include/linux/hid_bpf.h:171
msgid ""
"``source``: a u64 referring to a uniq but identifiable source. If ``0``, the "
"kernel itself emitted that call. For hidraw, ``source`` is set to the "
"associated ``struct file *``."
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:154
msgid ""
"Return: ``0`` to keep processing the request by hid-core; any other value "
"stops hid-core from processing that event. A positive value should be "
"returned with the number of bytes returned in the incoming buffer; a "
"negative error code interrupts the processing of this call."
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:163
msgid "``hid_hw_output_report``"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:164
msgid ""
"called whenever a hid_hw_output_report() call is emitted on the HID device"
msgstr ""

#: ../../../hid/hid-bpf:185: include/linux/hid_bpf.h:175
msgid ""
"Return: ``0`` to keep processing the request by hid-core; any other value "
"stops hid-core from processing that event. A positive value should be "
"returned with the number of bytes written to the device; a negative error "
"code interrupts the processing of this call."
msgstr ""

#: ../../../hid/hid-bpf.rst:190
msgid "User API data structures available in programs:"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:21
msgid "User accessible data for all HID programs"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:26
msgid "``hid``"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:27
msgid ""
"the :c:type:`struct hid_device <hid_device>` representing the device itself"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:27
msgid "``allocated_size``"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:28
msgid "Allocated size of data."
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:2
msgid "anonymous"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:42
msgid "``retval``"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:43
msgid "Return value of the previous program."
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:33
msgid "``size``"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:34
msgid "Valid data in the data field."
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:37
#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:291
#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:314
#: drivers/hid/bpf/hid_bpf_dispatch.c:404
#: drivers/hid/bpf/hid_bpf_dispatch.c:464
#: drivers/hid/bpf/hid_bpf_dispatch.c:521
#: drivers/hid/bpf/hid_bpf_dispatch.c:545
msgid "**Description**"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:22
msgid ""
"``data`` is not directly accessible from the context. We need to issue a "
"call to hid_bpf_get_data() in order to get a pointer to that field."
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:26
msgid ""
"This is how much memory is available and can be requested by the HID "
"program. Note that for ``HID_BPF_RDESC_FIXUP``, that memory is set to "
"``4096`` (4 KB)"
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:31
msgid ""
"Programs can get the available valid size in data by fetching this field. "
"Programs can also change this value by returning a positive number in the "
"program. To discard the event, return a negative error code."
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:36
msgid ""
"``size`` must always be less or equal than ``allocated_size`` (it is "
"enforced once all BPF programs have been run)."
msgstr ""

#: ../../../hid/hid-bpf:192: include/linux/hid_bpf.h:39
msgid ""
"``hid`` and ``allocated_size`` are read-only, ``size`` and ``retval`` are "
"read-write."
msgstr ""

#: ../../../hid/hid-bpf.rst:196
msgid "Available API that can be used in all HID-BPF struct_ops programs:"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:285
msgid "Get the kernel memory pointer associated with the context **ctx**"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:289
#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:314
#: drivers/hid/bpf/hid_bpf_dispatch.c:342
#: drivers/hid/bpf/hid_bpf_dispatch.c:400
#: drivers/hid/bpf/hid_bpf_dispatch.c:462
#: drivers/hid/bpf/hid_bpf_dispatch.c:518
#: drivers/hid/bpf/hid_bpf_dispatch.c:542
msgid "**Parameters**"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:291
#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:344
#: drivers/hid/bpf/hid_bpf_dispatch.c:402
#: drivers/hid/bpf/hid_bpf_dispatch.c:464
#: drivers/hid/bpf/hid_bpf_dispatch.c:520
#: drivers/hid/bpf/hid_bpf_dispatch.c:544
msgid "``struct hid_bpf_ctx *ctx``"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:287
msgid "The HID-BPF context"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:289
msgid "``unsigned int offset``"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:288
msgid "The offset within the memory"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:290
msgid "``const size_t rdwr_buf_size``"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:289
msgid "the const size of the buffer"
msgstr ""

#: ../../../hid/hid-bpf:198: drivers/hid/bpf/hid_bpf_dispatch.c:290
msgid "**returns** ``NULL`` on error, an ``__u8`` memory pointer on success"
msgstr ""

#: ../../../hid/hid-bpf.rst:202
msgid ""
"Available API that can be used in syscall HID-BPF programs or in sleepable "
"HID-BPF struct_ops programs:"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:310
msgid "Allocate a context to the given HID device"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:316
msgid "``unsigned int hid_id``"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:312
msgid "the system unique identifier of the HID device"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:313
msgid ""
"**returns** A pointer to :c:type:`struct hid_bpf_ctx <hid_bpf_ctx>` on "
"success, ``NULL`` on error."
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:338
msgid "Release the previously allocated context **ctx**"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:340
msgid "the HID-BPF context to release"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:396
msgid "Communicate with a HID device"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:398
#: drivers/hid/bpf/hid_bpf_dispatch.c:460
#: drivers/hid/bpf/hid_bpf_dispatch.c:516
#: drivers/hid/bpf/hid_bpf_dispatch.c:540
msgid "the HID-BPF context previously allocated in hid_bpf_allocate_context()"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:400
#: drivers/hid/bpf/hid_bpf_dispatch.c:462
msgid "``__u8 *buf``"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:399
#: drivers/hid/bpf/hid_bpf_dispatch.c:461
#: drivers/hid/bpf/hid_bpf_dispatch.c:518
#: drivers/hid/bpf/hid_bpf_dispatch.c:542
msgid "a ``PTR_TO_MEM`` buffer"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:401
#: drivers/hid/bpf/hid_bpf_dispatch.c:463
msgid "``size_t buf__sz``"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:400
#: drivers/hid/bpf/hid_bpf_dispatch.c:462
#: drivers/hid/bpf/hid_bpf_dispatch.c:519
#: drivers/hid/bpf/hid_bpf_dispatch.c:543
msgid "the size of the data to transfer"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:402
msgid "``enum hid_report_type rtype``"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:401
#: drivers/hid/bpf/hid_bpf_dispatch.c:517
#: drivers/hid/bpf/hid_bpf_dispatch.c:541
msgid ""
"the type of the report (``HID_INPUT_REPORT``, ``HID_FEATURE_REPORT``, "
"``HID_OUTPUT_REPORT``)"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:403
msgid "``enum hid_class_request reqtype``"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:402
msgid ""
"the type of the request (``HID_REQ_GET_REPORT``, ``HID_REQ_SET_REPORT``, ...)"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:403
msgid "**returns** ``0`` on success, a negative error code otherwise."
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:458
msgid "Send an output report to a HID device"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:463
msgid ""
"Returns the number of bytes transferred on success, a negative error code "
"otherwise."
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:514
#: drivers/hid/bpf/hid_bpf_dispatch.c:538
msgid "Inject a HID report in the kernel from a HID device"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:518
#: drivers/hid/bpf/hid_bpf_dispatch.c:542
msgid "``enum hid_report_type type``"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:519
#: drivers/hid/bpf/hid_bpf_dispatch.c:543
msgid "``u8 *buf``"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:520
#: drivers/hid/bpf/hid_bpf_dispatch.c:544
msgid "``const size_t buf__sz``"
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:520
msgid ""
"Returns ``0`` on success, a negative error code otherwise. This function "
"will immediately fail if the device is not available, thus can be safely "
"used in IRQ context."
msgstr ""

#: ../../../hid/hid-bpf:204: drivers/hid/bpf/hid_bpf_dispatch.c:544
msgid ""
"Returns ``0`` on success, a negative error code otherwise. This function "
"will wait for the device to be available before injecting the event, thus "
"needs to be called in sleepable context."
msgstr ""

#: ../../../hid/hid-bpf.rst:208
msgid "General overview of a HID-BPF program"
msgstr ""

#: ../../../hid/hid-bpf.rst:211
msgid "Accessing the data attached to the context"
msgstr ""

#: ../../../hid/hid-bpf.rst:213
msgid ""
"The ``struct hid_bpf_ctx`` doesn't export the ``data`` fields directly and "
"to access it, a bpf program needs to first call :c:func:`hid_bpf_get_data`."
msgstr ""

#: ../../../hid/hid-bpf.rst:216
msgid ""
"``offset`` can be any integer, but ``size`` needs to be constant, known at "
"compile time."
msgstr ""

#: ../../../hid/hid-bpf.rst:219
msgid "This allows the following:"
msgstr ""

#: ../../../hid/hid-bpf.rst:221
msgid ""
"for a given device, if we know that the report length will always be of a "
"certain value, we can request the ``data`` pointer to point at the full "
"report length."
msgstr ""

#: ../../../hid/hid-bpf.rst:224
msgid ""
"The kernel will ensure we are using a correct size and offset and eBPF will "
"ensure the code will not attempt to read or write outside of the boundaries::"
msgstr ""

#: ../../../hid/hid-bpf.rst:235
msgid ""
"if the report length is variable, but we know the value of ``X`` is always a "
"16-bit integer, we can then have a pointer to that value only::"
msgstr ""

#: ../../../hid/hid-bpf.rst:246
msgid "Effect of a HID-BPF program"
msgstr ""

#: ../../../hid/hid-bpf.rst:248
msgid ""
"For all HID-BPF attachment types except for :c:func:`hid_rdesc_fixup`, "
"several eBPF programs can be attached to the same device. If a HID-BPF "
"struct_ops has a :c:func:`hid_rdesc_fixup` while another is already attached "
"to the device, the kernel will return `-EINVAL` when attaching the "
"struct_ops."
msgstr ""

#: ../../../hid/hid-bpf.rst:253
msgid ""
"Unless ``BPF_F_BEFORE`` is added to the flags while attaching the program, "
"the new program is appended at the end of the list. ``BPF_F_BEFORE`` will "
"insert the new program at the beginning of the list which is useful for e.g. "
"tracing where we need to get the unprocessed events from the device."
msgstr ""

#: ../../../hid/hid-bpf.rst:258
msgid ""
"Note that if there are multiple programs using the ``BPF_F_BEFORE`` flag, "
"only the most recently loaded one is actually the first in the list."
msgstr ""

#: ../../../hid/hid-bpf.rst:262
msgid "``SEC(\"struct_ops/hid_device_event\")``"
msgstr ""

#: ../../../hid/hid-bpf.rst:264
msgid ""
"Whenever a matching event is raised, the eBPF programs are called one after "
"the other and are working on the same data buffer."
msgstr ""

#: ../../../hid/hid-bpf.rst:267
msgid ""
"If a program changes the data associated with the context, the next one will "
"see the modified data but it will have *no* idea of what the original data "
"was."
msgstr ""

#: ../../../hid/hid-bpf.rst:270
msgid ""
"Once all the programs are run and return ``0`` or a positive value, the rest "
"of the HID stack will work on the modified data, with the ``size`` field of "
"the last hid_bpf_ctx being the new size of the input stream of data."
msgstr ""

#: ../../../hid/hid-bpf.rst:274
msgid ""
"A BPF program returning a negative error discards the event, i.e. this event "
"will not be processed by the HID stack. Clients (hidraw, input, LEDs) will "
"**not** see this event."
msgstr ""

#: ../../../hid/hid-bpf.rst:278
msgid "``SEC(\"syscall\")``"
msgstr ""

#: ../../../hid/hid-bpf.rst:280
msgid ""
"``syscall`` are not attached to a given device. To tell which device we are "
"working with, userspace needs to refer to the device by its unique system id "
"(the last 4 numbers in the sysfs path: ``/sys/bus/hid/devices/xxxx:yyyy:"
"zzzz:0000``)."
msgstr ""

#: ../../../hid/hid-bpf.rst:284
msgid ""
"To retrieve a context associated with the device, the program must call "
"hid_bpf_allocate_context() and must release it with "
"hid_bpf_release_context() before returning. Once the context is retrieved, "
"one can also request a pointer to kernel memory with hid_bpf_get_data(). "
"This memory is big enough to support all input/output/feature reports of the "
"given device."
msgstr ""

#: ../../../hid/hid-bpf.rst:292
msgid "``SEC(\"struct_ops/hid_rdesc_fixup\")``"
msgstr ""

#: ../../../hid/hid-bpf.rst:294
msgid ""
"The ``hid_rdesc_fixup`` program works in a similar manner to ``."
"report_fixup`` of ``struct hid_driver``."
msgstr ""

#: ../../../hid/hid-bpf.rst:297
msgid ""
"When the device is probed, the kernel sets the data buffer of the context "
"with the content of the report descriptor. The memory associated with that "
"buffer is ``HID_MAX_DESCRIPTOR_SIZE`` (currently 4kB)."
msgstr ""

#: ../../../hid/hid-bpf.rst:301
msgid ""
"The eBPF program can modify the data buffer at-will and the kernel uses the "
"modified content and size as the report descriptor."
msgstr ""

#: ../../../hid/hid-bpf.rst:304
msgid ""
"Whenever a struct_ops containing a ``SEC(\"struct_ops/hid_rdesc_fixup\")`` "
"program is attached (if no program was attached before), the kernel "
"immediately disconnects the HID device and does a reprobe."
msgstr ""

#: ../../../hid/hid-bpf.rst:308
msgid ""
"In the same way, when this struct_ops is detached, the kernel issues a "
"disconnect on the device."
msgstr ""

#: ../../../hid/hid-bpf.rst:311
msgid ""
"There is no ``detach`` facility in HID-BPF. Detaching a program happens when "
"all the user space file descriptors pointing at a HID-BPF struct_ops link "
"are closed. Thus, if we need to replace a report descriptor fixup, some "
"cooperation is required from the owner of the original report descriptor "
"fixup. The previous owner will likely pin the struct_ops link in the bpffs, "
"and we can then replace it through normal bpf operations."
msgstr ""

#: ../../../hid/hid-bpf.rst:319
msgid "Attaching a bpf program to a device"
msgstr ""

#: ../../../hid/hid-bpf.rst:321
msgid ""
"We now use standard struct_ops attachment through "
"``bpf_map__attach_struct_ops()``. But given that we need to attach a "
"struct_ops to a dedicated HID device, the caller must set ``hid_id`` in the "
"struct_ops map before loading the program in the kernel."
msgstr ""

#: ../../../hid/hid-bpf.rst:325
msgid ""
"``hid_id`` is the unique system ID of the HID device (the last 4 numbers in "
"the sysfs path: ``/sys/bus/hid/devices/xxxx:yyyy:zzzz:0000``)"
msgstr ""

#: ../../../hid/hid-bpf.rst:328
msgid ""
"One can also set ``flags``, which is of type ``enum hid_bpf_attach_flags``."
msgstr ""

#: ../../../hid/hid-bpf.rst:330
msgid ""
"We can not rely on hidraw to bind a BPF program to a HID device. hidraw is "
"an artefact of the processing of the HID device, and is not stable. Some "
"drivers even disable it, so that removes the tracing capabilities on those "
"devices (where it is interesting to get the non-hidraw traces)."
msgstr ""

#: ../../../hid/hid-bpf.rst:335
msgid ""
"On the other hand, the ``hid_id`` is stable for the entire life of the HID "
"device, even if we change its report descriptor."
msgstr ""

#: ../../../hid/hid-bpf.rst:338
msgid ""
"Given that hidraw is not stable when the device disconnects/reconnects, we "
"recommend accessing the current report descriptor of the device through the "
"sysfs. This is available at ``/sys/bus/hid/devices/BUS:VID:PID.000N/"
"report_descriptor`` as a binary stream."
msgstr ""

#: ../../../hid/hid-bpf.rst:343
msgid ""
"Parsing the report descriptor is the responsibility of the BPF programmer or "
"the userspace component that loads the eBPF program."
msgstr ""

#: ../../../hid/hid-bpf.rst:347
msgid "An (almost) complete example of a BPF enhanced HID device"
msgstr ""

#: ../../../hid/hid-bpf.rst:349
msgid ""
"*Foreword: for most parts, this could be implemented as a kernel driver*"
msgstr ""

#: ../../../hid/hid-bpf.rst:351
msgid ""
"Let's imagine we have a new tablet device that has some haptic capabilities "
"to simulate the surface the user is scratching on. This device would also "
"have a specific 3 positions switch to toggle between *pencil on paper*, "
"*cray on a wall* and *brush on a painting canvas*. To make things even "
"better, we can control the physical position of the switch through a feature "
"report."
msgstr ""

#: ../../../hid/hid-bpf.rst:357
msgid ""
"And of course, the switch is relying on some userspace component to control "
"the haptic feature of the device itself."
msgstr ""

#: ../../../hid/hid-bpf.rst:361
msgid "Filtering events"
msgstr ""

#: ../../../hid/hid-bpf.rst:363
msgid ""
"The first step consists in filtering events from the device. Given that the "
"switch position is actually reported in the flow of the pen events, using "
"hidraw to implement that filtering would mean that we wake up userspace for "
"every single event."
msgstr ""

#: ../../../hid/hid-bpf.rst:367
msgid ""
"This is OK for libinput, but having an external library that is just "
"interested in one byte in the report is less than ideal."
msgstr ""

#: ../../../hid/hid-bpf.rst:370
msgid "For that, we can create a basic skeleton for our BPF program::"
msgstr ""

#: ../../../hid/hid-bpf.rst:421
msgid "To attach ``haptic_tablet``, userspace needs to set ``hid_id`` first::"
msgstr ""

#: ../../../hid/hid-bpf.rst:441
msgid ""
"Our userspace program can now listen to notifications on the ring buffer, "
"and is awaken only when the value changes."
msgstr ""

#: ../../../hid/hid-bpf.rst:444
msgid ""
"When the userspace program doesn't need to listen to events anymore, it can "
"just close the returned bpf link from :c:func:`attach_filter`, which will "
"tell the kernel to detach the program from the HID device."
msgstr ""

#: ../../../hid/hid-bpf.rst:448
msgid ""
"Of course, in other use cases, the userspace program can also pin the fd to "
"the BPF filesystem through a call to :c:func:`bpf_obj_pin`, as with any "
"bpf_link."
msgstr ""

#: ../../../hid/hid-bpf.rst:452
msgid "Controlling the device"
msgstr ""

#: ../../../hid/hid-bpf.rst:454
msgid ""
"To be able to change the haptic feedback from the tablet, the userspace "
"program needs to emit a feature report on the device itself."
msgstr ""

#: ../../../hid/hid-bpf.rst:457
msgid ""
"Instead of using hidraw for that, we can create a ``SEC(\"syscall\")`` "
"program that talks to the device::"
msgstr ""

#: ../../../hid/hid-bpf.rst:497
msgid "And then userspace needs to call that program directly::"
msgstr ""

#: ../../../hid/hid-bpf.rst:520
msgid ""
"Now our userspace program is aware of the haptic state and can control it. "
"The program could make this state further available to other userspace "
"programs (e.g. via a DBus API)."
msgstr ""

#: ../../../hid/hid-bpf.rst:524
msgid ""
"The interesting bit here is that we did not created a new kernel API for "
"this. Which means that if there is a bug in our implementation, we can "
"change the interface with the kernel at-will, because the userspace "
"application is responsible for its own usage."
msgstr ""
