# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/msm-preemption.rst:7
msgid "MSM Preemption"
msgstr ""

#: ../../../gpu/msm-preemption.rst:9
msgid ""
"Preemption allows Adreno GPUs to switch to a higher priority ring when work "
"is pushed to it, reducing latency for high priority submissions."
msgstr ""

#: ../../../gpu/msm-preemption.rst:12
msgid ""
"When preemption is enabled 4 rings are initialized, corresponding to "
"different priority levels. Having multiple rings is purely a software "
"concept as the GPU only has registers to keep track of one graphics ring. "
"The kernel is able to switch which ring is currently being processed by "
"requesting preemption. When certain conditions are met, depending on the "
"priority level, the GPU will save its current state in a series of buffers, "
"then restores state from a similar set of buffers specified by the kernel. "
"It then resumes execution and fires an IRQ to let the kernel know the "
"context switch has completed."
msgstr ""

#: ../../../gpu/msm-preemption.rst:22
msgid ""
"This mechanism can be used by the kernel to switch between rings. Whenever a "
"submission occurs the kernel finds the highest priority ring which isn't "
"empty and preempts to it if said ring is not the one being currently "
"executed. This is also done whenever a submission completes to make sure "
"execution resumes on a lower priority ring when a higher priority ring is "
"done."
msgstr ""

#: ../../../gpu/msm-preemption.rst:29
msgid "Preemption levels"
msgstr ""

#: ../../../gpu/msm-preemption.rst:31
msgid ""
"Preemption can only occur at certain boundaries. The exact conditions can be "
"configured by changing the preemption level, this allows to compromise "
"between latency (ie. the time that passes between when the kernel requests "
"preemption and when the SQE begins saving state) and overhead (the amount of "
"state that needs to be saved)."
msgstr ""

#: ../../../gpu/msm-preemption.rst:37
msgid "The GPU offers 3 levels:"
msgstr ""

#: ../../../gpu/msm-preemption.rst:39
msgid "Level 0"
msgstr ""

#: ../../../gpu/msm-preemption.rst:40
msgid ""
"Preemption only occurs at the submission level. This requires the least "
"amount of state to be saved as the execution of userspace submitted IBs is "
"never interrupted, however it offers very little benefit compared to not "
"enabling preemption of any kind."
msgstr ""

#: ../../../gpu/msm-preemption.rst:45
msgid "Level 1"
msgstr ""

#: ../../../gpu/msm-preemption.rst:46
msgid ""
"Preemption occurs at either bin level, if using GMEM rendering, or draw "
"level in the sysmem rendering case."
msgstr ""

#: ../../../gpu/msm-preemption.rst:49
msgid "Level 2"
msgstr ""

#: ../../../gpu/msm-preemption.rst:50
msgid "Preemption occurs at draw level."
msgstr ""

#: ../../../gpu/msm-preemption.rst:52
msgid "Level 1 is the mode that is used by the msm driver."
msgstr ""

#: ../../../gpu/msm-preemption.rst:54
msgid ""
"Additionally the GPU allows to specify a `skip_save_restore` option. This "
"disables the saving and restoring of all registers except those relating to "
"the operation of the SQE itself, reducing overhead. Saving and restoring is "
"only skipped when using GMEM with Level 1 preemption. When enabling this "
"userspace is expected to set the state that isn't preserved whenever "
"preemption occurs which is done by specifying preamble and postambles. Those "
"are IBs that are executed before and after preemption."
msgstr ""

#: ../../../gpu/msm-preemption.rst:63
msgid "Preemption buffers"
msgstr ""

#: ../../../gpu/msm-preemption.rst:65
msgid ""
"A series of buffers are necessary to store the state of rings while they are "
"not being executed. There are different kinds of preemption records and most "
"of those require one buffer per ring. This is because preemption never "
"occurs between submissions on the same ring, which always run in sequence "
"when the ring is active. This means that only one context per ring is "
"effectively active."
msgstr ""

#: ../../../gpu/msm-preemption.rst:71
msgid "SMMU_INFO"
msgstr ""

#: ../../../gpu/msm-preemption.rst:72
msgid ""
"This buffer contains info about the current SMMU configuration such as the "
"ttbr0 register. The SQE firmware isn't actually able to save this record. As "
"a result SMMU info must be saved manually from the CP to a buffer and the "
"SMMU record updated with info from said buffer before triggering preemption."
msgstr ""

#: ../../../gpu/msm-preemption.rst:78
msgid "NON_SECURE"
msgstr ""

#: ../../../gpu/msm-preemption.rst:79
msgid ""
"This is the main preemption record where most state is saved. It is mostly "
"opaque to the kernel except for the first few words that must be initialized "
"by the kernel."
msgstr ""

#: ../../../gpu/msm-preemption.rst:83
msgid "SECURE"
msgstr ""

#: ../../../gpu/msm-preemption.rst:84
msgid "This saves state related to the GPU's secure mode."
msgstr ""

#: ../../../gpu/msm-preemption.rst:86
msgid "NON_PRIV"
msgstr ""

#: ../../../gpu/msm-preemption.rst:87
msgid ""
"The intended purpose of this record is unknown. The SQE firmware actually "
"ignores it and therefore msm doesn't handle it."
msgstr ""

#: ../../../gpu/msm-preemption.rst:90
msgid "COUNTER"
msgstr ""

#: ../../../gpu/msm-preemption.rst:91
msgid "This record is used to save and restore performance counters."
msgstr ""

#: ../../../gpu/msm-preemption.rst:93
msgid ""
"Handling the permissions of those buffers is critical for security. All but "
"the NON_PRIV records need to be inaccessible from userspace, so they must be "
"mapped in the kernel address space with the MSM_BO_MAP_PRIV flag. For "
"example, making the NON_SECURE record accessible from userspace would allow "
"any process to manipulate a saved ring's RPTR which can be used to skip the "
"execution of some packets in a ring and execute user commands with higher "
"privileges."
msgstr ""
