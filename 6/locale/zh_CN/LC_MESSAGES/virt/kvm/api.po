# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../virt/kvm/api.rst:5
msgid "The Definitive KVM (Kernel-based Virtual Machine) API Documentation"
msgstr ""

#: ../../../virt/kvm/api.rst:8
msgid "1. General description"
msgstr ""

#: ../../../virt/kvm/api.rst:10
msgid ""
"The kvm API is centered around different kinds of file descriptors and "
"ioctls that can be issued to these file descriptors.  An initial open(\"/dev/"
"kvm\") obtains a handle to the kvm subsystem; this handle can be used to "
"issue system ioctls.  A KVM_CREATE_VM ioctl on this handle will create a VM "
"file descriptor which can be used to issue VM ioctls.  A KVM_CREATE_VCPU or "
"KVM_CREATE_DEVICE ioctl on a VM fd will create a virtual cpu or device and "
"return a file descriptor pointing to the new resource."
msgstr ""

#: ../../../virt/kvm/api.rst:19
msgid ""
"In other words, the kvm API is a set of ioctls that are issued to different "
"kinds of file descriptor in order to control various aspects of a virtual "
"machine.  Depending on the file descriptor that accepts them, ioctls belong "
"to the following classes:"
msgstr ""

#: ../../../virt/kvm/api.rst:24
msgid ""
"System ioctls: These query and set global attributes which affect the whole "
"kvm subsystem.  In addition a system ioctl is used to create virtual "
"machines."
msgstr ""

#: ../../../virt/kvm/api.rst:28
msgid ""
"VM ioctls: These query and set attributes that affect an entire virtual "
"machine, for example memory layout.  In addition a VM ioctl is used to "
"create virtual cpus (vcpus) and devices."
msgstr ""

#: ../../../virt/kvm/api.rst:32
msgid ""
"VM ioctls must be issued from the same process (address space) that was used "
"to create the VM."
msgstr ""

#: ../../../virt/kvm/api.rst:35
msgid ""
"vcpu ioctls: These query and set attributes that control the operation of a "
"single virtual cpu."
msgstr ""

#: ../../../virt/kvm/api.rst:38
msgid ""
"vcpu ioctls should be issued from the same thread that was used to create "
"the vcpu, except for asynchronous vcpu ioctl that are marked as such in the "
"documentation.  Otherwise, the first ioctl after switching threads could see "
"a performance impact."
msgstr ""

#: ../../../virt/kvm/api.rst:43
msgid ""
"device ioctls: These query and set attributes that control the operation of "
"a single device."
msgstr ""

#: ../../../virt/kvm/api.rst:46
msgid ""
"device ioctls must be issued from the same process (address space) that was "
"used to create the VM."
msgstr ""

#: ../../../virt/kvm/api.rst:49
msgid ""
"While most ioctls are specific to one kind of file descriptor, in some cases "
"the same ioctl can belong to more than one class."
msgstr ""

#: ../../../virt/kvm/api.rst:52
msgid ""
"The KVM API grew over time.  For this reason, KVM defines many constants of "
"the form ``KVM_CAP_*``, each corresponding to a set of functionality "
"provided by one or more ioctls.  Availability of these \"capabilities\" can "
"be checked with :ref:`KVM_CHECK_EXTENSION <KVM_CHECK_EXTENSION>`.  Some "
"capabilities also need to be enabled for VMs or VCPUs where their "
"functionality is desired (see :ref:`cap_enable` and :ref:`cap_enable_vm`)."
msgstr ""

#: ../../../virt/kvm/api.rst:61
msgid "2. Restrictions"
msgstr ""

#: ../../../virt/kvm/api.rst:63
msgid ""
"In general file descriptors can be migrated among processes by means of "
"fork() and the SCM_RIGHTS facility of unix domain socket.  These kinds of "
"tricks are explicitly not supported by kvm.  While they will not cause harm "
"to the host, their actual behavior is not guaranteed by the API.  See "
"\"General description\" for details on the ioctl usage model that is "
"supported by KVM."
msgstr ""

#: ../../../virt/kvm/api.rst:70
msgid ""
"It is important to note that although VM ioctls may only be issued from the "
"process that created the VM, a VM's lifecycle is associated with its file "
"descriptor, not its creator (process).  In other words, the VM and its "
"resources, *including the associated address space*, are not freed until the "
"last reference to the VM's file descriptor has been released. For example, "
"if fork() is issued after ioctl(KVM_CREATE_VM), the VM will not be freed "
"until both the parent (original) process and its child have put their "
"references to the VM's file descriptor."
msgstr ""

#: ../../../virt/kvm/api.rst:79
msgid ""
"Because a VM's resources are not freed until the last reference to its file "
"descriptor is released, creating additional references to a VM via fork(), "
"dup(), etc... without careful consideration is strongly discouraged and may "
"have unwanted side effects, e.g. memory allocated by and on behalf of the "
"VM's process may not be freed/unaccounted when the VM is shut down."
msgstr ""

#: ../../../virt/kvm/api.rst:88
msgid "3. Extensions"
msgstr ""

#: ../../../virt/kvm/api.rst:90
msgid ""
"As of Linux 2.6.22, the KVM ABI has been stabilized: no backward "
"incompatible change are allowed.  However, there is an extension facility "
"that allows backward-compatible extensions to the API to be queried and used."
msgstr ""

#: ../../../virt/kvm/api.rst:95
msgid ""
"The extension mechanism is not based on the Linux version number. Instead, "
"kvm defines extension identifiers and a facility to query whether a "
"particular extension identifier is available.  If it is, a set of ioctls is "
"available for application use."
msgstr ""

#: ../../../virt/kvm/api.rst:102
msgid "4. API description"
msgstr ""

#: ../../../virt/kvm/api.rst:104
msgid ""
"This section describes ioctls that can be used to control kvm guests. For "
"each ioctl, the following information is provided along with a description:"
msgstr ""

#: ../../../virt/kvm/api.rst:108
msgid "Capability:"
msgstr ""

#: ../../../virt/kvm/api.rst:109
msgid ""
"which KVM extension provides this ioctl.  Can be 'basic', which means that "
"is will be provided by any kernel that supports API version 12 (see :ref:"
"`KVM_GET_API_VERSION <KVM_GET_API_VERSION>`), or a KVM_CAP_xyz constant that "
"can be checked with :ref:`KVM_CHECK_EXTENSION <KVM_CHECK_EXTENSION>`."
msgstr ""

#: ../../../virt/kvm/api.rst:115 ../../../virt/kvm/api.rst:7295
#: ../../../virt/kvm/api.rst:7625
msgid "Architectures:"
msgstr ""

#: ../../../virt/kvm/api.rst:116 ../../../virt/kvm/api.rst:7296
#: ../../../virt/kvm/api.rst:7626
msgid ""
"which instruction set architectures provide this ioctl. x86 includes both "
"i386 and x86_64."
msgstr ""

#: ../../../virt/kvm/api.rst:119
msgid "Type:"
msgstr ""

#: ../../../virt/kvm/api.rst:120
msgid "system, vm, or vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:122 ../../../virt/kvm/api.rst:7302
#: ../../../virt/kvm/api.rst:7629
msgid "Parameters:"
msgstr ""

#: ../../../virt/kvm/api.rst:123
msgid "what parameters are accepted by the ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:125 ../../../virt/kvm/api.rst:7305
#: ../../../virt/kvm/api.rst:7632
msgid "Returns:"
msgstr ""

#: ../../../virt/kvm/api.rst:126 ../../../virt/kvm/api.rst:7306
#: ../../../virt/kvm/api.rst:7633
msgid ""
"the return value.  General error numbers (EBADF, ENOMEM, EINVAL) are not "
"detailed, but errors with specific meanings are."
msgstr ""

#: ../../../virt/kvm/api.rst:133
msgid "4.1 KVM_GET_API_VERSION"
msgstr ""

#: ../../../virt/kvm/api.rst:0
msgid "Capability"
msgstr ""

#: ../../../virt/kvm/api.rst:135 ../../../virt/kvm/api.rst:152
#: ../../../virt/kvm/api.rst:284 ../../../virt/kvm/api.rst:310
#: ../../../virt/kvm/api.rst:357 ../../../virt/kvm/api.rst:395
#: ../../../virt/kvm/api.rst:422 ../../../virt/kvm/api.rst:462
#: ../../../virt/kvm/api.rst:476 ../../../virt/kvm/api.rst:507
#: ../../../virt/kvm/api.rst:520 ../../../virt/kvm/api.rst:547
#: ../../../virt/kvm/api.rst:686 ../../../virt/kvm/api.rst:708
#: ../../../virt/kvm/api.rst:748 ../../../virt/kvm/api.rst:774
#: ../../../virt/kvm/api.rst:812 ../../../virt/kvm/api.rst:3235
#: ../../../virt/kvm/api.rst:3445 ../../../virt/kvm/api.rst:3555
#: ../../../virt/kvm/api.rst:3584 ../../../virt/kvm/api.rst:4791
#: ../../../virt/kvm/api.rst:4810 ../../../virt/kvm/api.rst:4834
#: ../../../virt/kvm/api.rst:5267 ../../../virt/kvm/api.rst:5303
msgid "basic"
msgstr ""

#: ../../../virt/kvm/api.rst:0
msgid "Architectures"
msgstr ""

#: ../../../virt/kvm/api.rst:136 ../../../virt/kvm/api.rst:153
#: ../../../virt/kvm/api.rst:266 ../../../virt/kvm/api.rst:285
#: ../../../virt/kvm/api.rst:311 ../../../virt/kvm/api.rst:358
#: ../../../virt/kvm/api.rst:396 ../../../virt/kvm/api.rst:749
#: ../../../virt/kvm/api.rst:1354 ../../../virt/kvm/api.rst:1464
#: ../../../virt/kvm/api.rst:2091 ../../../virt/kvm/api.rst:2301
#: ../../../virt/kvm/api.rst:2916 ../../../virt/kvm/api.rst:3346
#: ../../../virt/kvm/api.rst:4969 ../../../virt/kvm/api.rst:5883
#: ../../../virt/kvm/api.rst:6293 ../../../virt/kvm/api.rst:8018
msgid "all"
msgstr ""

#: ../../../virt/kvm/api.rst:0
msgid "Type"
msgstr ""

#: ../../../virt/kvm/api.rst:137 ../../../virt/kvm/api.rst:154
#: ../../../virt/kvm/api.rst:223 ../../../virt/kvm/api.rst:286
#: ../../../virt/kvm/api.rst:1761 ../../../virt/kvm/api.rst:3764
#: ../../../virt/kvm/api.rst:4531 ../../../virt/kvm/api.rst:9115
msgid "system ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:0
msgid "Parameters"
msgstr ""

#: ../../../virt/kvm/api.rst:138 ../../../virt/kvm/api.rst:287
#: ../../../virt/kvm/api.rst:398 ../../../virt/kvm/api.rst:853
#: ../../../virt/kvm/api.rst:2024 ../../../virt/kvm/api.rst:2214
#: ../../../virt/kvm/api.rst:4178 ../../../virt/kvm/api.rst:5270
#: ../../../virt/kvm/api.rst:5294 ../../../virt/kvm/api.rst:5306
#: ../../../virt/kvm/api.rst:5319 ../../../virt/kvm/api.rst:5885
#: ../../../virt/kvm/api.rst:6135 ../../../virt/kvm/api.rst:6380
#: ../../../virt/kvm/api.rst:6423 ../../../virt/kvm/api.rst:7315
#: ../../../virt/kvm/api.rst:7331 ../../../virt/kvm/api.rst:7399
#: ../../../virt/kvm/api.rst:7456 ../../../virt/kvm/api.rst:7493
#: ../../../virt/kvm/api.rst:7663 ../../../virt/kvm/api.rst:7685
#: ../../../virt/kvm/api.rst:7696 ../../../virt/kvm/api.rst:7747
#: ../../../virt/kvm/api.rst:7780 ../../../virt/kvm/api.rst:7795
#: ../../../virt/kvm/api.rst:7805 ../../../virt/kvm/api.rst:7832
#: ../../../virt/kvm/api.rst:7891 ../../../virt/kvm/api.rst:7919
#: ../../../virt/kvm/api.rst:8111 ../../../virt/kvm/api.rst:8179
msgid "none"
msgstr ""

#: ../../../virt/kvm/api.rst:0
msgid "Returns"
msgstr ""

#: ../../../virt/kvm/api.rst:139
msgid "the constant KVM_API_VERSION (=12)"
msgstr ""

#: ../../../virt/kvm/api.rst:141
msgid ""
"This identifies the API version as the stable kvm API. It is not expected "
"that this number will change.  However, Linux 2.6.20 and 2.6.21 report "
"earlier versions; these are not documented and not supported.  Applications "
"should refuse to run if KVM_GET_API_VERSION returns a value other than 12.  "
"If this check passes, all ioctls described as 'basic' will be available."
msgstr ""

#: ../../../virt/kvm/api.rst:150
msgid "4.2 KVM_CREATE_VM"
msgstr ""

#: ../../../virt/kvm/api.rst:155
msgid "machine type identifier (KVM_VM_*)"
msgstr ""

#: ../../../virt/kvm/api.rst:156
msgid "a VM fd that can be used to control the new virtual machine."
msgstr ""

#: ../../../virt/kvm/api.rst:158
msgid ""
"The new VM has no virtual cpus and no memory. You probably want to use 0 as "
"machine type."
msgstr ""

#: ../../../virt/kvm/api.rst:162 ../../../virt/kvm/api.rst:564
#: ../../../virt/kvm/api.rst:1134 ../../../virt/kvm/api.rst:1257
msgid "X86:"
msgstr ""

#: ../../../virt/kvm/api.rst:164
msgid "Supported X86 VM types can be queried via KVM_CAP_VM_TYPES."
msgstr ""

#: ../../../virt/kvm/api.rst:167 ../../../virt/kvm/api.rst:1427
#: ../../../virt/kvm/api.rst:6335
msgid "S390:"
msgstr ""

#: ../../../virt/kvm/api.rst:169
msgid ""
"In order to create user controlled virtual machines on S390, check "
"KVM_CAP_S390_UCONTROL and use the flag KVM_VM_S390_UCONTROL as privileged "
"user (CAP_SYS_ADMIN)."
msgstr ""

#: ../../../virt/kvm/api.rst:174 ../../../virt/kvm/api.rst:610
msgid "MIPS:"
msgstr ""

#: ../../../virt/kvm/api.rst:176
msgid ""
"To use hardware assisted virtualization on MIPS (VZ ASE) rather than the "
"default trap & emulate implementation (which changes the virtual memory "
"layout to fit in user mode), check KVM_CAP_MIPS_VZ and use the flag "
"KVM_VM_MIPS_VZ."
msgstr ""

#: ../../../virt/kvm/api.rst:182 ../../../virt/kvm/api.rst:1192
#: ../../../virt/kvm/api.rst:1291
msgid "ARM64:"
msgstr ""

#: ../../../virt/kvm/api.rst:184
msgid ""
"On arm64, the physical address size for a VM (IPA Size limit) is limited to "
"40bits by default. The limit can be configured if the host supports the "
"extension KVM_CAP_ARM_VM_IPA_SIZE. When supported, use "
"KVM_VM_TYPE_ARM_IPA_SIZE(IPA_Bits) to set the size in the machine type "
"identifier, where IPA_Bits is the maximum width of any physical address used "
"by the VM. The IPA_Bits is encoded in bits[7-0] of the machine type "
"identifier."
msgstr ""

#: ../../../virt/kvm/api.rst:192
msgid "e.g, to configure a guest to use 48bit physical address size::"
msgstr ""

#: ../../../virt/kvm/api.rst:196
msgid "The requested size (IPA_Bits) must be:"
msgstr ""

#: ../../../virt/kvm/api.rst:199 ../../../virt/kvm/api.rst:569
#: ../../../virt/kvm/api.rst:5295 ../../../virt/kvm/api.rst:5307
#: ../../../virt/kvm/api.rst:5320 ../../../virt/kvm/api.rst:8724
#: ../../../virt/kvm/api.rst:8746
msgid "0"
msgstr ""

#: ../../../virt/kvm/api.rst:199
msgid "Implies default size, 40bits (for backward compatibility)"
msgstr ""

#: ../../../virt/kvm/api.rst:200
msgid "N"
msgstr ""

#: ../../../virt/kvm/api.rst:200
msgid ""
"Implies N bits, where N is a positive integer such that, 32 <= N <= "
"Host_IPA_Limit"
msgstr ""

#: ../../../virt/kvm/api.rst:204
msgid ""
"Host_IPA_Limit is the maximum possible value for IPA_Bits on the host and is "
"dependent on the CPU capability and the kernel configuration. The limit can "
"be retrieved using KVM_CAP_ARM_VM_IPA_SIZE of the KVM_CHECK_EXTENSION "
"ioctl() at run-time."
msgstr ""

#: ../../../virt/kvm/api.rst:209
msgid ""
"Creation of the VM will fail if the requested IPA size (whether it is "
"implicit or explicit) is unsupported on the host."
msgstr ""

#: ../../../virt/kvm/api.rst:212
msgid ""
"Please note that configuring the IPA size does not affect the capability "
"exposed by the guest CPUs in ID_AA64MMFR0_EL1[PARange]. It only affects size "
"of the address translated by the stage2 level (guest physical to host "
"physical address translations)."
msgstr ""

#: ../../../virt/kvm/api.rst:219
msgid "4.3 KVM_GET_MSR_INDEX_LIST, KVM_GET_MSR_FEATURE_INDEX_LIST"
msgstr ""

#: ../../../virt/kvm/api.rst:221
msgid "basic, KVM_CAP_GET_MSR_FEATURES for KVM_GET_MSR_FEATURE_INDEX_LIST"
msgstr ""

#: ../../../virt/kvm/api.rst:222 ../../../virt/kvm/api.rst:521
#: ../../../virt/kvm/api.rst:647 ../../../virt/kvm/api.rst:687
#: ../../../virt/kvm/api.rst:709 ../../../virt/kvm/api.rst:942
#: ../../../virt/kvm/api.rst:967 ../../../virt/kvm/api.rst:992
#: ../../../virt/kvm/api.rst:1042 ../../../virt/kvm/api.rst:1092
#: ../../../virt/kvm/api.rst:1317 ../../../virt/kvm/api.rst:1339
#: ../../../virt/kvm/api.rst:1436 ../../../virt/kvm/api.rst:1619
#: ../../../virt/kvm/api.rst:1643 ../../../virt/kvm/api.rst:1658
#: ../../../virt/kvm/api.rst:1678 ../../../virt/kvm/api.rst:1706
#: ../../../virt/kvm/api.rst:1733 ../../../virt/kvm/api.rst:1760
#: ../../../virt/kvm/api.rst:1999 ../../../virt/kvm/api.rst:2022
#: ../../../virt/kvm/api.rst:2036 ../../../virt/kvm/api.rst:2067
#: ../../../virt/kvm/api.rst:2212 ../../../virt/kvm/api.rst:3009
#: ../../../virt/kvm/api.rst:3042 ../../../virt/kvm/api.rst:3070
#: ../../../virt/kvm/api.rst:3763 ../../../virt/kvm/api.rst:4176
#: ../../../virt/kvm/api.rst:4187 ../../../virt/kvm/api.rst:4333
#: ../../../virt/kvm/api.rst:4530 ../../../virt/kvm/api.rst:4543
#: ../../../virt/kvm/api.rst:4562 ../../../virt/kvm/api.rst:4792
#: ../../../virt/kvm/api.rst:4811 ../../../virt/kvm/api.rst:4835
#: ../../../virt/kvm/api.rst:4847 ../../../virt/kvm/api.rst:4882
#: ../../../virt/kvm/api.rst:4956 ../../../virt/kvm/api.rst:5039
#: ../../../virt/kvm/api.rst:5152 ../../../virt/kvm/api.rst:5534
#: ../../../virt/kvm/api.rst:5657 ../../../virt/kvm/api.rst:5670
#: ../../../virt/kvm/api.rst:5784 ../../../virt/kvm/api.rst:5837
#: ../../../virt/kvm/api.rst:5870 ../../../virt/kvm/api.rst:6086
#: ../../../virt/kvm/api.rst:6113 ../../../virt/kvm/api.rst:6344
#: ../../../virt/kvm/api.rst:7547 ../../../virt/kvm/api.rst:7563
#: ../../../virt/kvm/api.rst:7574 ../../../virt/kvm/api.rst:7590
#: ../../../virt/kvm/api.rst:7602 ../../../virt/kvm/api.rst:7725
#: ../../../virt/kvm/api.rst:7756 ../../../virt/kvm/api.rst:7843
#: ../../../virt/kvm/api.rst:7908 ../../../virt/kvm/api.rst:7933
#: ../../../virt/kvm/api.rst:8034 ../../../virt/kvm/api.rst:8066
#: ../../../virt/kvm/api.rst:8137 ../../../virt/kvm/api.rst:8160
#: ../../../virt/kvm/api.rst:8218 ../../../virt/kvm/api.rst:8346
#: ../../../virt/kvm/api.rst:8367 ../../../virt/kvm/api.rst:8396
#: ../../../virt/kvm/api.rst:8538 ../../../virt/kvm/api.rst:8559
#: ../../../virt/kvm/api.rst:8601 ../../../virt/kvm/api.rst:8816
#: ../../../virt/kvm/api.rst:8869 ../../../virt/kvm/api.rst:8894
#: ../../../virt/kvm/api.rst:8955 ../../../virt/kvm/api.rst:8966
#: ../../../virt/kvm/api.rst:8980 ../../../virt/kvm/api.rst:9114
#: ../../../virt/kvm/api.rst:9161 ../../../virt/kvm/api.rst:9181
msgid "x86"
msgstr ""

#: ../../../virt/kvm/api.rst:224
msgid "struct kvm_msr_list (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:225 ../../../virt/kvm/api.rst:1461
#: ../../../virt/kvm/api.rst:1467 ../../../virt/kvm/api.rst:1516
#: ../../../virt/kvm/api.rst:1597 ../../../virt/kvm/api.rst:3449
#: ../../../virt/kvm/api.rst:3559 ../../../virt/kvm/api.rst:3588
#: ../../../virt/kvm/api.rst:3705 ../../../virt/kvm/api.rst:4795
#: ../../../virt/kvm/api.rst:4814 ../../../virt/kvm/api.rst:4838
#: ../../../virt/kvm/api.rst:7316 ../../../virt/kvm/api.rst:7332
#: ../../../virt/kvm/api.rst:7353 ../../../virt/kvm/api.rst:7400
#: ../../../virt/kvm/api.rst:7419 ../../../virt/kvm/api.rst:8021
#: ../../../virt/kvm/api.rst:8037
msgid "0 on success; -1 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:227 ../../../virt/kvm/api.rst:401
#: ../../../virt/kvm/api.rst:2306 ../../../virt/kvm/api.rst:3351
#: ../../../virt/kvm/api.rst:3392 ../../../virt/kvm/api.rst:3428
#: ../../../virt/kvm/api.rst:3451 ../../../virt/kvm/api.rst:3561
#: ../../../virt/kvm/api.rst:3590 ../../../virt/kvm/api.rst:3638
#: ../../../virt/kvm/api.rst:4048 ../../../virt/kvm/api.rst:4601
#: ../../../virt/kvm/api.rst:4887 ../../../virt/kvm/api.rst:5114
#: ../../../virt/kvm/api.rst:5157 ../../../virt/kvm/api.rst:5273
#: ../../../virt/kvm/api.rst:5364 ../../../virt/kvm/api.rst:5888
#: ../../../virt/kvm/api.rst:6428
msgid "Errors:"
msgstr ""

#: ../../../virt/kvm/api.rst:230 ../../../virt/kvm/api.rst:4609
#: ../../../virt/kvm/api.rst:5160 ../../../virt/kvm/api.rst:6435
msgid "EFAULT"
msgstr ""

#: ../../../virt/kvm/api.rst:230
msgid "the msr index list cannot be read from or written to"
msgstr ""

#: ../../../virt/kvm/api.rst:231 ../../../virt/kvm/api.rst:3593
#: ../../../virt/kvm/api.rst:3644 ../../../virt/kvm/api.rst:4890
#: ../../../virt/kvm/api.rst:5162
msgid "E2BIG"
msgstr ""

#: ../../../virt/kvm/api.rst:231
msgid ""
"the msr index list is too big to fit in the array specified by the user."
msgstr ""

#: ../../../virt/kvm/api.rst:242
msgid ""
"The user fills in the size of the indices array in nmsrs, and in return kvm "
"adjusts nmsrs to reflect the actual number of msrs and fills in the indices "
"array with their numbers."
msgstr ""

#: ../../../virt/kvm/api.rst:246
msgid ""
"KVM_GET_MSR_INDEX_LIST returns the guest msrs that are supported.  The list "
"varies by kvm version and host processor, but does not change otherwise."
msgstr ""

#: ../../../virt/kvm/api.rst:249
msgid ""
"Note: if kvm indicates supports MCE (KVM_CAP_MCE), then the MCE bank MSRs "
"are not returned in the MSR list, as different vcpus can have a different "
"number of banks, as set via the KVM_X86_SETUP_MCE ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:253
msgid ""
"KVM_GET_MSR_FEATURE_INDEX_LIST returns the list of MSRs that can be passed "
"to the KVM_GET_MSRS system ioctl.  This lets userspace probe host "
"capabilities and processor features that are exposed via MSRs (e.g., VMX "
"capabilities). This list also varies by kvm version and host processor, but "
"does not change otherwise."
msgstr ""

#: ../../../virt/kvm/api.rst:263
msgid "4.4 KVM_CHECK_EXTENSION"
msgstr ""

#: ../../../virt/kvm/api.rst:265
msgid "basic, KVM_CAP_CHECK_EXTENSION_VM for vm ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:267
msgid "system ioctl, vm ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:268
msgid "extension identifier (KVM_CAP_*)"
msgstr ""

#: ../../../virt/kvm/api.rst:269
msgid "0 if unsupported; 1 (or some other positive integer) if supported"
msgstr ""

#: ../../../virt/kvm/api.rst:271
msgid ""
"The API allows the application to query about extensions to the core kvm "
"API.  Userspace passes an extension identifier (an integer) and receives an "
"integer that describes the extension availability. Generally 0 means no and "
"1 means yes, but some extensions may report additional information in the "
"integer return value."
msgstr ""

#: ../../../virt/kvm/api.rst:277
msgid ""
"Based on their initialization different VMs may have different capabilities. "
"It is thus encouraged to use the vm ioctl to query for capabilities "
"(available with KVM_CAP_CHECK_EXTENSION_VM on the vm fd)"
msgstr ""

#: ../../../virt/kvm/api.rst:282
msgid "4.5 KVM_GET_VCPU_MMAP_SIZE"
msgstr ""

#: ../../../virt/kvm/api.rst:288
msgid "size of vcpu mmap area, in bytes"
msgstr ""

#: ../../../virt/kvm/api.rst:290
msgid ""
"The KVM_RUN ioctl (cf.) communicates with userspace via a shared memory "
"region.  This ioctl returns the size of that region.  See the KVM_RUN "
"documentation for details."
msgstr ""

#: ../../../virt/kvm/api.rst:294
msgid ""
"Besides the size of the KVM_RUN communication region, other areas of the "
"VCPU file descriptor can be mmap-ed, including:"
msgstr ""

#: ../../../virt/kvm/api.rst:297
msgid ""
"if KVM_CAP_COALESCED_MMIO is available, a page at "
"KVM_COALESCED_MMIO_PAGE_OFFSET * PAGE_SIZE; for historical reasons, this "
"page is included in the result of KVM_GET_VCPU_MMAP_SIZE. "
"KVM_CAP_COALESCED_MMIO is not documented yet."
msgstr ""

#: ../../../virt/kvm/api.rst:302
msgid ""
"if KVM_CAP_DIRTY_LOG_RING is available, a number of pages at "
"KVM_DIRTY_LOG_PAGE_OFFSET * PAGE_SIZE.  For more information on "
"KVM_CAP_DIRTY_LOG_RING, see :ref:`KVM_CAP_DIRTY_LOG_RING`."
msgstr ""

#: ../../../virt/kvm/api.rst:308
msgid "4.7 KVM_CREATE_VCPU"
msgstr ""

#: ../../../virt/kvm/api.rst:312 ../../../virt/kvm/api.rst:359
#: ../../../virt/kvm/api.rst:852 ../../../virt/kvm/api.rst:874
#: ../../../virt/kvm/api.rst:943 ../../../virt/kvm/api.rst:968
#: ../../../virt/kvm/api.rst:993 ../../../virt/kvm/api.rst:1043
#: ../../../virt/kvm/api.rst:1093 ../../../virt/kvm/api.rst:1355
#: ../../../virt/kvm/api.rst:1437 ../../../virt/kvm/api.rst:1465
#: ../../../virt/kvm/api.rst:1620 ../../../virt/kvm/api.rst:1644
#: ../../../virt/kvm/api.rst:1853 ../../../virt/kvm/api.rst:1883
#: ../../../virt/kvm/api.rst:2092 ../../../virt/kvm/api.rst:2174
#: ../../../virt/kvm/api.rst:2971 ../../../virt/kvm/api.rst:3010
#: ../../../virt/kvm/api.rst:3043 ../../../virt/kvm/api.rst:3071
#: ../../../virt/kvm/api.rst:3086 ../../../virt/kvm/api.rst:3161
#: ../../../virt/kvm/api.rst:3200 ../../../virt/kvm/api.rst:3292
#: ../../../virt/kvm/api.rst:3347 ../../../virt/kvm/api.rst:3557
#: ../../../virt/kvm/api.rst:3634 ../../../virt/kvm/api.rst:3683
#: ../../../virt/kvm/api.rst:3984 ../../../virt/kvm/api.rst:4016
#: ../../../virt/kvm/api.rst:4188 ../../../virt/kvm/api.rst:4301
#: ../../../virt/kvm/api.rst:4334 ../../../virt/kvm/api.rst:4361
#: ../../../virt/kvm/api.rst:4395 ../../../virt/kvm/api.rst:4432
#: ../../../virt/kvm/api.rst:4486 ../../../virt/kvm/api.rst:4597
#: ../../../virt/kvm/api.rst:4698 ../../../virt/kvm/api.rst:4746
#: ../../../virt/kvm/api.rst:4848 ../../../virt/kvm/api.rst:4970
#: ../../../virt/kvm/api.rst:4998 ../../../virt/kvm/api.rst:5153
#: ../../../virt/kvm/api.rst:5269 ../../../virt/kvm/api.rst:5332
#: ../../../virt/kvm/api.rst:5535 ../../../virt/kvm/api.rst:5658
#: ../../../virt/kvm/api.rst:5800 ../../../virt/kvm/api.rst:6114
#: ../../../virt/kvm/api.rst:6159 ../../../virt/kvm/api.rst:6206
#: ../../../virt/kvm/api.rst:6246 ../../../virt/kvm/api.rst:6294
#: ../../../virt/kvm/api.rst:6345 ../../../virt/kvm/api.rst:6381
msgid "vm ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:313
msgid "vcpu id (apic id on x86)"
msgstr ""

#: ../../../virt/kvm/api.rst:314
msgid "vcpu fd on success, -1 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:316
msgid ""
"This API adds a vcpu to a virtual machine. No more than max_vcpus may be "
"added. The vcpu id is an integer in the range [0, max_vcpu_id)."
msgstr ""

#: ../../../virt/kvm/api.rst:319
msgid ""
"The recommended max_vcpus value can be retrieved using the KVM_CAP_NR_VCPUS "
"of the KVM_CHECK_EXTENSION ioctl() at run-time. The maximum possible value "
"for max_vcpus can be retrieved using the KVM_CAP_MAX_VCPUS of the "
"KVM_CHECK_EXTENSION ioctl() at run-time."
msgstr ""

#: ../../../virt/kvm/api.rst:324
msgid ""
"If the KVM_CAP_NR_VCPUS does not exist, you should assume that max_vcpus is "
"4 cpus max. If the KVM_CAP_MAX_VCPUS does not exist, you should assume that "
"max_vcpus is same as the value returned from KVM_CAP_NR_VCPUS."
msgstr ""

#: ../../../virt/kvm/api.rst:329
msgid ""
"The maximum possible value for max_vcpu_id can be retrieved using the "
"KVM_CAP_MAX_VCPU_ID of the KVM_CHECK_EXTENSION ioctl() at run-time."
msgstr ""

#: ../../../virt/kvm/api.rst:332
msgid ""
"If the KVM_CAP_MAX_VCPU_ID does not exist, you should assume that "
"max_vcpu_id is the same as the value returned from KVM_CAP_MAX_VCPUS."
msgstr ""

#: ../../../virt/kvm/api.rst:335
msgid ""
"On powerpc using book3s_hv mode, the vcpus are mapped onto virtual threads "
"in one or more virtual CPU cores.  (This is because the hardware requires "
"all the hardware threads in a CPU core to be in the same partition.)  The "
"KVM_CAP_PPC_SMT capability indicates the number of vcpus per virtual core "
"(vcore).  The vcore id is obtained by dividing the vcpu id by the number of "
"vcpus per vcore.  The vcpus in a given vcore will always be in the same "
"physical core as each other (though that might be a different physical core "
"from time to time). Userspace can control the threading (SMT) mode of the "
"guest by its allocation of vcpu ids.  For example, if userspace wants single-"
"threaded guest vcpus, it should make all vcpu ids be a multiple of the "
"number of vcpus per vcore."
msgstr ""

#: ../../../virt/kvm/api.rst:348
msgid ""
"For virtual cpus that have been created with S390 user controlled virtual "
"machines, the resulting vcpu fd can be memory mapped at page offset "
"KVM_S390_SIE_PAGE_OFFSET in order to obtain a memory map of the virtual "
"cpu's hardware control block."
msgstr ""

#: ../../../virt/kvm/api.rst:355
msgid "4.8 KVM_GET_DIRTY_LOG"
msgstr ""

#: ../../../virt/kvm/api.rst:360
msgid "struct kvm_dirty_log (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:361 ../../../virt/kvm/api.rst:399
#: ../../../virt/kvm/api.rst:426 ../../../virt/kvm/api.rst:466
#: ../../../virt/kvm/api.rst:480 ../../../virt/kvm/api.rst:511
#: ../../../virt/kvm/api.rst:524 ../../../virt/kvm/api.rst:712
#: ../../../virt/kvm/api.rst:752 ../../../virt/kvm/api.rst:778
#: ../../../virt/kvm/api.rst:816 ../../../virt/kvm/api.rst:854
#: ../../../virt/kvm/api.rst:876 ../../../virt/kvm/api.rst:945
#: ../../../virt/kvm/api.rst:970 ../../../virt/kvm/api.rst:995
#: ../../../virt/kvm/api.rst:1045 ../../../virt/kvm/api.rst:1095
#: ../../../virt/kvm/api.rst:1131 ../../../virt/kvm/api.rst:1254
#: ../../../virt/kvm/api.rst:1320 ../../../virt/kvm/api.rst:1342
#: ../../../virt/kvm/api.rst:1357 ../../../virt/kvm/api.rst:1439
#: ../../../virt/kvm/api.rst:1622 ../../../virt/kvm/api.rst:1646
#: ../../../virt/kvm/api.rst:1661 ../../../virt/kvm/api.rst:1681
#: ../../../virt/kvm/api.rst:1709 ../../../virt/kvm/api.rst:1736
#: ../../../virt/kvm/api.rst:1763 ../../../virt/kvm/api.rst:1885
#: ../../../virt/kvm/api.rst:2002 ../../../virt/kvm/api.rst:2039
#: ../../../virt/kvm/api.rst:2070 ../../../virt/kvm/api.rst:2140
#: ../../../virt/kvm/api.rst:2215 ../../../virt/kvm/api.rst:2949
#: ../../../virt/kvm/api.rst:3012 ../../../virt/kvm/api.rst:3045
#: ../../../virt/kvm/api.rst:3073 ../../../virt/kvm/api.rst:3088
#: ../../../virt/kvm/api.rst:3163 ../../../virt/kvm/api.rst:3202
#: ../../../virt/kvm/api.rst:3239 ../../../virt/kvm/api.rst:3349
#: ../../../virt/kvm/api.rst:3390 ../../../virt/kvm/api.rst:3426
#: ../../../virt/kvm/api.rst:3636 ../../../virt/kvm/api.rst:3685
#: ../../../virt/kvm/api.rst:3766 ../../../virt/kvm/api.rst:4046
#: ../../../virt/kvm/api.rst:4179 ../../../virt/kvm/api.rst:4533
#: ../../../virt/kvm/api.rst:4885 ../../../virt/kvm/api.rst:4959
#: ../../../virt/kvm/api.rst:5000 ../../../virt/kvm/api.rst:5042
#: ../../../virt/kvm/api.rst:5112 ../../../virt/kvm/api.rst:5155
#: ../../../virt/kvm/api.rst:5840 ../../../virt/kvm/api.rst:5873
#: ../../../virt/kvm/api.rst:6089 ../../../virt/kvm/api.rst:6296
#: ../../../virt/kvm/api.rst:7727
msgid "0 on success, -1 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:375
msgid ""
"Given a memory slot, return a bitmap containing any pages dirtied since the "
"last call to this ioctl.  Bit 0 is the first page in the memory slot.  "
"Ensure the entire structure is cleared to avoid padding issues."
msgstr ""

#: ../../../virt/kvm/api.rst:380
msgid ""
"If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of slot field "
"specifies the address space for which you want to return the dirty bitmap.  "
"See KVM_SET_USER_MEMORY_REGION for details on the usage of slot field."
msgstr ""

#: ../../../virt/kvm/api.rst:384
msgid ""
"The bits in the dirty bitmap are cleared before the ioctl returns, unless "
"KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 is enabled.  For more information, see the "
"description of the capability."
msgstr ""

#: ../../../virt/kvm/api.rst:388
msgid ""
"Note that the Xen shared_info page, if configured, shall always be assumed "
"to be dirty. KVM will not explicitly mark it such."
msgstr ""

#: ../../../virt/kvm/api.rst:393
msgid "4.10 KVM_RUN"
msgstr ""

#: ../../../virt/kvm/api.rst:397 ../../../virt/kvm/api.rst:424
#: ../../../virt/kvm/api.rst:464 ../../../virt/kvm/api.rst:478
#: ../../../virt/kvm/api.rst:509 ../../../virt/kvm/api.rst:522
#: ../../../virt/kvm/api.rst:549 ../../../virt/kvm/api.rst:688
#: ../../../virt/kvm/api.rst:710 ../../../virt/kvm/api.rst:750
#: ../../../virt/kvm/api.rst:776 ../../../virt/kvm/api.rst:814
#: ../../../virt/kvm/api.rst:1129 ../../../virt/kvm/api.rst:1252
#: ../../../virt/kvm/api.rst:1318 ../../../virt/kvm/api.rst:1340
#: ../../../virt/kvm/api.rst:1459 ../../../virt/kvm/api.rst:1514
#: ../../../virt/kvm/api.rst:1595 ../../../virt/kvm/api.rst:1659
#: ../../../virt/kvm/api.rst:1679 ../../../virt/kvm/api.rst:1707
#: ../../../virt/kvm/api.rst:1734 ../../../virt/kvm/api.rst:2037
#: ../../../virt/kvm/api.rst:2068 ../../../virt/kvm/api.rst:2138
#: ../../../virt/kvm/api.rst:2213 ../../../virt/kvm/api.rst:2240
#: ../../../virt/kvm/api.rst:2262 ../../../virt/kvm/api.rst:2284
#: ../../../virt/kvm/api.rst:2302 ../../../virt/kvm/api.rst:2917
#: ../../../virt/kvm/api.rst:2947 ../../../virt/kvm/api.rst:3447
#: ../../../virt/kvm/api.rst:3586 ../../../virt/kvm/api.rst:3703
#: ../../../virt/kvm/api.rst:4044 ../../../virt/kvm/api.rst:4104
#: ../../../virt/kvm/api.rst:4139 ../../../virt/kvm/api.rst:4177
#: ../../../virt/kvm/api.rst:4544 ../../../virt/kvm/api.rst:4563
#: ../../../virt/kvm/api.rst:4883 ../../../virt/kvm/api.rst:4957
#: ../../../virt/kvm/api.rst:5110 ../../../virt/kvm/api.rst:5293
#: ../../../virt/kvm/api.rst:5305 ../../../virt/kvm/api.rst:5318
#: ../../../virt/kvm/api.rst:5671 ../../../virt/kvm/api.rst:5785
#: ../../../virt/kvm/api.rst:5838 ../../../virt/kvm/api.rst:5871
#: ../../../virt/kvm/api.rst:6087 ../../../virt/kvm/api.rst:6134
#: ../../../virt/kvm/api.rst:6424
msgid "vcpu ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:404 ../../../virt/kvm/api.rst:5367
#: ../../../virt/kvm/api.rst:6434
msgid "EINTR"
msgstr ""

#: ../../../virt/kvm/api.rst:404 ../../../virt/kvm/api.rst:5367
msgid "an unmasked signal is pending"
msgstr ""

#: ../../../virt/kvm/api.rst:405
msgid "ENOEXEC"
msgstr ""

#: ../../../virt/kvm/api.rst:405
msgid ""
"the vcpu hasn't been initialized or the guest tried to execute instructions "
"from device memory (arm64)"
msgstr ""

#: ../../../virt/kvm/api.rst:407
msgid "ENOSYS"
msgstr ""

#: ../../../virt/kvm/api.rst:407
msgid ""
"data abort outside memslots with no syndrome info and "
"KVM_CAP_ARM_NISV_TO_USER not enabled (arm64)"
msgstr ""

#: ../../../virt/kvm/api.rst:409 ../../../virt/kvm/api.rst:2312
#: ../../../virt/kvm/api.rst:2927 ../../../virt/kvm/api.rst:3397
#: ../../../virt/kvm/api.rst:5117
msgid "EPERM"
msgstr ""

#: ../../../virt/kvm/api.rst:409
msgid "SVE feature set but not finalized (arm64)"
msgstr ""

#: ../../../virt/kvm/api.rst:412
msgid ""
"This ioctl is used to run a guest virtual cpu.  While there are no explicit "
"parameters, there is an implicit parameter block that can be obtained by "
"mmap()ing the vcpu fd at offset 0, with the size given by "
"KVM_GET_VCPU_MMAP_SIZE.  The parameter block is formatted as a 'struct "
"kvm_run' (see below)."
msgstr ""

#: ../../../virt/kvm/api.rst:420
msgid "4.11 KVM_GET_REGS"
msgstr ""

#: ../../../virt/kvm/api.rst:423 ../../../virt/kvm/api.rst:463
msgid "all except arm64"
msgstr ""

#: ../../../virt/kvm/api.rst:425
msgid "struct kvm_regs (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:428
msgid "Reads the general purpose registers from the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:460
msgid "4.12 KVM_SET_REGS"
msgstr ""

#: ../../../virt/kvm/api.rst:465
msgid "struct kvm_regs (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:468
msgid "Writes the general purpose registers into the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:470
msgid "See KVM_GET_REGS for the data structure."
msgstr ""

#: ../../../virt/kvm/api.rst:474
msgid "4.13 KVM_GET_SREGS"
msgstr ""

#: ../../../virt/kvm/api.rst:477 ../../../virt/kvm/api.rst:508
msgid "x86, ppc"
msgstr ""

#: ../../../virt/kvm/api.rst:479
msgid "struct kvm_sregs (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:482
msgid "Reads special registers from the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:499
msgid ""
"interrupt_bitmap is a bitmap of pending external interrupts.  At most one "
"bit may be set.  This interrupt has been acknowledged by the APIC but not "
"yet injected into the cpu core."
msgstr ""

#: ../../../virt/kvm/api.rst:505
msgid "4.14 KVM_SET_SREGS"
msgstr ""

#: ../../../virt/kvm/api.rst:510
msgid "struct kvm_sregs (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:513
msgid ""
"Writes special registers into the vcpu.  See KVM_GET_SREGS for the data "
"structures."
msgstr ""

#: ../../../virt/kvm/api.rst:518
msgid "4.15 KVM_TRANSLATE"
msgstr ""

#: ../../../virt/kvm/api.rst:523
msgid "struct kvm_translation (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:526
msgid ""
"Translates a virtual address according to the vcpu's current address "
"translation mode."
msgstr ""

#: ../../../virt/kvm/api.rst:545
msgid "4.16 KVM_INTERRUPT"
msgstr ""

#: ../../../virt/kvm/api.rst:548
msgid "x86, ppc, mips, riscv, loongarch"
msgstr ""

#: ../../../virt/kvm/api.rst:550
msgid "struct kvm_interrupt (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:551
msgid "0 on success, negative on failure."
msgstr ""

#: ../../../virt/kvm/api.rst:553
msgid "Queues a hardware interrupt vector to be injected."
msgstr ""

#: ../../../virt/kvm/api.rst:569
msgid "on success,"
msgstr ""

#: ../../../virt/kvm/api.rst:570
msgid "-EEXIST"
msgstr ""

#: ../../../virt/kvm/api.rst:570
msgid "if an interrupt is already enqueued"
msgstr ""

#: ../../../virt/kvm/api.rst:571
msgid "-EINVAL"
msgstr ""

#: ../../../virt/kvm/api.rst:571
msgid "the irq number is invalid"
msgstr ""

#: ../../../virt/kvm/api.rst:572
msgid "-ENXIO"
msgstr ""

#: ../../../virt/kvm/api.rst:572
msgid "if the PIC is in the kernel"
msgstr ""

#: ../../../virt/kvm/api.rst:573
msgid "-EFAULT"
msgstr ""

#: ../../../virt/kvm/api.rst:573
msgid "if the pointer is invalid"
msgstr ""

#: ../../../virt/kvm/api.rst:576
msgid ""
"Note 'irq' is an interrupt vector, not an interrupt pin or line. This ioctl "
"is useful if the in-kernel PIC is not used."
msgstr ""

#: ../../../virt/kvm/api.rst:580
msgid "PPC:"
msgstr ""

#: ../../../virt/kvm/api.rst:582
msgid ""
"Queues an external interrupt to be injected. This ioctl is overloaded with 3 "
"different irq values:"
msgstr ""

#: ../../../virt/kvm/api.rst:585 ../../../virt/kvm/api.rst:623
msgid "KVM_INTERRUPT_SET"
msgstr ""

#: ../../../virt/kvm/api.rst:587
msgid ""
"This injects an edge type external interrupt into the guest once it's ready "
"to receive interrupts. When injected, the interrupt is done."
msgstr ""

#: ../../../virt/kvm/api.rst:590 ../../../virt/kvm/api.rst:628
msgid "KVM_INTERRUPT_UNSET"
msgstr ""

#: ../../../virt/kvm/api.rst:592
msgid "This unsets any pending interrupt."
msgstr ""

#: ../../../virt/kvm/api.rst:594
msgid "Only available with KVM_CAP_PPC_UNSET_IRQ."
msgstr ""

#: ../../../virt/kvm/api.rst:596
msgid "KVM_INTERRUPT_SET_LEVEL"
msgstr ""

#: ../../../virt/kvm/api.rst:598
msgid ""
"This injects a level type external interrupt into the guest context. The "
"interrupt stays pending until a specific ioctl with KVM_INTERRUPT_UNSET is "
"triggered."
msgstr ""

#: ../../../virt/kvm/api.rst:602
msgid "Only available with KVM_CAP_PPC_IRQ_LEVEL."
msgstr ""

#: ../../../virt/kvm/api.rst:604
msgid ""
"Note that any value for 'irq' other than the ones stated above is invalid "
"and incurs unexpected behavior."
msgstr ""

#: ../../../virt/kvm/api.rst:607 ../../../virt/kvm/api.rst:615
#: ../../../virt/kvm/api.rst:632 ../../../virt/kvm/api.rst:640
#: ../../../virt/kvm/api.rst:3285 ../../../virt/kvm/api.rst:4097
msgid "This is an asynchronous vcpu ioctl and can be invoked from any thread."
msgstr ""

#: ../../../virt/kvm/api.rst:612 ../../../virt/kvm/api.rst:637
msgid ""
"Queues an external interrupt to be injected into the virtual CPU. A negative "
"interrupt number dequeues the interrupt."
msgstr ""

#: ../../../virt/kvm/api.rst:618
msgid "RISC-V:"
msgstr ""

#: ../../../virt/kvm/api.rst:620
msgid ""
"Queues an external interrupt to be injected into the virtual CPU. This ioctl "
"is overloaded with 2 different irq values:"
msgstr ""

#: ../../../virt/kvm/api.rst:625
msgid ""
"This sets external interrupt for a virtual CPU and it will receive once it "
"is ready."
msgstr ""

#: ../../../virt/kvm/api.rst:630
msgid "This clears pending external interrupt for a virtual CPU."
msgstr ""

#: ../../../virt/kvm/api.rst:635
msgid "LOONGARCH:"
msgstr ""

#: ../../../virt/kvm/api.rst:644
msgid "4.18 KVM_GET_MSRS"
msgstr ""

#: ../../../virt/kvm/api.rst:646
msgid "basic (vcpu), KVM_CAP_GET_MSR_FEATURES (system)"
msgstr ""

#: ../../../virt/kvm/api.rst:648 ../../../virt/kvm/api.rst:5040
msgid "system ioctl, vcpu ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:649
msgid "struct kvm_msrs (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:650
msgid "number of msrs successfully returned; -1 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:653
msgid ""
"When used as a system ioctl: Reads the values of MSR-based features that are "
"available for the VM.  This is similar to KVM_GET_SUPPORTED_CPUID, but it "
"returns MSR indices and values. The list of msr-based features can be "
"obtained using KVM_GET_MSR_FEATURE_INDEX_LIST in a system ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:659
msgid ""
"When used as a vcpu ioctl: Reads model-specific registers from the vcpu.  "
"Supported msr indices can be obtained using KVM_GET_MSR_INDEX_LIST in a "
"system ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:678
msgid ""
"Application code should set the 'nmsrs' member (which indicates the size of "
"the entries array) and the 'index' member of each array entry. kvm will fill "
"in the 'data' member."
msgstr ""

#: ../../../virt/kvm/api.rst:684
msgid "4.19 KVM_SET_MSRS"
msgstr ""

#: ../../../virt/kvm/api.rst:689
msgid "struct kvm_msrs (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:690
msgid "number of msrs successfully set (see below), -1 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:692
msgid ""
"Writes model-specific registers to the vcpu.  See KVM_GET_MSRS for the data "
"structures."
msgstr ""

#: ../../../virt/kvm/api.rst:695
msgid ""
"Application code should set the 'nmsrs' member (which indicates the size of "
"the entries array), and the 'index' and 'data' members of each array entry."
msgstr ""

#: ../../../virt/kvm/api.rst:699
msgid ""
"It tries to set the MSRs in array entries[] one by one. If setting an MSR "
"fails, e.g., due to setting reserved bits, the MSR isn't supported/emulated "
"by KVM, etc..., it stops processing the MSR list and returns the number of "
"MSRs that have been set successfully."
msgstr ""

#: ../../../virt/kvm/api.rst:706
msgid "4.20 KVM_SET_CPUID"
msgstr ""

#: ../../../virt/kvm/api.rst:711
msgid "struct kvm_cpuid (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:714
msgid ""
"Defines the vcpu responses to the cpuid instruction.  Applications should "
"use the KVM_SET_CPUID2 ioctl if available."
msgstr ""

#: ../../../virt/kvm/api.rst:717
msgid "Caveat emptor:"
msgstr ""

#: ../../../virt/kvm/api.rst:718
msgid ""
"If this IOCTL fails, KVM gives no guarantees that previous valid CPUID "
"configuration (if there is) is not corrupted. Userspace can get a copy of "
"the resulting CPUID configuration through KVM_GET_CPUID2 in case."
msgstr ""

#: ../../../virt/kvm/api.rst:721
msgid ""
"Using KVM_SET_CPUID{,2} after KVM_RUN, i.e. changing the guest vCPU model "
"after running the guest, may cause guest instability."
msgstr ""

#: ../../../virt/kvm/api.rst:723
msgid ""
"Using heterogeneous CPUID configurations, modulo APIC IDs, topology, etc... "
"may cause guest instability."
msgstr ""

#: ../../../virt/kvm/api.rst:746
msgid "4.21 KVM_SET_SIGNAL_MASK"
msgstr ""

#: ../../../virt/kvm/api.rst:751
msgid "struct kvm_signal_mask (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:754
msgid ""
"Defines which signals are blocked during execution of KVM_RUN.  This signal "
"mask temporarily overrides the threads signal mask.  Any unblocked signal "
"received (except SIGKILL and SIGSTOP, which retain their traditional "
"behaviour) will cause KVM_RUN to return with -EINTR."
msgstr ""

#: ../../../virt/kvm/api.rst:759
msgid ""
"Note the signal will only be delivered if not blocked by the original signal "
"mask."
msgstr ""

#: ../../../virt/kvm/api.rst:772
msgid "4.22 KVM_GET_FPU"
msgstr ""

#: ../../../virt/kvm/api.rst:775 ../../../virt/kvm/api.rst:813
msgid "x86, loongarch"
msgstr ""

#: ../../../virt/kvm/api.rst:777
msgid "struct kvm_fpu (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:780
msgid "Reads the floating point state from the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:810
msgid "4.23 KVM_SET_FPU"
msgstr ""

#: ../../../virt/kvm/api.rst:815
msgid "struct kvm_fpu (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:818
msgid "Writes the floating point state to the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:848
msgid "4.24 KVM_CREATE_IRQCHIP"
msgstr ""

#: ../../../virt/kvm/api.rst:850
msgid "KVM_CAP_IRQCHIP, KVM_CAP_S390_IRQCHIP (s390)"
msgstr ""

#: ../../../virt/kvm/api.rst:851 ../../../virt/kvm/api.rst:3387
msgid "x86, arm64, s390"
msgstr ""

#: ../../../virt/kvm/api.rst:856
msgid ""
"Creates an interrupt controller model in the kernel. On x86, creates a "
"virtual ioapic, a virtual PIC (two PICs, nested), and sets up future vcpus "
"to have a local APIC.  IRQ routing for GSIs 0-15 is set to both PIC and "
"IOAPIC; GSI 16-23 only go to the IOAPIC. On arm64, a GICv2 is created. Any "
"other GIC versions require the usage of KVM_CREATE_DEVICE, which also "
"supports creating a GICv2.  Using KVM_CREATE_DEVICE is preferred over "
"KVM_CREATE_IRQCHIP for GICv2. On s390, a dummy irq routing table is created."
msgstr ""

#: ../../../virt/kvm/api.rst:865
msgid ""
"Note that on s390 the KVM_CAP_S390_IRQCHIP vm capability needs to be enabled "
"before KVM_CREATE_IRQCHIP can be used."
msgstr ""

#: ../../../virt/kvm/api.rst:870
msgid "4.25 KVM_IRQ_LINE"
msgstr ""

#: ../../../virt/kvm/api.rst:872 ../../../virt/kvm/api.rst:941
#: ../../../virt/kvm/api.rst:966 ../../../virt/kvm/api.rst:2035
#: ../../../virt/kvm/api.rst:2066
msgid "KVM_CAP_IRQCHIP"
msgstr ""

#: ../../../virt/kvm/api.rst:873 ../../../virt/kvm/api.rst:1128
#: ../../../virt/kvm/api.rst:1251
msgid "x86, arm64"
msgstr ""

#: ../../../virt/kvm/api.rst:875
msgid "struct kvm_irq_level"
msgstr ""

#: ../../../virt/kvm/api.rst:878
msgid ""
"Sets the level of a GSI input to the interrupt controller model in the "
"kernel. On some architectures it is required that an interrupt controller "
"model has been previously created with KVM_CREATE_IRQCHIP.  Note that edge-"
"triggered interrupts require the level to be set to 1 and then back to 0."
msgstr ""

#: ../../../virt/kvm/api.rst:883
msgid ""
"On real hardware, interrupt pins can be active-low or active-high.  This "
"does not matter for the level field of struct kvm_irq_level: 1 always means "
"active (asserted), 0 means inactive (deasserted)."
msgstr ""

#: ../../../virt/kvm/api.rst:887
msgid ""
"x86 allows the operating system to program the interrupt polarity (active-"
"low/active-high) for level-triggered interrupts, and KVM used to consider "
"the polarity.  However, due to bitrot in the handling of active-low "
"interrupts, the above convention is now valid on x86 too. This is signaled "
"by KVM_CAP_X86_IOAPIC_POLARITY_IGNORED.  Userspace should not present "
"interrupts to the guest as active-low unless this capability is present (or "
"unless it is not using the in-kernel irqchip, of course)."
msgstr ""

#: ../../../virt/kvm/api.rst:897
msgid ""
"arm64 can signal an interrupt either at the CPU level, or at the in-kernel "
"irqchip (GIC), and for in-kernel irqchip can tell the GIC to use PPIs "
"designated for specific cpus.  The irq field is interpreted like this::"
msgstr ""

#: ../../../virt/kvm/api.rst:905
msgid "The irq_type field has the following values:"
msgstr ""

#: ../../../virt/kvm/api.rst:907
msgid "KVM_ARM_IRQ_TYPE_CPU:"
msgstr ""

#: ../../../virt/kvm/api.rst:908
msgid "out-of-kernel GIC: irq_id 0 is IRQ, irq_id 1 is FIQ"
msgstr ""

#: ../../../virt/kvm/api.rst:909
msgid "KVM_ARM_IRQ_TYPE_SPI:"
msgstr ""

#: ../../../virt/kvm/api.rst:910
msgid ""
"in-kernel GIC: SPI, irq_id between 32 and 1019 (incl.) (the vcpu_index field "
"is ignored)"
msgstr ""

#: ../../../virt/kvm/api.rst:912
msgid "KVM_ARM_IRQ_TYPE_PPI:"
msgstr ""

#: ../../../virt/kvm/api.rst:913
msgid "in-kernel GIC: PPI, irq_id between 16 and 31 (incl.)"
msgstr ""

#: ../../../virt/kvm/api.rst:915
msgid ""
"(The irq_id field thus corresponds nicely to the IRQ ID in the ARM GIC specs)"
msgstr ""

#: ../../../virt/kvm/api.rst:917
msgid "In both cases, level is used to assert/deassert the line."
msgstr ""

#: ../../../virt/kvm/api.rst:919
msgid ""
"When KVM_CAP_ARM_IRQ_LINE_LAYOUT_2 is supported, the target vcpu is "
"identified as (256 * vcpu2_index + vcpu_index). Otherwise, vcpu2_index must "
"be zero."
msgstr ""

#: ../../../virt/kvm/api.rst:923
msgid ""
"Note that on arm64, the KVM_CAP_IRQCHIP capability only conditions injection "
"of interrupts for the in-kernel irqchip. KVM_IRQ_LINE can always be used for "
"a userspace interrupt controller."
msgstr ""

#: ../../../virt/kvm/api.rst:939
msgid "4.26 KVM_GET_IRQCHIP"
msgstr ""

#: ../../../virt/kvm/api.rst:944
msgid "struct kvm_irqchip (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:947
msgid ""
"Reads the state of a kernel interrupt controller created with "
"KVM_CREATE_IRQCHIP into a buffer provided by the caller."
msgstr ""

#: ../../../virt/kvm/api.rst:964
msgid "4.27 KVM_SET_IRQCHIP"
msgstr ""

#: ../../../virt/kvm/api.rst:969
msgid "struct kvm_irqchip (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:972
msgid ""
"Sets the state of a kernel interrupt controller created with "
"KVM_CREATE_IRQCHIP from a buffer provided by the caller."
msgstr ""

#: ../../../virt/kvm/api.rst:989
msgid "4.28 KVM_XEN_HVM_CONFIG"
msgstr ""

#: ../../../virt/kvm/api.rst:991
msgid "KVM_CAP_XEN_HVM"
msgstr ""

#: ../../../virt/kvm/api.rst:994
msgid "struct kvm_xen_hvm_config (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:997
msgid ""
"Sets the MSR that the Xen HVM guest uses to initialize its hypercall page, "
"and provides the starting address and size of the hypercall blobs in "
"userspace.  When the guest writes the MSR, kvm copies one page of a blob "
"(32- or 64-bit, depending on the vcpu mode) to guest memory."
msgstr ""

#: ../../../virt/kvm/api.rst:1003
msgid ""
"The MSR index must be in the range [0x40000000, 0x4fffffff], i.e. must "
"reside in the range that is unofficially reserved for use by hypervisors.  "
"The min/max values are enumerated via KVM_XEN_MSR_MIN_INDEX and "
"KVM_XEN_MSR_MAX_INDEX."
msgstr ""

#: ../../../virt/kvm/api.rst:1019
msgid ""
"If certain flags are returned from the KVM_CAP_XEN_HVM check, they may be "
"set in the flags field of this ioctl:"
msgstr ""

#: ../../../virt/kvm/api.rst:1022
msgid ""
"The KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL flag requests KVM to generate the "
"contents of the hypercall page automatically; hypercalls will be intercepted "
"and passed to userspace through KVM_EXIT_XEN.  In this case, all of the blob "
"size and address fields must be zero."
msgstr ""

#: ../../../virt/kvm/api.rst:1027
msgid ""
"The KVM_XEN_HVM_CONFIG_EVTCHN_SEND flag indicates to KVM that userspace will "
"always use the KVM_XEN_HVM_EVTCHN_SEND ioctl to deliver event channel "
"interrupts rather than manipulating the guest's shared_info structures "
"directly. This, in turn, may allow KVM to enable features such as "
"intercepting the SCHEDOP_poll hypercall to accelerate PV spinlock operation "
"for the guest. Userspace may still use the ioctl to deliver events if it was "
"advertised, even if userspace does not send this indication that it will "
"always do so"
msgstr ""

#: ../../../virt/kvm/api.rst:1036
msgid "No other flags are currently valid in the struct kvm_xen_hvm_config."
msgstr ""

#: ../../../virt/kvm/api.rst:1039
msgid "4.29 KVM_GET_CLOCK"
msgstr ""

#: ../../../virt/kvm/api.rst:1041 ../../../virt/kvm/api.rst:1091
msgid "KVM_CAP_ADJUST_CLOCK"
msgstr ""

#: ../../../virt/kvm/api.rst:1044
msgid "struct kvm_clock_data (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:1047
msgid ""
"Gets the current timestamp of kvmclock as seen by the current guest. In "
"conjunction with KVM_SET_CLOCK, it is used to ensure monotonicity on "
"scenarios such as migration."
msgstr ""

#: ../../../virt/kvm/api.rst:1051
msgid ""
"When KVM_CAP_ADJUST_CLOCK is passed to KVM_CHECK_EXTENSION, it returns the "
"set of bits that KVM can return in struct kvm_clock_data's flag member."
msgstr ""

#: ../../../virt/kvm/api.rst:1054
msgid "The following flags are defined:"
msgstr ""

#: ../../../virt/kvm/api.rst:1056
msgid "KVM_CLOCK_TSC_STABLE"
msgstr ""

#: ../../../virt/kvm/api.rst:1057
msgid ""
"If set, the returned value is the exact kvmclock value seen by all VCPUs at "
"the instant when KVM_GET_CLOCK was called. If clear, the returned value is "
"simply CLOCK_MONOTONIC plus a constant offset; the offset can be modified "
"with KVM_SET_CLOCK.  KVM will try to make all VCPUs follow this clock, but "
"the exact value read by each VCPU could differ, because the host TSC is not "
"stable."
msgstr ""

#: ../../../virt/kvm/api.rst:1064 ../../../virt/kvm/api.rst:1103
msgid "KVM_CLOCK_REALTIME"
msgstr ""

#: ../../../virt/kvm/api.rst:1065
msgid ""
"If set, the `realtime` field in the kvm_clock_data structure is populated "
"with the value of the host's real time clocksource at the instant when "
"KVM_GET_CLOCK was called. If clear, the `realtime` field does not contain a "
"value."
msgstr ""

#: ../../../virt/kvm/api.rst:1070
msgid "KVM_CLOCK_HOST_TSC"
msgstr ""

#: ../../../virt/kvm/api.rst:1071
msgid ""
"If set, the `host_tsc` field in the kvm_clock_data structure is populated "
"with the value of the host's timestamp counter (TSC) at the instant when "
"KVM_GET_CLOCK was called. If clear, the `host_tsc` field does not contain a "
"value."
msgstr ""

#: ../../../virt/kvm/api.rst:1089
msgid "4.30 KVM_SET_CLOCK"
msgstr ""

#: ../../../virt/kvm/api.rst:1094
msgid "struct kvm_clock_data (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1097
msgid ""
"Sets the current timestamp of kvmclock to the value specified in its "
"parameter. In conjunction with KVM_GET_CLOCK, it is used to ensure "
"monotonicity on scenarios such as migration."
msgstr ""

#: ../../../virt/kvm/api.rst:1101
msgid "The following flags can be passed:"
msgstr ""

#: ../../../virt/kvm/api.rst:1104
msgid ""
"If set, KVM will compare the value of the `realtime` field with the value of "
"the host's real time clocksource at the instant when KVM_SET_CLOCK was "
"called. The difference in elapsed time is added to the final kvmclock value "
"that will be provided to guests."
msgstr ""

#: ../../../virt/kvm/api.rst:1109
msgid "Other flags returned by ``KVM_GET_CLOCK`` are accepted but ignored."
msgstr ""

#: ../../../virt/kvm/api.rst:1124
msgid "4.31 KVM_GET_VCPU_EVENTS"
msgstr ""

#: ../../../virt/kvm/api.rst:1126 ../../../virt/kvm/api.rst:1249
msgid "KVM_CAP_VCPU_EVENTS"
msgstr ""

#: ../../../virt/kvm/api.rst:0
msgid "Extended by"
msgstr ""

#: ../../../virt/kvm/api.rst:1127 ../../../virt/kvm/api.rst:1250
msgid "KVM_CAP_INTR_SHADOW"
msgstr ""

#: ../../../virt/kvm/api.rst:1130
msgid "struct kvm_vcpu_events (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:1136
msgid ""
"Gets currently pending exceptions, interrupts, and NMIs as well as related "
"states of the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:1174
msgid "The following bits are defined in the flags field:"
msgstr ""

#: ../../../virt/kvm/api.rst:1176
msgid ""
"KVM_VCPUEVENT_VALID_SHADOW may be set to signal that interrupt.shadow "
"contains a valid state."
msgstr ""

#: ../../../virt/kvm/api.rst:1179
msgid ""
"KVM_VCPUEVENT_VALID_SMM may be set to signal that smi contains a valid state."
msgstr ""

#: ../../../virt/kvm/api.rst:1182
msgid ""
"KVM_VCPUEVENT_VALID_PAYLOAD may be set to signal that the "
"exception_has_payload, exception_payload, and exception.pending fields "
"contain a valid state. This bit will be set whenever "
"KVM_CAP_EXCEPTION_PAYLOAD is enabled."
msgstr ""

#: ../../../virt/kvm/api.rst:1187
msgid ""
"KVM_VCPUEVENT_VALID_TRIPLE_FAULT may be set to signal that the "
"triple_fault_pending field contains a valid state. This bit will be set "
"whenever KVM_CAP_X86_TRIPLE_FAULT_EVENT is enabled."
msgstr ""

#: ../../../virt/kvm/api.rst:1194
msgid ""
"If the guest accesses a device that is being emulated by the host kernel in "
"such a way that a real device would generate a physical SError, KVM may make "
"a virtual SError pending for that VCPU. This system error interrupt remains "
"pending until the guest takes the exception by unmasking PSTATE.A."
msgstr ""

#: ../../../virt/kvm/api.rst:1199
msgid ""
"Running the VCPU may cause it to take a pending SError, or make an access "
"that causes an SError to become pending. The event's description is only "
"valid while the VPCU is not running."
msgstr ""

#: ../../../virt/kvm/api.rst:1203
msgid ""
"This API provides a way to read and write the pending 'event' state that is "
"not visible to the guest. To save, restore or migrate a VCPU the struct "
"representing the state can be read then written using this GET/SET API, "
"along with the other guest-visible registers. It is not possible to 'cancel' "
"an SError that has been made pending."
msgstr ""

#: ../../../virt/kvm/api.rst:1209
msgid ""
"A device being emulated in user-space may also wish to generate an SError. "
"To do this the events structure can be populated by user-space. The current "
"state should be read first, to ensure no existing SError is pending. If an "
"existing SError is pending, the architecture's 'Multiple SError interrupts' "
"rules should be followed. (2.5.3 of DDI0587.a \"ARM Reliability, "
"Availability, and Serviceability (RAS) Specification\")."
msgstr ""

#: ../../../virt/kvm/api.rst:1216
msgid ""
"SError exceptions always have an ESR value. Some CPUs have the ability to "
"specify what the virtual SError's ESR value should be. These systems will "
"advertise KVM_CAP_ARM_INJECT_SERROR_ESR. In this case exception.has_esr will "
"always have a non-zero value when read, and the agent making an SError "
"pending should specify the ISS field in the lower 24 bits of exception."
"serror_esr. If the system supports KVM_CAP_ARM_INJECT_SERROR_ESR, but user-"
"space sets the events with exception.has_esr as zero, KVM will choose an ESR."
msgstr ""

#: ../../../virt/kvm/api.rst:1224
msgid ""
"Specifying exception.has_esr on a system that does not support it will "
"return -EINVAL. Setting anything other than the lower 24bits of exception."
"serror_esr will return -EINVAL."
msgstr ""

#: ../../../virt/kvm/api.rst:1228
msgid ""
"It is not possible to read back a pending external abort (injected via "
"KVM_SET_VCPU_EVENTS or otherwise) because such an exception is always "
"delivered directly to the virtual CPU)."
msgstr ""

#: ../../../virt/kvm/api.rst:1247
msgid "4.32 KVM_SET_VCPU_EVENTS"
msgstr ""

#: ../../../virt/kvm/api.rst:1253
msgid "struct kvm_vcpu_events (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1259
msgid ""
"Set pending exceptions, interrupts, and NMIs as well as related states of "
"the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:1262 ../../../virt/kvm/api.rst:1310
msgid "See KVM_GET_VCPU_EVENTS for the data structure."
msgstr ""

#: ../../../virt/kvm/api.rst:1264
msgid ""
"Fields that may be modified asynchronously by running VCPUs can be excluded "
"from the update. These fields are nmi.pending, sipi_vector, smi.smm, smi."
"pending. Keep the corresponding bits in the flags field cleared to suppress "
"overwriting the current in-kernel state. The bits are:"
msgstr ""

#: ../../../virt/kvm/api.rst:1270
msgid "KVM_VCPUEVENT_VALID_NMI_PENDING"
msgstr ""

#: ../../../virt/kvm/api.rst:1270
msgid "transfer nmi.pending to the kernel"
msgstr ""

#: ../../../virt/kvm/api.rst:1271
msgid "KVM_VCPUEVENT_VALID_SIPI_VECTOR"
msgstr ""

#: ../../../virt/kvm/api.rst:1271
msgid "transfer sipi_vector"
msgstr ""

#: ../../../virt/kvm/api.rst:1272
msgid "KVM_VCPUEVENT_VALID_SMM"
msgstr ""

#: ../../../virt/kvm/api.rst:1272
msgid "transfer the smi sub-struct."
msgstr ""

#: ../../../virt/kvm/api.rst:1275
msgid ""
"If KVM_CAP_INTR_SHADOW is available, KVM_VCPUEVENT_VALID_SHADOW can be set "
"in the flags field to signal that interrupt.shadow contains a valid state "
"and shall be written into the VCPU."
msgstr ""

#: ../../../virt/kvm/api.rst:1279
msgid ""
"KVM_VCPUEVENT_VALID_SMM can only be set if KVM_CAP_X86_SMM is available."
msgstr ""

#: ../../../virt/kvm/api.rst:1281
msgid ""
"If KVM_CAP_EXCEPTION_PAYLOAD is enabled, KVM_VCPUEVENT_VALID_PAYLOAD can be "
"set in the flags field to signal that the exception_has_payload, "
"exception_payload, and exception.pending fields contain a valid state and "
"shall be written into the VCPU."
msgstr ""

#: ../../../virt/kvm/api.rst:1286
msgid ""
"If KVM_CAP_X86_TRIPLE_FAULT_EVENT is enabled, "
"KVM_VCPUEVENT_VALID_TRIPLE_FAULT can be set in flags field to signal that "
"the triple_fault field contains a valid state and shall be written into the "
"VCPU."
msgstr ""

#: ../../../virt/kvm/api.rst:1293
msgid "User space may need to inject several types of events to the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:1295
msgid ""
"Set the pending SError exception state for this VCPU. It is not possible to "
"'cancel' an Serror that has been made pending."
msgstr ""

#: ../../../virt/kvm/api.rst:1298
msgid ""
"If the guest performed an access to I/O memory which could not be handled by "
"userspace, for example because of missing instruction syndrome decode "
"information or because there is no device mapped at the accessed IPA, then "
"userspace can ask the kernel to inject an external abort using the address "
"from the exiting fault on the VCPU. It is a programming error to set "
"ext_dabt_pending after an exit which was not either KVM_EXIT_MMIO or "
"KVM_EXIT_ARM_NISV. This feature is only available if the system supports "
"KVM_CAP_ARM_INJECT_EXT_DABT. This is a helper which provides commonality in "
"how userspace reports accesses for the above cases to guests, across "
"different userspace implementations. Nevertheless, userspace can still "
"emulate all Arm exceptions by manipulating individual registers using the "
"KVM_SET_ONE_REG API."
msgstr ""

#: ../../../virt/kvm/api.rst:1314
msgid "4.33 KVM_GET_DEBUGREGS"
msgstr ""

#: ../../../virt/kvm/api.rst:1316 ../../../virt/kvm/api.rst:1338
msgid "KVM_CAP_DEBUGREGS"
msgstr ""

#: ../../../virt/kvm/api.rst:1319
msgid "struct kvm_debugregs (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:1322
msgid "Reads debug registers from the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:1336
msgid "4.34 KVM_SET_DEBUGREGS"
msgstr ""

#: ../../../virt/kvm/api.rst:1341
msgid "struct kvm_debugregs (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1344
msgid "Writes debug registers into the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:1346
msgid ""
"See KVM_GET_DEBUGREGS for the data structure. The flags field is unused yet "
"and must be cleared on entry."
msgstr ""

#: ../../../virt/kvm/api.rst:1351
msgid "4.35 KVM_SET_USER_MEMORY_REGION"
msgstr ""

#: ../../../virt/kvm/api.rst:1353
msgid "KVM_CAP_USER_MEMORY"
msgstr ""

#: ../../../virt/kvm/api.rst:1356
msgid "struct kvm_userspace_memory_region (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1373
msgid ""
"This ioctl allows the user to create, modify or delete a guest physical "
"memory slot.  Bits 0-15 of \"slot\" specify the slot id and this value "
"should be less than the maximum number of user memory slots supported per "
"VM.  The maximum allowed slots can be queried using KVM_CAP_NR_MEMSLOTS. "
"Slots may not overlap in guest physical address space."
msgstr ""

#: ../../../virt/kvm/api.rst:1379
msgid ""
"If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of \"slot\" "
"specifies the address space which is being modified.  They must be less than "
"the value that KVM_CHECK_EXTENSION returns for the "
"KVM_CAP_MULTI_ADDRESS_SPACE capability.  Slots in separate address spaces "
"are unrelated; the restriction on overlapping slots only applies within each "
"address space."
msgstr ""

#: ../../../virt/kvm/api.rst:1386
msgid ""
"Deleting a slot is done by passing zero for memory_size.  When changing an "
"existing slot, it may be moved in the guest physical memory space, or its "
"flags may be modified, but it may not be resized."
msgstr ""

#: ../../../virt/kvm/api.rst:1390
msgid ""
"Memory for the region is taken starting at the address denoted by the field "
"userspace_addr, which must point at user addressable memory for the entire "
"memory slot size.  Any object may back this memory, including anonymous "
"memory, ordinary files, and hugetlbfs."
msgstr ""

#: ../../../virt/kvm/api.rst:1395
msgid ""
"On architectures that support a form of address tagging, userspace_addr must "
"be an untagged address."
msgstr ""

#: ../../../virt/kvm/api.rst:1398
msgid ""
"It is recommended that the lower 21 bits of guest_phys_addr and "
"userspace_addr be identical.  This allows large pages in the guest to be "
"backed by large pages in the host."
msgstr ""

#: ../../../virt/kvm/api.rst:1402
msgid ""
"The flags field supports two flags: KVM_MEM_LOG_DIRTY_PAGES and "
"KVM_MEM_READONLY.  The former can be set to instruct KVM to keep track of "
"writes to memory within the slot.  See KVM_GET_DIRTY_LOG ioctl to know how "
"to use it.  The latter can be set, if KVM_CAP_READONLY_MEM capability allows "
"it, to make a new slot read-only.  In this case, writes to this memory will "
"be posted to userspace as KVM_EXIT_MMIO exits."
msgstr ""

#: ../../../virt/kvm/api.rst:1409
msgid ""
"When the KVM_CAP_SYNC_MMU capability is available, changes in the backing of "
"the memory region are automatically reflected into the guest.  For example, "
"an mmap() that affects the region will be made visible immediately.  Another "
"example is madvise(MADV_DROP)."
msgstr ""

#: ../../../virt/kvm/api.rst:1414
msgid ""
"For TDX guest, deleting/moving memory region loses guest memory contents. "
"Read only region isn't supported.  Only as-id 0 is supported."
msgstr ""

#: ../../../virt/kvm/api.rst:1417
msgid ""
"Note: On arm64, a write generated by the page-table walker (to update the "
"Access and Dirty flags, for example) never results in a KVM_EXIT_MMIO exit "
"when the slot has the KVM_MEM_READONLY flag. This is because KVM cannot "
"provide the data that would be written by the page-table walker, making it "
"impossible to emulate the access. Instead, an abort (data abort if the cause "
"of the page-table update was a load or a store, instruction abort if it was "
"an instruction fetch) is injected in the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:1429
msgid ""
"Returns -EINVAL or -EEXIST if the VM has the KVM_VM_S390_UCONTROL flag set. "
"Returns -EINVAL if called on a protected VM."
msgstr ""

#: ../../../virt/kvm/api.rst:1433
msgid "4.36 KVM_SET_TSS_ADDR"
msgstr ""

#: ../../../virt/kvm/api.rst:1435
msgid "KVM_CAP_SET_TSS_ADDR"
msgstr ""

#: ../../../virt/kvm/api.rst:1438
msgid "unsigned long tss_address (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1441
msgid ""
"This ioctl defines the physical address of a three-page region in the guest "
"physical address space.  The region must be within the first 4GB of the "
"guest physical address space and must not conflict with any memory slot or "
"any mmio address.  The guest may malfunction if it accesses this memory "
"region."
msgstr ""

#: ../../../virt/kvm/api.rst:1447 ../../../virt/kvm/api.rst:1633
msgid ""
"This ioctl is required on Intel-based hosts.  This is needed on Intel "
"hardware because of a quirk in the virtualization implementation (see the "
"internals documentation when it pops into existence)."
msgstr ""

#: ../../../virt/kvm/api.rst:1455
msgid "4.37 KVM_ENABLE_CAP"
msgstr ""

#: ../../../virt/kvm/api.rst:1457
msgid "KVM_CAP_ENABLE_CAP"
msgstr ""

#: ../../../virt/kvm/api.rst:1458
msgid "mips, ppc, s390, x86, loongarch"
msgstr ""

#: ../../../virt/kvm/api.rst:1460 ../../../virt/kvm/api.rst:1466
msgid "struct kvm_enable_cap (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1463
msgid "KVM_CAP_ENABLE_CAP_VM"
msgstr ""

#: ../../../virt/kvm/api.rst:1471
msgid ""
"Not all extensions are enabled by default. Using this ioctl the application "
"can enable an extension, making it available to the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:1474
msgid ""
"On systems that do not support this ioctl, it always fails. On systems that "
"do support it, it only works for extensions that are supported for "
"enablement."
msgstr ""

#: ../../../virt/kvm/api.rst:1477
msgid ""
"To check if a capability can be enabled, the KVM_CHECK_EXTENSION ioctl "
"should be used."
msgstr ""

#: ../../../virt/kvm/api.rst:1486
msgid "The capability that is supposed to get enabled."
msgstr ""

#: ../../../virt/kvm/api.rst:1492
msgid "A bitfield indicating future enhancements. Has to be 0 for now."
msgstr ""

#: ../../../virt/kvm/api.rst:1498
msgid ""
"Arguments for enabling a feature. If a feature needs initial values to "
"function properly, this is the place to put them."
msgstr ""

#: ../../../virt/kvm/api.rst:1506
msgid ""
"The vcpu ioctl should be used for vcpu-specific capabilities, the vm ioctl "
"for vm-wide capabilities."
msgstr ""

#: ../../../virt/kvm/api.rst:1510
msgid "4.38 KVM_GET_MP_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:1512 ../../../virt/kvm/api.rst:1593
msgid "KVM_CAP_MP_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:1513 ../../../virt/kvm/api.rst:1594
msgid "x86, s390, arm64, riscv, loongarch"
msgstr ""

#: ../../../virt/kvm/api.rst:1515
msgid "struct kvm_mp_state (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:1524
msgid ""
"Returns the vcpu's current \"multiprocessing state\" (though also valid on "
"uniprocessor guests)."
msgstr ""

#: ../../../virt/kvm/api.rst:1527
msgid "Possible values are:"
msgstr ""

#: ../../../virt/kvm/api.rst:1530
msgid "KVM_MP_STATE_RUNNABLE"
msgstr ""

#: ../../../virt/kvm/api.rst:1530
msgid "the vcpu is currently running [x86,arm64,riscv,loongarch]"
msgstr ""

#: ../../../virt/kvm/api.rst:1532
msgid "KVM_MP_STATE_UNINITIALIZED"
msgstr ""

#: ../../../virt/kvm/api.rst:1532
msgid ""
"the vcpu is an application processor (AP) which has not yet received an INIT "
"signal [x86]"
msgstr ""

#: ../../../virt/kvm/api.rst:1534
msgid "KVM_MP_STATE_INIT_RECEIVED"
msgstr ""

#: ../../../virt/kvm/api.rst:1534
msgid "the vcpu has received an INIT signal, and is now ready for a SIPI [x86]"
msgstr ""

#: ../../../virt/kvm/api.rst:1536
msgid "KVM_MP_STATE_HALTED"
msgstr ""

#: ../../../virt/kvm/api.rst:1536
msgid ""
"the vcpu has executed a HLT instruction and is waiting for an interrupt [x86]"
msgstr ""

#: ../../../virt/kvm/api.rst:1538
msgid "KVM_MP_STATE_SIPI_RECEIVED"
msgstr ""

#: ../../../virt/kvm/api.rst:1538
msgid ""
"the vcpu has just received a SIPI (vector accessible via "
"KVM_GET_VCPU_EVENTS) [x86]"
msgstr ""

#: ../../../virt/kvm/api.rst:1540
msgid "KVM_MP_STATE_STOPPED"
msgstr ""

#: ../../../virt/kvm/api.rst:1540
msgid "the vcpu is stopped [s390,arm64,riscv]"
msgstr ""

#: ../../../virt/kvm/api.rst:1541
msgid "KVM_MP_STATE_CHECK_STOP"
msgstr ""

#: ../../../virt/kvm/api.rst:1541
msgid "the vcpu is in a special error state [s390]"
msgstr ""

#: ../../../virt/kvm/api.rst:1542
msgid "KVM_MP_STATE_OPERATING"
msgstr ""

#: ../../../virt/kvm/api.rst:1542
msgid "the vcpu is operating (running or halted) [s390]"
msgstr ""

#: ../../../virt/kvm/api.rst:1544
msgid "KVM_MP_STATE_LOAD"
msgstr ""

#: ../../../virt/kvm/api.rst:1544
msgid "the vcpu is in a special load/startup state [s390]"
msgstr ""

#: ../../../virt/kvm/api.rst:1546
msgid "KVM_MP_STATE_SUSPENDED"
msgstr ""

#: ../../../virt/kvm/api.rst:1546
msgid ""
"the vcpu is in a suspend state and is waiting for a wakeup event [arm64]"
msgstr ""

#: ../../../virt/kvm/api.rst:1550 ../../../virt/kvm/api.rst:1602
msgid ""
"On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an in-"
"kernel irqchip, the multiprocessing state must be maintained by userspace on "
"these architectures."
msgstr ""

#: ../../../virt/kvm/api.rst:1555 ../../../virt/kvm/api.rst:6686
msgid "For arm64:"
msgstr ""

#: ../../../virt/kvm/api.rst:1557
msgid ""
"If a vCPU is in the KVM_MP_STATE_SUSPENDED state, KVM will emulate the "
"architectural execution of a WFI instruction."
msgstr ""

#: ../../../virt/kvm/api.rst:1560
msgid ""
"If a wakeup event is recognized, KVM will exit to userspace with a "
"KVM_SYSTEM_EVENT exit, where the event type is KVM_SYSTEM_EVENT_WAKEUP. If "
"userspace wants to honor the wakeup, it must set the vCPU's MP state to "
"KVM_MP_STATE_RUNNABLE. If it does not, KVM will continue to await a wakeup "
"event in subsequent calls to KVM_RUN."
msgstr ""

#: ../../../virt/kvm/api.rst:1568
msgid ""
"If userspace intends to keep the vCPU in a SUSPENDED state, it is strongly "
"recommended that userspace take action to suppress the wakeup event (such as "
"masking an interrupt). Otherwise, subsequent calls to KVM_RUN will "
"immediately exit with a KVM_SYSTEM_EVENT_WAKEUP event and inadvertently "
"waste CPU cycles."
msgstr ""

#: ../../../virt/kvm/api.rst:1574
msgid ""
"Additionally, if userspace takes action to suppress a wakeup event, it is "
"strongly recommended that it also restores the vCPU to its original state "
"when the vCPU is made RUNNABLE again. For example, if userspace masked a "
"pending interrupt to suppress the wakeup, the interrupt should be unmasked "
"before returning control to the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:1582
msgid "For riscv:"
msgstr ""

#: ../../../virt/kvm/api.rst:1584
msgid ""
"The only states that are valid are KVM_MP_STATE_STOPPED and "
"KVM_MP_STATE_RUNNABLE which reflect if the vcpu is paused or not."
msgstr ""

#: ../../../virt/kvm/api.rst:1587 ../../../virt/kvm/api.rst:1612
msgid ""
"On LoongArch, only the KVM_MP_STATE_RUNNABLE state is used to reflect "
"whether the vcpu is runnable."
msgstr ""

#: ../../../virt/kvm/api.rst:1591
msgid "4.39 KVM_SET_MP_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:1596
msgid "struct kvm_mp_state (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1599
msgid ""
"Sets the vcpu's current \"multiprocessing state\"; see KVM_GET_MP_STATE for "
"arguments."
msgstr ""

#: ../../../virt/kvm/api.rst:1607
msgid "For arm64/riscv:"
msgstr ""

#: ../../../virt/kvm/api.rst:1609
msgid ""
"The only states that are valid are KVM_MP_STATE_STOPPED and "
"KVM_MP_STATE_RUNNABLE which reflect if the vcpu should be paused or not."
msgstr ""

#: ../../../virt/kvm/api.rst:1616
msgid "4.40 KVM_SET_IDENTITY_MAP_ADDR"
msgstr ""

#: ../../../virt/kvm/api.rst:1618
msgid "KVM_CAP_SET_IDENTITY_MAP_ADDR"
msgstr ""

#: ../../../virt/kvm/api.rst:1621
msgid "unsigned long identity (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1624
msgid ""
"This ioctl defines the physical address of a one-page region in the guest "
"physical address space.  The region must be within the first 4GB of the "
"guest physical address space and must not conflict with any memory slot or "
"any mmio address.  The guest may malfunction if it accesses this memory "
"region."
msgstr ""

#: ../../../virt/kvm/api.rst:1630
msgid ""
"Setting the address to 0 will result in resetting the address to its default "
"(0xfffbc000)."
msgstr ""

#: ../../../virt/kvm/api.rst:1637
msgid "Fails if any VCPU has already been created."
msgstr ""

#: ../../../virt/kvm/api.rst:1640
msgid "4.41 KVM_SET_BOOT_CPU_ID"
msgstr ""

#: ../../../virt/kvm/api.rst:1642
msgid "KVM_CAP_SET_BOOT_CPU_ID"
msgstr ""

#: ../../../virt/kvm/api.rst:1645
msgid "unsigned long vcpu_id"
msgstr ""

#: ../../../virt/kvm/api.rst:1648
msgid ""
"Define which vcpu is the Bootstrap Processor (BSP).  Values are the same as "
"the vcpu id in KVM_CREATE_VCPU.  If this ioctl is not called, the default is "
"vcpu 0. This ioctl has to be called before vcpu creation, otherwise it will "
"return EBUSY error."
msgstr ""

#: ../../../virt/kvm/api.rst:1655
msgid "4.42 KVM_GET_XSAVE"
msgstr ""

#: ../../../virt/kvm/api.rst:1657
msgid "KVM_CAP_XSAVE"
msgstr ""

#: ../../../virt/kvm/api.rst:1660 ../../../virt/kvm/api.rst:6088
msgid "struct kvm_xsave (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:1671
msgid "This ioctl would copy current vcpu's xsave struct to the userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:1675
msgid "4.43 KVM_SET_XSAVE"
msgstr ""

#: ../../../virt/kvm/api.rst:1677
msgid "KVM_CAP_XSAVE and KVM_CAP_XSAVE2"
msgstr ""

#: ../../../virt/kvm/api.rst:1680
msgid "struct kvm_xsave (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1691
msgid ""
"This ioctl would copy userspace's xsave struct to the kernel. It copies as "
"many bytes as are returned by KVM_CHECK_EXTENSION(KVM_CAP_XSAVE2), when "
"invoked on the vm file descriptor. The size value returned by "
"KVM_CHECK_EXTENSION(KVM_CAP_XSAVE2) will always be at least 4096. Currently, "
"it is only greater than 4096 if a dynamic feature has been enabled with "
"``arch_prctl()``, but this may change in the future."
msgstr ""

#: ../../../virt/kvm/api.rst:1698 ../../../virt/kvm/api.rst:6106
msgid ""
"The offsets of the state save areas in struct kvm_xsave follow the contents "
"of CPUID leaf 0xD on the host."
msgstr ""

#: ../../../virt/kvm/api.rst:1703
msgid "4.44 KVM_GET_XCRS"
msgstr ""

#: ../../../virt/kvm/api.rst:1705 ../../../virt/kvm/api.rst:1732
msgid "KVM_CAP_XCRS"
msgstr ""

#: ../../../virt/kvm/api.rst:1708
msgid "struct kvm_xcrs (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:1726
msgid "This ioctl would copy current vcpu's xcrs to the userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:1730
msgid "4.45 KVM_SET_XCRS"
msgstr ""

#: ../../../virt/kvm/api.rst:1735
msgid "struct kvm_xcrs (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1753
msgid "This ioctl would set vcpu's xcr to the value userspace specified."
msgstr ""

#: ../../../virt/kvm/api.rst:1757
msgid "4.46 KVM_GET_SUPPORTED_CPUID"
msgstr ""

#: ../../../virt/kvm/api.rst:1759
msgid "KVM_CAP_EXT_CPUID"
msgstr ""

#: ../../../virt/kvm/api.rst:1762 ../../../virt/kvm/api.rst:3765
#: ../../../virt/kvm/api.rst:5041
msgid "struct kvm_cpuid2 (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:1788
msgid ""
"This ioctl returns x86 cpuid features which are supported by both the "
"hardware and kvm in its default configuration.  Userspace can use the "
"information returned by this ioctl to construct cpuid information (for "
"KVM_SET_CPUID2) that is consistent with hardware, kernel, and userspace "
"capabilities, and with user requirements (for example, the user may wish to "
"constrain cpuid to emulate older hardware, or for feature consistency across "
"a cluster)."
msgstr ""

#: ../../../virt/kvm/api.rst:1796
msgid ""
"Dynamically-enabled feature bits need to be requested with ``arch_prctl()`` "
"before calling this ioctl. Feature bits that have not been requested are "
"excluded from the result."
msgstr ""

#: ../../../virt/kvm/api.rst:1800
msgid ""
"Note that certain capabilities, such as KVM_CAP_X86_DISABLE_EXITS, may "
"expose cpuid features (e.g. MONITOR) which are not supported by kvm in its "
"default configuration. If userspace enables such capabilities, it is "
"responsible for modifying the results of this ioctl appropriately."
msgstr ""

#: ../../../virt/kvm/api.rst:1805
msgid ""
"Userspace invokes KVM_GET_SUPPORTED_CPUID by passing a kvm_cpuid2 structure "
"with the 'nent' field indicating the number of entries in the variable-size "
"array 'entries'.  If the number of entries is too low to describe the cpu "
"capabilities, an error (E2BIG) is returned.  If the number is too high, the "
"'nent' field is adjusted and an error (ENOMEM) is returned.  If the number "
"is just right, the 'nent' field is adjusted to the number of valid entries "
"in the 'entries' array, which is then filled."
msgstr ""

#: ../../../virt/kvm/api.rst:1813
msgid ""
"The entries returned are the host cpuid as returned by the cpuid "
"instruction, with unknown or unsupported features masked out.  Some features "
"(for example, x2apic), may not be present in the host cpu, but are exposed "
"by kvm if it can emulate them efficiently. The fields in each entry are "
"defined as follows:"
msgstr ""

#: ../../../virt/kvm/api.rst:1818 ../../../virt/kvm/api.rst:3818
msgid "function:"
msgstr ""

#: ../../../virt/kvm/api.rst:1819 ../../../virt/kvm/api.rst:3819
msgid "the eax value used to obtain the entry"
msgstr ""

#: ../../../virt/kvm/api.rst:1821 ../../../virt/kvm/api.rst:3820
msgid "index:"
msgstr ""

#: ../../../virt/kvm/api.rst:1822 ../../../virt/kvm/api.rst:3821
msgid ""
"the ecx value used to obtain the entry (for entries that are affected by ecx)"
msgstr ""

#: ../../../virt/kvm/api.rst:1825 ../../../virt/kvm/api.rst:1930
#: ../../../virt/kvm/api.rst:2989 ../../../virt/kvm/api.rst:3823
msgid "flags:"
msgstr ""

#: ../../../virt/kvm/api.rst:1826 ../../../virt/kvm/api.rst:3824
msgid "an OR of zero or more of the following:"
msgstr ""

#: ../../../virt/kvm/api.rst:1828 ../../../virt/kvm/api.rst:3826
msgid "KVM_CPUID_FLAG_SIGNIFCANT_INDEX:"
msgstr ""

#: ../../../virt/kvm/api.rst:1829 ../../../virt/kvm/api.rst:3827
msgid "if the index field is valid"
msgstr ""

#: ../../../virt/kvm/api.rst:1831 ../../../virt/kvm/api.rst:3829
msgid "eax, ebx, ecx, edx:"
msgstr ""

#: ../../../virt/kvm/api.rst:1832 ../../../virt/kvm/api.rst:3831
msgid ""
"the values returned by the cpuid instruction for this function/index "
"combination"
msgstr ""

#: ../../../virt/kvm/api.rst:1835
msgid ""
"x2APIC (CPUID leaf 1, ecx[21) and TSC deadline timer (CPUID leaf 1, ecx[24]) "
"may be returned as true, but they depend on KVM_CREATE_IRQCHIP for in-kernel "
"emulation of the local APIC.  TSC deadline timer support is also reported "
"via::"
msgstr ""

#: ../../../virt/kvm/api.rst:1841
msgid ""
"if that returns true and you use KVM_CREATE_IRQCHIP, or if you emulate the "
"feature in userspace, then you can enable the feature for KVM_SET_CPUID2."
msgstr ""

#: ../../../virt/kvm/api.rst:1844
msgid ""
"Enabling x2APIC in KVM_SET_CPUID2 requires KVM_CREATE_IRQCHIP as KVM doesn't "
"support forwarding x2APIC MSR accesses to userspace, i.e. KVM does not "
"support emulating x2APIC in userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:1849
msgid "4.47 KVM_PPC_GET_PVINFO"
msgstr ""

#: ../../../virt/kvm/api.rst:1851
msgid "KVM_CAP_PPC_GET_PVINFO"
msgstr ""

#: ../../../virt/kvm/api.rst:1852 ../../../virt/kvm/api.rst:2137
#: ../../../virt/kvm/api.rst:3682 ../../../virt/kvm/api.rst:4360
#: ../../../virt/kvm/api.rst:4394 ../../../virt/kvm/api.rst:7313
#: ../../../virt/kvm/api.rst:7329 ../../../virt/kvm/api.rst:7350
#: ../../../virt/kvm/api.rst:7416 ../../../virt/kvm/api.rst:7435
#: ../../../virt/kvm/api.rst:7444 ../../../virt/kvm/api.rst:7537
#: ../../../virt/kvm/api.rst:7640 ../../../virt/kvm/api.rst:7813
#: ../../../virt/kvm/api.rst:7831 ../../../virt/kvm/api.rst:7918
#: ../../../virt/kvm/api.rst:8001 ../../../virt/kvm/api.rst:8110
#: ../../../virt/kvm/api.rst:8674 ../../../virt/kvm/api.rst:8685
#: ../../../virt/kvm/api.rst:8695 ../../../virt/kvm/api.rst:8806
#: ../../../virt/kvm/api.rst:9044 ../../../virt/kvm/api.rst:9133
#: ../../../virt/kvm/api.rst:9149
msgid "ppc"
msgstr ""

#: ../../../virt/kvm/api.rst:1854
msgid "struct kvm_ppc_pvinfo (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:1855 ../../../virt/kvm/api.rst:2094
msgid "0 on success, !0 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:1865
msgid ""
"This ioctl fetches PV specific information that need to be passed to the "
"guest using the device tree or other means from vm context."
msgstr ""

#: ../../../virt/kvm/api.rst:1868
msgid "The hcall array defines 4 instructions that make up a hypercall."
msgstr ""

#: ../../../virt/kvm/api.rst:1870
msgid ""
"If any additional field gets added to this structure later on, a bit for "
"that additional piece of information will be set in the flags bitmap."
msgstr ""

#: ../../../virt/kvm/api.rst:1873
msgid "The flags bitmap is defined as::"
msgstr ""

#: ../../../virt/kvm/api.rst:1879
msgid "4.52 KVM_SET_GSI_ROUTING"
msgstr ""

#: ../../../virt/kvm/api.rst:1881
msgid "KVM_CAP_IRQ_ROUTING"
msgstr ""

#: ../../../virt/kvm/api.rst:1882 ../../../virt/kvm/api.rst:3160
msgid "x86 s390 arm64"
msgstr ""

#: ../../../virt/kvm/api.rst:1884
msgid "struct kvm_irq_routing (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:1887
msgid ""
"Sets the GSI routing table entries, overwriting any previously set entries."
msgstr ""

#: ../../../virt/kvm/api.rst:1889
msgid "On arm64, GSI routing has the following limitation:"
msgstr ""

#: ../../../virt/kvm/api.rst:1891
msgid "GSI routing does not apply to KVM_IRQ_LINE but only to KVM_IRQFD."
msgstr ""

#: ../../../virt/kvm/api.rst:1901
msgid ""
"No flags are specified so far, the corresponding field must be set to zero."
msgstr ""

#: ../../../virt/kvm/api.rst:1927
msgid ""
"On s390, adding a KVM_IRQ_ROUTING_S390_ADAPTER is rejected on ucontrol VMs "
"with error -EINVAL."
msgstr ""

#: ../../../virt/kvm/api.rst:1932
msgid ""
"KVM_MSI_VALID_DEVID: used along with KVM_IRQ_ROUTING_MSI routing entry type, "
"specifies that the devid field contains a valid value.  The per-VM "
"KVM_CAP_MSI_DEVID capability advertises the requirement to provide the "
"device ID.  If this capability is not available, userspace should never set "
"the KVM_MSI_VALID_DEVID flag as the ioctl might fail."
msgstr ""

#: ../../../virt/kvm/api.rst:1937
msgid "zero otherwise"
msgstr ""

#: ../../../virt/kvm/api.rst:1956 ../../../virt/kvm/api.rst:2995
msgid ""
"If KVM_MSI_VALID_DEVID is set, devid contains a unique device identifier for "
"the device that wrote the MSI message.  For PCI, this is usually a BDF "
"identifier in the lower 16 bits."
msgstr ""

#: ../../../virt/kvm/api.rst:1960 ../../../virt/kvm/api.rst:2999
msgid ""
"On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS "
"feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled, "
"address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of "
"address_hi must be zero."
msgstr ""

#: ../../../virt/kvm/api.rst:1987
msgid ""
"When KVM_CAP_XEN_HVM includes the KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL bit in "
"its indication of supported features, routing to Xen event channels is "
"supported. Although the priority field is present, only the value "
"KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL is supported, which means delivery by 2 "
"level event channels. FIFO event channel support may be added in the future."
msgstr ""

#: ../../../virt/kvm/api.rst:1996
msgid "4.55 KVM_SET_TSC_KHZ"
msgstr ""

#: ../../../virt/kvm/api.rst:1998
msgid "KVM_CAP_TSC_CONTROL / KVM_CAP_VM_TSC_CONTROL"
msgstr ""

#: ../../../virt/kvm/api.rst:2000 ../../../virt/kvm/api.rst:2023
msgid "vcpu ioctl / vm ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:2001
msgid "virtual tsc_khz"
msgstr ""

#: ../../../virt/kvm/api.rst:2004
msgid ""
"Specifies the tsc frequency for the virtual machine. The unit of the "
"frequency is KHz."
msgstr ""

#: ../../../virt/kvm/api.rst:2007
msgid ""
"If the KVM_CAP_VM_TSC_CONTROL capability is advertised, this can also be "
"used as a vm ioctl to set the initial tsc frequency of subsequently created "
"vCPUs.  Note, the vm ioctl is only allowed prior to creating vCPUs."
msgstr ""

#: ../../../virt/kvm/api.rst:2011
msgid ""
"For TSC protected Confidential Computing (CoCo) VMs where TSC frequency is "
"configured once at VM scope and remains unchanged during VM's lifetime, the "
"vm ioctl should be used to configure the TSC frequency and the vcpu ioctl is "
"not supported."
msgstr ""

#: ../../../virt/kvm/api.rst:2016
msgid "Example of such CoCo VMs: TDX guests."
msgstr ""

#: ../../../virt/kvm/api.rst:2019
msgid "4.56 KVM_GET_TSC_KHZ"
msgstr ""

#: ../../../virt/kvm/api.rst:2021
msgid "KVM_CAP_GET_TSC_KHZ / KVM_CAP_VM_TSC_CONTROL"
msgstr ""

#: ../../../virt/kvm/api.rst:2025
msgid "virtual tsc-khz on success, negative value on error"
msgstr ""

#: ../../../virt/kvm/api.rst:2027
msgid ""
"Returns the tsc frequency of the guest. The unit of the return value is KHz. "
"If the host has unstable tsc this ioctl returns -EIO instead as an error."
msgstr ""

#: ../../../virt/kvm/api.rst:2033
msgid "4.57 KVM_GET_LAPIC"
msgstr ""

#: ../../../virt/kvm/api.rst:2038
msgid "struct kvm_lapic_state (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:2048
msgid ""
"Reads the Local APIC registers and copies them into the input argument.  The "
"data format and layout are the same as documented in the architecture manual."
msgstr ""

#: ../../../virt/kvm/api.rst:2051
msgid ""
"If KVM_X2APIC_API_USE_32BIT_IDS feature of KVM_CAP_X2APIC_API is enabled, "
"then the format of APIC_ID register depends on the APIC mode (reported by "
"MSR_IA32_APICBASE) of its VCPU.  x2APIC stores APIC ID in the APIC_ID "
"register (bytes 32-35).  xAPIC only allows an 8-bit APIC ID which is stored "
"in bits 31-24 of the APIC register, or equivalently in byte 35 of struct "
"kvm_lapic_state's regs field.  KVM_GET_LAPIC must then be called after "
"MSR_IA32_APICBASE has been set with KVM_SET_MSR."
msgstr ""

#: ../../../virt/kvm/api.rst:2059
msgid ""
"If KVM_X2APIC_API_USE_32BIT_IDS feature is disabled, struct kvm_lapic_state "
"always uses xAPIC format."
msgstr ""

#: ../../../virt/kvm/api.rst:2064
msgid "4.58 KVM_SET_LAPIC"
msgstr ""

#: ../../../virt/kvm/api.rst:2069
msgid "struct kvm_lapic_state (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:2079
msgid ""
"Copies the input argument into the Local APIC registers.  The data format "
"and layout are the same as documented in the architecture manual."
msgstr ""

#: ../../../virt/kvm/api.rst:2082
msgid ""
"The format of the APIC ID register (bytes 32-35 of struct kvm_lapic_state's "
"regs field) depends on the state of the KVM_CAP_X2APIC_API capability. See "
"the note in KVM_GET_LAPIC."
msgstr ""

#: ../../../virt/kvm/api.rst:2088
msgid "4.59 KVM_IOEVENTFD"
msgstr ""

#: ../../../virt/kvm/api.rst:2090
msgid "KVM_CAP_IOEVENTFD"
msgstr ""

#: ../../../virt/kvm/api.rst:2093
msgid "struct kvm_ioeventfd (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:2096
msgid ""
"This ioctl attaches or detaches an ioeventfd to a legal pio/mmio address "
"within the guest.  A guest write in the registered address will signal the "
"provided event instead of triggering an exit."
msgstr ""

#: ../../../virt/kvm/api.rst:2111
msgid ""
"For the special case of virtio-ccw devices on s390, the ioevent is matched "
"to a subchannel/virtqueue tuple instead."
msgstr ""

#: ../../../virt/kvm/api.rst:2114
msgid "The following flags are defined::"
msgstr ""

#: ../../../virt/kvm/api.rst:2122
msgid ""
"If datamatch flag is set, the event will be signaled only if the written "
"value to the registered address is equal to datamatch in struct "
"kvm_ioeventfd."
msgstr ""

#: ../../../virt/kvm/api.rst:2125
msgid ""
"For virtio-ccw devices, addr contains the subchannel id and datamatch the "
"virtqueue index."
msgstr ""

#: ../../../virt/kvm/api.rst:2128
msgid ""
"With KVM_CAP_IOEVENTFD_ANY_LENGTH, a zero length ioeventfd is allowed, and "
"the kernel will ignore the length of guest write and may get a faster "
"vmexit. The speedup may only apply to specific architectures, but the "
"ioeventfd will work anyway."
msgstr ""

#: ../../../virt/kvm/api.rst:2134
msgid "4.60 KVM_DIRTY_TLB"
msgstr ""

#: ../../../virt/kvm/api.rst:2136
msgid "KVM_CAP_SW_TLB"
msgstr ""

#: ../../../virt/kvm/api.rst:2139
msgid "struct kvm_dirty_tlb (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:2149
msgid ""
"This must be called whenever userspace has changed an entry in the shared "
"TLB, prior to calling KVM_RUN on the associated vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:2152
msgid ""
"The \"bitmap\" field is the userspace address of an array.  This array "
"consists of a number of bits, equal to the total number of TLB entries as "
"determined by the last successful call to "
"``KVM_ENABLE_CAP(KVM_CAP_SW_TLB)``, rounded up to the nearest multiple of 64."
msgstr ""

#: ../../../virt/kvm/api.rst:2157
msgid ""
"Each bit corresponds to one TLB entry, ordered the same as in the shared TLB "
"array."
msgstr ""

#: ../../../virt/kvm/api.rst:2160
msgid ""
"The array is little-endian: the bit 0 is the least significant bit of the "
"first byte, bit 8 is the least significant bit of the second byte, etc. This "
"avoids any complications with differing word sizes."
msgstr ""

#: ../../../virt/kvm/api.rst:2164
msgid ""
"The \"num_dirty\" field is a performance hint for KVM to determine whether "
"it should skip processing the bitmap and just invalidate everything.  It "
"must be set to the number of set bits in the bitmap."
msgstr ""

#: ../../../virt/kvm/api.rst:2170
msgid "4.62 KVM_CREATE_SPAPR_TCE"
msgstr ""

#: ../../../virt/kvm/api.rst:2172
msgid "KVM_CAP_SPAPR_TCE"
msgstr ""

#: ../../../virt/kvm/api.rst:2173 ../../../virt/kvm/api.rst:3085
#: ../../../virt/kvm/api.rst:3199 ../../../virt/kvm/api.rst:3291
#: ../../../virt/kvm/api.rst:4300 ../../../virt/kvm/api.rst:4431
#: ../../../virt/kvm/api.rst:4485 ../../../virt/kvm/api.rst:4745
#: ../../../virt/kvm/api.rst:5268
msgid "powerpc"
msgstr ""

#: ../../../virt/kvm/api.rst:2175
msgid "struct kvm_create_spapr_tce (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:2176 ../../../virt/kvm/api.rst:4303
msgid "file descriptor for manipulating the created TCE table"
msgstr ""

#: ../../../virt/kvm/api.rst:2178
msgid ""
"This creates a virtual TCE (translation control entry) table, which is an "
"IOMMU for PAPR-style virtual I/O.  It is used to translate logical addresses "
"used in virtual I/O into guest physical addresses, and provides a scatter/"
"gather capability for PAPR virtual I/O."
msgstr ""

#: ../../../virt/kvm/api.rst:2191
msgid ""
"The liobn field gives the logical IO bus number for which to create a TCE "
"table.  The window_size field specifies the size of the DMA window which "
"this TCE table will translate - the table will contain one 64 bit TCE entry "
"for every 4kiB of the DMA window."
msgstr ""

#: ../../../virt/kvm/api.rst:2196
msgid ""
"When the guest issues an H_PUT_TCE hcall on a liobn for which a TCE table "
"has been created using this ioctl(), the kernel will handle it in real mode, "
"updating the TCE table.  H_PUT_TCE calls for other liobns will cause a vm "
"exit and must be handled by userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:2201
msgid ""
"The return value is a file descriptor which can be passed to mmap(2) to map "
"the created TCE table into userspace.  This lets userspace read the entries "
"written by kernel-handled H_PUT_TCE calls, and also lets userspace update "
"the TCE table directly which is useful in some circumstances."
msgstr ""

#: ../../../virt/kvm/api.rst:2209
msgid "4.64 KVM_NMI"
msgstr ""

#: ../../../virt/kvm/api.rst:2211
msgid "KVM_CAP_USER_NMI"
msgstr ""

#: ../../../virt/kvm/api.rst:2217
msgid ""
"Queues an NMI on the thread's vcpu.  Note this is well defined only when "
"KVM_CREATE_IRQCHIP has not been called, since this is an interface between "
"the virtual cpu core and virtual local APIC.  After KVM_CREATE_IRQCHIP has "
"been called, this interface is completely emulated within the kernel."
msgstr ""

#: ../../../virt/kvm/api.rst:2222
msgid ""
"To use this to emulate the LINT1 input with KVM_CREATE_IRQCHIP, use the "
"following algorithm:"
msgstr ""

#: ../../../virt/kvm/api.rst:2225
msgid "pause the vcpu"
msgstr ""

#: ../../../virt/kvm/api.rst:2226
msgid "read the local APIC's state (KVM_GET_LAPIC)"
msgstr ""

#: ../../../virt/kvm/api.rst:2227
msgid ""
"check whether changing LINT1 will queue an NMI (see the LVT entry for LINT1)"
msgstr ""

#: ../../../virt/kvm/api.rst:2228
msgid "if so, issue KVM_NMI"
msgstr ""

#: ../../../virt/kvm/api.rst:2229
msgid "resume the vcpu"
msgstr ""

#: ../../../virt/kvm/api.rst:2231
msgid ""
"Some guests configure the LINT1 NMI input to cause a panic, aiding in "
"debugging."
msgstr ""

#: ../../../virt/kvm/api.rst:2236
msgid "4.65 KVM_S390_UCAS_MAP"
msgstr ""

#: ../../../virt/kvm/api.rst:2238 ../../../virt/kvm/api.rst:2260
#: ../../../virt/kvm/api.rst:2282
msgid "KVM_CAP_S390_UCONTROL"
msgstr ""

#: ../../../virt/kvm/api.rst:2239 ../../../virt/kvm/api.rst:2261
#: ../../../virt/kvm/api.rst:2283 ../../../virt/kvm/api.rst:3236
#: ../../../virt/kvm/api.rst:3838 ../../../virt/kvm/api.rst:3983
#: ../../../virt/kvm/api.rst:4015 ../../../virt/kvm/api.rst:4043
#: ../../../virt/kvm/api.rst:4103 ../../../virt/kvm/api.rst:4138
#: ../../../virt/kvm/api.rst:4596 ../../../virt/kvm/api.rst:4697
#: ../../../virt/kvm/api.rst:5292 ../../../virt/kvm/api.rst:5304
#: ../../../virt/kvm/api.rst:5317 ../../../virt/kvm/api.rst:5331
#: ../../../virt/kvm/api.rst:6133 ../../../virt/kvm/api.rst:6158
#: ../../../virt/kvm/api.rst:7397 ../../../virt/kvm/api.rst:7454
#: ../../../virt/kvm/api.rst:7662 ../../../virt/kvm/api.rst:7684
#: ../../../virt/kvm/api.rst:7695 ../../../virt/kvm/api.rst:7746
#: ../../../virt/kvm/api.rst:7779 ../../../virt/kvm/api.rst:7794
#: ../../../virt/kvm/api.rst:7804 ../../../virt/kvm/api.rst:7890
#: ../../../virt/kvm/api.rst:8826 ../../../virt/kvm/api.rst:8835
#: ../../../virt/kvm/api.rst:8842 ../../../virt/kvm/api.rst:8851
#: ../../../virt/kvm/api.rst:8860 ../../../virt/kvm/api.rst:8903
#: ../../../virt/kvm/api.rst:8911 ../../../virt/kvm/api.rst:8935
#: ../../../virt/kvm/api.rst:9078 ../../../virt/kvm/api.rst:9090
msgid "s390"
msgstr ""

#: ../../../virt/kvm/api.rst:2241 ../../../virt/kvm/api.rst:2263
msgid "struct kvm_s390_ucas_mapping (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:2242 ../../../virt/kvm/api.rst:2264
#: ../../../virt/kvm/api.rst:2286
msgid "0 in case of success"
msgstr ""

#: ../../../virt/kvm/api.rst:2244 ../../../virt/kvm/api.rst:2266
msgid "The parameter is defined like this::"
msgstr ""

#: ../../../virt/kvm/api.rst:2252
msgid ""
"This ioctl maps the memory at \"user_addr\" with the length \"length\" to "
"the vcpu's address space starting at \"vcpu_addr\". All parameters need to "
"be aligned by 1 megabyte."
msgstr ""

#: ../../../virt/kvm/api.rst:2258
msgid "4.66 KVM_S390_UCAS_UNMAP"
msgstr ""

#: ../../../virt/kvm/api.rst:2274
msgid ""
"This ioctl unmaps the memory in the vcpu's address space starting at "
"\"vcpu_addr\" with the length \"length\". The field \"user_addr\" is "
"ignored. All parameters need to be aligned by 1 megabyte."
msgstr ""

#: ../../../virt/kvm/api.rst:2280
msgid "4.67 KVM_S390_VCPU_FAULT"
msgstr ""

#: ../../../virt/kvm/api.rst:2285
msgid "vcpu absolute address (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:2288
msgid ""
"This call creates a page table entry on the virtual cpu's address space (for "
"user controlled virtual machines) or the virtual machine's address space "
"(for regular virtual machines). This only works for minor faults, thus it's "
"recommended to access subject memory page via the user page table upfront. "
"This is useful to handle validity intercepts for user controlled virtual "
"machines to fault in the virtual cpu's lowcore pages prior to calling the "
"KVM_RUN ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:2298
msgid "4.68 KVM_SET_ONE_REG"
msgstr ""

#: ../../../virt/kvm/api.rst:2300 ../../../virt/kvm/api.rst:2915
msgid "KVM_CAP_ONE_REG"
msgstr ""

#: ../../../virt/kvm/api.rst:2303
msgid "struct kvm_one_reg (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:2304 ../../../virt/kvm/api.rst:2919
msgid "0 on success, negative value on failure"
msgstr ""

#: ../../../virt/kvm/api.rst:2309 ../../../virt/kvm/api.rst:2924
#: ../../../virt/kvm/api.rst:3455 ../../../virt/kvm/api.rst:6433
msgid "ENOENT"
msgstr ""

#: ../../../virt/kvm/api.rst:2309 ../../../virt/kvm/api.rst:2924
msgid "no such register"
msgstr ""

#: ../../../virt/kvm/api.rst:2310 ../../../virt/kvm/api.rst:2925
#: ../../../virt/kvm/api.rst:3454 ../../../virt/kvm/api.rst:4052
#: ../../../virt/kvm/api.rst:4606 ../../../virt/kvm/api.rst:4607
#: ../../../virt/kvm/api.rst:5118 ../../../virt/kvm/api.rst:5161
#: ../../../virt/kvm/api.rst:5276 ../../../virt/kvm/api.rst:6431
msgid "EINVAL"
msgstr ""

#: ../../../virt/kvm/api.rst:2310 ../../../virt/kvm/api.rst:2925
msgid ""
"invalid register ID, or no such register or used with VMs in protected "
"virtualization mode on s390"
msgstr ""

#: ../../../virt/kvm/api.rst:2312 ../../../virt/kvm/api.rst:2927
msgid "(arm64) register access not allowed before vcpu finalization"
msgstr ""

#: ../../../virt/kvm/api.rst:2313 ../../../virt/kvm/api.rst:3645
#: ../../../virt/kvm/api.rst:4056 ../../../virt/kvm/api.rst:5163
msgid "EBUSY"
msgstr ""

#: ../../../virt/kvm/api.rst:2313
msgid ""
"(riscv) changing register value not allowed after the vcpu has run at least "
"once"
msgstr ""

#: ../../../virt/kvm/api.rst:2317 ../../../virt/kvm/api.rst:2930
msgid ""
"(These error codes are indicative only: do not rely on a specific error code "
"being returned in a specific situation.)"
msgstr ""

#: ../../../virt/kvm/api.rst:2327
msgid ""
"Using this ioctl, a single vcpu register can be set to a specific value "
"defined by user space with the passed in struct kvm_one_reg, where id refers "
"to the register identifier as described below and addr is a pointer to a "
"variable with the respective size. There can be architecture agnostic and "
"architecture specific registers. Each have their own range of operation and "
"their own constants and width. To keep track of the implemented registers, "
"find a list below:"
msgstr ""

#: ../../../virt/kvm/api.rst:2336
msgid "Arch"
msgstr ""

#: ../../../virt/kvm/api.rst:2336 ../../../virt/kvm/api.rst:2579
#: ../../../virt/kvm/api.rst:2772 ../../../virt/kvm/api.rst:2790
#: ../../../virt/kvm/api.rst:2836 ../../../virt/kvm/api.rst:2857
#: ../../../virt/kvm/api.rst:2873 ../../../virt/kvm/api.rst:2890
msgid "Register"
msgstr ""

#: ../../../virt/kvm/api.rst:2336
msgid "Width (bits)"
msgstr ""

#: ../../../virt/kvm/api.rst:2338 ../../../virt/kvm/api.rst:2339
#: ../../../virt/kvm/api.rst:2340 ../../../virt/kvm/api.rst:2341
#: ../../../virt/kvm/api.rst:2342 ../../../virt/kvm/api.rst:2343
#: ../../../virt/kvm/api.rst:2344 ../../../virt/kvm/api.rst:2345
#: ../../../virt/kvm/api.rst:2346 ../../../virt/kvm/api.rst:2347
#: ../../../virt/kvm/api.rst:2348 ../../../virt/kvm/api.rst:2349
#: ../../../virt/kvm/api.rst:2350 ../../../virt/kvm/api.rst:2351
#: ../../../virt/kvm/api.rst:2352 ../../../virt/kvm/api.rst:2353
#: ../../../virt/kvm/api.rst:2354 ../../../virt/kvm/api.rst:2355
#: ../../../virt/kvm/api.rst:2356 ../../../virt/kvm/api.rst:2357
#: ../../../virt/kvm/api.rst:2358 ../../../virt/kvm/api.rst:2359
#: ../../../virt/kvm/api.rst:2360 ../../../virt/kvm/api.rst:2361
#: ../../../virt/kvm/api.rst:2362 ../../../virt/kvm/api.rst:2363
#: ../../../virt/kvm/api.rst:2364 ../../../virt/kvm/api.rst:2365
#: ../../../virt/kvm/api.rst:2366 ../../../virt/kvm/api.rst:2367
#: ../../../virt/kvm/api.rst:2368 ../../../virt/kvm/api.rst:2369
#: ../../../virt/kvm/api.rst:2370 ../../../virt/kvm/api.rst:2371
#: ../../../virt/kvm/api.rst:2372 ../../../virt/kvm/api.rst:2374
#: ../../../virt/kvm/api.rst:2375 ../../../virt/kvm/api.rst:2377
#: ../../../virt/kvm/api.rst:2378 ../../../virt/kvm/api.rst:2380
#: ../../../virt/kvm/api.rst:2381 ../../../virt/kvm/api.rst:2382
#: ../../../virt/kvm/api.rst:2383 ../../../virt/kvm/api.rst:2384
#: ../../../virt/kvm/api.rst:2385 ../../../virt/kvm/api.rst:2386
#: ../../../virt/kvm/api.rst:2387 ../../../virt/kvm/api.rst:2388
#: ../../../virt/kvm/api.rst:2389 ../../../virt/kvm/api.rst:2390
#: ../../../virt/kvm/api.rst:2391 ../../../virt/kvm/api.rst:2392
#: ../../../virt/kvm/api.rst:2393 ../../../virt/kvm/api.rst:2394
#: ../../../virt/kvm/api.rst:2395 ../../../virt/kvm/api.rst:2396
#: ../../../virt/kvm/api.rst:2397 ../../../virt/kvm/api.rst:2398
#: ../../../virt/kvm/api.rst:2399 ../../../virt/kvm/api.rst:2400
#: ../../../virt/kvm/api.rst:2401 ../../../virt/kvm/api.rst:2402
#: ../../../virt/kvm/api.rst:2403 ../../../virt/kvm/api.rst:2404
#: ../../../virt/kvm/api.rst:2405 ../../../virt/kvm/api.rst:2406
#: ../../../virt/kvm/api.rst:2407 ../../../virt/kvm/api.rst:2408
#: ../../../virt/kvm/api.rst:2409 ../../../virt/kvm/api.rst:2410
#: ../../../virt/kvm/api.rst:2411 ../../../virt/kvm/api.rst:2412
#: ../../../virt/kvm/api.rst:2413 ../../../virt/kvm/api.rst:2414
#: ../../../virt/kvm/api.rst:2415 ../../../virt/kvm/api.rst:2416
#: ../../../virt/kvm/api.rst:2417 ../../../virt/kvm/api.rst:2418
#: ../../../virt/kvm/api.rst:2419 ../../../virt/kvm/api.rst:2420
#: ../../../virt/kvm/api.rst:2421 ../../../virt/kvm/api.rst:2422
#: ../../../virt/kvm/api.rst:2423 ../../../virt/kvm/api.rst:2424
#: ../../../virt/kvm/api.rst:2425 ../../../virt/kvm/api.rst:2426
#: ../../../virt/kvm/api.rst:2427 ../../../virt/kvm/api.rst:2428
#: ../../../virt/kvm/api.rst:2429 ../../../virt/kvm/api.rst:2430
#: ../../../virt/kvm/api.rst:2431 ../../../virt/kvm/api.rst:2432
#: ../../../virt/kvm/api.rst:2433 ../../../virt/kvm/api.rst:2434
#: ../../../virt/kvm/api.rst:2435 ../../../virt/kvm/api.rst:2436
#: ../../../virt/kvm/api.rst:2437 ../../../virt/kvm/api.rst:2438
#: ../../../virt/kvm/api.rst:2439 ../../../virt/kvm/api.rst:2440
#: ../../../virt/kvm/api.rst:2441 ../../../virt/kvm/api.rst:2442
#: ../../../virt/kvm/api.rst:2443 ../../../virt/kvm/api.rst:2444
#: ../../../virt/kvm/api.rst:2445 ../../../virt/kvm/api.rst:2446
#: ../../../virt/kvm/api.rst:2447 ../../../virt/kvm/api.rst:2448
#: ../../../virt/kvm/api.rst:2449 ../../../virt/kvm/api.rst:2450
#: ../../../virt/kvm/api.rst:2451 ../../../virt/kvm/api.rst:2452
#: ../../../virt/kvm/api.rst:2454 ../../../virt/kvm/api.rst:2455
#: ../../../virt/kvm/api.rst:2457 ../../../virt/kvm/api.rst:2458
#: ../../../virt/kvm/api.rst:2459 ../../../virt/kvm/api.rst:2460
#: ../../../virt/kvm/api.rst:2461 ../../../virt/kvm/api.rst:2462
#: ../../../virt/kvm/api.rst:2463 ../../../virt/kvm/api.rst:2464
#: ../../../virt/kvm/api.rst:2465 ../../../virt/kvm/api.rst:2466
#: ../../../virt/kvm/api.rst:2467 ../../../virt/kvm/api.rst:2468
msgid "PPC"
msgstr ""

#: ../../../virt/kvm/api.rst:2338
msgid "KVM_REG_PPC_HIOR"
msgstr ""

#: ../../../virt/kvm/api.rst:2338 ../../../virt/kvm/api.rst:2339
#: ../../../virt/kvm/api.rst:2340 ../../../virt/kvm/api.rst:2341
#: ../../../virt/kvm/api.rst:2342 ../../../virt/kvm/api.rst:2343
#: ../../../virt/kvm/api.rst:2344 ../../../virt/kvm/api.rst:2345
#: ../../../virt/kvm/api.rst:2346 ../../../virt/kvm/api.rst:2347
#: ../../../virt/kvm/api.rst:2348 ../../../virt/kvm/api.rst:2349
#: ../../../virt/kvm/api.rst:2351 ../../../virt/kvm/api.rst:2352
#: ../../../virt/kvm/api.rst:2353 ../../../virt/kvm/api.rst:2354
#: ../../../virt/kvm/api.rst:2355 ../../../virt/kvm/api.rst:2356
#: ../../../virt/kvm/api.rst:2357 ../../../virt/kvm/api.rst:2358
#: ../../../virt/kvm/api.rst:2359 ../../../virt/kvm/api.rst:2360
#: ../../../virt/kvm/api.rst:2361 ../../../virt/kvm/api.rst:2362
#: ../../../virt/kvm/api.rst:2363 ../../../virt/kvm/api.rst:2372
#: ../../../virt/kvm/api.rst:2374 ../../../virt/kvm/api.rst:2381
#: ../../../virt/kvm/api.rst:2383 ../../../virt/kvm/api.rst:2394
#: ../../../virt/kvm/api.rst:2395 ../../../virt/kvm/api.rst:2408
#: ../../../virt/kvm/api.rst:2410 ../../../virt/kvm/api.rst:2413
#: ../../../virt/kvm/api.rst:2414 ../../../virt/kvm/api.rst:2415
#: ../../../virt/kvm/api.rst:2416 ../../../virt/kvm/api.rst:2417
#: ../../../virt/kvm/api.rst:2419 ../../../virt/kvm/api.rst:2420
#: ../../../virt/kvm/api.rst:2421 ../../../virt/kvm/api.rst:2422
#: ../../../virt/kvm/api.rst:2423 ../../../virt/kvm/api.rst:2424
#: ../../../virt/kvm/api.rst:2425 ../../../virt/kvm/api.rst:2426
#: ../../../virt/kvm/api.rst:2427 ../../../virt/kvm/api.rst:2428
#: ../../../virt/kvm/api.rst:2429 ../../../virt/kvm/api.rst:2430
#: ../../../virt/kvm/api.rst:2431 ../../../virt/kvm/api.rst:2432
#: ../../../virt/kvm/api.rst:2433 ../../../virt/kvm/api.rst:2436
#: ../../../virt/kvm/api.rst:2437 ../../../virt/kvm/api.rst:2440
#: ../../../virt/kvm/api.rst:2441 ../../../virt/kvm/api.rst:2443
#: ../../../virt/kvm/api.rst:2444 ../../../virt/kvm/api.rst:2445
#: ../../../virt/kvm/api.rst:2446 ../../../virt/kvm/api.rst:2447
#: ../../../virt/kvm/api.rst:2448 ../../../virt/kvm/api.rst:2449
#: ../../../virt/kvm/api.rst:2450 ../../../virt/kvm/api.rst:2451
#: ../../../virt/kvm/api.rst:2452 ../../../virt/kvm/api.rst:2454
#: ../../../virt/kvm/api.rst:2458 ../../../virt/kvm/api.rst:2459
#: ../../../virt/kvm/api.rst:2460 ../../../virt/kvm/api.rst:2461
#: ../../../virt/kvm/api.rst:2462 ../../../virt/kvm/api.rst:2463
#: ../../../virt/kvm/api.rst:2464 ../../../virt/kvm/api.rst:2466
#: ../../../virt/kvm/api.rst:2467 ../../../virt/kvm/api.rst:2468
#: ../../../virt/kvm/api.rst:2470 ../../../virt/kvm/api.rst:2472
#: ../../../virt/kvm/api.rst:2473 ../../../virt/kvm/api.rst:2474
#: ../../../virt/kvm/api.rst:2475 ../../../virt/kvm/api.rst:2477
#: ../../../virt/kvm/api.rst:2478 ../../../virt/kvm/api.rst:2479
#: ../../../virt/kvm/api.rst:2481 ../../../virt/kvm/api.rst:2482
#: ../../../virt/kvm/api.rst:2485 ../../../virt/kvm/api.rst:2486
#: ../../../virt/kvm/api.rst:2487 ../../../virt/kvm/api.rst:2488
#: ../../../virt/kvm/api.rst:2489 ../../../virt/kvm/api.rst:2490
#: ../../../virt/kvm/api.rst:2494 ../../../virt/kvm/api.rst:2498
#: ../../../virt/kvm/api.rst:2503 ../../../virt/kvm/api.rst:2505
#: ../../../virt/kvm/api.rst:2513 ../../../virt/kvm/api.rst:2514
#: ../../../virt/kvm/api.rst:2515 ../../../virt/kvm/api.rst:2516
#: ../../../virt/kvm/api.rst:2517 ../../../virt/kvm/api.rst:2518
#: ../../../virt/kvm/api.rst:2519 ../../../virt/kvm/api.rst:2520
#: ../../../virt/kvm/api.rst:2521 ../../../virt/kvm/api.rst:2522
#: ../../../virt/kvm/api.rst:2523 ../../../virt/kvm/api.rst:2524
#: ../../../virt/kvm/api.rst:2526 ../../../virt/kvm/api.rst:2581
#: ../../../virt/kvm/api.rst:2582 ../../../virt/kvm/api.rst:2584
#: ../../../virt/kvm/api.rst:2585 ../../../virt/kvm/api.rst:2586
#: ../../../virt/kvm/api.rst:2587 ../../../virt/kvm/api.rst:2588
#: ../../../virt/kvm/api.rst:2589 ../../../virt/kvm/api.rst:2590
#: ../../../virt/kvm/api.rst:2591 ../../../virt/kvm/api.rst:2592
#: ../../../virt/kvm/api.rst:2593 ../../../virt/kvm/api.rst:2594
msgid "64"
msgstr ""

#: ../../../virt/kvm/api.rst:2339
msgid "KVM_REG_PPC_IAC1"
msgstr ""

#: ../../../virt/kvm/api.rst:2340
msgid "KVM_REG_PPC_IAC2"
msgstr ""

#: ../../../virt/kvm/api.rst:2341
msgid "KVM_REG_PPC_IAC3"
msgstr ""

#: ../../../virt/kvm/api.rst:2342
msgid "KVM_REG_PPC_IAC4"
msgstr ""

#: ../../../virt/kvm/api.rst:2343
msgid "KVM_REG_PPC_DAC1"
msgstr ""

#: ../../../virt/kvm/api.rst:2344
msgid "KVM_REG_PPC_DAC2"
msgstr ""

#: ../../../virt/kvm/api.rst:2345
msgid "KVM_REG_PPC_DABR"
msgstr ""

#: ../../../virt/kvm/api.rst:2346
msgid "KVM_REG_PPC_DSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2347
msgid "KVM_REG_PPC_PURR"
msgstr ""

#: ../../../virt/kvm/api.rst:2348
msgid "KVM_REG_PPC_SPURR"
msgstr ""

#: ../../../virt/kvm/api.rst:2349
msgid "KVM_REG_PPC_DAR"
msgstr ""

#: ../../../virt/kvm/api.rst:2350
msgid "KVM_REG_PPC_DSISR"
msgstr ""

#: ../../../virt/kvm/api.rst:2350 ../../../virt/kvm/api.rst:2364
#: ../../../virt/kvm/api.rst:2365 ../../../virt/kvm/api.rst:2366
#: ../../../virt/kvm/api.rst:2367 ../../../virt/kvm/api.rst:2368
#: ../../../virt/kvm/api.rst:2369 ../../../virt/kvm/api.rst:2370
#: ../../../virt/kvm/api.rst:2371 ../../../virt/kvm/api.rst:2382
#: ../../../virt/kvm/api.rst:2386 ../../../virt/kvm/api.rst:2387
#: ../../../virt/kvm/api.rst:2388 ../../../virt/kvm/api.rst:2389
#: ../../../virt/kvm/api.rst:2390 ../../../virt/kvm/api.rst:2391
#: ../../../virt/kvm/api.rst:2392 ../../../virt/kvm/api.rst:2393
#: ../../../virt/kvm/api.rst:2396 ../../../virt/kvm/api.rst:2397
#: ../../../virt/kvm/api.rst:2398 ../../../virt/kvm/api.rst:2399
#: ../../../virt/kvm/api.rst:2400 ../../../virt/kvm/api.rst:2401
#: ../../../virt/kvm/api.rst:2402 ../../../virt/kvm/api.rst:2403
#: ../../../virt/kvm/api.rst:2404 ../../../virt/kvm/api.rst:2405
#: ../../../virt/kvm/api.rst:2406 ../../../virt/kvm/api.rst:2407
#: ../../../virt/kvm/api.rst:2411 ../../../virt/kvm/api.rst:2412
#: ../../../virt/kvm/api.rst:2418 ../../../virt/kvm/api.rst:2434
#: ../../../virt/kvm/api.rst:2435 ../../../virt/kvm/api.rst:2438
#: ../../../virt/kvm/api.rst:2439 ../../../virt/kvm/api.rst:2442
#: ../../../virt/kvm/api.rst:2465 ../../../virt/kvm/api.rst:2476
#: ../../../virt/kvm/api.rst:2480 ../../../virt/kvm/api.rst:2483
#: ../../../virt/kvm/api.rst:2484 ../../../virt/kvm/api.rst:2491
#: ../../../virt/kvm/api.rst:2492 ../../../virt/kvm/api.rst:2493
#: ../../../virt/kvm/api.rst:2495 ../../../virt/kvm/api.rst:2496
#: ../../../virt/kvm/api.rst:2497 ../../../virt/kvm/api.rst:2499
#: ../../../virt/kvm/api.rst:2500 ../../../virt/kvm/api.rst:2501
#: ../../../virt/kvm/api.rst:2502 ../../../virt/kvm/api.rst:2504
#: ../../../virt/kvm/api.rst:2506 ../../../virt/kvm/api.rst:2507
#: ../../../virt/kvm/api.rst:2508 ../../../virt/kvm/api.rst:2509
#: ../../../virt/kvm/api.rst:2510 ../../../virt/kvm/api.rst:2511
#: ../../../virt/kvm/api.rst:2512 ../../../virt/kvm/api.rst:2525
#: ../../../virt/kvm/api.rst:2528 ../../../virt/kvm/api.rst:2529
#: ../../../virt/kvm/api.rst:2530 ../../../virt/kvm/api.rst:2531
#: ../../../virt/kvm/api.rst:2599 ../../../virt/kvm/api.rst:2600
msgid "32"
msgstr ""

#: ../../../virt/kvm/api.rst:2351
msgid "KVM_REG_PPC_AMR"
msgstr ""

#: ../../../virt/kvm/api.rst:2352
msgid "KVM_REG_PPC_UAMOR"
msgstr ""

#: ../../../virt/kvm/api.rst:2353
msgid "KVM_REG_PPC_MMCR0"
msgstr ""

#: ../../../virt/kvm/api.rst:2354
msgid "KVM_REG_PPC_MMCR1"
msgstr ""

#: ../../../virt/kvm/api.rst:2355
msgid "KVM_REG_PPC_MMCRA"
msgstr ""

#: ../../../virt/kvm/api.rst:2356
msgid "KVM_REG_PPC_MMCR2"
msgstr ""

#: ../../../virt/kvm/api.rst:2357
msgid "KVM_REG_PPC_MMCRS"
msgstr ""

#: ../../../virt/kvm/api.rst:2358
msgid "KVM_REG_PPC_MMCR3"
msgstr ""

#: ../../../virt/kvm/api.rst:2359
msgid "KVM_REG_PPC_SIAR"
msgstr ""

#: ../../../virt/kvm/api.rst:2360
msgid "KVM_REG_PPC_SDAR"
msgstr ""

#: ../../../virt/kvm/api.rst:2361
msgid "KVM_REG_PPC_SIER"
msgstr ""

#: ../../../virt/kvm/api.rst:2362
msgid "KVM_REG_PPC_SIER2"
msgstr ""

#: ../../../virt/kvm/api.rst:2363
msgid "KVM_REG_PPC_SIER3"
msgstr ""

#: ../../../virt/kvm/api.rst:2364
msgid "KVM_REG_PPC_PMC1"
msgstr ""

#: ../../../virt/kvm/api.rst:2365
msgid "KVM_REG_PPC_PMC2"
msgstr ""

#: ../../../virt/kvm/api.rst:2366
msgid "KVM_REG_PPC_PMC3"
msgstr ""

#: ../../../virt/kvm/api.rst:2367
msgid "KVM_REG_PPC_PMC4"
msgstr ""

#: ../../../virt/kvm/api.rst:2368
msgid "KVM_REG_PPC_PMC5"
msgstr ""

#: ../../../virt/kvm/api.rst:2369
msgid "KVM_REG_PPC_PMC6"
msgstr ""

#: ../../../virt/kvm/api.rst:2370
msgid "KVM_REG_PPC_PMC7"
msgstr ""

#: ../../../virt/kvm/api.rst:2371
msgid "KVM_REG_PPC_PMC8"
msgstr ""

#: ../../../virt/kvm/api.rst:2372
msgid "KVM_REG_PPC_FPR0"
msgstr ""

#: ../../../virt/kvm/api.rst:2373 ../../../virt/kvm/api.rst:2376
#: ../../../virt/kvm/api.rst:2379 ../../../virt/kvm/api.rst:2453
#: ../../../virt/kvm/api.rst:2456 ../../../virt/kvm/api.rst:2471
#: ../../../virt/kvm/api.rst:2583 ../../../virt/kvm/api.rst:2597
#: ../../../virt/kvm/api.rst:2876 ../../../virt/kvm/api.rst:2893
msgid "..."
msgstr ""

#: ../../../virt/kvm/api.rst:2374
msgid "KVM_REG_PPC_FPR31"
msgstr ""

#: ../../../virt/kvm/api.rst:2375
msgid "KVM_REG_PPC_VR0"
msgstr ""

#: ../../../virt/kvm/api.rst:2375 ../../../virt/kvm/api.rst:2377
#: ../../../virt/kvm/api.rst:2378 ../../../virt/kvm/api.rst:2380
#: ../../../virt/kvm/api.rst:2384 ../../../virt/kvm/api.rst:2385
#: ../../../virt/kvm/api.rst:2409 ../../../virt/kvm/api.rst:2455
#: ../../../virt/kvm/api.rst:2457 ../../../virt/kvm/api.rst:2527
#: ../../../virt/kvm/api.rst:2595 ../../../virt/kvm/api.rst:2596
#: ../../../virt/kvm/api.rst:2598
msgid "128"
msgstr ""

#: ../../../virt/kvm/api.rst:2377
msgid "KVM_REG_PPC_VR31"
msgstr ""

#: ../../../virt/kvm/api.rst:2378
msgid "KVM_REG_PPC_VSR0"
msgstr ""

#: ../../../virt/kvm/api.rst:2380
msgid "KVM_REG_PPC_VSR31"
msgstr ""

#: ../../../virt/kvm/api.rst:2381
msgid "KVM_REG_PPC_FPSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2382
msgid "KVM_REG_PPC_VSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2383
msgid "KVM_REG_PPC_VPA_ADDR"
msgstr ""

#: ../../../virt/kvm/api.rst:2384
msgid "KVM_REG_PPC_VPA_SLB"
msgstr ""

#: ../../../virt/kvm/api.rst:2385
msgid "KVM_REG_PPC_VPA_DTL"
msgstr ""

#: ../../../virt/kvm/api.rst:2386
msgid "KVM_REG_PPC_EPCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2387
msgid "KVM_REG_PPC_EPR"
msgstr ""

#: ../../../virt/kvm/api.rst:2388
msgid "KVM_REG_PPC_TCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2389
msgid "KVM_REG_PPC_TSR"
msgstr ""

#: ../../../virt/kvm/api.rst:2390
msgid "KVM_REG_PPC_OR_TSR"
msgstr ""

#: ../../../virt/kvm/api.rst:2391
msgid "KVM_REG_PPC_CLEAR_TSR"
msgstr ""

#: ../../../virt/kvm/api.rst:2392
msgid "KVM_REG_PPC_MAS0"
msgstr ""

#: ../../../virt/kvm/api.rst:2393
msgid "KVM_REG_PPC_MAS1"
msgstr ""

#: ../../../virt/kvm/api.rst:2394
msgid "KVM_REG_PPC_MAS2"
msgstr ""

#: ../../../virt/kvm/api.rst:2395
msgid "KVM_REG_PPC_MAS7_3"
msgstr ""

#: ../../../virt/kvm/api.rst:2396
msgid "KVM_REG_PPC_MAS4"
msgstr ""

#: ../../../virt/kvm/api.rst:2397
msgid "KVM_REG_PPC_MAS6"
msgstr ""

#: ../../../virt/kvm/api.rst:2398
msgid "KVM_REG_PPC_MMUCFG"
msgstr ""

#: ../../../virt/kvm/api.rst:2399
msgid "KVM_REG_PPC_TLB0CFG"
msgstr ""

#: ../../../virt/kvm/api.rst:2400
msgid "KVM_REG_PPC_TLB1CFG"
msgstr ""

#: ../../../virt/kvm/api.rst:2401
msgid "KVM_REG_PPC_TLB2CFG"
msgstr ""

#: ../../../virt/kvm/api.rst:2402
msgid "KVM_REG_PPC_TLB3CFG"
msgstr ""

#: ../../../virt/kvm/api.rst:2403
msgid "KVM_REG_PPC_TLB0PS"
msgstr ""

#: ../../../virt/kvm/api.rst:2404
msgid "KVM_REG_PPC_TLB1PS"
msgstr ""

#: ../../../virt/kvm/api.rst:2405
msgid "KVM_REG_PPC_TLB2PS"
msgstr ""

#: ../../../virt/kvm/api.rst:2406
msgid "KVM_REG_PPC_TLB3PS"
msgstr ""

#: ../../../virt/kvm/api.rst:2407
msgid "KVM_REG_PPC_EPTCFG"
msgstr ""

#: ../../../virt/kvm/api.rst:2408
msgid "KVM_REG_PPC_ICP_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:2409
msgid "KVM_REG_PPC_VP_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:2410
msgid "KVM_REG_PPC_TB_OFFSET"
msgstr ""

#: ../../../virt/kvm/api.rst:2411
msgid "KVM_REG_PPC_SPMC1"
msgstr ""

#: ../../../virt/kvm/api.rst:2412
msgid "KVM_REG_PPC_SPMC2"
msgstr ""

#: ../../../virt/kvm/api.rst:2413
msgid "KVM_REG_PPC_IAMR"
msgstr ""

#: ../../../virt/kvm/api.rst:2414
msgid "KVM_REG_PPC_TFHAR"
msgstr ""

#: ../../../virt/kvm/api.rst:2415
msgid "KVM_REG_PPC_TFIAR"
msgstr ""

#: ../../../virt/kvm/api.rst:2416
msgid "KVM_REG_PPC_TEXASR"
msgstr ""

#: ../../../virt/kvm/api.rst:2417
msgid "KVM_REG_PPC_FSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2418
msgid "KVM_REG_PPC_PSPB"
msgstr ""

#: ../../../virt/kvm/api.rst:2419
msgid "KVM_REG_PPC_EBBHR"
msgstr ""

#: ../../../virt/kvm/api.rst:2420
msgid "KVM_REG_PPC_EBBRR"
msgstr ""

#: ../../../virt/kvm/api.rst:2421
msgid "KVM_REG_PPC_BESCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2422
msgid "KVM_REG_PPC_TAR"
msgstr ""

#: ../../../virt/kvm/api.rst:2423
msgid "KVM_REG_PPC_DPDES"
msgstr ""

#: ../../../virt/kvm/api.rst:2424
msgid "KVM_REG_PPC_DAWR"
msgstr ""

#: ../../../virt/kvm/api.rst:2425
msgid "KVM_REG_PPC_DAWRX"
msgstr ""

#: ../../../virt/kvm/api.rst:2426
msgid "KVM_REG_PPC_CIABR"
msgstr ""

#: ../../../virt/kvm/api.rst:2427
msgid "KVM_REG_PPC_IC"
msgstr ""

#: ../../../virt/kvm/api.rst:2428
msgid "KVM_REG_PPC_VTB"
msgstr ""

#: ../../../virt/kvm/api.rst:2429
msgid "KVM_REG_PPC_CSIGR"
msgstr ""

#: ../../../virt/kvm/api.rst:2430
msgid "KVM_REG_PPC_TACR"
msgstr ""

#: ../../../virt/kvm/api.rst:2431
msgid "KVM_REG_PPC_TCSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2432
msgid "KVM_REG_PPC_PID"
msgstr ""

#: ../../../virt/kvm/api.rst:2433
msgid "KVM_REG_PPC_ACOP"
msgstr ""

#: ../../../virt/kvm/api.rst:2434
msgid "KVM_REG_PPC_VRSAVE"
msgstr ""

#: ../../../virt/kvm/api.rst:2435
msgid "KVM_REG_PPC_LPCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2436
msgid "KVM_REG_PPC_LPCR_64"
msgstr ""

#: ../../../virt/kvm/api.rst:2437
msgid "KVM_REG_PPC_PPR"
msgstr ""

#: ../../../virt/kvm/api.rst:2438
msgid "KVM_REG_PPC_ARCH_COMPAT"
msgstr ""

#: ../../../virt/kvm/api.rst:2439
msgid "KVM_REG_PPC_DABRX"
msgstr ""

#: ../../../virt/kvm/api.rst:2440
msgid "KVM_REG_PPC_WORT"
msgstr ""

#: ../../../virt/kvm/api.rst:2441
msgid "KVM_REG_PPC_SPRG9"
msgstr ""

#: ../../../virt/kvm/api.rst:2442
msgid "KVM_REG_PPC_DBSR"
msgstr ""

#: ../../../virt/kvm/api.rst:2443
msgid "KVM_REG_PPC_TIDR"
msgstr ""

#: ../../../virt/kvm/api.rst:2444
msgid "KVM_REG_PPC_PSSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2445
msgid "KVM_REG_PPC_DEC_EXPIRY"
msgstr ""

#: ../../../virt/kvm/api.rst:2446
msgid "KVM_REG_PPC_PTCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2447
msgid "KVM_REG_PPC_HASHKEYR"
msgstr ""

#: ../../../virt/kvm/api.rst:2448
msgid "KVM_REG_PPC_HASHPKEYR"
msgstr ""

#: ../../../virt/kvm/api.rst:2449
msgid "KVM_REG_PPC_DAWR1"
msgstr ""

#: ../../../virt/kvm/api.rst:2450
msgid "KVM_REG_PPC_DAWRX1"
msgstr ""

#: ../../../virt/kvm/api.rst:2451
msgid "KVM_REG_PPC_DEXCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2452
msgid "KVM_REG_PPC_TM_GPR0"
msgstr ""

#: ../../../virt/kvm/api.rst:2454
msgid "KVM_REG_PPC_TM_GPR31"
msgstr ""

#: ../../../virt/kvm/api.rst:2455
msgid "KVM_REG_PPC_TM_VSR0"
msgstr ""

#: ../../../virt/kvm/api.rst:2457
msgid "KVM_REG_PPC_TM_VSR63"
msgstr ""

#: ../../../virt/kvm/api.rst:2458
msgid "KVM_REG_PPC_TM_CR"
msgstr ""

#: ../../../virt/kvm/api.rst:2459
msgid "KVM_REG_PPC_TM_LR"
msgstr ""

#: ../../../virt/kvm/api.rst:2460
msgid "KVM_REG_PPC_TM_CTR"
msgstr ""

#: ../../../virt/kvm/api.rst:2461
msgid "KVM_REG_PPC_TM_FPSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2462
msgid "KVM_REG_PPC_TM_AMR"
msgstr ""

#: ../../../virt/kvm/api.rst:2463
msgid "KVM_REG_PPC_TM_PPR"
msgstr ""

#: ../../../virt/kvm/api.rst:2464
msgid "KVM_REG_PPC_TM_VRSAVE"
msgstr ""

#: ../../../virt/kvm/api.rst:2465
msgid "KVM_REG_PPC_TM_VSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2466
msgid "KVM_REG_PPC_TM_DSCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2467
msgid "KVM_REG_PPC_TM_TAR"
msgstr ""

#: ../../../virt/kvm/api.rst:2468
msgid "KVM_REG_PPC_TM_XER"
msgstr ""

#: ../../../virt/kvm/api.rst:2470 ../../../virt/kvm/api.rst:2472
#: ../../../virt/kvm/api.rst:2473 ../../../virt/kvm/api.rst:2474
#: ../../../virt/kvm/api.rst:2475 ../../../virt/kvm/api.rst:2476
#: ../../../virt/kvm/api.rst:2477 ../../../virt/kvm/api.rst:2478
#: ../../../virt/kvm/api.rst:2479 ../../../virt/kvm/api.rst:2480
#: ../../../virt/kvm/api.rst:2481 ../../../virt/kvm/api.rst:2482
#: ../../../virt/kvm/api.rst:2483 ../../../virt/kvm/api.rst:2484
#: ../../../virt/kvm/api.rst:2485 ../../../virt/kvm/api.rst:2486
#: ../../../virt/kvm/api.rst:2487 ../../../virt/kvm/api.rst:2488
#: ../../../virt/kvm/api.rst:2489 ../../../virt/kvm/api.rst:2490
#: ../../../virt/kvm/api.rst:2491 ../../../virt/kvm/api.rst:2492
#: ../../../virt/kvm/api.rst:2493 ../../../virt/kvm/api.rst:2494
#: ../../../virt/kvm/api.rst:2495 ../../../virt/kvm/api.rst:2496
#: ../../../virt/kvm/api.rst:2497 ../../../virt/kvm/api.rst:2498
#: ../../../virt/kvm/api.rst:2499 ../../../virt/kvm/api.rst:2500
#: ../../../virt/kvm/api.rst:2501 ../../../virt/kvm/api.rst:2502
#: ../../../virt/kvm/api.rst:2503 ../../../virt/kvm/api.rst:2504
#: ../../../virt/kvm/api.rst:2505 ../../../virt/kvm/api.rst:2506
#: ../../../virt/kvm/api.rst:2507 ../../../virt/kvm/api.rst:2508
#: ../../../virt/kvm/api.rst:2509 ../../../virt/kvm/api.rst:2510
#: ../../../virt/kvm/api.rst:2511 ../../../virt/kvm/api.rst:2512
#: ../../../virt/kvm/api.rst:2513 ../../../virt/kvm/api.rst:2514
#: ../../../virt/kvm/api.rst:2515 ../../../virt/kvm/api.rst:2516
#: ../../../virt/kvm/api.rst:2517 ../../../virt/kvm/api.rst:2518
#: ../../../virt/kvm/api.rst:2519 ../../../virt/kvm/api.rst:2520
#: ../../../virt/kvm/api.rst:2521 ../../../virt/kvm/api.rst:2522
#: ../../../virt/kvm/api.rst:2523 ../../../virt/kvm/api.rst:2524
#: ../../../virt/kvm/api.rst:2525 ../../../virt/kvm/api.rst:2526
#: ../../../virt/kvm/api.rst:2527 ../../../virt/kvm/api.rst:2528
#: ../../../virt/kvm/api.rst:2529 ../../../virt/kvm/api.rst:2530
#: ../../../virt/kvm/api.rst:2531
msgid "MIPS"
msgstr ""

#: ../../../virt/kvm/api.rst:2470
msgid "KVM_REG_MIPS_R0"
msgstr ""

#: ../../../virt/kvm/api.rst:2472
msgid "KVM_REG_MIPS_R31"
msgstr ""

#: ../../../virt/kvm/api.rst:2473
msgid "KVM_REG_MIPS_HI"
msgstr ""

#: ../../../virt/kvm/api.rst:2474
msgid "KVM_REG_MIPS_LO"
msgstr ""

#: ../../../virt/kvm/api.rst:2475
msgid "KVM_REG_MIPS_PC"
msgstr ""

#: ../../../virt/kvm/api.rst:2476
msgid "KVM_REG_MIPS_CP0_INDEX"
msgstr ""

#: ../../../virt/kvm/api.rst:2477
msgid "KVM_REG_MIPS_CP0_ENTRYLO0"
msgstr ""

#: ../../../virt/kvm/api.rst:2478
msgid "KVM_REG_MIPS_CP0_ENTRYLO1"
msgstr ""

#: ../../../virt/kvm/api.rst:2479
msgid "KVM_REG_MIPS_CP0_CONTEXT"
msgstr ""

#: ../../../virt/kvm/api.rst:2480
msgid "KVM_REG_MIPS_CP0_CONTEXTCONFIG"
msgstr ""

#: ../../../virt/kvm/api.rst:2481
msgid "KVM_REG_MIPS_CP0_USERLOCAL"
msgstr ""

#: ../../../virt/kvm/api.rst:2482
msgid "KVM_REG_MIPS_CP0_XCONTEXTCONFIG"
msgstr ""

#: ../../../virt/kvm/api.rst:2483
msgid "KVM_REG_MIPS_CP0_PAGEMASK"
msgstr ""

#: ../../../virt/kvm/api.rst:2484
msgid "KVM_REG_MIPS_CP0_PAGEGRAIN"
msgstr ""

#: ../../../virt/kvm/api.rst:2485
msgid "KVM_REG_MIPS_CP0_SEGCTL0"
msgstr ""

#: ../../../virt/kvm/api.rst:2486
msgid "KVM_REG_MIPS_CP0_SEGCTL1"
msgstr ""

#: ../../../virt/kvm/api.rst:2487
msgid "KVM_REG_MIPS_CP0_SEGCTL2"
msgstr ""

#: ../../../virt/kvm/api.rst:2488
msgid "KVM_REG_MIPS_CP0_PWBASE"
msgstr ""

#: ../../../virt/kvm/api.rst:2489
msgid "KVM_REG_MIPS_CP0_PWFIELD"
msgstr ""

#: ../../../virt/kvm/api.rst:2490
msgid "KVM_REG_MIPS_CP0_PWSIZE"
msgstr ""

#: ../../../virt/kvm/api.rst:2491
msgid "KVM_REG_MIPS_CP0_WIRED"
msgstr ""

#: ../../../virt/kvm/api.rst:2492
msgid "KVM_REG_MIPS_CP0_PWCTL"
msgstr ""

#: ../../../virt/kvm/api.rst:2493
msgid "KVM_REG_MIPS_CP0_HWRENA"
msgstr ""

#: ../../../virt/kvm/api.rst:2494
msgid "KVM_REG_MIPS_CP0_BADVADDR"
msgstr ""

#: ../../../virt/kvm/api.rst:2495
msgid "KVM_REG_MIPS_CP0_BADINSTR"
msgstr ""

#: ../../../virt/kvm/api.rst:2496
msgid "KVM_REG_MIPS_CP0_BADINSTRP"
msgstr ""

#: ../../../virt/kvm/api.rst:2497
msgid "KVM_REG_MIPS_CP0_COUNT"
msgstr ""

#: ../../../virt/kvm/api.rst:2498
msgid "KVM_REG_MIPS_CP0_ENTRYHI"
msgstr ""

#: ../../../virt/kvm/api.rst:2499
msgid "KVM_REG_MIPS_CP0_COMPARE"
msgstr ""

#: ../../../virt/kvm/api.rst:2500
msgid "KVM_REG_MIPS_CP0_STATUS"
msgstr ""

#: ../../../virt/kvm/api.rst:2501
msgid "KVM_REG_MIPS_CP0_INTCTL"
msgstr ""

#: ../../../virt/kvm/api.rst:2502
msgid "KVM_REG_MIPS_CP0_CAUSE"
msgstr ""

#: ../../../virt/kvm/api.rst:2503
msgid "KVM_REG_MIPS_CP0_EPC"
msgstr ""

#: ../../../virt/kvm/api.rst:2504
msgid "KVM_REG_MIPS_CP0_PRID"
msgstr ""

#: ../../../virt/kvm/api.rst:2505
msgid "KVM_REG_MIPS_CP0_EBASE"
msgstr ""

#: ../../../virt/kvm/api.rst:2506
msgid "KVM_REG_MIPS_CP0_CONFIG"
msgstr ""

#: ../../../virt/kvm/api.rst:2507
msgid "KVM_REG_MIPS_CP0_CONFIG1"
msgstr ""

#: ../../../virt/kvm/api.rst:2508
msgid "KVM_REG_MIPS_CP0_CONFIG2"
msgstr ""

#: ../../../virt/kvm/api.rst:2509
msgid "KVM_REG_MIPS_CP0_CONFIG3"
msgstr ""

#: ../../../virt/kvm/api.rst:2510
msgid "KVM_REG_MIPS_CP0_CONFIG4"
msgstr ""

#: ../../../virt/kvm/api.rst:2511
msgid "KVM_REG_MIPS_CP0_CONFIG5"
msgstr ""

#: ../../../virt/kvm/api.rst:2512
msgid "KVM_REG_MIPS_CP0_CONFIG7"
msgstr ""

#: ../../../virt/kvm/api.rst:2513
msgid "KVM_REG_MIPS_CP0_XCONTEXT"
msgstr ""

#: ../../../virt/kvm/api.rst:2514
msgid "KVM_REG_MIPS_CP0_ERROREPC"
msgstr ""

#: ../../../virt/kvm/api.rst:2515
msgid "KVM_REG_MIPS_CP0_KSCRATCH1"
msgstr ""

#: ../../../virt/kvm/api.rst:2516
msgid "KVM_REG_MIPS_CP0_KSCRATCH2"
msgstr ""

#: ../../../virt/kvm/api.rst:2517
msgid "KVM_REG_MIPS_CP0_KSCRATCH3"
msgstr ""

#: ../../../virt/kvm/api.rst:2518
msgid "KVM_REG_MIPS_CP0_KSCRATCH4"
msgstr ""

#: ../../../virt/kvm/api.rst:2519
msgid "KVM_REG_MIPS_CP0_KSCRATCH5"
msgstr ""

#: ../../../virt/kvm/api.rst:2520
msgid "KVM_REG_MIPS_CP0_KSCRATCH6"
msgstr ""

#: ../../../virt/kvm/api.rst:2521
msgid "KVM_REG_MIPS_CP0_MAAR(0..63)"
msgstr ""

#: ../../../virt/kvm/api.rst:2522
msgid "KVM_REG_MIPS_COUNT_CTL"
msgstr ""

#: ../../../virt/kvm/api.rst:2523
msgid "KVM_REG_MIPS_COUNT_RESUME"
msgstr ""

#: ../../../virt/kvm/api.rst:2524
msgid "KVM_REG_MIPS_COUNT_HZ"
msgstr ""

#: ../../../virt/kvm/api.rst:2525
msgid "KVM_REG_MIPS_FPR_32(0..31)"
msgstr ""

#: ../../../virt/kvm/api.rst:2526
msgid "KVM_REG_MIPS_FPR_64(0..31)"
msgstr ""

#: ../../../virt/kvm/api.rst:2527
msgid "KVM_REG_MIPS_VEC_128(0..31)"
msgstr ""

#: ../../../virt/kvm/api.rst:2528
msgid "KVM_REG_MIPS_FCR_IR"
msgstr ""

#: ../../../virt/kvm/api.rst:2529
msgid "KVM_REG_MIPS_FCR_CSR"
msgstr ""

#: ../../../virt/kvm/api.rst:2530
msgid "KVM_REG_MIPS_MSA_IR"
msgstr ""

#: ../../../virt/kvm/api.rst:2531
msgid "KVM_REG_MIPS_MSA_CSR"
msgstr ""

#: ../../../virt/kvm/api.rst:2534
msgid ""
"ARM registers are mapped using the lower 32 bits.  The upper 16 of that is "
"the register group type, or coprocessor number:"
msgstr ""

#: ../../../virt/kvm/api.rst:2537
msgid "ARM core registers have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2541
msgid "ARM 32-bit CP15 registers have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2545
msgid "ARM 64-bit CP15 registers have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2549
msgid "ARM CCSIDR registers are demultiplexed by CSSELR value::"
msgstr ""

#: ../../../virt/kvm/api.rst:2553
msgid "ARM 32-bit VFP control registers have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2557
msgid "ARM 64-bit FP registers have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2561
msgid "ARM firmware pseudo-registers have the following bit pattern::"
msgstr ""

#: ../../../virt/kvm/api.rst:2566
msgid ""
"arm64 registers are mapped using the lower 32 bits. The upper 16 of that is "
"the register group type, or coprocessor number:"
msgstr ""

#: ../../../virt/kvm/api.rst:2569
msgid ""
"arm64 core/FP-SIMD registers have the following id bit patterns. Note that "
"the size of the access is variable, as the kvm_regs structure contains "
"elements ranging from 32 to 128 bits. The index is a 32bit value in the "
"kvm_regs structure seen as a 32bit array::"
msgstr ""

#: ../../../virt/kvm/api.rst:2576
msgid "Specifically:"
msgstr ""

#: ../../../virt/kvm/api.rst:2579 ../../../virt/kvm/api.rst:2772
#: ../../../virt/kvm/api.rst:2790 ../../../virt/kvm/api.rst:2836
#: ../../../virt/kvm/api.rst:2857 ../../../virt/kvm/api.rst:2873
#: ../../../virt/kvm/api.rst:2890
msgid "Encoding"
msgstr ""

#: ../../../virt/kvm/api.rst:2579
msgid "Bits"
msgstr ""

#: ../../../virt/kvm/api.rst:2579
msgid "kvm_regs member"
msgstr ""

#: ../../../virt/kvm/api.rst:2581
msgid "0x6030 0000 0010 0000"
msgstr ""

#: ../../../virt/kvm/api.rst:2581
msgid "X0"
msgstr ""

#: ../../../virt/kvm/api.rst:2581
msgid "regs.regs[0]"
msgstr ""

#: ../../../virt/kvm/api.rst:2582
msgid "0x6030 0000 0010 0002"
msgstr ""

#: ../../../virt/kvm/api.rst:2582
msgid "X1"
msgstr ""

#: ../../../virt/kvm/api.rst:2582
msgid "regs.regs[1]"
msgstr ""

#: ../../../virt/kvm/api.rst:2584
msgid "0x6030 0000 0010 003c"
msgstr ""

#: ../../../virt/kvm/api.rst:2584
msgid "X30"
msgstr ""

#: ../../../virt/kvm/api.rst:2584
msgid "regs.regs[30]"
msgstr ""

#: ../../../virt/kvm/api.rst:2585
msgid "0x6030 0000 0010 003e"
msgstr ""

#: ../../../virt/kvm/api.rst:2585
msgid "SP"
msgstr ""

#: ../../../virt/kvm/api.rst:2585 ../../../virt/kvm/api.rst:2794
msgid "regs.sp"
msgstr ""

#: ../../../virt/kvm/api.rst:2586
msgid "0x6030 0000 0010 0040"
msgstr ""

#: ../../../virt/kvm/api.rst:2586
msgid "PC"
msgstr ""

#: ../../../virt/kvm/api.rst:2586 ../../../virt/kvm/api.rst:2792
msgid "regs.pc"
msgstr ""

#: ../../../virt/kvm/api.rst:2587
msgid "0x6030 0000 0010 0042"
msgstr ""

#: ../../../virt/kvm/api.rst:2587
msgid "PSTATE"
msgstr ""

#: ../../../virt/kvm/api.rst:2587
msgid "regs.pstate"
msgstr ""

#: ../../../virt/kvm/api.rst:2588
msgid "0x6030 0000 0010 0044"
msgstr ""

#: ../../../virt/kvm/api.rst:2588
msgid "SP_EL1"
msgstr ""

#: ../../../virt/kvm/api.rst:2588
msgid "sp_el1"
msgstr ""

#: ../../../virt/kvm/api.rst:2589
msgid "0x6030 0000 0010 0046"
msgstr ""

#: ../../../virt/kvm/api.rst:2589
msgid "ELR_EL1"
msgstr ""

#: ../../../virt/kvm/api.rst:2589
msgid "elr_el1"
msgstr ""

#: ../../../virt/kvm/api.rst:2590
msgid "0x6030 0000 0010 0048"
msgstr ""

#: ../../../virt/kvm/api.rst:2590
msgid "SPSR_EL1"
msgstr ""

#: ../../../virt/kvm/api.rst:2590
msgid "spsr[KVM_SPSR_EL1] (alias SPSR_SVC)"
msgstr ""

#: ../../../virt/kvm/api.rst:2591
msgid "0x6030 0000 0010 004a"
msgstr ""

#: ../../../virt/kvm/api.rst:2591
msgid "SPSR_ABT"
msgstr ""

#: ../../../virt/kvm/api.rst:2591
msgid "spsr[KVM_SPSR_ABT]"
msgstr ""

#: ../../../virt/kvm/api.rst:2592
msgid "0x6030 0000 0010 004c"
msgstr ""

#: ../../../virt/kvm/api.rst:2592
msgid "SPSR_UND"
msgstr ""

#: ../../../virt/kvm/api.rst:2592
msgid "spsr[KVM_SPSR_UND]"
msgstr ""

#: ../../../virt/kvm/api.rst:2593
msgid "0x6030 0000 0010 004e"
msgstr ""

#: ../../../virt/kvm/api.rst:2593
msgid "SPSR_IRQ"
msgstr ""

#: ../../../virt/kvm/api.rst:2593
msgid "spsr[KVM_SPSR_IRQ]"
msgstr ""

#: ../../../virt/kvm/api.rst:2594
msgid "0x6030 0000 0010 0050"
msgstr ""

#: ../../../virt/kvm/api.rst:2594
msgid "SPSR_FIQ"
msgstr ""

#: ../../../virt/kvm/api.rst:2594
msgid "spsr[KVM_SPSR_FIQ]"
msgstr ""

#: ../../../virt/kvm/api.rst:2595
msgid "0x6040 0000 0010 0054"
msgstr ""

#: ../../../virt/kvm/api.rst:2595
msgid "V0"
msgstr ""

#: ../../../virt/kvm/api.rst:2595
msgid "fp_regs.vregs[0]    [1]_"
msgstr ""

#: ../../../virt/kvm/api.rst:2596
msgid "0x6040 0000 0010 0058"
msgstr ""

#: ../../../virt/kvm/api.rst:2596
msgid "V1"
msgstr ""

#: ../../../virt/kvm/api.rst:2596
msgid "fp_regs.vregs[1]    [1]_"
msgstr ""

#: ../../../virt/kvm/api.rst:2598
msgid "0x6040 0000 0010 00d0"
msgstr ""

#: ../../../virt/kvm/api.rst:2598
msgid "V31"
msgstr ""

#: ../../../virt/kvm/api.rst:2598
msgid "fp_regs.vregs[31]   [1]_"
msgstr ""

#: ../../../virt/kvm/api.rst:2599
msgid "0x6020 0000 0010 00d4"
msgstr ""

#: ../../../virt/kvm/api.rst:2599
msgid "FPSR"
msgstr ""

#: ../../../virt/kvm/api.rst:2599
msgid "fp_regs.fpsr"
msgstr ""

#: ../../../virt/kvm/api.rst:2600
msgid "0x6020 0000 0010 00d5"
msgstr ""

#: ../../../virt/kvm/api.rst:2600
msgid "FPCR"
msgstr ""

#: ../../../virt/kvm/api.rst:2600
msgid "fp_regs.fpcr"
msgstr ""

#: ../../../virt/kvm/api.rst:2603
msgid ""
"These encodings are not accepted for SVE-enabled vcpus.  See :ref:"
"`KVM_ARM_VCPU_INIT`."
msgstr ""

#: ../../../virt/kvm/api.rst:2606
msgid ""
"The equivalent register content can be accessed via bits [127:0] of the "
"corresponding SVE Zn registers instead for vcpus that have SVE enabled (see "
"below)."
msgstr ""

#: ../../../virt/kvm/api.rst:2610
msgid "arm64 CCSIDR registers are demultiplexed by CSSELR value::"
msgstr ""

#: ../../../virt/kvm/api.rst:2614
msgid "arm64 system registers have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2620
msgid ""
"Two system register IDs do not follow the specified pattern.  These are "
"KVM_REG_ARM_TIMER_CVAL and KVM_REG_ARM_TIMER_CNT, which map to system "
"registers CNTV_CVAL_EL0 and CNTVCT_EL0 respectively.  These two had their "
"values accidentally swapped, which means TIMER_CVAL is derived from the "
"register encoding for CNTVCT_EL0 and TIMER_CNT is derived from the register "
"encoding for CNTV_CVAL_EL0.  As this is API, it must remain this way."
msgstr ""

#: ../../../virt/kvm/api.rst:2628
msgid "arm64 firmware pseudo-registers have the following bit pattern::"
msgstr ""

#: ../../../virt/kvm/api.rst:2632
msgid "arm64 SVE registers have the following bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2639
msgid ""
"Access to register IDs where 2048 * slice >= 128 * max_vq will fail with "
"ENOENT.  max_vq is the vcpu's maximum supported vector length in 128-bit "
"quadwords: see [2]_ below."
msgstr ""

#: ../../../virt/kvm/api.rst:2643
msgid ""
"These registers are only accessible on vcpus for which SVE is enabled. See "
"KVM_ARM_VCPU_INIT for details."
msgstr ""

#: ../../../virt/kvm/api.rst:2646
msgid ""
"In addition, except for KVM_REG_ARM64_SVE_VLS, these registers are not "
"accessible until the vcpu's SVE configuration has been finalized using "
"KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE).  See KVM_ARM_VCPU_INIT and "
"KVM_ARM_VCPU_FINALIZE for more information about this procedure."
msgstr ""

#: ../../../virt/kvm/api.rst:2651
msgid ""
"KVM_REG_ARM64_SVE_VLS is a pseudo-register that allows the set of vector "
"lengths supported by the vcpu to be discovered and configured by userspace.  "
"When transferred to or from user memory via KVM_GET_ONE_REG or "
"KVM_SET_ONE_REG, the value of this register is of type "
"__u64[KVM_ARM64_SVE_VLS_WORDS], and encodes the set of vector lengths as "
"follows::"
msgstr ""

#: ../../../virt/kvm/api.rst:2667
msgid ""
"The maximum value vq for which the above condition is true is max_vq.  This "
"is the maximum vector length available to the guest on this vcpu, and "
"determines which register slices are visible through this ioctl interface."
msgstr ""

#: ../../../virt/kvm/api.rst:2672
msgid ""
"(See Documentation/arch/arm64/sve.rst for an explanation of the \"vq\" "
"nomenclature.)"
msgstr ""

#: ../../../virt/kvm/api.rst:2675
msgid ""
"KVM_REG_ARM64_SVE_VLS is only accessible after KVM_ARM_VCPU_INIT. "
"KVM_ARM_VCPU_INIT initialises it to the best set of vector lengths that the "
"host supports."
msgstr ""

#: ../../../virt/kvm/api.rst:2679
msgid ""
"Userspace may subsequently modify it if desired until the vcpu's SVE "
"configuration is finalized using KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE)."
msgstr ""

#: ../../../virt/kvm/api.rst:2682
msgid ""
"Apart from simply removing all vector lengths from the host set that exceed "
"some value, support for arbitrarily chosen sets of vector lengths is "
"hardware-dependent and may not be available.  Attempting to configure an "
"invalid set of vector lengths via KVM_SET_ONE_REG will fail with EINVAL."
msgstr ""

#: ../../../virt/kvm/api.rst:2688
msgid ""
"After the vcpu's SVE configuration is finalized, further attempts to write "
"this register will fail with EPERM."
msgstr ""

#: ../../../virt/kvm/api.rst:2691
msgid ""
"arm64 bitmap feature firmware pseudo-registers have the following bit "
"pattern::"
msgstr ""

#: ../../../virt/kvm/api.rst:2695
msgid ""
"The bitmap feature firmware registers exposes the hypercall services that "
"are available for userspace to configure. The set bits corresponds to the "
"services that are available for the guests to access. By default, KVM sets "
"all the supported bits during VM initialization. The userspace can discover "
"the available services via KVM_GET_ONE_REG, and write back the bitmap "
"corresponding to the features that it wishes guests to see via "
"KVM_SET_ONE_REG."
msgstr ""

#: ../../../virt/kvm/api.rst:2703
msgid ""
"Note: These registers are immutable once any of the vCPUs of the VM has run "
"at least once. A KVM_SET_ONE_REG in such a scenario will return a -EBUSY to "
"userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:2707
msgid "(See Documentation/virt/kvm/arm/hypercalls.rst for more details.)"
msgstr ""

#: ../../../virt/kvm/api.rst:2710
msgid ""
"MIPS registers are mapped using the lower 32 bits.  The upper 16 of that is "
"the register group type:"
msgstr ""

#: ../../../virt/kvm/api.rst:2713
msgid "MIPS core registers (see above) have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2717
msgid ""
"MIPS CP0 registers (see KVM_REG_MIPS_CP0_* above) have the following id bit "
"patterns depending on whether they're 32-bit or 64-bit registers::"
msgstr ""

#: ../../../virt/kvm/api.rst:2723
msgid ""
"Note: KVM_REG_MIPS_CP0_ENTRYLO0 and KVM_REG_MIPS_CP0_ENTRYLO1 are the MIPS64 "
"versions of the EntryLo registers regardless of the word size of the host "
"hardware, host kernel, guest, and whether XPA is present in the guest, i.e. "
"with the RI and XI bits (if they exist) in bits 63 and 62 respectively, and "
"the PFNX field starting at bit 30."
msgstr ""

#: ../../../virt/kvm/api.rst:2729
msgid ""
"MIPS MAARs (see KVM_REG_MIPS_CP0_MAAR(*) above) have the following id bit "
"patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2734
msgid ""
"MIPS KVM control registers (see above) have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2738
msgid ""
"MIPS FPU registers (see KVM_REG_MIPS_FPR_{32,64}() above) have the following "
"id bit patterns depending on the size of the register being accessed. They "
"are always accessed according to the current guest FPU mode (Status.FR and "
"Config5.FRE), i.e. as the guest would see them, and they become "
"unpredictable if the guest FPU mode is changed. MIPS SIMD Architecture (MSA) "
"vector registers (see KVM_REG_MIPS_VEC_128() above) have similar patterns as "
"they overlap the FPU registers::"
msgstr ""

#: ../../../virt/kvm/api.rst:2750
msgid ""
"MIPS FPU control registers (see KVM_REG_MIPS_FCR_{IR,CSR} above) have the "
"following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2755
msgid ""
"MIPS MSA control registers (see KVM_REG_MIPS_MSA_{IR,CSR} above) have the "
"following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2760
msgid ""
"RISC-V registers are mapped using the lower 32 bits. The upper 8 bits of "
"that is the register group type."
msgstr ""

#: ../../../virt/kvm/api.rst:2763
msgid ""
"RISC-V config registers are meant for configuring a Guest VCPU and it has "
"the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2769
msgid "Following are the RISC-V config registers:"
msgstr ""

#: ../../../virt/kvm/api.rst:2772 ../../../virt/kvm/api.rst:2790
#: ../../../virt/kvm/api.rst:2836 ../../../virt/kvm/api.rst:2857
#: ../../../virt/kvm/api.rst:2873 ../../../virt/kvm/api.rst:2890
msgid "Description"
msgstr ""

#: ../../../virt/kvm/api.rst:2774
msgid "0x80x0 0000 0100 0000"
msgstr ""

#: ../../../virt/kvm/api.rst:2774
msgid "isa"
msgstr ""

#: ../../../virt/kvm/api.rst:2774
msgid "ISA feature bitmap of Guest VCPU"
msgstr ""

#: ../../../virt/kvm/api.rst:2777
msgid ""
"The isa config register can be read anytime but can only be written before a "
"Guest VCPU runs. It will have ISA feature bits matching underlying host set "
"by default."
msgstr ""

#: ../../../virt/kvm/api.rst:2781
msgid ""
"RISC-V core registers represent the general execution state of a Guest VCPU "
"and it has the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2787
msgid "Following are the RISC-V core registers:"
msgstr ""

#: ../../../virt/kvm/api.rst:2792
msgid "0x80x0 0000 0200 0000"
msgstr ""

#: ../../../virt/kvm/api.rst:2792
msgid "Program counter"
msgstr ""

#: ../../../virt/kvm/api.rst:2793
msgid "0x80x0 0000 0200 0001"
msgstr ""

#: ../../../virt/kvm/api.rst:2793
msgid "regs.ra"
msgstr ""

#: ../../../virt/kvm/api.rst:2793
msgid "Return address"
msgstr ""

#: ../../../virt/kvm/api.rst:2794
msgid "0x80x0 0000 0200 0002"
msgstr ""

#: ../../../virt/kvm/api.rst:2794
msgid "Stack pointer"
msgstr ""

#: ../../../virt/kvm/api.rst:2795
msgid "0x80x0 0000 0200 0003"
msgstr ""

#: ../../../virt/kvm/api.rst:2795
msgid "regs.gp"
msgstr ""

#: ../../../virt/kvm/api.rst:2795
msgid "Global pointer"
msgstr ""

#: ../../../virt/kvm/api.rst:2796
msgid "0x80x0 0000 0200 0004"
msgstr ""

#: ../../../virt/kvm/api.rst:2796
msgid "regs.tp"
msgstr ""

#: ../../../virt/kvm/api.rst:2796
msgid "Task pointer"
msgstr ""

#: ../../../virt/kvm/api.rst:2797
msgid "0x80x0 0000 0200 0005"
msgstr ""

#: ../../../virt/kvm/api.rst:2797
msgid "regs.t0"
msgstr ""

#: ../../../virt/kvm/api.rst:2797
msgid "Caller saved register 0"
msgstr ""

#: ../../../virt/kvm/api.rst:2798
msgid "0x80x0 0000 0200 0006"
msgstr ""

#: ../../../virt/kvm/api.rst:2798
msgid "regs.t1"
msgstr ""

#: ../../../virt/kvm/api.rst:2798
msgid "Caller saved register 1"
msgstr ""

#: ../../../virt/kvm/api.rst:2799
msgid "0x80x0 0000 0200 0007"
msgstr ""

#: ../../../virt/kvm/api.rst:2799
msgid "regs.t2"
msgstr ""

#: ../../../virt/kvm/api.rst:2799
msgid "Caller saved register 2"
msgstr ""

#: ../../../virt/kvm/api.rst:2800
msgid "0x80x0 0000 0200 0008"
msgstr ""

#: ../../../virt/kvm/api.rst:2800
msgid "regs.s0"
msgstr ""

#: ../../../virt/kvm/api.rst:2800
msgid "Callee saved register 0"
msgstr ""

#: ../../../virt/kvm/api.rst:2801
msgid "0x80x0 0000 0200 0009"
msgstr ""

#: ../../../virt/kvm/api.rst:2801
msgid "regs.s1"
msgstr ""

#: ../../../virt/kvm/api.rst:2801
msgid "Callee saved register 1"
msgstr ""

#: ../../../virt/kvm/api.rst:2802
msgid "0x80x0 0000 0200 000a"
msgstr ""

#: ../../../virt/kvm/api.rst:2802
msgid "regs.a0"
msgstr ""

#: ../../../virt/kvm/api.rst:2802
msgid "Function argument (or return value) 0"
msgstr ""

#: ../../../virt/kvm/api.rst:2803
msgid "0x80x0 0000 0200 000b"
msgstr ""

#: ../../../virt/kvm/api.rst:2803
msgid "regs.a1"
msgstr ""

#: ../../../virt/kvm/api.rst:2803
msgid "Function argument (or return value) 1"
msgstr ""

#: ../../../virt/kvm/api.rst:2804
msgid "0x80x0 0000 0200 000c"
msgstr ""

#: ../../../virt/kvm/api.rst:2804
msgid "regs.a2"
msgstr ""

#: ../../../virt/kvm/api.rst:2804
msgid "Function argument 2"
msgstr ""

#: ../../../virt/kvm/api.rst:2805
msgid "0x80x0 0000 0200 000d"
msgstr ""

#: ../../../virt/kvm/api.rst:2805
msgid "regs.a3"
msgstr ""

#: ../../../virt/kvm/api.rst:2805
msgid "Function argument 3"
msgstr ""

#: ../../../virt/kvm/api.rst:2806
msgid "0x80x0 0000 0200 000e"
msgstr ""

#: ../../../virt/kvm/api.rst:2806
msgid "regs.a4"
msgstr ""

#: ../../../virt/kvm/api.rst:2806
msgid "Function argument 4"
msgstr ""

#: ../../../virt/kvm/api.rst:2807
msgid "0x80x0 0000 0200 000f"
msgstr ""

#: ../../../virt/kvm/api.rst:2807
msgid "regs.a5"
msgstr ""

#: ../../../virt/kvm/api.rst:2807
msgid "Function argument 5"
msgstr ""

#: ../../../virt/kvm/api.rst:2808
msgid "0x80x0 0000 0200 0010"
msgstr ""

#: ../../../virt/kvm/api.rst:2808
msgid "regs.a6"
msgstr ""

#: ../../../virt/kvm/api.rst:2808
msgid "Function argument 6"
msgstr ""

#: ../../../virt/kvm/api.rst:2809
msgid "0x80x0 0000 0200 0011"
msgstr ""

#: ../../../virt/kvm/api.rst:2809
msgid "regs.a7"
msgstr ""

#: ../../../virt/kvm/api.rst:2809
msgid "Function argument 7"
msgstr ""

#: ../../../virt/kvm/api.rst:2810
msgid "0x80x0 0000 0200 0012"
msgstr ""

#: ../../../virt/kvm/api.rst:2810
msgid "regs.s2"
msgstr ""

#: ../../../virt/kvm/api.rst:2810
msgid "Callee saved register 2"
msgstr ""

#: ../../../virt/kvm/api.rst:2811
msgid "0x80x0 0000 0200 0013"
msgstr ""

#: ../../../virt/kvm/api.rst:2811
msgid "regs.s3"
msgstr ""

#: ../../../virt/kvm/api.rst:2811
msgid "Callee saved register 3"
msgstr ""

#: ../../../virt/kvm/api.rst:2812
msgid "0x80x0 0000 0200 0014"
msgstr ""

#: ../../../virt/kvm/api.rst:2812
msgid "regs.s4"
msgstr ""

#: ../../../virt/kvm/api.rst:2812
msgid "Callee saved register 4"
msgstr ""

#: ../../../virt/kvm/api.rst:2813
msgid "0x80x0 0000 0200 0015"
msgstr ""

#: ../../../virt/kvm/api.rst:2813
msgid "regs.s5"
msgstr ""

#: ../../../virt/kvm/api.rst:2813
msgid "Callee saved register 5"
msgstr ""

#: ../../../virt/kvm/api.rst:2814
msgid "0x80x0 0000 0200 0016"
msgstr ""

#: ../../../virt/kvm/api.rst:2814
msgid "regs.s6"
msgstr ""

#: ../../../virt/kvm/api.rst:2814
msgid "Callee saved register 6"
msgstr ""

#: ../../../virt/kvm/api.rst:2815
msgid "0x80x0 0000 0200 0017"
msgstr ""

#: ../../../virt/kvm/api.rst:2815
msgid "regs.s7"
msgstr ""

#: ../../../virt/kvm/api.rst:2815
msgid "Callee saved register 7"
msgstr ""

#: ../../../virt/kvm/api.rst:2816
msgid "0x80x0 0000 0200 0018"
msgstr ""

#: ../../../virt/kvm/api.rst:2816
msgid "regs.s8"
msgstr ""

#: ../../../virt/kvm/api.rst:2816
msgid "Callee saved register 8"
msgstr ""

#: ../../../virt/kvm/api.rst:2817
msgid "0x80x0 0000 0200 0019"
msgstr ""

#: ../../../virt/kvm/api.rst:2817
msgid "regs.s9"
msgstr ""

#: ../../../virt/kvm/api.rst:2817
msgid "Callee saved register 9"
msgstr ""

#: ../../../virt/kvm/api.rst:2818
msgid "0x80x0 0000 0200 001a"
msgstr ""

#: ../../../virt/kvm/api.rst:2818
msgid "regs.s10"
msgstr ""

#: ../../../virt/kvm/api.rst:2818
msgid "Callee saved register 10"
msgstr ""

#: ../../../virt/kvm/api.rst:2819
msgid "0x80x0 0000 0200 001b"
msgstr ""

#: ../../../virt/kvm/api.rst:2819
msgid "regs.s11"
msgstr ""

#: ../../../virt/kvm/api.rst:2819
msgid "Callee saved register 11"
msgstr ""

#: ../../../virt/kvm/api.rst:2820
msgid "0x80x0 0000 0200 001c"
msgstr ""

#: ../../../virt/kvm/api.rst:2820
msgid "regs.t3"
msgstr ""

#: ../../../virt/kvm/api.rst:2820
msgid "Caller saved register 3"
msgstr ""

#: ../../../virt/kvm/api.rst:2821
msgid "0x80x0 0000 0200 001d"
msgstr ""

#: ../../../virt/kvm/api.rst:2821
msgid "regs.t4"
msgstr ""

#: ../../../virt/kvm/api.rst:2821
msgid "Caller saved register 4"
msgstr ""

#: ../../../virt/kvm/api.rst:2822
msgid "0x80x0 0000 0200 001e"
msgstr ""

#: ../../../virt/kvm/api.rst:2822
msgid "regs.t5"
msgstr ""

#: ../../../virt/kvm/api.rst:2822
msgid "Caller saved register 5"
msgstr ""

#: ../../../virt/kvm/api.rst:2823
msgid "0x80x0 0000 0200 001f"
msgstr ""

#: ../../../virt/kvm/api.rst:2823
msgid "regs.t6"
msgstr ""

#: ../../../virt/kvm/api.rst:2823
msgid "Caller saved register 6"
msgstr ""

#: ../../../virt/kvm/api.rst:2824
msgid "0x80x0 0000 0200 0020"
msgstr ""

#: ../../../virt/kvm/api.rst:2824
msgid "mode"
msgstr ""

#: ../../../virt/kvm/api.rst:2824
msgid "Privilege mode (1 = S-mode or 0 = U-mode)"
msgstr ""

#: ../../../virt/kvm/api.rst:2827
msgid ""
"RISC-V csr registers represent the supervisor mode control/status registers "
"of a Guest VCPU and it has the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2833
msgid "Following are the RISC-V csr registers:"
msgstr ""

#: ../../../virt/kvm/api.rst:2838
msgid "0x80x0 0000 0300 0000"
msgstr ""

#: ../../../virt/kvm/api.rst:2838
msgid "sstatus"
msgstr ""

#: ../../../virt/kvm/api.rst:2838
msgid "Supervisor status"
msgstr ""

#: ../../../virt/kvm/api.rst:2839
msgid "0x80x0 0000 0300 0001"
msgstr ""

#: ../../../virt/kvm/api.rst:2839
msgid "sie"
msgstr ""

#: ../../../virt/kvm/api.rst:2839
msgid "Supervisor interrupt enable"
msgstr ""

#: ../../../virt/kvm/api.rst:2840
msgid "0x80x0 0000 0300 0002"
msgstr ""

#: ../../../virt/kvm/api.rst:2840
msgid "stvec"
msgstr ""

#: ../../../virt/kvm/api.rst:2840
msgid "Supervisor trap vector base"
msgstr ""

#: ../../../virt/kvm/api.rst:2841
msgid "0x80x0 0000 0300 0003"
msgstr ""

#: ../../../virt/kvm/api.rst:2841
msgid "sscratch"
msgstr ""

#: ../../../virt/kvm/api.rst:2841
msgid "Supervisor scratch register"
msgstr ""

#: ../../../virt/kvm/api.rst:2842
msgid "0x80x0 0000 0300 0004"
msgstr ""

#: ../../../virt/kvm/api.rst:2842
msgid "sepc"
msgstr ""

#: ../../../virt/kvm/api.rst:2842
msgid "Supervisor exception program counter"
msgstr ""

#: ../../../virt/kvm/api.rst:2843
msgid "0x80x0 0000 0300 0005"
msgstr ""

#: ../../../virt/kvm/api.rst:2843
msgid "scause"
msgstr ""

#: ../../../virt/kvm/api.rst:2843
msgid "Supervisor trap cause"
msgstr ""

#: ../../../virt/kvm/api.rst:2844
msgid "0x80x0 0000 0300 0006"
msgstr ""

#: ../../../virt/kvm/api.rst:2844
msgid "stval"
msgstr ""

#: ../../../virt/kvm/api.rst:2844
msgid "Supervisor bad address or instruction"
msgstr ""

#: ../../../virt/kvm/api.rst:2845
msgid "0x80x0 0000 0300 0007"
msgstr ""

#: ../../../virt/kvm/api.rst:2845
msgid "sip"
msgstr ""

#: ../../../virt/kvm/api.rst:2845
msgid "Supervisor interrupt pending"
msgstr ""

#: ../../../virt/kvm/api.rst:2846
msgid "0x80x0 0000 0300 0008"
msgstr ""

#: ../../../virt/kvm/api.rst:2846
msgid "satp"
msgstr ""

#: ../../../virt/kvm/api.rst:2846
msgid "Supervisor address translation and protection"
msgstr ""

#: ../../../virt/kvm/api.rst:2849
msgid ""
"RISC-V timer registers represent the timer state of a Guest VCPU and it has "
"the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2854
msgid "Following are the RISC-V timer registers:"
msgstr ""

#: ../../../virt/kvm/api.rst:2859
msgid "0x8030 0000 0400 0000"
msgstr ""

#: ../../../virt/kvm/api.rst:2859
msgid "frequency"
msgstr ""

#: ../../../virt/kvm/api.rst:2859
msgid "Time base frequency (read-only)"
msgstr ""

#: ../../../virt/kvm/api.rst:2860
msgid "0x8030 0000 0400 0001"
msgstr ""

#: ../../../virt/kvm/api.rst:2860
msgid "time"
msgstr ""

#: ../../../virt/kvm/api.rst:2860
msgid "Time value visible to Guest"
msgstr ""

#: ../../../virt/kvm/api.rst:2861
msgid "0x8030 0000 0400 0002"
msgstr ""

#: ../../../virt/kvm/api.rst:2861
msgid "compare"
msgstr ""

#: ../../../virt/kvm/api.rst:2861
msgid "Time compare programmed by Guest"
msgstr ""

#: ../../../virt/kvm/api.rst:2862
msgid "0x8030 0000 0400 0003"
msgstr ""

#: ../../../virt/kvm/api.rst:2862
msgid "state"
msgstr ""

#: ../../../virt/kvm/api.rst:2862
msgid "Time compare state (1 = ON or 0 = OFF)"
msgstr ""

#: ../../../virt/kvm/api.rst:2865
msgid ""
"RISC-V F-extension registers represent the single precision floating point "
"state of a Guest VCPU and it has the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2870
msgid "Following are the RISC-V F-extension registers:"
msgstr ""

#: ../../../virt/kvm/api.rst:2875
msgid "0x8020 0000 0500 0000"
msgstr ""

#: ../../../virt/kvm/api.rst:2875 ../../../virt/kvm/api.rst:2892
msgid "f[0]"
msgstr ""

#: ../../../virt/kvm/api.rst:2875 ../../../virt/kvm/api.rst:2892
msgid "Floating point register 0"
msgstr ""

#: ../../../virt/kvm/api.rst:2877
msgid "0x8020 0000 0500 001f"
msgstr ""

#: ../../../virt/kvm/api.rst:2877 ../../../virt/kvm/api.rst:2894
msgid "f[31]"
msgstr ""

#: ../../../virt/kvm/api.rst:2877 ../../../virt/kvm/api.rst:2894
msgid "Floating point register 31"
msgstr ""

#: ../../../virt/kvm/api.rst:2878
msgid "0x8020 0000 0500 0020"
msgstr ""

#: ../../../virt/kvm/api.rst:2878 ../../../virt/kvm/api.rst:2895
msgid "fcsr"
msgstr ""

#: ../../../virt/kvm/api.rst:2878 ../../../virt/kvm/api.rst:2895
msgid "Floating point control and status register"
msgstr ""

#: ../../../virt/kvm/api.rst:2881
msgid ""
"RISC-V D-extension registers represent the double precision floating point "
"state of a Guest VCPU and it has the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2887
msgid "Following are the RISC-V D-extension registers:"
msgstr ""

#: ../../../virt/kvm/api.rst:2892
msgid "0x8030 0000 0600 0000"
msgstr ""

#: ../../../virt/kvm/api.rst:2894
msgid "0x8030 0000 0600 001f"
msgstr ""

#: ../../../virt/kvm/api.rst:2895
msgid "0x8020 0000 0600 0020"
msgstr ""

#: ../../../virt/kvm/api.rst:2898
msgid ""
"LoongArch registers are mapped using the lower 32 bits. The upper 16 bits of "
"that is the register group type."
msgstr ""

#: ../../../virt/kvm/api.rst:2901
msgid ""
"LoongArch csr registers are used to control guest cpu or get status of guest "
"cpu, and they have the following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2906
msgid ""
"LoongArch KVM control registers are used to implement some new defined "
"functions such as set vcpu counter or reset vcpu, and they have the "
"following id bit patterns::"
msgstr ""

#: ../../../virt/kvm/api.rst:2913
msgid "4.69 KVM_GET_ONE_REG"
msgstr ""

#: ../../../virt/kvm/api.rst:2918
msgid "struct kvm_one_reg (in and out)"
msgstr ""

#: ../../../virt/kvm/api.rst:2921
msgid "Errors include:"
msgstr ""

#: ../../../virt/kvm/api.rst:2933
msgid ""
"This ioctl allows to receive the value of a single register implemented in a "
"vcpu. The register to read is indicated by the \"id\" field of the "
"kvm_one_reg struct passed in. On success, the register value can be found at "
"the memory location pointed to by \"addr\"."
msgstr ""

#: ../../../virt/kvm/api.rst:2938
msgid ""
"The list of registers accessible using this interface is identical to the "
"list in 4.68."
msgstr ""

#: ../../../virt/kvm/api.rst:2943
msgid "4.70 KVM_KVMCLOCK_CTRL"
msgstr ""

#: ../../../virt/kvm/api.rst:2945
msgid "KVM_CAP_KVMCLOCK_CTRL"
msgstr ""

#: ../../../virt/kvm/api.rst:2946
msgid "Any that implement pvclocks (currently x86 only)"
msgstr ""

#: ../../../virt/kvm/api.rst:2948 ../../../virt/kvm/api.rst:3087
#: ../../../virt/kvm/api.rst:8630 ../../../virt/kvm/api.rst:8648
#: ../../../virt/kvm/api.rst:8659
msgid "None"
msgstr ""

#: ../../../virt/kvm/api.rst:2951
msgid ""
"This ioctl sets a flag accessible to the guest indicating that the specified "
"vCPU has been paused by the host userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:2954
msgid ""
"The host will set a flag in the pvclock structure that is checked from the "
"soft lockup watchdog.  The flag is part of the pvclock structure that is "
"shared between guest and host, specifically the second bit of the flags "
"field of the pvclock_vcpu_time_info structure.  It will be set exclusively "
"by the host and read/cleared exclusively by the guest.  The guest operation "
"of checking and clearing the flag must be an atomic operation so load-link/"
"store-conditional, or equivalent must be used.  There are two cases where "
"the guest will clear the flag: when the soft lockup watchdog timer resets "
"itself or when a soft lockup is detected.  This ioctl can be called any time "
"after pausing the vcpu, but before it is resumed."
msgstr ""

#: ../../../virt/kvm/api.rst:2967
msgid "4.71 KVM_SIGNAL_MSI"
msgstr ""

#: ../../../virt/kvm/api.rst:2969
msgid "KVM_CAP_SIGNAL_MSI"
msgstr ""

#: ../../../virt/kvm/api.rst:2970
msgid "x86 arm64"
msgstr ""

#: ../../../virt/kvm/api.rst:2972
msgid "struct kvm_msi (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:2973
msgid ">0 on delivery, 0 if guest blocked the MSI, and -1 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:2975
msgid ""
"Directly inject a MSI message. Only valid with in-kernel irqchip that "
"handles MSI messages."
msgstr ""

#: ../../../virt/kvm/api.rst:2990
msgid ""
"KVM_MSI_VALID_DEVID: devid contains a valid value.  The per-VM "
"KVM_CAP_MSI_DEVID capability advertises the requirement to provide the "
"device ID.  If this capability is not available, userspace should never set "
"the KVM_MSI_VALID_DEVID flag as the ioctl might fail."
msgstr ""

#: ../../../virt/kvm/api.rst:3006
msgid "4.71 KVM_CREATE_PIT2"
msgstr ""

#: ../../../virt/kvm/api.rst:3008
msgid "KVM_CAP_PIT2"
msgstr ""

#: ../../../virt/kvm/api.rst:3011
msgid "struct kvm_pit_config (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3014
msgid ""
"Creates an in-kernel device model for the i8254 PIT. This call is only valid "
"after enabling in-kernel irqchip support via KVM_CREATE_IRQCHIP. The "
"following parameters have to be passed::"
msgstr ""

#: ../../../virt/kvm/api.rst:3023 ../../../virt/kvm/api.rst:3056
#: ../../../virt/kvm/api.rst:7962
msgid "Valid flags are::"
msgstr ""

#: ../../../virt/kvm/api.rst:3027
msgid ""
"PIT timer interrupts may use a per-VM kernel thread for injection. If it "
"exists, this thread will have a name of the following pattern::"
msgstr ""

#: ../../../virt/kvm/api.rst:3032
msgid ""
"When running a guest with elevated priorities, the scheduling parameters of "
"this thread may have to be adjusted accordingly."
msgstr ""

#: ../../../virt/kvm/api.rst:3035
msgid "This IOCTL replaces the obsolete KVM_CREATE_PIT."
msgstr ""

#: ../../../virt/kvm/api.rst:3039
msgid "4.72 KVM_GET_PIT2"
msgstr ""

#: ../../../virt/kvm/api.rst:3041 ../../../virt/kvm/api.rst:3069
msgid "KVM_CAP_PIT_STATE2"
msgstr ""

#: ../../../virt/kvm/api.rst:3044
msgid "struct kvm_pit_state2 (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:3047
msgid ""
"Retrieves the state of the in-kernel PIT model. Only valid after "
"KVM_CREATE_PIT2. The state is returned in the following structure::"
msgstr ""

#: ../../../virt/kvm/api.rst:3063
msgid "This IOCTL replaces the obsolete KVM_GET_PIT."
msgstr ""

#: ../../../virt/kvm/api.rst:3067
msgid "4.73 KVM_SET_PIT2"
msgstr ""

#: ../../../virt/kvm/api.rst:3072
msgid "struct kvm_pit_state2 (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3075
msgid ""
"Sets the state of the in-kernel PIT model. Only valid after KVM_CREATE_PIT2. "
"See KVM_GET_PIT2 for details on struct kvm_pit_state2."
msgstr ""

#: ../../../virt/kvm/api.rst:3078
msgid "This IOCTL replaces the obsolete KVM_SET_PIT."
msgstr ""

#: ../../../virt/kvm/api.rst:3082
msgid "4.74 KVM_PPC_GET_SMMU_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:3084
msgid "KVM_CAP_PPC_GET_SMMU_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:3090
msgid ""
"This populates and returns a structure describing the features of the "
"\"Server\" class MMU emulation supported by KVM. This can in turn be used by "
"userspace to generate the appropriate device-tree properties for the guest "
"operating system."
msgstr ""

#: ../../../virt/kvm/api.rst:3095
msgid ""
"The structure contains some global information, followed by an array of "
"supported segment page sizes::"
msgstr ""

#: ../../../virt/kvm/api.rst:3105
msgid "The supported flags are:"
msgstr ""

#: ../../../virt/kvm/api.rst:3107
msgid "KVM_PPC_PAGE_SIZES_REAL:"
msgstr ""

#: ../../../virt/kvm/api.rst:3108
msgid ""
"When that flag is set, guest page sizes must \"fit\" the backing store page "
"sizes. When not set, any page size in the list can be used regardless of how "
"they are backed by userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:3112
msgid "KVM_PPC_1T_SEGMENTS"
msgstr ""

#: ../../../virt/kvm/api.rst:3113
msgid ""
"The emulated MMU supports 1T segments in addition to the standard 256M ones."
msgstr ""

#: ../../../virt/kvm/api.rst:3116
msgid "KVM_PPC_NO_HASH"
msgstr ""

#: ../../../virt/kvm/api.rst:3117
msgid ""
"This flag indicates that HPT guests are not supported by KVM, thus all "
"guests must use radix MMU mode."
msgstr ""

#: ../../../virt/kvm/api.rst:3120
msgid "The \"slb_size\" field indicates how many SLB entries are supported"
msgstr ""

#: ../../../virt/kvm/api.rst:3122
msgid ""
"The \"sps\" array contains 8 entries indicating the supported base page "
"sizes for a segment in increasing order. Each entry is defined as follow::"
msgstr ""

#: ../../../virt/kvm/api.rst:3132
msgid ""
"An entry with a \"page_shift\" of 0 is unused. Because the array is "
"organized in increasing order, a lookup can stop when encountering such an "
"entry."
msgstr ""

#: ../../../virt/kvm/api.rst:3136
msgid ""
"The \"slb_enc\" field provides the encoding to use in the SLB for the page "
"size. The bits are in positions such as the value can directly be OR'ed into "
"the \"vsid\" argument of the slbmte instruction."
msgstr ""

#: ../../../virt/kvm/api.rst:3140
msgid ""
"The \"enc\" array is a list which for each of those segment base page size "
"provides the list of supported actual page sizes (which can be only larger "
"or equal to the base page size), along with the corresponding encoding in "
"the hash PTE. Similarly, the array is 8 entries sorted by increasing sizes "
"and an entry with a \"0\" shift is an empty entry and a terminator::"
msgstr ""

#: ../../../virt/kvm/api.rst:3152
msgid ""
"The \"pte_enc\" field provides a value that can OR'ed into the hash PTE's "
"RPN field (ie, it needs to be shifted left by 12 to OR it into the hash PTE "
"second double word)."
msgstr ""

#: ../../../virt/kvm/api.rst:3157
msgid "4.75 KVM_IRQFD"
msgstr ""

#: ../../../virt/kvm/api.rst:3159
msgid "KVM_CAP_IRQFD"
msgstr ""

#: ../../../virt/kvm/api.rst:3162
msgid "struct kvm_irqfd (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3165
msgid ""
"Allows setting an eventfd to directly trigger a guest interrupt. kvm_irqfd."
"fd specifies the file descriptor to use as the eventfd and kvm_irqfd.gsi "
"specifies the irqchip pin toggled by this event.  When an event is triggered "
"on the eventfd, an interrupt is injected into the guest using the specified "
"gsi pin.  The irqfd is removed using the KVM_IRQFD_FLAG_DEASSIGN flag, "
"specifying both kvm_irqfd.fd and kvm_irqfd.gsi."
msgstr ""

#: ../../../virt/kvm/api.rst:3173
msgid ""
"With KVM_CAP_IRQFD_RESAMPLE, KVM_IRQFD supports a de-assert and notify "
"mechanism allowing emulation of level-triggered, irqfd-based interrupts.  "
"When KVM_IRQFD_FLAG_RESAMPLE is set the user must pass an additional eventfd "
"in the kvm_irqfd.resamplefd field.  When operating in resample mode, posting "
"of an interrupt through kvm_irq.fd asserts the specified gsi in the "
"irqchip.  When the irqchip is resampled, such as from an EOI, the gsi is de-"
"asserted and the user is notified via kvm_irqfd.resamplefd.  It is the "
"user's responsibility to re-queue the interrupt if the device making use of "
"it still requires service. Note that closing the resamplefd is not "
"sufficient to disable the irqfd.  The KVM_IRQFD_FLAG_RESAMPLE is only "
"necessary on assignment and need not be specified with "
"KVM_IRQFD_FLAG_DEASSIGN."
msgstr ""

#: ../../../virt/kvm/api.rst:3186
msgid "On arm64, gsi routing being supported, the following can happen:"
msgstr ""

#: ../../../virt/kvm/api.rst:3188
msgid "in case no routing entry is associated to this gsi, injection fails"
msgstr ""

#: ../../../virt/kvm/api.rst:3189
msgid ""
"in case the gsi is associated to an irqchip routing entry, irqchip.pin + 32 "
"corresponds to the injected SPI ID."
msgstr ""

#: ../../../virt/kvm/api.rst:3191
msgid ""
"in case the gsi is associated to an MSI routing entry, the MSI message and "
"device ID are translated into an LPI (support restricted to GICv3 ITS in-"
"kernel emulation)."
msgstr ""

#: ../../../virt/kvm/api.rst:3196
msgid "4.76 KVM_PPC_ALLOCATE_HTAB"
msgstr ""

#: ../../../virt/kvm/api.rst:3198
msgid "KVM_CAP_PPC_ALLOC_HTAB"
msgstr ""

#: ../../../virt/kvm/api.rst:3201
msgid "Pointer to u32 containing hash table order (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:3204
msgid ""
"This requests the host kernel to allocate an MMU hash table for a guest "
"using the PAPR paravirtualization interface.  This only does anything if the "
"kernel is configured to use the Book 3S HV style of virtualization.  "
"Otherwise the capability doesn't exist and the ioctl returns an ENOTTY "
"error.  The rest of this description assumes Book 3S HV."
msgstr ""

#: ../../../virt/kvm/api.rst:3211
msgid ""
"There must be no vcpus running when this ioctl is called; if there are, it "
"will do nothing and return an EBUSY error."
msgstr ""

#: ../../../virt/kvm/api.rst:3214
msgid ""
"The parameter is a pointer to a 32-bit unsigned integer variable containing "
"the order (log base 2) of the desired size of the hash table, which must be "
"between 18 and 46.  On successful return from the ioctl, the value will not "
"be changed by the kernel."
msgstr ""

#: ../../../virt/kvm/api.rst:3219
msgid ""
"If no hash table has been allocated when any vcpu is asked to run (with the "
"KVM_RUN ioctl), the host kernel will allocate a default-sized hash table (16 "
"MB)."
msgstr ""

#: ../../../virt/kvm/api.rst:3223
msgid ""
"If this ioctl is called when a hash table has already been allocated, with a "
"different order from the existing hash table, the existing hash table will "
"be freed and a new one allocated.  If this is ioctl is called when a hash "
"table has already been allocated of the same order as specified, the kernel "
"will clear out the existing hash table (zero all HPTEs).  In either case, if "
"the guest is using the virtualized real-mode area (VRMA) facility, the "
"kernel will re-create the VMRA HPTEs on the next KVM_RUN of any vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:3233
msgid "4.77 KVM_S390_INTERRUPT"
msgstr ""

#: ../../../virt/kvm/api.rst:3237 ../../../virt/kvm/api.rst:3839
#: ../../../virt/kvm/api.rst:4793 ../../../virt/kvm/api.rst:5884
msgid "vm ioctl, vcpu ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:3238
msgid "struct kvm_s390_interrupt (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3241
msgid ""
"Allows to inject an interrupt to the guest. Interrupts can be floating (vm "
"ioctl) or per cpu (vcpu ioctl), depending on the interrupt type."
msgstr ""

#: ../../../virt/kvm/api.rst:3244
msgid "Interrupt parameters are passed via kvm_s390_interrupt::"
msgstr ""

#: ../../../virt/kvm/api.rst:3252 ../../../virt/kvm/api.rst:4085
msgid "type can be one of the following:"
msgstr ""

#: ../../../virt/kvm/api.rst:3254
msgid "KVM_S390_SIGP_STOP (vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3255
msgid "sigp stop; optional flags in parm"
msgstr ""

#: ../../../virt/kvm/api.rst:3256
msgid "KVM_S390_PROGRAM_INT (vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3257
msgid "program check; code in parm"
msgstr ""

#: ../../../virt/kvm/api.rst:3258
msgid "KVM_S390_SIGP_SET_PREFIX (vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3259
msgid "sigp set prefix; prefix address in parm"
msgstr ""

#: ../../../virt/kvm/api.rst:3260
msgid "KVM_S390_RESTART (vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3261
msgid "restart"
msgstr ""

#: ../../../virt/kvm/api.rst:3262
msgid "KVM_S390_INT_CLOCK_COMP (vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3263
msgid "clock comparator interrupt"
msgstr ""

#: ../../../virt/kvm/api.rst:3264
msgid "KVM_S390_INT_CPU_TIMER (vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3265
msgid "CPU timer interrupt"
msgstr ""

#: ../../../virt/kvm/api.rst:3266
msgid "KVM_S390_INT_VIRTIO (vm)"
msgstr ""

#: ../../../virt/kvm/api.rst:3267
msgid ""
"virtio external interrupt; external interrupt parameters in parm and parm64"
msgstr ""

#: ../../../virt/kvm/api.rst:3269
msgid "KVM_S390_INT_SERVICE (vm)"
msgstr ""

#: ../../../virt/kvm/api.rst:3270
msgid "sclp external interrupt; sclp parameter in parm"
msgstr ""

#: ../../../virt/kvm/api.rst:3271
msgid "KVM_S390_INT_EMERGENCY (vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3272
msgid "sigp emergency; source cpu in parm"
msgstr ""

#: ../../../virt/kvm/api.rst:3273
msgid "KVM_S390_INT_EXTERNAL_CALL (vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3274
msgid "sigp external call; source cpu in parm"
msgstr ""

#: ../../../virt/kvm/api.rst:3275
msgid "KVM_S390_INT_IO(ai,cssid,ssid,schid) (vm)"
msgstr ""

#: ../../../virt/kvm/api.rst:3276
msgid ""
"compound value to indicate an I/O interrupt (ai - adapter interrupt; cssid,"
"ssid,schid - subchannel); I/O interruption parameters in parm (subchannel) "
"and parm64 (intparm, interruption subclass)"
msgstr ""

#: ../../../virt/kvm/api.rst:3280
msgid "KVM_S390_MCHK (vm, vcpu)"
msgstr ""

#: ../../../virt/kvm/api.rst:3281
msgid ""
"machine check interrupt; cr 14 bits in parm, machine check interrupt code in "
"parm64 (note that machine checks needing further payload are not supported "
"by this ioctl)"
msgstr ""

#: ../../../virt/kvm/api.rst:3288
msgid "4.78 KVM_PPC_GET_HTAB_FD"
msgstr ""

#: ../../../virt/kvm/api.rst:3290
msgid "KVM_CAP_PPC_HTAB_FD"
msgstr ""

#: ../../../virt/kvm/api.rst:3293
msgid "Pointer to struct kvm_get_htab_fd (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3294
msgid "file descriptor number (>= 0) on success, -1 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:3296
msgid ""
"This returns a file descriptor that can be used either to read out the "
"entries in the guest's hashed page table (HPT), or to write entries to "
"initialize the HPT.  The returned fd can only be written to if the "
"KVM_GET_HTAB_WRITE bit is set in the flags field of the argument, and can "
"only be read if that bit is clear.  The argument struct looks like this::"
msgstr ""

#: ../../../virt/kvm/api.rst:3314
msgid ""
"The 'start_index' field gives the index in the HPT of the entry at which to "
"start reading.  It is ignored when writing."
msgstr ""

#: ../../../virt/kvm/api.rst:3317
msgid ""
"Reads on the fd will initially supply information about all \"interesting\" "
"HPT entries.  Interesting entries are those with the bolted bit set, if the "
"KVM_GET_HTAB_BOLTED_ONLY bit is set, otherwise all entries.  When the end of "
"the HPT is reached, the read() will return.  If read() is called again on "
"the fd, it will start again from the beginning of the HPT, but will only "
"return HPT entries that have changed since they were last read."
msgstr ""

#: ../../../virt/kvm/api.rst:3325
msgid ""
"Data read or written is structured as a header (8 bytes) followed by a "
"series of valid HPT entries (16 bytes) each.  The header indicates how many "
"valid HPT entries there are and how many invalid entries follow the valid "
"entries.  The invalid entries are not represented explicitly in the stream.  "
"The header format is::"
msgstr ""

#: ../../../virt/kvm/api.rst:3337
msgid ""
"Writes to the fd create HPT entries starting at the index given in the "
"header; first 'n_valid' valid entries with contents from the data written, "
"then 'n_invalid' invalid entries, invalidating any previously valid entries "
"found."
msgstr ""

#: ../../../virt/kvm/api.rst:3343
msgid "4.79 KVM_CREATE_DEVICE"
msgstr ""

#: ../../../virt/kvm/api.rst:3345
msgid "KVM_CAP_DEVICE_CTRL"
msgstr ""

#: ../../../virt/kvm/api.rst:3348
msgid "struct kvm_create_device (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:3354 ../../../virt/kvm/api.rst:3564
#: ../../../virt/kvm/api.rst:3641
msgid "ENODEV"
msgstr ""

#: ../../../virt/kvm/api.rst:3354
msgid "The device type is unknown or unsupported"
msgstr ""

#: ../../../virt/kvm/api.rst:3355 ../../../virt/kvm/api.rst:3643
msgid "EEXIST"
msgstr ""

#: ../../../virt/kvm/api.rst:3355
msgid ""
"Device already created, and this type of device may not be instantiated "
"multiple times"
msgstr ""

#: ../../../virt/kvm/api.rst:3359
msgid ""
"Other error conditions may be defined by individual device types or have "
"their standard meanings."
msgstr ""

#: ../../../virt/kvm/api.rst:3362
msgid ""
"Creates an emulated device in the kernel.  The file descriptor returned in "
"fd can be used with KVM_SET/GET/HAS_DEVICE_ATTR."
msgstr ""

#: ../../../virt/kvm/api.rst:3365
msgid ""
"If the KVM_CREATE_DEVICE_TEST flag is set, only test whether the device type "
"is supported (not necessarily whether it can be created in the current vm)."
msgstr ""

#: ../../../virt/kvm/api.rst:3369
msgid ""
"Individual devices should not define flags.  Attributes should be used for "
"specifying any behavior that is not implied by the device type number."
msgstr ""

#: ../../../virt/kvm/api.rst:3382
msgid "4.80 KVM_SET_DEVICE_ATTR/KVM_GET_DEVICE_ATTR"
msgstr ""

#: ../../../virt/kvm/api.rst:3384
msgid ""
"KVM_CAP_DEVICE_CTRL, KVM_CAP_VM_ATTRIBUTES for vm device, "
"KVM_CAP_VCPU_ATTRIBUTES for vcpu device KVM_CAP_SYS_ATTRIBUTES for system (/"
"dev/kvm) device (no set)"
msgstr ""

#: ../../../virt/kvm/api.rst:3388 ../../../virt/kvm/api.rst:3424
msgid "device ioctl, vm ioctl, vcpu ioctl"
msgstr ""

#: ../../../virt/kvm/api.rst:3389 ../../../virt/kvm/api.rst:3425
msgid "struct kvm_device_attr"
msgstr ""

#: ../../../virt/kvm/api.rst:3395 ../../../virt/kvm/api.rst:3431
#: ../../../virt/kvm/api.rst:3642 ../../../virt/kvm/api.rst:4605
msgid "ENXIO"
msgstr ""

#: ../../../virt/kvm/api.rst:3395 ../../../virt/kvm/api.rst:3431
msgid ""
"The group or attribute is unknown/unsupported for this device or hardware "
"support is missing."
msgstr ""

#: ../../../virt/kvm/api.rst:3397
msgid ""
"The attribute cannot (currently) be accessed this way (e.g. read-only "
"attribute, or attribute that only makes sense when the device is in a "
"different state)"
msgstr ""

#: ../../../virt/kvm/api.rst:3402
msgid "Other error conditions may be defined by individual device types."
msgstr ""

#: ../../../virt/kvm/api.rst:3404
msgid ""
"Gets/sets a specified piece of device configuration and/or state.  The "
"semantics are device-specific.  See individual device documentation in the "
"\"devices\" directory.  As with ONE_REG, the size of the data transferred is "
"defined by the particular attribute."
msgstr ""

#: ../../../virt/kvm/api.rst:3419
msgid "4.81 KVM_HAS_DEVICE_ATTR"
msgstr ""

#: ../../../virt/kvm/api.rst:3421
msgid ""
"KVM_CAP_DEVICE_CTRL, KVM_CAP_VM_ATTRIBUTES for vm device, "
"KVM_CAP_VCPU_ATTRIBUTES for vcpu device KVM_CAP_SYS_ATTRIBUTES for system (/"
"dev/kvm) device"
msgstr ""

#: ../../../virt/kvm/api.rst:3435
msgid ""
"Tests whether a device supports a particular attribute.  A successful return "
"indicates the attribute is implemented.  It does not necessarily indicate "
"that the attribute can be read or written in the device's current state.  "
"\"addr\" is ignored."
msgstr ""

#: ../../../virt/kvm/api.rst:3443
msgid "4.82 KVM_ARM_VCPU_INIT"
msgstr ""

#: ../../../virt/kvm/api.rst:3446 ../../../virt/kvm/api.rst:3556
#: ../../../virt/kvm/api.rst:3633 ../../../virt/kvm/api.rst:5109
#: ../../../virt/kvm/api.rst:5124 ../../../virt/kvm/api.rst:5799
#: ../../../virt/kvm/api.rst:6205 ../../../virt/kvm/api.rst:6245
#: ../../../virt/kvm/api.rst:8178 ../../../virt/kvm/api.rst:8575
#: ../../../virt/kvm/api.rst:8619 ../../../virt/kvm/api.rst:8628
#: ../../../virt/kvm/api.rst:8657 ../../../virt/kvm/api.rst:8763
#: ../../../virt/kvm/api.rst:8879 ../../../virt/kvm/api.rst:9069
msgid "arm64"
msgstr ""

#: ../../../virt/kvm/api.rst:3448
msgid "struct kvm_vcpu_init (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3454
msgid "the target is unknown, or the combination of features is invalid."
msgstr ""

#: ../../../virt/kvm/api.rst:3455
msgid "a features bit specified is unknown."
msgstr ""

#: ../../../virt/kvm/api.rst:3458
msgid ""
"This tells KVM what type of CPU to present to the guest, and what optional "
"features it should have.  This will cause a reset of the cpu registers to "
"their initial values.  If this is not called, KVM_RUN will return ENOEXEC "
"for that vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:3463
msgid "The initial values are defined as:"
msgstr ""

#: ../../../virt/kvm/api.rst:3464
msgid "Processor state:"
msgstr ""

#: ../../../virt/kvm/api.rst:3465
msgid "AArch64: EL1h, D, A, I and F bits set. All other bits are cleared."
msgstr ""

#: ../../../virt/kvm/api.rst:3467
msgid "AArch32: SVC, A, I and F bits set. All other bits are cleared."
msgstr ""

#: ../../../virt/kvm/api.rst:3469
msgid "General Purpose registers, including PC and SP: set to 0"
msgstr ""

#: ../../../virt/kvm/api.rst:3470
msgid "FPSIMD/NEON registers: set to 0"
msgstr ""

#: ../../../virt/kvm/api.rst:3471
msgid "SVE registers: set to 0"
msgstr ""

#: ../../../virt/kvm/api.rst:3472
msgid ""
"System registers: Reset to their architecturally defined values as for a "
"warm reset to EL1 (resp. SVC) or EL2 (in the case of EL2 being enabled)."
msgstr ""

#: ../../../virt/kvm/api.rst:3476
msgid ""
"Note that because some registers reflect machine topology, all vcpus should "
"be created before this ioctl is invoked."
msgstr ""

#: ../../../virt/kvm/api.rst:3479
msgid ""
"Userspace can call this function multiple times for a given vcpu, including "
"after the vcpu has been run. This will reset the vcpu to its initial state. "
"All calls to this function after the initial call must use the same target "
"and same set of feature flags, otherwise EINVAL will be returned."
msgstr ""

#: ../../../virt/kvm/api.rst:3484
msgid "Possible features:"
msgstr ""

#: ../../../virt/kvm/api.rst:3486
msgid ""
"KVM_ARM_VCPU_POWER_OFF: Starts the CPU in a power-off state. Depends on "
"KVM_CAP_ARM_PSCI.  If not set, the CPU will be powered on and execute guest "
"code when KVM_RUN is called."
msgstr ""

#: ../../../virt/kvm/api.rst:3489
msgid ""
"KVM_ARM_VCPU_EL1_32BIT: Starts the CPU in a 32bit mode. Depends on "
"KVM_CAP_ARM_EL1_32BIT (arm64 only)."
msgstr ""

#: ../../../virt/kvm/api.rst:3491
msgid ""
"KVM_ARM_VCPU_PSCI_0_2: Emulate PSCI v0.2 (or a future revision backward "
"compatible with v0.2) for the CPU. Depends on KVM_CAP_ARM_PSCI_0_2."
msgstr ""

#: ../../../virt/kvm/api.rst:3494
msgid ""
"KVM_ARM_VCPU_PMU_V3: Emulate PMUv3 for the CPU. Depends on "
"KVM_CAP_ARM_PMU_V3."
msgstr ""

#: ../../../virt/kvm/api.rst:3497
msgid ""
"KVM_ARM_VCPU_PTRAUTH_ADDRESS: Enables Address Pointer authentication for "
"arm64 only. Depends on KVM_CAP_ARM_PTRAUTH_ADDRESS. If "
"KVM_CAP_ARM_PTRAUTH_ADDRESS and KVM_CAP_ARM_PTRAUTH_GENERIC are both "
"present, then both KVM_ARM_VCPU_PTRAUTH_ADDRESS and "
"KVM_ARM_VCPU_PTRAUTH_GENERIC must be requested or neither must be requested."
msgstr ""

#: ../../../virt/kvm/api.rst:3505
msgid ""
"KVM_ARM_VCPU_PTRAUTH_GENERIC: Enables Generic Pointer authentication for "
"arm64 only. Depends on KVM_CAP_ARM_PTRAUTH_GENERIC. If "
"KVM_CAP_ARM_PTRAUTH_ADDRESS and KVM_CAP_ARM_PTRAUTH_GENERIC are both "
"present, then both KVM_ARM_VCPU_PTRAUTH_ADDRESS and "
"KVM_ARM_VCPU_PTRAUTH_GENERIC must be requested or neither must be requested."
msgstr ""

#: ../../../virt/kvm/api.rst:3513
msgid ""
"KVM_ARM_VCPU_SVE: Enables SVE for the CPU (arm64 only). Depends on "
"KVM_CAP_ARM_SVE. Requires KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE):"
msgstr ""

#: ../../../virt/kvm/api.rst:3517
msgid "After KVM_ARM_VCPU_INIT:"
msgstr ""

#: ../../../virt/kvm/api.rst:3519
msgid ""
"KVM_REG_ARM64_SVE_VLS may be read using KVM_GET_ONE_REG: the initial value "
"of this pseudo-register indicates the best set of vector lengths possible "
"for a vcpu on this host."
msgstr ""

#: ../../../virt/kvm/api.rst:3523
msgid "Before KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE):"
msgstr ""

#: ../../../virt/kvm/api.rst:3525
msgid "KVM_RUN and KVM_GET_REG_LIST are not available;"
msgstr ""

#: ../../../virt/kvm/api.rst:3527
msgid ""
"KVM_GET_ONE_REG and KVM_SET_ONE_REG cannot be used to access the scalable "
"architectural SVE registers KVM_REG_ARM64_SVE_ZREG(), "
"KVM_REG_ARM64_SVE_PREG() or KVM_REG_ARM64_SVE_FFR;"
msgstr ""

#: ../../../virt/kvm/api.rst:3532
msgid ""
"KVM_REG_ARM64_SVE_VLS may optionally be written using KVM_SET_ONE_REG, to "
"modify the set of vector lengths available for the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:3536
msgid "After KVM_ARM_VCPU_FINALIZE(KVM_ARM_VCPU_SVE):"
msgstr ""

#: ../../../virt/kvm/api.rst:3538
msgid ""
"the KVM_REG_ARM64_SVE_VLS pseudo-register is immutable, and can no longer be "
"written using KVM_SET_ONE_REG."
msgstr ""

#: ../../../virt/kvm/api.rst:3541
msgid ""
"KVM_ARM_VCPU_HAS_EL2: Enable Nested Virtualisation support, booting the "
"guest from EL2 instead of EL1. Depends on KVM_CAP_ARM_EL2. The VM is running "
"with HCR_EL2.E2H being RES1 (VHE) unless KVM_ARM_VCPU_HAS_EL2_E2H0 is also "
"set."
msgstr ""

#: ../../../virt/kvm/api.rst:3547
msgid ""
"KVM_ARM_VCPU_HAS_EL2_E2H0: Restrict Nested Virtualisation support to HCR_EL2."
"E2H being RES0 (non-VHE). Depends on KVM_CAP_ARM_EL2_E2H0. "
"KVM_ARM_VCPU_HAS_EL2 must also be set."
msgstr ""

#: ../../../virt/kvm/api.rst:3553
msgid "4.83 KVM_ARM_PREFERRED_TARGET"
msgstr ""

#: ../../../virt/kvm/api.rst:3558
msgid "struct kvm_vcpu_init (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:3564
msgid "no preferred target available for the host"
msgstr ""

#: ../../../virt/kvm/api.rst:3567
msgid ""
"This queries KVM for preferred CPU target type which can be emulated by KVM "
"on underlying host."
msgstr ""

#: ../../../virt/kvm/api.rst:3570
msgid ""
"The ioctl returns struct kvm_vcpu_init instance containing information about "
"preferred CPU target type and recommended features for it.  The "
"kvm_vcpu_init->features bitmap returned will have feature bits set if the "
"preferred target recommends setting these features, but this is not "
"mandatory."
msgstr ""

#: ../../../virt/kvm/api.rst:3576
msgid ""
"The information returned by this ioctl can be used to prepare an instance of "
"struct kvm_vcpu_init for KVM_ARM_VCPU_INIT ioctl which will result in VCPU "
"matching underlying host."
msgstr ""

#: ../../../virt/kvm/api.rst:3582
msgid "4.84 KVM_GET_REG_LIST"
msgstr ""

#: ../../../virt/kvm/api.rst:3585
msgid "arm64, mips, riscv"
msgstr ""

#: ../../../virt/kvm/api.rst:3587
msgid "struct kvm_reg_list (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:3593
msgid ""
"the reg index list is too big to fit in the array specified by the user (the "
"number required will be written into n)."
msgstr ""

#: ../../../virt/kvm/api.rst:3604
msgid ""
"This ioctl returns the guest registers that are supported for the "
"KVM_GET_ONE_REG/KVM_SET_ONE_REG calls."
msgstr ""

#: ../../../virt/kvm/api.rst:3607
msgid ""
"Note that s390 does not support KVM_GET_REG_LIST for historical reasons "
"(read: nobody cared).  The set of registers in kernels 4.x and newer is:"
msgstr ""

#: ../../../virt/kvm/api.rst:3610
msgid "KVM_REG_S390_TODPR"
msgstr ""

#: ../../../virt/kvm/api.rst:3612
msgid "KVM_REG_S390_EPOCHDIFF"
msgstr ""

#: ../../../virt/kvm/api.rst:3614
msgid "KVM_REG_S390_CPU_TIMER"
msgstr ""

#: ../../../virt/kvm/api.rst:3616
msgid "KVM_REG_S390_CLOCK_COMP"
msgstr ""

#: ../../../virt/kvm/api.rst:3618
msgid "KVM_REG_S390_PFTOKEN"
msgstr ""

#: ../../../virt/kvm/api.rst:3620
msgid "KVM_REG_S390_PFCOMPARE"
msgstr ""

#: ../../../virt/kvm/api.rst:3622
msgid "KVM_REG_S390_PFSELECT"
msgstr ""

#: ../../../virt/kvm/api.rst:3624
msgid "KVM_REG_S390_PP"
msgstr ""

#: ../../../virt/kvm/api.rst:3626
msgid "KVM_REG_S390_GBEA"
msgstr ""

#: ../../../virt/kvm/api.rst:3630
msgid "4.85 KVM_ARM_SET_DEVICE_ADDR (deprecated)"
msgstr ""

#: ../../../virt/kvm/api.rst:3632
msgid "KVM_CAP_ARM_SET_DEVICE_ADDR"
msgstr ""

#: ../../../virt/kvm/api.rst:3635
msgid "struct kvm_arm_device_address (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3641
msgid "The device id is unknown"
msgstr ""

#: ../../../virt/kvm/api.rst:3642
msgid "Device not supported on current system"
msgstr ""

#: ../../../virt/kvm/api.rst:3643
msgid "Address already set"
msgstr ""

#: ../../../virt/kvm/api.rst:3644
msgid "Address outside guest physical address space"
msgstr ""

#: ../../../virt/kvm/api.rst:3645
msgid "Address overlaps with other device range"
msgstr ""

#: ../../../virt/kvm/api.rst:3655
msgid ""
"Specify a device address in the guest's physical address space where guests "
"can access emulated or directly exposed devices, which the host kernel needs "
"to know about. The id field is an architecture specific identifier for a "
"specific device."
msgstr ""

#: ../../../virt/kvm/api.rst:3660
msgid ""
"arm64 divides the id field into two parts, a device id and an address type "
"id specific to the individual device::"
msgstr ""

#: ../../../virt/kvm/api.rst:3666
msgid ""
"arm64 currently only require this when using the in-kernel GIC support for "
"the hardware VGIC features, using KVM_ARM_DEVICE_VGIC_V2 as the device id.  "
"When setting the base address for the guest's mapping of the VGIC virtual "
"CPU and distributor interface, the ioctl must be called after calling "
"KVM_CREATE_IRQCHIP, but before calling KVM_RUN on any of the VCPUs.  Calling "
"this ioctl twice for any of the base addresses will return -EEXIST."
msgstr ""

#: ../../../virt/kvm/api.rst:3674
msgid ""
"Note, this IOCTL is deprecated and the more flexible SET/GET_DEVICE_ATTR API "
"should be used instead."
msgstr ""

#: ../../../virt/kvm/api.rst:3679
msgid "4.86 KVM_PPC_RTAS_DEFINE_TOKEN"
msgstr ""

#: ../../../virt/kvm/api.rst:3681
msgid "KVM_CAP_PPC_RTAS"
msgstr ""

#: ../../../virt/kvm/api.rst:3684
msgid "struct kvm_rtas_token_args"
msgstr ""

#: ../../../virt/kvm/api.rst:3687
msgid ""
"Defines a token value for a RTAS (Run Time Abstraction Services) service in "
"order to allow it to be handled in the kernel.  The argument struct gives "
"the name of the service, which must be the name of a service that has a "
"kernel-side implementation.  If the token value is non-zero, it will be "
"associated with that service, and subsequent RTAS calls by the guest "
"specifying that token will be handled by the kernel.  If the token value is "
"0, then any token associated with the service will be forgotten, and "
"subsequent RTAS calls by the guest for that service will be passed to "
"userspace to be handled."
msgstr ""

#: ../../../virt/kvm/api.rst:3699
msgid "4.87 KVM_SET_GUEST_DEBUG"
msgstr ""

#: ../../../virt/kvm/api.rst:3701
msgid "KVM_CAP_SET_GUEST_DEBUG"
msgstr ""

#: ../../../virt/kvm/api.rst:3702
msgid "x86, s390, ppc, arm64"
msgstr ""

#: ../../../virt/kvm/api.rst:3704
msgid "struct kvm_guest_debug (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3715
msgid ""
"Set up the processor specific debug registers and configure vcpu for "
"handling guest debug events. There are two parts to the structure, the first "
"a control bitfield indicates the type of debug events to handle when "
"running. Common control bits are:"
msgstr ""

#: ../../../virt/kvm/api.rst:3720
msgid "KVM_GUESTDBG_ENABLE:        guest debugging is enabled"
msgstr ""

#: ../../../virt/kvm/api.rst:3721
msgid "KVM_GUESTDBG_SINGLESTEP:    the next run should single-step"
msgstr ""

#: ../../../virt/kvm/api.rst:3723
msgid ""
"The top 16 bits of the control field are architecture specific control flags "
"which can include the following:"
msgstr ""

#: ../../../virt/kvm/api.rst:3726
msgid "KVM_GUESTDBG_USE_SW_BP:     using software breakpoints [x86, arm64]"
msgstr ""

#: ../../../virt/kvm/api.rst:3727
msgid "KVM_GUESTDBG_USE_HW_BP:     using hardware breakpoints [x86, s390]"
msgstr ""

#: ../../../virt/kvm/api.rst:3728
msgid "KVM_GUESTDBG_USE_HW:        using hardware debug events [arm64]"
msgstr ""

#: ../../../virt/kvm/api.rst:3729
msgid "KVM_GUESTDBG_INJECT_DB:     inject DB type exception [x86]"
msgstr ""

#: ../../../virt/kvm/api.rst:3730
msgid "KVM_GUESTDBG_INJECT_BP:     inject BP type exception [x86]"
msgstr ""

#: ../../../virt/kvm/api.rst:3731
msgid "KVM_GUESTDBG_EXIT_PENDING:  trigger an immediate guest exit [s390]"
msgstr ""

#: ../../../virt/kvm/api.rst:3732
msgid "KVM_GUESTDBG_BLOCKIRQ:      avoid injecting interrupts/NMI/SMI [x86]"
msgstr ""

#: ../../../virt/kvm/api.rst:3734
msgid ""
"For example KVM_GUESTDBG_USE_SW_BP indicates that software breakpoints are "
"enabled in memory so we need to ensure breakpoint exceptions are correctly "
"trapped and the KVM run loop exits at the breakpoint and not running off "
"into the normal guest vector. For KVM_GUESTDBG_USE_HW_BP we need to ensure "
"the guest vCPUs architecture specific registers are updated to the correct "
"(supplied) values."
msgstr ""

#: ../../../virt/kvm/api.rst:3741
msgid ""
"The second part of the structure is architecture specific and typically "
"contains a set of debug registers."
msgstr ""

#: ../../../virt/kvm/api.rst:3744
msgid ""
"For arm64 the number of debug registers is implementation defined and can be "
"determined by querying the KVM_CAP_GUEST_DEBUG_HW_BPS and "
"KVM_CAP_GUEST_DEBUG_HW_WPS capabilities which return a positive number "
"indicating the number of supported registers."
msgstr ""

#: ../../../virt/kvm/api.rst:3749
msgid ""
"For ppc, the KVM_CAP_PPC_GUEST_DEBUG_SSTEP capability indicates whether the "
"single-step debug event (KVM_GUESTDBG_SINGLESTEP) is supported."
msgstr ""

#: ../../../virt/kvm/api.rst:3752
msgid ""
"Also when supported, KVM_CAP_SET_GUEST_DEBUG2 capability indicates the "
"supported KVM_GUESTDBG_* bits in the control field."
msgstr ""

#: ../../../virt/kvm/api.rst:3755
msgid ""
"When debug events exit the main run loop with the reason KVM_EXIT_DEBUG with "
"the kvm_debug_exit_arch part of the kvm_run structure containing "
"architecture specific debug information."
msgstr ""

#: ../../../virt/kvm/api.rst:3760
msgid "4.88 KVM_GET_EMULATED_CPUID"
msgstr ""

#: ../../../virt/kvm/api.rst:3762
msgid "KVM_CAP_EXT_EMUL_CPUID"
msgstr ""

#: ../../../virt/kvm/api.rst:3776
msgid "The member 'flags' is used for passing flags from userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:3795
msgid ""
"This ioctl returns x86 cpuid features which are emulated by kvm.Userspace "
"can use the information returned by this ioctl to query which features are "
"emulated by kvm instead of being present natively."
msgstr ""

#: ../../../virt/kvm/api.rst:3799
msgid ""
"Userspace invokes KVM_GET_EMULATED_CPUID by passing a kvm_cpuid2 structure "
"with the 'nent' field indicating the number of entries in the variable-size "
"array 'entries'. If the number of entries is too low to describe the cpu "
"capabilities, an error (E2BIG) is returned. If the number is too high, the "
"'nent' field is adjusted and an error (ENOMEM) is returned. If the number is "
"just right, the 'nent' field is adjusted to the number of valid entries in "
"the 'entries' array, which is then filled."
msgstr ""

#: ../../../virt/kvm/api.rst:3808
msgid ""
"The entries returned are the set CPUID bits of the respective features which "
"kvm emulates, as returned by the CPUID instruction, with unknown or "
"unsupported feature bits cleared."
msgstr ""

#: ../../../virt/kvm/api.rst:3812
msgid ""
"Features like x2apic, for example, may not be present in the host cpu but "
"are exposed by kvm in KVM_GET_SUPPORTED_CPUID because they can be emulated "
"efficiently and thus not included here."
msgstr ""

#: ../../../virt/kvm/api.rst:3816
msgid "The fields in each entry are defined as follows:"
msgstr ""

#: ../../../virt/kvm/api.rst:3835
msgid "4.89 KVM_S390_MEM_OP"
msgstr ""

#: ../../../virt/kvm/api.rst:3837
msgid ""
"KVM_CAP_S390_MEM_OP, KVM_CAP_S390_PROTECTED, KVM_CAP_S390_MEM_OP_EXTENSION"
msgstr ""

#: ../../../virt/kvm/api.rst:3840
msgid "struct kvm_s390_mem_op (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:3841
msgid ""
"= 0 on success, < 0 on generic error (e.g. -EFAULT or -ENOMEM), 16 bit "
"program exception code if the access causes such an exception"
msgstr ""

#: ../../../virt/kvm/api.rst:3845
msgid ""
"Read or write data from/to the VM's memory. The "
"KVM_CAP_S390_MEM_OP_EXTENSION capability specifies what functionality is "
"supported."
msgstr ""

#: ../../../virt/kvm/api.rst:3849 ../../../virt/kvm/api.rst:6165
msgid "Parameters are specified via the following structure::"
msgstr ""

#: ../../../virt/kvm/api.rst:3869
msgid ""
"The start address of the memory region has to be specified in the \"gaddr\" "
"field, and the length of the region in the \"size\" field (which must not be "
"0). The maximum value for \"size\" can be obtained by checking the "
"KVM_CAP_S390_MEM_OP capability. \"buf\" is the buffer supplied by the "
"userspace application where the read data should be written to for a read "
"access, or where the data that should be written is stored for a write "
"access.  The \"reserved\" field is meant for future extensions. Reserved and "
"unused values are ignored. Future extension that add members must introduce "
"new flags."
msgstr ""

#: ../../../virt/kvm/api.rst:3879
msgid ""
"The type of operation is specified in the \"op\" field. Flags modifying "
"their behavior can be set in the \"flags\" field. Undefined flag bits must "
"be set to 0."
msgstr ""

#: ../../../virt/kvm/api.rst:3883
msgid "Possible operations are:"
msgstr ""

#: ../../../virt/kvm/api.rst:3884
msgid "``KVM_S390_MEMOP_LOGICAL_READ``"
msgstr ""

#: ../../../virt/kvm/api.rst:3885
msgid "``KVM_S390_MEMOP_LOGICAL_WRITE``"
msgstr ""

#: ../../../virt/kvm/api.rst:3886
msgid "``KVM_S390_MEMOP_ABSOLUTE_READ``"
msgstr ""

#: ../../../virt/kvm/api.rst:3887
msgid "``KVM_S390_MEMOP_ABSOLUTE_WRITE``"
msgstr ""

#: ../../../virt/kvm/api.rst:3888
msgid "``KVM_S390_MEMOP_SIDA_READ``"
msgstr ""

#: ../../../virt/kvm/api.rst:3889
msgid "``KVM_S390_MEMOP_SIDA_WRITE``"
msgstr ""

#: ../../../virt/kvm/api.rst:3890
msgid "``KVM_S390_MEMOP_ABSOLUTE_CMPXCHG``"
msgstr ""

#: ../../../virt/kvm/api.rst:3893
msgid "Logical read/write:"
msgstr ""

#: ../../../virt/kvm/api.rst:3895
msgid ""
"Access logical memory, i.e. translate the given guest address to an absolute "
"address given the state of the VCPU and use the absolute address as target "
"of the access. \"ar\" designates the access register number to be used; the "
"valid range is 0..15. Logical accesses are permitted for the VCPU ioctl "
"only. Logical accesses are permitted for non-protected guests only."
msgstr ""

#: ../../../virt/kvm/api.rst:3902 ../../../virt/kvm/api.rst:3943
#: ../../../virt/kvm/api.rst:3965
msgid "Supported flags:"
msgstr ""

#: ../../../virt/kvm/api.rst:3903 ../../../virt/kvm/api.rst:3944
msgid "``KVM_S390_MEMOP_F_CHECK_ONLY``"
msgstr ""

#: ../../../virt/kvm/api.rst:3904
msgid "``KVM_S390_MEMOP_F_INJECT_EXCEPTION``"
msgstr ""

#: ../../../virt/kvm/api.rst:3905 ../../../virt/kvm/api.rst:3945
#: ../../../virt/kvm/api.rst:3966
msgid "``KVM_S390_MEMOP_F_SKEY_PROTECTION``"
msgstr ""

#: ../../../virt/kvm/api.rst:3907
msgid ""
"The KVM_S390_MEMOP_F_CHECK_ONLY flag can be set to check whether the "
"corresponding memory access would cause an access exception; however, no "
"actual access to the data in memory at the destination is performed. In this "
"case, \"buf\" is unused and can be NULL."
msgstr ""

#: ../../../virt/kvm/api.rst:3912
msgid ""
"In case an access exception occurred during the access (or would occur in "
"case of KVM_S390_MEMOP_F_CHECK_ONLY), the ioctl returns a positive error "
"number indicating the type of exception. This exception is also raised "
"directly at the corresponding VCPU if the flag "
"KVM_S390_MEMOP_F_INJECT_EXCEPTION is set. On protection exceptions, unless "
"specified otherwise, the injected translation-exception identifier (TEID) "
"indicates suppression."
msgstr ""

#: ../../../virt/kvm/api.rst:3920
msgid ""
"If the KVM_S390_MEMOP_F_SKEY_PROTECTION flag is set, storage key protection "
"is also in effect and may cause exceptions if accesses are prohibited given "
"the access key designated by \"key\"; the valid range is 0..15. "
"KVM_S390_MEMOP_F_SKEY_PROTECTION is available if "
"KVM_CAP_S390_MEM_OP_EXTENSION is > 0. Since the accessed memory may span "
"multiple pages and those pages might have different storage keys, it is "
"possible that a protection exception occurs after memory has been modified. "
"In this case, if the exception is injected, the TEID does not indicate "
"suppression."
msgstr ""

#: ../../../virt/kvm/api.rst:3931
msgid "Absolute read/write:"
msgstr ""

#: ../../../virt/kvm/api.rst:3933
msgid ""
"Access absolute memory. This operation is intended to be used with the "
"KVM_S390_MEMOP_F_SKEY_PROTECTION flag, to allow accessing memory and "
"performing the checks required for storage key protection as one operation "
"(as opposed to user space getting the storage keys, performing the checks, "
"and accessing memory thereafter, which could lead to a delay between check "
"and access). Absolute accesses are permitted for the VM ioctl if "
"KVM_CAP_S390_MEM_OP_EXTENSION has the KVM_S390_MEMOP_EXTENSION_CAP_BASE bit "
"set. Currently absolute accesses are not permitted for VCPU ioctls. Absolute "
"accesses are permitted for non-protected guests only."
msgstr ""

#: ../../../virt/kvm/api.rst:3947
msgid ""
"The semantics of the flags common with logical accesses are as for logical "
"accesses."
msgstr ""

#: ../../../virt/kvm/api.rst:3951
msgid "Absolute cmpxchg:"
msgstr ""

#: ../../../virt/kvm/api.rst:3953
msgid ""
"Perform cmpxchg on absolute guest memory. Intended for use with the "
"KVM_S390_MEMOP_F_SKEY_PROTECTION flag. Instead of doing an unconditional "
"write, the access occurs only if the target location contains the value "
"pointed to by \"old_addr\". This is performed as an atomic cmpxchg with the "
"length specified by the \"size\" parameter. \"size\" must be a power of two "
"up to and including 16. If the exchange did not take place because the "
"target value doesn't match the old value, the value \"old_addr\" points to "
"is replaced by the target value. User space can tell if an exchange took "
"place by checking if this replacement occurred. The cmpxchg op is permitted "
"for the VM ioctl if KVM_CAP_S390_MEM_OP_EXTENSION has flag "
"KVM_S390_MEMOP_EXTENSION_CAP_CMPXCHG set."
msgstr ""

#: ../../../virt/kvm/api.rst:3969
msgid "SIDA read/write:"
msgstr ""

#: ../../../virt/kvm/api.rst:3971
msgid ""
"Access the secure instruction data area which contains memory operands "
"necessary for instruction emulation for protected guests. SIDA accesses are "
"available if the KVM_CAP_S390_PROTECTED capability is available. SIDA "
"accesses are permitted for the VCPU ioctl only. SIDA accesses are permitted "
"for protected guests only."
msgstr ""

#: ../../../virt/kvm/api.rst:3977
msgid "No flags are supported."
msgstr ""

#: ../../../virt/kvm/api.rst:3980
msgid "4.90 KVM_S390_GET_SKEYS"
msgstr ""

#: ../../../virt/kvm/api.rst:3982 ../../../virt/kvm/api.rst:4014
msgid "KVM_CAP_S390_SKEYS"
msgstr ""

#: ../../../virt/kvm/api.rst:3985 ../../../virt/kvm/api.rst:4017
msgid "struct kvm_s390_skeys"
msgstr ""

#: ../../../virt/kvm/api.rst:3986
msgid ""
"0 on success, KVM_S390_GET_SKEYS_NONE if guest is not using storage keys, "
"negative value on error"
msgstr ""

#: ../../../virt/kvm/api.rst:3989
msgid ""
"This ioctl is used to get guest storage key values on the s390 architecture. "
"The ioctl takes parameters via the kvm_s390_skeys struct::"
msgstr ""

#: ../../../virt/kvm/api.rst:4000
msgid ""
"The start_gfn field is the number of the first guest frame whose storage "
"keys you want to get."
msgstr ""

#: ../../../virt/kvm/api.rst:4003 ../../../virt/kvm/api.rst:4027
msgid ""
"The count field is the number of consecutive frames (starting from "
"start_gfn) whose storage keys to get. The count field must be at least 1 and "
"the maximum allowed value is defined as KVM_S390_SKEYS_MAX. Values outside "
"this range will cause the ioctl to return -EINVAL."
msgstr ""

#: ../../../virt/kvm/api.rst:4008
msgid ""
"The skeydata_addr field is the address to a buffer large enough to hold "
"count bytes. This buffer will be filled with storage key data by the ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:4012
msgid "4.91 KVM_S390_SET_SKEYS"
msgstr ""

#: ../../../virt/kvm/api.rst:4018 ../../../virt/kvm/api.rst:7686
msgid "0 on success, negative value on error"
msgstr ""

#: ../../../virt/kvm/api.rst:4020
msgid ""
"This ioctl is used to set guest storage key values on the s390 architecture. "
"The ioctl takes parameters via the kvm_s390_skeys struct. See section on "
"KVM_S390_GET_SKEYS for struct definition."
msgstr ""

#: ../../../virt/kvm/api.rst:4024
msgid ""
"The start_gfn field is the number of the first guest frame whose storage "
"keys you want to set."
msgstr ""

#: ../../../virt/kvm/api.rst:4032
msgid ""
"The skeydata_addr field is the address to a buffer containing count bytes of "
"storage keys. Each byte in the buffer will be set as the storage key for a "
"single frame starting at start_gfn for count frames."
msgstr ""

#: ../../../virt/kvm/api.rst:4036
msgid ""
"Note: If any architecturally invalid key value is found in the given data "
"then the ioctl will return -EINVAL."
msgstr ""

#: ../../../virt/kvm/api.rst:4040
msgid "4.92 KVM_S390_IRQ"
msgstr ""

#: ../../../virt/kvm/api.rst:4042
msgid "KVM_CAP_S390_INJECT_IRQ"
msgstr ""

#: ../../../virt/kvm/api.rst:4045
msgid "struct kvm_s390_irq (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4052
msgid ""
"interrupt type is invalid type is KVM_S390_SIGP_STOP and flag parameter is "
"invalid value, type is KVM_S390_INT_EXTERNAL_CALL and code is bigger than "
"the maximum of VCPUs"
msgstr ""

#: ../../../virt/kvm/api.rst:4056
msgid ""
"type is KVM_S390_SIGP_SET_PREFIX and vcpu is not stopped, type is "
"KVM_S390_SIGP_STOP and a stop irq is already pending, type is "
"KVM_S390_INT_EXTERNAL_CALL and an external call interrupt is already pending"
msgstr ""

#: ../../../virt/kvm/api.rst:4062
msgid "Allows to inject an interrupt to the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:4064
msgid ""
"Using struct kvm_s390_irq as a parameter allows to inject additional payload "
"which is not possible via KVM_S390_INTERRUPT."
msgstr ""

#: ../../../virt/kvm/api.rst:4068
msgid "Interrupt parameters are passed via kvm_s390_irq::"
msgstr ""

#: ../../../virt/kvm/api.rst:4087
msgid "KVM_S390_SIGP_STOP - sigp stop; parameter in .stop"
msgstr ""

#: ../../../virt/kvm/api.rst:4088
msgid "KVM_S390_PROGRAM_INT - program check; parameters in .pgm"
msgstr ""

#: ../../../virt/kvm/api.rst:4089
msgid "KVM_S390_SIGP_SET_PREFIX - sigp set prefix; parameters in .prefix"
msgstr ""

#: ../../../virt/kvm/api.rst:4090
msgid "KVM_S390_RESTART - restart; no parameters"
msgstr ""

#: ../../../virt/kvm/api.rst:4091
msgid "KVM_S390_INT_CLOCK_COMP - clock comparator interrupt; no parameters"
msgstr ""

#: ../../../virt/kvm/api.rst:4092
msgid "KVM_S390_INT_CPU_TIMER - CPU timer interrupt; no parameters"
msgstr ""

#: ../../../virt/kvm/api.rst:4093
msgid "KVM_S390_INT_EMERGENCY - sigp emergency; parameters in .emerg"
msgstr ""

#: ../../../virt/kvm/api.rst:4094
msgid "KVM_S390_INT_EXTERNAL_CALL - sigp external call; parameters in .extcall"
msgstr ""

#: ../../../virt/kvm/api.rst:4095
msgid "KVM_S390_MCHK - machine check interrupt; parameters in .mchk"
msgstr ""

#: ../../../virt/kvm/api.rst:4100
msgid "4.94 KVM_S390_GET_IRQ_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:4102 ../../../virt/kvm/api.rst:4137
msgid "KVM_CAP_S390_IRQ_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:4105
msgid "struct kvm_s390_irq_state (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:4106
msgid ""
">= number of bytes copied into buffer, -EINVAL if buffer size is 0, -ENOBUFS "
"if buffer size is too small to fit all pending interrupts, -EFAULT if the "
"buffer address was invalid"
msgstr ""

#: ../../../virt/kvm/api.rst:4111
msgid ""
"This ioctl allows userspace to retrieve the complete state of all currently "
"pending interrupts in a single buffer. Use cases include migration and "
"introspection. The parameter structure contains the address of a userspace "
"buffer and its length::"
msgstr ""

#: ../../../virt/kvm/api.rst:4123
msgid ""
"Userspace passes in the above struct and for each pending interrupt a struct "
"kvm_s390_irq is copied to the provided buffer."
msgstr ""

#: ../../../virt/kvm/api.rst:4126
msgid ""
"The structure contains a flags and a reserved field for future extensions. "
"As the kernel never checked for flags == 0 and QEMU never pre-zeroed flags "
"and reserved, these fields can not be used in the future without breaking "
"compatibility."
msgstr ""

#: ../../../virt/kvm/api.rst:4131
msgid ""
"If -ENOBUFS is returned the buffer provided was too small and userspace may "
"retry with a bigger buffer."
msgstr ""

#: ../../../virt/kvm/api.rst:4135
msgid "4.95 KVM_S390_SET_IRQ_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:4140
msgid "struct kvm_s390_irq_state (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4141
msgid ""
"0 on success, -EFAULT if the buffer address was invalid, -EINVAL for an "
"invalid buffer length (see below), -EBUSY if there were already interrupts "
"pending, errors occurring when actually injecting the interrupt. See "
"KVM_S390_IRQ."
msgstr ""

#: ../../../virt/kvm/api.rst:4148
msgid ""
"This ioctl allows userspace to set the complete state of all cpu-local "
"interrupts currently pending for the vcpu. It is intended for restoring "
"interrupt state after a migration. The input parameter is a userspace buffer "
"containing a struct kvm_s390_irq_state::"
msgstr ""

#: ../../../virt/kvm/api.rst:4160
msgid ""
"The restrictions for flags and reserved apply as well. (see "
"KVM_S390_GET_IRQ_STATE)"
msgstr ""

#: ../../../virt/kvm/api.rst:4163
msgid ""
"The userspace memory referenced by buf contains a struct kvm_s390_irq for "
"each interrupt to be injected into the guest. If one of the interrupts could "
"not be injected for some reason the ioctl aborts."
msgstr ""

#: ../../../virt/kvm/api.rst:4168
msgid ""
"len must be a multiple of sizeof(struct kvm_s390_irq). It must be > 0 and it "
"must not exceed (max_vcpus + 32) * sizeof(struct kvm_s390_irq), which is the "
"maximum number of possibly pending cpu-local interrupts."
msgstr ""

#: ../../../virt/kvm/api.rst:4173
msgid "4.96 KVM_SMI"
msgstr ""

#: ../../../virt/kvm/api.rst:4175
msgid "KVM_CAP_X86_SMM"
msgstr ""

#: ../../../virt/kvm/api.rst:4181
msgid "Queues an SMI on the thread's vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:4184
msgid "4.97 KVM_X86_SET_MSR_FILTER"
msgstr ""

#: ../../../virt/kvm/api.rst:4186
msgid "KVM_CAP_X86_MSR_FILTER"
msgstr ""

#: ../../../virt/kvm/api.rst:4189
msgid "struct kvm_msr_filter"
msgstr ""

#: ../../../virt/kvm/api.rst:4190 ../../../virt/kvm/api.rst:4972
#: ../../../virt/kvm/api.rst:5334 ../../../virt/kvm/api.rst:5537
#: ../../../virt/kvm/api.rst:5660 ../../../virt/kvm/api.rst:5673
#: ../../../virt/kvm/api.rst:5787 ../../../virt/kvm/api.rst:6116
#: ../../../virt/kvm/api.rst:6136 ../../../virt/kvm/api.rst:6208
#: ../../../virt/kvm/api.rst:6248
msgid "0 on success, < 0 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:4211
msgid "flags values for ``struct kvm_msr_filter_range``:"
msgstr ""

#: ../../../virt/kvm/api.rst:4213
msgid "``KVM_MSR_FILTER_READ``"
msgstr ""

#: ../../../virt/kvm/api.rst:4215
msgid ""
"Filter read accesses to MSRs using the given bitmap. A 0 in the bitmap "
"indicates that read accesses should be denied, while a 1 indicates that a "
"read for a particular MSR should be allowed regardless of the default filter "
"action."
msgstr ""

#: ../../../virt/kvm/api.rst:4220
msgid "``KVM_MSR_FILTER_WRITE``"
msgstr ""

#: ../../../virt/kvm/api.rst:4222
msgid ""
"Filter write accesses to MSRs using the given bitmap. A 0 in the bitmap "
"indicates that write accesses should be denied, while a 1 indicates that a "
"write for a particular MSR should be allowed regardless of the default "
"filter action."
msgstr ""

#: ../../../virt/kvm/api.rst:4227
msgid "flags values for ``struct kvm_msr_filter``:"
msgstr ""

#: ../../../virt/kvm/api.rst:4229
msgid "``KVM_MSR_FILTER_DEFAULT_ALLOW``"
msgstr ""

#: ../../../virt/kvm/api.rst:4231
msgid ""
"If no filter range matches an MSR index that is getting accessed, KVM will "
"allow accesses to all MSRs by default."
msgstr ""

#: ../../../virt/kvm/api.rst:4234
msgid "``KVM_MSR_FILTER_DEFAULT_DENY``"
msgstr ""

#: ../../../virt/kvm/api.rst:4236
msgid ""
"If no filter range matches an MSR index that is getting accessed, KVM will "
"deny accesses to all MSRs by default."
msgstr ""

#: ../../../virt/kvm/api.rst:4239
msgid ""
"This ioctl allows userspace to define up to 16 bitmaps of MSR ranges to deny "
"guest MSR accesses that would normally be allowed by KVM.  If an MSR is not "
"covered by a specific range, the \"default\" filtering behavior applies.  "
"Each bitmap range covers MSRs from [base .. base+nmsrs)."
msgstr ""

#: ../../../virt/kvm/api.rst:4244
msgid ""
"If an MSR access is denied by userspace, the resulting KVM behavior depends "
"on whether or not KVM_CAP_X86_USER_SPACE_MSR's KVM_MSR_EXIT_REASON_FILTER is "
"enabled.  If KVM_MSR_EXIT_REASON_FILTER is enabled, KVM will exit to "
"userspace on denied accesses, i.e. userspace effectively intercepts the MSR "
"access.  If KVM_MSR_EXIT_REASON_FILTER is not enabled, KVM will inject a #GP "
"into the guest on denied accesses.  Note, if an MSR access is denied during "
"emulation of MSR load/stores during VMX transitions, KVM ignores "
"KVM_MSR_EXIT_REASON_FILTER. See the below warning for full details."
msgstr ""

#: ../../../virt/kvm/api.rst:4253
msgid ""
"If an MSR access is allowed by userspace, KVM will emulate and/or virtualize "
"the access in accordance with the vCPU model.  Note, KVM may still "
"ultimately inject a #GP if an access is allowed by userspace, e.g. if KVM "
"doesn't support the MSR, or to follow architectural behavior for the MSR."
msgstr ""

#: ../../../virt/kvm/api.rst:4258
msgid ""
"By default, KVM operates in KVM_MSR_FILTER_DEFAULT_ALLOW mode with no MSR "
"range filters."
msgstr ""

#: ../../../virt/kvm/api.rst:4261
msgid ""
"Calling this ioctl with an empty set of ranges (all nmsrs == 0) disables MSR "
"filtering. In that mode, ``KVM_MSR_FILTER_DEFAULT_DENY`` is invalid and "
"causes an error."
msgstr ""

#: ../../../virt/kvm/api.rst:4266
msgid ""
"MSR accesses that are side effects of instruction execution (emulated or "
"native) are not filtered as hardware does not honor MSR bitmaps outside of "
"RDMSR and WRMSR, and KVM mimics that behavior when emulating instructions to "
"avoid pointless divergence from hardware.  E.g. RDPID reads MSR_TSC_AUX, "
"SYSENTER reads the SYSENTER MSRs, etc."
msgstr ""

#: ../../../virt/kvm/api.rst:4272
msgid ""
"MSRs that are loaded/stored via dedicated VMCS fields are not filtered as "
"part of VM-Enter/VM-Exit emulation."
msgstr ""

#: ../../../virt/kvm/api.rst:4275
msgid ""
"MSRs that are loaded/store via VMX's load/store lists _are_ filtered as part "
"of VM-Enter/VM-Exit emulation.  If an MSR access is denied on VM-Enter, KVM "
"synthesizes a consistency check VM-Exit(EXIT_REASON_MSR_LOAD_FAIL).  If an "
"MSR access is denied on VM-Exit, KVM synthesizes a VM-Abort.  In short, KVM "
"extends Intel's architectural list of MSRs that cannot be loaded/saved via "
"the VM-Enter/VM-Exit MSR list.  It is platform owner's responsibility to to "
"communicate any such restrictions to their end users."
msgstr ""

#: ../../../virt/kvm/api.rst:4283
msgid ""
"x2APIC MSR accesses cannot be filtered (KVM silently ignores filters that "
"cover any x2APIC MSRs)."
msgstr ""

#: ../../../virt/kvm/api.rst:4286
msgid ""
"Note, invoking this ioctl while a vCPU is running is inherently racy.  "
"However, KVM does guarantee that vCPUs will see either the previous filter "
"or the new filter, e.g. MSRs with identical settings in both the old and new "
"filter will have deterministic behavior."
msgstr ""

#: ../../../virt/kvm/api.rst:4291
msgid ""
"Similarly, if userspace wishes to intercept on denied accesses, "
"KVM_MSR_EXIT_REASON_FILTER must be enabled before activating any filters, "
"and left enabled until after all filters are deactivated.  Failure to do so "
"may result in KVM injecting a #GP instead of exiting to userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:4297
msgid "4.98 KVM_CREATE_SPAPR_TCE_64"
msgstr ""

#: ../../../virt/kvm/api.rst:4299
msgid "KVM_CAP_SPAPR_TCE_64"
msgstr ""

#: ../../../virt/kvm/api.rst:4302
msgid "struct kvm_create_spapr_tce_64 (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4305
msgid ""
"This is an extension for KVM_CAP_SPAPR_TCE which only supports 32bit "
"windows, described in 4.62 KVM_CREATE_SPAPR_TCE"
msgstr ""

#: ../../../virt/kvm/api.rst:4308
msgid "This capability uses extended struct in ioctl interface::"
msgstr ""

#: ../../../virt/kvm/api.rst:4319
msgid ""
"The aim of extension is to support an additional bigger DMA window with a "
"variable page size. KVM_CREATE_SPAPR_TCE_64 receives a 64bit window size, an "
"IOMMU page shift and a bus offset of the corresponding DMA window, @size and "
"@offset are numbers of IOMMU pages."
msgstr ""

#: ../../../virt/kvm/api.rst:4325
msgid "@flags are not used at the moment."
msgstr ""

#: ../../../virt/kvm/api.rst:4327
msgid "The rest of functionality is identical to KVM_CREATE_SPAPR_TCE."
msgstr ""

#: ../../../virt/kvm/api.rst:4330
msgid "4.99 KVM_REINJECT_CONTROL"
msgstr ""

#: ../../../virt/kvm/api.rst:4332
msgid "KVM_CAP_REINJECT_CONTROL"
msgstr ""

#: ../../../virt/kvm/api.rst:4335
msgid "struct kvm_reinject_control (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4336
msgid ""
"0 on success, -EFAULT if struct kvm_reinject_control cannot be read, -ENXIO "
"if KVM_CREATE_PIT or KVM_CREATE_PIT2 didn't succeed earlier."
msgstr ""

#: ../../../virt/kvm/api.rst:4340
msgid ""
"i8254 (PIT) has two modes, reinject and !reinject.  The default is reinject, "
"where KVM queues elapsed i8254 ticks and monitors completion of interrupt "
"from vector(s) that i8254 injects.  Reinject mode dequeues a tick and "
"injects its interrupt whenever there isn't a pending interrupt from i8254. !"
"reinject mode injects an interrupt as soon as a tick arrives."
msgstr ""

#: ../../../virt/kvm/api.rst:4353
msgid ""
"pit_reinject = 0 (!reinject mode) is recommended, unless running an old "
"operating system that uses the PIT for timing (e.g. Linux 2.4.x)."
msgstr ""

#: ../../../virt/kvm/api.rst:4357
msgid "4.100 KVM_PPC_CONFIGURE_V3_MMU"
msgstr ""

#: ../../../virt/kvm/api.rst:4359
msgid "KVM_CAP_PPC_MMU_RADIX or KVM_CAP_PPC_MMU_HASH_V3"
msgstr ""

#: ../../../virt/kvm/api.rst:4362
msgid "struct kvm_ppc_mmuv3_cfg (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4363
msgid ""
"0 on success, -EFAULT if struct kvm_ppc_mmuv3_cfg cannot be read, -EINVAL if "
"the configuration is invalid"
msgstr ""

#: ../../../virt/kvm/api.rst:4367
msgid ""
"This ioctl controls whether the guest will use radix or HPT (hashed page "
"table) translation, and sets the pointer to the process table for the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:4378
msgid ""
"There are two bits that can be set in flags; KVM_PPC_MMUV3_RADIX and "
"KVM_PPC_MMUV3_GTSE.  KVM_PPC_MMUV3_RADIX, if set, configures the guest to "
"use radix tree translation, and if clear, to use HPT translation. "
"KVM_PPC_MMUV3_GTSE, if set and if KVM permits it, configures the guest to be "
"able to use the global TLB and SLB invalidation instructions; if clear, the "
"guest may not use these instructions."
msgstr ""

#: ../../../virt/kvm/api.rst:4385
msgid ""
"The process_table field specifies the address and size of the guest process "
"table, which is in the guest's space.  This field is formatted as the second "
"doubleword of the partition table entry, as defined in the Power ISA V3.00, "
"Book III section 5.7.6.1."
msgstr ""

#: ../../../virt/kvm/api.rst:4391
msgid "4.101 KVM_PPC_GET_RMMU_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:4393
msgid "KVM_CAP_PPC_MMU_RADIX"
msgstr ""

#: ../../../virt/kvm/api.rst:4396
msgid "struct kvm_ppc_rmmu_info (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:4397
msgid ""
"0 on success, -EFAULT if struct kvm_ppc_rmmu_info cannot be written, -EINVAL "
"if no useful information can be returned"
msgstr ""

#: ../../../virt/kvm/api.rst:4401
msgid ""
"This ioctl returns a structure containing two things: (a) a list containing "
"supported radix tree geometries, and (b) a list that maps page sizes to put "
"in the \"AP\" (actual page size) field for the tlbie (TLB invalidate entry) "
"instruction."
msgstr ""

#: ../../../virt/kvm/api.rst:4417
msgid ""
"The geometries[] field gives up to 8 supported geometries for the radix page "
"table, in terms of the log base 2 of the smallest page size, and the number "
"of bits indexed at each level of the tree, from the PTE level up to the PGD "
"level in that order.  Any unused entries will have 0 in the page_shift field."
msgstr ""

#: ../../../virt/kvm/api.rst:4423
msgid ""
"The ap_encodings gives the supported page sizes and their AP field "
"encodings, encoded with the AP value in the top 3 bits and the log base 2 of "
"the page size in the bottom 6 bits."
msgstr ""

#: ../../../virt/kvm/api.rst:4428
msgid "4.102 KVM_PPC_RESIZE_HPT_PREPARE"
msgstr ""

#: ../../../virt/kvm/api.rst:4430 ../../../virt/kvm/api.rst:4484
msgid "KVM_CAP_SPAPR_RESIZE_HPT"
msgstr ""

#: ../../../virt/kvm/api.rst:4433 ../../../virt/kvm/api.rst:4487
msgid "struct kvm_ppc_resize_hpt (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4434
msgid ""
"0 on successful completion, >0 if a new HPT is being prepared, the value is "
"an estimated number of milliseconds until preparation is complete, -EFAULT "
"if struct kvm_reinject_control cannot be read, -EINVAL if the supplied shift "
"or flags are invalid, -ENOMEM if unable to allocate the new HPT,"
msgstr ""

#: ../../../virt/kvm/api.rst:4441
msgid ""
"Used to implement the PAPR extension for runtime resizing of a guest's "
"Hashed Page Table (HPT).  Specifically this starts, stops or monitors the "
"preparation of a new potential HPT for the guest, essentially implementing "
"the H_RESIZE_HPT_PREPARE hypercall."
msgstr ""

#: ../../../virt/kvm/api.rst:4454
msgid ""
"If called with shift > 0 when there is no pending HPT for the guest, this "
"begins preparation of a new pending HPT of size 2^(shift) bytes. It then "
"returns a positive integer with the estimated number of milliseconds until "
"preparation is complete."
msgstr ""

#: ../../../virt/kvm/api.rst:4459
msgid ""
"If called when there is a pending HPT whose size does not match that "
"requested in the parameters, discards the existing pending HPT and creates a "
"new one as above."
msgstr ""

#: ../../../virt/kvm/api.rst:4463
msgid "If called when there is a pending HPT of the size requested, will:"
msgstr ""

#: ../../../virt/kvm/api.rst:4465
msgid "If preparation of the pending HPT is already complete, return 0"
msgstr ""

#: ../../../virt/kvm/api.rst:4466
msgid ""
"If preparation of the pending HPT has failed, return an error code, then "
"discard the pending HPT."
msgstr ""

#: ../../../virt/kvm/api.rst:4468
msgid ""
"If preparation of the pending HPT is still in progress, return an estimated "
"number of milliseconds until preparation is complete."
msgstr ""

#: ../../../virt/kvm/api.rst:4471
msgid ""
"If called with shift == 0, discards any currently pending HPT and returns 0 "
"(i.e. cancels any in-progress preparation)."
msgstr ""

#: ../../../virt/kvm/api.rst:4474
msgid ""
"flags is reserved for future expansion, currently setting any bits in flags "
"will result in an -EINVAL."
msgstr ""

#: ../../../virt/kvm/api.rst:4477
msgid ""
"Normally this will be called repeatedly with the same parameters until it "
"returns <= 0.  The first call will initiate preparation, subsequent ones "
"will monitor preparation until it completes or fails."
msgstr ""

#: ../../../virt/kvm/api.rst:4482
msgid "4.103 KVM_PPC_RESIZE_HPT_COMMIT"
msgstr ""

#: ../../../virt/kvm/api.rst:4488
msgid ""
"0 on successful completion, -EFAULT if struct kvm_reinject_control cannot be "
"read, -EINVAL if the supplied shift or flags are invalid, -ENXIO is there is "
"no pending HPT, or the pending HPT doesn't have the requested size, -EBUSY "
"if the pending HPT is not fully prepared, -ENOSPC if there was a hash "
"collision when moving existing HPT entries to the new HPT, -EIO on other "
"error conditions"
msgstr ""

#: ../../../virt/kvm/api.rst:4498
msgid ""
"Used to implement the PAPR extension for runtime resizing of a guest's "
"Hashed Page Table (HPT).  Specifically this requests that the guest be "
"transferred to working with the new HPT, essentially implementing the "
"H_RESIZE_HPT_COMMIT hypercall."
msgstr ""

#: ../../../virt/kvm/api.rst:4511
msgid ""
"This should only be called after KVM_PPC_RESIZE_HPT_PREPARE has returned 0 "
"with the same parameters.  In other cases KVM_PPC_RESIZE_HPT_COMMIT will "
"return an error (usually -ENXIO or -EBUSY, though others may be possible if "
"the preparation was started, but failed)."
msgstr ""

#: ../../../virt/kvm/api.rst:4517
msgid ""
"This will have undefined effects on the guest if it has not already placed "
"itself in a quiescent state where no vcpu will make MMU enabled memory "
"accesses."
msgstr ""

#: ../../../virt/kvm/api.rst:4521
msgid ""
"On successful completion, the pending HPT will become the guest's active HPT "
"and the previous HPT will be discarded."
msgstr ""

#: ../../../virt/kvm/api.rst:4524
msgid "On failure, the guest will still be operating on its previous HPT."
msgstr ""

#: ../../../virt/kvm/api.rst:4527
msgid "4.104 KVM_X86_GET_MCE_CAP_SUPPORTED"
msgstr ""

#: ../../../virt/kvm/api.rst:4529 ../../../virt/kvm/api.rst:4542
#: ../../../virt/kvm/api.rst:4561
msgid "KVM_CAP_MCE"
msgstr ""

#: ../../../virt/kvm/api.rst:4532
msgid "u64 mce_cap (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:4535
msgid ""
"Returns supported MCE capabilities. The u64 mce_cap parameter has the same "
"format as the MSR_IA32_MCG_CAP register. Supported capabilities will have "
"the corresponding bits set."
msgstr ""

#: ../../../virt/kvm/api.rst:4540
msgid "4.105 KVM_X86_SETUP_MCE"
msgstr ""

#: ../../../virt/kvm/api.rst:4545
msgid "u64 mcg_cap (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4546
msgid ""
"0 on success, -EFAULT if u64 mcg_cap cannot be read, -EINVAL if the "
"requested number of banks is invalid, -EINVAL if requested MCE capability is "
"not supported."
msgstr ""

#: ../../../virt/kvm/api.rst:4551
msgid ""
"Initializes MCE support for use. The u64 mcg_cap parameter has the same "
"format as the MSR_IA32_MCG_CAP register and specifies which capabilities "
"should be enabled. The maximum supported number of error-reporting banks can "
"be retrieved when checking for KVM_CAP_MCE. The supported capabilities can "
"be retrieved with KVM_X86_GET_MCE_CAP_SUPPORTED."
msgstr ""

#: ../../../virt/kvm/api.rst:4559
msgid "4.106 KVM_X86_SET_MCE"
msgstr ""

#: ../../../virt/kvm/api.rst:4564
msgid "struct kvm_x86_mce (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4565
msgid ""
"0 on success, -EFAULT if struct kvm_x86_mce cannot be read, -EINVAL if the "
"bank number is invalid, -EINVAL if VAL bit is not set in status field."
msgstr ""

#: ../../../virt/kvm/api.rst:4570
msgid ""
"Inject a machine check error (MCE) into the guest. The input parameter is::"
msgstr ""

#: ../../../virt/kvm/api.rst:4583
msgid ""
"If the MCE being reported is an uncorrected error, KVM will inject it as an "
"MCE exception into the guest. If the guest MCG_STATUS register reports that "
"an MCE is in progress, KVM causes an KVM_EXIT_SHUTDOWN vmexit."
msgstr ""

#: ../../../virt/kvm/api.rst:4588
msgid ""
"Otherwise, if the MCE is a corrected error, KVM will just store it in the "
"corresponding bank (provided this bank is not holding a previously reported "
"uncorrected error)."
msgstr ""

#: ../../../virt/kvm/api.rst:4593
msgid "4.107 KVM_S390_GET_CMMA_BITS"
msgstr ""

#: ../../../virt/kvm/api.rst:4595 ../../../virt/kvm/api.rst:4696
msgid "KVM_CAP_S390_CMMA_MIGRATION"
msgstr ""

#: ../../../virt/kvm/api.rst:4598
msgid "struct kvm_s390_cmma_log (in, out)"
msgstr ""

#: ../../../virt/kvm/api.rst:4599 ../../../virt/kvm/api.rst:4700
msgid "0 on success, a negative value on error"
msgstr ""

#: ../../../virt/kvm/api.rst:4604 ../../../virt/kvm/api.rst:5277
#: ../../../virt/kvm/api.rst:5891
msgid "ENOMEM"
msgstr ""

#: ../../../virt/kvm/api.rst:4604
msgid "not enough memory can be allocated to complete the task"
msgstr ""

#: ../../../virt/kvm/api.rst:4605
msgid "if CMMA is not enabled"
msgstr ""

#: ../../../virt/kvm/api.rst:4606
msgid "if KVM_S390_CMMA_PEEK is not set but migration mode was not enabled"
msgstr ""

#: ../../../virt/kvm/api.rst:4607
msgid ""
"if KVM_S390_CMMA_PEEK is not set but dirty tracking has been disabled (and "
"thus migration mode was automatically disabled)"
msgstr ""

#: ../../../virt/kvm/api.rst:4609
msgid ""
"if the userspace address is invalid or if no page table is present for the "
"addresses (e.g. when using hugepages)."
msgstr ""

#: ../../../virt/kvm/api.rst:4613
msgid ""
"This ioctl is used to get the values of the CMMA bits on the s390 "
"architecture. It is meant to be used in two scenarios:"
msgstr ""

#: ../../../virt/kvm/api.rst:4616
msgid ""
"During live migration to save the CMMA values. Live migration needs to be "
"enabled via the KVM_REQ_START_MIGRATION VM property."
msgstr ""

#: ../../../virt/kvm/api.rst:4618
msgid ""
"To non-destructively peek at the CMMA values, with the flag "
"KVM_S390_CMMA_PEEK set."
msgstr ""

#: ../../../virt/kvm/api.rst:4621
msgid ""
"The ioctl takes parameters via the kvm_s390_cmma_log struct. The desired "
"values are written to a buffer whose location is indicated via the "
"\"values\" member in the kvm_s390_cmma_log struct.  The values in the input "
"struct are also updated as needed."
msgstr ""

#: ../../../virt/kvm/api.rst:4626
msgid "Each CMMA value takes up one byte."
msgstr ""

#: ../../../virt/kvm/api.rst:4641
msgid ""
"start_gfn is the number of the first guest frame whose CMMA values are to be "
"retrieved,"
msgstr ""

#: ../../../virt/kvm/api.rst:4644
msgid "count is the length of the buffer in bytes,"
msgstr ""

#: ../../../virt/kvm/api.rst:4646
msgid "values points to the buffer where the result will be written to."
msgstr ""

#: ../../../virt/kvm/api.rst:4648
msgid ""
"If count is greater than KVM_S390_SKEYS_MAX, then it is considered to be "
"KVM_S390_SKEYS_MAX. KVM_S390_SKEYS_MAX is re-used for consistency with other "
"ioctls."
msgstr ""

#: ../../../virt/kvm/api.rst:4652
msgid ""
"The result is written in the buffer pointed to by the field values, and the "
"values of the input parameter are updated as follows."
msgstr ""

#: ../../../virt/kvm/api.rst:4655
msgid ""
"Depending on the flags, different actions are performed. The only supported "
"flag so far is KVM_S390_CMMA_PEEK."
msgstr ""

#: ../../../virt/kvm/api.rst:4658
msgid ""
"The default behaviour if KVM_S390_CMMA_PEEK is not set is: start_gfn will "
"indicate the first page frame whose CMMA bits were dirty. It is not "
"necessarily the same as the one passed as input, as clean pages are skipped."
msgstr ""

#: ../../../virt/kvm/api.rst:4663
msgid ""
"count will indicate the number of bytes actually written in the buffer. It "
"can (and very often will) be smaller than the input value, since the buffer "
"is only filled until 16 bytes of clean values are found (which are then not "
"copied in the buffer). Since a CMMA migration block needs the base address "
"and the length, for a total of 16 bytes, we will send back some clean data "
"if there is some dirty data afterwards, as long as the size of the clean "
"data does not exceed the size of the header. This allows to minimize the "
"amount of data to be saved or transferred over the network at the expense of "
"more roundtrips to userspace. The next invocation of the ioctl will skip "
"over all the clean values, saving potentially more than just the 16 bytes we "
"found."
msgstr ""

#: ../../../virt/kvm/api.rst:4675
msgid ""
"If KVM_S390_CMMA_PEEK is set: the existing storage attributes are read even "
"when not in migration mode, and no other action is performed;"
msgstr ""

#: ../../../virt/kvm/api.rst:4679
msgid "the output start_gfn will be equal to the input start_gfn,"
msgstr ""

#: ../../../virt/kvm/api.rst:4681
msgid ""
"the output count will be equal to the input count, except if the end of "
"memory has been reached."
msgstr ""

#: ../../../virt/kvm/api.rst:4684
msgid ""
"In both cases: the field \"remaining\" will indicate the total number of "
"dirty CMMA values still remaining, or 0 if KVM_S390_CMMA_PEEK is set and "
"migration mode is not enabled."
msgstr ""

#: ../../../virt/kvm/api.rst:4689
msgid "mask is unused."
msgstr ""

#: ../../../virt/kvm/api.rst:4691
msgid "values points to the userspace buffer where the result will be stored."
msgstr ""

#: ../../../virt/kvm/api.rst:4694
msgid "4.108 KVM_S390_SET_CMMA_BITS"
msgstr ""

#: ../../../virt/kvm/api.rst:4699
msgid "struct kvm_s390_cmma_log (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4702
msgid ""
"This ioctl is used to set the values of the CMMA bits on the s390 "
"architecture. It is meant to be used during live migration to restore the "
"CMMA values, but there are no restrictions on its use. The ioctl takes "
"parameters via the kvm_s390_cmma_values struct. Each CMMA value takes up one "
"byte."
msgstr ""

#: ../../../virt/kvm/api.rst:4721
msgid "start_gfn indicates the starting guest frame number,"
msgstr ""

#: ../../../virt/kvm/api.rst:4723
msgid "count indicates how many values are to be considered in the buffer,"
msgstr ""

#: ../../../virt/kvm/api.rst:4725
msgid "flags is not used and must be 0."
msgstr ""

#: ../../../virt/kvm/api.rst:4727
msgid "mask indicates which PGSTE bits are to be considered."
msgstr ""

#: ../../../virt/kvm/api.rst:4729
msgid "remaining is not used."
msgstr ""

#: ../../../virt/kvm/api.rst:4731
msgid "values points to the buffer in userspace where to store the values."
msgstr ""

#: ../../../virt/kvm/api.rst:4733
msgid ""
"This ioctl can fail with -ENOMEM if not enough memory can be allocated to "
"complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if the "
"count field is too large (e.g. more than KVM_S390_CMMA_SIZE_MAX) or if the "
"flags field was not 0, with -EFAULT if the userspace address is invalid, if "
"invalid pages are written to (e.g. after the end of memory) or if no page "
"table is present for the addresses (e.g. when using hugepages)."
msgstr ""

#: ../../../virt/kvm/api.rst:4742
msgid "4.109 KVM_PPC_GET_CPU_CHAR"
msgstr ""

#: ../../../virt/kvm/api.rst:4744
msgid "KVM_CAP_PPC_GET_CPU_CHAR"
msgstr ""

#: ../../../virt/kvm/api.rst:4747
msgid "struct kvm_ppc_cpu_char (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:4748
msgid ""
"0 on successful completion, -EFAULT if struct kvm_ppc_cpu_char cannot be "
"written"
msgstr ""

#: ../../../virt/kvm/api.rst:4751
msgid ""
"This ioctl gives userspace information about certain characteristics of the "
"CPU relating to speculative execution of instructions and possible "
"information leakage resulting from speculative execution (see CVE-2017-5715, "
"CVE-2017-5753 and CVE-2017-5754).  The information is returned in struct "
"kvm_ppc_cpu_char, which looks like this::"
msgstr ""

#: ../../../virt/kvm/api.rst:4764
msgid ""
"For extensibility, the character_mask and behaviour_mask fields indicate "
"which bits of character and behaviour have been filled in by the kernel.  If "
"the set of defined bits is extended in future then userspace will be able to "
"tell whether it is running on a kernel that knows about the new bits."
msgstr ""

#: ../../../virt/kvm/api.rst:4770
msgid ""
"The character field describes attributes of the CPU which can help with "
"preventing inadvertent information disclosure - specifically, whether there "
"is an instruction to flash-invalidate the L1 data cache (ori 30,30,0 or "
"mtspr SPRN_TRIG2,rN), whether the L1 data cache is set to a mode where "
"entries can only be used by the thread that created them, whether the "
"bcctr[l] instruction prevents speculation, and whether a speculation barrier "
"instruction (ori 31,31,0) is provided."
msgstr ""

#: ../../../virt/kvm/api.rst:4778
msgid ""
"The behaviour field describes actions that software should take to prevent "
"inadvertent information disclosure, and thus describes which vulnerabilities "
"the hardware is subject to; specifically whether the L1 data cache should be "
"flushed when returning to user mode from the kernel, and whether a "
"speculation barrier should be placed between an array bounds check and the "
"array access."
msgstr ""

#: ../../../virt/kvm/api.rst:4785
msgid ""
"These fields use the same bit definitions as the new "
"H_GET_CPU_CHARACTERISTICS hypercall."
msgstr ""

#: ../../../virt/kvm/api.rst:4789
msgid "4.110 KVM_MEMORY_ENCRYPT_OP"
msgstr ""

#: ../../../virt/kvm/api.rst:4794
msgid "an opaque platform specific structure (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:4797
msgid ""
"If the platform supports creating encrypted VMs then this ioctl can be used "
"for issuing platform-specific memory encryption commands to manage those "
"encrypted VMs."
msgstr ""

#: ../../../virt/kvm/api.rst:4801
msgid ""
"Currently, this ioctl is used for issuing both Secure Encrypted "
"Virtualization (SEV) commands on AMD Processors and Trusted Domain "
"Extensions (TDX) commands on Intel Processors.  The detailed commands are "
"defined in Documentation/virt/kvm/x86/amd-memory-encryption.rst and "
"Documentation/virt/kvm/x86/intel-tdx.rst."
msgstr ""

#: ../../../virt/kvm/api.rst:4808
msgid "4.111 KVM_MEMORY_ENCRYPT_REG_REGION"
msgstr ""

#: ../../../virt/kvm/api.rst:4812 ../../../virt/kvm/api.rst:4836
msgid "system"
msgstr ""

#: ../../../virt/kvm/api.rst:4813 ../../../virt/kvm/api.rst:4837
msgid "struct kvm_enc_region (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4816
msgid ""
"This ioctl can be used to register a guest memory region which may contain "
"encrypted data (e.g. guest RAM, SMRAM etc)."
msgstr ""

#: ../../../virt/kvm/api.rst:4819
msgid ""
"It is used in the SEV-enabled guest. When encryption is enabled, a guest "
"memory region may contain encrypted data. The SEV memory encryption engine "
"uses a tweak such that two identical plaintext pages, each at different "
"locations will have differing ciphertexts. So swapping or moving ciphertext "
"of those pages will not result in plaintext being swapped. So relocating (or "
"migrating) physical backing pages for the SEV guest will require some "
"additional steps."
msgstr ""

#: ../../../virt/kvm/api.rst:4827
msgid ""
"Note: The current SEV key management spec does not provide commands to swap "
"or migrate (move) ciphertext pages. Hence, for now we pin the guest memory "
"region registered with the ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:4832
msgid "4.112 KVM_MEMORY_ENCRYPT_UNREG_REGION"
msgstr ""

#: ../../../virt/kvm/api.rst:4840
msgid ""
"This ioctl can be used to unregister the guest memory region registered with "
"KVM_MEMORY_ENCRYPT_REG_REGION ioctl above."
msgstr ""

#: ../../../virt/kvm/api.rst:4844
msgid "4.113 KVM_HYPERV_EVENTFD"
msgstr ""

#: ../../../virt/kvm/api.rst:4846
msgid "KVM_CAP_HYPERV_EVENTFD"
msgstr ""

#: ../../../virt/kvm/api.rst:4849
msgid "struct kvm_hyperv_eventfd (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4851
msgid ""
"This ioctl (un)registers an eventfd to receive notifications from the guest "
"on the specified Hyper-V connection id through the SIGNAL_EVENT hypercall, "
"without causing a user exit.  SIGNAL_EVENT hypercall with non-zero event "
"flag number (bits 24-31) still triggers a KVM_EXIT_HYPERV_HCALL user exit."
msgstr ""

#: ../../../virt/kvm/api.rst:4865
msgid "The conn_id field should fit within 24 bits::"
msgstr ""

#: ../../../virt/kvm/api.rst:4869
msgid "The acceptable values for the flags field are::"
msgstr ""

#: ../../../virt/kvm/api.rst:4873
msgid ""
"0 on success, -EINVAL if conn_id or flags is outside the allowed range, -"
"ENOENT on deassign if the conn_id isn't registered, -EEXIST on assign if the "
"conn_id is already registered"
msgstr ""

#: ../../../virt/kvm/api.rst:4879
msgid "4.114 KVM_GET_NESTED_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:4881 ../../../virt/kvm/api.rst:4955
msgid "KVM_CAP_NESTED_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:4884
msgid "struct kvm_nested_state (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:4890
msgid ""
"the total state size exceeds the value of 'size' specified by the user; the "
"size required will be written into size."
msgstr ""

#: ../../../virt/kvm/api.rst:4946
msgid ""
"This ioctl copies the vcpu's nested virtualization state from the kernel to "
"userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:4949
msgid ""
"The maximum size of the state can be retrieved by passing "
"KVM_CAP_NESTED_STATE to the KVM_CHECK_EXTENSION ioctl()."
msgstr ""

#: ../../../virt/kvm/api.rst:4953
msgid "4.115 KVM_SET_NESTED_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:4958
msgid "struct kvm_nested_state (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:4961
msgid ""
"This copies the vcpu's kvm_nested_state struct from userspace to the kernel. "
"For the definition of struct kvm_nested_state, see KVM_GET_NESTED_STATE."
msgstr ""

#: ../../../virt/kvm/api.rst:4965
msgid "4.116 KVM_(UN)REGISTER_COALESCED_MMIO"
msgstr ""

#: ../../../virt/kvm/api.rst:4967
msgid ""
"KVM_CAP_COALESCED_MMIO (for coalesced mmio) KVM_CAP_COALESCED_PIO (for "
"coalesced pio)"
msgstr ""

#: ../../../virt/kvm/api.rst:4971
msgid "struct kvm_coalesced_mmio_zone"
msgstr ""

#: ../../../virt/kvm/api.rst:4974
msgid ""
"Coalesced I/O is a performance optimization that defers hardware register "
"write emulation so that userspace exits are avoided.  It is typically used "
"to reduce the overhead of emulating frequently accessed hardware registers."
msgstr ""

#: ../../../virt/kvm/api.rst:4979
msgid ""
"When a hardware register is configured for coalesced I/O, write accesses do "
"not exit to userspace and their value is recorded in a ring buffer that is "
"shared between kernel and userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:4983
msgid ""
"Coalesced I/O is used if one or more write accesses to a hardware register "
"can be deferred until a read or a write to another hardware register on the "
"same device.  This last access will cause a vmexit and userspace will "
"process accesses from the ring buffer before emulating it. That will avoid "
"exiting to userspace on repeated writes."
msgstr ""

#: ../../../virt/kvm/api.rst:4989
msgid ""
"Coalesced pio is based on coalesced mmio. There is little difference between "
"coalesced mmio and pio except that coalesced pio records accesses to I/O "
"ports."
msgstr ""

#: ../../../virt/kvm/api.rst:4994
msgid "4.117 KVM_CLEAR_DIRTY_LOG"
msgstr ""

#: ../../../virt/kvm/api.rst:4996
msgid "KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2"
msgstr ""

#: ../../../virt/kvm/api.rst:4997 ../../../virt/kvm/api.rst:7959
msgid "x86, arm64, mips"
msgstr ""

#: ../../../virt/kvm/api.rst:4999
msgid "struct kvm_clear_dirty_log (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:5015
msgid ""
"The ioctl clears the dirty status of pages in a memory slot, according to "
"the bitmap that is passed in struct kvm_clear_dirty_log's dirty_bitmap "
"field.  Bit 0 of the bitmap corresponds to page \"first_page\" in the memory "
"slot, and num_pages is the size in bits of the input bitmap. first_page must "
"be a multiple of 64; num_pages must also be a multiple of 64 unless "
"first_page + num_pages is the size of the memory slot.  For each bit that is "
"set in the input bitmap, the corresponding page is marked \"clean\" in KVM's "
"dirty bitmap, and dirty tracking is re-enabled for that page (for example "
"via write-protection, or by clearing the dirty bit in a page table entry)."
msgstr ""

#: ../../../virt/kvm/api.rst:5026
msgid ""
"If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of slot field "
"specifies the address space for which you want to clear the dirty status.  "
"See KVM_SET_USER_MEMORY_REGION for details on the usage of slot field."
msgstr ""

#: ../../../virt/kvm/api.rst:5030
msgid ""
"This ioctl is mostly useful when KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 is "
"enabled; for more information, see the description of the capability. "
"However, it can always be used as long as KVM_CHECK_EXTENSION confirms that "
"KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 is present."
msgstr ""

#: ../../../virt/kvm/api.rst:5036
msgid "4.118 KVM_GET_SUPPORTED_HV_CPUID"
msgstr ""

#: ../../../virt/kvm/api.rst:5038
msgid "KVM_CAP_HYPERV_CPUID (vcpu), KVM_CAP_SYS_HYPERV_CPUID (system)"
msgstr ""

#: ../../../virt/kvm/api.rst:5063
msgid ""
"This ioctl returns x86 cpuid features leaves related to Hyper-V emulation in "
"KVM.  Userspace can use the information returned by this ioctl to construct "
"cpuid information presented to guests consuming Hyper-V enlightenments (e.g. "
"Windows or Hyper-V guests)."
msgstr ""

#: ../../../virt/kvm/api.rst:5068
msgid ""
"CPUID feature leaves returned by this ioctl are defined by Hyper-V Top Level "
"Functional Specification (TLFS). These leaves can't be obtained with "
"KVM_GET_SUPPORTED_CPUID ioctl because some of them intersect with KVM "
"feature leaves (0x40000000, 0x40000001)."
msgstr ""

#: ../../../virt/kvm/api.rst:5073
msgid "Currently, the following list of CPUID leaves are returned:"
msgstr ""

#: ../../../virt/kvm/api.rst:5075
msgid "HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS"
msgstr ""

#: ../../../virt/kvm/api.rst:5076
msgid "HYPERV_CPUID_INTERFACE"
msgstr ""

#: ../../../virt/kvm/api.rst:5077
msgid "HYPERV_CPUID_VERSION"
msgstr ""

#: ../../../virt/kvm/api.rst:5078
msgid "HYPERV_CPUID_FEATURES"
msgstr ""

#: ../../../virt/kvm/api.rst:5079
msgid "HYPERV_CPUID_ENLIGHTMENT_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:5080
msgid "HYPERV_CPUID_IMPLEMENT_LIMITS"
msgstr ""

#: ../../../virt/kvm/api.rst:5081
msgid "HYPERV_CPUID_NESTED_FEATURES"
msgstr ""

#: ../../../virt/kvm/api.rst:5082
msgid "HYPERV_CPUID_SYNDBG_VENDOR_AND_MAX_FUNCTIONS"
msgstr ""

#: ../../../virt/kvm/api.rst:5083
msgid "HYPERV_CPUID_SYNDBG_INTERFACE"
msgstr ""

#: ../../../virt/kvm/api.rst:5084
msgid "HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES"
msgstr ""

#: ../../../virt/kvm/api.rst:5086
msgid ""
"Userspace invokes KVM_GET_SUPPORTED_HV_CPUID by passing a kvm_cpuid2 "
"structure with the 'nent' field indicating the number of entries in the "
"variable-size array 'entries'.  If the number of entries is too low to "
"describe all Hyper-V feature leaves, an error (E2BIG) is returned. If the "
"number is more or equal to the number of Hyper-V feature leaves, the 'nent' "
"field is adjusted to the number of valid entries in the 'entries' array, "
"which is then filled."
msgstr ""

#: ../../../virt/kvm/api.rst:5093
msgid ""
"'index' and 'flags' fields in 'struct kvm_cpuid_entry2' are currently "
"reserved, userspace should not expect to get any particular value there."
msgstr ""

#: ../../../virt/kvm/api.rst:5096
msgid ""
"Note, vcpu version of KVM_GET_SUPPORTED_HV_CPUID is currently deprecated. "
"Unlike system ioctl which exposes all supported feature bits "
"unconditionally, vcpu version has the following quirks:"
msgstr ""

#: ../../../virt/kvm/api.rst:5100
msgid ""
"HYPERV_CPUID_NESTED_FEATURES leaf and HV_X64_ENLIGHTENED_VMCS_RECOMMENDED "
"feature bit are only exposed when Enlightened VMCS was previously enabled on "
"the corresponding vCPU (KVM_CAP_HYPERV_ENLIGHTENED_VMCS)."
msgstr ""

#: ../../../virt/kvm/api.rst:5103
msgid ""
"HV_STIMER_DIRECT_MODE_AVAILABLE bit is only exposed with in-kernel LAPIC. "
"(presumes KVM_CREATE_IRQCHIP has already been called)."
msgstr ""

#: ../../../virt/kvm/api.rst:5107
msgid "4.119 KVM_ARM_VCPU_FINALIZE"
msgstr ""

#: ../../../virt/kvm/api.rst:5111
msgid "int feature (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:5117
msgid "feature not enabled, needs configuration, or already finalized"
msgstr ""

#: ../../../virt/kvm/api.rst:5118
msgid "feature unknown or not present"
msgstr ""

#: ../../../virt/kvm/api.rst:5121
msgid "Recognised values for feature:"
msgstr ""

#: ../../../virt/kvm/api.rst:5124
msgid "KVM_ARM_VCPU_SVE (requires KVM_CAP_ARM_SVE)"
msgstr ""

#: ../../../virt/kvm/api.rst:5127
msgid "Finalizes the configuration of the specified vcpu feature."
msgstr ""

#: ../../../virt/kvm/api.rst:5129
msgid ""
"The vcpu must already have been initialised, enabling the affected feature, "
"by means of a successful :ref:`KVM_ARM_VCPU_INIT <KVM_ARM_VCPU_INIT>` call "
"with the appropriate flag set in features[]."
msgstr ""

#: ../../../virt/kvm/api.rst:5133
msgid ""
"For affected vcpu features, this is a mandatory step that must be performed "
"before the vcpu is fully usable."
msgstr ""

#: ../../../virt/kvm/api.rst:5136
msgid ""
"Between KVM_ARM_VCPU_INIT and KVM_ARM_VCPU_FINALIZE, the feature may be "
"configured by use of ioctls such as KVM_SET_ONE_REG.  The exact "
"configuration that should be performed and how to do it are feature-"
"dependent."
msgstr ""

#: ../../../virt/kvm/api.rst:5140
msgid ""
"Other calls that depend on a particular feature being finalized, such as "
"KVM_RUN, KVM_GET_REG_LIST, KVM_GET_ONE_REG and KVM_SET_ONE_REG, will fail "
"with -EPERM unless the feature has already been finalized by means of a "
"KVM_ARM_VCPU_FINALIZE call."
msgstr ""

#: ../../../virt/kvm/api.rst:5145
msgid ""
"See KVM_ARM_VCPU_INIT for details of vcpu features that require finalization "
"using this ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:5149
msgid "4.120 KVM_SET_PMU_EVENT_FILTER"
msgstr ""

#: ../../../virt/kvm/api.rst:5151
msgid "KVM_CAP_PMU_EVENT_FILTER"
msgstr ""

#: ../../../virt/kvm/api.rst:5154
msgid "struct kvm_pmu_event_filter (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:5160
msgid "args[0] cannot be accessed"
msgstr ""

#: ../../../virt/kvm/api.rst:5161
msgid "args[0] contains invalid data in the filter or filter events"
msgstr ""

#: ../../../virt/kvm/api.rst:5162
msgid "nevents is too large"
msgstr ""

#: ../../../virt/kvm/api.rst:5163
msgid "not enough memory to allocate the filter"
msgstr ""

#: ../../../virt/kvm/api.rst:5177
msgid ""
"This ioctl restricts the set of PMU events the guest can program by limiting "
"which event select and unit mask combinations are permitted."
msgstr ""

#: ../../../virt/kvm/api.rst:5180
msgid ""
"The argument holds a list of filter events which will be allowed or denied."
msgstr ""

#: ../../../virt/kvm/api.rst:5182
msgid ""
"Filter events only control general purpose counters; fixed purpose counters "
"are controlled by the fixed_counter_bitmap."
msgstr ""

#: ../../../virt/kvm/api.rst:5185
msgid "Valid values for 'flags'::"
msgstr ""

#: ../../../virt/kvm/api.rst:5189
msgid "To use this mode, clear the 'flags' field."
msgstr ""

#: ../../../virt/kvm/api.rst:5191
msgid "In this mode each event will contain an event select + unit mask."
msgstr ""

#: ../../../virt/kvm/api.rst:5193
msgid ""
"When the guest attempts to program the PMU the guest's event select + unit "
"mask is compared against the filter events to determine whether the guest "
"should have access."
msgstr ""

#: ../../../virt/kvm/api.rst:5197
msgid ""
"``KVM_PMU_EVENT_FLAG_MASKED_EVENTS`` :Capability: "
"KVM_CAP_PMU_EVENT_MASKED_EVENTS"
msgstr ""

#: ../../../virt/kvm/api.rst:5200
msgid ""
"In this mode each filter event will contain an event select, mask, match, "
"and exclude value.  To encode a masked event use::"
msgstr ""

#: ../../../virt/kvm/api.rst:5205
msgid "An encoded event will follow this layout::"
msgstr ""

#: ../../../virt/kvm/api.rst:5217
msgid ""
"When the guest attempts to program the PMU, these steps are followed in "
"determining if the guest should have access:"
msgstr ""

#: ../../../virt/kvm/api.rst:5220
msgid "Match the event select from the guest against the filter events."
msgstr ""

#: ../../../virt/kvm/api.rst:5221
msgid ""
"If a match is found, match the guest's unit mask to the mask and match "
"values of the included filter events. I.e. (unit mask & mask) == match && !"
"exclude."
msgstr ""

#: ../../../virt/kvm/api.rst:5224
msgid ""
"If a match is found, match the guest's unit mask to the mask and match "
"values of the excluded filter events. I.e. (unit mask & mask) == match && "
"exclude."
msgstr ""

#: ../../../virt/kvm/api.rst:5228
msgid ""
"If an included match is found and an excluded match is not found, filter the "
"event."
msgstr ""

#: ../../../virt/kvm/api.rst:5230
msgid "For everything else, do not filter the event."
msgstr ""

#: ../../../virt/kvm/api.rst:5232
msgid ""
"If the event is filtered and it's an allow list, allow the guest to program "
"the event."
msgstr ""

#: ../../../virt/kvm/api.rst:5234
msgid ""
"If the event is filtered and it's a deny list, do not allow the guest to "
"program the event."
msgstr ""

#: ../../../virt/kvm/api.rst:5237
msgid ""
"When setting a new pmu event filter, -EINVAL will be returned if any of the "
"unused fields are set or if any of the high bits (35:32) in the event select "
"are set when called on Intel."
msgstr ""

#: ../../../virt/kvm/api.rst:5241
msgid "Valid values for 'action'::"
msgstr ""

#: ../../../virt/kvm/api.rst:5246
msgid ""
"Via this API, KVM userspace can also control the behavior of the VM's fixed "
"counters (if any) by configuring the \"action\" and \"fixed_counter_bitmap\" "
"fields."
msgstr ""

#: ../../../virt/kvm/api.rst:5249
msgid ""
"Specifically, KVM follows the following pseudo-code when determining whether "
"to allow the guest FixCtr[i] to count its pre-defined fixed event::"
msgstr ""

#: ../../../virt/kvm/api.rst:5256
msgid ""
"KVM always consumes fixed_counter_bitmap, it's userspace's responsibility to "
"ensure fixed_counter_bitmap is set correctly, e.g. if userspace wants to "
"define a filter that only affects general purpose counters."
msgstr ""

#: ../../../virt/kvm/api.rst:5260
msgid ""
"Note, the \"events\" field also applies to fixed counters' hardcoded "
"event_select and unit_mask values.  \"fixed_counter_bitmap\" has higher "
"priority than \"events\" if there is a contradiction between the two."
msgstr ""

#: ../../../virt/kvm/api.rst:5265
msgid "4.121 KVM_PPC_SVM_OFF"
msgstr ""

#: ../../../virt/kvm/api.rst:5271
msgid "0 on successful completion,"
msgstr ""

#: ../../../virt/kvm/api.rst:5276
msgid "if ultravisor failed to terminate the secure guest"
msgstr ""

#: ../../../virt/kvm/api.rst:5277
msgid "if hypervisor failed to allocate new radix page tables for guest"
msgstr ""

#: ../../../virt/kvm/api.rst:5280
msgid ""
"This ioctl is used to turn off the secure mode of the guest or transition "
"the guest from secure mode to normal mode. This is invoked when the guest is "
"reset. This has no effect if called for a normal guest."
msgstr ""

#: ../../../virt/kvm/api.rst:5284
msgid ""
"This ioctl issues an ultravisor call to terminate the secure guest, unpins "
"the VPA pages and releases all the device pages that are used to track the "
"secure pages by hypervisor."
msgstr ""

#: ../../../virt/kvm/api.rst:5289
msgid "4.122 KVM_S390_NORMAL_RESET"
msgstr ""

#: ../../../virt/kvm/api.rst:5291 ../../../virt/kvm/api.rst:5316
msgid "KVM_CAP_S390_VCPU_RESETS"
msgstr ""

#: ../../../virt/kvm/api.rst:5297
msgid ""
"This ioctl resets VCPU registers and control structures according to the cpu "
"reset definition in the POP (Principles Of Operation)."
msgstr ""

#: ../../../virt/kvm/api.rst:5301
msgid "4.123 KVM_S390_INITIAL_RESET"
msgstr ""

#: ../../../virt/kvm/api.rst:5309
msgid ""
"This ioctl resets VCPU registers and control structures according to the "
"initial cpu reset definition in the POP. However, the cpu is not put into "
"ESA mode. This reset is a superset of the normal reset."
msgstr ""

#: ../../../virt/kvm/api.rst:5314
msgid "4.124 KVM_S390_CLEAR_RESET"
msgstr ""

#: ../../../virt/kvm/api.rst:5322
msgid ""
"This ioctl resets VCPU registers and control structures according to the "
"clear cpu reset definition in the POP. However, the cpu is not put into ESA "
"mode. This reset is a superset of the initial reset."
msgstr ""

#: ../../../virt/kvm/api.rst:5328
msgid "4.125 KVM_S390_PV_COMMAND"
msgstr ""

#: ../../../virt/kvm/api.rst:5330
msgid "KVM_CAP_S390_PROTECTED"
msgstr ""

#: ../../../virt/kvm/api.rst:5333
msgid "struct kvm_pv_cmd"
msgstr ""

#: ../../../virt/kvm/api.rst:5347
msgid ""
"**Ultravisor return codes** The Ultravisor return (reason) codes are "
"provided by the kernel if a Ultravisor call has been executed to achieve the "
"results expected by the command. Therefore they are independent of the IOCTL "
"return code. If KVM changes `rc`, its value will always be greater than 0 "
"hence setting it to 0 before issuing a PV command is advised to be able to "
"detect a change of `rc`."
msgstr ""

#: ../../../virt/kvm/api.rst:5355
msgid "**cmd values:**"
msgstr ""

#: ../../../virt/kvm/api.rst:5357
msgid "KVM_PV_ENABLE"
msgstr ""

#: ../../../virt/kvm/api.rst:5358
msgid ""
"Allocate memory and register the VM with the Ultravisor, thereby donating "
"memory to the Ultravisor that will become inaccessible to KVM. All existing "
"CPUs are converted to protected ones. After this command has succeeded, any "
"CPU added via hotplug will become protected during its creation as well."
msgstr ""

#: ../../../virt/kvm/api.rst:5370
msgid "KVM_PV_DISABLE"
msgstr ""

#: ../../../virt/kvm/api.rst:5371
msgid ""
"Deregister the VM from the Ultravisor and reclaim the memory that had been "
"donated to the Ultravisor, making it usable by the kernel again. All "
"registered VCPUs are converted back to non-protected ones. If a previous "
"protected VM had been prepared for asynchronous teardown with "
"KVM_PV_ASYNC_CLEANUP_PREPARE and not subsequently torn down with "
"KVM_PV_ASYNC_CLEANUP_PERFORM, it will be torn down in this call together "
"with the current protected VM."
msgstr ""

#: ../../../virt/kvm/api.rst:5379
msgid "KVM_PV_VM_SET_SEC_PARMS"
msgstr ""

#: ../../../virt/kvm/api.rst:5380
msgid ""
"Pass the image header from VM memory to the Ultravisor in preparation of "
"image unpacking and verification."
msgstr ""

#: ../../../virt/kvm/api.rst:5383
msgid "KVM_PV_VM_UNPACK"
msgstr ""

#: ../../../virt/kvm/api.rst:5384
msgid "Unpack (protect and decrypt) a page of the encrypted boot image."
msgstr ""

#: ../../../virt/kvm/api.rst:5386
msgid "KVM_PV_VM_VERIFY"
msgstr ""

#: ../../../virt/kvm/api.rst:5387
msgid ""
"Verify the integrity of the unpacked image. Only if this succeeds, KVM is "
"allowed to start protected VCPUs."
msgstr ""

#: ../../../virt/kvm/api.rst:5390
msgid "KVM_PV_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:5391 ../../../virt/kvm/api.rst:5456
#: ../../../virt/kvm/api.rst:6132
msgid "KVM_CAP_S390_PROTECTED_DUMP"
msgstr ""

#: ../../../virt/kvm/api.rst:5393
msgid ""
"Presents an API that provides Ultravisor related data to userspace via "
"subcommands. len_max is the size of the user space buffer, len_written is "
"KVM's indication of how much bytes of that buffer were actually written to. "
"len_written can be used to determine the valid fields if more response "
"fields are added in the future."
msgstr ""

#: ../../../virt/kvm/api.rst:5419 ../../../virt/kvm/api.rst:5470
msgid "**subcommands:**"
msgstr ""

#: ../../../virt/kvm/api.rst:5421
msgid "KVM_PV_INFO_VM"
msgstr ""

#: ../../../virt/kvm/api.rst:5422
msgid ""
"This subcommand provides basic Ultravisor information for PV hosts. These "
"values are likely also exported as files in the sysfs firmware UV query "
"interface but they are more easily available to programs in this API."
msgstr ""

#: ../../../virt/kvm/api.rst:5427
msgid ""
"The installed calls and feature_indication members provide the installed UV "
"calls and the UV's other feature indications."
msgstr ""

#: ../../../virt/kvm/api.rst:5430
msgid ""
"The max_* members provide information about the maximum number of PV vcpus, "
"PV guests and PV guest memory size."
msgstr ""

#: ../../../virt/kvm/api.rst:5444
msgid "KVM_PV_INFO_DUMP"
msgstr ""

#: ../../../virt/kvm/api.rst:5445
msgid "This subcommand provides information related to dumping PV guests."
msgstr ""

#: ../../../virt/kvm/api.rst:5455 ../../../virt/kvm/api.rst:6144
msgid "KVM_PV_DUMP"
msgstr ""

#: ../../../virt/kvm/api.rst:5458
msgid ""
"Presents an API that provides calls which facilitate dumping a protected VM."
msgstr ""

#: ../../../virt/kvm/api.rst:5472
msgid "KVM_PV_DUMP_INIT"
msgstr ""

#: ../../../virt/kvm/api.rst:5473
msgid ""
"Initializes the dump process of a protected VM. If this call does not "
"succeed all other subcommands will fail with -EINVAL. This subcommand will "
"return -EINVAL if a dump process has not yet been completed."
msgstr ""

#: ../../../virt/kvm/api.rst:5478
msgid ""
"Not all PV vms can be dumped, the owner needs to set `dump allowed` PCF bit "
"34 in the SE header to allow dumping."
msgstr ""

#: ../../../virt/kvm/api.rst:5481
msgid "KVM_PV_DUMP_CONFIG_STOR_STATE"
msgstr ""

#: ../../../virt/kvm/api.rst:5482
msgid ""
"Stores `buff_len` bytes of tweak component values starting with the 1MB "
"block specified by the absolute guest address (`gaddr`). `buff_len` needs to "
"be `conf_dump_storage_state_len` aligned and at least >= the "
"`conf_dump_storage_state_len` value provided by the dump uv_info data. "
"buff_user might be written to even if an error rc is returned. For instance "
"if we encounter a fault after writing the first page of data."
msgstr ""

#: ../../../virt/kvm/api.rst:5490
msgid "KVM_PV_DUMP_COMPLETE"
msgstr ""

#: ../../../virt/kvm/api.rst:5491
msgid ""
"If the subcommand succeeds it completes the dump process and lets "
"KVM_PV_DUMP_INIT be called again."
msgstr ""

#: ../../../virt/kvm/api.rst:5494
msgid ""
"On success `conf_dump_finalize_len` bytes of completion data will be stored "
"to the `buff_addr`. The completion data contains a key derivation seed, IV, "
"tweak nonce and encryption keys as well as an authentication tag all of "
"which are needed to decrypt the dump at a later time."
msgstr ""

#: ../../../virt/kvm/api.rst:5500
msgid "KVM_PV_ASYNC_CLEANUP_PREPARE"
msgstr ""

#: ../../../virt/kvm/api.rst:5501 ../../../virt/kvm/api.rst:5518
msgid "KVM_CAP_S390_PROTECTED_ASYNC_DISABLE"
msgstr ""

#: ../../../virt/kvm/api.rst:5503
msgid ""
"Prepare the current protected VM for asynchronous teardown. Most resources "
"used by the current protected VM will be set aside for a subsequent "
"asynchronous teardown. The current protected VM will then resume execution "
"immediately as non-protected. There can be at most one protected VM prepared "
"for asynchronous teardown at any time. If a protected VM had already been "
"prepared for teardown without subsequently calling "
"KVM_PV_ASYNC_CLEANUP_PERFORM, this call will fail. In that case, the "
"userspace process should issue a normal KVM_PV_DISABLE. The resources set "
"aside with this call will need to be cleaned up with a subsequent call to "
"KVM_PV_ASYNC_CLEANUP_PERFORM or KVM_PV_DISABLE, otherwise they will be "
"cleaned up when KVM terminates. KVM_PV_ASYNC_CLEANUP_PREPARE can be called "
"again as soon as cleanup starts, i.e. before KVM_PV_ASYNC_CLEANUP_PERFORM "
"finishes."
msgstr ""

#: ../../../virt/kvm/api.rst:5517
msgid "KVM_PV_ASYNC_CLEANUP_PERFORM"
msgstr ""

#: ../../../virt/kvm/api.rst:5520
msgid ""
"Tear down the protected VM previously prepared for teardown with "
"KVM_PV_ASYNC_CLEANUP_PREPARE. The resources that had been set aside will be "
"freed during the execution of this command. This PV command should ideally "
"be issued by userspace from a separate thread. If a fatal signal is received "
"(or the process terminates naturally), the command will terminate "
"immediately without completing, and the normal KVM shutdown procedure will "
"take care of cleaning up all remaining protected VMs, including the ones "
"whose teardown was interrupted by process termination."
msgstr ""

#: ../../../virt/kvm/api.rst:5531
msgid "4.126 KVM_XEN_HVM_SET_ATTR"
msgstr ""

#: ../../../virt/kvm/api.rst:5533 ../../../virt/kvm/api.rst:5656
#: ../../../virt/kvm/api.rst:5669 ../../../virt/kvm/api.rst:5783
msgid "KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_SHARED_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:5536 ../../../virt/kvm/api.rst:5659
msgid "struct kvm_xen_hvm_attr"
msgstr ""

#: ../../../virt/kvm/api.rst:5574 ../../../virt/kvm/api.rst:5701
msgid "type values:"
msgstr ""

#: ../../../virt/kvm/api.rst:5576
msgid "KVM_XEN_ATTR_TYPE_LONG_MODE"
msgstr ""

#: ../../../virt/kvm/api.rst:5577
msgid ""
"Sets the ABI mode of the VM to 32-bit or 64-bit (long mode). This determines "
"the layout of the shared_info page exposed to the VM."
msgstr ""

#: ../../../virt/kvm/api.rst:5580
msgid "KVM_XEN_ATTR_TYPE_SHARED_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:5581
msgid ""
"Sets the guest physical frame number at which the Xen shared_info page "
"resides. Note that although Xen places vcpu_info for the first 32 vCPUs in "
"the shared_info page, KVM does not automatically do so and instead requires "
"that KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO or "
"KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO_HVA be used explicitly even when the "
"vcpu_info for a given vCPU resides at the \"default\" location in the "
"shared_info page. This is because KVM may not be aware of the Xen CPU id "
"which is used as the index into the vcpu_info[] array, so may know the "
"correct default location."
msgstr ""

#: ../../../virt/kvm/api.rst:5591
msgid ""
"Note that the shared_info page may be constantly written to by KVM; it "
"contains the event channel bitmap used to deliver interrupts to a Xen guest, "
"amongst other things. It is exempt from dirty tracking mechanisms — KVM will "
"not explicitly mark the page as dirty each time an event channel interrupt "
"is delivered to the guest! Thus, userspace should always assume that the "
"designated GFN is dirty if any vCPU has been running or any event channel "
"interrupts can be routed to the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:5600
msgid ""
"Setting the gfn to KVM_XEN_INVALID_GFN will disable the shared_info page."
msgstr ""

#: ../../../virt/kvm/api.rst:5603
msgid "KVM_XEN_ATTR_TYPE_SHARED_INFO_HVA"
msgstr ""

#: ../../../virt/kvm/api.rst:5604
msgid ""
"If the KVM_XEN_HVM_CONFIG_SHARED_INFO_HVA flag is also set in the Xen "
"capabilities, then this attribute may be used to set the userspace address "
"at which the shared_info page resides, which will always be fixed in the VMM "
"regardless of where it is mapped in guest physical address space. This "
"attribute should be used in preference to KVM_XEN_ATTR_TYPE_SHARED_INFO as "
"it avoids unnecessary invalidation of an internal cache when the page is re-"
"mapped in guest physical address space."
msgstr ""

#: ../../../virt/kvm/api.rst:5613
msgid "Setting the hva to zero will disable the shared_info page."
msgstr ""

#: ../../../virt/kvm/api.rst:5615
msgid "KVM_XEN_ATTR_TYPE_UPCALL_VECTOR"
msgstr ""

#: ../../../virt/kvm/api.rst:5616
msgid ""
"Sets the exception vector used to deliver Xen event channel upcalls. This is "
"the HVM-wide vector injected directly by the hypervisor (not through the "
"local APIC), typically configured by a guest via HVM_PARAM_CALLBACK_IRQ. "
"This can be disabled again (e.g. for guest SHUTDOWN_soft_reset) by setting "
"it to zero."
msgstr ""

#: ../../../virt/kvm/api.rst:5622
msgid "KVM_XEN_ATTR_TYPE_EVTCHN"
msgstr ""

#: ../../../virt/kvm/api.rst:5623
msgid ""
"This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates support "
"for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It configures an outbound port "
"number for interception of EVTCHNOP_send requests from the guest. A given "
"sending port number may be directed back to a specified vCPU (by APIC ID) / "
"port / priority on the guest, or to trigger events on an eventfd. The vCPU "
"and priority can be changed by setting KVM_XEN_EVTCHN_UPDATE in a subsequent "
"call, but other fields cannot change for a given sending port. A port "
"mapping is removed by using KVM_XEN_EVTCHN_DEASSIGN in the flags field. "
"Passing KVM_XEN_EVTCHN_RESET in the flags field removes all interception of "
"outbound event channels. The values of the flags field are mutually "
"exclusive and cannot be combined as a bitmask."
msgstr ""

#: ../../../virt/kvm/api.rst:5636
msgid "KVM_XEN_ATTR_TYPE_XEN_VERSION"
msgstr ""

#: ../../../virt/kvm/api.rst:5637
msgid ""
"This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates support "
"for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It configures the 32-bit "
"version code returned to the guest when it invokes the XENVER_version call; "
"typically (XEN_MAJOR << 16 | XEN_MINOR). PV Xen guests will often use this "
"to as a dummy hypercall to trigger event channel delivery, so responding "
"within the kernel without exiting to userspace is beneficial."
msgstr ""

#: ../../../virt/kvm/api.rst:5645
msgid "KVM_XEN_ATTR_TYPE_RUNSTATE_UPDATE_FLAG"
msgstr ""

#: ../../../virt/kvm/api.rst:5646
msgid ""
"This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates support "
"for KVM_XEN_HVM_CONFIG_RUNSTATE_UPDATE_FLAG. It enables the "
"XEN_RUNSTATE_UPDATE flag which allows guest vCPUs to safely read other "
"vCPUs' vcpu_runstate_info. Xen guests enable this feature via the "
"VMASST_TYPE_runstate_update_flag of the HYPERVISOR_vm_assist hypercall."
msgstr ""

#: ../../../virt/kvm/api.rst:5654
msgid "4.127 KVM_XEN_HVM_GET_ATTR"
msgstr ""

#: ../../../virt/kvm/api.rst:5662
msgid ""
"Allows Xen VM attributes to be read. For the structure and types, see "
"KVM_XEN_HVM_SET_ATTR above. The KVM_XEN_ATTR_TYPE_EVTCHN attribute cannot be "
"read."
msgstr ""

#: ../../../virt/kvm/api.rst:5667
msgid "4.128 KVM_XEN_VCPU_SET_ATTR"
msgstr ""

#: ../../../virt/kvm/api.rst:5672 ../../../virt/kvm/api.rst:5786
msgid "struct kvm_xen_vcpu_attr"
msgstr ""

#: ../../../virt/kvm/api.rst:5703
msgid "KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:5704
msgid ""
"Sets the guest physical address of the vcpu_info for a given vCPU. As with "
"the shared_info page for the VM, the corresponding page may be dirtied at "
"any time if event channel interrupt delivery is enabled, so userspace should "
"always assume that the page is dirty without relying on dirty logging. "
"Setting the gpa to KVM_XEN_INVALID_GPA will disable the vcpu_info."
msgstr ""

#: ../../../virt/kvm/api.rst:5711
msgid "KVM_XEN_VCPU_ATTR_TYPE_VCPU_INFO_HVA"
msgstr ""

#: ../../../virt/kvm/api.rst:5712
msgid ""
"If the KVM_XEN_HVM_CONFIG_SHARED_INFO_HVA flag is also set in the Xen "
"capabilities, then this attribute may be used to set the userspace address "
"of the vcpu_info for a given vCPU. It should only be used when the vcpu_info "
"resides at the \"default\" location in the shared_info page. In this case it "
"is safe to assume the userspace address will not change, because the "
"shared_info page is an overlay on guest memory and remains at a fixed host "
"address regardless of where it is mapped in guest physical address space and "
"hence unnecessary invalidation of an internal cache may be avoided if the "
"guest memory layout is modified. If the vcpu_info does not reside at the "
"\"default\" location then it is not guaranteed to remain at the same host "
"address and hence the aforementioned cache invalidation is required."
msgstr ""

#: ../../../virt/kvm/api.rst:5726
msgid "KVM_XEN_VCPU_ATTR_TYPE_VCPU_TIME_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:5727
msgid ""
"Sets the guest physical address of an additional pvclock structure for a "
"given vCPU. This is typically used for guest vsyscall support. Setting the "
"gpa to KVM_XEN_INVALID_GPA will disable the structure."
msgstr ""

#: ../../../virt/kvm/api.rst:5731
msgid "KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR"
msgstr ""

#: ../../../virt/kvm/api.rst:5732
msgid ""
"Sets the guest physical address of the vcpu_runstate_info for a given vCPU. "
"This is how a Xen guest tracks CPU state such as steal time. Setting the gpa "
"to KVM_XEN_INVALID_GPA will disable the runstate area."
msgstr ""

#: ../../../virt/kvm/api.rst:5736
msgid "KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_CURRENT"
msgstr ""

#: ../../../virt/kvm/api.rst:5737
msgid ""
"Sets the runstate (RUNSTATE_running/_runnable/_blocked/_offline) of the "
"given vCPU from the .u.runstate.state member of the structure. KVM "
"automatically accounts running and runnable time but blocked and offline "
"states are only entered explicitly."
msgstr ""

#: ../../../virt/kvm/api.rst:5742
msgid "KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_DATA"
msgstr ""

#: ../../../virt/kvm/api.rst:5743
msgid ""
"Sets all fields of the vCPU runstate data from the .u.runstate member of the "
"structure, including the current runstate. The state_entry_time must equal "
"the sum of the other four times."
msgstr ""

#: ../../../virt/kvm/api.rst:5747
msgid "KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST"
msgstr ""

#: ../../../virt/kvm/api.rst:5748
msgid ""
"This *adds* the contents of the .u.runstate members of the structure to the "
"corresponding members of the given vCPU's runstate data, thus permitting "
"atomic adjustments to the runstate times. The adjustment to the "
"state_entry_time must equal the sum of the adjustments to the other four "
"times. The state field must be set to -1, or to a valid runstate value "
"(RUNSTATE_running, RUNSTATE_runnable, RUNSTATE_blocked or RUNSTATE_offline) "
"to set the current accounted state as of the adjusted state_entry_time."
msgstr ""

#: ../../../virt/kvm/api.rst:5757
msgid "KVM_XEN_VCPU_ATTR_TYPE_VCPU_ID"
msgstr ""

#: ../../../virt/kvm/api.rst:5758
msgid ""
"This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates support "
"for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It sets the Xen vCPU ID of the "
"given vCPU, to allow timer-related VCPU operations to be intercepted by KVM."
msgstr ""

#: ../../../virt/kvm/api.rst:5763
msgid "KVM_XEN_VCPU_ATTR_TYPE_TIMER"
msgstr ""

#: ../../../virt/kvm/api.rst:5764
msgid ""
"This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates support "
"for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It sets the event channel port/"
"priority for the VIRQ_TIMER of the vCPU, as well as allowing a pending timer "
"to be saved/restored. Setting the timer port to zero disables kernel "
"handling of the singleshot timer."
msgstr ""

#: ../../../virt/kvm/api.rst:5770
msgid "KVM_XEN_VCPU_ATTR_TYPE_UPCALL_VECTOR"
msgstr ""

#: ../../../virt/kvm/api.rst:5771
msgid ""
"This attribute is available when the KVM_CAP_XEN_HVM ioctl indicates support "
"for KVM_XEN_HVM_CONFIG_EVTCHN_SEND features. It sets the per-vCPU local APIC "
"upcall vector, configured by a Xen guest with the "
"HVMOP_set_evtchn_upcall_vector hypercall. This is typically used by Windows "
"guests, and is distinct from the HVM-wide upcall vector configured with "
"HVM_PARAM_CALLBACK_IRQ. It is disabled by setting the vector to zero."
msgstr ""

#: ../../../virt/kvm/api.rst:5781
msgid "4.129 KVM_XEN_VCPU_GET_ATTR"
msgstr ""

#: ../../../virt/kvm/api.rst:5789
msgid ""
"Allows Xen vCPU attributes to be read. For the structure and types, see "
"KVM_XEN_VCPU_SET_ATTR above."
msgstr ""

#: ../../../virt/kvm/api.rst:5792
msgid ""
"The KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADJUST type may not be used with the "
"KVM_XEN_VCPU_GET_ATTR ioctl."
msgstr ""

#: ../../../virt/kvm/api.rst:5796
msgid "4.130 KVM_ARM_MTE_COPY_TAGS"
msgstr ""

#: ../../../virt/kvm/api.rst:5798
msgid "KVM_CAP_ARM_MTE"
msgstr ""

#: ../../../virt/kvm/api.rst:5801
msgid "struct kvm_arm_copy_mte_tags"
msgstr ""

#: ../../../virt/kvm/api.rst:5802
msgid ""
"number of bytes copied, < 0 on error (-EINVAL for incorrect arguments, -"
"EFAULT if memory cannot be accessed)."
msgstr ""

#: ../../../virt/kvm/api.rst:5815
msgid ""
"Copies Memory Tagging Extension (MTE) tags to/from guest tag memory. The "
"``guest_ipa`` and ``length`` fields must be ``PAGE_SIZE`` aligned. "
"``length`` must not be bigger than 2^31 - PAGE_SIZE bytes. The ``addr`` "
"field must point to a buffer which the tags will be copied to or from."
msgstr ""

#: ../../../virt/kvm/api.rst:5820
msgid ""
"``flags`` specifies the direction of copy, either ``KVM_ARM_TAGS_TO_GUEST`` "
"or ``KVM_ARM_TAGS_FROM_GUEST``."
msgstr ""

#: ../../../virt/kvm/api.rst:5823
msgid ""
"The size of the buffer to store the tags is ``(length / 16)`` bytes "
"(granules in MTE are 16 bytes long). Each byte contains a single tag value. "
"This matches the format of ``PTRACE_PEEKMTETAGS`` and ``PTRACE_POKEMTETAGS``."
msgstr ""

#: ../../../virt/kvm/api.rst:5828
msgid ""
"If an error occurs before any data is copied then a negative error code is "
"returned. If some tags have been copied before an error occurs then the "
"number of bytes successfully copied is returned. If the call completes "
"successfully then ``length`` is returned."
msgstr ""

#: ../../../virt/kvm/api.rst:5834
msgid "4.131 KVM_GET_SREGS2"
msgstr ""

#: ../../../virt/kvm/api.rst:5836 ../../../virt/kvm/api.rst:5869
msgid "KVM_CAP_SREGS2"
msgstr ""

#: ../../../virt/kvm/api.rst:5839
msgid "struct kvm_sregs2 (out)"
msgstr ""

#: ../../../virt/kvm/api.rst:5842
msgid ""
"Reads special registers from the vcpu. This ioctl (when supported) replaces "
"the KVM_GET_SREGS."
msgstr ""

#: ../../../virt/kvm/api.rst:5859
msgid "flags values for ``kvm_sregs2``:"
msgstr ""

#: ../../../virt/kvm/api.rst:5861
msgid "``KVM_SREGS2_FLAGS_PDPTRS_VALID``"
msgstr ""

#: ../../../virt/kvm/api.rst:5863
msgid "Indicates that the struct contains valid PDPTR values."
msgstr ""

#: ../../../virt/kvm/api.rst:5867
msgid "4.132 KVM_SET_SREGS2"
msgstr ""

#: ../../../virt/kvm/api.rst:5872
msgid "struct kvm_sregs2 (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:5875
msgid ""
"Writes special registers into the vcpu. See KVM_GET_SREGS2 for the data "
"structures. This ioctl (when supported) replaces the KVM_SET_SREGS."
msgstr ""

#: ../../../virt/kvm/api.rst:5880
msgid "4.133 KVM_GET_STATS_FD"
msgstr ""

#: ../../../virt/kvm/api.rst:5882
msgid "KVM_CAP_STATS_BINARY_FD"
msgstr ""

#: ../../../virt/kvm/api.rst:5886
msgid "statistics file descriptor on success, < 0 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:5891
msgid "if the fd could not be created due to lack of memory"
msgstr ""

#: ../../../virt/kvm/api.rst:5892
msgid "EMFILE"
msgstr ""

#: ../../../virt/kvm/api.rst:5892
msgid "if the number of opened files exceeds the limit"
msgstr ""

#: ../../../virt/kvm/api.rst:5895
msgid ""
"The returned file descriptor can be used to read VM/vCPU statistics data in "
"binary format. The data in the file descriptor consists of four blocks "
"organized as follows:"
msgstr ""

#: ../../../virt/kvm/api.rst:5900
msgid "Header"
msgstr ""

#: ../../../virt/kvm/api.rst:5902
msgid "id string"
msgstr ""

#: ../../../virt/kvm/api.rst:5904
msgid "Descriptors"
msgstr ""

#: ../../../virt/kvm/api.rst:5906
msgid "Stats Data"
msgstr ""

#: ../../../virt/kvm/api.rst:5909
msgid ""
"Apart from the header starting at offset 0, please be aware that it is not "
"guaranteed that the four blocks are adjacent or in the above order; the "
"offsets of the id, descriptors and data blocks are found in the header.  "
"However, all four blocks are aligned to 64 bit offsets in the file and they "
"do not overlap."
msgstr ""

#: ../../../virt/kvm/api.rst:5915
msgid ""
"All blocks except the data block are immutable.  Userspace can read them "
"only one time after retrieving the file descriptor, and then use ``pread`` "
"or ``lseek`` to read the statistics repeatedly."
msgstr ""

#: ../../../virt/kvm/api.rst:5919
msgid "All data is in system endianness."
msgstr ""

#: ../../../virt/kvm/api.rst:5921
msgid "The format of the header is as follows::"
msgstr ""

#: ../../../virt/kvm/api.rst:5932
msgid "The ``flags`` field is not used at the moment. It is always read as 0."
msgstr ""

#: ../../../virt/kvm/api.rst:5934
msgid ""
"The ``name_size`` field is the size (in byte) of the statistics name string "
"(including trailing '\\0') which is contained in the \"id string\" block and "
"appended at the end of every descriptor."
msgstr ""

#: ../../../virt/kvm/api.rst:5938
msgid ""
"The ``num_desc`` field is the number of descriptors that are included in the "
"descriptor block.  (The actual number of values in the data block may be "
"larger, since each descriptor may comprise more than one value)."
msgstr ""

#: ../../../virt/kvm/api.rst:5942
msgid ""
"The ``id_offset`` field is the offset of the id string from the start of the "
"file indicated by the file descriptor. It is a multiple of 8."
msgstr ""

#: ../../../virt/kvm/api.rst:5945
msgid ""
"The ``desc_offset`` field is the offset of the Descriptors block from the "
"start of the file indicated by the file descriptor. It is a multiple of 8."
msgstr ""

#: ../../../virt/kvm/api.rst:5948
msgid ""
"The ``data_offset`` field is the offset of the Stats Data block from the "
"start of the file indicated by the file descriptor. It is a multiple of 8."
msgstr ""

#: ../../../virt/kvm/api.rst:5951
msgid ""
"The id string block contains a string which identifies the file descriptor "
"on which KVM_GET_STATS_FD was invoked.  The size of the block, including the "
"trailing ``'\\0'``, is indicated by the ``name_size`` field in the header."
msgstr ""

#: ../../../virt/kvm/api.rst:5955
msgid ""
"The descriptors block is only needed to be read once for the lifetime of the "
"file descriptor contains a sequence of ``struct kvm_stats_desc``, each "
"followed by a string of size ``name_size``. ::"
msgstr ""

#: ../../../virt/kvm/api.rst:5993
msgid ""
"The ``flags`` field contains the type and unit of the statistics data "
"described by this descriptor. Its endianness is CPU native. The following "
"flags are supported:"
msgstr ""

#: ../../../virt/kvm/api.rst:5997
msgid "Bits 0-3 of ``flags`` encode the type:"
msgstr ""

#: ../../../virt/kvm/api.rst:5999
msgid ""
"``KVM_STATS_TYPE_CUMULATIVE`` The statistics reports a cumulative count. The "
"value of data can only be increased. Most of the counters used in KVM are of "
"this type. The corresponding ``size`` field for this type is always 1. All "
"cumulative statistics data are read/write."
msgstr ""

#: ../../../virt/kvm/api.rst:6004
msgid ""
"``KVM_STATS_TYPE_INSTANT`` The statistics reports an instantaneous value. "
"Its value can be increased or decreased. This type is usually used as a "
"measurement of some resources, like the number of dirty pages, the number of "
"large pages, etc. All instant statistics are read only. The corresponding "
"``size`` field for this type is always 1."
msgstr ""

#: ../../../virt/kvm/api.rst:6010
msgid ""
"``KVM_STATS_TYPE_PEAK`` The statistics data reports a peak value, for "
"example the maximum number of items in a hash table bucket, the longest time "
"waited and so on. The value of data can only be increased. The corresponding "
"``size`` field for this type is always 1."
msgstr ""

#: ../../../virt/kvm/api.rst:6015
msgid ""
"``KVM_STATS_TYPE_LINEAR_HIST`` The statistic is reported as a linear "
"histogram. The number of buckets is specified by the ``size`` field. The "
"size of buckets is specified by the ``hist_param`` field. The range of the "
"Nth bucket (1 <= N < ``size``) is [``hist_param``*(N-1), ``hist_param``*N), "
"while the range of the last bucket is [``hist_param``*(``size``-1), +INF). "
"(+INF means positive infinity value.)"
msgstr ""

#: ../../../virt/kvm/api.rst:6022
msgid ""
"``KVM_STATS_TYPE_LOG_HIST`` The statistic is reported as a logarithmic "
"histogram. The number of buckets is specified by the ``size`` field. The "
"range of the first bucket is [0, 1), while the range of the last bucket is "
"[pow(2, ``size``-2), +INF). Otherwise, The Nth bucket (1 < N < ``size``) "
"covers [pow(2, N-2), pow(2, N-1))."
msgstr ""

#: ../../../virt/kvm/api.rst:6029
msgid "Bits 4-7 of ``flags`` encode the unit:"
msgstr ""

#: ../../../virt/kvm/api.rst:6031
msgid ""
"``KVM_STATS_UNIT_NONE`` There is no unit for the value of statistics data. "
"This usually means that the value is a simple counter of an event."
msgstr ""

#: ../../../virt/kvm/api.rst:6034
msgid ""
"``KVM_STATS_UNIT_BYTES`` It indicates that the statistics data is used to "
"measure memory size, in the unit of Byte, KiByte, MiByte, GiByte, etc. The "
"unit of the data is determined by the ``exponent`` field in the descriptor."
msgstr ""

#: ../../../virt/kvm/api.rst:6038
msgid ""
"``KVM_STATS_UNIT_SECONDS`` It indicates that the statistics data is used to "
"measure time or latency."
msgstr ""

#: ../../../virt/kvm/api.rst:6040
msgid ""
"``KVM_STATS_UNIT_CYCLES`` It indicates that the statistics data is used to "
"measure CPU clock cycles."
msgstr ""

#: ../../../virt/kvm/api.rst:6042
msgid ""
"``KVM_STATS_UNIT_BOOLEAN`` It indicates that the statistic will always be "
"either 0 or 1.  Boolean statistics of \"peak\" type will never go back from "
"1 to 0.  Boolean statistics can be linear histograms (with two buckets) but "
"not logarithmic histograms."
msgstr ""

#: ../../../virt/kvm/api.rst:6048
msgid ""
"Note that, in the case of histograms, the unit applies to the bucket ranges, "
"while the bucket value indicates how many samples fell in the bucket's range."
msgstr ""

#: ../../../virt/kvm/api.rst:6052
msgid ""
"Bits 8-11 of ``flags``, together with ``exponent``, encode the scale of the "
"unit:"
msgstr ""

#: ../../../virt/kvm/api.rst:6055
msgid ""
"``KVM_STATS_BASE_POW10`` The scale is based on power of 10. It is used for "
"measurement of time and CPU clock cycles.  For example, an exponent of -9 "
"can be used with ``KVM_STATS_UNIT_SECONDS`` to express that the unit is "
"nanoseconds."
msgstr ""

#: ../../../virt/kvm/api.rst:6059
msgid ""
"``KVM_STATS_BASE_POW2`` The scale is based on power of 2. It is used for "
"measurement of memory size. For example, an exponent of 20 can be used with "
"``KVM_STATS_UNIT_BYTES`` to express that the unit is MiB."
msgstr ""

#: ../../../virt/kvm/api.rst:6064
msgid ""
"The ``size`` field is the number of values of this statistics data. Its "
"value is usually 1 for most of simple statistics. 1 means it contains an "
"unsigned 64bit data."
msgstr ""

#: ../../../virt/kvm/api.rst:6068
msgid ""
"The ``offset`` field is the offset from the start of Data Block to the start "
"of the corresponding statistics data."
msgstr ""

#: ../../../virt/kvm/api.rst:6071
msgid ""
"The ``bucket_size`` field is used as a parameter for histogram statistics "
"data. It is only used by linear histogram statistics data, specifying the "
"size of a bucket in the unit expressed by bits 4-11 of ``flags`` together "
"with ``exponent``."
msgstr ""

#: ../../../virt/kvm/api.rst:6075
msgid ""
"The ``name`` field is the name string of the statistics data. The name "
"string starts at the end of ``struct kvm_stats_desc``.  The maximum length "
"including the trailing ``'\\0'``, is indicated by ``name_size`` in the "
"header."
msgstr ""

#: ../../../virt/kvm/api.rst:6079
msgid ""
"The Stats Data block contains an array of 64-bit values in the same order as "
"the descriptors in Descriptors block."
msgstr ""

#: ../../../virt/kvm/api.rst:6083
msgid "4.134 KVM_GET_XSAVE2"
msgstr ""

#: ../../../virt/kvm/api.rst:6085
msgid "KVM_CAP_XSAVE2"
msgstr ""

#: ../../../virt/kvm/api.rst:6099
msgid ""
"This ioctl would copy current vcpu's xsave struct to the userspace. It "
"copies as many bytes as are returned by KVM_CHECK_EXTENSION(KVM_CAP_XSAVE2) "
"when invoked on the vm file descriptor. The size value returned by "
"KVM_CHECK_EXTENSION(KVM_CAP_XSAVE2) will always be at least 4096. Currently, "
"it is only greater than 4096 if a dynamic feature has been enabled with "
"``arch_prctl()``, but this may change in the future."
msgstr ""

#: ../../../virt/kvm/api.rst:6110
msgid "4.135 KVM_XEN_HVM_EVTCHN_SEND"
msgstr ""

#: ../../../virt/kvm/api.rst:6112
msgid "KVM_CAP_XEN_HVM / KVM_XEN_HVM_CONFIG_EVTCHN_SEND"
msgstr ""

#: ../../../virt/kvm/api.rst:6115
msgid "struct kvm_irq_routing_xen_evtchn"
msgstr ""

#: ../../../virt/kvm/api.rst:6127
msgid ""
"This ioctl injects an event channel interrupt directly to the guest vCPU."
msgstr ""

#: ../../../virt/kvm/api.rst:6130
msgid "4.136 KVM_S390_PV_CPU_COMMAND"
msgstr ""

#: ../../../virt/kvm/api.rst:6138
msgid ""
"This ioctl closely mirrors `KVM_S390_PV_COMMAND` but handles requests for "
"vcpus. It re-uses the kvm_s390_pv_dmp struct and hence also shares the "
"command ids."
msgstr ""

#: ../../../virt/kvm/api.rst:6142
msgid "**command:**"
msgstr ""

#: ../../../virt/kvm/api.rst:6145
msgid ""
"Presents an API that provides calls which facilitate dumping a vcpu of a "
"protected VM."
msgstr ""

#: ../../../virt/kvm/api.rst:6148
msgid "**subcommand:**"
msgstr ""

#: ../../../virt/kvm/api.rst:6150
msgid "KVM_PV_DUMP_CPU"
msgstr ""

#: ../../../virt/kvm/api.rst:6151
msgid ""
"Provides encrypted dump data like register values. The length of the "
"returned data is provided by uv_info.guest_cpu_stor_len."
msgstr ""

#: ../../../virt/kvm/api.rst:6155
msgid "4.137 KVM_S390_ZPCI_OP"
msgstr ""

#: ../../../virt/kvm/api.rst:6157
msgid "KVM_CAP_S390_ZPCI_OP"
msgstr ""

#: ../../../virt/kvm/api.rst:6160
msgid "struct kvm_s390_zpci_op (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:6161 ../../../virt/kvm/api.rst:6347
msgid "0 on success, <0 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:6163
msgid ""
"Used to manage hardware-assisted virtualization features for zPCI devices."
msgstr ""

#: ../../../virt/kvm/api.rst:6187
msgid ""
"The type of operation is specified in the \"op\" field. "
"KVM_S390_ZPCIOP_REG_AEN is used to register the VM for adapter event "
"notification interpretation, which will allow firmware delivery of adapter "
"events directly to the vm, with KVM providing a backup delivery mechanism; "
"KVM_S390_ZPCIOP_DEREG_AEN is used to subsequently disable interpretation of "
"adapter event notifications."
msgstr ""

#: ../../../virt/kvm/api.rst:6194
msgid ""
"The target zPCI function must also be specified via the \"fh\" field.  For "
"the KVM_S390_ZPCIOP_REG_AEN operation, additional information to establish "
"firmware delivery must be provided via the \"reg_aen\" struct."
msgstr ""

#: ../../../virt/kvm/api.rst:6198
msgid ""
"The \"pad\" and \"reserved\" fields may be used for future extensions and "
"should be set to 0s by userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:6202
msgid "4.138 KVM_ARM_SET_COUNTER_OFFSET"
msgstr ""

#: ../../../virt/kvm/api.rst:6204
msgid "KVM_CAP_COUNTER_OFFSET"
msgstr ""

#: ../../../virt/kvm/api.rst:6207
msgid "struct kvm_arm_counter_offset (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:6210
msgid ""
"This capability indicates that userspace is able to apply a single VM-wide "
"offset to both the virtual and physical counters as viewed by the guest "
"using the KVM_ARM_SET_CNT_OFFSET ioctl and the following data structure:"
msgstr ""

#: ../../../virt/kvm/api.rst:6221
msgid ""
"The offset describes a number of counter cycles that are subtracted from "
"both virtual and physical counter views (similar to the effects of the "
"CNTVOFF_EL2 and CNTPOFF_EL2 system registers, but only global). The offset "
"always applies to all vcpus (already created or created after this ioctl) "
"for this VM."
msgstr ""

#: ../../../virt/kvm/api.rst:6227
msgid ""
"It is userspace's responsibility to compute the offset based, for example, "
"on previous values of the guest counters."
msgstr ""

#: ../../../virt/kvm/api.rst:6230
msgid ""
"Any value other than 0 for the \"reserved\" field may result in an error (-"
"EINVAL) being returned. This ioctl can also return -EBUSY if any vcpu ioctl "
"is issued concurrently."
msgstr ""

#: ../../../virt/kvm/api.rst:6234
msgid ""
"Note that using this ioctl results in KVM ignoring subsequent userspace "
"writes to the CNTVCT_EL0 and CNTPCT_EL0 registers using the SET_ONE_REG "
"interface. No error will be returned, but the resulting offset will not be "
"applied."
msgstr ""

#: ../../../virt/kvm/api.rst:6242
msgid "4.139 KVM_ARM_GET_REG_WRITABLE_MASKS"
msgstr ""

#: ../../../virt/kvm/api.rst:6244
msgid "KVM_CAP_ARM_SUPPORTED_REG_MASK_RANGES"
msgstr ""

#: ../../../virt/kvm/api.rst:6247
msgid "struct reg_mask_range (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:6262
msgid ""
"This ioctl copies the writable masks for a selected range of registers to "
"userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:6265
msgid ""
"The ``addr`` field is a pointer to the destination array where KVM copies "
"the writable masks."
msgstr ""

#: ../../../virt/kvm/api.rst:6268
msgid ""
"The ``range`` field indicates the requested range of registers. "
"``KVM_CHECK_EXTENSION`` for the ``KVM_CAP_ARM_SUPPORTED_REG_MASK_RANGES`` "
"capability returns the supported ranges, expressed as a set of flags. Each "
"flag's bit index represents a possible value for the ``range`` field. All "
"other values are reserved for future use and KVM may return an error."
msgstr ""

#: ../../../virt/kvm/api.rst:6274
msgid ""
"The ``reserved[13]`` array is reserved for future use and should be 0, or "
"KVM may return an error."
msgstr ""

#: ../../../virt/kvm/api.rst:6278
msgid "KVM_ARM_FEATURE_ID_RANGE (0)"
msgstr ""

#: ../../../virt/kvm/api.rst:6280
msgid ""
"The Feature ID range is defined as the AArch64 System register space with "
"op0==3, op1=={0, 1, 3}, CRn==0, CRm=={0-7}, op2=={0-7}."
msgstr ""

#: ../../../virt/kvm/api.rst:6283
msgid ""
"The mask returned array pointed to by ``addr`` is indexed by the macro "
"``ARM64_FEATURE_ID_RANGE_IDX(op0, op1, crn, crm, op2)``, allowing userspace "
"to know what fields can be changed for the system register described by "
"``op0, op1, crn, crm, op2``. KVM rejects ID register values that describe a "
"superset of the features supported by the system."
msgstr ""

#: ../../../virt/kvm/api.rst:6290
msgid "4.140 KVM_SET_USER_MEMORY_REGION2"
msgstr ""

#: ../../../virt/kvm/api.rst:6292
msgid "KVM_CAP_USER_MEMORY2"
msgstr ""

#: ../../../virt/kvm/api.rst:6295
msgid "struct kvm_userspace_memory_region2 (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:6298
msgid ""
"KVM_SET_USER_MEMORY_REGION2 is an extension to KVM_SET_USER_MEMORY_REGION "
"that allows mapping guest_memfd memory into a guest.  All fields shared with "
"KVM_SET_USER_MEMORY_REGION identically.  Userspace can set "
"KVM_MEM_GUEST_MEMFD in flags to have KVM bind the memory region to a given "
"guest_memfd range of [guest_memfd_offset, guest_memfd_offset + "
"memory_size].  The target guest_memfd must point at a file created via "
"KVM_CREATE_GUEST_MEMFD on the current VM, and the target range must not be "
"bound to any other memory region.  All standard bounds checks apply (use "
"common sense)."
msgstr ""

#: ../../../virt/kvm/api.rst:6321
msgid ""
"A KVM_MEM_GUEST_MEMFD region _must_ have a valid guest_memfd (private "
"memory) and userspace_addr (shared memory).  However, \"valid\" for "
"userspace_addr simply means that the address itself must be a legal "
"userspace address.  The backing mapping for userspace_addr is not required "
"to be valid/populated at the time of KVM_SET_USER_MEMORY_REGION2, e.g. "
"shared memory can be lazily mapped/allocated on-demand."
msgstr ""

#: ../../../virt/kvm/api.rst:6328
msgid ""
"When mapping a gfn into the guest, KVM selects shared vs. private, i.e "
"consumes userspace_addr vs. guest_memfd, based on the gfn's "
"KVM_MEMORY_ATTRIBUTE_PRIVATE state.  At VM creation time, all memory is "
"shared, i.e. the PRIVATE attribute is '0' for all gfns.  Userspace can "
"control whether memory is shared/private by toggling "
"KVM_MEMORY_ATTRIBUTE_PRIVATE via KVM_SET_MEMORY_ATTRIBUTES as needed."
msgstr ""

#: ../../../virt/kvm/api.rst:6337
msgid ""
"Returns -EINVAL if the VM has the KVM_VM_S390_UCONTROL flag set. Returns -"
"EINVAL if called on a protected VM."
msgstr ""

#: ../../../virt/kvm/api.rst:6341
msgid "4.141 KVM_SET_MEMORY_ATTRIBUTES"
msgstr ""

#: ../../../virt/kvm/api.rst:6343
msgid "KVM_CAP_MEMORY_ATTRIBUTES"
msgstr ""

#: ../../../virt/kvm/api.rst:6346
msgid "struct kvm_memory_attributes (in)"
msgstr ""

#: ../../../virt/kvm/api.rst:6349
msgid ""
"KVM_SET_MEMORY_ATTRIBUTES allows userspace to set memory attributes for a "
"range of guest physical memory."
msgstr ""

#: ../../../virt/kvm/api.rst:6363
msgid ""
"The address and size must be page aligned.  The supported attributes can be "
"retrieved via ioctl(KVM_CHECK_EXTENSION) on KVM_CAP_MEMORY_ATTRIBUTES.  If "
"executed on a VM, KVM_CAP_MEMORY_ATTRIBUTES precisely returns the attributes "
"supported by that VM.  If executed at system scope, "
"KVM_CAP_MEMORY_ATTRIBUTES returns all attributes supported by KVM.  The only "
"attribute defined at this time is KVM_MEMORY_ATTRIBUTE_PRIVATE, which marks "
"the associated gfn as being guest private memory."
msgstr ""

#: ../../../virt/kvm/api.rst:6371
msgid ""
"Note, there is no \"get\" API.  Userspace is responsible for explicitly "
"tracking the state of a gfn/page as needed."
msgstr ""

#: ../../../virt/kvm/api.rst:6374
msgid "The \"flags\" field is reserved for future extensions and must be '0'."
msgstr ""

#: ../../../virt/kvm/api.rst:6377
msgid "4.142 KVM_CREATE_GUEST_MEMFD"
msgstr ""

#: ../../../virt/kvm/api.rst:6379
msgid "KVM_CAP_GUEST_MEMFD"
msgstr ""

#: ../../../virt/kvm/api.rst:6382
msgid "struct kvm_create_guest_memfd(in)"
msgstr ""

#: ../../../virt/kvm/api.rst:6383
msgid "A file descriptor on success, <0 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:6385
msgid ""
"KVM_CREATE_GUEST_MEMFD creates an anonymous file and returns a file "
"descriptor that refers to it.  guest_memfd files are roughly analogous to "
"files created via memfd_create(), e.g. guest_memfd files live in RAM, have "
"volatile storage, and are automatically released when the last reference is "
"dropped.  Unlike \"regular\" memfd_create() files, guest_memfd files are "
"bound to their owning virtual machine (see below), cannot be mapped, read, "
"or written by userspace, and cannot be resized  (guest_memfd files do "
"however support PUNCH_HOLE)."
msgstr ""

#: ../../../virt/kvm/api.rst:6401
msgid ""
"Conceptually, the inode backing a guest_memfd file represents physical "
"memory, i.e. is coupled to the virtual machine as a thing, not to a \"struct "
"kvm\".  The file itself, which is bound to a \"struct kvm\", is that "
"instance's view of the underlying memory, e.g. effectively provides the "
"translation of guest addresses to host memory.  This allows for use cases "
"where multiple KVM structures are used to manage a single virtual machine, e."
"g. when performing intrahost migration of a virtual machine."
msgstr ""

#: ../../../virt/kvm/api.rst:6409
msgid ""
"KVM currently only supports mapping guest_memfd via "
"KVM_SET_USER_MEMORY_REGION2, and more specifically via the guest_memfd and "
"guest_memfd_offset fields in \"struct kvm_userspace_memory_region2\", where "
"guest_memfd_offset is the offset into the guest_memfd instance.  For a given "
"guest_memfd file, there can be at most one mapping per page, i.e. binding "
"multiple memory regions to a single guest_memfd range is not allowed (any "
"number of memory regions can be bound to a single guest_memfd file, but the "
"bound ranges must not overlap)."
msgstr ""

#: ../../../virt/kvm/api.rst:6417
msgid "See KVM_SET_USER_MEMORY_REGION2 for additional details."
msgstr ""

#: ../../../virt/kvm/api.rst:6420
msgid "4.143 KVM_PRE_FAULT_MEMORY"
msgstr ""

#: ../../../virt/kvm/api.rst:6422
msgid "KVM_CAP_PRE_FAULT_MEMORY"
msgstr ""

#: ../../../virt/kvm/api.rst:6425
msgid "struct kvm_pre_fault_memory (in/out)"
msgstr ""

#: ../../../virt/kvm/api.rst:6426
msgid "0 if at least one page is processed, < 0 on error"
msgstr ""

#: ../../../virt/kvm/api.rst:6431
msgid ""
"The specified `gpa` and `size` were invalid (e.g. not page aligned, causes "
"an overflow, or size is zero)."
msgstr ""

#: ../../../virt/kvm/api.rst:6433
msgid "The specified `gpa` is outside defined memslots."
msgstr ""

#: ../../../virt/kvm/api.rst:6434
msgid "An unmasked signal is pending and no page was processed."
msgstr ""

#: ../../../virt/kvm/api.rst:6435
msgid "The parameter address was invalid."
msgstr ""

#: ../../../virt/kvm/api.rst:6436
msgid "EOPNOTSUPP"
msgstr ""

#: ../../../virt/kvm/api.rst:6436
msgid ""
"Mapping memory for a GPA is unsupported by the hypervisor, and/or for the "
"current vCPU state/mode."
msgstr ""

#: ../../../virt/kvm/api.rst:6438
msgid "EIO"
msgstr ""

#: ../../../virt/kvm/api.rst:6438
msgid "unexpected error conditions (also causes a WARN)"
msgstr ""

#: ../../../virt/kvm/api.rst:6452
msgid ""
"KVM_PRE_FAULT_MEMORY populates KVM's stage-2 page tables used to map memory "
"for the current vCPU state.  KVM maps memory as if the vCPU generated a "
"stage-2 read page fault, e.g. faults in memory as needed, but doesn't break "
"CoW.  However, KVM does not mark any newly created stage-2 PTE as Accessed."
msgstr ""

#: ../../../virt/kvm/api.rst:6457
msgid ""
"In the case of confidential VM types where there is an initial set up of "
"private guest memory before the guest is 'finalized'/measured, this ioctl "
"should only be issued after completing all the necessary setup to put the "
"guest into a 'finalized' state so that the above semantics can be reliably "
"ensured."
msgstr ""

#: ../../../virt/kvm/api.rst:6463
msgid ""
"In some cases, multiple vCPUs might share the page tables.  In this case, "
"the ioctl can be called in parallel."
msgstr ""

#: ../../../virt/kvm/api.rst:6466
msgid ""
"When the ioctl returns, the input values are updated to point to the "
"remaining range.  If `size` > 0 on return, the caller can just issue the "
"ioctl again with the same `struct kvm_map_memory` argument."
msgstr ""

#: ../../../virt/kvm/api.rst:6470
msgid ""
"Shadow page tables cannot support this ioctl because they are indexed by "
"virtual address or nested guest physical address. Calling this ioctl when "
"the guest is using shadow page tables (for example because it is running a "
"nested guest with nested page tables) will fail with `EOPNOTSUPP` even if "
"`KVM_CHECK_EXTENSION` reports the capability to be present."
msgstr ""

#: ../../../virt/kvm/api.rst:6477
msgid "`flags` must currently be zero."
msgstr ""

#: ../../../virt/kvm/api.rst:6483
msgid "5. The kvm_run structure"
msgstr ""

#: ../../../virt/kvm/api.rst:6485
msgid ""
"Application code obtains a pointer to the kvm_run structure by mmap()ing a "
"vcpu fd.  From that point, application code can control execution by "
"changing fields in kvm_run prior to calling the KVM_RUN ioctl, and obtain "
"information about the reason KVM_RUN returned by looking up structure "
"members."
msgstr ""

#: ../../../virt/kvm/api.rst:6497
msgid ""
"Request that KVM_RUN return when it becomes possible to inject external "
"interrupts into the guest.  Useful in conjunction with KVM_INTERRUPT."
msgstr ""

#: ../../../virt/kvm/api.rst:6504
msgid ""
"This field is polled once when KVM_RUN starts; if non-zero, KVM_RUN exits "
"immediately, returning -EINTR.  In the common scenario where a signal is "
"used to \"kick\" a VCPU out of KVM_RUN, this field can be used to avoid "
"usage of KVM_SET_SIGNAL_MASK, which has worse scalability. Rather than "
"blocking the signal outside KVM_RUN, userspace can set up a signal handler "
"that sets run->immediate_exit to a non-zero value."
msgstr ""

#: ../../../virt/kvm/api.rst:6511
msgid "This field is ignored if KVM_CAP_IMMEDIATE_EXIT is not available."
msgstr ""

#: ../../../virt/kvm/api.rst:6520
msgid ""
"When KVM_RUN has returned successfully (return value 0), this informs "
"application code why KVM_RUN has returned.  Allowable values for this field "
"are detailed below."
msgstr ""

#: ../../../virt/kvm/api.rst:6528
msgid ""
"If request_interrupt_window has been specified, this field indicates an "
"interrupt can be injected now with KVM_INTERRUPT."
msgstr ""

#: ../../../virt/kvm/api.rst:6535
msgid ""
"The value of the current interrupt flag.  Only valid if in-kernel local APIC "
"is not used."
msgstr ""

#: ../../../virt/kvm/api.rst:6542
msgid ""
"More architecture-specific flags detailing state of the VCPU that may affect "
"the device's behavior. Current defined flags::"
msgstr ""

#: ../../../virt/kvm/api.rst:6560
msgid ""
"The value of the cr8 register.  Only valid if in-kernel local APIC is not "
"used.  Both input and output."
msgstr ""

#: ../../../virt/kvm/api.rst:6567
msgid ""
"The value of the APIC BASE msr.  Only valid if in-kernel local APIC is not "
"used.  Both input and output."
msgstr ""

#: ../../../virt/kvm/api.rst:6578
msgid ""
"If exit_reason is KVM_EXIT_UNKNOWN, the vcpu has exited due to unknown "
"reasons.  Further architecture-specific information is available in "
"hardware_exit_reason."
msgstr ""

#: ../../../virt/kvm/api.rst:6590
msgid ""
"If exit_reason is KVM_EXIT_FAIL_ENTRY, the vcpu could not be run due to "
"unknown reasons.  Further architecture-specific information is available in "
"hardware_entry_failure_reason."
msgstr ""

#: ../../../virt/kvm/api.rst:6602
msgid "Unused."
msgstr ""

#: ../../../virt/kvm/api.rst:6617
msgid ""
"If exit_reason is KVM_EXIT_IO, then the vcpu has executed a port I/O "
"instruction which could not be satisfied by kvm. data_offset describes where "
"the data is located (KVM_EXIT_IO_OUT) or where kvm expects application code "
"to place the data for the next KVM_RUN invocation (KVM_EXIT_IO_IN).  Data "
"format is a packed array."
msgstr ""

#: ../../../virt/kvm/api.rst:6630
msgid ""
"If the exit_reason is KVM_EXIT_DEBUG, then a vcpu is processing a debug "
"event for which architecture specific information is returned."
msgstr ""

#: ../../../virt/kvm/api.rst:6643
msgid ""
"If exit_reason is KVM_EXIT_MMIO, then the vcpu has executed a memory-mapped "
"I/O instruction which could not be satisfied by kvm.  The 'data' member "
"contains the written data if 'is_write' is true, and should be filled by "
"application code otherwise."
msgstr ""

#: ../../../virt/kvm/api.rst:6648
msgid ""
"The 'data' member contains, in its first 'len' bytes, the value as it would "
"appear if the VCPU performed a load or store of the appropriate width "
"directly to the byte array."
msgstr ""

#: ../../../virt/kvm/api.rst:6654
msgid ""
"For KVM_EXIT_IO, KVM_EXIT_MMIO, KVM_EXIT_OSI, KVM_EXIT_PAPR, KVM_EXIT_XEN, "
"KVM_EXIT_EPR, KVM_EXIT_HYPERCALL, KVM_EXIT_TDX, KVM_EXIT_X86_RDMSR and "
"KVM_EXIT_X86_WRMSR the corresponding operations are complete (and guest "
"state is consistent) only after userspace has re-entered the kernel with "
"KVM_RUN.  The kernel side will first finish incomplete operations and then "
"check for pending signals."
msgstr ""

#: ../../../virt/kvm/api.rst:6661
msgid ""
"The pending state of the operation is not preserved in state which is "
"visible to userspace, thus userspace should ensure that the operation is "
"completed before performing a live migration.  Userspace can re-enter the "
"guest with an unmasked signal pending or with the immediate_exit field set "
"to complete pending operations without allowing any further instructions to "
"be executed."
msgstr ""

#: ../../../virt/kvm/api.rst:6679
msgid ""
"It is strongly recommended that userspace use ``KVM_EXIT_IO`` (x86) or "
"``KVM_EXIT_MMIO`` (all except s390) to implement functionality that requires "
"a guest to interact with host userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:6683
msgid "KVM_EXIT_IO is significantly faster than KVM_EXIT_MMIO."
msgstr ""

#: ../../../virt/kvm/api.rst:6688
msgid ""
"SMCCC exits can be enabled depending on the configuration of the SMCCC "
"filter. See the Documentation/virt/kvm/devices/vm.rst "
"``KVM_ARM_SMCCC_FILTER`` for more details."
msgstr ""

#: ../../../virt/kvm/api.rst:6692
msgid ""
"``nr`` contains the function ID of the guest's SMCCC call. Userspace is "
"expected to use the ``KVM_GET_ONE_REG`` ioctl to retrieve the call "
"parameters from the vCPU's GPRs."
msgstr ""

#: ../../../virt/kvm/api.rst:6696
msgid "Definition of ``flags``:"
msgstr ""

#: ../../../virt/kvm/api.rst:6697
msgid ""
"``KVM_HYPERCALL_EXIT_SMC``: Indicates that the guest used the SMC conduit to "
"initiate the SMCCC call. If this bit is 0 then the guest used the HVC "
"conduit for the SMCCC call."
msgstr ""

#: ../../../virt/kvm/api.rst:6701
msgid ""
"``KVM_HYPERCALL_EXIT_16BIT``: Indicates that the guest used a 16bit "
"instruction to initiate the SMCCC call. If this bit is 0 then the guest used "
"a 32bit instruction. An AArch64 guest always has this bit set to 0."
msgstr ""

#: ../../../virt/kvm/api.rst:6706
msgid ""
"At the point of exit, PC points to the instruction immediately following the "
"trapping instruction."
msgstr ""

#: ../../../virt/kvm/api.rst:6718
msgid "To be documented (KVM_TPR_ACCESS_REPORTING)."
msgstr ""

#: ../../../virt/kvm/api.rst:6731 ../../../virt/kvm/api.rst:6743
msgid "s390 specific."
msgstr ""

#: ../../../virt/kvm/api.rst:6753
msgid ""
"s390 specific. A page fault has occurred for a user controlled virtual "
"machine (KVM_VM_S390_UNCONTROL) on its host page table that cannot be "
"resolved by the kernel. The program code and the translation exception code "
"that were placed in the cpu's lowcore are presented here as defined by the z "
"Architecture Principles of Operation Book in the Chapter for Dynamic Address "
"Translation (DAT)"
msgstr ""

#: ../../../virt/kvm/api.rst:6770
msgid "Deprecated - was used for 440 KVM."
msgstr ""

#: ../../../virt/kvm/api.rst:6779
msgid ""
"MOL uses a special hypercall interface it calls 'OSI'. To enable it, we "
"catch hypercalls and exit with this exit struct that contains all the guest "
"gprs."
msgstr ""

#: ../../../virt/kvm/api.rst:6782
msgid ""
"If exit_reason is KVM_EXIT_OSI, then the vcpu has triggered such a "
"hypercall. Userspace can now handle the hypercall and when it's done modify "
"the gprs as necessary. Upon guest entry all guest GPRs will then be replaced "
"by the values in this struct."
msgstr ""

#: ../../../virt/kvm/api.rst:6796
msgid ""
"This is used on 64-bit PowerPC when emulating a pSeries partition, e.g. with "
"the 'pseries' machine type in qemu.  It occurs when the guest does a "
"hypercall using the 'sc 1' instruction.  The 'nr' field contains the "
"hypercall number (from the guest R3), and 'args' contains the arguments "
"(from the guest R4 - R12).  Userspace should put the return code in 'ret' "
"and any extra returned values in args[]. The possible hypercalls are defined "
"in the Power Architecture Platform Requirements (PAPR) document available "
"from www.power.org (free developer registration required to access it)."
msgstr ""

#: ../../../virt/kvm/api.rst:6818
msgid ""
"s390 specific. This exit occurs when KVM_CAP_S390_CSS_SUPPORT has been "
"enabled and TEST SUBCHANNEL was intercepted. If dequeued is set, a pending I/"
"O interrupt for the target subchannel has been dequeued and subchannel_id, "
"subchannel_nr, io_int_parm and io_int_word contain the parameters for that "
"interrupt. ipb is needed for instruction parameter decoding."
msgstr ""

#: ../../../virt/kvm/api.rst:6831
msgid ""
"On FSL BookE PowerPC chips, the interrupt controller has a fast patch "
"interrupt acknowledge path to the core. When the core successfully delivers "
"an interrupt, it automatically populates the EPR register with the interrupt "
"vector number and acknowledges the interrupt inside the interrupt controller."
msgstr ""

#: ../../../virt/kvm/api.rst:6837
msgid ""
"In case the interrupt controller lives in user space, we need to do the "
"interrupt acknowledge cycle through it to fetch the next to be delivered "
"interrupt vector using this exit."
msgstr ""

#: ../../../virt/kvm/api.rst:6841
msgid ""
"It gets triggered whenever both KVM_CAP_PPC_EPR are enabled and an external "
"interrupt has just been delivered into the guest. User space should put the "
"acknowledged interrupt vector into the 'epr' field."
msgstr ""

#: ../../../virt/kvm/api.rst:6861
msgid ""
"If exit_reason is KVM_EXIT_SYSTEM_EVENT then the vcpu has triggered a system-"
"level event using some architecture specific mechanism (hypercall or some "
"special instruction). In case of ARM64, this is triggered using HVC "
"instruction based PSCI call from the vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:6866
msgid ""
"The 'type' field describes the system-level event type. Valid values for "
"'type' are:"
msgstr ""

#: ../../../virt/kvm/api.rst:6869
msgid ""
"KVM_SYSTEM_EVENT_SHUTDOWN -- the guest has requested a shutdown of the VM. "
"Userspace is not obliged to honour this, and if it does honour this does not "
"need to destroy the VM synchronously (ie it may call KVM_RUN again before "
"shutdown finally occurs)."
msgstr ""

#: ../../../virt/kvm/api.rst:6873
msgid ""
"KVM_SYSTEM_EVENT_RESET -- the guest has requested a reset of the VM. As with "
"SHUTDOWN, userspace can choose to ignore the request, or to schedule the "
"reset to occur in the future and may call KVM_RUN again."
msgstr ""

#: ../../../virt/kvm/api.rst:6876
msgid ""
"KVM_SYSTEM_EVENT_CRASH -- the guest crash occurred and the guest has "
"requested a crash condition maintenance. Userspace can choose to ignore the "
"request, or to gather VM memory core dump and/or reset/shutdown of the VM."
msgstr ""

#: ../../../virt/kvm/api.rst:6880
msgid ""
"KVM_SYSTEM_EVENT_SEV_TERM -- an AMD SEV guest requested termination. The "
"guest physical address of the guest's GHCB is stored in `data[0]`."
msgstr ""

#: ../../../virt/kvm/api.rst:6882
msgid ""
"KVM_SYSTEM_EVENT_TDX_FATAL -- a TDX guest reported a fatal error state. KVM "
"doesn't do any parsing or conversion, it just dumps 16 general-purpose "
"registers to userspace, in ascending order of the 4-bit indices for x86-64 "
"general-purpose registers in instruction encoding, as defined in the Intel "
"SDM."
msgstr ""

#: ../../../virt/kvm/api.rst:6887
msgid ""
"KVM_SYSTEM_EVENT_WAKEUP -- the exiting vCPU is in a suspended state and KVM "
"has recognized a wakeup event. Userspace may honor this event by marking the "
"exiting vCPU as runnable, or deny it and call KVM_RUN again."
msgstr ""

#: ../../../virt/kvm/api.rst:6890
msgid ""
"KVM_SYSTEM_EVENT_SUSPEND -- the guest has requested a suspension of the VM."
msgstr ""

#: ../../../virt/kvm/api.rst:6893
msgid ""
"If KVM_CAP_SYSTEM_EVENT_DATA is present, the 'data' field can contain "
"architecture specific information for the system-level event.  Only the "
"first `ndata` items (possibly zero) of the data array are valid."
msgstr ""

#: ../../../virt/kvm/api.rst:6897
msgid ""
"for arm64, data[0] is set to KVM_SYSTEM_EVENT_RESET_FLAG_PSCI_RESET2 if the "
"guest issued a SYSTEM_RESET2 call according to v1.1 of the PSCI "
"specification."
msgstr ""

#: ../../../virt/kvm/api.rst:6901
msgid ""
"for arm64, data[0] is set to KVM_SYSTEM_EVENT_SHUTDOWN_FLAG_PSCI_OFF2 if the "
"guest issued a SYSTEM_OFF2 call according to v1.3 of the PSCI specification."
msgstr ""

#: ../../../virt/kvm/api.rst:6905
msgid ""
"for RISC-V, data[0] is set to the value of the second argument of the "
"``sbi_system_reset`` call."
msgstr ""

#: ../../../virt/kvm/api.rst:6908
msgid ""
"Previous versions of Linux defined a `flags` member in this struct.  The "
"field is now aliased to `data[0]`.  Userspace can assume that it is only "
"written if ndata is greater than 0."
msgstr ""

#: ../../../virt/kvm/api.rst:6913
msgid "For arm/arm64:"
msgstr ""

#: ../../../virt/kvm/api.rst:6915
msgid ""
"KVM_SYSTEM_EVENT_SUSPEND exits are enabled with the "
"KVM_CAP_ARM_SYSTEM_SUSPEND VM capability. If a guest invokes the PSCI "
"SYSTEM_SUSPEND function, KVM will exit to userspace with this event type."
msgstr ""

#: ../../../virt/kvm/api.rst:6920
msgid ""
"It is the sole responsibility of userspace to implement the PSCI "
"SYSTEM_SUSPEND call according to ARM DEN0022D.b 5.19 \"SYSTEM_SUSPEND\". KVM "
"does not change the vCPU's state before exiting to userspace, so the call "
"parameters are left in-place in the vCPU registers."
msgstr ""

#: ../../../virt/kvm/api.rst:6925
msgid ""
"Userspace is _required_ to take action for such an exit. It must either:"
msgstr ""

#: ../../../virt/kvm/api.rst:6928
msgid ""
"Honor the guest request to suspend the VM. Userspace can request in-kernel "
"emulation of suspension by setting the calling vCPU's state to "
"KVM_MP_STATE_SUSPENDED. Userspace must configure the vCPU's state according "
"to the parameters passed to the PSCI function when the calling vCPU is "
"resumed. See ARM DEN0022D.b 5.19.1 \"Intended use\" for details on the "
"function parameters."
msgstr ""

#: ../../../virt/kvm/api.rst:6935
msgid ""
"Deny the guest request to suspend the VM. See ARM DEN0022D.b 5.19.2 \"Caller "
"responsibilities\" for possible return values."
msgstr ""

#: ../../../virt/kvm/api.rst:6938
msgid ""
"Hibernation using the PSCI SYSTEM_OFF2 call is enabled when PSCI v1.3 is "
"enabled. If a guest invokes the PSCI SYSTEM_OFF2 function, KVM will exit to "
"userspace with the KVM_SYSTEM_EVENT_SHUTDOWN event type and with data[0] set "
"to KVM_SYSTEM_EVENT_SHUTDOWN_FLAG_PSCI_OFF2. The only supported hibernate "
"type for the SYSTEM_OFF2 function is HIBERNATE_OFF."
msgstr ""

#: ../../../virt/kvm/api.rst:6951
msgid ""
"Indicates that the VCPU's in-kernel local APIC received an EOI for a level-"
"triggered IOAPIC interrupt.  This exit only triggers when the IOAPIC is "
"implemented in userspace (i.e. KVM_CAP_SPLIT_IRQCHIP is enabled); the "
"userspace IOAPIC should process the EOI and retrigger the interrupt if it is "
"still asserted.  Vector is the LAPIC interrupt vector for which the EOI was "
"received."
msgstr ""

#: ../../../virt/kvm/api.rst:6993
msgid ""
"Indicates that the VCPU exits into userspace to process some tasks related "
"to Hyper-V emulation."
msgstr ""

#: ../../../virt/kvm/api.rst:6996 ../../../virt/kvm/api.rst:7115
msgid "Valid values for 'type' are:"
msgstr ""

#: ../../../virt/kvm/api.rst:6998
msgid "KVM_EXIT_HYPERV_SYNIC -- synchronously notify user-space about"
msgstr ""

#: ../../../virt/kvm/api.rst:7000
msgid ""
"Hyper-V SynIC state change. Notification is used to remap SynIC event/"
"message pages and to enable/disable SynIC messages/events processing in "
"userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:7004
msgid "KVM_EXIT_HYPERV_SYNDBG -- synchronously notify user-space about"
msgstr ""

#: ../../../virt/kvm/api.rst:7006
msgid ""
"Hyper-V Synthetic debugger state change. Notification is used to either "
"update the pending_page location or to send a control command (send the "
"buffer located in send_page or recv a buffer to recv_page)."
msgstr ""

#: ../../../virt/kvm/api.rst:7018
msgid ""
"Used on arm64 systems. If a guest accesses memory not in a memslot, KVM will "
"typically return to userspace and ask it to do MMIO emulation on its behalf. "
"However, for certain classes of instructions, no instruction decode "
"(direction, length of memory access) is provided, and fetching and decoding "
"the instruction from the VM is overly complicated to live in the kernel."
msgstr ""

#: ../../../virt/kvm/api.rst:7024
msgid ""
"Historically, when this situation occurred, KVM would print a warning and "
"kill the VM. KVM assumed that if the guest accessed non-memslot memory, it "
"was trying to do I/O, which just couldn't be emulated, and the warning "
"message was phrased accordingly. However, what happened more often was that "
"a guest bug caused access outside the guest memory areas which should lead "
"to a more meaningful warning message and an external abort in the guest, if "
"the access did not fall within an I/O window."
msgstr ""

#: ../../../virt/kvm/api.rst:7032
msgid ""
"Userspace implementations can query for KVM_CAP_ARM_NISV_TO_USER, and enable "
"this capability at VM creation. Once this is done, these types of errors "
"will instead return to userspace with KVM_EXIT_ARM_NISV, with the valid bits "
"from the ESR_EL2 in the esr_iss field, and the faulting IPA in the fault_ipa "
"field. Userspace can either fix up the access if it's actually an I/O access "
"by decoding the instruction from guest memory (if it's very brave) and "
"continue executing the guest, or it can decide to suspend, dump, or restart "
"the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:7040
msgid ""
"Note that KVM does not skip the faulting instruction as it does for "
"KVM_EXIT_MMIO, but userspace has to emulate any change to the processing "
"state if it decides to decode and emulate the instruction."
msgstr ""

#: ../../../virt/kvm/api.rst:7044
msgid ""
"This feature isn't available to protected VMs, as userspace does not have "
"access to the state that is required to perform the emulation. Instead, a "
"data abort exception is directly injected in the guest. Note that although "
"KVM_CAP_ARM_NISV_TO_USER will be reported if queried outside of a protected "
"VM context, the feature will not be exposed if queried on a protected VM "
"file descriptor."
msgstr ""

#: ../../../virt/kvm/api.rst:7062
msgid ""
"Used on x86 systems. When the VM capability KVM_CAP_X86_USER_SPACE_MSR is "
"enabled, MSR accesses to registers that would invoke a #GP by KVM kernel "
"code may instead trigger a KVM_EXIT_X86_RDMSR exit for reads and "
"KVM_EXIT_X86_WRMSR exit for writes."
msgstr ""

#: ../../../virt/kvm/api.rst:7067
msgid ""
"The \"reason\" field specifies why the MSR interception occurred. Userspace "
"will only receive MSR exits when a particular reason was requested during "
"through ENABLE_CAP. Currently valid exit reasons are:"
msgstr ""

#: ../../../virt/kvm/api.rst:7072 ../../../virt/kvm/api.rst:8056
msgid "KVM_MSR_EXIT_REASON_UNKNOWN"
msgstr ""

#: ../../../virt/kvm/api.rst:7072
msgid "access to MSR that is unknown to KVM"
msgstr ""

#: ../../../virt/kvm/api.rst:7073 ../../../virt/kvm/api.rst:8057
msgid "KVM_MSR_EXIT_REASON_INVAL"
msgstr ""

#: ../../../virt/kvm/api.rst:7073
msgid "access to invalid MSRs or reserved bits"
msgstr ""

#: ../../../virt/kvm/api.rst:7074 ../../../virt/kvm/api.rst:8059
msgid "KVM_MSR_EXIT_REASON_FILTER"
msgstr ""

#: ../../../virt/kvm/api.rst:7074
msgid "access blocked by KVM_X86_SET_MSR_FILTER"
msgstr ""

#: ../../../virt/kvm/api.rst:7077
msgid ""
"For KVM_EXIT_X86_RDMSR, the \"index\" field tells userspace which MSR the "
"guest wants to read. To respond to this request with a successful read, "
"userspace writes the respective data into the \"data\" field and must "
"continue guest execution to ensure the read data is transferred into guest "
"register state."
msgstr ""

#: ../../../virt/kvm/api.rst:7082
msgid ""
"If the RDMSR request was unsuccessful, userspace indicates that with a \"1\" "
"in the \"error\" field. This will inject a #GP into the guest when the VCPU "
"is executed again."
msgstr ""

#: ../../../virt/kvm/api.rst:7086
msgid ""
"For KVM_EXIT_X86_WRMSR, the \"index\" field tells userspace which MSR the "
"guest wants to write. Once finished processing the event, userspace must "
"continue vCPU execution. If the MSR write was unsuccessful, userspace also "
"sets the \"error\" field to \"1\"."
msgstr ""

#: ../../../virt/kvm/api.rst:7091
msgid ""
"See KVM_X86_SET_MSR_FILTER for details on the interaction with MSR filtering."
msgstr ""

#: ../../../virt/kvm/api.rst:7112
msgid ""
"Indicates that the VCPU exits into userspace to process some tasks related "
"to Xen emulation."
msgstr ""

#: ../../../virt/kvm/api.rst:7117
msgid ""
"KVM_EXIT_XEN_HCALL -- synchronously notify user-space about Xen hypercall. "
"Userspace is expected to place the hypercall result into the appropriate "
"field before invoking KVM_RUN again."
msgstr ""

#: ../../../virt/kvm/api.rst:7131
msgid ""
"If exit reason is KVM_EXIT_RISCV_SBI then it indicates that the VCPU has "
"done a SBI call which is not handled by KVM RISC-V kernel module. The "
"details of the SBI call are available in 'riscv_sbi' member of kvm_run "
"structure. The 'extension_id' field of 'riscv_sbi' represents SBI extension "
"ID whereas the 'function_id' field represents function ID of given SBI "
"extension. The 'args' array field of 'riscv_sbi' represents parameters for "
"the SBI call and 'ret' array field represents return values. The userspace "
"should update the return values of SBI call before resuming the VCPU. For "
"more details on RISC-V SBI spec refer, https://github.com/riscv/riscv-sbi-"
"doc."
msgstr ""

#: ../../../virt/kvm/api.rst:7151
msgid ""
"KVM_EXIT_MEMORY_FAULT indicates the vCPU has encountered a memory fault that "
"could not be resolved by KVM.  The 'gpa' and 'size' (in bytes) describe the "
"guest physical address range [gpa, gpa + size) of the fault.  The 'flags' "
"field describes properties of the faulting access that are likely pertinent:"
msgstr ""

#: ../../../virt/kvm/api.rst:7156
msgid ""
"KVM_MEMORY_EXIT_FLAG_PRIVATE - When set, indicates the memory fault occurred "
"on a private memory access.  When clear, indicates the fault occurred on a "
"shared access."
msgstr ""

#: ../../../virt/kvm/api.rst:7160
msgid ""
"Note!  KVM_EXIT_MEMORY_FAULT is unique among all KVM exit reasons in that it "
"accompanies a return code of '-1', not '0'!  errno will always be set to "
"EFAULT or EHWPOISON when KVM exits with KVM_EXIT_MEMORY_FAULT, userspace "
"should assume kvm_run.exit_reason is stale/undefined for all other error "
"numbers."
msgstr ""

#: ../../../virt/kvm/api.rst:7173
msgid ""
"Used on x86 systems. When the VM capability KVM_CAP_X86_NOTIFY_VMEXIT is "
"enabled, a VM exit generated if no event window occurs in VM non-root mode "
"for a specified amount of time. Once KVM_X86_NOTIFY_VMEXIT_USER is set when "
"enabling the cap, it would exit to userspace with the exit reason "
"KVM_EXIT_NOTIFY for further handling. The \"flags\" field contains more "
"detailed info."
msgstr ""

#: ../../../virt/kvm/api.rst:7180
msgid "The valid value for 'flags' is:"
msgstr ""

#: ../../../virt/kvm/api.rst:7182
msgid ""
"KVM_NOTIFY_CONTEXT_INVALID -- the VM context is corrupted and not valid in "
"VMCS. It would run into unknown result if resume the target VM."
msgstr ""

#: ../../../virt/kvm/api.rst:7213
msgid ""
"Process a TDVMCALL from the guest.  KVM forwards select TDVMCALL based on "
"the Guest-Hypervisor Communication Interface (GHCI) specification; KVM "
"bridges these requests to the userspace VMM with minimal changes, placing "
"the inputs in the union and copying them back to the guest on re-entry."
msgstr ""

#: ../../../virt/kvm/api.rst:7219
msgid ""
"Flags are currently always zero, whereas ``nr`` contains the TDVMCALL number "
"from register R11.  The remaining field of the union provide the inputs and "
"outputs of the TDVMCALL.  Currently the following values of ``nr`` are "
"defined:"
msgstr ""

#: ../../../virt/kvm/api.rst:7224
msgid ""
"``TDVMCALL_GET_QUOTE``: the guest has requested to generate a TD-Quote "
"signed by a service hosting TD-Quoting Enclave operating on the host. "
"Parameters and return value are in the ``get_quote`` field of the union. The "
"``gpa`` field and ``size`` specify the guest physical address (without the "
"shared bit set) and the size of a shared-memory buffer, in which the TDX "
"guest passes a TD Report.  The ``ret`` field represents the return value of "
"the GetQuote request.  When the request has been queued successfully, the "
"TDX guest can poll the status field in the shared-memory area to check "
"whether the Quote generation is completed or not. When completed, the "
"generated Quote is returned via the same buffer."
msgstr ""

#: ../../../virt/kvm/api.rst:7235
msgid ""
"``TDVMCALL_GET_TD_VM_CALL_INFO``: the guest has requested the support status "
"of TDVMCALLs.  The output values for the given leaf should be placed in "
"fields from ``r11`` to ``r14`` of the ``get_tdvmcall_info`` field of the "
"union."
msgstr ""

#: ../../../virt/kvm/api.rst:7240
msgid ""
"``TDVMCALL_SETUP_EVENT_NOTIFY_INTERRUPT``: the guest has requested to set up "
"a notification interrupt for vector ``vector``."
msgstr ""

#: ../../../virt/kvm/api.rst:7243
msgid ""
"KVM may add support for more values in the future that may cause a userspace "
"exit, even without calls to ``KVM_ENABLE_CAP`` or similar.  In this case, it "
"will enter with output fields already valid; in the common case, the "
"``unknown.ret`` field of the union will be "
"``TDVMCALL_STATUS_SUBFUNC_UNSUPPORTED``. Userspace need not do anything if "
"it does not wish to support a TDVMCALL. ::"
msgstr ""

#: ../../../virt/kvm/api.rst:7268
msgid ""
"If KVM_CAP_SYNC_REGS is defined, these fields allow userspace to access "
"certain guest registers without having to call SET/GET_*REGS. Thus we can "
"avoid some system call overhead if userspace has to handle the exit. "
"Userspace can query the validity of the structure by checking kvm_valid_regs "
"for specific bits. These bits are architecture specific and usually define "
"the validity of a groups of registers. (e.g. one bit for general purpose "
"registers)"
msgstr ""

#: ../../../virt/kvm/api.rst:7276
msgid ""
"Please note that the kernel is allowed to use the kvm_run structure as the "
"primary storage for certain register types. Therefore, the kernel may use "
"the values in kvm_run even if the corresponding bit in kvm_dirty_regs is not "
"set."
msgstr ""

#: ../../../virt/kvm/api.rst:7284
msgid "6. Capabilities that can be enabled on vCPUs"
msgstr ""

#: ../../../virt/kvm/api.rst:7286
msgid ""
"There are certain capabilities that change the behavior of the virtual CPU "
"or the virtual machine when enabled. To enable them, please see :ref:"
"`KVM_ENABLE_CAP`."
msgstr ""

#: ../../../virt/kvm/api.rst:7290
msgid ""
"Below you can find a list of capabilities and what their effect on the vCPU "
"or the virtual machine is when enabling them."
msgstr ""

#: ../../../virt/kvm/api.rst:7293 ../../../virt/kvm/api.rst:7623
msgid "The following information is provided along with the description:"
msgstr ""

#: ../../../virt/kvm/api.rst:7299
msgid "Target:"
msgstr ""

#: ../../../virt/kvm/api.rst:7300
msgid "whether this is a per-vcpu or per-vm capability."
msgstr ""

#: ../../../virt/kvm/api.rst:7303 ../../../virt/kvm/api.rst:7630
msgid "what parameters are accepted by the capability."
msgstr ""

#: ../../../virt/kvm/api.rst:7311
msgid "6.1 KVM_CAP_PPC_OSI"
msgstr ""

#: ../../../virt/kvm/api.rst:0
msgid "Target"
msgstr ""

#: ../../../virt/kvm/api.rst:7314 ../../../virt/kvm/api.rst:7330
#: ../../../virt/kvm/api.rst:7351 ../../../virt/kvm/api.rst:7398
#: ../../../virt/kvm/api.rst:7417 ../../../virt/kvm/api.rst:7445
#: ../../../virt/kvm/api.rst:7465 ../../../virt/kvm/api.rst:7479
#: ../../../virt/kvm/api.rst:7538 ../../../virt/kvm/api.rst:7548
#: ../../../virt/kvm/api.rst:7564 ../../../virt/kvm/api.rst:7575
#: ../../../virt/kvm/api.rst:7591 ../../../virt/kvm/api.rst:7603
msgid "vcpu"
msgstr ""

#: ../../../virt/kvm/api.rst:7318
msgid ""
"This capability enables interception of OSI hypercalls that otherwise would "
"be treated as normal system calls to be injected into the guest. OSI "
"hypercalls were invented by Mac-on-Linux to have a standardized "
"communication mechanism between the guest and the host."
msgstr ""

#: ../../../virt/kvm/api.rst:7323
msgid "When this capability is enabled, KVM_EXIT_OSI can occur."
msgstr ""

#: ../../../virt/kvm/api.rst:7327
msgid "6.2 KVM_CAP_PPC_PAPR"
msgstr ""

#: ../../../virt/kvm/api.rst:7334
msgid ""
"This capability enables interception of PAPR hypercalls. PAPR hypercalls are "
"done using the hypercall instruction \"sc 1\"."
msgstr ""

#: ../../../virt/kvm/api.rst:7337
msgid ""
"It also sets the guest privilege level to \"supervisor\" mode. Usually the "
"guest runs in \"hypervisor\" privilege mode with a few missing features."
msgstr ""

#: ../../../virt/kvm/api.rst:7340
msgid ""
"In addition to the above, it changes the semantics of SDR1. In this mode, "
"the HTAB address part of SDR1 contains an HVA instead of a GPA, as PAPR "
"keeps the HTAB invisible to the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:7344
msgid "When this capability is enabled, KVM_EXIT_PAPR_HCALL can occur."
msgstr ""

#: ../../../virt/kvm/api.rst:7348
msgid "6.3 KVM_CAP_SW_TLB"
msgstr ""

#: ../../../virt/kvm/api.rst:7352
msgid "args[0] is the address of a struct kvm_config_tlb"
msgstr ""

#: ../../../virt/kvm/api.rst:7364
msgid ""
"Configures the virtual CPU's TLB array, establishing a shared memory area "
"between userspace and KVM.  The \"params\" and \"array\" fields are "
"userspace addresses of mmu-type-specific data structures.  The \"array_len\" "
"field is an safety mechanism, and should be set to the size in bytes of the "
"memory that userspace has reserved for the array.  It must be at least the "
"size dictated by \"mmu_type\" and \"params\"."
msgstr ""

#: ../../../virt/kvm/api.rst:7371
msgid ""
"While KVM_RUN is active, the shared region is under control of KVM.  Its "
"contents are undefined, and any modification by userspace results in "
"boundedly undefined behavior."
msgstr ""

#: ../../../virt/kvm/api.rst:7375
msgid ""
"On return from KVM_RUN, the shared region will reflect the current state of "
"the guest's TLB.  If userspace makes any changes, it must call KVM_DIRTY_TLB "
"to tell KVM which entries have been changed, prior to calling KVM_RUN again "
"on this vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:7380
msgid "For mmu types KVM_MMU_FSL_BOOKE_NOHV and KVM_MMU_FSL_BOOKE_HV:"
msgstr ""

#: ../../../virt/kvm/api.rst:7382
msgid "The \"params\" field is of type \"struct kvm_book3e_206_tlb_params\"."
msgstr ""

#: ../../../virt/kvm/api.rst:7383
msgid ""
"The \"array\" field points to an array of type \"struct "
"kvm_book3e_206_tlb_entry\"."
msgstr ""

#: ../../../virt/kvm/api.rst:7385
msgid ""
"The array consists of all entries in the first TLB, followed by all entries "
"in the second TLB."
msgstr ""

#: ../../../virt/kvm/api.rst:7387
msgid ""
"Within a TLB, entries are ordered first by increasing set number.  Within a "
"set, entries are ordered by way (increasing ESEL)."
msgstr ""

#: ../../../virt/kvm/api.rst:7389
msgid ""
"The hash for determining set number in TLB0 is: (MAS2 >> 12) & (num_sets - "
"1) where \"num_sets\" is the tlb_sizes[] value divided by the tlb_ways[] "
"value."
msgstr ""

#: ../../../virt/kvm/api.rst:7391
msgid ""
"The tsize field of mas1 shall be set to 4K on TLB0, even though the hardware "
"ignores this value for TLB0."
msgstr ""

#: ../../../virt/kvm/api.rst:7395
msgid "6.4 KVM_CAP_S390_CSS_SUPPORT"
msgstr ""

#: ../../../virt/kvm/api.rst:7402
msgid ""
"This capability enables support for handling of channel I/O instructions."
msgstr ""

#: ../../../virt/kvm/api.rst:7404
msgid ""
"TEST PENDING INTERRUPTION and the interrupt portion of TEST SUBCHANNEL are "
"handled in-kernel, while the other I/O instructions are passed to userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:7407
msgid ""
"When this capability is enabled, KVM_EXIT_S390_TSCH will occur on TEST "
"SUBCHANNEL intercepts."
msgstr ""

#: ../../../virt/kvm/api.rst:7410
msgid ""
"Note that even though this capability is enabled per-vcpu, the complete "
"virtual machine is affected."
msgstr ""

#: ../../../virt/kvm/api.rst:7414
msgid "6.5 KVM_CAP_PPC_EPR"
msgstr ""

#: ../../../virt/kvm/api.rst:7418
msgid "args[0] defines whether the proxy facility is active"
msgstr ""

#: ../../../virt/kvm/api.rst:7421
msgid ""
"This capability enables or disables the delivery of interrupts through the "
"external proxy facility."
msgstr ""

#: ../../../virt/kvm/api.rst:7424
msgid ""
"When enabled (args[0] != 0), every time the guest gets an external interrupt "
"delivered, it automatically exits into user space with a KVM_EXIT_EPR exit "
"to receive the topmost interrupt vector."
msgstr ""

#: ../../../virt/kvm/api.rst:7428
msgid ""
"When disabled (args[0] == 0), behavior is as if this facility is unsupported."
msgstr ""

#: ../../../virt/kvm/api.rst:7430
msgid "When this capability is enabled, KVM_EXIT_EPR can occur."
msgstr ""

#: ../../../virt/kvm/api.rst:7433
msgid "6.6 KVM_CAP_IRQ_MPIC"
msgstr ""

#: ../../../virt/kvm/api.rst:7436
msgid ""
"args[0] is the MPIC device fd; args[1] is the MPIC CPU number for this vcpu"
msgstr ""

#: ../../../virt/kvm/api.rst:7439
msgid "This capability connects the vcpu to an in-kernel MPIC device."
msgstr ""

#: ../../../virt/kvm/api.rst:7442
msgid "6.7 KVM_CAP_IRQ_XICS"
msgstr ""

#: ../../../virt/kvm/api.rst:7446
msgid ""
"args[0] is the XICS device fd; args[1] is the XICS CPU number (server ID) "
"for this vcpu"
msgstr ""

#: ../../../virt/kvm/api.rst:7449
msgid "This capability connects the vcpu to an in-kernel XICS device."
msgstr ""

#: ../../../virt/kvm/api.rst:7452
msgid "6.8 KVM_CAP_S390_IRQCHIP"
msgstr ""

#: ../../../virt/kvm/api.rst:7455 ../../../virt/kvm/api.rst:8122
#: ../../../virt/kvm/api.rst:8204 ../../../virt/kvm/api.rst:8219
#: ../../../virt/kvm/api.rst:8414 ../../../virt/kvm/api.rst:8539
#: ../../../virt/kvm/api.rst:8560 ../../../virt/kvm/api.rst:8576
#: ../../../virt/kvm/api.rst:8602 ../../../virt/kvm/api.rst:8620
#: ../../../virt/kvm/api.rst:9045 ../../../virt/kvm/api.rst:9079
#: ../../../virt/kvm/api.rst:9091
msgid "vm"
msgstr ""

#: ../../../virt/kvm/api.rst:7458
msgid ""
"This capability enables the in-kernel irqchip for s390. Please refer to "
"\"4.24 KVM_CREATE_IRQCHIP\" for details."
msgstr ""

#: ../../../virt/kvm/api.rst:7462
msgid "6.9 KVM_CAP_MIPS_FPU"
msgstr ""

#: ../../../virt/kvm/api.rst:7464 ../../../virt/kvm/api.rst:7478
#: ../../../virt/kvm/api.rst:8705 ../../../virt/kvm/api.rst:8735
msgid "mips"
msgstr ""

#: ../../../virt/kvm/api.rst:7466 ../../../virt/kvm/api.rst:7480
msgid "args[0] is reserved for future use (should be 0)."
msgstr ""

#: ../../../virt/kvm/api.rst:7468
msgid ""
"This capability allows the use of the host Floating Point Unit by the guest. "
"It allows the Config1.FP bit to be set to enable the FPU in the guest. Once "
"this is done the ``KVM_REG_MIPS_FPR_*`` and ``KVM_REG_MIPS_FCR_*`` registers "
"can be accessed (depending on the current guest FPU register mode), and the "
"Status.FR, Config5.FRE bits are accessible via the KVM API and also from the "
"guest, depending on them being supported by the FPU."
msgstr ""

#: ../../../virt/kvm/api.rst:7476
msgid "6.10 KVM_CAP_MIPS_MSA"
msgstr ""

#: ../../../virt/kvm/api.rst:7482
msgid ""
"This capability allows the use of the MIPS SIMD Architecture (MSA) by the "
"guest. It allows the Config3.MSAP bit to be set to enable the use of MSA by "
"the guest. Once this is done the ``KVM_REG_MIPS_VEC_*`` and "
"``KVM_REG_MIPS_MSA_*`` registers can be accessed, and the Config5.MSAEn bit "
"is accessible via the KVM API and also from the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:7489
msgid "6.74 KVM_CAP_SYNC_REGS"
msgstr ""

#: ../../../virt/kvm/api.rst:7491
msgid "s390, x86"
msgstr ""

#: ../../../virt/kvm/api.rst:7492
msgid "s390: always enabled, x86: vcpu"
msgstr ""

#: ../../../virt/kvm/api.rst:7494
msgid ""
"x86: KVM_CHECK_EXTENSION returns a bit-array indicating which register sets "
"are supported (bitfields defined in arch/x86/include/uapi/asm/kvm.h)."
msgstr ""

#: ../../../virt/kvm/api.rst:7498
msgid ""
"As described above in the kvm_sync_regs struct info in section :ref:"
"`kvm_run`, KVM_CAP_SYNC_REGS \"allow[s] userspace to access certain guest "
"registers without having to call SET/GET_*REGS\". This reduces overhead by "
"eliminating repeated ioctl calls for setting and/or getting register values. "
"This is particularly important when userspace is making synchronous guest "
"state modifications, e.g. when emulating and/or intercepting instructions in "
"userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:7506
msgid "For s390 specifics, please refer to the source code."
msgstr ""

#: ../../../virt/kvm/api.rst:7508
msgid "For x86:"
msgstr ""

#: ../../../virt/kvm/api.rst:7510
msgid ""
"the register sets to be copied out to kvm_run are selectable by userspace "
"(rather that all sets being copied out for every exit)."
msgstr ""

#: ../../../virt/kvm/api.rst:7512
msgid "vcpu_events are available in addition to regs and sregs."
msgstr ""

#: ../../../virt/kvm/api.rst:7514
msgid ""
"For x86, the 'kvm_valid_regs' field of struct kvm_run is overloaded to "
"function as an input bit-array field set by userspace to indicate the "
"specific register sets to be copied out on the next exit."
msgstr ""

#: ../../../virt/kvm/api.rst:7518
msgid ""
"To indicate when userspace has modified values that should be copied into "
"the vCPU, the all architecture bitarray field, 'kvm_dirty_regs' must be set. "
"This is done using the same bitflags as for the 'kvm_valid_regs' field. If "
"the dirty bit is not set, then the register set values will not be copied "
"into the vCPU even if they've been modified."
msgstr ""

#: ../../../virt/kvm/api.rst:7524
msgid "Unused bitfields in the bitarrays must be set to zero."
msgstr ""

#: ../../../virt/kvm/api.rst:7535
msgid "6.75 KVM_CAP_PPC_IRQ_XIVE"
msgstr ""

#: ../../../virt/kvm/api.rst:7539
msgid ""
"args[0] is the XIVE device fd; args[1] is the XIVE CPU number (server ID) "
"for this vcpu"
msgstr ""

#: ../../../virt/kvm/api.rst:7542
msgid "This capability connects the vcpu to an in-kernel XIVE device."
msgstr ""

#: ../../../virt/kvm/api.rst:7545
msgid "6.76 KVM_CAP_HYPERV_SYNIC"
msgstr ""

#: ../../../virt/kvm/api.rst:7550
msgid ""
"This capability, if KVM_CHECK_EXTENSION indicates that it is available, "
"means that the kernel has an implementation of the Hyper-V Synthetic "
"interrupt controller(SynIC). Hyper-V SynIC is used to support Windows Hyper-"
"V based guest paravirt drivers(VMBus)."
msgstr ""

#: ../../../virt/kvm/api.rst:7555
msgid ""
"In order to use SynIC, it has to be activated by setting this capability via "
"KVM_ENABLE_CAP ioctl on the vcpu fd. Note that this will disable the use of "
"APIC hardware virtualization even if supported by the CPU, as it's "
"incompatible with SynIC auto-EOI behavior."
msgstr ""

#: ../../../virt/kvm/api.rst:7561
msgid "6.77 KVM_CAP_HYPERV_SYNIC2"
msgstr ""

#: ../../../virt/kvm/api.rst:7566
msgid ""
"This capability enables a newer version of Hyper-V Synthetic interrupt "
"controller (SynIC).  The only difference with KVM_CAP_HYPERV_SYNIC is that "
"KVM doesn't clear SynIC message and event flags pages when they are enabled "
"by writing to the respective MSRs."
msgstr ""

#: ../../../virt/kvm/api.rst:7572
msgid "6.78 KVM_CAP_HYPERV_DIRECT_TLBFLUSH"
msgstr ""

#: ../../../virt/kvm/api.rst:7577
msgid ""
"This capability indicates that KVM running on top of Hyper-V hypervisor "
"enables Direct TLB flush for its guests meaning that TLB flush hypercalls "
"are handled by Level 0 hypervisor (Hyper-V) bypassing KVM. Due to the "
"different ABI for hypercall parameters between Hyper-V and KVM, enabling "
"this capability effectively disables all hypercall handling by KVM (as some "
"KVM hypercall may be mistakenly treated as TLB flush hypercalls by Hyper-V) "
"so userspace should disable KVM identification in CPUID and only exposes "
"Hyper-V identification. In this case, guest thinks it's running on Hyper-V "
"and only use Hyper-V hypercalls."
msgstr ""

#: ../../../virt/kvm/api.rst:7588
msgid "6.79 KVM_CAP_HYPERV_ENFORCE_CPUID"
msgstr ""

#: ../../../virt/kvm/api.rst:7593
msgid ""
"When enabled, KVM will disable emulated Hyper-V features provided to the "
"guest according to the bits Hyper-V CPUID feature leaves. Otherwise, all "
"currently implemented Hyper-V features are provided unconditionally when "
"Hyper-V identification is set in the HYPERV_CPUID_INTERFACE (0x40000001) "
"leaf."
msgstr ""

#: ../../../virt/kvm/api.rst:7600
msgid "6.80 KVM_CAP_ENFORCE_PV_FEATURE_CPUID"
msgstr ""

#: ../../../virt/kvm/api.rst:7605
msgid ""
"When enabled, KVM will disable paravirtual features provided to the guest "
"according to the bits in the KVM_CPUID_FEATURES CPUID leaf (0x40000001). "
"Otherwise, a guest may use the paravirtual features regardless of what has "
"actually been exposed through the CPUID leaf."
msgstr ""

#: ../../../virt/kvm/api.rst:7616
msgid "7. Capabilities that can be enabled on VMs"
msgstr ""

#: ../../../virt/kvm/api.rst:7618
msgid ""
"There are certain capabilities that change the behavior of the virtual "
"machine when enabled. To enable them, please see section :ref:"
"`KVM_ENABLE_CAP`. Below you can find a list of capabilities and what their "
"effect on the VM is when enabling them."
msgstr ""

#: ../../../virt/kvm/api.rst:7638
msgid "7.1 KVM_CAP_PPC_ENABLE_HCALL"
msgstr ""

#: ../../../virt/kvm/api.rst:7641
msgid ""
"args[0] is the sPAPR hcall number; args[1] is 0 to disable, 1 to enable in-"
"kernel handling"
msgstr ""

#: ../../../virt/kvm/api.rst:7644
msgid ""
"This capability controls whether individual sPAPR hypercalls (hcalls) get "
"handled by the kernel or not.  Enabling or disabling in-kernel handling of "
"an hcall is effective across the VM.  On creation, an initial set of hcalls "
"are enabled for in-kernel handling, which consists of those hcalls for which "
"in-kernel handlers were implemented before this capability was implemented.  "
"If disabled, the kernel will not to attempt to handle the hcall, but will "
"always exit to userspace to handle it.  Note that it may not make sense to "
"enable some and disable others of a group of related hcalls, but KVM does "
"not prevent userspace from doing that."
msgstr ""

#: ../../../virt/kvm/api.rst:7655
msgid ""
"If the hcall number specified is not one that has an in-kernel "
"implementation, the KVM_ENABLE_CAP ioctl will fail with an EINVAL error."
msgstr ""

#: ../../../virt/kvm/api.rst:7660
msgid "7.2 KVM_CAP_S390_USER_SIGP"
msgstr ""

#: ../../../virt/kvm/api.rst:7665
msgid ""
"This capability controls which SIGP orders will be handled completely in "
"user space. With this capability enabled, all fast orders will be handled "
"completely in the kernel:"
msgstr ""

#: ../../../virt/kvm/api.rst:7669
msgid "SENSE"
msgstr ""

#: ../../../virt/kvm/api.rst:7670
msgid "SENSE RUNNING"
msgstr ""

#: ../../../virt/kvm/api.rst:7671
msgid "EXTERNAL CALL"
msgstr ""

#: ../../../virt/kvm/api.rst:7672
msgid "EMERGENCY SIGNAL"
msgstr ""

#: ../../../virt/kvm/api.rst:7673
msgid "CONDITIONAL EMERGENCY SIGNAL"
msgstr ""

#: ../../../virt/kvm/api.rst:7675
msgid "All other orders will be handled completely in user space."
msgstr ""

#: ../../../virt/kvm/api.rst:7677
msgid ""
"Only privileged operation exceptions will be checked for in the kernel (or "
"even in the hardware prior to interception). If this capability is not "
"enabled, the old way of handling SIGP orders is used (partially in kernel "
"and user space)."
msgstr ""

#: ../../../virt/kvm/api.rst:7682
msgid "7.3 KVM_CAP_S390_VECTOR_REGISTERS"
msgstr ""

#: ../../../virt/kvm/api.rst:7688
msgid ""
"Allows use of the vector registers introduced with z13 processor, and "
"provides for the synchronization between host and user space.  Will return -"
"EINVAL if the machine does not support vectors."
msgstr ""

#: ../../../virt/kvm/api.rst:7693
msgid "7.4 KVM_CAP_S390_USER_STSI"
msgstr ""

#: ../../../virt/kvm/api.rst:7698
msgid ""
"This capability allows post-handlers for the STSI instruction. After initial "
"handling in the kernel, KVM exits to user space with KVM_EXIT_S390_STSI to "
"allow user space to insert further data."
msgstr ""

#: ../../../virt/kvm/api.rst:7702
msgid ""
"Before exiting to userspace, kvm handlers should fill in s390_stsi field of "
"vcpu->run::"
msgstr ""

#: ../../../virt/kvm/api.rst:7720
msgid "KVM handlers should exit to userspace with rc = -EREMOTE."
msgstr ""

#: ../../../virt/kvm/api.rst:7723
msgid "7.5 KVM_CAP_SPLIT_IRQCHIP"
msgstr ""

#: ../../../virt/kvm/api.rst:7726
msgid "args[0] - number of routes reserved for userspace IOAPICs"
msgstr ""

#: ../../../virt/kvm/api.rst:7729
msgid ""
"Create a local apic for each processor in the kernel. This can be used "
"instead of KVM_CREATE_IRQCHIP if the userspace VMM wishes to emulate the "
"IOAPIC and PIC (and also the PIT, even though this has to be enabled "
"separately)."
msgstr ""

#: ../../../virt/kvm/api.rst:7734
msgid ""
"This capability also enables in kernel routing of interrupt requests; when "
"KVM_CAP_SPLIT_IRQCHIP only routes of KVM_IRQ_ROUTING_MSI type are used in "
"the IRQ routing table.  The first args[0] MSI routes are reserved for the "
"IOAPIC pins.  Whenever the LAPIC receives an EOI for these routes, a "
"KVM_EXIT_IOAPIC_EOI vmexit will be reported to userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:7740
msgid ""
"Fails if VCPU has already been created, or if the irqchip is already in the "
"kernel (i.e. KVM_CREATE_IRQCHIP has already been called)."
msgstr ""

#: ../../../virt/kvm/api.rst:7744
msgid "7.6 KVM_CAP_S390_RI"
msgstr ""

#: ../../../virt/kvm/api.rst:7749
msgid ""
"Allows use of runtime-instrumentation introduced with zEC12 processor. Will "
"return -EINVAL if the machine does not support runtime-instrumentation. Will "
"return -EBUSY if a VCPU has already been created."
msgstr ""

#: ../../../virt/kvm/api.rst:7754
msgid "7.7 KVM_CAP_X2APIC_API"
msgstr ""

#: ../../../virt/kvm/api.rst:7757
msgid "args[0] - features that should be enabled"
msgstr ""

#: ../../../virt/kvm/api.rst:7758
msgid "0 on success, -EINVAL when args[0] contains invalid features"
msgstr ""

#: ../../../virt/kvm/api.rst:7760
msgid "Valid feature flags in args[0] are::"
msgstr ""

#: ../../../virt/kvm/api.rst:7765
msgid ""
"Enabling KVM_X2APIC_API_USE_32BIT_IDS changes the behavior of "
"KVM_SET_GSI_ROUTING, KVM_SIGNAL_MSI, KVM_SET_LAPIC, and KVM_GET_LAPIC, "
"allowing the use of 32-bit APIC IDs.  See KVM_CAP_X2APIC_API in their "
"respective sections."
msgstr ""

#: ../../../virt/kvm/api.rst:7770
msgid ""
"KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK must be enabled for x2APIC to work in "
"logical mode or with more than 255 VCPUs.  Otherwise, KVM treats 0xff as a "
"broadcast even in x2APIC mode in order to support physical x2APIC without "
"interrupt remapping.  This is undesirable in logical mode, where 0xff "
"represents CPUs 0-7 in cluster 0."
msgstr ""

#: ../../../virt/kvm/api.rst:7777
msgid "7.8 KVM_CAP_S390_USER_INSTR0"
msgstr ""

#: ../../../virt/kvm/api.rst:7782
msgid ""
"With this capability enabled, all illegal instructions 0x0000 (2 bytes) will "
"be intercepted and forwarded to user space. User space can use this "
"mechanism e.g. to realize 2-byte software breakpoints. The kernel will not "
"inject an operating exception for these instructions, user space has to take "
"care of that."
msgstr ""

#: ../../../virt/kvm/api.rst:7788
msgid ""
"This capability can be enabled dynamically even if VCPUs were already "
"created and are running."
msgstr ""

#: ../../../virt/kvm/api.rst:7792
msgid "7.9 KVM_CAP_S390_GS"
msgstr ""

#: ../../../virt/kvm/api.rst:7796
msgid ""
"0 on success; -EINVAL if the machine does not support guarded storage; -"
"EBUSY if a VCPU has already been created."
msgstr ""

#: ../../../virt/kvm/api.rst:7799
msgid "Allows use of guarded storage for the KVM guest."
msgstr ""

#: ../../../virt/kvm/api.rst:7802
msgid "7.10 KVM_CAP_S390_AIS"
msgstr ""

#: ../../../virt/kvm/api.rst:7807
msgid ""
"Allow use of adapter-interruption suppression. :Returns: 0 on success; -"
"EBUSY if a VCPU has already been created."
msgstr ""

#: ../../../virt/kvm/api.rst:7811
msgid "7.11 KVM_CAP_PPC_SMT"
msgstr ""

#: ../../../virt/kvm/api.rst:7814
msgid "vsmt_mode, flags"
msgstr ""

#: ../../../virt/kvm/api.rst:7816
msgid ""
"Enabling this capability on a VM provides userspace with a way to set the "
"desired virtual SMT mode (i.e. the number of virtual CPUs per virtual "
"core).  The virtual SMT mode, vsmt_mode, must be a power of 2 between 1 and "
"8.  On POWER8, vsmt_mode must also be no greater than the number of threads "
"per subcore for the host.  Currently flags must be 0.  A successful call to "
"enable this capability will result in vsmt_mode being returned when the "
"KVM_CAP_PPC_SMT capability is subsequently queried for the VM.  This "
"capability is only supported by HV KVM, and can only be set before any VCPUs "
"have been created. The KVM_CAP_PPC_SMT_POSSIBLE capability indicates which "
"virtual SMT modes are available."
msgstr ""

#: ../../../virt/kvm/api.rst:7829
msgid "7.12 KVM_CAP_PPC_FWNMI"
msgstr ""

#: ../../../virt/kvm/api.rst:7834
msgid ""
"With this capability a machine check exception in the guest address space "
"will cause KVM to exit the guest with NMI exit reason. This enables QEMU to "
"build error log and branch to guest kernel registered machine check handling "
"routine. Without this capability KVM will branch to guests' 0x200 interrupt "
"vector."
msgstr ""

#: ../../../virt/kvm/api.rst:7841
msgid "7.13 KVM_CAP_X86_DISABLE_EXITS"
msgstr ""

#: ../../../virt/kvm/api.rst:7844
msgid "args[0] defines which exits are disabled"
msgstr ""

#: ../../../virt/kvm/api.rst:7845
msgid ""
"0 on success, -EINVAL when args[0] contains invalid exits or if any vCPUs "
"have already been created"
msgstr ""

#: ../../../virt/kvm/api.rst:7848 ../../../virt/kvm/api.rst:8071
msgid "Valid bits in args[0] are::"
msgstr ""

#: ../../../virt/kvm/api.rst:7856
msgid ""
"Enabling this capability on a VM provides userspace with a way to no longer "
"intercept some instructions for improved latency in some workloads, and is "
"suggested when vCPUs are associated to dedicated physical CPUs.  More bits "
"can be added in the future; userspace can just pass the KVM_CHECK_EXTENSION "
"result to KVM_ENABLE_CAP to disable all such vmexits."
msgstr ""

#: ../../../virt/kvm/api.rst:7863
msgid "Do not enable KVM_FEATURE_PV_UNHALT if you disable HLT exits."
msgstr ""

#: ../../../virt/kvm/api.rst:7865
msgid ""
"Virtualizing the ``IA32_APERF`` and ``IA32_MPERF`` MSRs requires more than "
"just disabling APERF/MPERF exits. While both Intel and AMD document strict "
"usage conditions for these MSRs--emphasizing that only the ratio of their "
"deltas over a time interval (T0 to T1) is architecturally defined--simply "
"passing through the MSRs can still produce an incorrect ratio."
msgstr ""

#: ../../../virt/kvm/api.rst:7872
msgid "This erroneous ratio can occur if, between T0 and T1:"
msgstr ""

#: ../../../virt/kvm/api.rst:7874
msgid "The vCPU thread migrates between logical processors."
msgstr ""

#: ../../../virt/kvm/api.rst:7875
msgid "Live migration or suspend/resume operations take place."
msgstr ""

#: ../../../virt/kvm/api.rst:7876
msgid "Another task shares the vCPU's logical processor."
msgstr ""

#: ../../../virt/kvm/api.rst:7877
msgid "C-states lower than C0 are emulated (e.g., via HLT interception)."
msgstr ""

#: ../../../virt/kvm/api.rst:7878
msgid "The guest TSC frequency doesn't match the host TSC frequency."
msgstr ""

#: ../../../virt/kvm/api.rst:7880
msgid ""
"Due to these complexities, KVM does not automatically associate this "
"passthrough capability with the guest CPUID bit, ``CPUID.6:ECX."
"APERFMPERF[bit 0]``. Userspace VMMs that deem this mechanism adequate for "
"virtualizing the ``IA32_APERF`` and ``IA32_MPERF`` MSRs must set the guest "
"CPUID bit explicitly."
msgstr ""

#: ../../../virt/kvm/api.rst:7888
msgid "7.14 KVM_CAP_S390_HPAGE_1M"
msgstr ""

#: ../../../virt/kvm/api.rst:7892
msgid ""
"0 on success, -EINVAL if hpage module parameter was not set or cmma is "
"enabled, or the VM has the KVM_VM_S390_UCONTROL flag set"
msgstr ""

#: ../../../virt/kvm/api.rst:7896
msgid ""
"With this capability the KVM support for memory backing with 1m pages "
"through hugetlbfs can be enabled for a VM. After the capability is enabled, "
"cmma can't be enabled anymore and pfmfi and the storage key interpretation "
"are disabled. If cmma has already been enabled or the hpage module parameter "
"is not set to 1, -EINVAL is returned."
msgstr ""

#: ../../../virt/kvm/api.rst:7902
msgid ""
"While it is generally possible to create a huge page backed VM without this "
"capability, the VM will not be able to run."
msgstr ""

#: ../../../virt/kvm/api.rst:7906
msgid "7.15 KVM_CAP_MSR_PLATFORM_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:7909 ../../../virt/kvm/api.rst:7934
#: ../../../virt/kvm/api.rst:7960
msgid "args[0] whether feature should be enabled or not"
msgstr ""

#: ../../../virt/kvm/api.rst:7911
msgid ""
"With this capability, a guest may read the MSR_PLATFORM_INFO MSR. Otherwise, "
"a #GP would be raised when the guest tries to access. Currently, this "
"capability does not enable write permissions of this MSR for the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:7916
msgid "7.16 KVM_CAP_PPC_NESTED_HV"
msgstr ""

#: ../../../virt/kvm/api.rst:7920
msgid ""
"0 on success, -EINVAL when the implementation doesn't support nested-HV "
"virtualization."
msgstr ""

#: ../../../virt/kvm/api.rst:7923
msgid ""
"HV-KVM on POWER9 and later systems allows for \"nested-HV\" virtualization, "
"which provides a way for a guest VM to run guests that can run using the "
"CPU's supervisor mode (privileged non-hypervisor state).  Enabling this "
"capability on a VM depends on the CPU having the necessary functionality and "
"on the facility being enabled with a kvm-hv module parameter."
msgstr ""

#: ../../../virt/kvm/api.rst:7931
msgid "7.17 KVM_CAP_EXCEPTION_PAYLOAD"
msgstr ""

#: ../../../virt/kvm/api.rst:7936
msgid ""
"With this capability enabled, CR2 will not be modified prior to the emulated "
"VM-exit when L1 intercepts a #PF exception that occurs in L2. Similarly, for "
"kvm-intel only, DR6 will not be modified prior to the emulated VM-exit when "
"L1 intercepts a #DB exception that occurs in L2. As a result, when "
"KVM_GET_VCPU_EVENTS reports a pending #PF (or #DB) exception for L2, "
"exception.has_payload will be set and the faulting address (or the new DR6 "
"bits*) will be reported in the exception_payload field. Similarly, when "
"userspace injects a #PF (or #DB) into L2 using KVM_SET_VCPU_EVENTS, it is "
"expected to set exception.has_payload and to put the faulting address - or "
"the new DR6 bits\\ [#]_ - in the exception_payload field."
msgstr ""

#: ../../../virt/kvm/api.rst:7948
msgid ""
"This capability also enables exception.pending in struct kvm_vcpu_events, "
"which allows userspace to distinguish between pending and injected "
"exceptions."
msgstr ""

#: ../../../virt/kvm/api.rst:7953
msgid ""
"For the new DR6 bits, note that bit 16 is set iff the #DB exception will "
"clear DR6.RTM."
msgstr ""

#: ../../../virt/kvm/api.rst:7957
msgid "7.18 KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2"
msgstr ""

#: ../../../virt/kvm/api.rst:7967
msgid ""
"With KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE is set, KVM_GET_DIRTY_LOG will not "
"automatically clear and write-protect all pages that are returned as dirty. "
"Rather, userspace will have to do this operation separately using "
"KVM_CLEAR_DIRTY_LOG."
msgstr ""

#: ../../../virt/kvm/api.rst:7972
msgid ""
"At the cost of a slightly more complicated operation, this provides better "
"scalability and responsiveness for two reasons.  First, KVM_CLEAR_DIRTY_LOG "
"ioctl can operate on a 64-page granularity rather than requiring to sync a "
"full memslot; this ensures that KVM does not take spinlocks for an extended "
"period of time.  Second, in some cases a large amount of time can pass "
"between a call to KVM_GET_DIRTY_LOG and userspace actually using the data in "
"the page.  Pages can be modified during this time, which is inefficient for "
"both the guest and userspace: the guest will incur a higher penalty due to "
"write protection faults, while userspace can see false reports of dirty "
"pages.  Manual reprotection helps reducing this time, improving guest "
"performance and reducing the number of dirty log false positives."
msgstr ""

#: ../../../virt/kvm/api.rst:7985
msgid ""
"With KVM_DIRTY_LOG_INITIALLY_SET set, all the bits of the dirty bitmap will "
"be initialized to 1 when created.  This also improves performance because "
"dirty logging can be enabled gradually in small chunks on the first call to "
"KVM_CLEAR_DIRTY_LOG.  KVM_DIRTY_LOG_INITIALLY_SET depends on "
"KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE (it is also only available on x86 and "
"arm64 for now)."
msgstr ""

#: ../../../virt/kvm/api.rst:7992
msgid ""
"KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 was previously available under the name "
"KVM_CAP_MANUAL_DIRTY_LOG_PROTECT, but the implementation had bugs that make "
"it hard or impossible to use it correctly.  The availability of "
"KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 signals that those bugs are fixed. "
"Userspace should not try to use KVM_CAP_MANUAL_DIRTY_LOG_PROTECT."
msgstr ""

#: ../../../virt/kvm/api.rst:7999
msgid "7.19 KVM_CAP_PPC_SECURE_GUEST"
msgstr ""

#: ../../../virt/kvm/api.rst:8003
msgid ""
"This capability indicates that KVM is running on a host that has ultravisor "
"firmware and thus can support a secure guest.  On such a system, a guest can "
"ask the ultravisor to make it a secure guest, one whose memory is "
"inaccessible to the host except for pages which are explicitly requested to "
"be shared with the host.  The ultravisor notifies KVM when a guest requests "
"to become a secure guest, and KVM has the opportunity to veto the transition."
msgstr ""

#: ../../../virt/kvm/api.rst:8011
msgid ""
"If present, this capability can be enabled for a VM, meaning that KVM will "
"allow the transition to secure guest mode.  Otherwise KVM will veto the "
"transition."
msgstr ""

#: ../../../virt/kvm/api.rst:8016
msgid "7.20 KVM_CAP_HALT_POLL"
msgstr ""

#: ../../../virt/kvm/api.rst:8019 ../../../virt/kvm/api.rst:8035
#: ../../../virt/kvm/api.rst:8067 ../../../virt/kvm/api.rst:8138
#: ../../../virt/kvm/api.rst:8347 ../../../virt/kvm/api.rst:8368
#: ../../../virt/kvm/api.rst:8397 ../../../virt/kvm/api.rst:8629
#: ../../../virt/kvm/api.rst:8647 ../../../virt/kvm/api.rst:8658
msgid "VM"
msgstr ""

#: ../../../virt/kvm/api.rst:8020
msgid "args[0] is the maximum poll time in nanoseconds"
msgstr ""

#: ../../../virt/kvm/api.rst:8023
msgid ""
"KVM_CAP_HALT_POLL overrides the kvm.halt_poll_ns module parameter to set the "
"maximum halt-polling time for all vCPUs in the target VM. This capability "
"can be invoked at any time and any number of times to dynamically change the "
"maximum halt-polling time."
msgstr ""

#: ../../../virt/kvm/api.rst:8028
msgid ""
"See Documentation/virt/kvm/halt-polling.rst for more information on halt "
"polling."
msgstr ""

#: ../../../virt/kvm/api.rst:8032
msgid "7.21 KVM_CAP_X86_USER_SPACE_MSR"
msgstr ""

#: ../../../virt/kvm/api.rst:8036
msgid "args[0] contains the mask of KVM_MSR_EXIT_REASON_* events to report"
msgstr ""

#: ../../../virt/kvm/api.rst:8039
msgid ""
"This capability allows userspace to intercept RDMSR and WRMSR instructions "
"if access to an MSR is denied.  By default, KVM injects #GP on denied "
"accesses."
msgstr ""

#: ../../../virt/kvm/api.rst:8042
msgid ""
"When a guest requests to read or write an MSR, KVM may not implement all "
"MSRs that are relevant to a respective system. It also does not "
"differentiate by CPU type."
msgstr ""

#: ../../../virt/kvm/api.rst:8046
msgid ""
"To allow more fine grained control over MSR handling, userspace may enable "
"this capability. With it enabled, MSR accesses that match the mask specified "
"in args[0] and would trigger a #GP inside the guest will instead trigger "
"KVM_EXIT_X86_RDMSR and KVM_EXIT_X86_WRMSR exit notifications.  Userspace can "
"then implement model specific MSR handling and/or user notifications to "
"inform a user that an MSR was not emulated/virtualized by KVM."
msgstr ""

#: ../../../virt/kvm/api.rst:8053
msgid "The valid mask flags are:"
msgstr ""

#: ../../../virt/kvm/api.rst:8056
msgid "intercept accesses to unknown (to KVM) MSRs"
msgstr ""

#: ../../../virt/kvm/api.rst:8057
msgid ""
"intercept accesses that are architecturally invalid according to the vCPU "
"model and/or mode"
msgstr ""

#: ../../../virt/kvm/api.rst:8059
msgid ""
"intercept accesses that are denied by userspace via KVM_X86_SET_MSR_FILTER"
msgstr ""

#: ../../../virt/kvm/api.rst:8064
msgid "7.22 KVM_CAP_X86_BUS_LOCK_EXIT"
msgstr ""

#: ../../../virt/kvm/api.rst:8068
msgid "args[0] defines the policy used when bus locks detected in guest"
msgstr ""

#: ../../../virt/kvm/api.rst:8069
msgid "0 on success, -EINVAL when args[0] contains invalid bits"
msgstr ""

#: ../../../virt/kvm/api.rst:8076
msgid ""
"Enabling this capability on a VM provides userspace with a way to select a "
"policy to handle the bus locks detected in guest. Userspace can obtain the "
"supported modes from the result of KVM_CHECK_EXTENSION and define it through "
"the KVM_ENABLE_CAP. The supported modes are mutually-exclusive."
msgstr ""

#: ../../../virt/kvm/api.rst:8081
msgid ""
"This capability allows userspace to force VM exits on bus locks detected in "
"the guest, irrespective whether or not the host has enabled split-lock "
"detection (which triggers an #AC exception that KVM intercepts). This "
"capability is intended to mitigate attacks where a malicious/buggy guest can "
"exploit bus locks to degrade the performance of the whole system."
msgstr ""

#: ../../../virt/kvm/api.rst:8087
msgid ""
"If KVM_BUS_LOCK_DETECTION_OFF is set, KVM doesn't force guest bus locks to "
"VM exit, although the host kernel's split-lock #AC detection still applies, "
"if enabled."
msgstr ""

#: ../../../virt/kvm/api.rst:8091
msgid ""
"If KVM_BUS_LOCK_DETECTION_EXIT is set, KVM enables a CPU feature that "
"ensures bus locks in the guest trigger a VM exit, and KVM exits to userspace "
"for all such VM exits, e.g. to allow userspace to throttle the offending "
"guest and/or apply some other policy-based mitigation. When exiting to "
"userspace, KVM sets KVM_RUN_X86_BUS_LOCK in vcpu-run->flags, and "
"conditionally sets the exit_reason to KVM_EXIT_X86_BUS_LOCK."
msgstr ""

#: ../../../virt/kvm/api.rst:8098
msgid ""
"Due to differences in the underlying hardware implementation, the vCPU's RIP "
"at the time of exit diverges between Intel and AMD.  On Intel hosts, RIP "
"points at the next instruction, i.e. the exit is trap-like.  On AMD hosts, "
"RIP points at the offending instruction, i.e. the exit is fault-like."
msgstr ""

#: ../../../virt/kvm/api.rst:8103
msgid ""
"Note! Detected bus locks may be coincident with other exits to userspace, i."
"e. KVM_RUN_X86_BUS_LOCK should be checked regardless of the primary exit "
"reason if userspace wants to take action on all detected bus locks."
msgstr ""

#: ../../../virt/kvm/api.rst:8108
msgid "7.23 KVM_CAP_PPC_DAWR1"
msgstr ""

#: ../../../virt/kvm/api.rst:8112
msgid "0 on success, -EINVAL when CPU doesn't support 2nd DAWR"
msgstr ""

#: ../../../virt/kvm/api.rst:8114
msgid ""
"This capability can be used to check / enable 2nd DAWR feature provided by "
"POWER10 processor."
msgstr ""

#: ../../../virt/kvm/api.rst:8119
msgid "7.24 KVM_CAP_VM_COPY_ENC_CONTEXT_FROM"
msgstr ""

#: ../../../virt/kvm/api.rst:8121 ../../../virt/kvm/api.rst:8203
msgid "x86 SEV enabled"
msgstr ""

#: ../../../virt/kvm/api.rst:8123 ../../../virt/kvm/api.rst:8205
msgid "args[0] is the fd of the source vm"
msgstr ""

#: ../../../virt/kvm/api.rst:8124
msgid "0 on success; ENOTTY on error"
msgstr ""

#: ../../../virt/kvm/api.rst:8126
msgid ""
"This capability enables userspace to copy encryption context from the vm "
"indicated by the fd to the vm this is called on."
msgstr ""

#: ../../../virt/kvm/api.rst:8129
msgid ""
"This is intended to support in-guest workloads scheduled by the host. This "
"allows the in-guest workload to maintain its own NPTs and keeps the two vms "
"from accidentally clobbering each other with interrupts and the like "
"(separate APIC/MSRs/etc)."
msgstr ""

#: ../../../virt/kvm/api.rst:8135
msgid "7.25 KVM_CAP_SGX_ATTRIBUTE"
msgstr ""

#: ../../../virt/kvm/api.rst:8139
msgid "args[0] is a file handle of a SGX attribute file in securityfs"
msgstr ""

#: ../../../virt/kvm/api.rst:8140
msgid ""
"0 on success, -EINVAL if the file handle is invalid or if a requested "
"attribute is not supported by KVM."
msgstr ""

#: ../../../virt/kvm/api.rst:8143
msgid ""
"KVM_CAP_SGX_ATTRIBUTE enables a userspace VMM to grant a VM access to one or "
"more privileged enclave attributes.  args[0] must hold a file handle to a "
"valid SGX attribute file corresponding to an attribute that is supported/"
"restricted by KVM (currently only PROVISIONKEY)."
msgstr ""

#: ../../../virt/kvm/api.rst:8148
msgid ""
"The SGX subsystem restricts access to a subset of enclave attributes to "
"provide additional security for an uncompromised kernel, e.g. use of the "
"PROVISIONKEY is restricted to deter malware from using the PROVISIONKEY to "
"obtain a stable system fingerprint.  To prevent userspace from circumventing "
"such restrictions by running an enclave in a VM, KVM prevents access to "
"privileged attributes by default."
msgstr ""

#: ../../../virt/kvm/api.rst:8155
msgid "See Documentation/arch/x86/sgx.rst for more details."
msgstr ""

#: ../../../virt/kvm/api.rst:8158
msgid "7.27 KVM_CAP_EXIT_ON_EMULATION_FAILURE"
msgstr ""

#: ../../../virt/kvm/api.rst:8161
msgid "args[0] whether the feature should be enabled or not"
msgstr ""

#: ../../../virt/kvm/api.rst:8163
msgid ""
"When this capability is enabled, an emulation failure will result in an exit "
"to userspace with KVM_INTERNAL_ERROR (except when the emulator was invoked "
"to handle a VMware backdoor instruction). Furthermore, KVM will now provide "
"up to 15 instruction bytes for any exit to userspace resulting from an "
"emulation failure.  When these exits to userspace occur use the "
"emulation_failure struct instead of the internal struct.  They both have the "
"same layout, but the emulation_failure struct matches the content better.  "
"It also explicitly defines the 'flags' field which is used to describe the "
"fields in the struct that are valid (ie: if "
"KVM_INTERNAL_ERROR_EMULATION_FLAG_INSTRUCTION_BYTES is set in the 'flags' "
"field then both 'insn_size' and 'insn_bytes' have valid data in them.)"
msgstr ""

#: ../../../virt/kvm/api.rst:8176
msgid "7.28 KVM_CAP_ARM_MTE"
msgstr ""

#: ../../../virt/kvm/api.rst:8181
msgid ""
"This capability indicates that KVM (and the hardware) supports exposing the "
"Memory Tagging Extensions (MTE) to the guest. It must also be enabled by the "
"VMM before creating any VCPUs to allow the guest access. Note that MTE is "
"only available to a guest running in AArch64 mode and enabling this "
"capability will cause attempts to create AArch32 VCPUs to fail."
msgstr ""

#: ../../../virt/kvm/api.rst:8187
msgid ""
"When enabled the guest is able to access tags associated with any memory "
"given to the guest. KVM will ensure that the tags are maintained during swap "
"or hibernation of the host; however the VMM needs to manually save/restore "
"the tags as appropriate if the VM is migrated."
msgstr ""

#: ../../../virt/kvm/api.rst:8192
msgid ""
"When this capability is enabled all memory in memslots must be mapped as "
"``MAP_ANONYMOUS`` or with a RAM-based file mapping (``tmpfs``, ``memfd``), "
"attempts to create a memslot with an invalid mmap will result in an -EINVAL "
"return."
msgstr ""

#: ../../../virt/kvm/api.rst:8197
msgid ""
"When enabled the VMM may make use of the ``KVM_ARM_MTE_COPY_TAGS`` ioctl to "
"perform a bulk copy of tags to/from the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:8201
msgid "7.29 KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM"
msgstr ""

#: ../../../virt/kvm/api.rst:8206
msgid "0 on success"
msgstr ""

#: ../../../virt/kvm/api.rst:8208
msgid ""
"This capability enables userspace to migrate the encryption context from the "
"VM indicated by the fd to the VM this is called on."
msgstr ""

#: ../../../virt/kvm/api.rst:8211
msgid ""
"This is intended to support intra-host migration of VMs between userspace "
"VMMs, upgrading the VMM process without interrupting the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:8215
msgid "7.31 KVM_CAP_DISABLE_QUIRKS2"
msgstr ""

#: ../../../virt/kvm/api.rst:8217
msgid "args[0] - set of KVM quirks to disable"
msgstr ""

#: ../../../virt/kvm/api.rst:8221
msgid ""
"This capability, if enabled, will cause KVM to disable some behavior quirks."
msgstr ""

#: ../../../virt/kvm/api.rst:8224
msgid ""
"Calling KVM_CHECK_EXTENSION for this capability returns a bitmask of quirks "
"that can be disabled in KVM."
msgstr ""

#: ../../../virt/kvm/api.rst:8227
msgid ""
"The argument to KVM_ENABLE_CAP for this capability is a bitmask of quirks to "
"disable, and must be a subset of the bitmask returned by KVM_CHECK_EXTENSION."
msgstr ""

#: ../../../virt/kvm/api.rst:8231
msgid "The valid bits in cap.args[0] are:"
msgstr ""

#: ../../../virt/kvm/api.rst:8234
msgid "KVM_X86_QUIRK_LINT0_REENABLED"
msgstr ""

#: ../../../virt/kvm/api.rst:8234
msgid ""
"By default, the reset value for the LVT LINT0 register is 0x700 "
"(APIC_MODE_EXTINT). When this quirk is disabled, the reset value is 0x10000 "
"(APIC_LVT_MASKED)."
msgstr ""

#: ../../../virt/kvm/api.rst:8239
msgid "KVM_X86_QUIRK_CD_NW_CLEARED"
msgstr ""

#: ../../../virt/kvm/api.rst:8239
msgid ""
"By default, KVM clears CR0.CD and CR0.NW on AMD CPUs to workaround buggy "
"guest firmware that runs in perpetuity with CR0.CD, i.e. with caches in \"no "
"fill\" mode."
msgstr ""

#: ../../../virt/kvm/api.rst:8244
msgid ""
"When this quirk is disabled, KVM does not change the value of CR0.CD and CR0."
"NW."
msgstr ""

#: ../../../virt/kvm/api.rst:8247
msgid "KVM_X86_QUIRK_LAPIC_MMIO_HOLE"
msgstr ""

#: ../../../virt/kvm/api.rst:8247
msgid ""
"By default, the MMIO LAPIC interface is available even when configured for "
"x2APIC mode. When this quirk is disabled, KVM disables the MMIO LAPIC "
"interface if the LAPIC is in x2APIC mode."
msgstr ""

#: ../../../virt/kvm/api.rst:8253
msgid "KVM_X86_QUIRK_OUT_7E_INC_RIP"
msgstr ""

#: ../../../virt/kvm/api.rst:8253
msgid ""
"By default, KVM pre-increments %rip before exiting to userspace for an OUT "
"instruction to port 0x7e. When this quirk is disabled, KVM does not pre-"
"increment %rip before exiting to userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:8259
msgid "KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT"
msgstr ""

#: ../../../virt/kvm/api.rst:8259
msgid ""
"When this quirk is disabled, KVM sets CPUID.01H:ECX[bit 3] (MONITOR/MWAIT) "
"if IA32_MISC_ENABLE[bit 18] (MWAIT) is set. Additionally, when this quirk is "
"disabled, KVM clears CPUID.01H:ECX[bit 3] if IA32_MISC_ENABLE[bit 18] is "
"cleared."
msgstr ""

#: ../../../virt/kvm/api.rst:8266
msgid "KVM_X86_QUIRK_FIX_HYPERCALL_INSN"
msgstr ""

#: ../../../virt/kvm/api.rst:8266
msgid ""
"By default, KVM rewrites guest VMMCALL/VMCALL instructions to match the "
"vendor's hypercall instruction for the system. When this quirk is disabled, "
"KVM will no longer rewrite invalid guest hypercall instructions. Executing "
"the incorrect hypercall instruction will generate a #UD within the guest."
msgstr ""

#: ../../../virt/kvm/api.rst:8275
msgid "KVM_X86_QUIRK_MWAIT_NEVER_UD_FAULTS"
msgstr ""

#: ../../../virt/kvm/api.rst:8275
msgid ""
"By default, KVM emulates MONITOR/MWAIT (if they are intercepted) as NOPs "
"regardless of whether or not MONITOR/MWAIT are supported according to guest "
"CPUID.  When this quirk is disabled and KVM_X86_DISABLE_EXITS_MWAIT is not "
"set (MONITOR/MWAIT are intercepted), KVM will inject a #UD on MONITOR/MWAIT "
"if they're unsupported per guest CPUID.  Note, KVM will modify MONITOR/MWAIT "
"support in guest CPUID on writes to MISC_ENABLE if "
"KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT is disabled."
msgstr ""

#: ../../../virt/kvm/api.rst:8288
msgid "KVM_X86_QUIRK_SLOT_ZAP_ALL"
msgstr ""

#: ../../../virt/kvm/api.rst:8288
msgid ""
"By default, for KVM_X86_DEFAULT_VM VMs, KVM invalidates all SPTEs in all "
"memslots and address spaces when a memslot is deleted or moved.  When this "
"quirk is disabled (or the VM type isn't KVM_X86_DEFAULT_VM), KVM only "
"ensures the backing memory of the deleted or moved memslot isn't reachable, "
"i.e KVM _may_ invalidate only SPTEs related to the memslot."
msgstr ""

#: ../../../virt/kvm/api.rst:8298
msgid "KVM_X86_QUIRK_STUFF_FEATURE_MSRS"
msgstr ""

#: ../../../virt/kvm/api.rst:8298
msgid ""
"By default, at vCPU creation, KVM sets the vCPU's MSR_IA32_PERF_CAPABILITIES "
"(0x345), MSR_IA32_ARCH_CAPABILITIES (0x10a), MSR_PLATFORM_INFO (0xce), and "
"all VMX MSRs (0x480..0x492) to the maximal capabilities supported by KVM.  "
"KVM also sets MSR_IA32_UCODE_REV (0x8b) to an arbitrary value (which is "
"different for Intel vs. AMD).  Lastly, when guest CPUID is set (by "
"userspace), KVM modifies select VMX MSR fields to force consistency between "
"guest CPUID and L2's effective ISA.  When this quirk is disabled, KVM zeroes "
"the vCPU's MSR values (with two exceptions, see below), i.e. treats the "
"feature MSRs like CPUID leaves and gives userspace full control of the vCPU "
"model definition.  This quirk does not affect VMX MSRs CR0/CR4_FIXED1 (0x487 "
"and 0x489), as KVM does now allow them to be set by userspace (KVM sets them "
"based on guest CPUID, for safety purposes)."
msgstr ""

#: ../../../virt/kvm/api.rst:8320
msgid "KVM_X86_QUIRK_IGNORE_GUEST_PAT"
msgstr ""

#: ../../../virt/kvm/api.rst:8320
msgid ""
"By default, on Intel platforms, KVM ignores guest PAT and forces the "
"effective memory type to WB in EPT.  The quirk is not available on Intel "
"platforms which are incapable of safely honoring guest PAT (i.e., without "
"CPU self-snoop, KVM always ignores guest PAT and forces effective memory "
"type to WB).  It is also ignored on AMD platforms or, on Intel, when a VM "
"has non-coherent DMA devices assigned; KVM always honors guest PAT in such "
"case. The quirk is needed to avoid slowdowns on certain Intel Xeon platforms "
"(e.g. ICX, SPR) where self-snoop feature is supported but UC is slow enough "
"to cause issues with some older guests that use UC instead of WC to map the "
"video RAM. Userspace can disable the quirk to honor guest PAT if it knows "
"that there is no such guest software, for example if it does not expose a "
"bochs graphics device (which is known to have had a buggy driver)."
msgstr ""

#: ../../../virt/kvm/api.rst:8344
msgid "7.32 KVM_CAP_MAX_VCPU_ID"
msgstr ""

#: ../../../virt/kvm/api.rst:8348
msgid "args[0] - maximum APIC ID value set for current VM"
msgstr ""

#: ../../../virt/kvm/api.rst:8349
msgid ""
"0 on success, -EINVAL if args[0] is beyond KVM_MAX_VCPU_IDS supported in KVM "
"or if it has been set."
msgstr ""

#: ../../../virt/kvm/api.rst:8352
msgid ""
"This capability allows userspace to specify maximum possible APIC ID "
"assigned for current VM session prior to the creation of vCPUs, saving "
"memory for data structures indexed by the APIC ID.  Userspace is able to "
"calculate the limit to APIC ID values from designated CPU topology."
msgstr ""

#: ../../../virt/kvm/api.rst:8358
msgid ""
"The value can be changed only until KVM_ENABLE_CAP is set to a nonzero value "
"or until a vCPU is created.  Upon creation of the first vCPU, if the value "
"was set to zero or KVM_ENABLE_CAP was not invoked, KVM uses the return value "
"of KVM_CHECK_EXTENSION(KVM_CAP_MAX_VCPU_ID) as the maximum APIC ID."
msgstr ""

#: ../../../virt/kvm/api.rst:8365
msgid "7.33 KVM_CAP_X86_NOTIFY_VMEXIT"
msgstr ""

#: ../../../virt/kvm/api.rst:8369
msgid "args[0] is the value of notify window as well as some flags"
msgstr ""

#: ../../../virt/kvm/api.rst:8370
msgid ""
"0 on success, -EINVAL if args[0] contains invalid flags or notify VM exit is "
"unsupported."
msgstr ""

#: ../../../virt/kvm/api.rst:8373
msgid ""
"Bits 63:32 of args[0] are used for notify window. Bits 31:0 of args[0] are "
"for some flags. Valid bits are::"
msgstr ""

#: ../../../virt/kvm/api.rst:8379
msgid ""
"This capability allows userspace to configure the notify VM exit on/off in "
"per-VM scope during VM creation. Notify VM exit is disabled by default. When "
"userspace sets KVM_X86_NOTIFY_VMEXIT_ENABLED bit in args[0], VMM will enable "
"this feature with the notify window provided, which will generate a VM exit "
"if no event window occurs in VM non-root mode for a specified of time "
"(notify window)."
msgstr ""

#: ../../../virt/kvm/api.rst:8386
msgid ""
"If KVM_X86_NOTIFY_VMEXIT_USER is set in args[0], upon notify VM exits "
"happen, KVM would exit to userspace for handling."
msgstr ""

#: ../../../virt/kvm/api.rst:8389
msgid ""
"This capability is aimed to mitigate the threat that malicious VMs can cause "
"CPU stuck (due to event windows don't open up) and make the CPU unavailable "
"to host or other VMs."
msgstr ""

#: ../../../virt/kvm/api.rst:8394
msgid "7.35 KVM_CAP_X86_APIC_BUS_CYCLES_NS"
msgstr ""

#: ../../../virt/kvm/api.rst:8398
msgid "args[0] is the desired APIC bus clock rate, in nanoseconds"
msgstr ""

#: ../../../virt/kvm/api.rst:8399
msgid ""
"0 on success, -EINVAL if args[0] contains an invalid value for the frequency "
"or if any vCPUs have been created, -ENXIO if a virtual local APIC has not "
"been created using KVM_CREATE_IRQCHIP."
msgstr ""

#: ../../../virt/kvm/api.rst:8403
msgid ""
"This capability sets the VM's APIC bus clock frequency, used by KVM's in-"
"kernel virtual APIC when emulating APIC timers.  KVM's default value can be "
"retrieved by KVM_CHECK_EXTENSION."
msgstr ""

#: ../../../virt/kvm/api.rst:8407
msgid ""
"Note: Userspace is responsible for correctly configuring CPUID 0x15, a.k.a. "
"the core crystal clock frequency, if a non-zero CPUID 0x15 is exposed to the "
"guest."
msgstr ""

#: ../../../virt/kvm/api.rst:8411
msgid "7.36 KVM_CAP_DIRTY_LOG_RING/KVM_CAP_DIRTY_LOG_RING_ACQ_REL"
msgstr ""

#: ../../../virt/kvm/api.rst:8413
msgid "x86, arm64, riscv"
msgstr ""

#: ../../../virt/kvm/api.rst:8415
msgid "args[0] - size of the dirty log ring"
msgstr ""

#: ../../../virt/kvm/api.rst:8417
msgid ""
"KVM is capable of tracking dirty memory using ring buffers that are mmapped "
"into userspace; there is one dirty ring per vcpu."
msgstr ""

#: ../../../virt/kvm/api.rst:8420
msgid ""
"The dirty ring is available to userspace as an array of ``struct "
"kvm_dirty_gfn``.  Each dirty entry is defined as::"
msgstr ""

#: ../../../virt/kvm/api.rst:8429
msgid ""
"The following values are defined for the flags field to define the current "
"state of the entry::"
msgstr ""

#: ../../../virt/kvm/api.rst:8436
msgid ""
"Userspace should call KVM_ENABLE_CAP ioctl right after KVM_CREATE_VM ioctl "
"to enable this capability for the new guest and set the size of the rings.  "
"Enabling the capability is only allowed before creating any vCPU, and the "
"size of the ring must be a power of two.  The larger the ring buffer, the "
"less likely the ring is full and the VM is forced to exit to userspace. The "
"optimal size depends on the workload, but it is recommended that it be at "
"least 64 KiB (4096 entries)."
msgstr ""

#: ../../../virt/kvm/api.rst:8444
msgid ""
"Just like for dirty page bitmaps, the buffer tracks writes to all user "
"memory regions for which the KVM_MEM_LOG_DIRTY_PAGES flag was set in "
"KVM_SET_USER_MEMORY_REGION.  Once a memory region is registered with the "
"flag set, userspace can start harvesting dirty pages from the ring buffer."
msgstr ""

#: ../../../virt/kvm/api.rst:8450
msgid ""
"An entry in the ring buffer can be unused (flag bits ``00``), dirty (flag "
"bits ``01``) or harvested (flag bits ``1X``).  The state machine for the "
"entry is as follows::"
msgstr ""

#: ../../../virt/kvm/api.rst:8460
msgid ""
"To harvest the dirty pages, userspace accesses the mmapped ring buffer to "
"read the dirty GFNs.  If the flags has the DIRTY bit set (at this stage the "
"RESET bit must be cleared), then it means this GFN is a dirty GFN. The "
"userspace should harvest this GFN and mark the flags from state ``01b`` to "
"``1Xb`` (bit 0 will be ignored by KVM, but bit 1 must be set to show that "
"this GFN is harvested and waiting for a reset), and move on to the next "
"GFN.  The userspace should continue to do this until the flags of a GFN have "
"the DIRTY bit cleared, meaning that it has harvested all the dirty GFNs that "
"were available."
msgstr ""

#: ../../../virt/kvm/api.rst:8470
msgid ""
"Note that on weakly ordered architectures, userspace accesses to the ring "
"buffer (and more specifically the 'flags' field) must be ordered, using load-"
"acquire/store-release accessors when available, or any other memory barrier "
"that will ensure this ordering."
msgstr ""

#: ../../../virt/kvm/api.rst:8475
msgid ""
"It's not necessary for userspace to harvest the all dirty GFNs at once. "
"However it must collect the dirty GFNs in sequence, i.e., the userspace "
"program cannot skip one dirty GFN to collect the one next to it."
msgstr ""

#: ../../../virt/kvm/api.rst:8479
msgid ""
"After processing one or more entries in the ring buffer, userspace calls the "
"VM ioctl KVM_RESET_DIRTY_RINGS to notify the kernel about it, so that the "
"kernel will reprotect those collected GFNs. Therefore, the ioctl must be "
"called *before* reading the content of the dirty pages."
msgstr ""

#: ../../../virt/kvm/api.rst:8485
msgid ""
"The dirty ring can get full.  When it happens, the KVM_RUN of the vcpu will "
"return with exit reason KVM_EXIT_DIRTY_LOG_FULL."
msgstr ""

#: ../../../virt/kvm/api.rst:8488
msgid ""
"The dirty ring interface has a major difference comparing to the "
"KVM_GET_DIRTY_LOG interface in that, when reading the dirty ring from "
"userspace, it's still possible that the kernel has not yet flushed the "
"processor's dirty page buffers into the kernel buffer (with dirty bitmaps, "
"the flushing is done by the KVM_GET_DIRTY_LOG ioctl).  To achieve that, one "
"needs to kick the vcpu out of KVM_RUN using a signal.  The resulting vmexit "
"ensures that all dirty GFNs are flushed to the dirty rings."
msgstr ""

#: ../../../virt/kvm/api.rst:8496
msgid ""
"NOTE: KVM_CAP_DIRTY_LOG_RING_ACQ_REL is the only capability that should be "
"exposed by weakly ordered architecture, in order to indicate the additional "
"memory ordering requirements imposed on userspace when reading the state of "
"an entry and mutating it from DIRTY to HARVESTED. Architecture with TSO-like "
"ordering (such as x86) are allowed to expose both KVM_CAP_DIRTY_LOG_RING and "
"KVM_CAP_DIRTY_LOG_RING_ACQ_REL to userspace."
msgstr ""

#: ../../../virt/kvm/api.rst:8504
msgid ""
"After enabling the dirty rings, the userspace needs to detect the capability "
"of KVM_CAP_DIRTY_LOG_RING_WITH_BITMAP to see whether the ring structures can "
"be backed by per-slot bitmaps. With this capability advertised, it means the "
"architecture can dirty guest pages without vcpu/ring context, so that some "
"of the dirty information will still be maintained in the bitmap structure. "
"KVM_CAP_DIRTY_LOG_RING_WITH_BITMAP can't be enabled if the capability of "
"KVM_CAP_DIRTY_LOG_RING_ACQ_REL hasn't been enabled, or any memslot has been "
"existing."
msgstr ""

#: ../../../virt/kvm/api.rst:8513
msgid ""
"Note that the bitmap here is only a backup of the ring structure. The use of "
"the ring and bitmap combination is only beneficial if there is only a very "
"small amount of memory that is dirtied out of vcpu/ring context. Otherwise, "
"the stand-alone per-slot bitmap mechanism needs to be considered."
msgstr ""

#: ../../../virt/kvm/api.rst:8519
msgid ""
"To collect dirty bits in the backup bitmap, userspace can use the same "
"KVM_GET_DIRTY_LOG ioctl. KVM_CLEAR_DIRTY_LOG isn't needed as long as all the "
"generation of the dirty bits is done in a single pass. Collecting the dirty "
"bitmap should be the very last thing that the VMM does before considering "
"the state as complete. VMM needs to ensure that the dirty state is final and "
"avoid missing dirty pages from another ioctl ordered after the bitmap "
"collection."
msgstr ""

#: ../../../virt/kvm/api.rst:8527
msgid ""
"NOTE: Multiple examples of using the backup bitmap: (1) save vgic/its tables "
"through command KVM_DEV_ARM_{VGIC_GRP_CTRL, ITS_SAVE_TABLES} on KVM device "
"\"kvm-arm-vgic-its\". (2) restore vgic/its tables through command "
"KVM_DEV_ARM_{VGIC_GRP_CTRL, ITS_RESTORE_TABLES} on KVM device \"kvm-arm-vgic-"
"its\". VGICv3 LPI pending status is restored. (3) save vgic3 pending table "
"through KVM_DEV_ARM_VGIC_{GRP_CTRL, SAVE_PENDING_TABLES} command on KVM "
"device \"kvm-arm-vgic-v3\"."
msgstr ""

#: ../../../virt/kvm/api.rst:8536
msgid "7.37 KVM_CAP_PMU_CAPABILITY"
msgstr ""

#: ../../../virt/kvm/api.rst:8540
msgid "arg[0] is bitmask of PMU virtualization capabilities."
msgstr ""

#: ../../../virt/kvm/api.rst:8541
msgid "0 on success, -EINVAL when arg[0] contains invalid bits"
msgstr ""

#: ../../../virt/kvm/api.rst:8543
msgid "This capability alters PMU virtualization in KVM."
msgstr ""

#: ../../../virt/kvm/api.rst:8545
msgid ""
"Calling KVM_CHECK_EXTENSION for this capability returns a bitmask of PMU "
"virtualization capabilities that can be adjusted on a VM."
msgstr ""

#: ../../../virt/kvm/api.rst:8548
msgid ""
"The argument to KVM_ENABLE_CAP is also a bitmask and selects specific PMU "
"virtualization capabilities to be applied to the VM.  This can only be "
"invoked on a VM prior to the creation of VCPUs."
msgstr ""

#: ../../../virt/kvm/api.rst:8552
msgid ""
"At this time, KVM_PMU_CAP_DISABLE is the only capability.  Setting this "
"capability will disable PMU virtualization for that VM.  Usermode should "
"adjust CPUID leaf 0xA to reflect that the PMU is disabled."
msgstr ""

#: ../../../virt/kvm/api.rst:8557
msgid "7.38 KVM_CAP_VM_DISABLE_NX_HUGE_PAGES"
msgstr ""

#: ../../../virt/kvm/api.rst:8561
msgid "arg[0] must be 0."
msgstr ""

#: ../../../virt/kvm/api.rst:8562
msgid ""
"0 on success, -EPERM if the userspace process does not have CAP_SYS_BOOT, -"
"EINVAL if args[0] is not 0 or any vCPUs have been created."
msgstr ""

#: ../../../virt/kvm/api.rst:8566
msgid ""
"This capability disables the NX huge pages mitigation for iTLB MULTIHIT."
msgstr ""

#: ../../../virt/kvm/api.rst:8568
msgid ""
"The capability has no effect if the nx_huge_pages module parameter is not "
"set."
msgstr ""

#: ../../../virt/kvm/api.rst:8570
msgid "This capability may only be set before any vCPUs are created."
msgstr ""

#: ../../../virt/kvm/api.rst:8573
msgid "7.39 KVM_CAP_ARM_EAGER_SPLIT_CHUNK_SIZE"
msgstr ""

#: ../../../virt/kvm/api.rst:8577
msgid "arg[0] is the new split chunk size."
msgstr ""

#: ../../../virt/kvm/api.rst:8578
msgid "0 on success, -EINVAL if any memslot was already created."
msgstr ""

#: ../../../virt/kvm/api.rst:8580
msgid "This capability sets the chunk size used in Eager Page Splitting."
msgstr ""

#: ../../../virt/kvm/api.rst:8582
msgid ""
"Eager Page Splitting improves the performance of dirty-logging (used in live "
"migrations) when guest memory is backed by huge-pages.  It avoids splitting "
"huge-pages (into PAGE_SIZE pages) on fault, by doing it eagerly when "
"enabling dirty logging (with the KVM_MEM_LOG_DIRTY_PAGES flag for a memory "
"region), or when using KVM_CLEAR_DIRTY_LOG."
msgstr ""

#: ../../../virt/kvm/api.rst:8589
msgid ""
"The chunk size specifies how many pages to break at a time, using a single "
"allocation for each chunk. Bigger the chunk size, more pages need to be "
"allocated ahead of time."
msgstr ""

#: ../../../virt/kvm/api.rst:8593
msgid ""
"The chunk size needs to be a valid block size. The list of acceptable block "
"sizes is exposed in KVM_CAP_ARM_SUPPORTED_BLOCK_SIZES as a 64-bit bitmap "
"(each bit describing a block size). The default value is 0, to disable the "
"eager page splitting."
msgstr ""

#: ../../../virt/kvm/api.rst:8599
msgid "7.40 KVM_CAP_EXIT_HYPERCALL"
msgstr ""

#: ../../../virt/kvm/api.rst:8604
msgid ""
"This capability, if enabled, will cause KVM to exit to userspace with "
"KVM_EXIT_HYPERCALL exit reason to process some hypercalls."
msgstr ""

#: ../../../virt/kvm/api.rst:8607
msgid ""
"Calling KVM_CHECK_EXTENSION for this capability will return a bitmask of "
"hypercalls that can be configured to exit to userspace. Right now, the only "
"such hypercall is KVM_HC_MAP_GPA_RANGE."
msgstr ""

#: ../../../virt/kvm/api.rst:8611
msgid ""
"The argument to KVM_ENABLE_CAP is also a bitmask, and must be a subset of "
"the result of KVM_CHECK_EXTENSION.  KVM will forward to userspace the "
"hypercalls whose corresponding bit is in the argument, and return ENOSYS for "
"the others."
msgstr ""

#: ../../../virt/kvm/api.rst:8617
msgid "7.41 KVM_CAP_ARM_SYSTEM_SUSPEND"
msgstr ""

#: ../../../virt/kvm/api.rst:8622
msgid ""
"When enabled, KVM will exit to userspace with KVM_EXIT_SYSTEM_EVENT of type "
"KVM_SYSTEM_EVENT_SUSPEND to process the guest suspend request."
msgstr ""

#: ../../../virt/kvm/api.rst:8626
msgid "7.42 KVM_CAP_ARM_WRITABLE_IMP_ID_REGS"
msgstr ""

#: ../../../virt/kvm/api.rst:8631
msgid ""
"0 on success, -EINVAL if vCPUs have been created before enabling this "
"capability."
msgstr ""

#: ../../../virt/kvm/api.rst:8634
msgid ""
"This capability changes the behavior of the registers that identify a PE "
"implementation of the Arm architecture: MIDR_EL1, REVIDR_EL1, and AIDR_EL1. "
"By default, these registers are visible to userspace but treated as "
"invariant."
msgstr ""

#: ../../../virt/kvm/api.rst:8638
msgid ""
"When this capability is enabled, KVM allows userspace to change the "
"aforementioned registers before the first KVM_RUN. These registers are VM "
"scoped, meaning that the same set of values are presented on all vCPUs in a "
"given VM."
msgstr ""

#: ../../../virt/kvm/api.rst:8644
msgid "7.43 KVM_CAP_RISCV_MP_STATE_RESET"
msgstr ""

#: ../../../virt/kvm/api.rst:8646
msgid "riscv"
msgstr ""

#: ../../../virt/kvm/api.rst:8649
msgid "0 on success, -EINVAL if arg[0] is not zero"
msgstr ""

#: ../../../virt/kvm/api.rst:8651
msgid ""
"When this capability is enabled, KVM resets the VCPU when setting "
"MP_STATE_INIT_RECEIVED through IOCTL.  The original MP_STATE is preserved."
msgstr ""

#: ../../../virt/kvm/api.rst:8655
msgid "7.43 KVM_CAP_ARM_CACHEABLE_PFNMAP_SUPPORTED"
msgstr ""

#: ../../../virt/kvm/api.rst:8661
msgid ""
"This capability indicate to the userspace whether a PFNMAP memory region can "
"be safely mapped as cacheable. This relies on the presence of force write "
"back (FWB) feature support on the hardware."
msgstr ""

#: ../../../virt/kvm/api.rst:8666
msgid "8. Other capabilities."
msgstr ""

#: ../../../virt/kvm/api.rst:8668
msgid ""
"This section lists capabilities that give information about other features "
"of the KVM implementation."
msgstr ""

#: ../../../virt/kvm/api.rst:8672
msgid "8.1 KVM_CAP_PPC_HWRNG"
msgstr ""

#: ../../../virt/kvm/api.rst:8676
msgid ""
"This capability, if KVM_CHECK_EXTENSION indicates that it is available, "
"means that the kernel has an implementation of the H_RANDOM hypercall backed "
"by a hardware random-number generator. If present, the kernel H_RANDOM "
"handler can be enabled for guest use with the KVM_CAP_PPC_ENABLE_HCALL "
"capability."
msgstr ""

#: ../../../virt/kvm/api.rst:8683
msgid "8.3 KVM_CAP_PPC_MMU_RADIX"
msgstr ""

#: ../../../virt/kvm/api.rst:8687
msgid ""
"This capability, if KVM_CHECK_EXTENSION indicates that it is available, "
"means that the kernel can support guests using the radix MMU defined in "
"Power ISA V3.00 (as implemented in the POWER9 processor)."
msgstr ""

#: ../../../virt/kvm/api.rst:8693
msgid "8.4 KVM_CAP_PPC_MMU_HASH_V3"
msgstr ""

#: ../../../virt/kvm/api.rst:8697
msgid ""
"This capability, if KVM_CHECK_EXTENSION indicates that it is available, "
"means that the kernel can support guests using the hashed page table MMU "
"defined in Power ISA V3.00 (as implemented in the POWER9 processor), "
"including in-memory segment tables."
msgstr ""

#: ../../../virt/kvm/api.rst:8703
msgid "8.5 KVM_CAP_MIPS_VZ"
msgstr ""

#: ../../../virt/kvm/api.rst:8707
msgid ""
"This capability, if KVM_CHECK_EXTENSION on the main kvm handle indicates "
"that it is available, means that full hardware assisted virtualization "
"capabilities of the hardware are available for use through KVM. An "
"appropriate KVM_VM_MIPS_* type must be passed to KVM_CREATE_VM to create a "
"VM which utilises it."
msgstr ""

#: ../../../virt/kvm/api.rst:8713
msgid ""
"If KVM_CHECK_EXTENSION on a kvm VM handle indicates that this capability is "
"available, it means that the VM is using full hardware assisted "
"virtualization capabilities of the hardware. This is useful to check after "
"creating a VM with KVM_VM_MIPS_DEFAULT."
msgstr ""

#: ../../../virt/kvm/api.rst:8718
msgid ""
"The value returned by KVM_CHECK_EXTENSION should be compared against known "
"values (see below). All other values are reserved. This is to allow for the "
"possibility of other hardware assisted virtualization implementations which "
"may be incompatible with the MIPS VZ ASE."
msgstr ""

#: ../../../virt/kvm/api.rst:8724
msgid ""
"The trap & emulate implementation is in use to run guest code in user mode. "
"Guest virtual memory segments are rearranged to fit the guest in the user "
"mode address space."
msgstr ""

#: ../../../virt/kvm/api.rst:8728 ../../../virt/kvm/api.rst:8750
msgid "1"
msgstr ""

#: ../../../virt/kvm/api.rst:8728
msgid ""
"The MIPS VZ ASE is in use, providing full hardware assisted virtualization, "
"including standard guest virtual memory segments."
msgstr ""

#: ../../../virt/kvm/api.rst:8733
msgid "8.7 KVM_CAP_MIPS_64BIT"
msgstr ""

#: ../../../virt/kvm/api.rst:8737
msgid ""
"This capability indicates the supported architecture type of the guest, i.e. "
"the supported register and address width."
msgstr ""

#: ../../../virt/kvm/api.rst:8740
msgid ""
"The values returned when this capability is checked by KVM_CHECK_EXTENSION "
"on a kvm VM handle correspond roughly to the CP0_Config.AT register field, "
"and should be checked specifically against known values (see below). All "
"other values are reserved."
msgstr ""

#: ../../../virt/kvm/api.rst:8746
msgid ""
"MIPS32 or microMIPS32. Both registers and addresses are 32-bits wide. It "
"will only be possible to run 32-bit guest code."
msgstr ""

#: ../../../virt/kvm/api.rst:8750
msgid ""
"MIPS64 or microMIPS64 with access only to 32-bit compatibility segments. "
"Registers are 64-bits wide, but addresses are 32-bits wide. 64-bit guest "
"code may run but cannot access MIPS64 memory segments. It will also be "
"possible to run 32-bit guest code."
msgstr ""

#: ../../../virt/kvm/api.rst:8755
msgid "2"
msgstr ""

#: ../../../virt/kvm/api.rst:8755
msgid ""
"MIPS64 or microMIPS64 with access to all address segments. Both registers "
"and addresses are 64-bits wide. It will be possible to run 64-bit or 32-bit "
"guest code."
msgstr ""

#: ../../../virt/kvm/api.rst:8761
msgid "8.9 KVM_CAP_ARM_USER_IRQ"
msgstr ""

#: ../../../virt/kvm/api.rst:8765
msgid ""
"This capability, if KVM_CHECK_EXTENSION indicates that it is available, "
"means that if userspace creates a VM without an in-kernel interrupt "
"controller, it will be notified of changes to the output level of in-kernel "
"emulated devices, which can generate virtual interrupts, presented to the "
"VM. For such VMs, on every return to userspace, the kernel updates the "
"vcpu's run->s.regs.device_irq_level field to represent the actual output "
"level of the device."
msgstr ""

#: ../../../virt/kvm/api.rst:8773
msgid ""
"Whenever kvm detects a change in the device output level, kvm guarantees at "
"least one return to userspace before running the VM.  This exit could either "
"be a KVM_EXIT_INTR or any other exit event, like KVM_EXIT_MMIO. This way, "
"userspace can always sample the device output level and re-compute the state "
"of the userspace interrupt controller.  Userspace should always check the "
"state of run->s.regs.device_irq_level on every kvm exit. The value in run->s."
"regs.device_irq_level can represent both level and edge triggered interrupt "
"signals, depending on the device.  Edge triggered interrupt signals will "
"exit to userspace with the bit in run->s.regs.device_irq_level set exactly "
"once per edge signal."
msgstr ""

#: ../../../virt/kvm/api.rst:8784
msgid ""
"The field run->s.regs.device_irq_level is available independent of run-"
">kvm_valid_regs or run->kvm_dirty_regs bits."
msgstr ""

#: ../../../virt/kvm/api.rst:8787
msgid ""
"If KVM_CAP_ARM_USER_IRQ is supported, the KVM_CHECK_EXTENSION ioctl returns "
"a number larger than 0 indicating the version of this capability is "
"implemented and thereby which bits in run->s.regs.device_irq_level can "
"signal values."
msgstr ""

#: ../../../virt/kvm/api.rst:8791
msgid ""
"Currently the following bits are defined for the device_irq_level bitmap::"
msgstr ""

#: ../../../virt/kvm/api.rst:8799
msgid ""
"Future versions of kvm may implement additional events. These will get "
"indicated by returning a higher number from KVM_CHECK_EXTENSION and will be "
"listed above."
msgstr ""

#: ../../../virt/kvm/api.rst:8804
msgid "8.10 KVM_CAP_PPC_SMT_POSSIBLE"
msgstr ""

#: ../../../virt/kvm/api.rst:8808
msgid ""
"Querying this capability returns a bitmap indicating the possible virtual "
"SMT modes that can be set using KVM_CAP_PPC_SMT.  If bit N (counting from "
"the right) is set, then a virtual SMT mode of 2^N is available."
msgstr ""

#: ../../../virt/kvm/api.rst:8814
msgid "8.12 KVM_CAP_HYPERV_VP_INDEX"
msgstr ""

#: ../../../virt/kvm/api.rst:8818
msgid ""
"This capability indicates that userspace can load HV_X64_MSR_VP_INDEX msr.  "
"Its value is used to denote the target vcpu for a SynIC interrupt.  For "
"compatibility, KVM initializes this msr to KVM's internal vcpu index.  When "
"this capability is absent, userspace can still query this msr's value."
msgstr ""

#: ../../../virt/kvm/api.rst:8824
msgid "8.13 KVM_CAP_S390_AIS_MIGRATION"
msgstr ""

#: ../../../virt/kvm/api.rst:8828
msgid ""
"This capability indicates if the flic device will be able to get/set the AIS "
"states for migration via the KVM_DEV_FLIC_AISM_ALL attribute and allows to "
"discover this without having to create a flic device."
msgstr ""

#: ../../../virt/kvm/api.rst:8833
msgid "8.14 KVM_CAP_S390_PSW"
msgstr ""

#: ../../../virt/kvm/api.rst:8837
msgid ""
"This capability indicates that the PSW is exposed via the kvm_run structure."
msgstr ""

#: ../../../virt/kvm/api.rst:8840
msgid "8.15 KVM_CAP_S390_GMAP"
msgstr ""

#: ../../../virt/kvm/api.rst:8844
msgid ""
"This capability indicates that the user space memory used as guest mapping "
"can be anywhere in the user memory address space, as long as the memory "
"slots are aligned and sized to a segment (1MB) boundary."
msgstr ""

#: ../../../virt/kvm/api.rst:8849
msgid "8.16 KVM_CAP_S390_COW"
msgstr ""

#: ../../../virt/kvm/api.rst:8853
msgid ""
"This capability indicates that the user space memory used as guest mapping "
"can use copy-on-write semantics as well as dirty pages tracking via read-"
"only page tables."
msgstr ""

#: ../../../virt/kvm/api.rst:8858
msgid "8.17 KVM_CAP_S390_BPB"
msgstr ""

#: ../../../virt/kvm/api.rst:8862
msgid ""
"This capability indicates that kvm will implement the interfaces to handle "
"reset, migration and nested KVM for branch prediction blocking. The stfle "
"facility 82 should not be provided to the guest without this capability."
msgstr ""

#: ../../../virt/kvm/api.rst:8867
msgid "8.18 KVM_CAP_HYPERV_TLBFLUSH"
msgstr ""

#: ../../../virt/kvm/api.rst:8871
msgid ""
"This capability indicates that KVM supports paravirtualized Hyper-V TLB "
"Flush hypercalls: HvFlushVirtualAddressSpace, HvFlushVirtualAddressSpaceEx, "
"HvFlushVirtualAddressList, HvFlushVirtualAddressListEx."
msgstr ""

#: ../../../virt/kvm/api.rst:8877
msgid "8.19 KVM_CAP_ARM_INJECT_SERROR_ESR"
msgstr ""

#: ../../../virt/kvm/api.rst:8881
msgid ""
"This capability indicates that userspace can specify (via the "
"KVM_SET_VCPU_EVENTS ioctl) the syndrome value reported to the guest when it "
"takes a virtual SError interrupt exception. If KVM advertises this "
"capability, userspace can only specify the ISS field for the ESR syndrome. "
"Other parts of the ESR, such as the EC are generated by the CPU when the "
"exception is taken. If this virtual SError is taken to EL1 using AArch64, "
"this value will be reported in the ISS field of ESR_ELx."
msgstr ""

#: ../../../virt/kvm/api.rst:8889
msgid "See KVM_CAP_VCPU_EVENTS for more details."
msgstr ""

#: ../../../virt/kvm/api.rst:8892
msgid "8.20 KVM_CAP_HYPERV_SEND_IPI"
msgstr ""

#: ../../../virt/kvm/api.rst:8896
msgid ""
"This capability indicates that KVM supports paravirtualized Hyper-V IPI send "
"hypercalls: HvCallSendSyntheticClusterIpi, HvCallSendSyntheticClusterIpiEx."
msgstr ""

#: ../../../virt/kvm/api.rst:8901
msgid "8.22 KVM_CAP_S390_VCPU_RESETS"
msgstr ""

#: ../../../virt/kvm/api.rst:8905
msgid ""
"This capability indicates that the KVM_S390_NORMAL_RESET and "
"KVM_S390_CLEAR_RESET ioctls are available."
msgstr ""

#: ../../../virt/kvm/api.rst:8909
msgid "8.23 KVM_CAP_S390_PROTECTED"
msgstr ""

#: ../../../virt/kvm/api.rst:8913
msgid ""
"This capability indicates that the Ultravisor has been initialized and KVM "
"can therefore start protected VMs. This capability governs the "
"KVM_S390_PV_COMMAND ioctl and the KVM_MP_STATE_LOAD MP_STATE. "
"KVM_SET_MP_STATE can fail for protected guests when the state change is "
"invalid."
msgstr ""

#: ../../../virt/kvm/api.rst:8920
msgid "8.24 KVM_CAP_STEAL_TIME"
msgstr ""

#: ../../../virt/kvm/api.rst:8922
msgid "arm64, x86"
msgstr ""

#: ../../../virt/kvm/api.rst:8924
msgid ""
"This capability indicates that KVM supports steal time accounting. When "
"steal time accounting is supported it may be enabled with architecture-"
"specific interfaces.  This capability and the architecture- specific "
"interfaces must be consistent, i.e. if one says the feature is supported, "
"than the other should as well and vice versa.  For arm64 see Documentation/"
"virt/kvm/devices/vcpu.rst \"KVM_ARM_VCPU_PVTIME_CTRL\". For x86 see "
"Documentation/virt/kvm/x86/msr.rst \"MSR_KVM_STEAL_TIME\"."
msgstr ""

#: ../../../virt/kvm/api.rst:8933
msgid "8.25 KVM_CAP_S390_DIAG318"
msgstr ""

#: ../../../virt/kvm/api.rst:8937
msgid ""
"This capability enables a guest to set information about its control program "
"(i.e. guest kernel type and version). The information is helpful during "
"system/firmware service events, providing additional data about the guest "
"environments running on the machine."
msgstr ""

#: ../../../virt/kvm/api.rst:8942
msgid ""
"The information is associated with the DIAGNOSE 0x318 instruction, which "
"sets an 8-byte value consisting of a one-byte Control Program Name Code "
"(CPNC) and a 7-byte Control Program Version Code (CPVC). The CPNC determines "
"what environment the control program is running in (e.g. Linux, z/VM...), "
"and the CPVC is used for information specific to OS (e.g. Linux version, "
"Linux distribution...)"
msgstr ""

#: ../../../virt/kvm/api.rst:8949
msgid ""
"If this capability is available, then the CPNC and CPVC can be synchronized "
"between KVM and userspace via the sync regs mechanism (KVM_SYNC_DIAG318)."
msgstr ""

#: ../../../virt/kvm/api.rst:8953
msgid "8.26 KVM_CAP_X86_USER_SPACE_MSR"
msgstr ""

#: ../../../virt/kvm/api.rst:8957
msgid ""
"This capability indicates that KVM supports deflection of MSR reads and "
"writes to user space. It can be enabled on a VM level. If enabled, MSR "
"accesses that would usually trigger a #GP by KVM into the guest will instead "
"get bounced to user space through the KVM_EXIT_X86_RDMSR and "
"KVM_EXIT_X86_WRMSR exit notifications."
msgstr ""

#: ../../../virt/kvm/api.rst:8964
msgid "8.27 KVM_CAP_X86_MSR_FILTER"
msgstr ""

#: ../../../virt/kvm/api.rst:8968
msgid ""
"This capability indicates that KVM supports that accesses to user defined "
"MSRs may be rejected. With this capability exposed, KVM exports new VM ioctl "
"KVM_X86_SET_MSR_FILTER which user space can call to specify bitmaps of MSR "
"ranges that KVM should deny access to."
msgstr ""

#: ../../../virt/kvm/api.rst:8973
msgid ""
"In combination with KVM_CAP_X86_USER_SPACE_MSR, this allows user space to "
"trap and emulate MSRs that are outside of the scope of KVM as well as limit "
"the attack surface on KVM's MSR emulation code."
msgstr ""

#: ../../../virt/kvm/api.rst:8978
msgid "8.30 KVM_CAP_XEN_HVM"
msgstr ""

#: ../../../virt/kvm/api.rst:8982
msgid ""
"This capability indicates the features that Xen supports for hosting Xen "
"PVHVM guests. Valid flags are::"
msgstr ""

#: ../../../virt/kvm/api.rst:8994
msgid ""
"The KVM_XEN_HVM_CONFIG_HYPERCALL_MSR flag indicates that the "
"KVM_XEN_HVM_CONFIG ioctl is available, for the guest to set its hypercall "
"page."
msgstr ""

#: ../../../virt/kvm/api.rst:8997
msgid ""
"If KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL is also set, the same flag may also be "
"provided in the flags to KVM_XEN_HVM_CONFIG, without providing hypercall "
"page contents, to request that KVM generate hypercall page content "
"automatically and also enable interception of guest hypercalls with "
"KVM_EXIT_XEN."
msgstr ""

#: ../../../virt/kvm/api.rst:9002
msgid ""
"The KVM_XEN_HVM_CONFIG_SHARED_INFO flag indicates the availability of the "
"KVM_XEN_HVM_SET_ATTR, KVM_XEN_HVM_GET_ATTR, KVM_XEN_VCPU_SET_ATTR and "
"KVM_XEN_VCPU_GET_ATTR ioctls, as well as the delivery of exception vectors "
"for event channel upcalls when the evtchn_upcall_pending field of a vcpu's "
"vcpu_info is set."
msgstr ""

#: ../../../virt/kvm/api.rst:9008
msgid ""
"The KVM_XEN_HVM_CONFIG_RUNSTATE flag indicates that the runstate-related "
"features KVM_XEN_VCPU_ATTR_TYPE_RUNSTATE_ADDR/_CURRENT/_DATA/_ADJUST are "
"supported by the KVM_XEN_VCPU_SET_ATTR/KVM_XEN_VCPU_GET_ATTR ioctls."
msgstr ""

#: ../../../virt/kvm/api.rst:9012
msgid ""
"The KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL flag indicates that IRQ routing entries "
"of the type KVM_IRQ_ROUTING_XEN_EVTCHN are supported, with the priority "
"field set to indicate 2 level event channel delivery."
msgstr ""

#: ../../../virt/kvm/api.rst:9016
msgid ""
"The KVM_XEN_HVM_CONFIG_EVTCHN_SEND flag indicates that KVM supports "
"injecting event channel events directly into the guest with the "
"KVM_XEN_HVM_EVTCHN_SEND ioctl. It also indicates support for the "
"KVM_XEN_ATTR_TYPE_EVTCHN/XEN_VERSION HVM attributes and the "
"KVM_XEN_VCPU_ATTR_TYPE_VCPU_ID/TIMER/UPCALL_VECTOR vCPU attributes. related "
"to event channel delivery, timers, and the XENVER_version interception."
msgstr ""

#: ../../../virt/kvm/api.rst:9024
msgid ""
"The KVM_XEN_HVM_CONFIG_RUNSTATE_UPDATE_FLAG flag indicates that KVM supports "
"the KVM_XEN_ATTR_TYPE_RUNSTATE_UPDATE_FLAG attribute in the KVM_XEN_SET_ATTR "
"and KVM_XEN_GET_ATTR ioctls. This controls whether KVM will set the "
"XEN_RUNSTATE_UPDATE flag in guest memory mapped vcpu_runstate_info during "
"updates of the runstate information. Note that versions of KVM which support "
"the RUNSTATE feature above, but not the RUNSTATE_UPDATE_FLAG feature, will "
"always set the XEN_RUNSTATE_UPDATE flag when updating the guest structure, "
"which is perhaps counterintuitive. When this flag is advertised, KVM will "
"behave more correctly, not using the XEN_RUNSTATE_UPDATE flag until/unless "
"specifically enabled (by the guest making the hypercall, causing the VMM to "
"enable the KVM_XEN_ATTR_TYPE_RUNSTATE_UPDATE_FLAG attribute)."
msgstr ""

#: ../../../virt/kvm/api.rst:9036
msgid ""
"The KVM_XEN_HVM_CONFIG_PVCLOCK_TSC_UNSTABLE flag indicates that KVM supports "
"clearing the PVCLOCK_TSC_STABLE_BIT flag in Xen pvclock sources. This will "
"be done when the KVM_CAP_XEN_HVM ioctl sets the "
"KVM_XEN_HVM_CONFIG_PVCLOCK_TSC_UNSTABLE flag."
msgstr ""

#: ../../../virt/kvm/api.rst:9042
msgid "8.31 KVM_CAP_SPAPR_MULTITCE"
msgstr ""

#: ../../../virt/kvm/api.rst:9047
msgid ""
"This capability means the kernel is capable of handling hypercalls "
"H_PUT_TCE_INDIRECT and H_STUFF_TCE without passing those into the user "
"space. This significantly accelerates DMA operations for PPC KVM guests. "
"User space should expect that its handlers for these hypercalls are not "
"going to be called if user space previously registered LIOBN in KVM (via "
"KVM_CREATE_SPAPR_TCE or similar calls)."
msgstr ""

#: ../../../virt/kvm/api.rst:9054
msgid ""
"In order to enable H_PUT_TCE_INDIRECT and H_STUFF_TCE use in the guest, user "
"space might have to advertise it for the guest. For example, IBM pSeries "
"(sPAPR) guest starts using them if \"hcall-multi-tce\" is present in the "
"\"ibm,hypertas-functions\" device-tree property."
msgstr ""

#: ../../../virt/kvm/api.rst:9059
msgid ""
"The hypercalls mentioned above may or may not be processed successfully in "
"the kernel based fast path. If they can not be handled by the kernel, they "
"will get passed on to user space. So user space still has to have an "
"implementation for these despite the in kernel acceleration."
msgstr ""

#: ../../../virt/kvm/api.rst:9064
msgid "This capability is always enabled."
msgstr ""

#: ../../../virt/kvm/api.rst:9067
msgid "8.32 KVM_CAP_PTP_KVM"
msgstr ""

#: ../../../virt/kvm/api.rst:9071
msgid ""
"This capability indicates that the KVM virtual PTP service is supported in "
"the host. A VMM can check whether the service is available to the guest on "
"migration."
msgstr ""

#: ../../../virt/kvm/api.rst:9076
msgid "8.37 KVM_CAP_S390_PROTECTED_DUMP"
msgstr ""

#: ../../../virt/kvm/api.rst:9081
msgid ""
"This capability indicates that KVM and the Ultravisor support dumping PV "
"guests. The `KVM_PV_DUMP` command is available for the `KVM_S390_PV_COMMAND` "
"ioctl and the `KVM_PV_INFO` command provides dump related UV data. Also the "
"vcpu ioctl `KVM_S390_PV_CPU_COMMAND` is available and supports the "
"`KVM_PV_DUMP_CPU` subcommand."
msgstr ""

#: ../../../virt/kvm/api.rst:9088
msgid "8.39 KVM_CAP_S390_CPU_TOPOLOGY"
msgstr ""

#: ../../../virt/kvm/api.rst:9093
msgid ""
"This capability indicates that KVM will provide the S390 CPU Topology "
"facility which consist of the interpretation of the PTF instruction for the "
"function code 2 along with interception and forwarding of both the PTF "
"instruction with function codes 0 or 1 and the STSI(15,1,x) instruction to "
"the userland hypervisor."
msgstr ""

#: ../../../virt/kvm/api.rst:9099
msgid ""
"The stfle facility 11, CPU Topology facility, should not be indicated to the "
"guest without this capability."
msgstr ""

#: ../../../virt/kvm/api.rst:9102
msgid ""
"When this capability is present, KVM provides a new attribute group on vm "
"fd, KVM_S390_VM_CPU_TOPOLOGY. This new attribute allows to get, set or clear "
"the Modified Change Topology Report (MTCR) bit of the SCA through the "
"kvm_device_attr structure."
msgstr ""

#: ../../../virt/kvm/api.rst:9108
msgid ""
"When getting the Modified Change Topology Report value, the attr->addr must "
"point to a byte where the value will be stored or retrieved from."
msgstr ""

#: ../../../virt/kvm/api.rst:9112
msgid "8.41 KVM_CAP_VM_TYPES"
msgstr ""

#: ../../../virt/kvm/api.rst:9117
msgid ""
"This capability returns a bitmap of support VM types.  The 1-setting of bit "
"@n means the VM type with value @n is supported.  Possible values of @n are::"
msgstr ""

#: ../../../virt/kvm/api.rst:9125
msgid ""
"Note, KVM_X86_SW_PROTECTED_VM is currently only for development and testing. "
"Do not use KVM_X86_SW_PROTECTED_VM for \"real\" VMs, and especially not in "
"production.  The behavior and effective ABI for software-protected VMs is "
"unstable."
msgstr ""

#: ../../../virt/kvm/api.rst:9131
msgid "8.42 KVM_CAP_PPC_RPT_INVALIDATE"
msgstr ""

#: ../../../virt/kvm/api.rst:9135
msgid ""
"This capability indicates that the kernel is capable of handling "
"H_RPT_INVALIDATE hcall."
msgstr ""

#: ../../../virt/kvm/api.rst:9138
msgid ""
"In order to enable the use of H_RPT_INVALIDATE in the guest, user space "
"might have to advertise it for the guest. For example, IBM pSeries (sPAPR) "
"guest starts using it if \"hcall-rpt-invalidate\" is present in the \"ibm,"
"hypertas-functions\" device-tree property."
msgstr ""

#: ../../../virt/kvm/api.rst:9143
msgid ""
"This capability is enabled for hypervisors on platforms like POWER9 that "
"support radix MMU."
msgstr ""

#: ../../../virt/kvm/api.rst:9147
msgid "8.43 KVM_CAP_PPC_AIL_MODE_3"
msgstr ""

#: ../../../virt/kvm/api.rst:9151
msgid ""
"This capability indicates that the kernel supports the mode 3 setting for "
"the \"Address Translation Mode on Interrupt\" aka \"Alternate Interrupt "
"Location\" resource that is controlled with the H_SET_MODE hypercall."
msgstr ""

#: ../../../virt/kvm/api.rst:9155
msgid ""
"This capability allows a guest kernel to use a better-performance mode for "
"handling interrupts and system calls."
msgstr ""

#: ../../../virt/kvm/api.rst:9159
msgid "8.44 KVM_CAP_MEMORY_FAULT_INFO"
msgstr ""

#: ../../../virt/kvm/api.rst:9163
msgid ""
"The presence of this capability indicates that KVM_RUN will fill kvm_run."
"memory_fault if KVM cannot resolve a guest page fault VM-Exit, e.g. if there "
"is a valid memslot but no backing VMA for the corresponding host virtual "
"address."
msgstr ""

#: ../../../virt/kvm/api.rst:9168
msgid ""
"The information in kvm_run.memory_fault is valid if and only if KVM_RUN "
"returns an error with errno=EFAULT or errno=EHWPOISON *and* kvm_run."
"exit_reason is set to KVM_EXIT_MEMORY_FAULT."
msgstr ""

#: ../../../virt/kvm/api.rst:9172
msgid ""
"Note: Userspaces which attempt to resolve memory faults so that they can "
"retry KVM_RUN are encouraged to guard against repeatedly receiving the same "
"error/annotated fault."
msgstr ""

#: ../../../virt/kvm/api.rst:9176
msgid "See KVM_EXIT_MEMORY_FAULT for more information."
msgstr ""

#: ../../../virt/kvm/api.rst:9179
msgid "8.45 KVM_CAP_X86_GUEST_MODE"
msgstr ""

#: ../../../virt/kvm/api.rst:9183
msgid ""
"The presence of this capability indicates that KVM_RUN will update the "
"KVM_RUN_X86_GUEST_MODE bit in kvm_run.flags to indicate whether the vCPU was "
"executing nested guest code when it exited."
msgstr ""

#: ../../../virt/kvm/api.rst:9187
msgid ""
"KVM exits with the register state of either the L1 or L2 guest depending on "
"which executed at the time of an exit. Userspace must take care to "
"differentiate between these cases."
msgstr ""

#: ../../../virt/kvm/api.rst:9192
msgid "9. Known KVM API problems"
msgstr ""

#: ../../../virt/kvm/api.rst:9194
msgid ""
"In some cases, KVM's API has some inconsistencies or common pitfalls that "
"userspace need to be aware of.  This section details some of these issues."
msgstr ""

#: ../../../virt/kvm/api.rst:9198
msgid ""
"Most of them are architecture specific, so the section is split by "
"architecture."
msgstr ""

#: ../../../virt/kvm/api.rst:9202
msgid "9.1. x86"
msgstr ""

#: ../../../virt/kvm/api.rst:9205
msgid "``KVM_GET_SUPPORTED_CPUID`` issues"
msgstr ""

#: ../../../virt/kvm/api.rst:9207
msgid ""
"In general, ``KVM_GET_SUPPORTED_CPUID`` is designed so that it is possible "
"to take its result and pass it directly to ``KVM_SET_CPUID2``.  This section "
"documents some cases in which that requires some care."
msgstr ""

#: ../../../virt/kvm/api.rst:9212
msgid "Local APIC features"
msgstr ""

#: ../../../virt/kvm/api.rst:9214
msgid ""
"CPU[EAX=1]:ECX[21] (X2APIC) is reported by ``KVM_GET_SUPPORTED_CPUID``, but "
"it can only be enabled if ``KVM_CREATE_IRQCHIP`` or "
"``KVM_ENABLE_CAP(KVM_CAP_IRQCHIP_SPLIT)`` are used to enable in-kernel "
"emulation of the local APIC."
msgstr ""

#: ../../../virt/kvm/api.rst:9219
msgid ""
"The same is true for the ``KVM_FEATURE_PV_UNHALT`` paravirtualized feature."
msgstr ""

#: ../../../virt/kvm/api.rst:9221
msgid ""
"On older versions of Linux, CPU[EAX=1]:ECX[24] (TSC_DEADLINE) is not "
"reported by ``KVM_GET_SUPPORTED_CPUID``, but it can be enabled if "
"``KVM_CAP_TSC_DEADLINE_TIMER`` is present and the kernel has enabled in-"
"kernel emulation of the local APIC. On newer versions, "
"``KVM_GET_SUPPORTED_CPUID`` does report the bit as available."
msgstr ""

#: ../../../virt/kvm/api.rst:9227
msgid "CPU topology"
msgstr ""

#: ../../../virt/kvm/api.rst:9229
msgid ""
"Several CPUID values include topology information for the host CPU: 0x0b and "
"0x1f for Intel systems, 0x8000001e for AMD systems.  Different versions of "
"KVM return different values for this information and userspace should not "
"rely on it.  Currently they return all zeroes."
msgstr ""

#: ../../../virt/kvm/api.rst:9234
msgid ""
"If userspace wishes to set up a guest topology, it should be careful that "
"the values of these three leaves differ for each CPU.  In particular, the "
"APIC ID is found in EDX for all subleaves of 0x0b and 0x1f, and in EAX for "
"0x8000001e; the latter also encodes the core id and node id in bits 7:0 of "
"EBX and ECX respectively."
msgstr ""

#: ../../../virt/kvm/api.rst:9241
msgid "Obsolete ioctls and capabilities"
msgstr ""

#: ../../../virt/kvm/api.rst:9243
msgid ""
"KVM_CAP_DISABLE_QUIRKS does not let userspace know which quirks are actually "
"available.  Use ``KVM_CHECK_EXTENSION(KVM_CAP_DISABLE_QUIRKS2)`` instead if "
"available."
msgstr ""

#: ../../../virt/kvm/api.rst:9248
msgid "Ordering of KVM_GET_*/KVM_SET_* ioctls"
msgstr ""

#: ../../../virt/kvm/api.rst:9250
msgid "TBD"
msgstr ""
