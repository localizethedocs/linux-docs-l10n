# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../staging/speculation.rst:3
msgid "Speculation"
msgstr ""

#: ../../../staging/speculation.rst:5
msgid ""
"This document explains potential effects of speculation, and how undesirable "
"effects can be mitigated portably using common APIs."
msgstr ""

#: ../../../staging/speculation.rst:10
msgid ""
"To improve performance and minimize average latencies, many contemporary "
"CPUs employ speculative execution techniques such as branch prediction, "
"performing work which may be discarded at a later stage."
msgstr ""

#: ../../../staging/speculation.rst:14
msgid ""
"Typically speculative execution cannot be observed from architectural state, "
"such as the contents of registers. However, in some cases it is possible to "
"observe its impact on microarchitectural state, such as the presence or "
"absence of data in caches. Such state may form side-channels which can be "
"observed to extract secret information."
msgstr ""

#: ../../../staging/speculation.rst:20
msgid ""
"For example, in the presence of branch prediction, it is possible for bounds "
"checks to be ignored by code which is speculatively executed. Consider the "
"following code::"
msgstr ""

#: ../../../staging/speculation.rst:32
msgid "Which, on arm64, may be compiled to an assembly sequence such as::"
msgstr ""

#: ../../../staging/speculation.rst:42
msgid ""
"It is possible that a CPU mis-predicts the conditional branch, and "
"speculatively loads array[index], even if index >= MAX_ARRAY_ELEMS. This "
"value will subsequently be discarded, but the speculated load may affect "
"microarchitectural state which can be subsequently measured."
msgstr ""

#: ../../../staging/speculation.rst:47
msgid ""
"More complex sequences involving multiple dependent memory accesses may "
"result in sensitive information being leaked. Consider the following code, "
"building on the prior example::"
msgstr ""

#: ../../../staging/speculation.rst:61
msgid ""
"Under speculation, the first call to load_array() may return the value of an "
"out-of-bounds address, while the second call will influence "
"microarchitectural state dependent on this value. This may provide an "
"arbitrary read primitive."
msgstr ""

#: ../../../staging/speculation.rst:67
msgid "Mitigating speculation side-channels"
msgstr ""

#: ../../../staging/speculation.rst:69
msgid ""
"The kernel provides a generic API to ensure that bounds checks are respected "
"even under speculation. Architectures which are affected by speculation-"
"based side-channels are expected to implement these primitives."
msgstr ""

#: ../../../staging/speculation.rst:74
msgid ""
"The array_index_nospec() helper in <linux/nospec.h> can be used to prevent "
"information from being leaked via side-channels."
msgstr ""

#: ../../../staging/speculation.rst:77
msgid ""
"A call to array_index_nospec(index, size) returns a sanitized index value "
"that is bounded to [0, size) even under cpu speculation conditions."
msgstr ""

#: ../../../staging/speculation.rst:81
msgid "This can be used to protect the earlier load_array() example::"
msgstr ""
