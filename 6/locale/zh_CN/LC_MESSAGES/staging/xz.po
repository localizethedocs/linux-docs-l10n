# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 09:03+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../staging/xz.rst:5
msgid "XZ data compression in Linux"
msgstr ""

#: ../../../staging/xz.rst:8
msgid "Introduction"
msgstr ""

#: ../../../staging/xz.rst:10
msgid ""
"XZ is a general purpose data compression format with high compression ratio. "
"The XZ decompressor in Linux is called XZ Embedded. It supports the LZMA2 "
"filter and optionally also Branch/Call/Jump (BCJ) filters for executable "
"code. CRC32 is supported for integrity checking."
msgstr ""

#: ../../../staging/xz.rst:15
msgid ""
"See the `XZ Embedded`_ home page for the latest version which includes a few "
"optional extra features that aren't required in the Linux kernel and "
"information about using the code outside the Linux kernel."
msgstr ""

#: ../../../staging/xz.rst:19
msgid ""
"For userspace, `XZ Utils`_ provide a zlib-like compression library and a "
"gzip-like command line tool."
msgstr ""

#: ../../../staging/xz.rst:26
msgid "XZ related components in the kernel"
msgstr ""

#: ../../../staging/xz.rst:28
msgid ""
"The xz_dec module provides XZ decompressor with single-call (buffer to "
"buffer) and multi-call (stateful) APIs in include/linux/xz.h."
msgstr ""

#: ../../../staging/xz.rst:31
msgid ""
"For decompressing the kernel image, initramfs, and initrd, there is a "
"wrapper function in lib/decompress_unxz.c. Its API is the same as in other "
"decompress_*.c files, which is defined in include/linux/decompress/generic.h."
msgstr ""

#: ../../../staging/xz.rst:36
msgid ""
"For kernel makefiles, three commands are provided for use with ``$(call "
"if_changed)``. They require the xz tool from XZ Utils."
msgstr ""

#: ../../../staging/xz.rst:39
msgid ""
"``$(call if_changed,xzkern)`` is for compressing the kernel image. It runs "
"the script scripts/xz_wrap.sh which uses arch-optimized options and a big "
"LZMA2 dictionary."
msgstr ""

#: ../../../staging/xz.rst:43
msgid ""
"``$(call if_changed,xzkern_with_size)`` is like ``xzkern`` above but this "
"also appends a four-byte trailer containing the uncompressed size of the "
"file. The trailer is needed by the boot code on some archs."
msgstr ""

#: ../../../staging/xz.rst:47
msgid ""
"Other things can be compressed with ``$(call if_needed,xzmisc)`` which will "
"use no BCJ filter and 1 MiB LZMA2 dictionary."
msgstr ""

#: ../../../staging/xz.rst:51
msgid "Notes on compression options"
msgstr ""

#: ../../../staging/xz.rst:53
msgid ""
"Since the XZ Embedded supports only streams with CRC32 or no integrity "
"check, make sure that you don't use some other integrity check type when "
"encoding files that are supposed to be decoded by the kernel. With liblzma "
"from XZ Utils, you need to use either ``LZMA_CHECK_CRC32`` or "
"``LZMA_CHECK_NONE`` when encoding. With the ``xz`` command line tool, use "
"``--check=crc32`` or ``--check=none`` to override the default ``--"
"check=crc64``."
msgstr ""

#: ../../../staging/xz.rst:61
msgid ""
"Using CRC32 is strongly recommended unless there is some other layer which "
"will verify the integrity of the uncompressed data anyway. Double checking "
"the integrity would probably be waste of CPU cycles. Note that the headers "
"will always have a CRC32 which will be validated by the decoder; you can "
"only change the integrity check type (or disable it) for the actual "
"uncompressed data."
msgstr ""

#: ../../../staging/xz.rst:68
msgid ""
"In userspace, LZMA2 is typically used with dictionary sizes of several "
"megabytes. The decoder needs to have the dictionary in RAM:"
msgstr ""

#: ../../../staging/xz.rst:71
msgid ""
"In multi-call mode the dictionary is allocated as part of the decoder state. "
"The reasonable maximum dictionary size for in-kernel use will depend on the "
"target hardware: a few megabytes is fine for desktop systems while 64 KiB to "
"1 MiB might be more appropriate on some embedded systems."
msgstr ""

#: ../../../staging/xz.rst:77
msgid ""
"In single-call mode the output buffer is used as the dictionary buffer. That "
"is, the size of the dictionary doesn't affect the decompressor memory usage "
"at all. Only the base data structures are allocated which take a little less "
"than 30 KiB of memory. For the best compression, the dictionary should be at "
"least as big as the uncompressed data. A notable example of single-call mode "
"is decompressing the kernel itself (except on PowerPC)."
msgstr ""

#: ../../../staging/xz.rst:85
msgid ""
"The compression presets in XZ Utils may not be optimal when creating files "
"for the kernel, so don't hesitate to use custom settings to, for example, "
"set the dictionary size. Also, xz may produce a smaller file in single-"
"threaded mode so setting that explicitly is recommended. Example::"
msgstr ""

#: ../../../staging/xz.rst:94
msgid "xz_dec API"
msgstr ""

#: ../../../staging/xz.rst:96
msgid "This is available with ``#include <linux/xz.h>``."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:22 include/linux/xz.h:147
msgid "Operation mode"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:26 include/linux/xz.h:57
msgid "**Constants**"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:28
msgid "``XZ_SINGLE``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:29
msgid ""
"Single-call mode. This uses less RAM than multi-call modes, because the "
"LZMA2 dictionary doesn't need to be allocated as part of the decoder state. "
"All required data structures are allocated at initialization, so "
"xz_dec_run() cannot return XZ_MEM_ERROR."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:36
msgid "``XZ_PREALLOC``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:37
msgid ""
"Multi-call mode with preallocated LZMA2 dictionary buffer. All data "
"structures are allocated at initialization, so xz_dec_run() cannot return "
"XZ_MEM_ERROR."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:42
msgid "``XZ_DYNALLOC``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:43
msgid ""
"Multi-call mode. The LZMA2 dictionary is allocated once the required size "
"has been parsed from the stream headers. If the allocation fails, "
"xz_dec_run() will return XZ_MEM_ERROR."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:49 include/linux/xz.h:111
#: include/linux/xz.h:129 include/linux/xz.h:158 include/linux/xz.h:195
#: include/linux/xz.h:214 include/linux/xz.h:255 include/linux/xz.h:291
msgid "**Description**"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:39
msgid ""
"It is possible to enable support only for a subset of the above modes at "
"compile time by defining XZ_DEC_SINGLE, XZ_DEC_PREALLOC, or XZ_DEC_DYNALLOC. "
"The xz_dec kernel module is always compiled with support for all operation "
"modes, but the preboot code may be built with fewer features to minimize "
"code size."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:53
msgid "Return codes"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:59
msgid "``XZ_OK``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:60
msgid ""
"Everything is OK so far. More input or more output space is required to "
"continue. This return code is possible only in multi-call mode (XZ_PREALLOC "
"or XZ_DYNALLOC)."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:65
msgid "``XZ_STREAM_END``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:66
msgid "Operation finished successfully."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:68
msgid "``XZ_UNSUPPORTED_CHECK``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:69
msgid ""
"Integrity check type is not supported. Decoding is still possible in multi-"
"call mode by simply calling xz_dec_run() again. Note that this return value "
"is used only if XZ_DEC_ANY_CHECK was defined at build time, which is not "
"used in the kernel. Unsupported check types return XZ_OPTIONS_ERROR if "
"XZ_DEC_ANY_CHECK was not defined at build time."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:78
msgid "``XZ_MEM_ERROR``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:79
msgid ""
"Allocating memory failed. This return code is possible only if the decoder "
"was initialized with XZ_DYNALLOC. The amount of memory that was tried to be "
"allocated was no more than the dict_max argument given to xz_dec_init()."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:85
msgid "``XZ_MEMLIMIT_ERROR``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:86
msgid ""
"A bigger LZMA2 dictionary would be needed than allowed by the dict_max "
"argument given to xz_dec_init(). This return value is possible only in multi-"
"call mode (XZ_PREALLOC or XZ_DYNALLOC); the single-call mode (XZ_SINGLE) "
"ignores the dict_max argument."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:93
msgid "``XZ_FORMAT_ERROR``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:94
msgid "File format was not recognized (wrong magic bytes)."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:97
msgid "``XZ_OPTIONS_ERROR``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:98
msgid ""
"This implementation doesn't support the requested compression options. In "
"the decoder this means that the header CRC32 matches, but the header itself "
"specifies something that we don't support."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:103
msgid "``XZ_DATA_ERROR``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:104
msgid "Compressed data is corrupt."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:106
msgid "``XZ_BUF_ERROR``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:107
msgid ""
"Cannot make any progress. Details are slightly different between multi-call "
"and single-call mode; more information below."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:88
msgid ""
"In multi-call mode, XZ_BUF_ERROR is returned when two consecutive calls to "
"XZ code cannot consume any input and cannot produce any new output. This "
"happens when there is no new input available, or the output buffer is full "
"while at least one output byte is still pending. Assuming your code is not "
"buggy, you can get this error only when decoding a compressed stream that is "
"truncated or otherwise corrupt."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:95
msgid ""
"In single-call mode, XZ_BUF_ERROR is returned only when the output buffer is "
"too small or the compressed input is corrupt in a way that makes the decoder "
"produce more output than the caller expected. When it is (relatively) clear "
"that the compressed input is truncated, XZ_DATA_ERROR is used instead of "
"XZ_BUF_ERROR."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:115
msgid "Passing input and output buffers to XZ code"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:119
msgid "**Definition**::"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:130
msgid "**Members**"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:116
msgid "``in``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:117
msgid ""
"Beginning of the input buffer. This may be NULL if and only if in_pos is "
"equal to in_size."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:118
msgid "``in_pos``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:119
msgid "Current position in the input buffer. This must not exceed in_size."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:120
msgid "``in_size``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:121
msgid "Size of the input buffer"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:121
msgid "``out``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:122
msgid ""
"Beginning of the output buffer. This may be NULL if and only if out_pos is "
"equal to out_size."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:123
msgid "``out_pos``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:124
msgid "Current position in the output buffer. This must not exceed out_size."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:125
msgid "``out_size``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:126
msgid "Size of the output buffer"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:126
msgid ""
"Only the contents of the output buffer from out[out_pos] onward, and the "
"variables in_pos and out_pos are modified by the XZ code."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:146
msgid "Allocate and initialize a XZ decoder state"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:150 include/linux/xz.h:195
#: include/linux/xz.h:215 include/linux/xz.h:228 include/linux/xz.h:254
#: include/linux/xz.h:274 include/linux/xz.h:291 include/linux/xz.h:329
msgid "**Parameters**"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:152 include/linux/xz.h:256
msgid "``enum xz_mode mode``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:149
msgid "``uint32_t dict_max``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:148
msgid ""
"Maximum size of the LZMA2 dictionary (history buffer) for multi-call "
"decoding. This is ignored in single-call mode (mode == XZ_SINGLE). LZMA2 "
"dictionary is always 2^n bytes or 2^n + 2^(n-1) bytes (the latter sizes are "
"less common in practice), so other values for dict_max don't make sense. In "
"the kernel, dictionary sizes of 64 KiB, 128 KiB, 256 KiB, 512 KiB, and 1 MiB "
"are probably the only reasonable values, except for kernel and initramfs "
"images where a bigger dictionary can be fine and useful."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:157
msgid ""
"Single-call mode (XZ_SINGLE): xz_dec_run() decodes the whole stream at once. "
"The caller must provide enough output space or the decoding will fail. The "
"output space is used as the dictionary buffer, which is why there is no need "
"to allocate the dictionary as part of the decoder's internal state."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:163
msgid ""
"Because the output buffer is used as the workspace, streams encoded using a "
"big dictionary are not a problem in single-call mode. It is enough that the "
"output buffer is big enough to hold the actual uncompressed data; it can be "
"smaller than the dictionary size stored in the stream headers."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:168
msgid ""
"Multi-call mode with preallocated dictionary (XZ_PREALLOC): dict_max bytes "
"of memory is preallocated for the LZMA2 dictionary. This way there is no "
"risk that xz_dec_run() could run out of memory, since xz_dec_run() will "
"never allocate any memory. Instead, if the preallocated dictionary is too "
"small for decoding the given input stream, xz_dec_run() will return "
"XZ_MEMLIMIT_ERROR. Thus, it is important to know what kind of data will be "
"decoded to avoid allocating excessive amount of memory for the dictionary."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:176
msgid ""
"Multi-call mode with dynamically allocated dictionary (XZ_DYNALLOC): "
"dict_max specifies the maximum allowed dictionary size that xz_dec_run() may "
"allocate once it has parsed the dictionary size from the stream headers. "
"This way excessive allocations can be avoided while still limiting the "
"maximum memory usage to a sane value to prevent running the system out of "
"memory when decompressing streams from untrusted sources."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:183
msgid ""
"On success, xz_dec_init() returns a pointer to struct xz_dec, which is ready "
"to be used with xz_dec_run(). If memory allocation fails, xz_dec_init() "
"returns NULL."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:191
msgid "Run the XZ decoder"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:197 include/linux/xz.h:217
#: include/linux/xz.h:230
msgid "``struct xz_dec *s``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:192 include/linux/xz.h:212
msgid "Decoder state allocated using xz_dec_init()"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:194 include/linux/xz.h:290
msgid "``struct xz_buf *b``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:193 include/linux/xz.h:289
msgid "Input and output buffers"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:194
msgid ""
"The possible return values depend on build options and operation mode. See "
"enum xz_ret for details."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:197
msgid ""
"Note that if an error occurs in single-call mode (return value is not "
"XZ_STREAM_END), b->in_pos and b->out_pos are not modified and the contents "
"of the output buffer from b->out[b->out_pos] onward are undefined. This is "
"true even after XZ_BUF_ERROR, because with some filter chains, there may be "
"a second pass over the output buffer, and this pass cannot be properly done "
"if the output buffer is truncated. Thus, you cannot give the single-call "
"decoder a too small buffer and then expect to get that amount valid data "
"from the beginning of the stream. You must use the multi-call decoder if you "
"don't want to uncompress the whole stream."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:211
msgid "Reset an already allocated decoder state"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:213
msgid ""
"This function can be used to reset the multi-call decoder state without "
"freeing and reallocating memory with xz_dec_end() and xz_dec_init()."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:216
msgid ""
"In single-call mode, xz_dec_reset() is always called in the beginning of "
"xz_dec_run(). Thus, explicit call to xz_dec_reset() is useful only in multi-"
"call mode."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:224 include/linux/xz.h:325
msgid "Free the memory allocated for the decoder state"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:225
msgid ""
"Decoder state allocated using xz_dec_init(). If s is NULL, this function "
"does nothing."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:231
msgid "**MicroLZMA decompressor**"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:231
msgid ""
"This MicroLZMA header format was created for use in EROFS but may be used by "
"others too. **In most cases one needs the XZ APIs above instead.**"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:234
msgid ""
"The compressed format supported by this decoder is a raw LZMA stream whose "
"first byte (always 0x00) has been replaced with bitwise-negation of the LZMA "
"properties (lc/lp/pb) byte. For example, if lc/lp/pb is 3/0/2, the first "
"byte is 0xA2. This way the first byte can never be 0x00. Just like with "
"LZMA2, lc + lp <= 4 must be true. The LZMA end-of-stream marker must not be "
"used. The unused values are reserved for future use."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:250
msgid "Allocate memory for the MicroLZMA decoder"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:251
msgid "XZ_SINGLE or XZ_PREALLOC"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:253
msgid "``uint32_t dict_size``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:252
msgid "LZMA dictionary size. This must be at least 4 KiB and at most 3 GiB."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:254
msgid ""
"In contrast to xz_dec_init(), this function only allocates the memory and "
"remembers the dictionary size. xz_dec_microlzma_reset() must be used before "
"calling xz_dec_microlzma_run()."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:258
msgid ""
"The amount of allocated memory is a little less than 30 KiB with XZ_SINGLE. "
"With XZ_PREALLOC also a dictionary buffer of dict_size bytes is allocated."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:261
msgid ""
"On success, xz_dec_microlzma_alloc() returns a pointer to struct "
"xz_dec_microlzma. If memory allocation fails or dict_size is invalid, NULL "
"is returned."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:270
msgid "Reset the MicroLZMA decoder state"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:276 include/linux/xz.h:293
#: include/linux/xz.h:331
msgid "``struct xz_dec_microlzma *s``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:271
msgid "Decoder state allocated using xz_dec_microlzma_alloc()"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:273
msgid "``uint32_t comp_size``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:272
msgid "Compressed size of the input stream"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:274
msgid "``uint32_t uncomp_size``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:273
msgid ""
"Uncompressed size of the input stream. A value smaller than the real "
"uncompressed size of the input stream can be specified if "
"uncomp_size_is_exact is set to false. uncomp_size can never be set to a "
"value larger than the expected real uncompressed size because it would "
"eventually result in XZ_DATA_ERROR."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:280
msgid "``int uncomp_size_is_exact``"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:279
msgid ""
"This is an int instead of bool to avoid requiring stdbool.h. This should "
"normally be set to true. When this is set to false, error detection is "
"weaker."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:287
msgid "Run the MicroLZMA decoder"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:288
msgid "Decoder state initialized using xz_dec_microlzma_reset()"
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:290
msgid ""
"This works similarly to xz_dec_run() with a few important differences. Only "
"the differences are documented here."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:293
msgid ""
"The only possible return values are XZ_OK, XZ_STREAM_END, and XZ_DATA_ERROR. "
"This function cannot return XZ_BUF_ERROR: if no progress is possible due to "
"lack of input data or output space, this function will keep returning XZ_OK. "
"Thus, the calling code must be written so that it will eventually provide "
"input and output space matching (or exceeding) comp_size and uncomp_size "
"arguments given to xz_dec_microlzma_reset(). If the caller cannot do this "
"(for example, if the input file is truncated or otherwise corrupt), the "
"caller must detect this error by itself to avoid an infinite loop."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:303
msgid ""
"If the compressed data seems to be corrupt, XZ_DATA_ERROR is returned. This "
"can happen also when incorrect dictionary, uncompressed, or compressed sizes "
"have been specified."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:307
msgid ""
"With XZ_PREALLOC only: As an extra feature, b->out may be NULL to skip over "
"uncompressed data. This way the caller doesn't need to provide a temporary "
"output buffer for the bytes that will be ignored."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:311
msgid ""
"With XZ_SINGLE only: In contrast to xz_dec_run(), the return value XZ_OK is "
"also possible and thus XZ_SINGLE is actually a limited multi-call mode. "
"After XZ_OK the bytes decoded so far may be read from the output buffer. It "
"is possible to continue decoding but the variables b->out and b->out_pos "
"MUST NOT be changed by the caller. Increasing the value of b->out_size is "
"allowed to make more output space available; one doesn't need to provide "
"space for the whole uncompressed data on the first call. The input buffer "
"may be changed normally like with XZ_PREALLOC. This way input data can be "
"provided from non-contiguous memory."
msgstr ""

#: ../../../staging/xz:98: include/linux/xz.h:326
msgid ""
"Decoder state allocated using xz_dec_microlzma_alloc(). If s is NULL, this "
"function does nothing."
msgstr ""
