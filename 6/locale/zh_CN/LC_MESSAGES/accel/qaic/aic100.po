# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../accel/qaic/aic100.rst:5
msgid "Qualcomm Cloud AI 100 (AIC100)"
msgstr ""

#: ../../../accel/qaic/aic100.rst:8 ../../../accel/qaic/aic100.rst:239
msgid "Overview"
msgstr ""

#: ../../../accel/qaic/aic100.rst:10
msgid ""
"The Qualcomm Cloud AI 100/AIC100 family of products (including SA9000P - "
"part of Snapdragon Ride) are PCIe adapter cards which contain a dedicated "
"SoC ASIC for the purpose of efficiently running Artificial Intelligence (AI) "
"Deep Learning inference workloads. They are AI accelerators."
msgstr ""

#: ../../../accel/qaic/aic100.rst:15
msgid ""
"The PCIe interface of AIC100 is capable of PCIe Gen4 speeds over eight lanes "
"(x8). An individual SoC on a card can have up to 16 NSPs for running "
"workloads. Each SoC has an A53 management CPU. On card, there can be up to "
"32 GB of DDR."
msgstr ""

#: ../../../accel/qaic/aic100.rst:19
msgid ""
"Multiple AIC100 cards can be hosted in a single system to scale overall "
"performance. AIC100 cards are multi-user capable and able to execute "
"workloads from multiple users in a concurrent manner."
msgstr ""

#: ../../../accel/qaic/aic100.rst:24
msgid "Hardware Description"
msgstr ""

#: ../../../accel/qaic/aic100.rst:26
msgid ""
"An AIC100 card consists of an AIC100 SoC, on-card DDR, and a set of misc "
"peripherals (PMICs, etc)."
msgstr ""

#: ../../../accel/qaic/aic100.rst:29
msgid ""
"An AIC100 card can either be a PCIe HHHL form factor (a traditional PCIe "
"card), or a Dual M.2 card. Both use PCIe to connect to the host system."
msgstr ""

#: ../../../accel/qaic/aic100.rst:32
msgid ""
"As a PCIe endpoint/adapter, AIC100 uses the standard VendorID(VID)/ "
"DeviceID(DID) combination to uniquely identify itself to the host. AIC100 "
"uses the standard Qualcomm VID (0x17cb). All AIC100 SKUs use the same AIC100 "
"DID (0xa100)."
msgstr ""

#: ../../../accel/qaic/aic100.rst:37
msgid "AIC100 does not implement FLR (function level reset)."
msgstr ""

#: ../../../accel/qaic/aic100.rst:39
msgid ""
"AIC100 implements MSI but does not implement MSI-X. AIC100 prefers 17 MSIs "
"to operate (1 for MHI, 16 for the DMA Bridge). Falling back to 1 MSI is "
"possible in scenarios where reserving 32 MSIs isn't feasible."
msgstr ""

#: ../../../accel/qaic/aic100.rst:43
msgid ""
"As a PCIe device, AIC100 utilizes BARs to provide host interfaces to the "
"device hardware. AIC100 provides 3, 64-bit BARs."
msgstr ""

#: ../../../accel/qaic/aic100.rst:46
msgid "The first BAR is 4K in size, and exposes the MHI interface to the host."
msgstr ""

#: ../../../accel/qaic/aic100.rst:48
msgid ""
"The second BAR is 2M in size, and exposes the DMA Bridge interface to the "
"host."
msgstr ""

#: ../../../accel/qaic/aic100.rst:51
msgid ""
"The third BAR is variable in size based on an individual AIC100's "
"configuration, but defaults to 64K. This BAR currently has no purpose."
msgstr ""

#: ../../../accel/qaic/aic100.rst:54
msgid "From the host perspective, AIC100 has several key hardware components -"
msgstr ""

#: ../../../accel/qaic/aic100.rst:56
msgid "MHI (Modem Host Interface)"
msgstr ""

#: ../../../accel/qaic/aic100.rst:57
msgid "QSM (QAIC Service Manager)"
msgstr ""

#: ../../../accel/qaic/aic100.rst:58
msgid "NSPs (Neural Signal Processor)"
msgstr ""

#: ../../../accel/qaic/aic100.rst:59 ../../../accel/qaic/aic100.rst:90
#: ../../../accel/qaic/aic100.rst:236
msgid "DMA Bridge"
msgstr ""

#: ../../../accel/qaic/aic100.rst:60 ../../../accel/qaic/aic100.rst:100
msgid "DDR"
msgstr ""

#: ../../../accel/qaic/aic100.rst:63
msgid "MHI"
msgstr ""

#: ../../../accel/qaic/aic100.rst:65
msgid ""
"AIC100 has one MHI interface over PCIe. MHI itself is documented at "
"Documentation/mhi/index.rst MHI is the mechanism the host uses to "
"communicate with the QSM. Except for workload data via the DMA Bridge, all "
"interaction with the device occurs via MHI."
msgstr ""

#: ../../../accel/qaic/aic100.rst:71
msgid "QSM"
msgstr ""

#: ../../../accel/qaic/aic100.rst:73
msgid ""
"QAIC Service Manager. This is an ARM A53 CPU that runs the primary firmware "
"of the card and performs on-card management tasks. It also communicates with "
"the host via MHI. Each AIC100 has one of these."
msgstr ""

#: ../../../accel/qaic/aic100.rst:79
msgid "NSP"
msgstr ""

#: ../../../accel/qaic/aic100.rst:81
msgid ""
"Neural Signal Processor. Each AIC100 has up to 16 of these. These are the "
"processors that run the workloads on AIC100. Each NSP is a Qualcomm Hexagon "
"(Q6) DSP with HVX and HMX. Each NSP can only run one workload at a time, but "
"multiple NSPs may be assigned to a single workload. Since each NSP can only "
"run one workload, AIC100 is limited to 16 concurrent workloads. Workload "
"\"scheduling\" is under the purview of the host. AIC100 does not "
"automatically timeslice."
msgstr ""

#: ../../../accel/qaic/aic100.rst:92
msgid ""
"The DMA Bridge is custom DMA engine that manages the flow of data in and out "
"of workloads. AIC100 has one of these. The DMA Bridge has 16 channels, each "
"consisting of a set of request/response FIFOs. Each active workload is "
"assigned a single DMA Bridge channel. The DMA Bridge exposes hardware "
"registers to manage the FIFOs (head/tail pointers), but requires host memory "
"to store the FIFOs."
msgstr ""

#: ../../../accel/qaic/aic100.rst:102
msgid ""
"AIC100 has on-card DDR. In total, an AIC100 can have up to 32 GB of DDR. "
"This DDR is used to store workloads, data for the workloads, and is used by "
"the QSM for managing the device. NSPs are granted access to sections of the "
"DDR by the QSM. The host does not have direct access to the DDR, and must "
"make requests to the QSM to transfer data to the DDR."
msgstr ""

#: ../../../accel/qaic/aic100.rst:109
msgid "High-level Use Flow"
msgstr ""

#: ../../../accel/qaic/aic100.rst:111
msgid ""
"AIC100 is a multi-user, programmable accelerator typically used for running "
"neural networks in inferencing mode to efficiently perform AI operations. "
"AIC100 is not intended for training neural networks. AIC100 can be utilized "
"for generic compute workloads."
msgstr ""

#: ../../../accel/qaic/aic100.rst:116
msgid "Assuming a user wants to utilize AIC100, they would follow these steps:"
msgstr ""

#: ../../../accel/qaic/aic100.rst:118
msgid "Compile the workload into an ELF targeting the NSP(s)"
msgstr ""

#: ../../../accel/qaic/aic100.rst:119
msgid ""
"Make requests to the QSM to load the workload and related artifacts into the "
"device DDR"
msgstr ""

#: ../../../accel/qaic/aic100.rst:121
msgid ""
"Make a request to the QSM to activate the workload onto a set of idle NSPs"
msgstr ""

#: ../../../accel/qaic/aic100.rst:122
msgid ""
"Make requests to the DMA Bridge to send input data to the workload to be "
"processed, and other requests to receive processed output data from the "
"workload."
msgstr ""

#: ../../../accel/qaic/aic100.rst:125
msgid ""
"Once the workload is no longer required, make a request to the QSM to "
"deactivate the workload, thus putting the NSPs back into an idle state."
msgstr ""

#: ../../../accel/qaic/aic100.rst:127
msgid ""
"Once the workload and related artifacts are no longer needed for future "
"sessions, make requests to the QSM to unload the data from DDR. This frees "
"the DDR to be used by other users."
msgstr ""

#: ../../../accel/qaic/aic100.rst:133
msgid "Boot Flow"
msgstr ""

#: ../../../accel/qaic/aic100.rst:135
msgid "AIC100 uses a flashless boot flow, derived from Qualcomm MSMs."
msgstr ""

#: ../../../accel/qaic/aic100.rst:137
msgid ""
"When AIC100 is first powered on, it begins executing PBL (Primary "
"Bootloader) from ROM. PBL enumerates the PCIe link, and initializes the BHI "
"(Boot Host Interface) component of MHI."
msgstr ""

#: ../../../accel/qaic/aic100.rst:141
msgid ""
"Using BHI, the host points PBL to the location of the SBL (Secondary "
"Bootloader) image. The PBL pulls the image from the host, validates it, and "
"begins execution of SBL."
msgstr ""

#: ../../../accel/qaic/aic100.rst:145
msgid ""
"SBL initializes MHI, and uses MHI to notify the host that the device has "
"entered the SBL stage. SBL performs a number of operations:"
msgstr ""

#: ../../../accel/qaic/aic100.rst:148
msgid ""
"SBL initializes the majority of hardware (anything PBL left uninitialized), "
"including DDR."
msgstr ""

#: ../../../accel/qaic/aic100.rst:150
msgid "SBL offloads the bootlog to the host."
msgstr ""

#: ../../../accel/qaic/aic100.rst:151
msgid "SBL synchronizes timestamps with the host for future logging."
msgstr ""

#: ../../../accel/qaic/aic100.rst:152
msgid ""
"SBL uses the Sahara protocol to obtain the runtime firmware images from the "
"host."
msgstr ""

#: ../../../accel/qaic/aic100.rst:155
msgid ""
"Once SBL has obtained and validated the runtime firmware, it brings the NSPs "
"out of reset, and jumps into the QSM."
msgstr ""

#: ../../../accel/qaic/aic100.rst:158
msgid ""
"The QSM uses MHI to notify the host that the device has entered the QSM "
"stage (AMSS in MHI terms). At this point, the AIC100 device is fully "
"functional, and ready to process workloads."
msgstr ""

#: ../../../accel/qaic/aic100.rst:163
msgid "Userspace components"
msgstr ""

#: ../../../accel/qaic/aic100.rst:166
msgid "Compiler"
msgstr ""

#: ../../../accel/qaic/aic100.rst:168
msgid ""
"An open compiler for AIC100 based on upstream LLVM can be found at: https://"
"github.com/quic/software-kit-for-qualcomm-cloud-ai-100-cc"
msgstr ""

#: ../../../accel/qaic/aic100.rst:172
msgid "Usermode Driver (UMD)"
msgstr ""

#: ../../../accel/qaic/aic100.rst:174
msgid ""
"An open UMD that interfaces with the qaic kernel driver can be found at: "
"https://github.com/quic/software-kit-for-qualcomm-cloud-ai-100"
msgstr ""

#: ../../../accel/qaic/aic100.rst:178
msgid "Sahara loader"
msgstr ""

#: ../../../accel/qaic/aic100.rst:180
msgid ""
"An open implementation of the Sahara protocol called kickstart can be found "
"at: https://github.com/andersson/qdl"
msgstr ""

#: ../../../accel/qaic/aic100.rst:184
msgid "MHI Channels"
msgstr ""

#: ../../../accel/qaic/aic100.rst:186
msgid ""
"AIC100 defines a number of MHI channels for different purposes. This is a "
"list of the defined channels, and their uses."
msgstr ""

#: ../../../accel/qaic/aic100.rst:190
msgid "Channel name"
msgstr ""

#: ../../../accel/qaic/aic100.rst:190
msgid "IDs"
msgstr ""

#: ../../../accel/qaic/aic100.rst:190
msgid "EEs"
msgstr ""

#: ../../../accel/qaic/aic100.rst:190
msgid "Purpose"
msgstr ""

#: ../../../accel/qaic/aic100.rst:192
msgid "QAIC_LOOPBACK"
msgstr ""

#: ../../../accel/qaic/aic100.rst:192
msgid "0 & 1"
msgstr ""

#: ../../../accel/qaic/aic100.rst:192 ../../../accel/qaic/aic100.rst:198
#: ../../../accel/qaic/aic100.rst:201 ../../../accel/qaic/aic100.rst:205
#: ../../../accel/qaic/aic100.rst:207 ../../../accel/qaic/aic100.rst:215
#: ../../../accel/qaic/aic100.rst:219 ../../../accel/qaic/aic100.rst:222
#: ../../../accel/qaic/aic100.rst:228 ../../../accel/qaic/aic100.rst:232
msgid "AMSS"
msgstr ""

#: ../../../accel/qaic/aic100.rst:192
msgid "Any data sent to the device on this channel is sent back to the host."
msgstr ""

#: ../../../accel/qaic/aic100.rst:195
msgid "QAIC_SAHARA"
msgstr ""

#: ../../../accel/qaic/aic100.rst:195
msgid "2 & 3"
msgstr ""

#: ../../../accel/qaic/aic100.rst:195 ../../../accel/qaic/aic100.rst:212
#: ../../../accel/qaic/aic100.rst:224
msgid "SBL"
msgstr ""

#: ../../../accel/qaic/aic100.rst:195
msgid "Used by SBL to obtain the runtime firmware from the host."
msgstr ""

#: ../../../accel/qaic/aic100.rst:198
msgid "QAIC_DIAG"
msgstr ""

#: ../../../accel/qaic/aic100.rst:198
msgid "4 & 5"
msgstr ""

#: ../../../accel/qaic/aic100.rst:198
msgid "Used to communicate with QSM via the DIAG protocol."
msgstr ""

#: ../../../accel/qaic/aic100.rst:201
msgid "QAIC_SSR"
msgstr ""

#: ../../../accel/qaic/aic100.rst:201
msgid "6 & 7"
msgstr ""

#: ../../../accel/qaic/aic100.rst:201
msgid ""
"Used to notify the host of subsystem restart events, and to offload SSR "
"crashdumps."
msgstr ""

#: ../../../accel/qaic/aic100.rst:205
msgid "QAIC_QDSS"
msgstr ""

#: ../../../accel/qaic/aic100.rst:205
msgid "8 & 9"
msgstr ""

#: ../../../accel/qaic/aic100.rst:205
msgid "Used for the Qualcomm Debug Subsystem."
msgstr ""

#: ../../../accel/qaic/aic100.rst:207
msgid "QAIC_CONTROL"
msgstr ""

#: ../../../accel/qaic/aic100.rst:207
msgid "10 & 11"
msgstr ""

#: ../../../accel/qaic/aic100.rst:207
msgid ""
"Used for the Neural Network Control (NNC) protocol. This is the primary "
"channel between host and QSM for managing workloads."
msgstr ""

#: ../../../accel/qaic/aic100.rst:212
msgid "QAIC_LOGGING"
msgstr ""

#: ../../../accel/qaic/aic100.rst:212
msgid "12 & 13"
msgstr ""

#: ../../../accel/qaic/aic100.rst:212
msgid "Used by the SBL to send the bootlog to the host."
msgstr ""

#: ../../../accel/qaic/aic100.rst:215
msgid "QAIC_STATUS"
msgstr ""

#: ../../../accel/qaic/aic100.rst:215
msgid "14 & 15"
msgstr ""

#: ../../../accel/qaic/aic100.rst:215
msgid ""
"Used to notify the host of Reliability, Accessibility, Serviceability (RAS) "
"events."
msgstr ""

#: ../../../accel/qaic/aic100.rst:219
msgid "QAIC_TELEMETRY"
msgstr ""

#: ../../../accel/qaic/aic100.rst:219
msgid "16 & 17"
msgstr ""

#: ../../../accel/qaic/aic100.rst:219
msgid "Used to get/set power/thermal/etc attributes."
msgstr ""

#: ../../../accel/qaic/aic100.rst:222
msgid "QAIC_DEBUG"
msgstr ""

#: ../../../accel/qaic/aic100.rst:222
msgid "18 & 19"
msgstr ""

#: ../../../accel/qaic/aic100.rst:222
msgid "Not used."
msgstr ""

#: ../../../accel/qaic/aic100.rst:224
msgid "QAIC_TIMESYNC"
msgstr ""

#: ../../../accel/qaic/aic100.rst:224
msgid "20 & 21"
msgstr ""

#: ../../../accel/qaic/aic100.rst:224
msgid ""
"Used to synchronize timestamps in the device side logs with the host time "
"source."
msgstr ""

#: ../../../accel/qaic/aic100.rst:228
msgid "QAIC_TIMESYNC _PERIODIC"
msgstr ""

#: ../../../accel/qaic/aic100.rst:228
msgid "22 & 23"
msgstr ""

#: ../../../accel/qaic/aic100.rst:228
msgid ""
"Used to periodically synchronize timestamps in the device side logs with the "
"host time source."
msgstr ""

#: ../../../accel/qaic/aic100.rst:232
msgid "IPCR"
msgstr ""

#: ../../../accel/qaic/aic100.rst:232
msgid "24 & 25"
msgstr ""

#: ../../../accel/qaic/aic100.rst:232
msgid "AF_QIPCRTR clients and servers."
msgstr ""

#: ../../../accel/qaic/aic100.rst:241
msgid ""
"The DMA Bridge is one of the main interfaces to the host from the device "
"(the other being MHI). As part of activating a workload to run on NSPs, the "
"QSM assigns that network a DMA Bridge channel. A workload's DMA Bridge "
"channel (DBC for short) is solely for the use of that workload and is not "
"shared with other workloads."
msgstr ""

#: ../../../accel/qaic/aic100.rst:247
msgid ""
"Each DBC is a pair of FIFOs that manage data in and out of the workload. One "
"FIFO is the request FIFO. The other FIFO is the response FIFO."
msgstr ""

#: ../../../accel/qaic/aic100.rst:250
msgid "Each DBC contains 4 registers in hardware:"
msgstr ""

#: ../../../accel/qaic/aic100.rst:252
msgid ""
"Request FIFO head pointer (offset 0x0). Read only by the host. Indicates the "
"latest item in the FIFO the device has consumed."
msgstr ""

#: ../../../accel/qaic/aic100.rst:254
msgid ""
"Request FIFO tail pointer (offset 0x4). Read/write by the host. Host "
"increments this register to add new items to the FIFO."
msgstr ""

#: ../../../accel/qaic/aic100.rst:256
msgid ""
"Response FIFO head pointer (offset 0x8). Read/write by the host. Indicates "
"the latest item in the FIFO the host has consumed."
msgstr ""

#: ../../../accel/qaic/aic100.rst:258
msgid ""
"Response FIFO tail pointer (offset 0xc). Read only by the host. Device "
"increments this register to add new items to the FIFO."
msgstr ""

#: ../../../accel/qaic/aic100.rst:261
msgid ""
"The values in each register are indexes in the FIFO. To get the location of "
"the FIFO element pointed to by the register: FIFO base address + register * "
"element size."
msgstr ""

#: ../../../accel/qaic/aic100.rst:265
msgid ""
"DBC registers are exposed to the host via the second BAR. Each DBC consumes "
"4KB of space in the BAR."
msgstr ""

#: ../../../accel/qaic/aic100.rst:268
msgid ""
"The actual FIFOs are backed by host memory. When sending a request to the "
"QSM to activate a network, the host must donate memory to be used for the "
"FIFOs. Due to internal mapping limitations of the device, a single "
"contiguous chunk of memory must be provided per DBC, which hosts both FIFOs. "
"The request FIFO will consume the beginning of the memory chunk, and the "
"response FIFO will consume the end of the memory chunk."
msgstr ""

#: ../../../accel/qaic/aic100.rst:276
msgid "Request FIFO"
msgstr ""

#: ../../../accel/qaic/aic100.rst:278
msgid "A request FIFO element has the following structure:"
msgstr ""

#: ../../../accel/qaic/aic100.rst:302
msgid "Request field descriptions:"
msgstr ""

#: ../../../accel/qaic/aic100.rst:304 ../../../accel/qaic/aic100.rst:404
msgid "req_id"
msgstr ""

#: ../../../accel/qaic/aic100.rst:305
msgid ""
"request ID. A request FIFO element and a response FIFO element with the same "
"request ID refer to the same command."
msgstr ""

#: ../../../accel/qaic/aic100.rst:308
msgid "seq_id"
msgstr ""

#: ../../../accel/qaic/aic100.rst:309
msgid "sequence ID within a request. Ignored by the DMA Bridge."
msgstr ""

#: ../../../accel/qaic/aic100.rst:311
msgid "pcie_dma_cmd"
msgstr ""

#: ../../../accel/qaic/aic100.rst:312
msgid "describes the DMA element of this request."
msgstr ""

#: ../../../accel/qaic/aic100.rst:314
msgid ""
"Bit(7) is the force msi flag, which overrides the DMA Bridge MSI logic and "
"generates a MSI when this request is complete, and QSM configures the DMA "
"Bridge to look at this bit."
msgstr ""

#: ../../../accel/qaic/aic100.rst:317
msgid "Bits(6:5) are reserved."
msgstr ""

#: ../../../accel/qaic/aic100.rst:318
msgid ""
"Bit(4) is the completion code flag, and indicates that the DMA Bridge shall "
"generate a response FIFO element when this request is complete."
msgstr ""

#: ../../../accel/qaic/aic100.rst:321
msgid ""
"Bit(3) indicates if this request is a linked list transfer(0) or a bulk "
"transfer(1)."
msgstr ""

#: ../../../accel/qaic/aic100.rst:323
msgid "Bit(2) is reserved."
msgstr ""

#: ../../../accel/qaic/aic100.rst:324
msgid ""
"Bits(1:0) indicate the type of transfer. No transfer(0), to device(1), from "
"device(2). Value 3 is illegal."
msgstr ""

#: ../../../accel/qaic/aic100.rst:327
msgid "pcie_dma_source_addr"
msgstr ""

#: ../../../accel/qaic/aic100.rst:328
msgid "source address for a bulk transfer, or the address of the linked list."
msgstr ""

#: ../../../accel/qaic/aic100.rst:330
msgid "pcie_dma_dest_addr"
msgstr ""

#: ../../../accel/qaic/aic100.rst:331
msgid "destination address for a bulk transfer."
msgstr ""

#: ../../../accel/qaic/aic100.rst:333
msgid "pcie_dma_len"
msgstr ""

#: ../../../accel/qaic/aic100.rst:334
msgid ""
"length of the bulk transfer. Note that the size of this field limits "
"transfers to 4G in size."
msgstr ""

#: ../../../accel/qaic/aic100.rst:337
msgid "doorbell_addr"
msgstr ""

#: ../../../accel/qaic/aic100.rst:338
msgid "address of the doorbell to ring when this request is complete."
msgstr ""

#: ../../../accel/qaic/aic100.rst:340
msgid "doorbell_attr"
msgstr ""

#: ../../../accel/qaic/aic100.rst:341
msgid "doorbell attributes."
msgstr ""

#: ../../../accel/qaic/aic100.rst:343
msgid "Bit(7) indicates if a write to a doorbell is to occur."
msgstr ""

#: ../../../accel/qaic/aic100.rst:344
msgid "Bits(6:2) are reserved."
msgstr ""

#: ../../../accel/qaic/aic100.rst:345
msgid ""
"Bits(1:0) contain the encoding of the doorbell length. 0 is 32-bit, 1 is 16-"
"bit, 2 is 8-bit, 3 is reserved. The doorbell address must be naturally "
"aligned to the specified length."
msgstr ""

#: ../../../accel/qaic/aic100.rst:349
msgid "doorbell_data"
msgstr ""

#: ../../../accel/qaic/aic100.rst:350
msgid ""
"data to write to the doorbell. Only the bits corresponding to the doorbell "
"length are valid."
msgstr ""

#: ../../../accel/qaic/aic100.rst:353
msgid "sem_cmdN"
msgstr ""

#: ../../../accel/qaic/aic100.rst:354
msgid "semaphore command."
msgstr ""

#: ../../../accel/qaic/aic100.rst:356
msgid "Bit(31) indicates this semaphore command is enabled."
msgstr ""

#: ../../../accel/qaic/aic100.rst:357
msgid ""
"Bit(30) is the to-device DMA fence. Block this request until all to-device "
"DMA transfers are complete."
msgstr ""

#: ../../../accel/qaic/aic100.rst:359
msgid ""
"Bit(29) is the from-device DMA fence. Block this request until all from-"
"device DMA transfers are complete."
msgstr ""

#: ../../../accel/qaic/aic100.rst:361
msgid "Bits(28:27) are reserved."
msgstr ""

#: ../../../accel/qaic/aic100.rst:362
msgid ""
"Bits(26:24) are the semaphore command. 0 is NOP. 1 is init with the "
"specified value. 2 is increment. 3 is decrement. 4 is wait until the "
"semaphore is equal to the specified value. 5 is wait until the semaphore is "
"greater or equal to the specified value. 6 is \"P\", wait until semaphore is "
"greater than 0, then decrement by 1. 7 is reserved."
msgstr ""

#: ../../../accel/qaic/aic100.rst:368
msgid "Bit(23) is reserved."
msgstr ""

#: ../../../accel/qaic/aic100.rst:369
msgid ""
"Bit(22) is the semaphore sync. 0 is post sync, which means that the "
"semaphore operation is done after the DMA transfer. 1 is presync, which "
"gates the DMA transfer. Only one presync is allowed per request."
msgstr ""

#: ../../../accel/qaic/aic100.rst:373
msgid "Bit(21) is reserved."
msgstr ""

#: ../../../accel/qaic/aic100.rst:374
msgid "Bits(20:16) is the index of the semaphore to operate on."
msgstr ""

#: ../../../accel/qaic/aic100.rst:375
msgid "Bits(15:12) are reserved."
msgstr ""

#: ../../../accel/qaic/aic100.rst:376
msgid "Bits(11:0) are the semaphore value to use in operations."
msgstr ""

#: ../../../accel/qaic/aic100.rst:378
msgid "Overall, a request is processed in 4 steps:"
msgstr ""

#: ../../../accel/qaic/aic100.rst:380
msgid "If specified, the presync semaphore condition must be true"
msgstr ""

#: ../../../accel/qaic/aic100.rst:381
msgid "If enabled, the DMA transfer occurs"
msgstr ""

#: ../../../accel/qaic/aic100.rst:382
msgid "If specified, the postsync semaphore conditions must be true"
msgstr ""

#: ../../../accel/qaic/aic100.rst:383
msgid "If enabled, the doorbell is written"
msgstr ""

#: ../../../accel/qaic/aic100.rst:385
msgid ""
"By using the semaphores in conjunction with the workload running on the "
"NSPs, the data pipeline can be synchronized such that the host can queue "
"multiple requests of data for the workload to process, but the DMA Bridge "
"will only copy the data into the memory of the workload when the workload is "
"ready to process the next input."
msgstr ""

#: ../../../accel/qaic/aic100.rst:392
msgid "Response FIFO"
msgstr ""

#: ../../../accel/qaic/aic100.rst:394
msgid ""
"Once a request is fully processed, a response FIFO element is generated if "
"specified in pcie_dma_cmd. The structure of a response FIFO element:"
msgstr ""

#: ../../../accel/qaic/aic100.rst:405
msgid "matches the req_id of the request that generated this element."
msgstr ""

#: ../../../accel/qaic/aic100.rst:407
msgid "completion_code"
msgstr ""

#: ../../../accel/qaic/aic100.rst:408
msgid "status of this request. 0 is success. Non-zero is an error."
msgstr ""

#: ../../../accel/qaic/aic100.rst:410
msgid ""
"The DMA Bridge will generate a MSI to the host as a reaction to activity in "
"the response FIFO of a DBC. The DMA Bridge hardware has an IRQ storm "
"mitigation algorithm, where it will only generate a MSI when the response "
"FIFO transitions from empty to non-empty (unless force MSI is enabled and "
"triggered). In response to this MSI, the host is expected to drain the "
"response FIFO, and must take care to handle any race conditions between "
"draining the FIFO, and the device inserting elements into the FIFO."
msgstr ""

#: ../../../accel/qaic/aic100.rst:419
msgid "Neural Network Control (NNC) Protocol"
msgstr ""

#: ../../../accel/qaic/aic100.rst:421
msgid ""
"The NNC protocol is how the host makes requests to the QSM to manage "
"workloads. It uses the QAIC_CONTROL MHI channel."
msgstr ""

#: ../../../accel/qaic/aic100.rst:424
msgid ""
"Each NNC request is packaged into a message. Each message is a series of "
"transactions. A passthrough type transaction can contain elements known as "
"commands."
msgstr ""

#: ../../../accel/qaic/aic100.rst:428
msgid ""
"QSM requires NNC messages be little endian encoded and the fields be "
"naturally aligned. Since there are 64-bit elements in some NNC messages, 64-"
"bit alignment must be maintained."
msgstr ""

#: ../../../accel/qaic/aic100.rst:432
msgid ""
"A message contains a header and then a series of transactions. A message may "
"be at most 4K in size from QSM to the host. From the host to the QSM, a "
"message can be at most 64K (maximum size of a single MHI packet), but there "
"is a continuation feature where message N+1 can be marked as a continuation "
"of message N. This is used for exceedingly large DMA xfer transactions."
msgstr ""

#: ../../../accel/qaic/aic100.rst:439
msgid "Transaction descriptions"
msgstr ""

#: ../../../accel/qaic/aic100.rst:441
msgid "passthrough"
msgstr ""

#: ../../../accel/qaic/aic100.rst:442
msgid ""
"Allows userspace to send an opaque payload directly to the QSM. This is used "
"for NNC commands. Userspace is responsible for managing the QSM message "
"requirements in the payload."
msgstr ""

#: ../../../accel/qaic/aic100.rst:446
msgid "dma_xfer"
msgstr ""

#: ../../../accel/qaic/aic100.rst:447
msgid ""
"DMA transfer. Describes an object that the QSM should DMA into the device "
"via address and size tuples."
msgstr ""

#: ../../../accel/qaic/aic100.rst:450
msgid "activate"
msgstr ""

#: ../../../accel/qaic/aic100.rst:451
msgid ""
"Activate a workload onto NSPs. The host must provide memory to be used by "
"the DBC."
msgstr ""

#: ../../../accel/qaic/aic100.rst:454
msgid "deactivate"
msgstr ""

#: ../../../accel/qaic/aic100.rst:455
msgid "Deactivate an active workload and return the NSPs to idle."
msgstr ""

#: ../../../accel/qaic/aic100.rst:457
msgid "status"
msgstr ""

#: ../../../accel/qaic/aic100.rst:458
msgid ""
"Query the QSM about it's NNC implementation. Returns the NNC version, and if "
"CRC is used."
msgstr ""

#: ../../../accel/qaic/aic100.rst:461
msgid "terminate"
msgstr ""

#: ../../../accel/qaic/aic100.rst:462
msgid "Release a user's resources."
msgstr ""

#: ../../../accel/qaic/aic100.rst:464
msgid "dma_xfer_cont"
msgstr ""

#: ../../../accel/qaic/aic100.rst:465
msgid ""
"Continuation of a previous DMA transfer. If a DMA transfer cannot be "
"specified in a single message (highly fragmented), this transaction can be "
"used to specify more ranges."
msgstr ""

#: ../../../accel/qaic/aic100.rst:469
msgid "validate_partition"
msgstr ""

#: ../../../accel/qaic/aic100.rst:470
msgid "Query to QSM to determine if a partition identifier is valid."
msgstr ""

#: ../../../accel/qaic/aic100.rst:472
msgid ""
"Each message is tagged with a user id, and a partition id. The user id "
"allows QSM to track resources, and release them when the user goes away (eg "
"the process crashes). A partition id identifies the resource partition that "
"QSM manages, which this message applies to."
msgstr ""

#: ../../../accel/qaic/aic100.rst:477
msgid ""
"Messages may have CRCs. Messages should have CRCs applied until the QSM "
"reports via the status transaction that CRCs are not needed. The QSM on the "
"SA9000P requires CRCs for black channel safing."
msgstr ""

#: ../../../accel/qaic/aic100.rst:482
msgid "Subsystem Restart (SSR)"
msgstr ""

#: ../../../accel/qaic/aic100.rst:484
msgid ""
"SSR is the concept of limiting the impact of an error. An AIC100 device may "
"have multiple users, each with their own workload running. If the workload "
"of one user crashes, the fallout of that should be limited to that workload "
"and not impact other workloads. SSR accomplishes this."
msgstr ""

#: ../../../accel/qaic/aic100.rst:489
msgid ""
"If a particular workload crashes, QSM notifies the host via the QAIC_SSR MHI "
"channel. This notification identifies the workload by its assigned DBC. A "
"multi-stage recovery process is then used to cleanup both sides, and gets "
"the DBC/NSPs into a working state."
msgstr ""

#: ../../../accel/qaic/aic100.rst:494
msgid ""
"When SSR occurs, any state in the workload is lost. Any inputs that were in "
"process, or queued by not yet serviced, are lost. The loaded artifacts will "
"remain in on-card DDR, but the host will need to re-activate the workload if "
"it desires to recover the workload."
msgstr ""

#: ../../../accel/qaic/aic100.rst:499
msgid ""
"When SSR occurs for a specific NSP, the assigned DBC goes through the "
"following state transactions in order:"
msgstr ""

#: ../../../accel/qaic/aic100.rst:502
msgid "DBC_STATE_BEFORE_SHUTDOWN"
msgstr ""

#: ../../../accel/qaic/aic100.rst:503
msgid ""
"Indicates that the affected NSP was found in an unrecoverable error "
"condition."
msgstr ""

#: ../../../accel/qaic/aic100.rst:505
msgid "DBC_STATE_AFTER_SHUTDOWN"
msgstr ""

#: ../../../accel/qaic/aic100.rst:506
msgid "Indicates that the NSP is under reset."
msgstr ""

#: ../../../accel/qaic/aic100.rst:507
msgid "DBC_STATE_BEFORE_POWER_UP"
msgstr ""

#: ../../../accel/qaic/aic100.rst:508
msgid ""
"Indicates that the NSP's debug information has been collected, and is ready "
"to be collected by the host (if desired). At that stage the NSP is restarted "
"by QSM."
msgstr ""

#: ../../../accel/qaic/aic100.rst:511
msgid "DBC_STATE_AFTER_POWER_UP"
msgstr ""

#: ../../../accel/qaic/aic100.rst:512
msgid ""
"Indicates that the NSP has been restarted, fully operational and is in idle "
"state."
msgstr ""

#: ../../../accel/qaic/aic100.rst:515
msgid ""
"SSR also has an optional crashdump collection feature. If enabled, the host "
"can collect the memory dump for the crashed NSP and dump it to the user "
"space via the dev_coredump subsystem. The host can also decline the "
"crashdump collection request from the device."
msgstr ""

#: ../../../accel/qaic/aic100.rst:521
msgid "Reliability, Accessibility, Serviceability (RAS)"
msgstr ""

#: ../../../accel/qaic/aic100.rst:523
msgid ""
"AIC100 is expected to be deployed in server systems where RAS ideology is "
"applied. Simply put, RAS is the concept of detecting, classifying, and "
"reporting errors. While PCIe has AER (Advanced Error Reporting) which "
"factors into RAS, AER does not allow for a device to report details about "
"internal errors. Therefore, AIC100 implements a custom RAS mechanism. When a "
"RAS event occurs, QSM will report the event with appropriate details via the "
"QAIC_STATUS MHI channel. A sysadmin may determine that a particular device "
"needs additional service based on RAS reports."
msgstr ""

#: ../../../accel/qaic/aic100.rst:533
msgid "Telemetry"
msgstr ""

#: ../../../accel/qaic/aic100.rst:535
msgid ""
"QSM has the ability to report various physical attributes of the device, and "
"in some cases, to allow the host to control them. Examples include thermal "
"limits, thermal readings, and power readings. These items are communicated "
"via the QAIC_TELEMETRY MHI channel."
msgstr ""
