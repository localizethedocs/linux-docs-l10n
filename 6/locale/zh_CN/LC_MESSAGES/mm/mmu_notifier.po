# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/mmu_notifier.rst:2
msgid "When do you need to notify inside page table lock ?"
msgstr ""

#: ../../../mm/mmu_notifier.rst:4
msgid ""
"When clearing a pte/pmd we are given a choice to notify the event through "
"(notify version of \\*_clear_flush call mmu_notifier_invalidate_range) under "
"the page table lock. But that notification is not necessary in all cases."
msgstr ""

#: ../../../mm/mmu_notifier.rst:8
msgid ""
"For secondary TLB (non CPU TLB) like IOMMU TLB or device TLB (when device "
"use thing like ATS/PASID to get the IOMMU to walk the CPU page table to "
"access a process virtual address space). There is only 2 cases when you need "
"to notify those secondary TLB while holding page table lock when clearing a "
"pte/pmd:"
msgstr ""

#: ../../../mm/mmu_notifier.rst:13
msgid "page backing address is free before mmu_notifier_invalidate_range_end()"
msgstr ""

#: ../../../mm/mmu_notifier.rst:14
msgid ""
"a page table entry is updated to point to a new page (COW, write fault on "
"zero page, __replace_page(), ...)"
msgstr ""

#: ../../../mm/mmu_notifier.rst:17
msgid ""
"Case A is obvious you do not want to take the risk for the device to write "
"to a page that might now be used by some completely different task."
msgstr ""

#: ../../../mm/mmu_notifier.rst:20
msgid ""
"Case B is more subtle. For correctness it requires the following sequence to "
"happen:"
msgstr ""

#: ../../../mm/mmu_notifier.rst:23
msgid "take page table lock"
msgstr ""

#: ../../../mm/mmu_notifier.rst:24
msgid ""
"clear page table entry and notify ([pmd/pte]p_huge_clear_flush_notify())"
msgstr ""

#: ../../../mm/mmu_notifier.rst:25
msgid "set page table entry to point to new page"
msgstr ""

#: ../../../mm/mmu_notifier.rst:27
msgid ""
"If clearing the page table entry is not followed by a notify before setting "
"the new pte/pmd value then you can break memory model like C11 or C++11 for "
"the device."
msgstr ""

#: ../../../mm/mmu_notifier.rst:31
msgid ""
"Consider the following scenario (device use a feature similar to ATS/PASID):"
msgstr ""

#: ../../../mm/mmu_notifier.rst:33
msgid ""
"Two address addrA and addrB such that \\|addrA - addrB\\| >= PAGE_SIZE we "
"assume they are write protected for COW (other case of B apply too)."
msgstr ""

#: ../../../mm/mmu_notifier.rst:88
msgid ""
"So here because at time N+2 the clear page table entry was not pair with a "
"notification to invalidate the secondary TLB, the device see the new value "
"for addrB before seeing the new value for addrA. This break total memory "
"ordering for the device."
msgstr ""

#: ../../../mm/mmu_notifier.rst:93
msgid ""
"When changing a pte to write protect or to point to a new write protected "
"page with same content (KSM) it is fine to delay the "
"mmu_notifier_invalidate_range call to mmu_notifier_invalidate_range_end() "
"outside the page table lock. This is true even if the thread doing the page "
"table update is preempted right after releasing page table lock but before "
"call mmu_notifier_invalidate_range_end()."
msgstr ""
