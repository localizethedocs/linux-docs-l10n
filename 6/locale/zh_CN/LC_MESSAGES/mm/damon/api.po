# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/damon/api.rst:5
msgid "API Reference"
msgstr ""

#: ../../../mm/damon/api.rst:7
msgid ""
"Kernel space programs can use every feature of DAMON using below APIs.  All "
"you need to do is including ``damon.h``, which is located in ``include/linux/"
"`` of the source tree."
msgstr ""

#: ../../../mm/damon/api.rst:12
msgid "Structures"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:29
msgid "Represents an address region of [**start**, **end**)."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:33
#: ../include/linux/damon.h:43 ../include/linux/damon.h:53
#: ../include/linux/damon.h:93 ../include/linux/damon.h:177
#: ../include/linux/damon.h:217 ../include/linux/damon.h:301
#: ../include/linux/damon.h:329 ../include/linux/damon.h:400
#: ../include/linux/damon.h:435 ../include/linux/damon.h:457
#: ../include/linux/damon.h:475 ../include/linux/damon.h:491
#: ../include/linux/damon.h:593 ../include/linux/damon.h:684
#: ../include/linux/damon.h:709 ../include/linux/damon.h:751
msgid "**Definition**::"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:40
#: ../include/linux/damon.h:50 ../include/linux/damon.h:64
#: ../include/linux/damon.h:103 ../include/linux/damon.h:193
#: ../include/linux/damon.h:230 ../include/linux/damon.h:311
#: ../include/linux/damon.h:340 ../include/linux/damon.h:415
#: ../include/linux/damon.h:442 ../include/linux/damon.h:468
#: ../include/linux/damon.h:483 ../include/linux/damon.h:512
#: ../include/linux/damon.h:608 ../include/linux/damon.h:693
#: ../include/linux/damon.h:720 ../include/linux/damon.h:764
msgid "**Members**"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:30
msgid "``start``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:31
msgid "Start address of the region (inclusive)."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:31
msgid "``end``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:32
msgid "End address of the region (exclusive)."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:39
msgid "Represents size for filter to operate on [**min**, **max**]."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:40
msgid "``min``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:41
msgid "Min size (inclusive)."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:41
msgid "``max``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:42
msgid "Max size (inclusive)."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:49
msgid "Represents a monitoring target region."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:50
msgid "``ar``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:51
msgid "The address range of the region."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:51
msgid "``sampling_addr``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:52
msgid "Address of the sample for the next access check."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:52
msgid "``nr_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:53
msgid "Access frequency of this region."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:53
msgid "``nr_accesses_bp``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:54
msgid ""
"**nr_accesses** in basis point (0.01%) that updated for each sampling "
"interval."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:55
#: ../include/linux/damon.h:93 ../include/linux/damon.h:180
#: ../include/linux/damon.h:406 ../include/linux/damon.h:499
msgid "``list``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:56
#: ../include/linux/damon.h:94 ../include/linux/damon.h:181
#: ../include/linux/damon.h:407 ../include/linux/damon.h:500
msgid "List head for siblings."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:56
msgid "``age``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:57
msgid "Age of this region."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:60
#: ../include/linux/damon.h:98 ../include/linux/damon.h:153
#: ../include/linux/damon.h:177 ../include/linux/damon.h:184
#: ../include/linux/damon.h:226 ../include/linux/damon.h:306
#: ../include/linux/damon.h:336 ../include/linux/damon.h:394
#: ../include/linux/damon.h:410 ../include/linux/damon.h:438
#: ../include/linux/damon.h:478 ../include/linux/damon.h:503
#: ../include/linux/damon.h:604 ../include/linux/damon.h:689
#: ../include/linux/damon.h:718 ../include/linux/damon.h:778
#: ../../../mm/damon/api:20: ../mm/damon/core.c:64 ../mm/damon/core.c:91
#: ../mm/damon/core.c:703 ../mm/damon/core.c:752 ../mm/damon/core.c:814
#: ../mm/damon/core.c:1232 ../mm/damon/core.c:1341 ../mm/damon/core.c:1439
#: ../mm/damon/core.c:1478 ../mm/damon/core.c:2822 ../mm/damon/core.c:2894
msgid "**Description**"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:57
msgid ""
"**nr_accesses** is reset to zero for every :c:type:`damon_attrs-"
">aggr_interval <damon_attrs>` and be increased for every :c:type:"
"`damon_attrs->sample_interval <damon_attrs>` if an access to the region "
"during the last sampling interval is found.  The update of this field should "
"not be done with direct access but with the helper function, "
"damon_update_region_access_rate()."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:63
msgid ""
"**nr_accesses_bp** is another representation of **nr_accesses** in basis "
"point (1 in 10,000) that updated for every :c:type:`damon_attrs-"
">sample_interval <damon_attrs>` in a manner similar to moving sum.  By the "
"algorithm, this value becomes **nr_accesses** * 10000 for every :c:type:"
"`struct damon_attrs <damon_attrs>`->aggr_interval.  This can be used when "
"the aggregation interval is too huge and therefore cannot wait for it before "
"getting the access monitoring results."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:70
msgid ""
"**age** is initially zero, increased for each aggregation interval, and "
"reset to zero again if the access frequency is significantly changed.  If "
"two regions are merged into a new region, both **nr_accesses** and **age** "
"of the new region are set as region size-weighted average of those of the "
"two regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:89
msgid "Represents a monitoring target."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:90
msgid "``pid``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:91
msgid "The PID of the virtual address space to monitor."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:91
msgid "``nr_regions``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:92
msgid "Number of monitoring target regions of this target."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:92
msgid "``regions_list``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:93
msgid "Head of the monitoring target regions of this target."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:94
msgid "``obsolete``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:95
msgid "Whether the commit destination target is obsolete."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:95
msgid ""
"Each monitoring context could have multiple targets.  For example, a context "
"for virtual memory address spaces could have multiple target processes.  The "
"**pid** should be set for appropriate :c:type:`struct damon_operations "
"<damon_operations>` including the virtual address spaces monitoring "
"operations."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:100
msgid ""
"**obsolete** is used only for damon_commit_targets() source targets, to "
"specify the matching destination targets are obsolete.  Read "
"damon_commit_targets() to see how it is handled."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:114
msgid ""
"Represents an action of a Data Access Monitoring-based Operation Scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:118
#: ../include/linux/damon.h:154 ../include/linux/damon.h:288
#: ../include/linux/damon.h:365 ../include/linux/damon.h:577
msgid "**Constants**"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:120
msgid "``DAMOS_WILLNEED``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:121
msgid "Call ``madvise()`` for the region with MADV_WILLNEED."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:123
msgid "``DAMOS_COLD``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:124
msgid "Call ``madvise()`` for the region with MADV_COLD."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:126
msgid "``DAMOS_PAGEOUT``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:127
msgid "Reclaim the region."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:129
msgid "``DAMOS_HUGEPAGE``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:130
msgid "Call ``madvise()`` for the region with MADV_HUGEPAGE."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:132
msgid "``DAMOS_NOHUGEPAGE``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:133
msgid "Call ``madvise()`` for the region with MADV_NOHUGEPAGE."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:135
msgid "``DAMOS_LRU_PRIO``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:136
msgid "Prioritize the region on its LRU lists."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:138
msgid "``DAMOS_LRU_DEPRIO``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:139
msgid "Deprioritize the region on its LRU lists."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:141
msgid "``DAMOS_MIGRATE_HOT``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:142
msgid "Migrate the regions prioritizing warmer regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:144
msgid "``DAMOS_MIGRATE_COLD``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:145
msgid "Migrate the regions prioritizing colder regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:147
msgid "``DAMOS_STAT``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:148
msgid "Do nothing but count the stat."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:150
msgid "``NR_DAMOS_ACTIONS``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:151
msgid "Total number of DAMOS actions"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:128
msgid ""
"The support of each action is up to running :c:type:`struct damon_operations "
"<damon_operations>`. Refer to 'Operation Action' section of Documentation/mm/"
"damon/design.rst for status of the supports."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:132
msgid "Note that DAMOS_PAGEOUT doesn't trigger demotions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:150
msgid "Represents the metric to be used as the goal"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:156
msgid "``DAMOS_QUOTA_USER_INPUT``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:157
msgid "User-input value."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:159
msgid "``DAMOS_QUOTA_SOME_MEM_PSI_US``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:160
msgid "System level some memory PSI in us."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:162
msgid "``DAMOS_QUOTA_NODE_MEM_USED_BP``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:163
msgid "MemUsed ratio of a node."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:165
msgid "``DAMOS_QUOTA_NODE_MEM_FREE_BP``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:166
msgid "MemFree ratio of a node."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:168
msgid "``DAMOS_QUOTA_NODE_MEMCG_USED_BP``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:169
msgid "MemUsed ratio of a node for a cgroup."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:171
msgid "``DAMOS_QUOTA_NODE_MEMCG_FREE_BP``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:172
msgid "MemFree ratio of a node for a cgroup."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:174
msgid "``NR_DAMOS_QUOTA_GOAL_METRICS``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:175
msgid "Number of DAMOS quota goal metrics."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:159
msgid ""
"Metrics equal to larger than **NR_DAMOS_QUOTA_GOAL_METRICS** are unsupported."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:173
msgid "DAMOS scheme quota auto-tuning goal."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:174
#: ../include/linux/damon.h:298
msgid "``metric``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:175
msgid "Metric to be used for representing the goal."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:175
msgid "``target_value``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:176
msgid "Target value of **metric** to achieve with the tuning."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:176
msgid "``current_value``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:177
msgid "Current value of **metric**."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:2
msgid "anonymous"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:177
msgid "``last_psi_total``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:178
msgid "Last measured total PSI"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:1
msgid "``{unnamed_struct}``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:178
msgid "``nid``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:179
msgid "Node id."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:179
#: ../include/linux/damon.h:400
msgid "``memcg_id``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:180
msgid "Memcg id."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:181
msgid ""
"Data structure for getting the current score of the quota tuning goal.  The "
"score is calculated by how close **current_value** and **target_value** "
"are.  Then the score is entered to DAMON's internal feedback loop mechanism "
"to get the auto-tuned quota."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:186
msgid ""
"If **metric** is DAMOS_QUOTA_USER_INPUT, **current_value** should be "
"manually entered by the user, probably inside the kdamond callbacks.  "
"Otherwise, DAMON sets **current_value** with self-measured value of "
"**metric**."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:190
msgid ""
"If **metric** is DAMOS_QUOTA_NODE_MEM_{USED,FREE}_BP, **nid** represents the "
"node id of the target node to account the used/free memory."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:193
msgid ""
"If **metric** is DAMOS_QUOTA_NODE_MEMCG_{USED,FREE}_BP, **nid** and "
"**memcg_id** represents the node id and the cgroup to account the used "
"memory for."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:213
msgid "Controls the aggressiveness of the given scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:214
msgid "``reset_interval``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:215
msgid "Charge reset interval in milliseconds."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:215
msgid "``ms``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:216
msgid "Maximum milliseconds that the scheme can use."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:216
msgid "``sz``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:217
msgid "Maximum bytes of memory that the action can be applied."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:217
msgid "``goals``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:218
msgid "Head of quota tuning goals (:c:type:`damos_quota_goal`) list."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:218
msgid "``esz``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:219
msgid "Effective size quota in bytes."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:220
msgid "``weight_sz``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:221
msgid "Weight of the region's size for prioritization."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:221
msgid "``weight_nr_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:222
msgid "Weight of the region's nr_accesses for prioritization."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:222
msgid "``weight_age``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:223
msgid "Weight of the region's age for prioritization."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:223
msgid ""
"To avoid consuming too much CPU time or IO resources for applying the :c:"
"type:`struct damos <damos>`->action to large memory, DAMON allows users to "
"set time and/or size quotas.  The quotas can be set by writing non-zero "
"values to :c:type:`ms` and :c:type:`sz`, respectively.  If the time quota is "
"set, DAMON tries to use only up to :c:type:`ms` milliseconds within :c:type:"
"`reset_interval` for applying the action.  If the size quota is set, DAMON "
"tries to apply the action only up to :c:type:`sz` bytes within :c:type:"
"`reset_interval`."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:231
msgid ""
"To convince the different types of quotas and goals, DAMON internally "
"converts those into one single size quota called \"effective quota\".  DAMON "
"internally uses it as the only one real quota.  The conversion is made as "
"follows."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:236
msgid ""
"The time quota is transformed to a size quota using estimated throughput of "
"the scheme's action.  DAMON then compares it against :c:type:`sz` and uses "
"smaller one as the effective quota."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:240
msgid ""
"If **goals** is not empty, DAMON calculates yet another size quota based on "
"the goals using its internal feedback loop algorithm, for every "
"**reset_interval**. Then, if the new size quota is smaller than the "
"effective quota, it uses the new size quota as the effective quota."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:245
msgid "The resulting effective size quota in bytes is set to **esz**."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:247
msgid ""
"For selecting regions within the quota, DAMON prioritizes current scheme's "
"target memory regions using the :c:type:`struct damon_operations "
"<damon_operations>`->get_scheme_score. You could customize the "
"prioritization logic by setting :c:type:`weight_sz`, :c:type:"
"`weight_nr_accesses`, and :c:type:`weight_age`, because monitoring "
"operations are encouraged to respect those."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:284
msgid "Represents the watermark metric."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:290
msgid "``DAMOS_WMARK_NONE``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:291
msgid "Ignore the watermarks of the given scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:293
msgid "``DAMOS_WMARK_FREE_MEM_RATE``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:294
msgid "Free memory rate of the system in [0,1000]."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:296
msgid "``NR_DAMOS_WMARK_METRICS``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:297
msgid "Total number of DAMOS watermark metrics"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:297
msgid "Controls when a given scheme should be activated."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:299
msgid "Metric for the watermarks."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:299
msgid "``interval``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:300
msgid "Watermarks check time interval in microseconds."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:300
msgid "``high``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:301
msgid "High watermark."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:301
msgid "``mid``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:302
msgid "Middle watermark."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:302
msgid "``low``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:303
msgid "Low watermark."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:303
msgid ""
"If :c:type:`metric` is :c:type:`DAMOS_WMARK_NONE`, the scheme is always "
"active.  Being active means DAMON does monitoring and applying the action of "
"the scheme to appropriate memory regions.  Else, DAMON checks :c:type:"
"`metric` of the system for at least every :c:type:`interval` microseconds "
"and works as below."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:308
msgid ""
"If :c:type:`metric` is higher than :c:type:`high`, the scheme is "
"inactivated.  If :c:type:`metric` is between :c:type:`mid` and :c:type:"
"`low`, the scheme is activated.  If :c:type:`metric` is lower than :c:type:"
"`low`, the scheme is inactivated."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:325
msgid "Statistics on a given scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:326
msgid "``nr_tried``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:327
msgid "Total number of regions that the scheme is tried to be applied."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:327
msgid "``sz_tried``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:328
msgid "Total size of regions that the scheme is tried to be applied."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:328
msgid "``nr_applied``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:329
msgid "Total number of regions that the scheme is applied."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:329
msgid "``sz_applied``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:330
msgid "Total size of regions that the scheme is applied."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:330
msgid "``sz_ops_filter_passed``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:331
msgid "Total bytes that passed ops layer-handled DAMOS filters."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:332
msgid "``qt_exceeds``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:333
msgid "Total number of times the quota of the scheme has exceeded."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:333
msgid ""
"\"Tried an action to a region\" in this context means the DAMOS core logic "
"determined the region as eligible to apply the action.  The access pattern (:"
"c:type:`struct damos_access_pattern <damos_access_pattern>`), quotas (:c:"
"type:`struct damos_quota <damos_quota>`), watermarks (:c:type:`struct "
"damos_watermarks <damos_watermarks>`) and filters (:c:type:`struct "
"damos_filter <damos_filter>`) that handled on core logic can affect this.  "
"The core logic asks the operation set (:c:type:`struct damon_operations "
"<damon_operations>`) to apply the action to the region."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:340
msgid ""
"\"Applied an action to a region\" in this context means the operation set (:"
"c:type:`struct damon_operations <damon_operations>`) successfully applied "
"the action to the region, at least to a part of the region.  The filters (:c:"
"type:`struct damos_filter <damos_filter>`) that handled on operation set "
"layer and type of the action and pages of the region can affect this.  For "
"example, if a filter is set to exclude anonymous pages and the region has "
"only anonymous pages, the region will be failed at applying the action.  If "
"the action is :c:type:`DAMOS_PAGEOUT` and all pages of the region are "
"already paged out, the region will be failed at applying the action."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:361
msgid "Type of memory for :c:type:`struct damos_filter <damos_filter>`"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:367
msgid "``DAMOS_FILTER_TYPE_ANON``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:368
msgid "Anonymous pages."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:370
msgid "``DAMOS_FILTER_TYPE_ACTIVE``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:371
msgid "Active pages."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:373
msgid "``DAMOS_FILTER_TYPE_MEMCG``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:374
msgid "Specific memcg's pages."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:376
msgid "``DAMOS_FILTER_TYPE_YOUNG``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:377
msgid "Recently accessed pages."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:379
msgid "``DAMOS_FILTER_TYPE_HUGEPAGE_SIZE``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:380
msgid "Page is part of a hugepage."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:382
msgid "``DAMOS_FILTER_TYPE_UNMAPPED``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:383
msgid "Unmapped pages."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:385
msgid "``DAMOS_FILTER_TYPE_ADDR``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:386
msgid "Address range."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:388
msgid "``DAMOS_FILTER_TYPE_TARGET``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:389
msgid "Data Access Monitoring target."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:391
msgid "``NR_DAMOS_FILTER_TYPES``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:392
msgid "Number of filter types."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:371
msgid ""
"The anon pages type and memcg type filters are handled by underlying :c:type:"
"`struct damon_operations <damon_operations>` as a part of scheme action "
"trying, and therefore accounted as 'tried'.  In contrast, other types are "
"handled by core layer before trying of the action and therefore not "
"accounted as 'tried'."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:376
msgid ""
"The support of the filters that handled by :c:type:`struct damon_operations "
"<damon_operations>` depend on the running :c:type:`struct damon_operations "
"<damon_operations>`. :c:type:`enum DAMON_OPS_PADDR <DAMON_OPS_PADDR>` "
"supports both anon pages type and memcg type filters, while :c:type:`enum "
"DAMON_OPS_VADDR <DAMON_OPS_VADDR>` and :c:type:`enum DAMON_OPS_FVADDR "
"<DAMON_OPS_FVADDR>` don't support any of the two types."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:396
msgid "DAMOS action target memory filter."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:397
msgid "``type``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:398
msgid "Type of the target memory."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:398
msgid "``matching``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:399
msgid "Whether this is for **type**-matching memory."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:399
msgid "``allow``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:400
msgid "Whether to include or exclude the **matching** memory."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:401
msgid "Memcg id of the question if **type** is DAMOS_FILTER_MEMCG."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:401
msgid "``addr_range``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:402
msgid "Address range if **type** is DAMOS_FILTER_TYPE_ADDR."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:402
msgid "``target_idx``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:403
msgid ""
"Index of the :c:type:`struct damon_target <damon_target>` of :c:type:"
"`damon_ctx->adaptive_targets <damon_ctx>` if **type** is "
"DAMOS_FILTER_TYPE_TARGET."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:405
msgid "``sz_range``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:406
msgid "Size range if **type** is DAMOS_FILTER_TYPE_HUGEPAGE_SIZE."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:407
msgid ""
"Before applying the :c:type:`damos->action <damos>` to a memory region, "
"DAMOS checks if each byte of the region matches to this given condition and "
"avoid applying the action if so.  Support of each filter type depends on the "
"running :c:type:`struct damon_operations <damon_operations>` and the type.  "
"Refer to :c:type:`enum damos_filter_type <damos_filter_type>` for more "
"details."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:431
msgid "Control damos_walk()."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:433
msgid "``walk_fn``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:434
msgid "Function to be called back for each region."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:434
msgid "``data``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:435
msgid "Data that will be passed to walk functions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:435
msgid ""
"Control damos_walk(), which requests specific kdamond to invoke the given "
"function to each region that eligible to apply actions of the kdamond's "
"schemes.  Refer to damos_walk() for more details."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:453
msgid "Target access pattern of the given scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:454
#: ../include/linux/damon.h:772
msgid "``min_sz_region``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:455
msgid "Minimum size of target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:455
msgid "``max_sz_region``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:456
msgid "Maximum size of target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:456
msgid "``min_nr_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:457
msgid "Minimum ``->nr_accesses`` of target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:457
msgid "``max_nr_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:458
msgid "Maximum ``->nr_accesses`` of target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:458
msgid "``min_age_region``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:459
msgid "Minimum age of target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:459
msgid "``max_age_region``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:460
msgid "Maximum age of target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:471
msgid "Migration destination nodes and their weights."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:472
msgid "``node_id_arr``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:473
msgid "Array of migration destination node ids."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:473
msgid "``weight_arr``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:474
msgid "Array of migration weights for **node_id_arr**."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:474
msgid "``nr_dests``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:475
msgid "Length of the **node_id_arr** and **weight_arr** arrays."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:475
msgid ""
"**node_id_arr** is an array of the ids of migration destination nodes. "
"**weight_arr** is an array of the weights for those.  The weights in "
"**weight_arr** are for nodes in **node_id_arr** of same array index."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:487
msgid "Represents a Data Access Monitoring-based Operation Scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:488
msgid "``pattern``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:489
msgid "Access pattern of target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:489
msgid "``action``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:490
msgid ":c:type:`damos_action` to be applied to the target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:490
msgid "``apply_interval_us``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:491
msgid "The time between applying the **action**."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:491
msgid "``quota``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:492
msgid "Control the aggressiveness of this scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:492
msgid "``wmarks``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:493
msgid "Watermarks for automated (in)activation of this scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:494
msgid "``target_nid``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:495
msgid "Destination node if **action** is \"migrate_{hot,cold}\"."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:493
msgid "``migrate_dests``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:494
msgid "Destination nodes if **action** is \"migrate_{hot,cold}\"."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:495
msgid "``core_filters``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:496
msgid ""
"Additional set of :c:type:`struct damos_filter <damos_filter>` for :c:type:"
"`action`."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:496
msgid "``ops_filters``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:497
msgid ""
"ops layer handling :c:type:`struct damos_filter <damos_filter>` objects list."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:497
msgid "``last_applied``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:498
msgid "Last **action** applied ops-managing entity."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:498
msgid "``stat``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:499
msgid "Statistics of this scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:500
msgid ""
"For each **apply_interval_us**, DAMON finds regions which fit in the :c:type:"
"`pattern` and applies :c:type:`action` to those. To avoid consuming too much "
"CPU time or IO resources for the :c:type:`action`, :c:type:`quota` is used."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:504
msgid ""
"If **apply_interval_us** is zero, :c:type:`damon_attrs->aggr_interval "
"<damon_attrs>` is used instead."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:506
msgid ""
"To do the work only when needed, schemes can be activated for specific "
"system situations using :c:type:`wmarks`.  If all schemes that registered to "
"the monitoring context are inactive, DAMON stops monitoring either, and just "
"repeatedly checks the watermarks."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:511
msgid ""
"**migrate_dests** specifies multiple migration target nodes with different "
"weights for migrate_hot or migrate_cold actions.  **target_nid** is ignored "
"if this is set."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:515
msgid ""
"**target_nid** is used to set the migration target node for migrate_hot or "
"migrate_cold actions, and **migrate_dests** is unset."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:518
msgid ""
"Before applying the :c:type:`action` to a memory region, :c:type:`struct "
"damon_operations <damon_operations>` implementation could check pages of the "
"region and skip :c:type:`action` to respect :c:type:`core_filters`"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:522
msgid ""
"The minimum entity that **action** can be applied depends on the underlying :"
"c:type:`struct damon_operations <damon_operations>`.  Since it may not be "
"aligned with the core layer abstract, namely :c:type:`struct damon_region "
"<damon_region>`, :c:type:`struct damon_operations <damon_operations>` could "
"apply **action** to same entity multiple times.  Large folios that "
"underlying on multiple :c:type:`struct damon <damon>` region objects could "
"be such examples.  The :c:type:`struct damon_operations <damon_operations>` "
"can use **last_applied** to avoid that.  DAMOS core logic unsets "
"**last_applied** when each regions walking for applying the scheme is "
"finished."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:531
msgid ""
"After applying the :c:type:`action` to each region, :c:type:`stat_count` "
"and :c:type:`stat_sz` is updated to reflect the number of regions and total "
"size of regions that the :c:type:`action` is applied."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:573
msgid "Identifier for each monitoring operations implementation"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:579
msgid "``DAMON_OPS_VADDR``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:580
msgid "Monitoring operations for virtual address spaces"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:582
msgid "``DAMON_OPS_FVADDR``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:583
msgid "Monitoring operations for only fixed ranges of virtual address spaces"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:586
msgid "``DAMON_OPS_PADDR``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:587
msgid "Monitoring operations for the physical address space"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:589
msgid "``NR_DAMON_OPS``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:590
msgid "Number of monitoring operations implementations"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:589
msgid "Monitoring operations for given use cases."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:591
msgid "``id``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:592
msgid "Identifier of this operations set."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:592
msgid "``init``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:593
msgid "Initialize operations-related data structures."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:593
msgid "``update``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:594
msgid "Update operations-related data structures."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:594
msgid "``prepare_access_checks``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:595
msgid "Prepare next access check of target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:595
msgid "``check_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:596
msgid "Check the accesses to target regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:596
msgid "``get_scheme_score``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:597
msgid "Get the score of a region for a scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:597
msgid "``apply_scheme``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:598
msgid "Apply a DAMON-based operation scheme."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:598
msgid "``target_valid``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:599
msgid "Determine if the target is valid."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:599
msgid "``cleanup_target``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:600
msgid "Clean up each target before deallocation."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:600
msgid "``cleanup``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:601
msgid "Clean up the context."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:601
msgid ""
"DAMON can be extended for various address spaces and usages.  For this, "
"users should register the low level operations for their target address "
"space and usecase via the :c:type:`damon_ctx.ops <damon_ctx>`.  Then, the "
"monitoring thread (:c:type:`damon_ctx.kdamond <damon_ctx>`) calls **init** "
"and **prepare_access_checks** before starting the monitoring, **update** "
"after each :c:type:`damon_attrs.ops_update_interval <damon_attrs>`, and "
"**check_accesses**, **target_valid** and **prepare_access_checks** after "
"each :c:type:`damon_attrs.sample_interval <damon_attrs>`."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:609
msgid ""
"Each :c:type:`struct damon_operations <damon_operations>` instance having "
"valid **id** can be registered via damon_register_ops() and selected by "
"damon_select_ops() later. **init** should initialize operations-related data "
"structures.  For example, this could be used to construct proper monitoring "
"target regions and link those to **damon_ctx.adaptive_targets**. **update** "
"should update the operations-related data structures.  For example, this "
"could be used to update monitoring target regions for current status. "
"**prepare_access_checks** should manipulate the monitoring regions to be "
"prepared for the next access check. **check_accesses** should check the "
"accesses to each region that made after the last preparation and update the "
"number of observed accesses of each region. It should also return max number "
"of observed accesses that made as a result of its update.  The value will be "
"used for regions adjustment threshold. **get_scheme_score** should return "
"the priority score of a region for a scheme as an integer in [0, :c:type:"
"`DAMOS_MAX_SCORE`]. **apply_scheme** is called from **kdamond** when a "
"region for user provided DAMON-based operation scheme is found.  It should "
"apply the scheme's action to the region and return bytes of the region that "
"the action is successfully applied.  It should also report how many bytes of "
"the region has passed filters (:c:type:`struct damos_filter <damos_filter>`) "
"that handled by itself. **target_valid** should check whether the target is "
"still valid for the monitoring. **cleanup_target** is called before the "
"target will be deallocated. **cleanup** is called from **kdamond** just "
"before its termination."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:680
msgid "Monitoring intervals auto-tuning goal."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:682
msgid "``access_bp``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:683
msgid "Access events observation ratio to achieve in bp."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:683
msgid "``aggrs``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:684
msgid "Number of aggregations to achieve **access_bp** within."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:684
msgid "``min_sample_us``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:685
msgid "Minimum resulting sampling interval in microseconds."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:685
msgid "``max_sample_us``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:686
msgid "Maximum resulting sampling interval in microseconds."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:686
msgid ""
"DAMON automatically tunes :c:type:`damon_attrs->sample_interval "
"<damon_attrs>` and :c:type:`damon_attrs->aggr_interval <damon_attrs>` aiming "
"the ratio in bp (1/10,000) of DAMON-observed access events to theoretical "
"maximum amount within **aggrs** aggregations be same to **access_bp**.  The "
"logic increases :c:type:`damon_attrs->aggr_interval <damon_attrs>` and :c:"
"type:`damon_attrs->sampling_interval <damon_attrs>` in same ratio if the "
"current access events observation ratio is lower than the target for each "
"**aggrs** aggregations, and vice versa."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:694
msgid ""
"If **aggrs** is zero, the tuning is disabled and hence this struct is "
"ignored."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:705
#: ../include/linux/damon.h:752
msgid "Monitoring attributes for accuracy/overhead control."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:707
msgid "``sample_interval``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:708
msgid "The time between access samplings."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:708
msgid "``aggr_interval``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:709
msgid "The time between monitor results aggregations."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:709
msgid "``ops_update_interval``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:710
msgid "The time between monitoring operations updates."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:710
msgid "``intervals_goal``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:711
msgid "Intervals auto-tuning goal."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:711
msgid "``min_nr_regions``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:712
msgid "The minimum number of adaptive monitoring regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:713
msgid "``max_nr_regions``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:714
msgid "The maximum number of adaptive monitoring regions."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:715
msgid ""
"For each **sample_interval**, DAMON checks whether each region is accessed "
"or not during the last **sample_interval**.  If such access is found, DAMON "
"aggregates the information by increasing :c:type:`damon_region->nr_accesses "
"<damon_region>` for **aggr_interval** time.  For each **aggr_interval**, the "
"count is reset.  DAMON also checks whether the target memory regions need "
"update (e.g., by ``mmap()`` calls from the application, in case of virtual "
"memory monitoring) and applies the changes for each "
"**ops_update_interval**.  All time intervals are in micro-seconds.  Please "
"refer to :c:type:`struct damon_operations <damon_operations>` and :c:type:"
"`struct damon_call_control <damon_call_control>` for more detail."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:747
msgid ""
"Represents a context for each monitoring. This is the main interface that "
"allows users to set the attributes and get the results of the monitoring."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:751
msgid "``attrs``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:752
msgid "``kdamond``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:753
msgid "Kernel thread who does the monitoring."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:753
msgid "``kdamond_lock``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:754
msgid "Mutex for the synchronizations with **kdamond**."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:770
msgid "``ops``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:771
msgid "Set of monitoring operations for given use cases."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:771
msgid "``addr_unit``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:772
msgid "Scale factor for core to ops address conversion."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:773
#: ../../../mm/damon/api:20: ../mm/damon/core.c:2820
msgid "Minimum region size."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:773
msgid "``adaptive_targets``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:774
msgid "Head of monitoring targets (:c:type:`damon_target`) list."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:774
msgid "``schemes``"
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:775
msgid "Head of schemes (:c:type:`damos`) list."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:754
msgid ""
"For each monitoring context, one kernel thread for the monitoring is "
"created.  The pointer to the thread is stored in **kdamond**."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:757
msgid ""
"Once started, the monitoring thread runs until explicitly required to be "
"terminated or every monitoring target is invalid.  The validity of the "
"targets is checked via the :c:type:`damon_operations.target_valid "
"<damon_operations>` of **ops**.  The termination can also be explicitly "
"requested by calling damon_stop(). The thread sets **kdamond** to NULL when "
"it terminates. Therefore, users can know whether the monitoring is ongoing "
"or terminated by reading **kdamond**. Reads and writes to **kdamond** from "
"outside of the monitoring thread must be protected by **kdamond_lock**."
msgstr ""

#: ../../../mm/damon/api:14: ../include/linux/damon.h:766
msgid ""
"Note that the monitoring thread protects only **kdamond** via "
"**kdamond_lock**. Accesses to other fields must be protected by themselves."
msgstr ""

#: ../../../mm/damon/api.rst:18
msgid "Functions"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:43
msgid "Check if a given damon_operations is registered."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:47 ../mm/damon/core.c:65
#: ../mm/damon/core.c:91 ../mm/damon/core.c:285 ../mm/damon/core.c:703
#: ../mm/damon/core.c:751 ../mm/damon/core.c:814 ../mm/damon/core.c:977
#: ../mm/damon/core.c:1232 ../mm/damon/core.c:1274 ../mm/damon/core.c:1340
#: ../mm/damon/core.c:1403 ../mm/damon/core.c:1423 ../mm/damon/core.c:1439
#: ../mm/damon/core.c:1478 ../mm/damon/core.c:2819 ../mm/damon/core.c:2893
#: ../mm/damon/core.c:2923
msgid "**Parameters**"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:49 ../mm/damon/core.c:90
msgid "``enum damon_ops_id id``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:44
msgid "Id of the damon_operations to check if registered."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:3 ../mm/damon/core.c:46
#: ../mm/damon/core.c:66 ../mm/damon/core.c:93 ../mm/damon/core.c:284
#: ../mm/damon/core.c:707 ../mm/damon/core.c:1347 ../mm/damon/core.c:1403
#: ../mm/damon/core.c:1422 ../mm/damon/core.c:1450 ../mm/damon/core.c:1491
#: ../mm/damon/core.c:2827
msgid "**Return**"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:46
msgid "true if the ops is set, false otherwise."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:61
msgid "Register a monitoring operations set to DAMON."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:67
msgid "``struct damon_operations *ops``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:62
msgid "monitoring operations set to register."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:63
msgid ""
"This function registers a monitoring operations set of valid :c:type:`struct "
"damon_operations <damon_operations>`->id so that others can find and use "
"them later."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:67 ../mm/damon/core.c:94
#: ../mm/damon/core.c:708 ../mm/damon/core.c:1348 ../mm/damon/core.c:1403
#: ../mm/damon/core.c:1451 ../mm/damon/core.c:1492 ../mm/damon/core.c:2828
msgid "0 on success, negative error code otherwise."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:87
msgid "Select a monitoring operations to use with the context."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:93 ../mm/damon/core.c:705
#: ../mm/damon/core.c:753 ../mm/damon/core.c:1425 ../mm/damon/core.c:1441
#: ../mm/damon/core.c:1480
msgid "``struct damon_ctx *ctx``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:88
msgid "monitoring context to use the operations."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:89
msgid "id of the registered monitoring operations to select."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:90
msgid ""
"This function finds registered monitoring operations set of **id** and make "
"**ctx** to use it."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:281
msgid "Return if the filter is ops-hndled one."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:287
msgid "``enum damos_filter_type type``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:282
msgid "type of the filter."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:284
msgid ""
"true if the filter of **type** needs to be handled by ops layer, false "
"otherwise."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:699
msgid "Set attributes for the monitoring."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:700 ../mm/damon/core.c:748
msgid "monitoring context"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:702 ../mm/damon/core.c:2893
msgid "``struct damon_attrs *attrs``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:701
msgid "monitoring attributes"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:702
msgid ""
"This function should be called while the kdamond is not running, an access "
"check results aggregation is not ongoing (e.g., from damon_call()."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:705
msgid "Every time interval is in micro-seconds."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:747
msgid "Set data access monitoring based operation schemes."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:750
msgid "``struct damos **schemes``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:749
msgid "array of the schemes"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:751
msgid "``ssize_t nr_schemes``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:750
msgid "number of entries in **schemes**"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:751
msgid ""
"This function should not be called while the kdamond of the context is "
"running."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:810
msgid "Commit DAMOS quota goals to another quota."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:816
msgid "``struct damos_quota *dst``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:811
msgid "The commit destination DAMOS quota."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:813
msgid "``struct damos_quota *src``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:812
msgid "The commit source DAMOS quota."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:813
msgid ""
"Copies user-specified parameters for quota goals from **src** to **dst**.  "
"Users should use this function for quota goals-level parameters update of "
"running DAMON contexts, instead of manual in-place updates."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:817 ../mm/damon/core.c:1236
msgid ""
"This function should be called from parameters-update safe context, like "
"damon_call()."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:973
msgid ""
"decide whether to reject memory that didn't match with any given filter."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:979
msgid "``struct list_head *filters``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:975
msgid "Given DAMOS filters of a group."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1228
msgid "Commit parameters of a DAMON context to another."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1234
msgid "``struct damon_ctx *dst``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1229
msgid "The commit destination DAMON context."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1231
msgid "``struct damon_ctx *src``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1230
msgid "The commit source DAMON context."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1231
msgid ""
"This function copies user-specified parameters from **src** to **dst** and "
"update the internal status and results accordingly.  Users should use this "
"function for context-level parameters update of running context, instead of "
"manual in-place updates."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1270
msgid "Return number of currently running contexts."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1276 ../mm/damon/core.c:2925
msgid "``void``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1
msgid "no arguments"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1336
msgid "Starts the monitorings for a given group of contexts."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1342 ../mm/damon/core.c:1405
msgid "``struct damon_ctx **ctxs``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1337
msgid "an array of the pointers for contexts to start monitoring"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1339 ../mm/damon/core.c:1402
msgid "``int nr_ctxs``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1338 ../mm/damon/core.c:1401
msgid "size of **ctxs**"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1340
msgid "``bool exclusive``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1339
msgid "exclusiveness of this contexts group"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1340
msgid ""
"This function starts a group of monitoring threads for a group of monitoring "
"contexts.  One thread per each context is created and run in parallel.  The "
"caller should handle synchronization between the threads by itself.  If "
"**exclusive** is true and a group of threads that created by other "
"'damon_start()' call is currently running, this function does nothing but "
"returns -EBUSY."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1399
msgid "Stops the monitorings for a given group of contexts."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1400
msgid "an array of the pointers for contexts to stop monitoring"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1419
msgid "Returns if a given DAMON context is running."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1420
msgid "The DAMON context to see if running."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1422
msgid "true if **ctx** is running, false otherwise."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1435
msgid "Invoke a given function on DAMON worker thread (kdamond)."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1436
msgid "DAMON context to call the function for."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1438
msgid "``struct damon_call_control *control``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1437
msgid "Control variable of the call request."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1438
msgid ""
"Ask DAMON worker thread (kdamond) of **ctx** to call a function with an "
"argument data that respectively passed via :c:type:`damon_call_control->fn "
"<damon_call_control>` and :c:type:`damon_call_control->data "
"<damon_call_control>` of **control**.  If :c:type:`damon_call_control-"
">repeat <damon_call_control>` of **control** is unset, further wait until "
"the kdamond finishes handling of the request.  Otherwise, return as soon as "
"the request is made."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1444
msgid ""
"The kdamond executes the function with the argument in the main loop, just "
"after a sampling of the iteration is finished.  The function can hence "
"safely access the internal data of the :c:type:`struct damon_ctx "
"<damon_ctx>` without additional synchronization.  The return value of the "
"function will be saved in :c:type:`damon_call_control->return_code "
"<damon_call_control>`."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1474
msgid "Invoke a given functions while DAMOS walk regions."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1475
msgid "DAMON context to call the functions for."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1477
msgid "``struct damos_walk_control *control``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1476
msgid "Control variable of the walk request."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1477
msgid ""
"Ask DAMON worker thread (kdamond) of **ctx** to call a function for each "
"region that the kdamond will apply DAMOS action to, and wait until the "
"kdamond finishes handling of the request."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:1481
msgid ""
"The kdamond executes the given function in the main loop, for each region "
"just after it applied any DAMOS actions of **ctx** to it.  The invocation is "
"made only within one :c:type:`damos->apply_interval_us <damos>` since "
"damos_walk() invocation, for each scheme.  The given callback function can "
"hence safely access the internal data of :c:type:`struct damon_ctx "
"<damon_ctx>` and :c:type:`struct damon_region <damon_region>` that each of "
"the scheme will apply the action for next interval, without additional "
"synchronizations against the kdamond.  If every scheme of **ctx** passed at "
"least one :c:type:`damos->apply_interval_us <damos>`, kdamond marks the "
"request as completed so that damos_walk() can wakeup and return."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2815
msgid ""
"Set the region of the given monitoring target as requested, or biggest "
"'System RAM'."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2821
msgid "``struct damon_target *t``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2817
msgid "The monitoring target to set the region."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2819
msgid "``unsigned long *start``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2818
msgid "The pointer to the start address of the region."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2820
msgid "``unsigned long *end``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2819
msgid "The pointer to the end address of the region."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2821
msgid "``unsigned long min_sz_region``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2821
msgid ""
"This function sets the region of **t** as requested by **start** and "
"**end**.  If the values of **start** and **end** are zero, however, this "
"function finds the biggest 'System RAM' resource and sets the region to "
"cover the resource.  In the latter case, this function saves the start and "
"end addresses of the resource in **start** and **end**, respectively."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2889
msgid "Update the access rate of a region."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2895
msgid "``struct damon_region *r``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2890
msgid "The DAMON region to update for its access check result."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2892
msgid "``bool accessed``"
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2891
msgid "Whether the region has accessed during last sampling interval."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2892
msgid "The damon_attrs of the DAMON context."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2893
msgid ""
"Update the access rate of a region with the region's last sampling interval "
"access check result."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2896
msgid ""
"Usually this will be called by :c:type:`damon_operations->check_accesses "
"<damon_operations>` callback."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2919
msgid "Return if DAMON is ready to be used."
msgstr ""

#: ../../../mm/damon/api:20: ../mm/damon/core.c:2921
msgid "true if DAMON is ready to be used, false otherwise."
msgstr ""
