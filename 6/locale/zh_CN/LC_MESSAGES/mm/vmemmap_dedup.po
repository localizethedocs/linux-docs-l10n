# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/vmemmap_dedup.rst:6
msgid "A vmemmap diet for HugeTLB and Device DAX"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:9
msgid "HugeTLB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:11
msgid ""
"This section is to explain how HugeTLB Vmemmap Optimization (HVO) works."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:13
msgid ""
"The ``struct page`` structures are used to describe a physical page frame. "
"By default, there is a one-to-one mapping from a page frame to its "
"corresponding ``struct page``."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:17
msgid ""
"HugeTLB pages consist of multiple base page size pages and is supported by "
"many architectures. See Documentation/admin-guide/mm/hugetlbpage.rst for "
"more details. On the x86-64 architecture, HugeTLB pages of size 2MB and 1GB "
"are currently supported. Since the base page size on x86 is 4KB, a 2MB "
"HugeTLB page consists of 512 base pages and a 1GB HugeTLB page consists of "
"262144 base pages. For each base page, there is a corresponding ``struct "
"page``."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:24
msgid ""
"Within the HugeTLB subsystem, only the first 4 ``struct page`` are used to "
"contain unique information about a HugeTLB page. ``__NR_USED_SUBPAGE`` "
"provides this upper limit. The only 'useful' information in the remaining "
"``struct page`` is the compound_head field, and this field is the same for "
"all tail pages."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:29
msgid ""
"By removing redundant ``struct page`` for HugeTLB pages, memory can be "
"returned to the buddy allocator for other uses."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:32
msgid ""
"Different architectures support different HugeTLB pages. For example, the "
"following table is the HugeTLB page size supported by x86 and arm64 "
"architectures. Because arm64 supports 4k, 16k, and 64k base pages and "
"supports contiguous entries, so it supports many kinds of sizes of HugeTLB "
"page."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:39
msgid "Architecture"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:39
msgid "Page Size"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:39
msgid "HugeTLB Page Size"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:41
msgid "x86-64"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:41 ../../../mm/vmemmap_dedup.rst:43
msgid "4KB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:41 ../../../mm/vmemmap_dedup.rst:43
#: ../../../mm/vmemmap_dedup.rst:45 ../../../mm/vmemmap_dedup.rst:47
msgid "2MB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:41 ../../../mm/vmemmap_dedup.rst:43
#: ../../../mm/vmemmap_dedup.rst:45
msgid "1GB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:45
msgid "arm64"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:43 ../../../mm/vmemmap_dedup.rst:47
msgid "64KB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:43 ../../../mm/vmemmap_dedup.rst:45
msgid "32MB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:45
msgid "16KB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:47
msgid "512MB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:47
msgid "16GB"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:50
msgid ""
"When the system boot up, every HugeTLB page has more than one ``struct "
"page`` structs which size is (unit: pages)::"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:55
msgid ""
"Where HugeTLB_Size is the size of the HugeTLB page. We know that the size of "
"the HugeTLB page is always n times PAGE_SIZE. So we can get the following "
"relationship::"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:61
msgid "Then::"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:66
msgid "We can use huge mapping at the pud/pmd level for the HugeTLB page."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:68
msgid "For the HugeTLB page of the pmd level mapping, then::"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:76
msgid ""
"Where n is how many pte entries which one page can contains. So the value of "
"n is (PAGE_SIZE / sizeof(pte_t))."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:79
msgid ""
"This optimization only supports 64-bit system, so the value of sizeof(pte_t) "
"is 8. And this optimization also applicable only when the size of ``struct "
"page`` is a power of two. In most cases, the size of ``struct page`` is 64 "
"bytes (e.g. x86-64 and arm64). So if we use pmd level mapping for a HugeTLB "
"page, the size of ``struct page`` structs of it is 8 page frames which size "
"depends on the size of the base page."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:86
msgid "For the HugeTLB page of the pud level mapping, then::"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:92
msgid ""
"Where the struct_size(pmd) is the size of the ``struct page`` structs of a "
"HugeTLB page of the pmd level mapping."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:95
msgid ""
"E.g.: A 2MB HugeTLB page on x86_64 consists in 8 page frames while 1GB "
"HugeTLB page consists in 4096."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:98
msgid ""
"Next, we take the pmd level mapping of the HugeTLB page as an example to "
"show the internal implementation of this optimization. There are 8 pages "
"``struct page`` structs associated with a HugeTLB page which is pmd mapped."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:102
msgid "Here is how things look before optimization::"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:127
msgid ""
"The value of page->compound_head is the same for all tail pages. The first "
"page of ``struct page`` (page 0) associated with the HugeTLB page contains "
"the 4 ``struct page`` necessary to describe the HugeTLB. The only use of the "
"remaining pages of ``struct page`` (page 1 to page 7) is to point to page-"
">compound_head. Therefore, we can remap pages 1 to 7 to page 0. Only 1 page "
"of ``struct page`` will be used for each HugeTLB page. This will allow us to "
"free the remaining 7 pages to the buddy allocator."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:135
msgid "Here is how things look after remapping::"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:160
msgid ""
"When a HugeTLB is freed to the buddy system, we should allocate 7 pages for "
"vmemmap pages and restore the previous mapping relationship."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:163
msgid ""
"For the HugeTLB page of the pud level mapping. It is similar to the former. "
"We also can use this approach to free (PAGE_SIZE - 1) vmemmap pages."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:166
msgid ""
"Apart from the HugeTLB page of the pmd/pud level mapping, some architectures "
"(e.g. aarch64) provides a contiguous bit in the translation table entries "
"that hints to the MMU to indicate that it is one of a contiguous set of "
"entries that can be cached in a single TLB entry."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:171
msgid ""
"The contiguous bit is used to increase the mapping size at the pmd and pte "
"(last) level. So this type of HugeTLB page can be optimized only when its "
"size of the ``struct page`` structs is greater than **1** page."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:175
msgid ""
"Notice: The head vmemmap page is not freed to the buddy allocator and all "
"tail vmemmap pages are mapped to the head vmemmap page frame. So we can see "
"more than one ``struct page`` struct with ``PG_head`` (e.g. 8 per 2 MB "
"HugeTLB page) associated with each HugeTLB page. The ``compound_head()`` can "
"handle this correctly. There is only **one** head ``struct page``, the tail "
"``struct page`` with ``PG_head`` are fake head ``struct page``.  We need an "
"approach to distinguish between those two different types of ``struct page`` "
"so that ``compound_head()`` can return the real head ``struct page`` when "
"the parameter is the tail ``struct page`` but with ``PG_head``."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:186
msgid "Device DAX"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:188
msgid ""
"The device-dax interface uses the same tail deduplication technique "
"explained in the previous chapter, except when used with the vmemmap in the "
"device (altmap)."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:192
msgid ""
"The following page sizes are supported in DAX: PAGE_SIZE (4K on x86_64), "
"PMD_SIZE (2M on x86_64) and PUD_SIZE (1G on x86_64). For powerpc equivalent "
"details see Documentation/arch/powerpc/vmemmap_dedup.rst"
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:196
msgid "The differences with HugeTLB are relatively minor."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:198
msgid ""
"It only use 3 ``struct page`` for storing all information as opposed to 4 on "
"HugeTLB pages."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:201
msgid ""
"There's no remapping of vmemmap given that device-dax memory is not part of "
"System RAM ranges initialized at boot. Thus the tail page deduplication "
"happens at a later stage when we populate the sections. HugeTLB reuses the "
"the head vmemmap page representing, whereas device-dax reuses the tail "
"vmemmap page. This results in only half of the savings compared to HugeTLB."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:207
msgid "Deduplicated tail pages are not mapped read-only."
msgstr ""

#: ../../../mm/vmemmap_dedup.rst:209
msgid ""
"Here's how things look like on device-dax after the sections are populated::"
msgstr ""
