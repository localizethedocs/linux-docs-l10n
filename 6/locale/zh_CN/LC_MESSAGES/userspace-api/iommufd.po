# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/iommufd.rst:5
msgid "IOMMUFD"
msgstr ""

#: ../../../userspace-api/iommufd.rst:0
msgid "Author"
msgstr ""

#: ../../../userspace-api/iommufd.rst:7
msgid "Jason Gunthorpe"
msgstr ""

#: ../../../userspace-api/iommufd.rst:8
msgid "Kevin Tian"
msgstr ""

#: ../../../userspace-api/iommufd.rst:11
msgid "Overview"
msgstr ""

#: ../../../userspace-api/iommufd.rst:13
msgid ""
"IOMMUFD is the user API to control the IOMMU subsystem as it relates to "
"managing IO page tables from userspace using file descriptors. It intends to "
"be general and consumable by any driver that wants to expose DMA to "
"userspace. These drivers are eventually expected to deprecate any internal "
"IOMMU logic they may already/historically implement (e.g. vfio_iommu_type1."
"c)."
msgstr ""

#: ../../../userspace-api/iommufd.rst:19
msgid ""
"At minimum iommufd provides universal support of managing I/O address spaces "
"and I/O page tables for all IOMMUs, with room in the design to add non-"
"generic features to cater to specific hardware functionality."
msgstr ""

#: ../../../userspace-api/iommufd.rst:23
msgid ""
"In this context the capital letter (IOMMUFD) refers to the subsystem while "
"the small letter (iommufd) refers to the file descriptors created via /dev/"
"iommu for use by userspace."
msgstr ""

#: ../../../userspace-api/iommufd.rst:28
msgid "Key Concepts"
msgstr ""

#: ../../../userspace-api/iommufd.rst:31
msgid "User Visible Objects"
msgstr ""

#: ../../../userspace-api/iommufd.rst:33
msgid "Following IOMMUFD objects are exposed to userspace:"
msgstr ""

#: ../../../userspace-api/iommufd.rst:35
msgid ""
"IOMMUFD_OBJ_IOAS, representing an I/O address space (IOAS), allowing map/"
"unmap of user space memory into ranges of I/O Virtual Address (IOVA)."
msgstr ""

#: ../../../userspace-api/iommufd.rst:38
msgid ""
"The IOAS is a functional replacement for the VFIO container, and like the "
"VFIO container it copies an IOVA map to a list of iommu_domains held within "
"it."
msgstr ""

#: ../../../userspace-api/iommufd.rst:41
msgid ""
"IOMMUFD_OBJ_DEVICE, representing a device that is bound to iommufd by an "
"external driver."
msgstr ""

#: ../../../userspace-api/iommufd.rst:44
msgid ""
"IOMMUFD_OBJ_HWPT_PAGING, representing an actual hardware I/O page table (i."
"e. a single struct iommu_domain) managed by the iommu driver. \"PAGING\" "
"primarily indicates this type of HWPT should be linked to an IOAS. It also "
"indicates that it is backed by an iommu_domain with __IOMMU_DOMAIN_PAGING "
"feature flag. This can be either an UNMANAGED stage-1 domain for a device "
"running in the user space, or a nesting parent stage-2 domain for mappings "
"from guest-level physical addresses to host-level physical addresses."
msgstr ""

#: ../../../userspace-api/iommufd.rst:52
msgid ""
"The IOAS has a list of HWPT_PAGINGs that share the same IOVA mapping and it "
"will synchronize its mapping with each member HWPT_PAGING."
msgstr ""

#: ../../../userspace-api/iommufd.rst:55
msgid ""
"IOMMUFD_OBJ_HWPT_NESTED, representing an actual hardware I/O page table (i."
"e. a single struct iommu_domain) managed by user space (e.g. guest OS). "
"\"NESTED\" indicates that this type of HWPT should be linked to an "
"HWPT_PAGING. It also indicates that it is backed by an iommu_domain that has "
"a type of IOMMU_DOMAIN_NESTED. This must be a stage-1 domain for a device "
"running in the user space (e.g. in a guest VM enabling the IOMMU nested "
"translation feature.) As such, it must be created with a given nesting "
"parent stage-2 domain to associate to. This nested stage-1 page table "
"managed by the user space usually has mappings from guest-level I/O virtual "
"addresses to guest- level physical addresses."
msgstr ""

#: ../../../userspace-api/iommufd.rst:66
msgid ""
"IOMMUFD_FAULT, representing a software queue for an HWPT reporting IO page "
"faults using the IOMMU HW's PRI (Page Request Interface). This queue object "
"provides user space an FD to poll the page fault events and also to respond "
"to those events. A FAULT object must be created first to get a fault_id that "
"could be then used to allocate a fault-enabled HWPT via the IOMMU_HWPT_ALLOC "
"command by setting the IOMMU_HWPT_FAULT_ID_VALID bit in its flags field."
msgstr ""

#: ../../../userspace-api/iommufd.rst:73
msgid ""
"IOMMUFD_OBJ_VIOMMU, representing a slice of the physical IOMMU instance, "
"passed to or shared with a VM. It may be some HW-accelerated virtualization "
"features and some SW resources used by the VM. For examples:"
msgstr ""

#: ../../../userspace-api/iommufd.rst:77
msgid "Security namespace for guest owned ID, e.g. guest-controlled cache tags"
msgstr ""

#: ../../../userspace-api/iommufd.rst:78
msgid "Non-device-affiliated event reporting, e.g. invalidation queue errors"
msgstr ""

#: ../../../userspace-api/iommufd.rst:79
msgid "Access to a shareable nesting parent pagetable across physical IOMMUs"
msgstr ""

#: ../../../userspace-api/iommufd.rst:80
msgid "Virtualization of various platforms IDs, e.g. RIDs and others"
msgstr ""

#: ../../../userspace-api/iommufd.rst:81
msgid "Delivery of paravirtualized invalidation"
msgstr ""

#: ../../../userspace-api/iommufd.rst:82
msgid "Direct assigned invalidation queues"
msgstr ""

#: ../../../userspace-api/iommufd.rst:83
msgid "Direct assigned interrupts"
msgstr ""

#: ../../../userspace-api/iommufd.rst:85
msgid ""
"Such a vIOMMU object generally has the access to a nesting parent pagetable "
"to support some HW-accelerated virtualization features. So, a vIOMMU object "
"must be created given a nesting parent HWPT_PAGING object, and then it would "
"encapsulate that HWPT_PAGING object. Therefore, a vIOMMU object can be used "
"to allocate an HWPT_NESTED object in place of the encapsulated HWPT_PAGING."
msgstr ""

#: ../../../userspace-api/iommufd.rst:93
msgid ""
"The name \"vIOMMU\" isn't necessarily identical to a virtualized IOMMU in a "
"VM. A VM can have one giant virtualized IOMMU running on a machine having "
"multiple physical IOMMUs, in which case the VMM will dispatch the requests "
"or configurations from this single virtualized IOMMU instance to multiple "
"vIOMMU objects created for individual slices of different physical IOMMUs. "
"In other words, a vIOMMU object is always a representation of one physical "
"IOMMU, not necessarily of a virtualized IOMMU. For VMMs that want the full "
"virtualization features from physical IOMMUs, it is suggested to build the "
"same number of virtualized IOMMUs as the number of physical IOMMUs, so the "
"passed-through devices would be connected to their own virtualized IOMMUs "
"backed by corresponding vIOMMU objects, in which case a guest OS would do "
"the \"dispatch\" naturally instead of VMM trappings."
msgstr ""

#: ../../../userspace-api/iommufd.rst:106
msgid ""
"IOMMUFD_OBJ_VDEVICE, representing a virtual device for an IOMMUFD_OBJ_DEVICE "
"against an IOMMUFD_OBJ_VIOMMU. This virtual device holds the device's "
"virtual information or attributes (related to the vIOMMU) in a VM. An "
"immediate vDATA example can be the virtual ID of the device on a vIOMMU, "
"which is a unique ID that VMM assigns to the device for a translation "
"channel/port of the vIOMMU, e.g. vSID of ARM SMMUv3, vDeviceID of AMD IOMMU, "
"and vRID of Intel VT-d to a Context Table. Potential use cases of some "
"advanced security information can be forwarded via this object too, such as "
"security level or realm information in a Confidential Compute Architecture. "
"A VMM should create a vDEVICE object to forward all the device information "
"in a VM, when it connects a device to a vIOMMU, which is a separate ioctl "
"call from attaching the same device to an HWPT_PAGING that the vIOMMU holds."
msgstr ""

#: ../../../userspace-api/iommufd.rst:119
msgid ""
"IOMMUFD_OBJ_VEVENTQ, representing a software queue for a vIOMMU to report "
"its events such as translation faults occurred to a nested stage-1 "
"(excluding I/O page faults that should go through IOMMUFD_OBJ_FAULT) and HW-"
"specific events. This queue object provides user space an FD to poll/read "
"the vIOMMU events. A vIOMMU object must be created first to get its "
"viommu_id, which could be then used to allocate a vEVENTQ. Each vIOMMU can "
"support multiple types of vEVENTS, but is confined to one vEVENTQ per "
"vEVENTQ type."
msgstr ""

#: ../../../userspace-api/iommufd.rst:127
msgid ""
"IOMMUFD_OBJ_HW_QUEUE, representing a hardware accelerated queue, as a subset "
"of IOMMU's virtualization features, for the IOMMU HW to directly read or "
"write the virtual queue memory owned by a guest OS. This HW-acceleration "
"feature can allow VM to work with the IOMMU HW directly without a VM Exit, "
"so as to reduce overhead from the hypercalls. Along with the HW QUEUE "
"object, iommufd provides user space an mmap interface for VMM to mmap a "
"physical MMIO region from the host physical address space to the guest "
"physical address space, allowing the guest OS to directly control the "
"allocated HW QUEUE. Thus, when allocating a HW QUEUE, the VMM must request a "
"pair of mmap info (offset/length) and pass in exactly to an mmap syscall via "
"its offset and length arguments."
msgstr ""

#: ../../../userspace-api/iommufd.rst:138
msgid "All user-visible objects are destroyed via the IOMMU_DESTROY uAPI."
msgstr ""

#: ../../../userspace-api/iommufd.rst:140
msgid ""
"The diagrams below show relationships between user-visible objects and "
"kernel datastructures (external to iommufd), with numbers referred to "
"operations creating the objects and links::"
msgstr ""

#: ../../../userspace-api/iommufd.rst:198
msgid ""
"IOMMUFD_OBJ_IOAS is created via the IOMMU_IOAS_ALLOC uAPI. An iommufd can "
"hold multiple IOAS objects. IOAS is the most generic object and does not "
"expose interfaces that are specific to single IOMMU drivers. All operations "
"on the IOAS must operate equally on each of the iommu_domains inside of it."
msgstr ""

#: ../../../userspace-api/iommufd.rst:203
msgid ""
"IOMMUFD_OBJ_DEVICE is created when an external driver calls the IOMMUFD kAPI "
"to bind a device to an iommufd. The driver is expected to implement a set of "
"ioctls to allow userspace to initiate the binding operation. Successful "
"completion of this operation establishes the desired DMA ownership over the "
"device. The driver must also set the driver_managed_dma flag and must not "
"touch the device until this operation succeeds."
msgstr ""

#: ../../../userspace-api/iommufd.rst:210
msgid "IOMMUFD_OBJ_HWPT_PAGING can be created in two ways:"
msgstr ""

#: ../../../userspace-api/iommufd.rst:212
msgid ""
"IOMMUFD_OBJ_HWPT_PAGING is automatically created when an external driver "
"calls the IOMMUFD kAPI to attach a bound device to an IOAS. Similarly the "
"external driver uAPI allows userspace to initiate the attaching operation. "
"If a compatible member HWPT_PAGING object exists in the IOAS's HWPT_PAGING "
"list, then it will be reused. Otherwise a new HWPT_PAGING that represents an "
"iommu_domain to userspace will be created, and then added to the list. "
"Successful completion of this operation sets up the linkages among IOAS, "
"device and iommu_domain. Once this completes the device could do DMA."
msgstr ""

#: ../../../userspace-api/iommufd.rst:221
msgid ""
"IOMMUFD_OBJ_HWPT_PAGING can be manually created via the IOMMU_HWPT_ALLOC "
"uAPI, provided an ioas_id via @pt_id to associate the new HWPT_PAGING to the "
"corresponding IOAS object. The benefit of this manual allocation is to allow "
"allocation flags (defined in enum iommufd_hwpt_alloc_flags), e.g. it "
"allocates a nesting parent HWPT_PAGING if the IOMMU_HWPT_ALLOC_NEST_PARENT "
"flag is set."
msgstr ""

#: ../../../userspace-api/iommufd.rst:228
msgid ""
"IOMMUFD_OBJ_HWPT_NESTED can be only manually created via the "
"IOMMU_HWPT_ALLOC uAPI, provided an hwpt_id or a viommu_id of a vIOMMU object "
"encapsulating a nesting parent HWPT_PAGING via @pt_id to associate the new "
"HWPT_NESTED object to the corresponding HWPT_PAGING object. The associating "
"HWPT_PAGING object must be a nesting parent manually allocated via the same "
"uAPI previously with an IOMMU_HWPT_ALLOC_NEST_PARENT flag, otherwise the "
"allocation will fail. The allocation will be further validated by the IOMMU "
"driver to ensure that the nesting parent domain and the nested domain being "
"allocated are compatible. Successful completion of this operation sets up "
"linkages among IOAS, device, and iommu_domains. Once this completes the "
"device could do DMA via a 2-stage translation, a.k.a nested translation. "
"Note that multiple HWPT_NESTED objects can be allocated by (and then "
"associated to) the same nesting parent."
msgstr ""

#: ../../../userspace-api/iommufd.rst:243
msgid ""
"Either a manual IOMMUFD_OBJ_HWPT_PAGING or an IOMMUFD_OBJ_HWPT_NESTED is "
"created via the same IOMMU_HWPT_ALLOC uAPI. The difference is at the type of "
"the object passed in via the @pt_id field of struct iommufd_hwpt_alloc."
msgstr ""

#: ../../../userspace-api/iommufd.rst:247
msgid ""
"IOMMUFD_OBJ_VIOMMU can be only manually created via the IOMMU_VIOMMU_ALLOC "
"uAPI, provided a dev_id (for the device's physical IOMMU to back the vIOMMU) "
"and an hwpt_id (to associate the vIOMMU to a nesting parent HWPT_PAGING). "
"The iommufd core will link the vIOMMU object to the struct iommu_device that "
"the struct device is behind. And an IOMMU driver can implement a "
"viommu_alloc op to allocate its own vIOMMU data structure embedding the core-"
"level structure iommufd_viommu and some driver-specific data. If necessary, "
"the driver can also configure its HW virtualization feature for that vIOMMU "
"(and thus for the VM). Successful completion of this operation sets up the "
"linkages between the vIOMMU object and the HWPT_PAGING, then this vIOMMU "
"object can be used as a nesting parent object to allocate an HWPT_NESTED "
"object described above."
msgstr ""

#: ../../../userspace-api/iommufd.rst:259
msgid ""
"IOMMUFD_OBJ_VDEVICE can be only manually created via the IOMMU_VDEVICE_ALLOC "
"uAPI, provided a viommu_id for an iommufd_viommu object and a dev_id for an "
"iommufd_device object. The vDEVICE object will be the binding between these "
"two parent objects. Another @virt_id will be also set via the uAPI providing "
"the iommufd core an index to store the vDEVICE object to a vDEVICE array per "
"vIOMMU. If necessary, the IOMMU driver may choose to implement a "
"vdevce_alloc op to init its HW for virtualization feature related to a "
"vDEVICE. Successful completion of this operation sets up the linkages "
"between vIOMMU and device."
msgstr ""

#: ../../../userspace-api/iommufd.rst:268
msgid ""
"A device can only bind to an iommufd due to DMA ownership claim and attach "
"to at most one IOAS object (no support of PASID yet)."
msgstr ""

#: ../../../userspace-api/iommufd.rst:272
msgid "Kernel Datastructure"
msgstr ""

#: ../../../userspace-api/iommufd.rst:274
msgid "User visible objects are backed by following datastructures:"
msgstr ""

#: ../../../userspace-api/iommufd.rst:276
msgid "iommufd_ioas for IOMMUFD_OBJ_IOAS."
msgstr ""

#: ../../../userspace-api/iommufd.rst:277
msgid "iommufd_device for IOMMUFD_OBJ_DEVICE."
msgstr ""

#: ../../../userspace-api/iommufd.rst:278
msgid "iommufd_hwpt_paging for IOMMUFD_OBJ_HWPT_PAGING."
msgstr ""

#: ../../../userspace-api/iommufd.rst:279
msgid "iommufd_hwpt_nested for IOMMUFD_OBJ_HWPT_NESTED."
msgstr ""

#: ../../../userspace-api/iommufd.rst:280
msgid "iommufd_fault for IOMMUFD_OBJ_FAULT."
msgstr ""

#: ../../../userspace-api/iommufd.rst:281
msgid "iommufd_viommu for IOMMUFD_OBJ_VIOMMU."
msgstr ""

#: ../../../userspace-api/iommufd.rst:282
msgid "iommufd_vdevice for IOMMUFD_OBJ_VDEVICE."
msgstr ""

#: ../../../userspace-api/iommufd.rst:283
msgid "iommufd_veventq for IOMMUFD_OBJ_VEVENTQ."
msgstr ""

#: ../../../userspace-api/iommufd.rst:284
msgid "iommufd_hw_queue for IOMMUFD_OBJ_HW_QUEUE."
msgstr ""

#: ../../../userspace-api/iommufd.rst:286
msgid "Several terminologies when looking at these datastructures:"
msgstr ""

#: ../../../userspace-api/iommufd.rst:288
msgid ""
"Automatic domain - refers to an iommu domain created automatically when "
"attaching a device to an IOAS object. This is compatible to the semantics of "
"VFIO type1."
msgstr ""

#: ../../../userspace-api/iommufd.rst:292
msgid ""
"Manual domain - refers to an iommu domain designated by the user as the "
"target pagetable to be attached to by a device. Though currently there are "
"no uAPIs to directly create such domain, the datastructure and algorithms "
"are ready for handling that use case."
msgstr ""

#: ../../../userspace-api/iommufd.rst:297
msgid ""
"In-kernel user - refers to something like a VFIO mdev that is using the "
"IOMMUFD access interface to access the IOAS. This starts by creating an "
"iommufd_access object that is similar to the domain binding a physical "
"device would do. The access object will then allow converting IOVA ranges "
"into struct page * lists, or doing direct read/write to an IOVA."
msgstr ""

#: ../../../userspace-api/iommufd.rst:303
msgid ""
"iommufd_ioas serves as the metadata datastructure to manage how IOVA ranges "
"are mapped to memory pages, composed of:"
msgstr ""

#: ../../../userspace-api/iommufd.rst:306
msgid "struct io_pagetable holding the IOVA map"
msgstr ""

#: ../../../userspace-api/iommufd.rst:307
msgid "struct iopt_area's representing populated portions of IOVA"
msgstr ""

#: ../../../userspace-api/iommufd.rst:308
msgid "struct iopt_pages representing the storage of PFNs"
msgstr ""

#: ../../../userspace-api/iommufd.rst:309
msgid "struct iommu_domain representing the IO page table in the IOMMU"
msgstr ""

#: ../../../userspace-api/iommufd.rst:310
msgid "struct iopt_pages_access representing in-kernel users of PFNs"
msgstr ""

#: ../../../userspace-api/iommufd.rst:311
msgid ""
"struct xarray pinned_pfns holding a list of pages pinned by in-kernel users"
msgstr ""

#: ../../../userspace-api/iommufd.rst:313
msgid ""
"Each iopt_pages represents a logical linear array of full PFNs. The PFNs are "
"ultimately derived from userspace VAs via an mm_struct. Once they have been "
"pinned the PFNs are stored in IOPTEs of an iommu_domain or inside the "
"pinned_pfns xarray if they have been pinned through an iommufd_access."
msgstr ""

#: ../../../userspace-api/iommufd.rst:318
msgid ""
"PFN have to be copied between all combinations of storage locations, "
"depending on what domains are present and what kinds of in-kernel \"software "
"access\" users exist. The mechanism ensures that a page is pinned only once."
msgstr ""

#: ../../../userspace-api/iommufd.rst:322
msgid ""
"An io_pagetable is composed of iopt_areas pointing at iopt_pages, along with "
"a list of iommu_domains that mirror the IOVA to PFN map."
msgstr ""

#: ../../../userspace-api/iommufd.rst:325
msgid ""
"Multiple io_pagetable-s, through their iopt_area-s, can share a single "
"iopt_pages which avoids multi-pinning and double accounting of page "
"consumption."
msgstr ""

#: ../../../userspace-api/iommufd.rst:329
msgid ""
"iommufd_ioas is shareable between subsystems, e.g. VFIO and VDPA, as long as "
"devices managed by different subsystems are bound to a same iommufd."
msgstr ""

#: ../../../userspace-api/iommufd.rst:333
msgid "IOMMUFD User API"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:3
msgid "**General ioctl format**"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:13
msgid ""
"The ioctl interface follows a general format to allow for extensibility. "
"Each ioctl is passed in a structure pointer as the argument providing the "
"size of the structure in the first u32. The kernel checks that any structure "
"space beyond what it understands is 0. This allows userspace to use the "
"backward compatible portion while consistently using the newer, larger, "
"structures."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:19
msgid "ioctls use a standard meaning for common errnos:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:21
msgid "ENOTTY: The IOCTL number itself is not supported at all"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:22
msgid ""
"E2BIG: The IOCTL number is supported, but the provided structure has non-"
"zero in a part the kernel does not understand."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:24
msgid ""
"EOPNOTSUPP: The IOCTL number is supported, and the structure is understood, "
"however a known field has a value the kernel does not understand or support."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:27
msgid ""
"EINVAL: Everything about the IOCTL was understood, but a field is not "
"correct."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:29
msgid "ENOENT: An ID or IOVA provided does not exist."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:30
msgid "ENOMEM: Out of memory."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:31
msgid "EOVERFLOW: Mathematics overflowed."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:33
msgid "As well as additional errnos, within specific ioctls."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:63
msgid "ioctl(IOMMU_DESTROY)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:67
#: include/uapi/linux/iommufd.h:80 include/uapi/linux/iommufd.h:96
#: include/uapi/linux/iommufd.h:108 include/uapi/linux/iommufd.h:152
#: include/uapi/linux/iommufd.h:197 include/uapi/linux/iommufd.h:227
#: include/uapi/linux/iommufd.h:251 include/uapi/linux/iommufd.h:282
#: include/uapi/linux/iommufd.h:331 include/uapi/linux/iommufd.h:366
#: include/uapi/linux/iommufd.h:428 include/uapi/linux/iommufd.h:443
#: include/uapi/linux/iommufd.h:475 include/uapi/linux/iommufd.h:536
#: include/uapi/linux/iommufd.h:557 include/uapi/linux/iommufd.h:599
#: include/uapi/linux/iommufd.h:670 include/uapi/linux/iommufd.h:733
#: include/uapi/linux/iommufd.h:764 include/uapi/linux/iommufd.h:819
#: include/uapi/linux/iommufd.h:844 include/uapi/linux/iommufd.h:866
#: include/uapi/linux/iommufd.h:931 include/uapi/linux/iommufd.h:974
#: include/uapi/linux/iommufd.h:984 include/uapi/linux/iommufd.h:1014
#: include/uapi/linux/iommufd.h:1030 include/uapi/linux/iommufd.h:1067
#: include/uapi/linux/iommufd.h:1093 include/uapi/linux/iommufd.h:1122
#: include/uapi/linux/iommufd.h:1167 include/uapi/linux/iommufd.h:1188
#: include/uapi/linux/iommufd.h:1201 include/uapi/linux/iommufd.h:1264
msgid "**Definition**::"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:74
#: include/uapi/linux/iommufd.h:88 include/uapi/linux/iommufd.h:103
#: include/uapi/linux/iommufd.h:119 include/uapi/linux/iommufd.h:162
#: include/uapi/linux/iommufd.h:209 include/uapi/linux/iommufd.h:239
#: include/uapi/linux/iommufd.h:263 include/uapi/linux/iommufd.h:291
#: include/uapi/linux/iommufd.h:342 include/uapi/linux/iommufd.h:375
#: include/uapi/linux/iommufd.h:437 include/uapi/linux/iommufd.h:449
#: include/uapi/linux/iommufd.h:491 include/uapi/linux/iommufd.h:545
#: include/uapi/linux/iommufd.h:567 include/uapi/linux/iommufd.h:609
#: include/uapi/linux/iommufd.h:687 include/uapi/linux/iommufd.h:742
#: include/uapi/linux/iommufd.h:777 include/uapi/linux/iommufd.h:828
#: include/uapi/linux/iommufd.h:850 include/uapi/linux/iommufd.h:878
#: include/uapi/linux/iommufd.h:945 include/uapi/linux/iommufd.h:981
#: include/uapi/linux/iommufd.h:993 include/uapi/linux/iommufd.h:1021
#: include/uapi/linux/iommufd.h:1044 include/uapi/linux/iommufd.h:1077
#: include/uapi/linux/iommufd.h:1100 include/uapi/linux/iommufd.h:1129
#: include/uapi/linux/iommufd.h:1173 include/uapi/linux/iommufd.h:1194
#: include/uapi/linux/iommufd.h:1214 include/uapi/linux/iommufd.h:1277
msgid "**Members**"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:64
#: include/uapi/linux/iommufd.h:77 include/uapi/linux/iommufd.h:105
#: include/uapi/linux/iommufd.h:149 include/uapi/linux/iommufd.h:194
#: include/uapi/linux/iommufd.h:224 include/uapi/linux/iommufd.h:248
#: include/uapi/linux/iommufd.h:279 include/uapi/linux/iommufd.h:328
#: include/uapi/linux/iommufd.h:363 include/uapi/linux/iommufd.h:472
#: include/uapi/linux/iommufd.h:667 include/uapi/linux/iommufd.h:730
#: include/uapi/linux/iommufd.h:761 include/uapi/linux/iommufd.h:863
#: include/uapi/linux/iommufd.h:981 include/uapi/linux/iommufd.h:1027
#: include/uapi/linux/iommufd.h:1064 include/uapi/linux/iommufd.h:1090
#: include/uapi/linux/iommufd.h:1198 include/uapi/linux/iommufd.h:1261
msgid "``size``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:65
msgid "sizeof(struct iommu_destroy)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:65
msgid "``id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:66
msgid "iommufd object ID to destroy. Can be any destroyable object type."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:69
#: include/uapi/linux/iommufd.h:83 include/uapi/linux/iommufd.h:98
#: include/uapi/linux/iommufd.h:114 include/uapi/linux/iommufd.h:157
#: include/uapi/linux/iommufd.h:205 include/uapi/linux/iommufd.h:234
#: include/uapi/linux/iommufd.h:259 include/uapi/linux/iommufd.h:286
#: include/uapi/linux/iommufd.h:337 include/uapi/linux/iommufd.h:371
#: include/uapi/linux/iommufd.h:450 include/uapi/linux/iommufd.h:487
#: include/uapi/linux/iommufd.h:544 include/uapi/linux/iommufd.h:565
#: include/uapi/linux/iommufd.h:606 include/uapi/linux/iommufd.h:656
#: include/uapi/linux/iommufd.h:687 include/uapi/linux/iommufd.h:737
#: include/uapi/linux/iommufd.h:773 include/uapi/linux/iommufd.h:825
#: include/uapi/linux/iommufd.h:847 include/uapi/linux/iommufd.h:877
#: include/uapi/linux/iommufd.h:988 include/uapi/linux/iommufd.h:1017
#: include/uapi/linux/iommufd.h:1039 include/uapi/linux/iommufd.h:1073
#: include/uapi/linux/iommufd.h:1095 include/uapi/linux/iommufd.h:1125
#: include/uapi/linux/iommufd.h:1178 include/uapi/linux/iommufd.h:1191
#: include/uapi/linux/iommufd.h:1210 include/uapi/linux/iommufd.h:1274
#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:208
#: drivers/iommu/iommufd/device.c:300 drivers/iommu/iommufd/device.c:329
#: drivers/iommu/iommufd/device.c:993 drivers/iommu/iommufd/device.c:1026
#: drivers/iommu/iommufd/device.c:1049 drivers/iommu/iommufd/device.c:1180
#: drivers/iommu/iommufd/device.c:1216 drivers/iommu/iommufd/device.c:1328
#: drivers/iommu/iommufd/device.c:1396 drivers/iommu/iommufd/device.c:1495
#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:592
#: drivers/iommu/iommufd/main.c:604 drivers/iommu/iommufd/main.c:624
msgid "**Description**"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:66
msgid "Destroy any object held within iommufd."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:76
msgid "ioctl(IOMMU_IOAS_ALLOC)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:78
msgid "sizeof(struct iommu_ioas_alloc)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:78
#: include/uapi/linux/iommufd.h:195 include/uapi/linux/iommufd.h:225
#: include/uapi/linux/iommufd.h:249 include/uapi/linux/iommufd.h:426
#: include/uapi/linux/iommufd.h:473 include/uapi/linux/iommufd.h:534
#: include/uapi/linux/iommufd.h:556 include/uapi/linux/iommufd.h:598
#: include/uapi/linux/iommufd.h:668 include/uapi/linux/iommufd.h:731
#: include/uapi/linux/iommufd.h:763 include/uapi/linux/iommufd.h:820
#: include/uapi/linux/iommufd.h:928 include/uapi/linux/iommufd.h:982
#: include/uapi/linux/iommufd.h:1028 include/uapi/linux/iommufd.h:1119
#: include/uapi/linux/iommufd.h:1199 include/uapi/linux/iommufd.h:1262
msgid "``flags``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:79
#: include/uapi/linux/iommufd.h:109 include/uapi/linux/iommufd.h:153
#: include/uapi/linux/iommufd.h:198 include/uapi/linux/iommufd.h:332
#: include/uapi/linux/iommufd.h:368 include/uapi/linux/iommufd.h:430
#: include/uapi/linux/iommufd.h:478 include/uapi/linux/iommufd.h:536
#: include/uapi/linux/iommufd.h:558 include/uapi/linux/iommufd.h:599
#: include/uapi/linux/iommufd.h:603 include/uapi/linux/iommufd.h:669
#: include/uapi/linux/iommufd.h:688 include/uapi/linux/iommufd.h:734
#: include/uapi/linux/iommufd.h:765 include/uapi/linux/iommufd.h:822
#: include/uapi/linux/iommufd.h:983 include/uapi/linux/iommufd.h:1029
#: include/uapi/linux/iommufd.h:1035 include/uapi/linux/iommufd.h:1092
#: include/uapi/linux/iommufd.h:1200 include/uapi/linux/iommufd.h:1207
#: include/uapi/linux/iommufd.h:1263
msgid "Must be 0"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:79
msgid "``out_ioas_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:80
msgid "Output IOAS ID for the allocated object"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:80
msgid ""
"Allocate an IO Address Space (IOAS) which holds an IO Virtual Address (IOVA) "
"to memory mapping."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:92
msgid "ioctl(IOMMU_IOVA_RANGE)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:93
#: include/uapi/linux/iommufd.h:228
msgid "``start``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:94
msgid "First IOVA"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:94
msgid "``last``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:95
msgid "Inclusive last IOVA"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:95
msgid "An interval in IOVA space."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:104
msgid "ioctl(IOMMU_IOAS_IOVA_RANGES)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:106
msgid "sizeof(struct iommu_ioas_iova_ranges)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:106
#: include/uapi/linux/iommufd.h:150 include/uapi/linux/iommufd.h:196
#: include/uapi/linux/iommufd.h:226 include/uapi/linux/iommufd.h:280
#: include/uapi/linux/iommufd.h:364
msgid "``ioas_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:107
msgid "IOAS ID to read ranges from"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:107
#: include/uapi/linux/iommufd.h:151
msgid "``num_iovas``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:108
#: include/uapi/linux/iommufd.h:152
msgid "Input/Output total number of ranges in the IOAS"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:108
#: include/uapi/linux/iommufd.h:152 include/uapi/linux/iommufd.h:197
#: include/uapi/linux/iommufd.h:331 include/uapi/linux/iommufd.h:367
#: include/uapi/linux/iommufd.h:429 include/uapi/linux/iommufd.h:477
#: include/uapi/linux/iommufd.h:535 include/uapi/linux/iommufd.h:557
#: include/uapi/linux/iommufd.h:602 include/uapi/linux/iommufd.h:687
#: include/uapi/linux/iommufd.h:733 include/uapi/linux/iommufd.h:764
#: include/uapi/linux/iommufd.h:821 include/uapi/linux/iommufd.h:873
#: include/uapi/linux/iommufd.h:933 include/uapi/linux/iommufd.h:1034
#: include/uapi/linux/iommufd.h:1091 include/uapi/linux/iommufd.h:1206
msgid "``__reserved``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:109
#: include/uapi/linux/iommufd.h:153
msgid "``allowed_iovas``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:110
msgid "Pointer to the output array of struct iommu_iova_range"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:110
msgid "``out_iova_alignment``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:111
msgid "Minimum alignment required for mapping IOVA"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:111
msgid ""
"Query an IOAS for ranges of allowed IOVAs. Mapping IOVA outside these ranges "
"is not allowed. num_iovas will be set to the total number of iovas and the "
"allowed_iovas[] will be filled in as space permits."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:115
msgid ""
"The allowed ranges are dependent on the HW path the DMA operation takes, and "
"can change during the lifetime of the IOAS. A fresh empty IOAS will have a "
"full range, and each attached device will narrow the ranges based on that "
"device's HW restrictions. Detaching a device can widen the ranges. Userspace "
"should query ranges after every attach/detach to know what IOVAs are valid "
"for mapping."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:122
msgid ""
"On input num_iovas is the length of the allowed_iovas array. On output it is "
"the total number of iovas filled in. The ioctl will return -EMSGSIZE and set "
"num_iovas to the required value if num_iovas is too small. In this case the "
"caller should allocate a larger output array and re-issue the ioctl."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:127
msgid ""
"out_iova_alignment returns the minimum IOVA alignment that can be given to "
"IOMMU_IOAS_MAP/COPY. IOVA's must satisfy::"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:133
msgid ""
"out_iova_alignment can be 1 indicating any IOVA is allowed. It cannot be "
"higher than the system PAGE_SIZE."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:148
msgid "ioctl(IOMMU_IOAS_ALLOW_IOVAS)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:150
msgid "sizeof(struct iommu_ioas_allow_iovas)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:151
msgid "IOAS ID to allow IOVAs from"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:154
msgid "Pointer to array of struct iommu_iova_range"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:154
msgid ""
"Ensure a range of IOVAs are always available for allocation. If this call "
"succeeds then IOMMU_IOAS_IOVA_RANGES will never return a list of IOVA ranges "
"that are narrower than the ranges provided here. This call will fail if "
"IOMMU_IOAS_IOVA_RANGES is currently narrower than the given ranges."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:159
msgid ""
"When an IOAS is first created the IOVA_RANGES will be maximally sized, and "
"as devices are attached the IOVA will narrow based on the device "
"restrictions. When an allowed range is specified any narrowing will be "
"refused, ie device attachment can fail if the device requires limiting "
"within the allowed range."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:164
msgid ""
"Automatic IOVA allocation is also impacted by this call. MAP will only "
"allocate within the allowed IOVAs if they are present."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:167
msgid "This call replaces the entire allowed list with the given list."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:180
msgid "Flags for map and copy"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:184
#: include/uapi/linux/iommufd.h:302 include/uapi/linux/iommufd.h:320
#: include/uapi/linux/iommufd.h:354 include/uapi/linux/iommufd.h:389
#: include/uapi/linux/iommufd.h:415 include/uapi/linux/iommufd.h:463
#: include/uapi/linux/iommufd.h:526 include/uapi/linux/iommufd.h:621
#: include/uapi/linux/iommufd.h:639 include/uapi/linux/iommufd.h:661
#: include/uapi/linux/iommufd.h:751 include/uapi/linux/iommufd.h:797
#: include/uapi/linux/iommufd.h:808 include/uapi/linux/iommufd.h:903
#: include/uapi/linux/iommufd.h:914 include/uapi/linux/iommufd.h:960
#: include/uapi/linux/iommufd.h:1001 include/uapi/linux/iommufd.h:1114
#: include/uapi/linux/iommufd.h:1155 include/uapi/linux/iommufd.h:1241
msgid "**Constants**"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:186
msgid "``IOMMU_IOAS_MAP_FIXED_IOVA``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:187
msgid ""
"If clear the kernel will compute an appropriate IOVA to place the mapping at"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:190
msgid "``IOMMU_IOAS_MAP_WRITEABLE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:191
msgid "DMA is allowed to write to this mapping"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:193
msgid "``IOMMU_IOAS_MAP_READABLE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:194
msgid "DMA is allowed to read from this mapping"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:193
msgid "ioctl(IOMMU_IOAS_MAP)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:195
msgid "sizeof(struct iommu_ioas_map)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:196
#: include/uapi/linux/iommufd.h:250
msgid "Combination of enum iommufd_ioas_map_flags"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:197
#: include/uapi/linux/iommufd.h:251 include/uapi/linux/iommufd.h:281
msgid "IOAS ID to change the mapping of"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:198
msgid "``user_va``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:199
msgid "Userspace pointer to start mapping from"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:199
#: include/uapi/linux/iommufd.h:229 include/uapi/linux/iommufd.h:252
#: include/uapi/linux/iommufd.h:282 include/uapi/linux/iommufd.h:766
#: include/uapi/linux/iommufd.h:935 include/uapi/linux/iommufd.h:1270
msgid "``length``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:200
msgid "Number of bytes to map"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:200
#: include/uapi/linux/iommufd.h:230 include/uapi/linux/iommufd.h:281
#: include/uapi/linux/iommufd.h:765
msgid "``iova``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:201
#: include/uapi/linux/iommufd.h:254
msgid ""
"IOVA the mapping was placed at. If IOMMU_IOAS_MAP_FIXED_IOVA is set then "
"this must be provided as input."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:202
msgid ""
"Set an IOVA mapping from a user pointer. If FIXED_IOVA is specified then the "
"mapping will be established at iova, otherwise a suitable location based on "
"the reserved and allowed lists will be automatically selected and returned "
"in iova."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:207
msgid ""
"If IOMMU_IOAS_MAP_FIXED_IOVA is specified then the iova range must currently "
"be unused, existing IOVA cannot be replaced."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:223
msgid "ioctl(IOMMU_IOAS_MAP_FILE)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:225
msgid "sizeof(struct iommu_ioas_map_file)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:226
#: include/uapi/linux/iommufd.h:227 include/uapi/linux/iommufd.h:230
#: include/uapi/linux/iommufd.h:231
msgid "same as for iommu_ioas_map"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:227
msgid "``fd``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:228
msgid "the memfd to map"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:229
msgid "byte offset from start of file to map from"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:231
msgid ""
"Set an IOVA mapping from a memfd file.  All other arguments and semantics "
"match those of IOMMU_IOAS_MAP."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:247
msgid "ioctl(IOMMU_IOAS_COPY)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:249
msgid "sizeof(struct iommu_ioas_copy)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:250
msgid "``dst_ioas_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:251
msgid "``src_ioas_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:252
msgid "IOAS ID to copy from"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:253
msgid "Number of bytes to copy and map"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:253
msgid "``dst_iova``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:255
msgid "``src_iova``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:256
msgid "IOVA to start the copy"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:256
msgid ""
"Copy an already existing mapping from src_ioas_id and establish it in "
"dst_ioas_id. The src iova/length must exactly match a range used with "
"IOMMU_IOAS_MAP."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:260
msgid ""
"This may be used to efficiently clone a subset of an IOAS to another, or as "
"a kind of 'cache' to speed up mapping. Copy has an efficiency advantage over "
"establishing equivalent new mappings, as internal resources are shared, and "
"the kernel will pin the user memory only once."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:278
msgid "ioctl(IOMMU_IOAS_UNMAP)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:280
msgid "sizeof(struct iommu_ioas_unmap)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:282
msgid "IOVA to start the unmapping at"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:283
msgid "Number of bytes to unmap, and return back the bytes unmapped"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:283
msgid ""
"Unmap an IOVA range. The iova/length must be a superset of a previously "
"mapped range used with IOMMU_IOAS_MAP or IOMMU_IOAS_COPY. Splitting or "
"truncating ranges is not allowed. The values 0 to U64_MAX will unmap "
"everything."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:298
msgid "ioctl(IOMMU_OPTION_RLIMIT_MODE) and ioctl(IOMMU_OPTION_HUGE_PAGES)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:304
msgid "``IOMMU_OPTION_RLIMIT_MODE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:305
msgid ""
"Change how RLIMIT_MEMLOCK accounting works. The caller must have privilege "
"to invoke this. Value 0 (default) is user based accounting, 1 uses process "
"based accounting. Global option, object_id must be 0"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:309
msgid "``IOMMU_OPTION_HUGE_PAGES``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:310
msgid ""
"Value 1 (default) allows contiguous pages to be combined when generating "
"iommu mappings. Value 0 disables combining, everything is mapped to "
"PAGE_SIZE. This can be useful for benchmarking.  This is a per-IOAS option, "
"the object_id must be the IOAS ID."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:316
msgid "ioctl(IOMMU_OPTION_OP_SET) and ioctl(IOMMU_OPTION_OP_GET)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:322
msgid "``IOMMU_OPTION_OP_SET``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:323
msgid "Set the option's value"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:325
msgid "``IOMMU_OPTION_OP_GET``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:326
msgid "Get the option's value"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:327
msgid "iommu option multiplexer"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:329
msgid "sizeof(struct iommu_option)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:329
msgid "``option_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:330
msgid "One of enum iommufd_option"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:330
#: include/uapi/linux/iommufd.h:366
msgid "``op``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:331
msgid "One of enum iommufd_option_ops"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:332
msgid "``object_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:333
msgid "ID of the object if required"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:333
msgid "``val64``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:334
msgid "Option value to set or value returned on get"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:334
msgid ""
"Change a simple option value. This multiplexor allows controlling options on "
"objects. IOMMU_OPTION_OP_SET will load an option and IOMMU_OPTION_OP_GET "
"will return the current value."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:350
msgid "IOMMU_VFIO_IOAS_* ioctls"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:356
msgid "``IOMMU_VFIO_IOAS_GET``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:357
msgid "Get the current compatibility IOAS"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:359
msgid "``IOMMU_VFIO_IOAS_SET``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:360
msgid "Change the current compatibility IOAS"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:362
msgid "``IOMMU_VFIO_IOAS_CLEAR``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:363
msgid "Disable VFIO compatibility"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:362
msgid "ioctl(IOMMU_VFIO_IOAS)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:364
msgid "sizeof(struct iommu_vfio_ioas)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:365
msgid ""
"For IOMMU_VFIO_IOAS_SET the input IOAS ID to set For IOMMU_VFIO_IOAS_GET "
"will output the IOAS ID"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:367
msgid "One of enum iommufd_vfio_ioas_op"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:368
msgid ""
"The VFIO compatibility support uses a single ioas because VFIO APIs do not "
"support the ID field. Set or Get the IOAS that VFIO compatibility will use. "
"When VFIO_GROUP_SET_CONTAINER is used on an iommufd it will get the "
"compatibility ioas, either by taking what is already set, or auto creating "
"one. From then on VFIO will continue to use that ioas and is not effected by "
"this ioctl. SET or CLEAR does not destroy any auto-created IOAS."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:385
msgid "Flags for HWPT allocation"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:391
msgid "``IOMMU_HWPT_ALLOC_NEST_PARENT``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:392
msgid ""
"If set, allocate a HWPT that can serve as the parent HWPT in a nesting "
"configuration."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:395
msgid "``IOMMU_HWPT_ALLOC_DIRTY_TRACKING``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:396
msgid ""
"Dirty tracking support for device IOMMU is enforced on device attachment"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:399
msgid "``IOMMU_HWPT_FAULT_ID_VALID``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:400
msgid "The fault_id field of hwpt allocation data is valid."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:403
msgid "``IOMMU_HWPT_ALLOC_PASID``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:404
msgid ""
"Requests a domain that can be used with PASID. The domain can be attached to "
"any PASID on the device. Any domain attached to the non-PASID part of the "
"device must also be flagged, otherwise attaching a PASID will blocked. For "
"the user that wants to attach PASID, ioas is not recommended for both the "
"non-PASID part and PASID part of the device. If IOMMU does not support PASID "
"it will return error (-EOPNOTSUPP)."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:411
msgid "Intel VT-d stage-1 page table entry attributes"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:417
msgid "``IOMMU_VTD_S1_SRE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:418
msgid "Supervisor request"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:420
msgid "``IOMMU_VTD_S1_EAFE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:421
msgid "Extended access enable"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:423
msgid "``IOMMU_VTD_S1_WPE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:424
msgid "Write protect enable"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:424
msgid "Intel VT-d stage-1 page table info (IOMMU_HWPT_DATA_VTD_S1)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:427
msgid "Combination of enum iommu_hwpt_vtd_s1_flags"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:427
msgid "``pgtbl_addr``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:428
msgid "The base address of the stage-1 page table."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:428
msgid "``addr_width``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:429
msgid "The address width of the stage-1 page table"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:439
msgid "ARM SMMUv3 nested STE (IOMMU_HWPT_DATA_ARM_SMMUV3)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:442
msgid "``ste``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:443
msgid ""
"The first two double words of the user space Stream Table Entry for the "
"translation. Must be little-endian. Allowed fields: (Refer to \"5.2 Stream "
"Table Entry\" in SMMUv3 HW Spec) - word-0: V, Cfg, S1Fmt, S1ContextPtr, "
"S1CDMax - word-1: EATS, S1DSS, S1CIR, S1COR, S1CSH, S1STALLD"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:447
msgid ""
"-EIO will be returned if **ste** is not legal or contains any non-allowed "
"field. Cfg can be used to select a S1, Bypass or Abort configuration. A "
"Bypass nested domain will translate the same as the nesting parent. The S1 "
"will install a Context Descriptor Table pointing at userspace memory "
"translated by the nesting parent."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:459
msgid "IOMMU HWPT Data Type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:465
msgid "``IOMMU_HWPT_DATA_NONE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:466
msgid "no data"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:468
msgid "``IOMMU_HWPT_DATA_VTD_S1``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:469
msgid "Intel VT-d stage-1 page table"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:471
msgid "``IOMMU_HWPT_DATA_ARM_SMMUV3``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:472
msgid "ARM SMMUv3 Context Descriptor Table"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:471
msgid "ioctl(IOMMU_HWPT_ALLOC)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:473
msgid "sizeof(struct iommu_hwpt_alloc)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:474
msgid "Combination of enum iommufd_hwpt_alloc_flags"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:474
#: include/uapi/linux/iommufd.h:669 include/uapi/linux/iommufd.h:929
#: include/uapi/linux/iommufd.h:1030 include/uapi/linux/iommufd.h:1066
msgid "``dev_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:475
msgid "The device to allocate this HWPT for"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:475
msgid "``pt_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:476
msgid "The IOAS or HWPT or vIOMMU to connect this HWPT to"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:476
msgid "``out_hwpt_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:477
msgid "The ID of the new HWPT"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:478
#: include/uapi/linux/iommufd.h:867
msgid "``data_type``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:479
msgid "One of enum iommu_hwpt_data_type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:479
#: include/uapi/linux/iommufd.h:670 include/uapi/linux/iommufd.h:1033
msgid "``data_len``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:480
#: include/uapi/linux/iommufd.h:1034
msgid "Length of the type specific data"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:480
#: include/uapi/linux/iommufd.h:672 include/uapi/linux/iommufd.h:865
#: include/uapi/linux/iommufd.h:1035
msgid "``data_uptr``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:481
msgid "User pointer to the type specific data"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:481
msgid "``fault_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:482
msgid ""
"The ID of IOMMUFD_FAULT object. Valid only if flags field of "
"IOMMU_HWPT_FAULT_ID_VALID is set."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:483
msgid "``__reserved2``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:484
msgid "Padding to 64-bit alignment. Must be 0."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:484
msgid ""
"Explicitly allocate a hardware page table object. This is the same object "
"type that is returned by iommufd_device_attach() and represents the "
"underlying iommu driver's iommu_domain kernel object."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:488
msgid ""
"A kernel-managed HWPT will be created with the mappings from the given IOAS "
"via the **pt_id**. The **data_type** for this allocation must be set to "
"IOMMU_HWPT_DATA_NONE. The HWPT can be allocated as a parent HWPT for a "
"nesting configuration by passing IOMMU_HWPT_ALLOC_NEST_PARENT via **flags**."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:493
msgid ""
"A user-managed nested HWPT will be created from a given vIOMMU (wrapping a "
"parent HWPT) or a parent HWPT via **pt_id**, in which the parent HWPT must "
"be allocated previously via the same ioctl from a given IOAS (**pt_id**). In "
"this case, the **data_type** must be set to a pre-defined type corresponding "
"to an I/O page table type supported by the underlying IOMMU hardware. The "
"device via **dev_id** and the vIOMMU via **pt_id** must be associated to the "
"same IOMMU instance."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:501
msgid ""
"If the **data_type** is set to IOMMU_HWPT_DATA_NONE, **data_len** and "
"**data_uptr** should be zero. Otherwise, both **data_len** and **data_uptr** "
"must be given."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:522
msgid "Flags for VT-d hw_info"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:528
msgid "``IOMMU_HW_INFO_VTD_ERRATA_772415_SPR17``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:529
msgid ""
"If set, disallow read-only mappings on a nested_parent domain. https://www."
"intel.com/content/www/us/en/content-details/772415/content-details.html"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:532
msgid "Intel VT-d hardware information"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:535
msgid "Combination of enum iommu_hw_info_vtd_flags"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:537
msgid "``cap_reg``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:538
msgid ""
"Value of Intel VT-d capability register defined in VT-d spec section 11.4.2 "
"Capability Register."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:539
msgid "``ecap_reg``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:540
msgid ""
"Value of Intel VT-d capability register defined in VT-d spec section 11.4.3 "
"Extended Capability Register."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:541
msgid ""
"User needs to understand the Intel VT-d specification to decode the register "
"value."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:553
msgid "ARM SMMUv3 hardware information (IOMMU_HW_INFO_TYPE_ARM_SMMUV3)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:557
msgid "Must be set to 0"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:558
msgid "``idr``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:559
msgid "Implemented features for ARM SMMU Non-secure programming interface"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:559
msgid "``iidr``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:560
msgid ""
"Information about the implementation and implementer of ARM SMMU, and "
"architecture version supported"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:561
msgid "``aidr``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:562
msgid "ARM SMMU architecture version"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:562
msgid ""
"For the details of **idr**, **iidr** and **aidr**, please refer to the "
"chapters from 6.3.1 to 6.3.6 in the SMMUv3 Spec."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:565
msgid ""
"This reports the raw HW capability, and not all bits are meaningful to be "
"read by userspace. Only the following fields should be used:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:568
msgid ""
"idr[0]: ST_LEVEL, TERM_MODEL, STALL_MODEL, TTENDIAN , CD2L, ASID16, TTF "
"idr[1]: SIDSIZE, SSIDSIZE idr[3]: BBML, RIL idr[5]: VAX, GRAN64K, GRAN16K, "
"GRAN4K"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:573
msgid "S1P should be assumed to be true if a NESTED HWPT can be created"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:574
msgid ""
"VFIO/iommufd only support platforms with COHACC, it should be assumed to be "
"true."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:576
msgid ""
"ATS is a per-device property. If the VMM describes any devices as ATS "
"capable in ACPI/DT it should set the corresponding idr."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:579
msgid ""
"This list may expand in future (eg E0PD, AIE, PBHA, D128, DS etc). It is "
"important that VMMs do not read bits outside the list to allow for "
"compatibility with future kernels. Several features in the SMMUv3 "
"architecture are not currently supported by the kernel for nesting: HTTU, "
"BTM, MPAM and others."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:595
msgid ""
"NVIDIA Tegra241 CMDQV Hardware Information "
"(IOMMU_HW_INFO_TYPE_TEGRA241_CMDQV)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:599
msgid "``version``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:600
msgid "Version number for the CMDQ-V HW for PARAM bits[03:00]"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:600
msgid "``log2vcmdqs``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:601
msgid "Log2 of the total number of VCMDQs for PARAM bits[07:04]"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:601
msgid "``log2vsids``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:602
msgid "Log2 of the total number of SID replacements for PARAM bits[15:12]"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:603
msgid ""
"VMM can use these fields directly in its emulated global PARAM register. "
"Note that only one Virtual Interface (VINTF) should be exposed to a VM, i.e. "
"PARAM bits[11:08] should be set to 0 for log2 of the total number of VINTFs."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:617
msgid "IOMMU Hardware Info Types"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:623
msgid "``IOMMU_HW_INFO_TYPE_NONE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:624
msgid "Output by the drivers that do not report hardware info"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:627
msgid "``IOMMU_HW_INFO_TYPE_DEFAULT``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:628
msgid "Input to request for a default type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:630
msgid "``IOMMU_HW_INFO_TYPE_INTEL_VTD``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:631
msgid "Intel VT-d iommu info type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:633
msgid "``IOMMU_HW_INFO_TYPE_ARM_SMMUV3``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:634
msgid "ARM SMMUv3 iommu info type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:636
msgid "``IOMMU_HW_INFO_TYPE_TEGRA241_CMDQV``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:637
msgid "NVIDIA Tegra241 CMDQV (extension for ARM SMMUv3) info type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:641
msgid "``IOMMU_HW_CAP_DIRTY_TRACKING``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:642
msgid ""
"IOMMU hardware support for dirty tracking If available, it means the "
"following APIs are supported:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:646
msgid "``IOMMU_HW_CAP_PCI_PASID_EXEC``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:647
msgid ""
"Execute Permission Supported, user ignores it when the struct iommu_hw_info::"
"out_max_pasid_log2 is zero."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:651
msgid "``IOMMU_HW_CAP_PCI_PASID_PRIV``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:652
msgid ""
"Privileged Mode Supported, user ignores it when the struct iommu_hw_info::"
"out_max_pasid_log2 is zero."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:639
msgid "IOMMU_HWPT_GET_DIRTY_BITMAP IOMMU_HWPT_SET_DIRTY_TRACKING"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:657
msgid "Flags for iommu_hw_info"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:663
msgid "``IOMMU_HW_INFO_FLAG_INPUT_TYPE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:664
msgid ""
"If set, **in_data_type** carries an input type for user space to request for "
"a specific info"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:666
msgid "ioctl(IOMMU_GET_HW_INFO)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:668
msgid "sizeof(struct iommu_hw_info)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:670
msgid "The device bound to the iommufd"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:671
msgid ""
"Input the length of a user buffer in bytes. Output the length of data that "
"kernel supports"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:673
msgid ""
"User pointer to a user-space buffer used by the kernel to fill the iommu "
"type specific hardware information data"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:2
msgid "anonymous"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:674
msgid "``in_data_type``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:675
msgid ""
"This shares the same field with **out_data_type**, making it be a "
"bidirectional field. When IOMMU_HW_INFO_FLAG_INPUT_TYPE is set, an input "
"type carried via this **in_data_type** field will be valid, requesting for "
"the info data to the given type. If IOMMU_HW_INFO_FLAG_INPUT_TYPE is unset, "
"any input value will be seen as IOMMU_HW_INFO_TYPE_DEFAULT"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:680
msgid "``out_data_type``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:681
msgid ""
"Output the iommu hardware info type as defined in the enum "
"iommu_hw_info_type."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:684
msgid "``out_max_pasid_log2``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:685
msgid ""
"Output the width of PASIDs. 0 means no PASID support. PCI devices turn to "
"out_capabilities to check if the specific capabilities is supported or not."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:682
msgid "``out_capabilities``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:683
msgid ""
"Output the generic iommu capability info type as defined in the enum "
"iommu_hw_capabilities."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:688
msgid ""
"Query an iommu type specific hardware information data from an iommu behind "
"a given device that has been bound to iommufd. This hardware info data will "
"be used to sync capabilities between the virtual iommu and the physical "
"iommu, e.g. a nested translation setup needs to check the hardware info, so "
"a guest stage-1 page table can be compatible with the physical iommu."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:694
msgid ""
"To capture an iommu type specific hardware information data, **data_uptr** "
"and its length **data_len** must be provided. Trailing bytes will be zeroed "
"if the user buffer is larger than the data that kernel has. Otherwise, "
"kernel only fills the buffer using the given length in **data_len**. If the "
"ioctl succeeds, **data_len** will be updated to the length that kernel "
"actually supports, **out_data_type** will be filled to decode the data "
"filled in the buffer pointed by **data_uptr**. Input **data_len** == zero is "
"allowed."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:729
msgid "ioctl(IOMMU_HWPT_SET_DIRTY_TRACKING)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:731
msgid "sizeof(struct iommu_hwpt_set_dirty_tracking)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:732
msgid "Combination of enum iommufd_hwpt_set_dirty_tracking_flags"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:732
#: include/uapi/linux/iommufd.h:762 include/uapi/linux/iommufd.h:864
#: include/uapi/linux/iommufd.h:1031
msgid "``hwpt_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:733
#: include/uapi/linux/iommufd.h:763
msgid "HW pagetable ID that represents the IOMMU domain"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:734
msgid "Toggle dirty tracking on an HW pagetable."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:747
msgid "Flags for getting dirty bits"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:753
msgid "``IOMMU_HWPT_GET_DIRTY_BITMAP_NO_CLEAR``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:754
msgid ""
"Just read the PTEs without clearing any dirty bits metadata. This flag can "
"be passed in the expectation where the next operation is an unmap of the "
"same IOVA range."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:760
msgid "ioctl(IOMMU_HWPT_GET_DIRTY_BITMAP)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:762
msgid "sizeof(struct iommu_hwpt_get_dirty_bitmap)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:764
msgid "Combination of enum iommufd_hwpt_get_dirty_bitmap_flags"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:766
msgid "base IOVA of the bitmap first bit"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:767
msgid "IOVA range size"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:767
msgid "``page_size``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:768
msgid "page size granularity of each bit in the bitmap"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:768
msgid "``data``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:769
msgid ""
"bitmap where to set the dirty bits. The bitmap bits each represent a "
"page_size which you deviate from an arbitrary iova."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:770
msgid "Checking a given IOVA is dirty:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:772
msgid "data[(iova / page_size) / 64] & (1ULL << ((iova / page_size) % 64))"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:774
msgid ""
"Walk the IOMMU pagetables for a given IOVA range to return a bitmap with the "
"dirty IOVAs. In doing so it will also by default clear any dirty bit "
"metadata set in the IOPTE."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:793
msgid "IOMMU HWPT Cache Invalidation Data Type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:799
msgid "``IOMMU_HWPT_INVALIDATE_DATA_VTD_S1``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:800
msgid "Invalidation data for VTD_S1"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:802
msgid "``IOMMU_VIOMMU_INVALIDATE_DATA_ARM_SMMUV3``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:803
msgid "Invalidation data for ARM SMMUv3"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:804
msgid "Flags for Intel VT-d stage-1 cache invalidation"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:810
msgid "``IOMMU_VTD_INV_FLAGS_LEAF``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:811
msgid ""
"Indicates whether the invalidation applies to all-levels page structure "
"cache or just the leaf PTE cache."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:815
msgid "Intel VT-d cache invalidation (IOMMU_HWPT_INVALIDATE_DATA_VTD_S1)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:817
#: include/uapi/linux/iommufd.h:934
msgid "``addr``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:818
msgid ""
"The start address of the range to be invalidated. It needs to be 4KB aligned."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:819
msgid "``npages``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:820
msgid "Number of contiguous 4K pages to be invalidated."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:821
msgid "Combination of enum iommu_hwpt_vtd_s1_invalidate_flags"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:822
msgid ""
"The Intel VT-d specific invalidation data for user-managed stage-1 cache "
"invalidation in nested translation. Userspace uses this structure to tell "
"the impacted cache scope after modifying the stage-1 page table."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:826
msgid ""
"Invalidating all the caches related to the page table by setting **addr** to "
"be 0 and **npages** to be U64_MAX."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:829
msgid "The device TLB will be invalidated automatically if ATS is enabled."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:840
msgid "ARM SMMUv3 cache invalidation (IOMMU_VIOMMU_INVALIDATE_DATA_ARM_SMMUV3)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:842
msgid "``cmd``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:843
msgid ""
"128-bit cache invalidation command that runs in SMMU CMDQ. Must be little-"
"endian."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:844
msgid "Supported command list only when passing in a vIOMMU via **hwpt_id**:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:845
msgid ""
"CMDQ_OP_TLBI_NSNH_ALL CMDQ_OP_TLBI_NH_VA CMDQ_OP_TLBI_NH_VAA "
"CMDQ_OP_TLBI_NH_ALL CMDQ_OP_TLBI_NH_ASID CMDQ_OP_ATC_INV CMDQ_OP_CFGI_CD "
"CMDQ_OP_CFGI_CD_ALL"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:854
msgid "-EIO will be returned if the command is not supported."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:862
msgid "ioctl(IOMMU_HWPT_INVALIDATE)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:864
msgid "sizeof(struct iommu_hwpt_invalidate)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:865
msgid "ID of a nested HWPT or a vIOMMU, for cache invalidation"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:866
msgid "User pointer to an array of driver-specific cache invalidation data."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:868
msgid ""
"One of enum iommu_hwpt_invalidate_data_type, defining the data type of all "
"the entries in the invalidation request array. It should be a type supported "
"by the hwpt pointed by **hwpt_id**."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:870
msgid "``entry_len``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:871
msgid "Length (in bytes) of a request entry in the request array"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:871
msgid "``entry_num``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:872
msgid ""
"Input the number of cache invalidation requests in the array. Output the "
"number of requests successfully handled by kernel."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:874
#: include/uapi/linux/iommufd.h:934
msgid "Must be 0."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:874
msgid ""
"Invalidate iommu cache for user-managed page table or vIOMMU. Modifications "
"on a user-managed page table should be followed by this operation, if a HWPT "
"is passed in via **hwpt_id**. Other caches, such as device cache or "
"descriptor cache can be flushed if a vIOMMU is passed in via the **hwpt_id** "
"field."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:879
msgid ""
"Each ioctl can support one or more cache invalidation requests in the array "
"that has a total size of **entry_len** * **entry_num**."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:882
msgid ""
"An empty invalidation request array by setting **entry_num**==0 is allowed, "
"and **entry_len** and **data_uptr** would be ignored in this case. This can "
"be used to check if the given **data_type** is supported or not by kernel."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:899
msgid "flags for struct iommu_hwpt_pgfault"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:905
msgid "``IOMMU_PGFAULT_FLAGS_PASID_VALID``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:906
msgid "The pasid field of the fault data is valid."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:909
msgid "``IOMMU_PGFAULT_FLAGS_LAST_PAGE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:910
msgid "It's the last fault of a fault group."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:910
msgid "perm bits for struct iommu_hwpt_pgfault"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:916
msgid "``IOMMU_PGFAULT_PERM_READ``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:917
msgid "request for read permission"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:919
msgid "``IOMMU_PGFAULT_PERM_WRITE``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:920
msgid "request for write permission"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:922
msgid "``IOMMU_PGFAULT_PERM_EXEC``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:923
msgid ""
"(PCIE 10.4.1) request with a PASID that has the Execute Requested bit set in "
"PASID TLP Prefix."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:926
msgid "``IOMMU_PGFAULT_PERM_PRIV``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:927
msgid ""
"(PCIE 10.4.1) request with a PASID that has the Privileged Mode Requested "
"bit set in PASID TLP Prefix."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:927
msgid "iommu page fault data"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:929
msgid "Combination of enum iommu_hwpt_pgfault_flags"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:930
msgid "id of the originated device"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:930
msgid "``pasid``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:931
msgid "Process Address Space ID"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:931
msgid "``grpid``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:932
msgid "Page Request Group Index"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:932
msgid "``perm``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:933
msgid "Combination of enum iommu_hwpt_pgfault_perm"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:935
msgid "Fault address"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:936
msgid ""
"a hint of how much data the requestor is expecting to fetch. For example, if "
"the PRI initiator knows it is going to do a 10MB transfer, it could fill in "
"10MB and the OS could pre-fault in 10MB of IOVA. It's default to 0 if "
"there's no such hint."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:939
#: include/uapi/linux/iommufd.h:971
msgid "``cookie``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:940
msgid ""
"kernel-managed cookie identifying a group of fault messages. The cookie "
"number encoded in the last page fault of the group should be echoed back in "
"the response message."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:956
msgid "Return status of fault handlers"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:962
msgid "``IOMMUFD_PAGE_RESP_SUCCESS``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:963
msgid ""
"Fault has been handled and the page tables populated, retry the access. This "
"is the \"Success\" defined in PCI 10.4.2.1."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:967
msgid "``IOMMUFD_PAGE_RESP_INVALID``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:968
msgid ""
"Could not handle this fault, don't retry the access. This is the \"Invalid "
"Request\" in PCI 10.4.2.1."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:970
msgid "IOMMU page fault response"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:972
msgid "The kernel-managed cookie reported in the fault message."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:972
msgid "``code``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:973
msgid "One of response code in enum iommufd_page_response_code."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:980
msgid "ioctl(IOMMU_FAULT_QUEUE_ALLOC)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:982
msgid "sizeof(struct iommu_fault_alloc)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:983
msgid "``out_fault_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:984
msgid "The ID of the new FAULT"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:984
msgid "``out_fault_fd``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:985
msgid "The fd of the new FAULT"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:985
msgid "Explicitly allocate a fault handling object."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:997
msgid "Virtual IOMMU Type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1003
msgid "``IOMMU_VIOMMU_TYPE_DEFAULT``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1004
#: include/uapi/linux/iommufd.h:1158 include/uapi/linux/iommufd.h:1244
msgid "Reserved for future use"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1006
msgid "``IOMMU_VIOMMU_TYPE_ARM_SMMUV3``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1007
msgid "ARM SMMUv3 driver specific type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1009
msgid "``IOMMU_VIOMMU_TYPE_TEGRA241_CMDQV``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1010
msgid ""
"NVIDIA Tegra241 CMDQV (extension for ARM SMMUv3) enabled ARM SMMUv3 type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1010
msgid ""
"NVIDIA Tegra241 CMDQV Virtual Interface (IOMMU_VIOMMU_TYPE_TEGRA241_CMDQV)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1012
msgid "``out_vintf_mmap_offset``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1013
msgid "mmap offset argument for VINTF's page0"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1013
msgid "``out_vintf_mmap_length``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1014
msgid "mmap length argument for VINTF's page0"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1014
msgid ""
"Both **out_vintf_mmap_offset** and **out_vintf_mmap_length** are reported by "
"kernel for user space to mmap the VINTF page0 from the host physical address "
"space to the guest physical address space so that a guest kernel can "
"directly R/W access to the VINTF page0 in order to control its virtual "
"command queues."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1026
msgid "ioctl(IOMMU_VIOMMU_ALLOC)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1028
msgid "sizeof(struct iommu_viommu_alloc)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1029
#: include/uapi/linux/iommufd.h:1201 include/uapi/linux/iommufd.h:1264
msgid "``type``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1030
msgid "Type of the virtual IOMMU. Must be defined in enum iommu_viommu_type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1031
msgid "The device's physical IOMMU will be used to back the virtual IOMMU"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1032
msgid "ID of a nesting parent HWPT to associate to"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1032
msgid "``out_viommu_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1033
msgid "Output virtual IOMMU ID for the allocated object"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1036
msgid "User pointer to a driver-specific virtual IOMMU data"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1036
msgid ""
"Allocate a virtual IOMMU object, representing the underlying physical "
"IOMMU's virtualization support that is a security-isolated slice of the real "
"IOMMU HW that is unique to a specific VM. Operations global to the IOMMU are "
"connected to the vIOMMU, such as: - Security namespace for guest owned ID, e."
"g. guest-controlled cache tags - Non-device-affiliated event reporting, e.g. "
"invalidation queue errors - Access to a sharable nesting parent pagetable "
"across physical IOMMUs - Virtualization of various platforms IDs, e.g. RIDs "
"and others - Delivery of paravirtualized invalidation - Direct assigned "
"invalidation queues - Direct assigned interrupts"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1063
msgid "ioctl(IOMMU_VDEVICE_ALLOC)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1065
msgid "sizeof(struct iommu_vdevice_alloc)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1065
#: include/uapi/linux/iommufd.h:1200 include/uapi/linux/iommufd.h:1263
msgid "``viommu_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1066
msgid "vIOMMU ID to associate with the virtual device"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1067
msgid "The physical device to allocate a virtual instance on the vIOMMU"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1067
msgid "``out_vdevice_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1068
msgid "Object handle for the vDevice. Pass to IOMMU_DESTORY"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1068
msgid "``virt_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1069
msgid ""
"Virtual device ID per vIOMMU, e.g. vSID of ARM SMMUv3, vDeviceID of AMD "
"IOMMU, and vRID of Intel VT-d"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1070
msgid ""
"Allocate a virtual device instance (for a physical device) against a vIOMMU. "
"This instance holds the device's information (related to its vIOMMU) in a "
"VM. User should use IOMMU_DESTROY to destroy the virtual device before "
"destroying the physical device (by closing vfio_cdev fd). Otherwise the "
"virtual device would be forcibly destroyed on physical device destruction, "
"its vdevice_id would be permanently leaked (unremovable & unreusable) until "
"iommu fd closed."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1089
msgid "ioctl(VFIO_IOAS_CHANGE_PROCESS)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1091
msgid "sizeof(struct iommu_ioas_change_process)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1092
msgid ""
"This transfers pinned memory counts for every memory map in every IOAS in "
"the context to the current process.  This only supports maps created with "
"IOMMU_IOAS_MAP_FILE, and returns EINVAL if other maps are present. If the "
"ioctl returns a failure status, then nothing is changed."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1097
msgid ""
"This API is useful for transferring operation of a device from one process "
"to another, such as during userland live update."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1110
msgid "flag for struct iommufd_vevent_header"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1116
msgid "``IOMMU_VEVENTQ_FLAG_LOST_EVENTS``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1117
msgid "vEVENTQ has lost vEVENTs"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1118
msgid "Virtual Event Header for a vEVENTQ Status"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1120
msgid "Combination of enum iommu_veventq_flag"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1120
msgid "``sequence``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1121
msgid ""
"The sequence index of a vEVENT in the vEVENTQ, with a range of [0, INT_MAX] "
"where the following index of INT_MAX is 0"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1122
msgid ""
"Each iommufd_vevent_header reports a sequence index of the following vEVENT:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1125
msgid "header0 {sequence=0}"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1125
#: include/uapi/linux/iommufd.h:1217
msgid "data0"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1125
msgid "header1 {sequence=1}"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1125
#: include/uapi/linux/iommufd.h:1217
msgid "data1"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1125
#: include/uapi/linux/iommufd.h:1133 include/uapi/linux/iommufd.h:1217
msgid "..."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1125
#: include/uapi/linux/iommufd.h:1217
msgid "dataN"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1128
msgid ""
"And this sequence index is expected to be monotonic to the sequence index of "
"the previous vEVENT. If two adjacent sequence indexes has a delta larger "
"than 1, it means that delta - 1 number of vEVENTs has lost, e.g. two lost "
"vEVENTs:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1133
#: include/uapi/linux/iommufd.h:1141
msgid "header3 {sequence=3}"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1133
#: include/uapi/linux/iommufd.h:1141
msgid "data3"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1133
msgid "header6 {sequence=6}"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1133
msgid "data6"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1136
msgid ""
"If a vEVENT lost at the tail of the vEVENTQ and there is no following vEVENT "
"providing the next sequence index, an IOMMU_VEVENTQ_FLAG_LOST_EVENTS header "
"would be added to the tail, and no data would follow this header:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1141
msgid "header4 {flags=LOST_EVENTS, sequence=4}"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1151
msgid "Virtual Event Queue Type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1157
msgid "``IOMMU_VEVENTQ_TYPE_DEFAULT``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1160
msgid "``IOMMU_VEVENTQ_TYPE_ARM_SMMUV3``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1161
msgid "ARM SMMUv3 Virtual Event Queue"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1163
msgid "``IOMMU_VEVENTQ_TYPE_TEGRA241_CMDQV``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1164
msgid "NVIDIA Tegra241 CMDQV Extension IRQ"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1163
msgid "ARM SMMUv3 Virtual Event (IOMMU_VEVENTQ_TYPE_ARM_SMMUV3)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1165
msgid "``evt``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1166
msgid ""
"256-bit ARM SMMUv3 Event record, little-endian. Reported event records: "
"(Refer to \"7.3 Event records\" in SMMUv3 HW Spec) - 0x04 C_BAD_STE - 0x06 "
"F_STREAM_DISABLED - 0x08 C_BAD_SUBSTREAMID - 0x0a C_BAD_CD - 0x10 "
"F_TRANSLATION - 0x11 F_ADDR_SIZE - 0x12 F_ACCESS - 0x13 F_PERMISSION"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1175
msgid ""
"StreamID field reports a virtual device ID. To receive a virtual event for a "
"device, a vDEVICE must be allocated via IOMMU_VDEVICE_ALLOC."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1184
msgid "Tegra241 CMDQV IRQ (IOMMU_VEVENTQ_TYPE_TEGRA241_CMDQV)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1186
msgid "``lvcmdq_err_map``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1187
msgid ""
"128-bit logical vcmdq error map, little-endian. (Refer to register "
"LVCMDQ_ERR_MAPs per VINTF )"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1188
msgid ""
"The 128-bit register value from HW exclusively reflect the error bits for a "
"Virtual Interface represented by a vIOMMU object. Read and report directly."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1197
msgid "ioctl(IOMMU_VEVENTQ_ALLOC)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1199
msgid "sizeof(struct iommu_veventq_alloc)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1201
msgid "virtual IOMMU ID to associate the vEVENTQ with"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1202
msgid "Type of the vEVENTQ. Must be defined in enum iommu_veventq_type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1202
msgid "``veventq_depth``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1203
msgid "Maximum number of events in the vEVENTQ"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1203
msgid "``out_veventq_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1204
msgid "The ID of the new vEVENTQ"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1204
msgid "``out_veventq_fd``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1205
msgid ""
"The fd of the new vEVENTQ. User space must close the successfully returned "
"fd after using it"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1207
msgid ""
"Explicitly allocate a virtual event queue interface for a vIOMMU. A vIOMMU "
"can have multiple FDs for different types, but is confined to one per "
"**type**. User space should open the **out_veventq_fd** to read vEVENTs out "
"of a vEVENTQ, if there are vEVENTs available. A vEVENTQ will lose events due "
"to overflow, if the number of the vEVENTs hits **veventq_depth**."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1213
msgid ""
"Each vEVENT in a vEVENTQ encloses a struct iommufd_vevent_header followed by "
"a type-specific data structure, in a normal case:"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1217
msgid "header0"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1217
msgid "header1"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1217
msgid "headerN"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1220
msgid ""
"unless a tailing IOMMU_VEVENTQ_FLAG_LOST_EVENTS header is logged (refer to "
"struct iommufd_vevent_header)."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1237
msgid "HW Queue Type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1243
msgid "``IOMMU_HW_QUEUE_TYPE_DEFAULT``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1246
msgid "``IOMMU_HW_QUEUE_TYPE_TEGRA241_CMDQV``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1247
msgid ""
"NVIDIA Tegra241 CMDQV (extension for ARM SMMUv3) Virtual Command Queue "
"(VCMDQ)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1260
msgid "ioctl(IOMMU_HW_QUEUE_ALLOC)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1262
msgid "sizeof(struct iommu_hw_queue_alloc)"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1264
msgid "Virtual IOMMU ID to associate the HW queue with"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1265
msgid "One of enum iommu_hw_queue_type"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1265
msgid "``index``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1266
msgid ""
"The logical index to the HW queue per virtual IOMMU for a multi-queue model"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1267
msgid "``out_hw_queue_id``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1268
msgid "The ID of the new HW queue"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1268
msgid "``nesting_parent_iova``"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1269
msgid "Base address of the queue memory in the guest physical address space"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1271
msgid "Length of the queue memory"
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1271
msgid ""
"Allocate a HW queue object for a vIOMMU-specific HW-accelerated queue, which "
"allows HW to access a guest queue memory described using "
"**nesting_parent_iova** and **length**."
msgstr ""

#: ../../../userspace-api/iommufd:335: include/uapi/linux/iommufd.h:1275
msgid ""
"A vIOMMU can allocate multiple queues, but it must use a different **index** "
"per type to separate each allocation, e.g::"
msgstr ""

#: ../../../userspace-api/iommufd.rst:338
msgid "IOMMUFD Kernel API"
msgstr ""

#: ../../../userspace-api/iommufd.rst:340
msgid ""
"The IOMMUFD kAPI is device-centric with group-related tricks managed behind "
"the scene. This allows the external drivers calling such kAPI to implement a "
"simple device-centric uAPI for connecting its device to an iommufd, instead "
"of explicitly imposing the group semantics in its uAPI as VFIO does."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:203
msgid "Bind a physical device to an iommu fd"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:207
#: drivers/iommu/iommufd/device.c:299 drivers/iommu/iommufd/device.c:330
#: drivers/iommu/iommufd/device.c:991 drivers/iommu/iommufd/device.c:1024
#: drivers/iommu/iommufd/device.c:1049 drivers/iommu/iommufd/device.c:1178
#: drivers/iommu/iommufd/device.c:1217 drivers/iommu/iommufd/device.c:1327
#: drivers/iommu/iommufd/device.c:1393 drivers/iommu/iommufd/device.c:1492
#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:593
#: drivers/iommu/iommufd/main.c:605 drivers/iommu/iommufd/main.c:625
#: drivers/iommu/iommufd/main.c:649
msgid "**Parameters**"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:209
#: drivers/iommu/iommufd/device.c:301 drivers/iommu/iommufd/device.c:1180
#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:595
#: drivers/iommu/iommufd/main.c:651
msgid "``struct iommufd_ctx *ictx``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:204
#: drivers/iommu/iommufd/device.c:297 drivers/iommu/iommufd/device.c:1175
msgid "iommufd file descriptor"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:206
msgid "``struct device *dev``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:205
msgid "Pointer to a physical device struct"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:207
#: drivers/iommu/iommufd/device.c:1179
msgid "``u32 *id``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:206
msgid "Output ID number to return to userspace for this device"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:207
msgid ""
"A successful bind establishes an ownership over the device and returns "
"struct iommufd_device pointer, otherwise returns error pointer."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:210
msgid ""
"A driver using this API must set driver_managed_dma and must not touch the "
"device until this routine succeeds and establishes ownership."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:213
msgid "Binding a PCI device places the entire RID under iommufd control."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:215
msgid "The caller must undo this with iommufd_device_unbind()"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:295
msgid "True if any device within the group is bound to the ictx"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:299
msgid "``struct iommu_group *group``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:298
msgid "Pointer to a physical iommu_group struct"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:299
msgid ""
"True if any device within the group has been bound to this ictx, ex. via "
"iommufd_device_bind(), therefore implying ictx ownership of the group."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:326
msgid "Undo iommufd_device_bind()"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:332
#: drivers/iommu/iommufd/device.c:993 drivers/iommu/iommufd/device.c:1026
#: drivers/iommu/iommufd/device.c:1051
msgid "``struct iommufd_device *idev``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:327
msgid "Device returned by iommufd_device_bind()"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:328
msgid ""
"Release the device from iommufd control. The DMA ownership will return back "
"to unowned with DMA controlled by the DMA API. This invalidates the "
"iommufd_device pointer, other APIs that consume it must not be called "
"concurrently."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:987
msgid "Connect a device/pasid to an iommu_domain"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:988
msgid "device to attach"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:990
#: drivers/iommu/iommufd/device.c:1023 drivers/iommu/iommufd/device.c:1048
msgid "``ioasid_t pasid``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:989
msgid "pasid to attach"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:991
#: drivers/iommu/iommufd/device.c:1024
msgid "``u32 *pt_id``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:990
#: drivers/iommu/iommufd/device.c:1023
msgid ""
"Input a IOMMUFD_OBJ_IOAS, or IOMMUFD_OBJ_HWPT_PAGING Output the "
"IOMMUFD_OBJ_HWPT_PAGING ID"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:992
msgid ""
"This connects the device/pasid to an iommu_domain, either automatically or "
"manually selected. Once this completes the device could do DMA with "
"**pasid**. **pasid** is IOMMU_NO_PASID if this attach is for no pasid usage."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:996
msgid ""
"The caller should return the resulting pt_id back to userspace. This "
"function is undone by calling iommufd_device_detach()."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1020
msgid "Change the device/pasid's iommu_domain"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1021
msgid "device to change"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1022
msgid "pasid to change"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1025
msgid "This is the same as::"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1030
msgid ""
"If it fails then no change is made to the attachment. The iommu driver may "
"implement this so there is no disruption in translation. This can only be "
"called if iommufd_device_attach() has already succeeded. **pasid** is "
"IOMMU_NO_PASID for no pasid usage."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1045
msgid "Disconnect a device/device to an iommu_domain"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1046
msgid "device to detach"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1047
msgid "pasid to detach"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1048
msgid ""
"Undo iommufd_device_attach(). This disconnects the idev from the previously "
"attached pt_id. The device returns back to a blocked DMA translation. "
"**pasid** is IOMMU_NO_PASID for no pasid usage."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1174
msgid "Create an iommufd_access"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1177
msgid "``const struct iommufd_access_ops *ops``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1176
msgid "Driver's ops to associate with the access"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1178
#: drivers/iommu/iommufd/device.c:1492
msgid "``void *data``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1177
msgid "Opaque data to pass into ops functions"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1178
msgid "Output ID number to return to userspace for this access"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1179
msgid ""
"An iommufd_access allows a driver to read/write to the IOAS without using "
"DMA. The underlying CPU memory can be accessed using the "
"iommufd_access_pin_pages() or iommufd_access_rw() functions."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1183
msgid "The provided ops are required to use iommufd_access_pin_pages()."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1213
msgid "Destroy an iommufd_access"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1219
#: drivers/iommu/iommufd/device.c:1329 drivers/iommu/iommufd/device.c:1395
#: drivers/iommu/iommufd/device.c:1494
msgid "``struct iommufd_access *access``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1214
msgid "The access to destroy"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1215
msgid "The caller must stop using the access before destroying it."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1323
msgid "Undo iommufd_access_pin_pages"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1324
#: drivers/iommu/iommufd/device.c:1390 drivers/iommu/iommufd/device.c:1489
msgid "IOAS access to act on"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1326
#: drivers/iommu/iommufd/device.c:1392 drivers/iommu/iommufd/device.c:1491
msgid "``unsigned long iova``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1325
#: drivers/iommu/iommufd/device.c:1391 drivers/iommu/iommufd/device.c:1490
msgid "Starting IOVA"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1327
#: drivers/iommu/iommufd/device.c:1393
msgid "``unsigned long length``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1326
#: drivers/iommu/iommufd/device.c:1392 drivers/iommu/iommufd/device.c:1492
msgid "Number of bytes to access"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1327
msgid ""
"Return the struct page's. The caller must stop accessing them before calling "
"this. The iova/length must exactly match the one provided to access_pages."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1389
msgid "Return a list of pages under the iova"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1394
msgid "``struct page **out_pages``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1393
msgid "Output page list"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1395
#: drivers/iommu/iommufd/device.c:1494
msgid "``unsigned int flags``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1394
msgid "IOPMMUFD_ACCESS_RW_* flags"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1395
msgid ""
"Reads **length** bytes starting at iova and returns the struct page * "
"pointers. These can be kmap'd by the caller for CPU access."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1398
msgid ""
"The caller must perform iommufd_access_unpin_pages() when done to balance "
"this."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1401
msgid ""
"This API always requires a page aligned iova. This happens naturally if the "
"ioas alignment is >= PAGE_SIZE and the iova is PAGE_SIZE aligned. However "
"smaller alignments have corner cases where this API can fail on otherwise "
"aligned iova."
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1488
msgid "Read or write data under the iova"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1491
msgid "Kernel buffer to copy to/from"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1493
msgid "``size_t length``"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1493
msgid "IOMMUFD_ACCESS_RW_* flags"
msgstr ""

#: ../../../userspace-api/iommufd:345: drivers/iommu/iommufd/device.c:1494
msgid ""
"Copy kernel to/from data into the range given by IOVA/length. If flags "
"indicates IOMMUFD_ACCESS_RW_KTHREAD then a large copy can be optimized by "
"changing it into copy_to/from_user()."
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:589
msgid "Get a context reference"
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:590
msgid "Context to get"
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:591
msgid "The caller must already hold a valid reference to ictx."
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:601
#: drivers/iommu/iommufd/main.c:621
msgid "Acquires a reference to the iommufd context"
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:607
msgid "``struct file *file``"
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:602
msgid "File to obtain the reference from"
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:603
msgid ""
"Returns a pointer to the iommufd_ctx, otherwise ERR_PTR. The struct file "
"remains owned by the caller and the caller must still do fput. On success "
"the caller is responsible to call iommufd_ctx_put()."
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:627
msgid "``int fd``"
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:622
msgid "File descriptor to obtain the reference from"
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:623
msgid ""
"Returns a pointer to the iommufd_ctx, otherwise ERR_PTR. On success the "
"caller is responsible to call iommufd_ctx_put()."
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:645
msgid "Put back a reference"
msgstr ""

#: ../../../userspace-api/iommufd:348: drivers/iommu/iommufd/main.c:646
msgid "Context to put back"
msgstr ""

#: ../../../userspace-api/iommufd.rst:352
msgid "VFIO and IOMMUFD"
msgstr ""

#: ../../../userspace-api/iommufd.rst:354
msgid "Connecting a VFIO device to iommufd can be done in two ways."
msgstr ""

#: ../../../userspace-api/iommufd.rst:356
msgid ""
"First is a VFIO compatible way by directly implementing the /dev/vfio/vfio "
"container IOCTLs by mapping them into io_pagetable operations. Doing so "
"allows the use of iommufd in legacy VFIO applications by symlinking /dev/"
"vfio/vfio to /dev/iommufd or extending VFIO to SET_CONTAINER using an "
"iommufd instead of a container fd."
msgstr ""

#: ../../../userspace-api/iommufd.rst:362
msgid ""
"The second approach directly extends VFIO to support a new set of device-"
"centric user API based on aforementioned IOMMUFD kernel API. It requires "
"userspace change but better matches the IOMMUFD API semantics and easier to "
"support new iommufd features when comparing it to the first approach."
msgstr ""

#: ../../../userspace-api/iommufd.rst:367
msgid "Currently both approaches are still work-in-progress."
msgstr ""

#: ../../../userspace-api/iommufd.rst:369
msgid ""
"There are still a few gaps to be resolved to catch up with VFIO type1, as "
"documented in iommufd_vfio_check_extension()."
msgstr ""

#: ../../../userspace-api/iommufd.rst:373
msgid "Future TODOs"
msgstr ""

#: ../../../userspace-api/iommufd.rst:375
msgid ""
"Currently IOMMUFD supports only kernel-managed I/O page table, similar to "
"VFIO type1. New features on the radar include:"
msgstr ""

#: ../../../userspace-api/iommufd.rst:378
msgid "Binding iommu_domain's to PASID/SSID"
msgstr ""

#: ../../../userspace-api/iommufd.rst:379
msgid "Userspace page tables, for ARM, x86 and S390"
msgstr ""

#: ../../../userspace-api/iommufd.rst:380
msgid "Kernel bypass'd invalidation of user page tables"
msgstr ""

#: ../../../userspace-api/iommufd.rst:381
msgid "Re-use of the KVM page table in the IOMMU"
msgstr ""

#: ../../../userspace-api/iommufd.rst:382
msgid "Dirty page tracking in the IOMMU"
msgstr ""

#: ../../../userspace-api/iommufd.rst:383
msgid "Runtime Increase/Decrease of IOPTE size"
msgstr ""

#: ../../../userspace-api/iommufd.rst:384
msgid "PRI support with faults resolved in userspace"
msgstr ""
