# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../power/regulator/consumer.rst:3
msgid "Regulator Consumer Driver Interface"
msgstr ""

#: ../../../power/regulator/consumer.rst:5
msgid ""
"This text describes the regulator interface for consumer device drivers. "
"Please see overview.txt for a description of the terms used in this text."
msgstr ""

#: ../../../power/regulator/consumer.rst:10
msgid "1. Consumer Regulator Access (static & dynamic drivers)"
msgstr ""

#: ../../../power/regulator/consumer.rst:12
msgid "A consumer driver can get access to its supply regulator by calling ::"
msgstr ""

#: ../../../power/regulator/consumer.rst:16
msgid ""
"The consumer passes in its struct device pointer and power supply ID. The "
"core then finds the correct regulator by consulting a machine specific "
"lookup table. If the lookup is successful then this call will return a "
"pointer to the struct regulator that supplies this consumer."
msgstr ""

#: ../../../power/regulator/consumer.rst:21
msgid "To release the regulator the consumer driver should call ::"
msgstr ""

#: ../../../power/regulator/consumer.rst:25
msgid ""
"Consumers can be supplied by more than one regulator e.g. codec consumer "
"with analog and digital supplies ::"
msgstr ""

#: ../../../power/regulator/consumer.rst:31
msgid ""
"The regulator access functions regulator_get() and regulator_put() will "
"usually be called in your device drivers probe() and remove() respectively."
msgstr ""

#: ../../../power/regulator/consumer.rst:36
msgid "2. Regulator Output Enable & Disable (static & dynamic drivers)"
msgstr ""

#: ../../../power/regulator/consumer.rst:39
msgid "A consumer can enable its power supply by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:43
#: ../../../power/regulator/consumer.rst:59
#: ../../../power/regulator/consumer.rst:67
#: ../../../power/regulator/consumer.rst:96
#: ../../../power/regulator/consumer.rst:118
#: ../../../power/regulator/consumer.rst:128
msgid "NOTE:"
msgstr ""

#: ../../../power/regulator/consumer.rst:44
msgid ""
"The supply may already be enabled before regulator_enable() is called. This "
"may happen if the consumer shares the regulator or the regulator has been "
"previously enabled by bootloader or kernel board initialization code."
msgstr ""

#: ../../../power/regulator/consumer.rst:48
msgid "A consumer can determine if a regulator is enabled by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:52
msgid "This will return > zero when the regulator is enabled."
msgstr ""

#: ../../../power/regulator/consumer.rst:55
msgid "A consumer can disable its supply when no longer needed by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:60
msgid ""
"This may not disable the supply if it's shared with other consumers. The "
"regulator will only be disabled when the enabled reference count is zero."
msgstr ""

#: ../../../power/regulator/consumer.rst:63
msgid ""
"Finally, a regulator can be forcefully disabled in the case of an emergency::"
msgstr ""

#: ../../../power/regulator/consumer.rst:68
msgid ""
"this will immediately and forcefully shutdown the regulator output. All "
"consumers will be powered off."
msgstr ""

#: ../../../power/regulator/consumer.rst:73
msgid "3. Regulator Voltage Control & Status (dynamic drivers)"
msgstr ""

#: ../../../power/regulator/consumer.rst:75
msgid ""
"Some consumer drivers need to be able to dynamically change their supply "
"voltage to match system operating points. e.g. CPUfreq drivers can scale "
"voltage along with frequency to save power, SD drivers may need to select "
"the correct card voltage, etc."
msgstr ""

#: ../../../power/regulator/consumer.rst:80
msgid "Consumers can control their supply voltage by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:84
msgid ""
"Where min_uV and max_uV are the minimum and maximum acceptable voltages in "
"microvolts."
msgstr ""

#: ../../../power/regulator/consumer.rst:87
msgid ""
"NOTE: this can be called when the regulator is enabled or disabled. If "
"called when enabled, then the voltage changes instantly, otherwise the "
"voltage configuration changes and the voltage is physically set when the "
"regulator is next enabled."
msgstr ""

#: ../../../power/regulator/consumer.rst:92
msgid "The regulators configured voltage output can be found by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:97
msgid ""
"get_voltage() will return the configured output voltage whether the "
"regulator is enabled or disabled and should NOT be used to determine "
"regulator output state. However this can be used in conjunction with "
"is_enabled() to determine the regulator physical output voltage."
msgstr ""

#: ../../../power/regulator/consumer.rst:104
msgid "4. Regulator Current Limit Control & Status (dynamic drivers)"
msgstr ""

#: ../../../power/regulator/consumer.rst:106
msgid ""
"Some consumer drivers need to be able to dynamically change their supply "
"current limit to match system operating points. e.g. LCD backlight driver "
"can change the current limit to vary the backlight brightness, USB drivers "
"may want to set the limit to 500mA when supplying power."
msgstr ""

#: ../../../power/regulator/consumer.rst:111
msgid "Consumers can control their supply current limit by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:115
msgid ""
"Where min_uA and max_uA are the minimum and maximum acceptable current limit "
"in microamps."
msgstr ""

#: ../../../power/regulator/consumer.rst:119
msgid ""
"this can be called when the regulator is enabled or disabled. If called when "
"enabled, then the current limit changes instantly, otherwise the current "
"limit configuration changes and the current limit is physically set when the "
"regulator is next enabled."
msgstr ""

#: ../../../power/regulator/consumer.rst:124
msgid "A regulators current limit can be found by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:129
msgid ""
"get_current_limit() will return the current limit whether the regulator is "
"enabled or disabled and should not be used to determine regulator current "
"load."
msgstr ""

#: ../../../power/regulator/consumer.rst:135
msgid "5. Regulator Operating Mode Control & Status (dynamic drivers)"
msgstr ""

#: ../../../power/regulator/consumer.rst:137
msgid ""
"Some consumers can further save system power by changing the operating mode "
"of their supply regulator to be more efficient when the consumers operating "
"state changes. e.g. consumer driver is idle and subsequently draws less "
"current"
msgstr ""

#: ../../../power/regulator/consumer.rst:141
msgid "Regulator operating mode can be changed indirectly or directly."
msgstr ""

#: ../../../power/regulator/consumer.rst:144
msgid "Indirect operating mode control."
msgstr ""

#: ../../../power/regulator/consumer.rst:145
msgid ""
"Consumer drivers can request a change in their supply regulator operating "
"mode by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:150
msgid ""
"This will cause the core to recalculate the total load on the regulator "
"(based on all its consumers) and change operating mode (if necessary and "
"permitted) to best match the current operating load."
msgstr ""

#: ../../../power/regulator/consumer.rst:154
msgid ""
"The load_uA value can be determined from the consumer's datasheet. e.g. most "
"datasheets have tables showing the maximum current consumed in certain "
"situations."
msgstr ""

#: ../../../power/regulator/consumer.rst:158
msgid ""
"Most consumers will use indirect operating mode control since they have no "
"knowledge of the regulator or whether the regulator is shared with other "
"consumers."
msgstr ""

#: ../../../power/regulator/consumer.rst:163
msgid "Direct operating mode control."
msgstr ""

#: ../../../power/regulator/consumer.rst:165
msgid ""
"Bespoke or tightly coupled drivers may want to directly control regulator "
"operating mode depending on their operating point. This can be achieved by "
"calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:172
msgid ""
"Direct mode will only be used by consumers that *know* about the regulator "
"and are not sharing the regulator with other consumers."
msgstr ""

#: ../../../power/regulator/consumer.rst:177
msgid "6. Regulator Events"
msgstr ""

#: ../../../power/regulator/consumer.rst:179
msgid ""
"Regulators can notify consumers of external events. Events could be received "
"by consumers under regulator stress or failure conditions."
msgstr ""

#: ../../../power/regulator/consumer.rst:182
msgid "Consumers can register interest in regulator events by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:187
msgid "Consumers can unregister interest by calling::"
msgstr ""

#: ../../../power/regulator/consumer.rst:192
msgid ""
"Regulators use the kernel notifier framework to send event to their "
"interested consumers."
msgstr ""

#: ../../../power/regulator/consumer.rst:196
msgid "7. Regulator Direct Register Access"
msgstr ""

#: ../../../power/regulator/consumer.rst:198
msgid ""
"Some kinds of power management hardware or firmware are designed such that "
"they need to do low-level hardware access to regulators, with no involvement "
"from the kernel. Examples of such devices are:"
msgstr ""

#: ../../../power/regulator/consumer.rst:202
msgid ""
"clocksource with a voltage-controlled oscillator and control logic to change "
"the supply voltage over I2C to achieve a desired output clock rate"
msgstr ""

#: ../../../power/regulator/consumer.rst:204
msgid ""
"thermal management firmware that can issue an arbitrary I2C transaction to "
"perform system poweroff during overtemperature conditions"
msgstr ""

#: ../../../power/regulator/consumer.rst:207
msgid ""
"To set up such a device/firmware, various parameters like I2C address of the "
"regulator, addresses of various regulator registers etc. need to be "
"configured to it. The regulator framework provides the following helpers for "
"querying these details."
msgstr ""

#: ../../../power/regulator/consumer.rst:212
msgid ""
"Bus-specific details, like I2C addresses or transfer rates are handled by "
"the regmap framework. To get the regulator's regmap (if supported), use::"
msgstr ""

#: ../../../power/regulator/consumer.rst:217
msgid ""
"To obtain the hardware register offset and bitmask for the regulator's "
"voltage selector register, use::"
msgstr ""

#: ../../../power/regulator/consumer.rst:224
msgid ""
"To convert a regulator framework voltage selector code (used by "
"regulator_list_voltage) to a hardware-specific voltage selector that can be "
"directly written to the voltage selector register, use::"
msgstr ""

#: ../../../power/regulator/consumer.rst:231
msgid ""
"To access the hardware for enabling/disabling the regulator, consumers must "
"use regulator_get_exclusive(), as it can't work if there's more than one "
"consumer. To enable/disable regulator use::"
msgstr ""
