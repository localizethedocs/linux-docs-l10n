# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/prog_flow_dissector.rst:5
msgid "BPF_PROG_TYPE_FLOW_DISSECTOR"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:8
msgid "Overview"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:10
msgid ""
"Flow dissector is a routine that parses metadata out of the packets. It's "
"used in the various places in the networking subsystem (RFS, flow hash, etc)."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:13
msgid ""
"BPF flow dissector is an attempt to reimplement C-based flow dissector logic "
"in BPF to gain all the benefits of BPF verifier (namely, limits on the "
"number of instructions and tail calls)."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:18
msgid "API"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:20
msgid ""
"BPF flow dissector programs operate on an ``__sk_buff``. However, only the "
"limited set of fields is allowed: ``data``, ``data_end`` and ``flow_keys``. "
"``flow_keys`` is ``struct bpf_flow_keys`` and contains flow dissector input "
"and output arguments."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:25
msgid "The inputs are:"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:26
msgid "``nhoff`` - initial offset of the networking header"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:27
msgid ""
"``thoff`` - initial offset of the transport header, initialized to nhoff"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:28
msgid "``n_proto`` - L3 protocol type, parsed out of L2 header"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:29
msgid "``flags`` - optional flags"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:31
msgid ""
"Flow dissector BPF program should fill out the rest of the ``struct "
"bpf_flow_keys`` fields. Input arguments ``nhoff/thoff/n_proto`` should be "
"also adjusted accordingly."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:35
msgid ""
"The return code of the BPF program is either BPF_OK to indicate successful "
"dissection, or BPF_DROP to indicate parsing error."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:39
msgid "__sk_buff->data"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:41
msgid ""
"In the VLAN-less case, this is what the initial state of the BPF flow "
"dissector looks like::"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:58
msgid ""
"In case of VLAN, flow dissector can be called with the two different states."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:60
msgid "Pre-VLAN parsing::"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:75
msgid ""
"Please note that TPID can be 802.1AD and, hence, BPF program would have to "
"parse VLAN information twice for double tagged packets."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:79
msgid "Post-VLAN parsing::"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:94
msgid ""
"In this case VLAN information has been processed before the flow dissector "
"and BPF flow dissector is not required to handle it."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:98
msgid ""
"The takeaway here is as follows: BPF flow dissector program can be called "
"with the optional VLAN header and should gracefully handle both cases: when "
"single or double VLAN is present and when it is not present. The same "
"program can be called for both cases and would have to be written carefully "
"to handle both cases."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:106
msgid "Flags"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:108
msgid ""
"``flow_keys->flags`` might contain optional input flags that work as follows:"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:110
msgid ""
"``BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG`` - tells BPF flow dissector to "
"continue parsing first fragment; the default expected behavior is that flow "
"dissector returns as soon as it finds out that the packet is fragmented; "
"used by ``eth_get_headlen`` to estimate length of all headers for GRO."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:114
msgid ""
"``BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL`` - tells BPF flow dissector to "
"stop parsing as soon as it reaches IPv6 flow label; used by "
"``___skb_get_hash`` to get flow hash."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:117
msgid ""
"``BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP`` - tells BPF flow dissector to stop "
"parsing as soon as it reaches encapsulated headers; used by routing "
"infrastructure."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:123
msgid "Reference Implementation"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:125
msgid ""
"See ``tools/testing/selftests/bpf/progs/bpf_flow.c`` for the reference "
"implementation and ``tools/testing/selftests/bpf/flow_dissector_load.[hc]`` "
"for the loader. bpftool can be used to load BPF flow dissector program as "
"well."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:129
msgid "The reference implementation is organized as follows:"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:130
msgid ""
"``jmp_table`` map that contains sub-programs for each supported L3 protocol"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:131
msgid ""
"``_dissect`` routine - entry point; it does input ``n_proto`` parsing and "
"does ``bpf_tail_call`` to the appropriate L3 handler"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:134
msgid ""
"Since BPF at this point doesn't support looping (or any jumping back), "
"jmp_table is used instead to handle multiple levels of encapsulation (and "
"IPv6 options)."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:140
msgid "Current Limitations"
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:141
msgid ""
"BPF flow dissector doesn't support exporting all the metadata that in-kernel "
"C-based implementation can export. Notable example is single VLAN (802.1Q) "
"and double VLAN (802.1AD) tags. Please refer to the ``struct bpf_flow_keys`` "
"for a set of information that's currently can be exported from the BPF "
"context."
msgstr ""

#: ../../../bpf/prog_flow_dissector.rst:146
msgid ""
"When BPF flow dissector is attached to the root network namespace (machine-"
"wide policy), users can't override it in their child network namespaces."
msgstr ""
