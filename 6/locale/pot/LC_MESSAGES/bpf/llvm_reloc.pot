# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/llvm_reloc.rst:5
msgid "BPF LLVM Relocations"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:7
msgid "This document describes LLVM BPF backend relocation types."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:10
msgid "Relocation Record"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:12
msgid ""
"LLVM BPF backend records each relocation with the following 16-byte ELF "
"structure::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:21
msgid "For example, for the following code::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:31
msgid ""
"Compiled with ``clang --target=bpf -O2 -c test.c``, the following is the "
"code with ``llvm-objdump -dr test.o``::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:51
msgid ""
"There are four relocations in the above for four ``LD_imm64`` instructions. "
"The following ``llvm-readelf -r test.o`` shows the binary values of the four "
"relocations::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:62
msgid ""
"Each relocation is represented by ``Offset`` (8 bytes) and ``Info`` (8 "
"bytes). For example, the first relocation corresponds to the first "
"instruction (Offset 0x0) and the corresponding ``Info`` indicates the "
"relocation type of ``R_BPF_64_64`` (type 1) and the entry in the symbol "
"table (entry 6). The following is the symbol table with ``llvm-readelf -s "
"test.o``::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:79
msgid "The 6th entry is global variable ``g1`` with value 0."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:81
msgid ""
"Similarly, the second relocation is at ``.text`` offset ``0x18``, "
"instruction 3, has a type of ``R_BPF_64_64`` and refers to entry 7 in the "
"symbol table. The second relocation resolves to global variable ``g2`` which "
"has a symbol value 4. The symbol value represents the offset from the start "
"of ``.data`` section where the initial value of the global variable ``g2`` "
"is stored."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:87
msgid ""
"The third and fourth relocations refer to static variables ``l1`` and "
"``l2``. From the ``.rel.text`` section above, it is not clear to which "
"symbols they really refer as they both refer to symbol table entry 4, symbol "
"``sec``, which has ``STT_SECTION`` type and represents a section. So for a "
"static variable or function, the section offset is written to the original "
"insn buffer, which is called ``A`` (addend). Looking at above insn ``7`` and "
"``11``, they have section offset ``8`` and ``12``. From symbol table, we can "
"find that they correspond to entries ``2`` and ``3`` for ``l1`` and ``l2``."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:98
msgid ""
"In general, the ``A`` is 0 for global variables and functions, and is the "
"section offset or some computation result based on section offset for static "
"variables/functions. The non-section-offset case refers to function calls. "
"See below for more details."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:104
msgid "Different Relocation Types"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:106
msgid ""
"Six relocation types are supported. The following is an overview and ``S`` "
"represents the value of the symbol in the symbol table::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:117
msgid ""
"For example, ``R_BPF_64_64`` relocation type is used for ``ld_imm64`` "
"instruction. The actual to-be-relocated data (0 or section offset) is stored "
"at ``r_offset + 4`` and the read/write data bitsize is 32 (4 bytes). The "
"relocation can be resolved with the symbol value plus implicit addend. Note "
"that the ``BitSize`` is 32 which means the section offset must be less than "
"or equal to ``UINT32_MAX`` and this is enforced by LLVM BPF backend."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:125
msgid ""
"In another case, ``R_BPF_64_ABS64`` relocation type is used for normal 64-"
"bit data. The actual to-be-relocated data is stored at ``r_offset`` and the "
"read/write data bitsize is 64 (8 bytes). The relocation can be resolved with "
"the symbol value plus implicit addend."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:130
msgid ""
"Both ``R_BPF_64_ABS32`` and ``R_BPF_64_NODYLD32`` types are for 32-bit data. "
"But ``R_BPF_64_NODYLD32`` specifically refers to relocations in ``.BTF`` and "
"``.BTF.ext`` sections. For cases like bcc where llvm ``ExecutionEngine "
"RuntimeDyld`` is involved, ``R_BPF_64_NODYLD32`` types of relocations should "
"not be resolved to actual function/variable address. Otherwise, ``.BTF`` and "
"``.BTF.ext`` become unusable by bcc and kernel."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:137
msgid ""
"Type ``R_BPF_64_32`` is used for call instruction. The call target section "
"offset is stored at ``r_offset + 4`` (32bit) and calculated as ``(S + A) / 8 "
"- 1``."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:142
msgid "Examples"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:144
msgid ""
"Types ``R_BPF_64_64`` and ``R_BPF_64_32`` are used to resolve ``ld_imm64`` "
"and ``call`` instructions. For example::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:160
msgid ""
"Compiled with ``clang --target=bpf -O2 -c test.c``, we will have following "
"code with `llvm-objdump -dr test.o``::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:194
msgid ""
"The first relocation corresponds to ``gfunc(a, b)`` where ``gfunc`` has a "
"value of 0, so the ``call`` instruction offset is ``(0 + 0)/8 - 1 = -1``. "
"The second relocation corresponds to ``lfunc(a, b)`` where ``lfunc`` has a "
"section offset ``0x18``, so the ``call`` instruction offset is ``(0 + "
"0x18)/8 - 1 = 2``. The third relocation corresponds to ld_imm64 of "
"``global``, which has a section offset ``0``."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:201
msgid ""
"The following is an example to show how R_BPF_64_ABS64 could be generated::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:206
msgid ""
"Compiled with ``clang --target=bpf -O2 -g -c test.c``, we will see a "
"relocation below in ``.data`` section with command ``llvm-readelf -r test."
"o``::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:214
msgid ""
"The relocation says the first 8-byte of ``.data`` section should be filled "
"with address of ``global`` variable."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:217
msgid ""
"With ``llvm-readelf`` output, we can see that dwarf sections have a bunch of "
"``R_BPF_64_ABS32`` and ``R_BPF_64_ABS64`` relocations::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:233
msgid "The .BTF/.BTF.ext sections has R_BPF_64_NODYLD32 relocations::"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:248
msgid "CO-RE Relocations"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:250
msgid ""
"From object file point of view CO-RE mechanism is implemented as a set of CO-"
"RE specific relocation records. These relocation records are not related to "
"ELF relocations and are encoded in .BTF.ext section. See :ref:`Documentation/"
"bpf/btf.rst <BTF_Ext_Section>` for more information on .BTF.ext structure."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:256
msgid ""
"CO-RE relocations are applied to BPF instructions to update immediate or "
"offset fields of the instruction at load time with information relevant for "
"target kernel."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:260
msgid "Field to patch is selected basing on the instruction class:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:262
msgid "For BPF_ALU, BPF_ALU64, BPF_LD `immediate` field is patched;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:263
msgid "For BPF_LDX, BPF_STX, BPF_ST `offset` field is patched;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:264
msgid "BPF_JMP, BPF_JMP32 instructions **should not** be patched."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:267
msgid "Relocation kinds"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:269
msgid ""
"There are several kinds of CO-RE relocations that could be split in three "
"groups:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:272
msgid ""
"Field-based - patch instruction with field related information, e.g. change "
"offset field of the BPF_LDX instruction to reflect offset of a specific "
"structure field in the target kernel."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:276
msgid ""
"Type-based - patch instruction with type related information, e.g. change "
"immediate field of the BPF_ALU move instruction to 0 or 1 to reflect if "
"specific type is present in the target kernel."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:280
msgid ""
"Enum-based - patch instruction with enum related information, e.g. change "
"immediate field of the BPF_LD_IMM64 instruction to reflect value of a "
"specific enum literal in the target kernel."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:284
msgid ""
"The complete list of relocation kinds is represented by the following enum:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:304
msgid "Notes:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:306
msgid ""
"``BPF_CORE_FIELD_LSHIFT_U64`` and ``BPF_CORE_FIELD_RSHIFT_U64`` are supposed "
"to be used to read bitfield values using the following algorithm:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:323
msgid ""
"The ``BPF_CORE_TYPE_MATCHES`` queries matching relation, defined as follows:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:326
msgid "for integers: types match if size and signedness match;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:327
msgid "for arrays & pointers: target types are recursively matched;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:328
msgid "for structs & unions:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:330
msgid "local members need to exist in target with the same name;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:332
msgid ""
"for each member we recursively check match unless it is already behind a "
"pointer, in which case we only check matching names and compatible kind;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:335
msgid "for enums:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:337
msgid ""
"local variants have to have a match in target by symbolic name (but not "
"numeric value);"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:340
msgid "size has to match (but enum may match enum64 and vice versa);"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:342
msgid "for function pointers:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:344
msgid "number and position of arguments in local type has to match target;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:345
msgid "for each argument and the return value we recursively check match."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:348
msgid "CO-RE Relocation Record"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:350
msgid "Relocation record is encoded as the following structure:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:361
msgid ""
"``insn_off`` - instruction offset (in bytes) within a code section "
"associated with this relocation;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:364
msgid ""
"``type_id`` - BTF type ID of the \"root\" (containing) entity of a "
"relocatable type or field;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:367
msgid ""
"``access_str_off`` - offset into corresponding .BTF string section. String "
"interpretation depends on specific relocation kind:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:370
msgid ""
"for field-based relocations, string encodes an accessed field using a "
"sequence of field and array indices, separated by colon (:). It's "
"conceptually very close to LLVM's `getelementptr <GEP_>`_ instruction's "
"arguments for identifying offset to a field. For example, consider the "
"following C code:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:385
msgid "Access to ``s[0].a`` would be encoded as ``0:0``:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:387
msgid "``0``: first element of ``s`` (as if ``s`` is an array);"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:388
msgid "``0``: index of field ``a`` in ``struct sample``."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:390
msgid "Access to ``s->a`` would be encoded as ``0:0`` as well."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:391
msgid "Access to ``s->b`` would be encoded as ``0:1``:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:393
msgid "``0``: first element of ``s``;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:394
msgid "``1``: index of field ``b`` in ``struct sample``."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:396
msgid "Access to ``s[1].c[5]`` would be encoded as ``1:2:0:5``:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:398
msgid "``1``: second element of ``s``;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:399
msgid "``2``: index of anonymous structure field in ``struct sample``;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:400
msgid "``0``: index of field ``c`` in anonymous structure;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:401
msgid "``5``: access to array element #5."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:403
msgid "for type-based relocations, string is expected to be just \"0\";"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:405
msgid "for enum value-based relocations, string contains an index of enum"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:406
msgid "value within its enum type;"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:408
msgid "``kind`` - one of ``enum bpf_core_relo_kind``."
msgstr ""

#: ../../../bpf/llvm_reloc.rst:415
msgid "CO-RE Relocation Examples"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:417
msgid "For the following C code:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:429
msgid "With the following BTF definitions:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:445
msgid ""
"Field offset relocations are generated automatically when "
"``__attribute__((preserve_access_index))`` is used, for example:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:464
msgid ""
"All relocation kinds could be requested via built-in functions. E.g. field-"
"based relocations:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:500
msgid "Type-based relocations:"
msgstr ""

#: ../../../bpf/llvm_reloc.rst:530
msgid "Enum-based relocations:"
msgstr ""
