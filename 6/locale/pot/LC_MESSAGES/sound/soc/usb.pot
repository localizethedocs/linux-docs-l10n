# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../sound/soc/usb.rst:3
msgid "ASoC USB support"
msgstr ""

#: ../../../sound/soc/usb.rst:6
msgid "Overview"
msgstr ""

#: ../../../sound/soc/usb.rst:7
msgid ""
"In order to leverage the existing USB sound device support in ALSA, the ASoC "
"USB APIs are introduced to allow the subsystems to exchange configuration "
"information."
msgstr ""

#: ../../../sound/soc/usb.rst:11
msgid ""
"One potential use case would be to support USB audio offloading, which is an "
"implementation that allows for an alternate power-optimized path in the "
"audio subsystem to handle the transfer of audio data over the USB bus.  This "
"would let the main processor to stay in lower power modes for longer "
"duration.  The following is an example design of how the ASoC and ALSA "
"pieces can be connected together to achieve this:"
msgstr ""

#: ../../../sound/soc/usb.rst:50
msgid "SoC USB driver"
msgstr ""

#: ../../../sound/soc/usb.rst:52
msgid "Structures"
msgstr ""

#: ../../../sound/soc/usb.rst:53
msgid "``struct snd_soc_usb``"
msgstr ""

#: ../../../sound/soc/usb.rst:55
msgid "``list``: list head for SND SoC struct list"
msgstr ""

#: ../../../sound/soc/usb.rst:56
msgid "``component``: reference to ASoC component"
msgstr ""

#: ../../../sound/soc/usb.rst:57
msgid "``connection_status_cb``: callback to notify connection events"
msgstr ""

#: ../../../sound/soc/usb.rst:58
msgid ""
"``update_offload_route_info``: callback to fetch selected USB sound card/PCM "
"device"
msgstr ""

#: ../../../sound/soc/usb.rst:60
msgid "``priv_data``: driver data"
msgstr ""

#: ../../../sound/soc/usb.rst:62
msgid ""
"The snd_soc_usb structure can be referenced using the ASoC platform card "
"device, or a USB device (udev->dev).  This is created by the ASoC BE DAI "
"link, and the USB sound entity will be able to pass information to the ASoC "
"BE DAI link using this structure."
msgstr ""

#: ../../../sound/soc/usb.rst:67
msgid "``struct snd_soc_usb_device``"
msgstr ""

#: ../../../sound/soc/usb.rst:69
msgid "``card_idx``: sound card index associated with USB sound device"
msgstr ""

#: ../../../sound/soc/usb.rst:70
msgid "``chip_idx``: USB sound chip array index"
msgstr ""

#: ../../../sound/soc/usb.rst:71
msgid ""
"``cpcm_idx``: capture pcm device indexes associated with the USB sound device"
msgstr ""

#: ../../../sound/soc/usb.rst:72
msgid ""
"``ppcm_idx``: playback pcm device indexes associated with the USB sound "
"device"
msgstr ""

#: ../../../sound/soc/usb.rst:73
msgid "``num_playback``: number of playback streams"
msgstr ""

#: ../../../sound/soc/usb.rst:74
msgid "``num_capture``: number of capture streams"
msgstr ""

#: ../../../sound/soc/usb.rst:75
msgid "``list``: list head for the USB sound device list"
msgstr ""

#: ../../../sound/soc/usb.rst:77
msgid ""
"The struct snd_soc_usb_device is created by the USB sound offload driver. "
"This will carry basic parameters/limitations that will be used to determine "
"the possible offloading paths for this USB audio device."
msgstr ""

#: ../../../sound/soc/usb.rst:82
msgid "Functions"
msgstr ""

#: ../../../sound/soc/usb.rst:89
msgid "``card_idx``: the index into the USB sound chip array."
msgstr ""

#: ../../../sound/soc/usb.rst:90
msgid "``params``: Requested PCM parameters from the USB DPCM BE DAI link"
msgstr ""

#: ../../../sound/soc/usb.rst:91
msgid "``direction``: capture or playback"
msgstr ""

#: ../../../sound/soc/usb.rst:93
msgid ""
"**snd_soc_usb_find_supported_format()** ensures that the requested audio "
"profile being requested by the external DSP is supported by the USB device."
msgstr ""

#: ../../../sound/soc/usb.rst:96
msgid "Returns 0 on success, and -EOPNOTSUPP on failure."
msgstr ""

#: ../../../sound/soc/usb.rst:103
msgid "``usbdev``: the usb device that was discovered"
msgstr ""

#: ../../../sound/soc/usb.rst:104
msgid "``sdev``: capabilities of the device"
msgstr ""

#: ../../../sound/soc/usb.rst:106
msgid ""
"**snd_soc_usb_connect()** notifies the ASoC USB DCPM BE DAI link of a USB "
"audio device detection.  This can be utilized in the BE DAI driver to keep "
"track of available USB audio devices.  This is intended to be called by the "
"USB offload driver residing in USB SND."
msgstr ""

#: ../../../sound/soc/usb.rst:111
msgid "Returns 0 on success, negative error code on failure."
msgstr ""

#: ../../../sound/soc/usb.rst:118
msgid "``usbdev``: the usb device that was removed"
msgstr ""

#: ../../../sound/soc/usb.rst:119
msgid "``sdev``: capabilities to free"
msgstr ""

#: ../../../sound/soc/usb.rst:121
msgid ""
"**snd_soc_usb_disconnect()** notifies the ASoC USB DCPM BE DAI link of a USB "
"audio device removal.  This is intended to be called by the USB offload "
"driver that resides in USB SND."
msgstr ""

#: ../../../sound/soc/usb.rst:130
msgid "``usbdev``: the usb device to reference to find private data"
msgstr ""

#: ../../../sound/soc/usb.rst:132
msgid ""
"**snd_soc_usb_find_priv_data()** fetches the private data saved to the SoC "
"USB device."
msgstr ""

#: ../../../sound/soc/usb.rst:135
msgid "Returns pointer to priv_data on success, NULL on failure."
msgstr ""

#: ../../../sound/soc/usb.rst:143
msgid "``component``: ASoC component to add the jack"
msgstr ""

#: ../../../sound/soc/usb.rst:144
msgid "``jack``: jack component to populate"
msgstr ""

#: ../../../sound/soc/usb.rst:146
msgid ""
"**snd_soc_usb_setup_offload_jack()** is a helper to add a sound jack control "
"to the platform sound card.  This will allow for consistent naming to be "
"used on designs that support USB audio offloading.  Additionally, this will "
"enable the jack to notify of changes."
msgstr ""

#: ../../../sound/soc/usb.rst:151 ../../../sound/soc/usb.rst:175
msgid "Returns 0 on success, negative otherwise."
msgstr ""

#: ../../../sound/soc/usb.rst:160
msgid "``dev``: USB device to look up offload path mapping"
msgstr ""

#: ../../../sound/soc/usb.rst:161
msgid "``card``: USB sound card index"
msgstr ""

#: ../../../sound/soc/usb.rst:162
msgid "``pcm``: USB sound PCM device index"
msgstr ""

#: ../../../sound/soc/usb.rst:163
msgid "``direction``: direction to fetch offload routing information"
msgstr ""

#: ../../../sound/soc/usb.rst:164
msgid "``path``: kcontrol selector - pcm device or card index"
msgstr ""

#: ../../../sound/soc/usb.rst:165
msgid ""
"``route``: mapping of sound card and pcm indexes for the offload path.  This "
"is"
msgstr ""

#: ../../../sound/soc/usb.rst:166
msgid ""
"an array of two integers that will carry the card and pcm device indexes in "
"that specific order.  This can be used as the array for the kcontrol output."
msgstr ""

#: ../../../sound/soc/usb.rst:170
msgid ""
"**snd_soc_usb_update_offload_route()** calls a registered callback to the "
"USB BE DAI link to fetch the information about the mapped ASoC devices for "
"executing USB audio offload for the device. ``route`` may be a pointer to a "
"kcontrol value output array, which carries values when the kcontrol is read."
msgstr ""

#: ../../../sound/soc/usb.rst:183
msgid "``component``: DPCM BE DAI link component"
msgstr ""

#: ../../../sound/soc/usb.rst:184
msgid "``data``: private data"
msgstr ""

#: ../../../sound/soc/usb.rst:186
msgid ""
"**snd_soc_usb_allocate_port()** allocates a SoC USB device and populates "
"standard parameters that is used for further operations."
msgstr ""

#: ../../../sound/soc/usb.rst:189
msgid "Returns a pointer to struct soc_usb on success, negative on error."
msgstr ""

#: ../../../sound/soc/usb.rst:196
msgid "``usb``: SoC USB device to free"
msgstr ""

#: ../../../sound/soc/usb.rst:198
msgid "**snd_soc_usb_free_port()** frees a SoC USB device."
msgstr ""

#: ../../../sound/soc/usb.rst:205
msgid "``usb``: SoC USB device to add"
msgstr ""

#: ../../../sound/soc/usb.rst:207
msgid ""
"**snd_soc_usb_add_port()** add an allocated SoC USB device to the SOC USB "
"framework. Once added, this device can be referenced by further operations."
msgstr ""

#: ../../../sound/soc/usb.rst:215
msgid "``usb``: SoC USB device to remove"
msgstr ""

#: ../../../sound/soc/usb.rst:217
msgid ""
"**snd_soc_usb_remove_port()** removes a SoC USB device from the SoC USB "
"framework. After removing a device, any SOC USB operations would not be able "
"to reference the device removed."
msgstr ""

#: ../../../sound/soc/usb.rst:222
msgid "How to Register to SoC USB"
msgstr ""

#: ../../../sound/soc/usb.rst:223
msgid ""
"The ASoC DPCM USB BE DAI link is the entity responsible for allocating and "
"registering the SoC USB device on the component bind.  Likewise, it will "
"also be responsible for freeing the allocated resources.  An example can be "
"shown below:"
msgstr ""

#: ../../../sound/soc/usb.rst:262
msgid ""
"BE DAI links can pass along vendor specific information as part of the call "
"to allocate the SoC USB device.  This will allow any BE DAI link parameters "
"or settings to be accessed by the USB offload driver that resides in USB SND."
msgstr ""

#: ../../../sound/soc/usb.rst:268
msgid "USB Audio Device Connection Flow"
msgstr ""

#: ../../../sound/soc/usb.rst:269
msgid ""
"USB devices can be hotplugged into the USB ports at any point in time. The "
"BE DAI link should be aware of the current state of the physical USB port, i."
"e. if there are any USB devices with audio interface(s) connected. "
"connection_status_cb() can be used to notify the BE DAI link of any change."
msgstr ""

#: ../../../sound/soc/usb.rst:274
msgid ""
"This is called whenever there is a USB SND interface bind or remove event, "
"using snd_soc_usb_connect() or snd_soc_usb_disconnect():"
msgstr ""

#: ../../../sound/soc/usb.rst:294
msgid ""
"In order to account for conditions where driver or device existence is not "
"guaranteed, USB SND exposes snd_usb_rediscover_devices() to resend the "
"connect events for any identified USB audio interfaces.  Consider the the "
"following situation:"
msgstr ""

#: ../../../sound/soc/usb.rst:299 ../../../sound/soc/usb.rst:324
msgid "**usb_audio_probe()**"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> USB audio streams allocated and saved to usb_chip[]"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> Propagate connect event to USB offload driver in USB SND"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> **snd_soc_usb_connect()** exits as USB BE DAI link is not ready"
msgstr ""

#: ../../../sound/soc/usb.rst:304 ../../../sound/soc/usb.rst:312
#: ../../../sound/soc/usb.rst:329
msgid "BE DAI link component probe"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> DAI link is probed and SoC USB port is allocated"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> The USB audio device connect event is missed"
msgstr ""

#: ../../../sound/soc/usb.rst:308
msgid ""
"To ensure connection events are not missed, **snd_usb_rediscover_devices()** "
"is executed when the SoC USB device is registered.  Now, when the BE DAI "
"link component probe occurs, the following highlights the sequence:"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> SoC USB device added, and **snd_usb_rediscover_devices()** runs"
msgstr ""

#: ../../../sound/soc/usb.rst:316
msgid "**snd_usb_rediscover_devices()**"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> Traverses through usb_chip[] and for non-NULL entries issue"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "**connection_status_cb()**"
msgstr ""

#: ../../../sound/soc/usb.rst:320
msgid ""
"In the case where the USB offload driver is unbound, while USB SND is ready, "
"the **snd_usb_rediscover_devices()** is called during module init.  This "
"allows for the offloading path to also be enabled with the following flow:"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> USB offload driver **NOT** ready!"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> No USB connect event due to missing USB offload driver"
msgstr ""

#: ../../../sound/soc/usb.rst:333
msgid "USB offload driver probe"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> **qc_usb_audio_offload_init()**"
msgstr ""

#: ../../../sound/soc/usb.rst:0
msgid "--> Calls **snd_usb_rediscover_devices()** to notify of devices"
msgstr ""

#: ../../../sound/soc/usb.rst:338
msgid "USB Offload Related Kcontrols"
msgstr ""

#: ../../../sound/soc/usb.rst:340
msgid "Details"
msgstr ""

#: ../../../sound/soc/usb.rst:341
msgid ""
"A set of kcontrols can be utilized by applications to help select the proper "
"sound devices to enable USB audio offloading.  SoC USB exposes the "
"get_offload_dev() callback that designs can use to ensure that the proper "
"indices are returned to the application."
msgstr ""

#: ../../../sound/soc/usb.rst:347
msgid "Implementation"
msgstr ""

#: ../../../sound/soc/usb.rst:349
msgid "**Example:**"
msgstr ""

#: ../../../sound/soc/usb.rst:351
msgid "**Sound Cards**:"
msgstr ""

#: ../../../sound/soc/usb.rst:364
msgid "**PCM Devices**:"
msgstr ""

#: ../../../sound/soc/usb.rst:381
msgid "**USB Sound Card** - card#1:"
msgstr ""

#: ../../../sound/soc/usb.rst:388
msgid "**USB Sound Card** - card#2:"
msgstr ""

#: ../../../sound/soc/usb.rst:395
msgid ""
"The above example shows a scenario where the system has one ASoC platform "
"card (card#0) and two USB sound devices connected (card#1 and card#2).  When "
"reading the available kcontrols for each USB audio device, the following "
"kcontrols lists the mapped offload card and pcm device indexes for the "
"specific USB device:"
msgstr ""

#: ../../../sound/soc/usb.rst:400
msgid "``USB Offload Playback Card Route PCM#*``"
msgstr ""

#: ../../../sound/soc/usb.rst:402
msgid "``USB Offload Playback PCM Route PCM#*``"
msgstr ""

#: ../../../sound/soc/usb.rst:404
msgid ""
"The kcontrol is indexed, because a USB audio device could potentially have "
"several PCM devices.  The above kcontrols are defined as:"
msgstr ""

#: ../../../sound/soc/usb.rst:407
msgid ""
"``USB Offload Playback Card Route PCM#`` **(R)**: Returns the ASoC platform "
"sound card index for a mapped offload path.  The output **\"0\"** (card "
"index) signifies that there is an available offload path for the USB SND "
"device through card#0. If **\"-1\"** is seen, then no offload path is "
"available for the USB SND device. This kcontrol exists for each USB audio "
"device that exists in the system, and its expected to derive the current "
"status of offload based on the output value for the kcontrol along with the "
"PCM route kcontrol."
msgstr ""

#: ../../../sound/soc/usb.rst:415
msgid ""
"``USB Offload Playback PCM Route PCM#`` **(R)**: Returns the ASoC platform "
"sound PCM device index for a mapped offload path.  The output **\"1\"** (PCM "
"device index) signifies that there is an available offload path for the USB "
"SND device through PCM device#0. If **\"-1\"** is seen, then no offload path "
"is available for the USB\\ SND device.  This kcontrol exists for each USB "
"audio device that exists in the system, and its expected to derive the "
"current status of offload based on the output value for this kcontrol, in "
"addition to the card route kcontrol."
msgstr ""

#: ../../../sound/soc/usb.rst:424
msgid "USB Offload Playback Route Kcontrol"
msgstr ""

#: ../../../sound/soc/usb.rst:425
msgid ""
"In order to allow for vendor specific implementations on audio offloading "
"device selection, the SoC USB layer exposes the following:"
msgstr ""

#: ../../../sound/soc/usb.rst:436
msgid ""
"These are specific for the **USB Offload Playback Card Route PCM#** and "
"**USB Offload PCM Route PCM#** kcontrols."
msgstr ""

#: ../../../sound/soc/usb.rst:439
msgid ""
"When users issue get calls to the kcontrol, the registered SoC USB callbacks "
"will execute the registered function calls to the DPCM BE DAI link."
msgstr ""

#: ../../../sound/soc/usb.rst:442
msgid "**Callback Registration:**"
msgstr ""

#: ../../../sound/soc/usb.rst:460
msgid "Existing USB Sound Kcontrol"
msgstr ""

#: ../../../sound/soc/usb.rst:461
msgid ""
"With the introduction of USB offload support, the above USB offload kcontrol "
"will be added to the pre existing list of kcontrols identified by the USB "
"sound framework.  These kcontrols are still the main controls that are used "
"to modify characteristics pertaining to the USB audio device."
msgstr ""

#: ../../../sound/soc/usb.rst:481
msgid ""
"Since USB audio device controls are handled over the USB control endpoint, "
"use the existing mechanisms present in the USB mixer to set parameters, such "
"as volume."
msgstr ""
