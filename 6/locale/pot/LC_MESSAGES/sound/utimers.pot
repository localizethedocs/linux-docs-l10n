# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../sound/utimers.rst:5
msgid "Userspace-driven timers"
msgstr ""

#: ../../../sound/utimers.rst:0
msgid "Author"
msgstr ""

#: ../../../sound/utimers.rst:7
msgid "Ivan Orlov <ivan.orlov0322@gmail.com>"
msgstr ""

#: ../../../sound/utimers.rst:10
msgid "Preface"
msgstr ""

#: ../../../sound/utimers.rst:12
msgid ""
"This document describes the userspace-driven timers: virtual ALSA timers "
"which could be created and controlled by userspace applications using IOCTL "
"calls. Such timers could be useful when synchronizing audio stream with "
"timer sources which we don't have ALSA timers exported for (e.g. PTP "
"clocks), and when synchronizing the audio stream going through two virtual "
"sound devices using ``snd-aloop`` (for instance, when we have a network "
"application sending frames to one snd-aloop device, and another sound "
"application listening on the other end of snd-aloop)."
msgstr ""

#: ../../../sound/utimers.rst:22
msgid "Enabling userspace-driven timers"
msgstr ""

#: ../../../sound/utimers.rst:24
msgid ""
"The userspace-driven timers could be enabled in the kernel using the "
"``CONFIG_SND_UTIMER`` configuration option. It depends on the "
"``CONFIG_SND_TIMER`` option, so it also should be enabled."
msgstr ""

#: ../../../sound/utimers.rst:29
msgid "Userspace-driven timers API"
msgstr ""

#: ../../../sound/utimers.rst:31
msgid ""
"Userspace application can create a userspace-driven ALSA timer by executing "
"the ``SNDRV_TIMER_IOCTL_CREATE`` ioctl call on the ``/dev/snd/timer`` device "
"file descriptor. The ``snd_timer_uinfo`` structure should be passed as an "
"ioctl argument:"
msgstr ""

#: ../../../sound/utimers.rst:45
msgid ""
"The ``resolution`` field sets the desired resolution in nanoseconds for the "
"virtual timer. ``resolution`` field simply provides an information about the "
"virtual timer, but does not affect the timing itself. ``id`` field gets "
"overwritten by the ioctl, and the identifier you get in this field after the "
"call can be used as a timer subdevice number when passing the timer to ``snd-"
"aloop`` kernel module or other userspace applications. There could be up to "
"128 userspace-driven timers in the system at one moment of time, thus the id "
"value ranges from 0 to 127."
msgstr ""

#: ../../../sound/utimers.rst:54
msgid ""
"Besides from overwriting the ``snd_timer_uinfo`` struct, ioctl stores a "
"timer file descriptor, which can be used to trigger the timer, in the ``fd`` "
"field of the ``snd_timer_uinfo`` struct. Allocation of a file descriptor for "
"the timer guarantees that the timer can only be triggered by the process "
"which created it. The timer then can be triggered with "
"``SNDRV_TIMER_IOCTL_TRIGGER`` ioctl call on the timer file descriptor."
msgstr ""

#: ../../../sound/utimers.rst:61
msgid "So, the example code for creating and triggering the timer would be:"
msgstr ""

#: ../../../sound/utimers.rst:93
msgid ""
"More detailed example of creating and ticking the timer could be found in "
"the utimer ALSA selftest."
msgstr ""

#: ../../../sound/utimers.rst:97
msgid "Userspace-driven timers and snd-aloop"
msgstr ""

#: ../../../sound/utimers.rst:99
msgid ""
"Userspace-driven timers could be easily used with ``snd-aloop`` module when "
"synchronizing two sound applications on both ends of the virtual sound "
"loopback. For instance, if one of the applications receives sound frames "
"from network and sends them to snd-aloop pcm device, and another application "
"listens for frames on the other snd-aloop pcm device, it makes sense that "
"the ALSA middle layer should initiate a data transaction when the new period "
"of data is received through network, but not when the certain amount of "
"jiffies elapses. Userspace-driven ALSA timers could be used to achieve this."
msgstr ""

#: ../../../sound/utimers.rst:109
msgid ""
"To use userspace-driven ALSA timer as a timer source of snd-aloop, pass the "
"following string as the snd-aloop ``timer_source`` parameter:"
msgstr ""

#: ../../../sound/utimers.rst:116
msgid ""
"Where ``utimer_id`` is the id of the timer you created with "
"``SNDRV_TIMER_IOCTL_CREATE``, and ``4`` is the number of userspace-driven "
"timers device (``SNDRV_TIMER_GLOBAL_UDRIVEN``)."
msgstr ""

#: ../../../sound/utimers.rst:120
msgid ""
"``resolution`` for the userspace-driven ALSA timer used with snd-aloop "
"should be calculated as ``1000000000ULL / frame_rate * period_size`` as the "
"timer is going to tick every time a new period of frames is ready."
msgstr ""

#: ../../../sound/utimers.rst:124
msgid ""
"After that, each time you trigger the timer with "
"``SNDRV_TIMER_IOCTL_TRIGGER`` the new period of data will be transferred "
"from one snd-aloop device to another."
msgstr ""
