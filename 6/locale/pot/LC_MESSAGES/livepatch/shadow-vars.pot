# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../livepatch/shadow-vars.rst:3
msgid "Shadow Variables"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:5
msgid ""
"Shadow variables are a simple way for livepatch modules to associate "
"additional \"shadow\" data with existing data structures.  Shadow data is "
"allocated separately from parent data structures, which are left "
"unmodified.  The shadow variable API described in this document is used to "
"allocate/add and remove/free shadow variables to/from their parents."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:11
msgid ""
"The implementation introduces a global, in-kernel hashtable that associates "
"pointers to parent objects and a numeric identifier of the shadow data.  The "
"numeric identifier is a simple enumeration that may be used to describe "
"shadow variable version, class or type, etc.  More specifically, the parent "
"pointer serves as the hashtable key while the numeric id subsequently "
"filters hashtable queries.  Multiple shadow variables may attach to the same "
"parent object, but their numeric identifier distinguishes between them."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:22
msgid "1. Brief API summary"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:24
msgid "(See the full API usage docbook notes in livepatch/shadow.c.)"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:26
msgid ""
"A hashtable references all shadow variables.  These references are stored "
"and retrieved through a <obj, id> pair."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:29
msgid ""
"The klp_shadow variable data structure encapsulates both tracking meta-data "
"and shadow-data:"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:32
msgid "meta-data"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:34
msgid "obj - pointer to parent object"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:35
msgid "id - data identifier"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:37
msgid "data[] - storage for shadow data"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:39
msgid ""
"It is important to note that the klp_shadow_alloc() and "
"klp_shadow_get_or_alloc() are zeroing the variable by default. They also "
"allow to call a custom constructor function when a non-zero value is needed. "
"Callers should provide whatever mutual exclusion is required."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:45
msgid ""
"Note that the constructor is called under klp_shadow_lock spinlock. It "
"allows to do actions that can be done only once when a new variable is "
"allocated."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:48
msgid ""
"klp_shadow_get() - retrieve a shadow variable data pointer - search "
"hashtable for <obj, id> pair"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:51
msgid ""
"klp_shadow_alloc() - allocate and add a new shadow variable - search "
"hashtable for <obj, id> pair"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:54 ../../../livepatch/shadow-vars.rst:67
msgid "if exists"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:56
msgid "WARN and return NULL"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:58 ../../../livepatch/shadow-vars.rst:71
msgid "if <obj, id> doesn't already exist"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:60 ../../../livepatch/shadow-vars.rst:73
msgid "allocate a new shadow variable"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:61 ../../../livepatch/shadow-vars.rst:74
msgid ""
"initialize the variable using a custom constructor and data when provided"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:62
msgid "add <obj, id> to the global hashtable"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:64
msgid ""
"klp_shadow_get_or_alloc() - get existing or alloc a new shadow variable - "
"search hashtable for <obj, id> pair"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:69
msgid "return existing shadow variable"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:75
msgid "add <obj, id> pair to the global hashtable"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:77
msgid ""
"klp_shadow_free() - detach and free a <obj, id> shadow variable - find and "
"remove a <obj, id> reference from global hashtable"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:80 ../../../livepatch/shadow-vars.rst:88
msgid "if found"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:82 ../../../livepatch/shadow-vars.rst:90
msgid "call destructor function if defined"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:83 ../../../livepatch/shadow-vars.rst:91
msgid "free shadow variable"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:85
msgid ""
"klp_shadow_free_all() - detach and free all <_, id> shadow variables - find "
"and remove any <_, id> references from global hashtable"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:95
msgid "2. Use cases"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:97
msgid ""
"(See the example shadow variable livepatch modules in samples/livepatch/ for "
"full working demonstrations.)"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:100
msgid ""
"For the following use-case examples, consider commit 1d147bfa6429 "
"(\"mac80211: fix AP powersave TX vs.  wakeup race\"), which added a spinlock "
"to net/mac80211/sta_info.h :: struct sta_info.  Each use-case example can be "
"considered a stand-alone livepatch implementation of this fix."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:108
msgid "Matching parent's lifecycle"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:110
msgid ""
"If parent data structures are frequently created and destroyed, it may be "
"easiest to align their shadow variables lifetimes to the same allocation and "
"release functions.  In this case, the parent data structure is typically "
"allocated, initialized, then registered in some manner.  Shadow variable "
"allocation and setup can then be considered part of the parent's "
"initialization and should be completed before the parent \"goes live\" (ie, "
"any shadow variable get-API requests are made for this <obj, id> pair.)"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:119
msgid ""
"For commit 1d147bfa6429, when a parent sta_info structure is allocated, "
"allocate a shadow copy of the ps_lock pointer, then initialize it::"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:140
msgid ""
"When requiring a ps_lock, query the shadow variable API to retrieve one for "
"a specific struct sta_info:::"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:153
msgid ""
"When the parent sta_info structure is freed, first free the shadow variable::"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:164
msgid "In-flight parent objects"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:166
msgid ""
"Sometimes it may not be convenient or possible to allocate shadow variables "
"alongside their parent objects.  Or a livepatch fix may require shadow "
"variables for only a subset of parent object instances. In these cases, the "
"klp_shadow_get_or_alloc() call can be used to attach shadow variables to "
"parents already in-flight."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:172
msgid ""
"For commit 1d147bfa6429, a good spot to allocate a shadow spinlock is inside "
"ieee80211_sta_ps_deliver_wakeup()::"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:197
msgid ""
"This usage will create a shadow variable, only if needed, otherwise it will "
"use one that was already created for this <obj, id> pair."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:200
msgid ""
"Like the previous use-case, the shadow spinlock needs to be cleaned up. A "
"shadow variable can be freed just before its parent object is freed, or even "
"when the shadow variable itself is no longer required."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:206
msgid "Other use-cases"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:208
msgid ""
"Shadow variables can also be used as a flag indicating that a data structure "
"was allocated by new, livepatched code.  In this case, it doesn't matter "
"what data value the shadow variable holds, its existence suggests how to "
"handle the parent object."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:215
msgid "3. References"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:217
msgid "https://github.com/dynup/kpatch"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:219
msgid ""
"The livepatch implementation is based on the kpatch version of shadow "
"variables."
msgstr ""

#: ../../../livepatch/shadow-vars.rst:222
msgid "http://files.mkgnu.net/files/dynamos/doc/papers/dynamos_eurosys_07.pdf"
msgstr ""

#: ../../../livepatch/shadow-vars.rst:224
msgid ""
"Dynamic and Adaptive Updates of Non-Quiescent Subsystems in Commodity "
"Operating System Kernels (Kritis Makris, Kyung Dong Ryu 2007) presented a "
"datatype update technique called \"shadow data structures\"."
msgstr ""
