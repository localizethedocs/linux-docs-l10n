# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../livepatch/cumulative-patches.rst:3
msgid "Atomic Replace & Cumulative Patches"
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:5
msgid ""
"There might be dependencies between livepatches. If multiple patches need to "
"do different changes to the same function(s) then we need to define an order "
"in which the patches will be installed. And function implementations from "
"any newer livepatch must be done on top of the older ones."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:10
msgid ""
"This might become a maintenance nightmare. Especially when more patches "
"modified the same function in different ways."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:13
msgid ""
"An elegant solution comes with the feature called \"Atomic Replace\". It "
"allows creation of so called \"Cumulative Patches\". They include all wanted "
"changes from all older livepatches and completely replace them in one "
"transition."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:18
msgid "Usage"
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:20
msgid ""
"The atomic replace can be enabled by setting \"replace\" flag in struct "
"klp_patch, for example::"
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:29
msgid ""
"All processes are then migrated to use the code only from the new patch. "
"Once the transition is finished, all older patches are automatically "
"disabled."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:33
msgid ""
"Ftrace handlers are transparently removed from functions that are no longer "
"modified by the new cumulative patch."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:36
msgid ""
"As a result, the livepatch authors might maintain sources only for one "
"cumulative patch. It helps to keep the patch consistent while adding or "
"removing various fixes or features."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:40
msgid ""
"Users could keep only the last patch installed on the system after the "
"transition to has finished. It helps to clearly see what code is actually in "
"use. Also the livepatch might then be seen as a \"normal\" module that "
"modifies the kernel behavior. The only difference is that it can be updated "
"at runtime without breaking its functionality."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:48
msgid "Features"
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:50
msgid "The atomic replace allows:"
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:52
msgid ""
"Atomically revert some functions in a previous patch while upgrading other "
"functions."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:55
msgid ""
"Remove eventual performance impact caused by core redirection for functions "
"that are no longer patched."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:58
msgid "Decrease user confusion about dependencies between livepatches."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:62
msgid "Limitations:"
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:64
msgid ""
"Once the operation finishes, there is no straightforward way to reverse it "
"and restore the replaced patches atomically."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:67
msgid ""
"A good practice is to set .replace flag in any released livepatch. Then re-"
"adding an older livepatch is equivalent to downgrading to that patch. This "
"is safe as long as the livepatches do _not_ do extra modifications in "
"(un)patching callbacks or in the module_init() or module_exit() functions, "
"see below."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:73
msgid ""
"Also note that the replaced patch can be removed and loaded again only when "
"the transition was not forced."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:77
msgid ""
"Only the (un)patching callbacks from the _new_ cumulative livepatch are "
"executed. Any callbacks from the replaced patches are ignored."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:80
msgid ""
"In other words, the cumulative patch is responsible for doing any actions "
"that are necessary to properly replace any older patch."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:83
msgid ""
"As a result, it might be dangerous to replace newer cumulative patches by "
"older ones. The old livepatches might not provide the necessary callbacks."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:86
msgid ""
"This might be seen as a limitation in some scenarios. But it makes life "
"easier in many others. Only the new cumulative livepatch knows what fixes/"
"features are added/removed and what special actions are necessary for a "
"smooth transition."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:91
msgid ""
"In any case, it would be a nightmare to think about the order of the various "
"callbacks and their interactions if the callbacks from all enabled patches "
"were called."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:96
msgid ""
"There is no special handling of shadow variables. Livepatch authors must "
"create their own rules how to pass them from one cumulative patch to the "
"other. Especially that they should not blindly remove them in module_exit() "
"functions."
msgstr ""

#: ../../../livepatch/cumulative-patches.rst:101
msgid ""
"A good practice might be to remove shadow variables in the post-unpatch "
"callback. It is called only when the livepatch is properly disabled."
msgstr ""
