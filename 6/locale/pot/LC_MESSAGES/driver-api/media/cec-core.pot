# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/media/cec-core.rst:4
msgid "CEC Kernel Support"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:6
msgid ""
"The CEC framework provides a unified kernel interface for use with HDMI CEC "
"hardware. It is designed to handle a multiple types of hardware (receivers, "
"transmitters, USB dongles). The framework also gives the option to decide "
"what to do in the kernel driver and what should be handled by userspace "
"applications. In addition it integrates the remote control passthrough "
"feature into the kernel's remote control framework."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:15
msgid "The CEC Protocol"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:17
msgid ""
"The CEC protocol enables consumer electronic devices to communicate with "
"each other through the HDMI connection. The protocol uses logical addresses "
"in the communication. The logical address is strictly connected with the "
"functionality provided by the device. The TV acting as the communication hub "
"is always assigned address 0. The physical address is determined by the "
"physical connection between devices."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:24
msgid ""
"The CEC framework described here is up to date with the CEC 2.0 "
"specification. It is documented in the HDMI 1.4 specification with the new "
"2.0 bits documented in the HDMI 2.0 specification. But for most of the "
"features the freely available HDMI 1.3a specification is sufficient:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:29
msgid "https://www.hdmi.org/spec/index"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:33
msgid "CEC Adapter Interface"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:35
msgid ""
"The struct cec_adapter represents the CEC adapter hardware. It is created by "
"calling cec_allocate_adapter() and deleted by calling cec_delete_adapter():"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:46
msgid "To create an adapter you need to pass the following information:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:48
msgid "ops:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:49
msgid ""
"adapter operations which are called by the CEC framework and that you have "
"to implement."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:52
msgid "priv:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:53
#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:66
msgid ""
"will be stored in adap->priv and can be used by the adapter ops. Use "
"cec_get_drvdata(adap) to get the priv pointer."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:56
msgid "name:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:57
#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:68
msgid "the name of the CEC adapter. Note: this name will be copied."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:59
msgid "caps:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:60
msgid ""
"capabilities of the CEC adapter. These capabilities determine the "
"capabilities of the hardware and which parts are to be handled by userspace "
"and which parts are handled by kernelspace. The capabilities are returned by "
"CEC_ADAP_G_CAPS."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:65
msgid "available_las:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:66
msgid ""
"the number of simultaneous logical addresses that this adapter can handle. "
"Must be 1 <= available_las <= CEC_MAX_LOG_ADDRS."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:69
msgid "To obtain the priv pointer use this helper function:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:74
msgid ""
"To register the /dev/cecX device node and the remote control device (if "
"CEC_CAP_RC is set) you call:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:81
msgid "where parent is the parent device."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:83
msgid "To unregister the devices call:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:88
msgid ""
"Note: if cec_register_adapter() fails, then call cec_delete_adapter() to "
"clean up. But if cec_register_adapter() succeeded, then only call "
"cec_unregister_adapter() to clean up, never cec_delete_adapter(). The "
"unregister function will delete the adapter automatically once the last user "
"of that /dev/cecX device has closed its file handle."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:96
msgid "Implementing the Low-Level CEC Adapter"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:98
msgid ""
"The following low-level adapter operations have to be implemented in your "
"driver:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:127
msgid ""
"These low-level ops deal with various aspects of controlling the CEC adapter "
"hardware. They are all called with the mutex adap->lock held."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:131
msgid "To enable/disable the hardware::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:135
msgid ""
"This callback enables or disables the CEC hardware. Enabling the CEC "
"hardware means powering it up in a state where no logical addresses are "
"claimed. The physical address will always be valid if CEC_CAP_NEEDS_HPD is "
"set. If that capability is not set, then the physical address can change "
"while the CEC hardware is enabled. CEC drivers should not set "
"CEC_CAP_NEEDS_HPD unless the hardware design requires that as this will make "
"it impossible to wake up displays that pull the HPD low when in standby "
"mode.  The initial state of the CEC adapter after calling "
"cec_allocate_adapter() is disabled."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:144
msgid "Note that adap_enable must return 0 if enable is false."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:147
msgid "To enable/disable the 'monitor all' mode::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:151
msgid ""
"If enabled, then the adapter should be put in a mode to also monitor "
"messages that are not for us. Not all hardware supports this and this "
"function is only called if the CEC_CAP_MONITOR_ALL capability is set. This "
"callback is optional (some hardware may always be in 'monitor all' mode)."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:156
msgid "Note that adap_monitor_all_enable must return 0 if enable is false."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:159
msgid "To enable/disable the 'monitor pin' mode::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:163
msgid ""
"If enabled, then the adapter should be put in a mode to also monitor CEC pin "
"changes. Not all hardware supports this and this function is only called if "
"the CEC_CAP_MONITOR_PIN capability is set. This callback is optional (some "
"hardware may always be in 'monitor pin' mode)."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:168
msgid "Note that adap_monitor_pin_enable must return 0 if enable is false."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:171
msgid "To program a new logical address::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:175
msgid ""
"If logical_addr == CEC_LOG_ADDR_INVALID then all programmed logical "
"addresses are to be erased. Otherwise the given logical address should be "
"programmed. If the maximum number of available logical addresses is "
"exceeded, then it should return -ENXIO. Once a logical address is programmed "
"the CEC hardware can receive directed messages to that address."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:181
msgid ""
"Note that adap_log_addr must return 0 if logical_addr is "
"CEC_LOG_ADDR_INVALID."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:184
msgid "Called when the adapter is unconfigured::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:188
msgid ""
"The adapter is unconfigured. If the driver has to take specific actions "
"after unconfiguration, then that can be done through this optional callback."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:192
msgid "To transmit a new message::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:197
msgid ""
"This transmits a new message. The attempts argument is the suggested number "
"of attempts for the transmit."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:200
msgid ""
"The signal_free_time is the number of data bit periods that the adapter "
"should wait when the line is free before attempting to send a message. This "
"value depends on whether this transmit is a retry, a message from a new "
"initiator or a new message for the same initiator. Most hardware will handle "
"this automatically, but in some cases this information is needed."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:206
msgid ""
"The CEC_FREE_TIME_TO_USEC macro can be used to convert signal_free_time to "
"microseconds (one data bit period is 2.4 ms)."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:210
msgid "To pass on the result of a canceled non-blocking transmit::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:215
msgid ""
"This optional callback can be used to obtain the result of a canceled non-"
"blocking transmit with sequence number msg->sequence. This is called if the "
"transmit was aborted, the transmit timed out (i.e. the hardware never "
"signaled that the transmit finished), or the transmit was successful, but "
"the wait for the expected reply was either aborted or it timed out."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:223
msgid "To log the current CEC hardware status::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:227
msgid ""
"This optional callback can be used to show the status of the CEC hardware. "
"The status is available through debugfs: cat /sys/kernel/debug/cec/cecX/"
"status"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:230
msgid "To free any resources when the adapter is deleted::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:234
msgid ""
"This optional callback can be used to free any resources that might have "
"been allocated by the driver. It's called from cec_delete_adapter."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:238
msgid ""
"Your adapter driver will also have to react to events (typically interrupt "
"driven) by calling into the framework in the following situations:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:241
msgid "When a transmit finished (successfully or otherwise)::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:247
msgid "or::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:251
msgid "The status can be one of:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:253
msgid "CEC_TX_STATUS_OK:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:254
msgid "the transmit was successful."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:256
msgid "CEC_TX_STATUS_ARB_LOST:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:257
msgid ""
"arbitration was lost: another CEC initiator took control of the CEC line and "
"you lost the arbitration."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:260
msgid "CEC_TX_STATUS_NACK:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:261
msgid ""
"the message was nacked (for a directed message) or acked (for a broadcast "
"message). A retransmission is needed."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:264
msgid "CEC_TX_STATUS_LOW_DRIVE:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:265
msgid ""
"low drive was detected on the CEC bus. This indicates that a follower "
"detected an error on the bus and requested a retransmission."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:269
msgid "CEC_TX_STATUS_ERROR:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:270
msgid ""
"some unspecified error occurred: this can be one of ARB_LOST or LOW_DRIVE if "
"the hardware cannot differentiate or something else entirely. Some hardware "
"only supports OK and FAIL as the result of a transmit, i.e. there is no way "
"to differentiate between the different possible errors. In that case map "
"FAIL to CEC_TX_STATUS_NACK and not to CEC_TX_STATUS_ERROR."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:277
msgid "CEC_TX_STATUS_MAX_RETRIES:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:278
msgid ""
"could not transmit the message after trying multiple times. Should only be "
"set by the driver if it has hardware support for retrying messages. If set, "
"then the framework assumes that it doesn't have to make another attempt to "
"transmit the message since the hardware did that already."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:284
msgid ""
"The hardware must be able to differentiate between OK, NACK and 'something "
"else'."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:287
msgid ""
"The \\*_cnt arguments are the number of error conditions that were seen. "
"This may be 0 if no information is available. Drivers that do not support "
"hardware retry can just set the counter corresponding to the transmit error "
"to 1, if the hardware does support retry then either set these counters to 0 "
"if the hardware provides no feedback of which errors occurred and how many "
"times, or fill in the correct values as reported by the hardware."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:294
msgid ""
"Be aware that calling these functions can immediately start a new transmit "
"if there is one pending in the queue. So make sure that the hardware is in a "
"state where new transmits can be started *before* calling these functions."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:298
msgid ""
"The cec_transmit_attempt_done() function is a helper for cases where the "
"hardware never retries, so the transmit is always for just a single attempt. "
"It will call cec_transmit_done() in turn, filling in 1 for the count "
"argument corresponding to the status. Or all 0 if the status was OK."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:303
msgid "When a CEC message was received:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:308
msgid "Speaks for itself."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:311
msgid "Implementing the interrupt handler"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:313
msgid ""
"Typically the CEC hardware provides interrupts that signal when a transmit "
"finished and whether it was successful or not, and it provides and interrupt "
"when a CEC message was received."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:317
msgid ""
"The CEC driver should always process the transmit interrupts first before "
"handling the receive interrupt. The framework expects to see the "
"cec_transmit_done call before the cec_received_msg call, otherwise it can "
"get confused if the received message was in reply to the transmitted message."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:323
msgid "Optional: Implementing Error Injection Support"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:325
msgid ""
"If the CEC adapter supports Error Injection functionality, then that can be "
"exposed through the Error Injection callbacks:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:342
msgid ""
"If both callbacks are set, then an ``error-inj`` file will appear in "
"debugfs. The basic syntax is as follows:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:345
msgid ""
"Leading spaces/tabs are ignored. If the next character is a ``#`` or the end "
"of the line was reached, then the whole line is ignored. Otherwise a command "
"is expected."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:348
msgid ""
"This basic parsing is done in the CEC Framework. It is up to the driver to "
"decide what commands to implement. The only requirement is that the command "
"``clear`` without any arguments must be implemented and that it will remove "
"all current error injection commands."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:353
msgid ""
"This ensures that you can always do ``echo clear >error-inj`` to clear any "
"error injections without having to know the details of the driver-specific "
"commands."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:356
msgid ""
"Note that the output of ``error-inj`` shall be valid as input to ``error-"
"inj``. So this must work:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:364
msgid ""
"The first callback is called when this file is read and it should show the "
"current error injection state::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:369
msgid ""
"It is recommended that it starts with a comment block with basic usage "
"information. It returns 0 for success and an error otherwise."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:372
msgid ""
"The second callback will parse commands written to the ``error-inj`` file::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:376
msgid ""
"The ``line`` argument points to the start of the command. Any leading spaces "
"or tabs have already been skipped. It is a single line only (so there are no "
"embedded newlines) and it is 0-terminated. The callback is free to modify "
"the contents of the buffer. It is only called for lines containing a "
"command, so this callback is never called for empty lines or comment lines."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:382
msgid ""
"Return true if the command was valid or false if there were syntax errors."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:385
msgid "Implementing the High-Level CEC Adapter"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:387
msgid ""
"The low-level operations drive the hardware, the high-level operations are "
"CEC protocol driven. The high-level callbacks are called without the adap-"
">lock mutex being held. The following high-level callbacks are available:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:405
msgid "Called when the adapter is configured::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:409
msgid ""
"The adapter is fully configured, i.e. all logical addresses have been "
"successfully claimed. If the driver has to take specific actions after "
"configuration, then that can be done through this optional callback."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:414
msgid ""
"The received() callback allows the driver to optionally handle a newly "
"received CEC message::"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:419
msgid ""
"If the driver wants to process a CEC message, then it can implement this "
"callback. If it doesn't want to handle this message, then it should return -"
"ENOMSG, otherwise the CEC framework assumes it processed this message and it "
"will not do anything with it."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:426
msgid "CEC framework functions"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:428
msgid "CEC Adapter drivers can call the following CEC framework functions:"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:434
msgid ""
"Transmit a CEC message. If block is true, then wait until the message has "
"been transmitted, otherwise just queue it and return."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:440
msgid ""
"Change the physical address. This function will set adap->phys_addr and send "
"an event if it has changed. If cec_s_log_addrs() has been called and the "
"physical address has become valid, then the CEC framework will start "
"claiming the logical addresses. If block is true, then this function won't "
"return until this process has finished."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:446
msgid ""
"When the physical address is set to a valid value the CEC adapter will be "
"enabled (see the adap_enable op). When it is set to CEC_PHYS_ADDR_INVALID, "
"then the CEC adapter will be disabled. If you change a valid physical "
"address to another valid physical address, then this function will first set "
"the address to CEC_PHYS_ADDR_INVALID before enabling the new physical "
"address."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:456
msgid ""
"A helper function that extracts the physical address from the edid struct "
"and calls cec_s_phys_addr() with that address, or CEC_PHYS_ADDR_INVALID if "
"the EDID did not contain a physical address or edid was a NULL pointer."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:464
msgid ""
"Claim the CEC logical addresses. Should never be called if CEC_CAP_LOG_ADDRS "
"is set. If block is true, then wait until the logical addresses have been "
"claimed, otherwise just queue it and return. To unconfigure all logical "
"addresses call this function with log_addrs set to NULL or with log_addrs-"
">num_log_addrs set to 0. The block argument is ignored when unconfiguring. "
"This function will just return if the physical address is invalid. Once the "
"physical address becomes valid, then the framework will attempt to claim "
"these logical addresses."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:474
msgid "CEC Pin framework"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:476
msgid ""
"Most CEC hardware operates on full CEC messages where the software provides "
"the message and the hardware handles the low-level CEC protocol. But some "
"hardware only drives the CEC pin and software has to handle the low-level "
"CEC protocol. The CEC pin framework was created to handle such devices."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:481
msgid ""
"Note that due to the close-to-realtime requirements it can never be "
"guaranteed to work 100%. This framework uses highres timers internally, but "
"if a timer goes off too late by more than 300 microseconds wrong results can "
"occur. In reality it appears to be fairly reliable."
msgstr ""

#: ../../../driver-api/media/cec-core.rst:486
msgid ""
"One advantage of this low-level implementation is that it can be used as a "
"cheap CEC analyser, especially if interrupts can be used to detect CEC pin "
"transitions from low to high or vice versa."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:15
msgid "low-level CEC pin operations"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:19
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:34
msgid "**Members**"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:16
msgid "``read``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:17
msgid ""
"read the CEC pin. Returns > 0 if high, 0 if low, or an error if negative."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:18
msgid "``low``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:19
msgid "drive the CEC pin low."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:19
msgid "``high``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:20
msgid ""
"stop driving the CEC pin. The pull-up will drive the pin high, unless "
"someone else is driving the pin low."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:21
msgid "``enable_irq``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:22
msgid "optional, enable the interrupt to detect pin voltage changes."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:22
msgid "``disable_irq``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:23
msgid "optional, disable the interrupt."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:23
msgid "``free``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:24
msgid ""
"optional. Free any allocated resources. Called when the adapter is deleted."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:25
msgid "``status``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:26
msgid "optional, log status information."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:26
msgid "``read_hpd``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:27
msgid ""
"optional. Read the HPD pin. Returns > 0 if high, 0 if low or an error if "
"negative."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:28
msgid "``read_5v``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:29
msgid ""
"optional. Read the 5V pin. Returns > 0 if high, 0 if low or an error if "
"negative."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:30
msgid "``received``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:31
msgid ""
"optional. High-level CEC message callback. Allows the driver to process CEC "
"messages."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:35
#: include/media/cec-pin.h:57 include/media/cec-pin.h:72
#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:30
#: include/media/cec-notifier.h:57 include/media/cec-notifier.h:83
#: include/media/cec-notifier.h:93 include/media/cec-notifier.h:103
#: include/media/cec-notifier.h:158
msgid "**Description**"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:32
msgid ""
"These operations (except for the **received** op) are used by the cec pin "
"framework to manipulate the CEC pin."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:52
msgid "update pin state from interrupt"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:56
#: include/media/cec-pin.h:67 ../../../driver-api/media/cec-core:502:
#: include/media/cec-notifier.h:27 include/media/cec-notifier.h:47
#: include/media/cec-notifier.h:54 include/media/cec-notifier.h:74
#: include/media/cec-notifier.h:83 include/media/cec-notifier.h:93
#: include/media/cec-notifier.h:104 include/media/cec-notifier.h:158
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:58
#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:56
#: include/media/cec-notifier.h:74
msgid "``struct cec_adapter *adap``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:54
msgid "pointer to the cec adapter"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:56
msgid "``bool value``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:55
msgid "when true the pin is high, otherwise it is low"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:56
msgid ""
"If changes of the CEC voltage are detected via an interrupt, then "
"cec_pin_changed is called from the interrupt with the new value."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:63
msgid "allocate a pin-based cec adapter"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:69
msgid "``const struct cec_pin_ops *pin_ops``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:65
msgid "low-level pin operations"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:67
msgid "``void *priv``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:69
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:70
msgid "``u32 caps``"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:69
msgid ""
"capabilities of the CEC adapter. This will be ORed with CEC_CAP_MONITOR_ALL "
"and CEC_CAP_MONITOR_PIN."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:71
msgid "Allocate a cec adapter using the cec pin framework."
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:73
msgid "**Return**"
msgstr ""

#: ../../../driver-api/media/cec-core:490: include/media/cec-pin.h:74
msgid "a pointer to the cec adapter or an error pointer"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:493
msgid "CEC Notifier framework"
msgstr ""

#: ../../../driver-api/media/cec-core.rst:495
msgid ""
"Most drm HDMI implementations have an integrated CEC implementation and no "
"notifier support is needed. But some have independent CEC implementations "
"that have their own driver. This could be an IP block for an SoC or a "
"completely separate chip that deals with the CEC pin. For those cases a drm "
"driver can install a notifier and use the notifier to inform the CEC driver "
"about changes in the physical address."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:23
msgid ""
"find or create a new cec_notifier for the given HDMI device and connector "
"tuple."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:29
#: include/media/cec-notifier.h:56
msgid "``struct device *hdmi_dev``"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:25
#: include/media/cec-notifier.h:52
msgid "HDMI device that sends the events."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:27
#: include/media/cec-notifier.h:54
msgid "``const char *port_name``"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:26
#: include/media/cec-notifier.h:53
msgid ""
"the connector name from which the event occurs. May be NULL if there is "
"always only one HDMI connector created by the HDMI device."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:29
msgid "``const struct cec_connector_info *conn_info``"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:28
msgid "the connector info from which the event occurs (may be NULL)"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:29
#: include/media/cec-notifier.h:56
msgid ""
"If a notifier for device **dev** and connector **port_name** already exists, "
"then increase the refcount and return that notifier."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:32
#: include/media/cec-notifier.h:59
msgid ""
"If it doesn't exist, then allocate a new notifier struct and return a "
"pointer to that new struct."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:35
#: include/media/cec-notifier.h:62
msgid "Return NULL if the memory could not be allocated."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:43
#: include/media/cec-notifier.h:70
msgid "decrease refcount and delete when the refcount reaches 0."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:49
#: include/media/cec-notifier.h:76 include/media/cec-notifier.h:85
#: include/media/cec-notifier.h:95 include/media/cec-notifier.h:160
msgid "``struct cec_notifier *n``"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:45
#: include/media/cec-notifier.h:72
msgid "notifier. If NULL, then this function does nothing."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:50
msgid "find or create a new cec_notifier for the given device."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:55
#: include/media/cec-notifier.h:73
msgid "the cec adapter that registered this notifier."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:79
msgid "set a new physical address."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:80
#: include/media/cec-notifier.h:90 include/media/cec-notifier.h:156
msgid "the CEC notifier"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:82
msgid "``u16 pa``"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:81
msgid "the CEC physical address"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:82
msgid "Set a new CEC physical address. Does nothing if **n** == NULL."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:89
msgid "set parse the PA from the EDID."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:92
msgid "``const struct edid *edid``"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:91
msgid "the struct edid pointer"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:92
msgid ""
"Parses the EDID to obtain the new CEC physical address and set it. Does "
"nothing if **n** == NULL."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:100
msgid "find the hdmi device from \"hdmi-phandle\""
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:106
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:101
msgid "the device with the \"hdmi-phandle\" device tree property"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:102
msgid ""
"Returns the device pointer referenced by the \"hdmi-phandle\" property. Note "
"that the refcount of the returned device is not incremented. This device "
"pointer is only used as a key value in the notifier list, but it is never "
"accessed by the CEC driver."
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:154
msgid "set the physical address to INVALID"
msgstr ""

#: ../../../driver-api/media/cec-core:502: include/media/cec-notifier.h:157
msgid ""
"This is a simple helper function to invalidate the physical address. Does "
"nothing if **n** == NULL."
msgstr ""
