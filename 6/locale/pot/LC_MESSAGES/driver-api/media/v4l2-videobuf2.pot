# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/media/v4l2-videobuf2.rst:6
msgid "V4L2 videobuf2 functions and data structures"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:27
msgid "type of memory model used to make the buffers visible on userspace."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:31 include/media/videobuf2-core.h:201
#: include/media/videobuf2-core.h:217
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:33
msgid "``VB2_MEMORY_UNKNOWN``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:34
msgid "Buffer status is unknown or it is not used yet on userspace."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:37
msgid "``VB2_MEMORY_MMAP``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:38
msgid ""
"The buffers are allocated by the Kernel and it is memory mapped via mmap() "
"ioctl. This model is also used when the user is using the buffers via read() "
"or write() system calls."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:43
msgid "``VB2_MEMORY_USERPTR``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:44
msgid ""
"The buffers was allocated in userspace and it is memory mapped via mmap() "
"ioctl."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:47
msgid "``VB2_MEMORY_DMABUF``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:48
msgid "The buffers are passed to userspace via DMA buffer."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:52
msgid "memory handling/memory allocator operations."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:33
#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:26
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:56 include/media/videobuf2-core.h:157
#: include/media/videobuf2-core.h:243 include/media/videobuf2-core.h:332
#: include/media/videobuf2-core.h:463 include/media/videobuf2-core.h:488
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:46
#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:34
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:76 include/media/videobuf2-core.h:175
#: include/media/videobuf2-core.h:256 include/media/videobuf2-core.h:351
#: include/media/videobuf2-core.h:473 include/media/videobuf2-core.h:521
msgid "**Members**"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:53
msgid "``alloc``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:54
msgid ""
"allocate video memory and, optionally, allocator private data, return "
"ERR_PTR() on failure or a pointer to allocator private, per-buffer data on "
"success; the returned private structure will then be passed as **buf_priv** "
"argument to other ops in this structure. The size argument to this function "
"shall be *page aligned*."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:25
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:59
msgid "``put``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:60
msgid ""
"inform the allocator that the buffer will no longer be used; usually will "
"result in the allocator freeing the buffer (if no other users of this buffer "
"are present); the **buf_priv** argument is the allocator private per-buffer "
"structure previously returned from the alloc callback."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:64
msgid "``get_dmabuf``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:65
msgid ""
"acquire userspace memory for a hardware operation; used for DMABUF memory "
"types."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:66
msgid "``get_userptr``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:67
msgid ""
"acquire userspace memory for a hardware operation; used for USERPTR memory "
"types; vaddr is the address passed to the videobuf2 layer when queuing a "
"video buffer of USERPTR type; should return an allocator private per-buffer "
"structure associated with the buffer on success, ERR_PTR() on failure; the "
"returned private structure will then be passed as **buf_priv** argument to "
"other ops in this structure."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:73
msgid "``put_userptr``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:74
msgid "inform the allocator that a USERPTR buffer will no longer be used."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:75
msgid "``prepare``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:76
msgid ""
"called every time the buffer is passed from userspace to the driver, useful "
"for cache synchronisation, optional."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:77
msgid "``finish``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:78
msgid ""
"called every time the buffer is passed back from the driver to the "
"userspace, also optional."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:79
msgid "``attach_dmabuf``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:80
msgid ""
"attach a shared :c:type:`struct dma_buf <dma_buf>` for a hardware operation; "
"used for DMABUF memory types; dev is the alloc device dbuf is the shared "
"dma_buf; returns ERR_PTR() on failure; allocator private per-buffer "
"structure on success; this needs to be used for further accesses to the "
"buffer."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:84
msgid "``detach_dmabuf``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:85
msgid ""
"inform the exporter of the buffer that the current DMABUF buffer is no "
"longer used; the **buf_priv** argument is the allocator private per-buffer "
"structure previously returned from the attach_dmabuf callback."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:88
msgid "``map_dmabuf``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:89
msgid ""
"request for access to the dmabuf from allocator; the allocator of dmabuf is "
"informed that this driver is going to use the dmabuf."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:91
msgid "``unmap_dmabuf``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:92
msgid ""
"releases access control to the dmabuf - allocator is notified that this "
"driver is done using the dmabuf for now."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:93
msgid "``vaddr``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:94
msgid ""
"return a kernel virtual address to a given memory buffer associated with the "
"passed private structure or NULL if no such mapping exists."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:96
msgid "``cookie``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:97
msgid ""
"return allocator specific cookie for a given memory buffer associated with "
"the passed private structure or NULL if not available."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:99
msgid "``num_users``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:100
msgid ""
"return the current number of users of a memory buffer; return 1 if the "
"videobuf2 layer (or actually the driver using it) is the only user."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:102
msgid "``mmap``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:103
msgid ""
"setup a userspace mapping for a given memory buffer under the provided "
"virtual memory region."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:43 include/media/videobuf2-v4l2.h:71
#: include/media/videobuf2-v4l2.h:105 include/media/videobuf2-v4l2.h:129
#: include/media/videobuf2-v4l2.h:154 include/media/videobuf2-v4l2.h:168
#: include/media/videobuf2-v4l2.h:191 include/media/videobuf2-v4l2.h:208
#: include/media/videobuf2-v4l2.h:226 include/media/videobuf2-v4l2.h:240
#: include/media/videobuf2-v4l2.h:252 include/media/videobuf2-v4l2.h:263
#: include/media/videobuf2-v4l2.h:280 include/media/videobuf2-v4l2.h:309
#: include/media/videobuf2-v4l2.h:360 include/media/videobuf2-v4l2.h:375
#: include/media/videobuf2-v4l2.h:384
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:107 include/media/videobuf2-core.h:179
#: include/media/videobuf2-core.h:436 include/media/videobuf2-core.h:709
#: include/media/videobuf2-core.h:720 include/media/videobuf2-core.h:737
#: include/media/videobuf2-core.h:754 include/media/videobuf2-core.h:768
#: include/media/videobuf2-core.h:782 include/media/videobuf2-core.h:801
#: include/media/videobuf2-core.h:836 include/media/videobuf2-core.h:862
#: include/media/videobuf2-core.h:895 include/media/videobuf2-core.h:925
#: include/media/videobuf2-core.h:948 include/media/videobuf2-core.h:962
#: include/media/videobuf2-core.h:983 include/media/videobuf2-core.h:997
#: include/media/videobuf2-core.h:1012 include/media/videobuf2-core.h:1022
#: include/media/videobuf2-core.h:1039 include/media/videobuf2-core.h:1066
#: include/media/videobuf2-core.h:1088 include/media/videobuf2-core.h:1128
#: include/media/videobuf2-core.h:1139 include/media/videobuf2-core.h:1170
#: include/media/videobuf2-core.h:1200 include/media/videobuf2-core.h:1288
msgid "**Description**"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:104
msgid ""
"Those operations are used by the videobuf2 core to implement the memory "
"handling/memory allocators for each type of supported streaming I/O method."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:108
msgid "Required ops for USERPTR types: get_userptr, put_userptr."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:110
msgid "Required ops for MMAP types: alloc, put, num_users, mmap."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:112
msgid "Required ops for read/write access types: alloc, put, num_users, vaddr."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:114
msgid ""
"Required ops for DMABUF types: attach_dmabuf, detach_dmabuf, map_dmabuf, "
"unmap_dmabuf."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:153
msgid "plane information."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:154
msgid "``mem_priv``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:155
msgid "private data with this plane."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:155
msgid "``dbuf``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:156
msgid "dma_buf - shared buffer object."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:156
msgid "``dbuf_mapped``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:157
msgid "flag to show whether dbuf is mapped or not"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:157
msgid "``dbuf_duplicated``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:158
msgid ""
"boolean to show whether dbuf is duplicated with a previous plane of the "
"buffer."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:159
msgid "``bytesused``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:160
msgid "number of bytes occupied by data in the plane (payload)."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:160
msgid "``length``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:161
msgid ""
"size of this plane (NOT the payload) in bytes. The maximum valid size is "
"MAX_UINT - PAGE_SIZE."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:162
msgid "``min_length``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:163
msgid ""
"minimum required size of this plane (NOT the payload) in bytes. **length** "
"is always greater or equal to **min_length**, and like **length**, it is "
"limited to MAX_UINT - PAGE_SIZE."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:165
msgid "``m``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:166
msgid "Union with memtype-specific data."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:166
msgid "``m.offset``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:167
msgid ""
"when memory in the associated struct vb2_buffer is ``VB2_MEMORY_MMAP``, "
"equals the offset from the start of the device memory for this plane (or is "
"a \"cookie\" that should be passed to mmap() called on the video node)."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:170
msgid "``m.userptr``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:171
msgid ""
"when memory is ``VB2_MEMORY_USERPTR``, a userspace pointer pointing to this "
"plane."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:172
msgid "``m.fd``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:173
msgid ""
"when memory is ``VB2_MEMORY_DMABUF``, a userspace file descriptor associated "
"with this plane."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:174
msgid "``data_offset``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:175
msgid ""
"offset in the plane to the start of data; usually 0, unless there is a "
"header in front of the data."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:176
msgid ""
"Should contain enough information to be able to cover all the fields of :c:"
"type:`struct v4l2_plane <v4l2_plane>` at videodev2.h."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:197
msgid "queue access methods."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:203
msgid "``VB2_MMAP``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:204
msgid "driver supports MMAP with streaming API."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:206
msgid "``VB2_USERPTR``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:207
msgid "driver supports USERPTR with streaming API."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:209
msgid "``VB2_READ``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:210
msgid "driver supports read() style access."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:212
msgid "``VB2_WRITE``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:213
msgid "driver supports write() style access."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:215
msgid "``VB2_DMABUF``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:216
msgid "driver supports DMABUF with streaming API."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:213
msgid "current video buffer state."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:219
msgid "``VB2_BUF_STATE_DEQUEUED``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:220
msgid "buffer under userspace control."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:222
msgid "``VB2_BUF_STATE_IN_REQUEST``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:223
msgid "buffer is queued in media request."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:225
msgid "``VB2_BUF_STATE_PREPARING``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:226
msgid "buffer is being prepared in videobuf2."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:228
msgid "``VB2_BUF_STATE_QUEUED``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:229
msgid "buffer queued in videobuf2, but not in driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:231
msgid "``VB2_BUF_STATE_ACTIVE``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:232
msgid "buffer queued in driver and possibly used in a hardware operation."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:235
msgid "``VB2_BUF_STATE_DONE``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:236
msgid ""
"buffer returned from driver to videobuf2, but not yet dequeued to userspace."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:239
msgid "``VB2_BUF_STATE_ERROR``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:240
msgid ""
"same as above, but the operation on the buffer has ended with an error, "
"which will be reported to the userspace when it is dequeued."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:239
msgid "represents a video buffer."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:240
msgid "``vb2_queue``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:241
msgid ""
"pointer to :c:type:`struct vb2_queue <vb2_queue>` with the queue to which "
"this driver belongs."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:242
msgid "``index``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:243
msgid "id number of the buffer."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:243 include/media/videobuf2-core.h:486
msgid "``type``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:244 include/media/videobuf2-core.h:975
msgid "buffer type."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:244
msgid "``memory``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:245
msgid "the method, in which the actual data is passed."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:245
msgid "``num_planes``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:246
msgid "number of planes in the buffer on an internal driver queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:247
msgid "``timestamp``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:248
msgid "frame timestamp in ns."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:248
msgid "``request``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:249
msgid "the request this buffer is associated with."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:249
msgid "``req_obj``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:250
msgid ""
"used to bind this buffer to a request. This request object has a refcount."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:328 include/media/videobuf2-core.h:459
msgid "driver-specific callbacks."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:333
msgid "``queue_setup``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:334
msgid ""
"called from VIDIOC_REQBUFS() and VIDIOC_CREATE_BUFS() handlers before memory "
"allocation. It can be called twice: if the original number of requested "
"buffers could not be allocated, then it will be called a second time with "
"the actually allocated number of buffers to verify if that is OK. The driver "
"should return the required number of buffers in \\*num_buffers, the required "
"number of planes per buffer in \\*num_planes, the size of each plane should "
"be set in the sizes\\[\\] array and optional per-plane allocator specific "
"device in the alloc_devs\\[\\] array. When called from VIDIOC_REQBUFS(), "
"\\*num_planes == 0, the driver has to use the currently configured format to "
"determine the plane sizes and \\*num_buffers is the total number of buffers "
"that are being allocated. When called from VIDIOC_CREATE_BUFS(), "
"\\*num_planes != 0 and it describes the requested number of planes and "
"sizes\\[\\] contains the requested plane sizes. In this case \\*num_buffers "
"are being allocated additionally to the buffers already allocated. If either "
"\\*num_planes or the requested sizes are invalid callback must return ``-"
"EINVAL``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:354
msgid "``wait_prepare``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:355
msgid ""
"release any locks taken while calling vb2 functions; it is called before an "
"ioctl needs to wait for a new buffer to arrive; required to avoid a deadlock "
"in blocking access type."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:358
msgid "``wait_finish``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:359
msgid ""
"reacquire all locks released in the previous callback; required to continue "
"operation after sleeping while waiting for a new buffer to arrive."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:361
msgid "``buf_out_validate``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:362
msgid ""
"called when the output buffer is prepared or queued to a request; drivers "
"can use this to validate userspace-provided information; this is required "
"only for OUTPUT queues."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:365
msgid "``buf_init``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:366
msgid ""
"called once after allocating a buffer (in MMAP case) or after acquiring a "
"new USERPTR buffer; drivers may perform additional buffer-related "
"initialization; initialization failure (return != 0) will prevent queue "
"setup from completing successfully; optional."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:370
msgid "``buf_prepare``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:371
msgid ""
"called every time the buffer is queued from userspace and from the "
"VIDIOC_PREPARE_BUF() ioctl; drivers may perform any initialization required "
"before each hardware operation in this callback; drivers can access/modify "
"the buffer here as it is still synced for the CPU; drivers that support "
"VIDIOC_CREATE_BUFS() must also validate the buffer size; if an error is "
"returned, the buffer will not be queued in driver; optional."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:378
msgid "``buf_finish``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:379
msgid ""
"called before every dequeue of the buffer back to userspace; the buffer is "
"synced for the CPU, so drivers can access/modify the buffer contents; "
"drivers may perform any operations required before userspace accesses the "
"buffer; optional. The buffer state can be one of the following: ``DONE`` and "
"``ERROR`` occur while streaming is in progress, and the ``PREPARED`` state "
"occurs when the queue has been canceled and all pending buffers are being "
"returned to their default ``DEQUEUED`` state. Typically you only have to do "
"something if the state is ``VB2_BUF_STATE_DONE``, since in all other cases "
"the buffer contents will be ignored anyway."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:390
msgid "``buf_cleanup``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:391
msgid ""
"called once before the buffer is freed; drivers may perform any additional "
"cleanup; optional."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:392
msgid "``prepare_streaming``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:393
msgid ""
"called once to prepare for 'streaming' state; this is where validation can "
"be done to verify everything is okay and streaming resources can be claimed. "
"It is called when the VIDIOC_STREAMON ioctl is called. The actual streaming "
"starts when **start_streaming** is called. Optional."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:398
msgid "``start_streaming``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:399
msgid ""
"called once to enter 'streaming' state; the driver may receive buffers with "
"**buf_queue** callback before **start_streaming** is called; the driver gets "
"the number of already queued buffers in count parameter; driver can return "
"an error if hardware fails, in that case all buffers that have been already "
"given by the **buf_queue** callback are to be returned by the driver by "
"calling vb2_buffer_done() with ``VB2_BUF_STATE_QUEUED``. If you need a "
"minimum number of buffers before you can start streaming, then set :c:type:"
"`vb2_queue->min_queued_buffers <vb2_queue>`. If that is non-zero then "
"**start_streaming** won't be called until at least that many buffers have "
"been queued up by userspace."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:411
msgid "``stop_streaming``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:412
msgid ""
"called when 'streaming' state must be disabled; driver should stop any DMA "
"transactions or wait until they finish and give back all buffers it got "
"from :c:type:`buf_queue` callback by calling vb2_buffer_done() with either "
"``VB2_BUF_STATE_DONE`` or ``VB2_BUF_STATE_ERROR``; may use "
"vb2_wait_for_all_buffers() function"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:417
msgid "``unprepare_streaming``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:418
msgid ""
"called as counterpart to **prepare_streaming**; any claimed streaming "
"resources can be released here. It is called when the VIDIOC_STREAMOFF "
"ioctls is called or when the streaming filehandle is closed. Optional."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:421
msgid "``buf_queue``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:422
msgid ""
"passes buffer vb to the driver; driver may start hardware operation on this "
"buffer; driver should give the buffer back by calling vb2_buffer_done() "
"function; it is always called after calling VIDIOC_STREAMON() ioctl; might "
"be called before **start_streaming** callback if user pre-queued buffers "
"before calling VIDIOC_STREAMON()."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:428
msgid "``buf_request_complete``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:429
msgid ""
"a buffer that was never queued to the driver but is associated with a queued "
"request was canceled. The driver will have to mark associated objects in the "
"request as completed; required if requests are supported."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:329
msgid ""
"These operations are not called from interrupt context except where "
"mentioned specifically."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:461
msgid "``verify_planes_array``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:462
msgid ""
"Verify that a given user space structure contains enough planes for the "
"buffer. This is called for each dequeued buffer."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:464
msgid "``init_buffer``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:465
msgid ""
"given a :c:type:`vb2_buffer` initialize the extra data after struct "
"vb2_buffer. For V4L2 this is a :c:type:`struct vb2_v4l2_buffer "
"<vb2_v4l2_buffer>`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:467
msgid "``fill_user_buffer``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:468
msgid ""
"given a :c:type:`vb2_buffer` fill in the userspace structure. For V4L2 this "
"is a :c:type:`struct v4l2_buffer <v4l2_buffer>`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:469
msgid "``fill_vb2_buffer``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:470
msgid ""
"given a userspace structure, fill in the :c:type:`vb2_buffer`. If the "
"userspace structure is invalid, then this op will return an error."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:472
msgid "``copy_timestamp``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:473
msgid ""
"copy the timestamp from a userspace structure to the :c:type:`struct "
"vb2_buffer <vb2_buffer>`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:484
msgid "a videobuf2 queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:487
msgid ""
"private buffer type whose content is defined by the vb2-core caller. For "
"example, for V4L2, it should match the types defined on :c:type:`enum "
"v4l2_buf_type <v4l2_buf_type>`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:489
msgid "``io_modes``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:490
msgid "supported io methods (see :c:type:`enum vb2_io_modes <vb2_io_modes>`)."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:490
msgid "``dev``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:491
msgid ""
"device to use for the default allocation context if the driver doesn't fill "
"in the **alloc_devs** array."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:492
msgid "``dma_attrs``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:493
msgid "DMA attributes to use for the DMA."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:493
msgid "``bidirectional``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:494
msgid ""
"when this flag is set the DMA direction for the buffers of this queue will "
"be overridden with ``DMA_BIDIRECTIONAL`` direction. This is useful in cases "
"where the hardware (firmware) writes to a buffer which is mapped as read "
"(``DMA_TO_DEVICE``), or reads from buffer which is mapped for write "
"(``DMA_FROM_DEVICE``) in order to satisfy some internal hardware "
"restrictions or adds a padding needed by the processing algorithm. In case "
"the DMA mapping is not bidirectional but the hardware (firmware) trying to "
"access the buffer (in the opposite direction) this could lead to an IOMMU "
"protection faults."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:503
msgid "``fileio_read_once``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:504
msgid "report EOF after reading the first buffer"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:504
msgid "``fileio_write_immediately``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:505
msgid "queue buffer after each write() call"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:505
msgid "``allow_zero_bytesused``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:506
msgid "allow bytesused == 0 to be passed to the driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:506
msgid "``quirk_poll_must_check_waiting_for_buffers``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:507
msgid ""
"Return ``EPOLLERR`` at poll when QBUF has not been called. This is a vb1 "
"idiom that has been adopted also by vb2."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:509
msgid "``supports_requests``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:510
msgid "this queue supports the Request API."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:510
msgid "``requires_requests``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:511
msgid ""
"this queue requires the Request API. If this is set to 1, then "
"supports_requests must be set to 1 as well."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:512
msgid "``uses_qbuf``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:513
msgid ""
"qbuf was used directly for this queue. Set to 1 the first time this is "
"called. Set to 0 when the queue is canceled. If this is 1, then you cannot "
"queue buffers from a request."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:515
msgid "``uses_requests``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:516
msgid ""
"requests are used for this queue. Set to 1 the first time a request is "
"queued. Set to 0 when the queue is canceled. If this is 1, then you cannot "
"queue buffers directly."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:518
msgid "``allow_cache_hints``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:519
msgid ""
"when set user-space can pass cache management hints in order to skip cache "
"flush/invalidation on ->prepare() or/and ->finish()."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:521
msgid "``non_coherent_mem``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:522
msgid ""
"when set queue will attempt to allocate buffers using non-coherent memory."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:523
msgid "``lock``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:524
msgid ""
"pointer to a mutex that protects the :c:type:`struct vb2_queue <vb2_queue>`. "
"The driver can set this to a mutex to let the v4l2 core serialize the "
"queuing ioctls. If the driver wants to handle locking itself, then this "
"should be set to NULL. This lock is not used by the videobuf2 core API."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:528
msgid "``owner``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:529
msgid ""
"The filehandle that 'owns' the buffers, i.e. the filehandle that called "
"reqbufs, create_buffers or started fileio. This field is not used by the "
"videobuf2 core API, but it allows drivers to easily associate an owner "
"filehandle with the queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:532
msgid "``ops``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:533
msgid "driver-specific callbacks"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:533
msgid "``mem_ops``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:534
msgid "memory allocator specific callbacks"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:534
msgid "``buf_ops``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:535
msgid ""
"callbacks to deliver buffer information. between user-space and kernel-space."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:536
msgid "``drv_priv``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:537
msgid "driver private data."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:537
msgid "``subsystem_flags``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:538
msgid ""
"Flags specific to the subsystem (V4L2/DVB/etc.). Not used by the vb2 core."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:539
msgid "``buf_struct_size``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:540
msgid ""
"size of the driver-specific buffer structure; \"0\" indicates the driver "
"doesn't want to use a custom buffer structure type. In that case a subsystem-"
"specific struct will be used (in the case of V4L2 that is ``sizeof(struct "
"vb2_v4l2_buffer)``). The first field of the driver-specific buffer structure "
"must be the subsystem-specific struct (vb2_v4l2_buffer in the case of V4L2)."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:546
msgid "``timestamp_flags``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:547
msgid ""
"Timestamp flags; ``V4L2_BUF_FLAG_TIMESTAMP_*`` and "
"``V4L2_BUF_FLAG_TSTAMP_SRC_*``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:548
msgid "``gfp_flags``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:549
msgid ""
"additional gfp flags used when allocating the buffers. Typically this is 0, "
"but it may be e.g. ``GFP_DMA`` or ``__GFP_DMA32`` to force the buffer "
"allocation to a specific memory zone."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:551
msgid "``min_queued_buffers``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:552
msgid ""
"the minimum number of queued buffers needed before **start_streaming** can "
"be called. Used when a DMA engine cannot be started unless at least this "
"number of buffers have been queued into the driver. VIDIOC_REQBUFS will "
"ensure at least **min_queued_buffers** + 1 buffers will be allocated. Note "
"that VIDIOC_CREATE_BUFS will not modify the requested buffer count."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:558
msgid "``min_reqbufs_allocation``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:559
msgid ""
"the minimum number of buffers to be allocated when calling VIDIOC_REQBUFS. "
"Note that VIDIOC_CREATE_BUFS will *not* modify the requested buffer count "
"and does not use this field. Drivers can set this if there has to be a "
"certain number of buffers available for the hardware to work effectively. "
"This allows calling VIDIOC_REQBUFS with a buffer count of 1 and it will be "
"automatically adjusted to a workable buffer count. If set, then "
"**min_reqbufs_allocation** must be larger than **min_queued_buffers** + 1. "
"If this field is > 3, then it is highly recommended that the driver "
"implements the V4L2_CID_MIN_BUFFERS_FOR_CAPTURE/OUTPUT control."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:570
msgid "``alloc_devs``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:571
msgid ""
":c:type:`struct device <device>` memory type/allocator-specific per-plane "
"device"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:693
msgid "Return true if the queue allows cache and memory consistency hints."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:70 include/media/videobuf2-v4l2.h:82
#: include/media/videobuf2-v4l2.h:92 include/media/videobuf2-v4l2.h:102
#: include/media/videobuf2-v4l2.h:127 include/media/videobuf2-v4l2.h:153
#: include/media/videobuf2-v4l2.h:164 include/media/videobuf2-v4l2.h:190
#: include/media/videobuf2-v4l2.h:208 include/media/videobuf2-v4l2.h:227
#: include/media/videobuf2-v4l2.h:240 include/media/videobuf2-v4l2.h:253
#: include/media/videobuf2-v4l2.h:263 include/media/videobuf2-v4l2.h:279
#: include/media/videobuf2-v4l2.h:309 include/media/videobuf2-v4l2.h:360
#: include/media/videobuf2-v4l2.h:375 include/media/videobuf2-v4l2.h:384
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:697 include/media/videobuf2-core.h:708
#: include/media/videobuf2-core.h:719 include/media/videobuf2-core.h:733
#: include/media/videobuf2-core.h:755 include/media/videobuf2-core.h:769
#: include/media/videobuf2-core.h:781 include/media/videobuf2-core.h:798
#: include/media/videobuf2-core.h:830 include/media/videobuf2-core.h:859
#: include/media/videobuf2-core.h:881 include/media/videobuf2-core.h:891
#: include/media/videobuf2-core.h:920 include/media/videobuf2-core.h:946
#: include/media/videobuf2-core.h:960 include/media/videobuf2-core.h:975
#: include/media/videobuf2-core.h:997 include/media/videobuf2-core.h:1013
#: include/media/videobuf2-core.h:1023 include/media/videobuf2-core.h:1038
#: include/media/videobuf2-core.h:1063 include/media/videobuf2-core.h:1085
#: include/media/videobuf2-core.h:1106 include/media/videobuf2-core.h:1116
#: include/media/videobuf2-core.h:1134 include/media/videobuf2-core.h:1137
#: include/media/videobuf2-core.h:1156 include/media/videobuf2-core.h:1162
#: include/media/videobuf2-core.h:1171 include/media/videobuf2-core.h:1189
#: include/media/videobuf2-core.h:1201 include/media/videobuf2-core.h:1212
#: include/media/videobuf2-core.h:1221 include/media/videobuf2-core.h:1242
#: include/media/videobuf2-core.h:1256 include/media/videobuf2-core.h:1270
#: include/media/videobuf2-core.h:1279 include/media/videobuf2-core.h:1288
#: include/media/videobuf2-core.h:1317 include/media/videobuf2-core.h:1326
#: include/media/videobuf2-core.h:1339 include/media/videobuf2-core.h:1346
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:72 include/media/videobuf2-v4l2.h:84
#: include/media/videobuf2-v4l2.h:94 include/media/videobuf2-v4l2.h:104
#: include/media/videobuf2-v4l2.h:129 include/media/videobuf2-v4l2.h:155
#: include/media/videobuf2-v4l2.h:166 include/media/videobuf2-v4l2.h:192
#: include/media/videobuf2-v4l2.h:210 include/media/videobuf2-v4l2.h:229
#: include/media/videobuf2-v4l2.h:242 include/media/videobuf2-v4l2.h:255
#: include/media/videobuf2-v4l2.h:265 include/media/videobuf2-v4l2.h:281
#: include/media/videobuf2-v4l2.h:311
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:699 include/media/videobuf2-core.h:757
#: include/media/videobuf2-core.h:771 include/media/videobuf2-core.h:783
#: include/media/videobuf2-core.h:800 include/media/videobuf2-core.h:832
#: include/media/videobuf2-core.h:861 include/media/videobuf2-core.h:883
#: include/media/videobuf2-core.h:893 include/media/videobuf2-core.h:922
#: include/media/videobuf2-core.h:948 include/media/videobuf2-core.h:962
#: include/media/videobuf2-core.h:977 include/media/videobuf2-core.h:999
#: include/media/videobuf2-core.h:1015 include/media/videobuf2-core.h:1025
#: include/media/videobuf2-core.h:1040 include/media/videobuf2-core.h:1065
#: include/media/videobuf2-core.h:1087 include/media/videobuf2-core.h:1108
#: include/media/videobuf2-core.h:1118 include/media/videobuf2-core.h:1139
#: include/media/videobuf2-core.h:1158 include/media/videobuf2-core.h:1164
#: include/media/videobuf2-core.h:1173 include/media/videobuf2-core.h:1191
#: include/media/videobuf2-core.h:1203 include/media/videobuf2-core.h:1214
#: include/media/videobuf2-core.h:1272 include/media/videobuf2-core.h:1281
#: include/media/videobuf2-core.h:1290 include/media/videobuf2-core.h:1319
#: include/media/videobuf2-core.h:1328
msgid "``struct vb2_queue *q``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:696 include/media/videobuf2-core.h:917
#: include/media/videobuf2-core.h:944 include/media/videobuf2-core.h:958
msgid "pointer to :c:type:`struct vb2_queue <vb2_queue>` with videobuf2 queue"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:704
msgid "Return a kernel virtual address of a given plane."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:710 include/media/videobuf2-core.h:721
#: include/media/videobuf2-core.h:735 include/media/videobuf2-core.h:780
#: include/media/videobuf2-core.h:859 include/media/videobuf2-core.h:891
#: include/media/videobuf2-core.h:977 include/media/videobuf2-core.h:1136
#: include/media/videobuf2-core.h:1223 include/media/videobuf2-core.h:1244
#: include/media/videobuf2-core.h:1258 include/media/videobuf2-core.h:1319
msgid "``struct vb2_buffer *vb``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:705 include/media/videobuf2-core.h:716
#: include/media/videobuf2-core.h:1218 include/media/videobuf2-core.h:1239
#: include/media/videobuf2-core.h:1253
msgid ""
"pointer to :c:type:`struct vb2_buffer <vb2_buffer>` to which the plane in "
"question belongs to."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:708 include/media/videobuf2-core.h:719
#: include/media/videobuf2-core.h:1221 include/media/videobuf2-core.h:1242
#: include/media/videobuf2-core.h:1256
msgid "``unsigned int plane_no``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:707
msgid "plane number for which the address is to be returned."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:708
msgid ""
"This function returns a kernel virtual address of a given plane if such a "
"mapping exist, NULL otherwise."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:715
msgid "Return allocator specific cookie for the given plane."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:718
msgid "plane number for which the cookie is to be returned."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:719
msgid ""
"This function returns an allocator specific cookie for a given plane if "
"available, NULL otherwise. The allocator should provide some simple static "
"inline function, which would convert this cookie to the allocator specific "
"type that can be used directly by the driver to access the buffer. This can "
"be for example physical address, pointer to scatter list or IOMMU mapping."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:729
msgid "inform videobuf2 that an operation on a buffer is finished."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:731
msgid "pointer to :c:type:`struct vb2_buffer <vb2_buffer>` to be used."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:733
msgid "``enum vb2_buffer_state state``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:732
msgid ""
"state of the buffer, as defined by :c:type:`enum vb2_buffer_state "
"<vb2_buffer_state>`. Either ``VB2_BUF_STATE_DONE`` if the operation finished "
"successfully, ``VB2_BUF_STATE_ERROR`` if the operation finished with an "
"error or ``VB2_BUF_STATE_QUEUED``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:736
msgid ""
"This function should be called by the driver after a hardware operation on a "
"buffer is finished and the buffer may be returned to userspace. The driver "
"cannot use this buffer anymore until it is queued back to it by videobuf by "
"the means of :c:type:`vb2_ops->buf_queue <vb2_ops>` callback. Only buffers "
"previously queued to the driver by :c:type:`vb2_ops->buf_queue <vb2_ops>` "
"can be passed to this function."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:742
msgid ""
"While streaming a buffer can only be returned in state DONE or ERROR. The :c:"
"type:`vb2_ops->start_streaming <vb2_ops>` op can also return them in case "
"the DMA engine cannot be started for some reason. In that case the buffers "
"should be returned with state QUEUED to put them back into the queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:751
msgid "discard all buffers marked as DONE."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:68 include/media/videobuf2-v4l2.h:81
#: include/media/videobuf2-v4l2.h:91 include/media/videobuf2-v4l2.h:100
#: include/media/videobuf2-v4l2.h:124 include/media/videobuf2-v4l2.h:150
#: include/media/videobuf2-v4l2.h:161 include/media/videobuf2-v4l2.h:187
#: include/media/videobuf2-v4l2.h:205 include/media/videobuf2-v4l2.h:224
#: include/media/videobuf2-v4l2.h:237 include/media/videobuf2-v4l2.h:250
#: include/media/videobuf2-v4l2.h:260 include/media/videobuf2-v4l2.h:276
#: include/media/videobuf2-v4l2.h:306
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:752 include/media/videobuf2-core.h:766
#: include/media/videobuf2-core.h:778 include/media/videobuf2-core.h:795
#: include/media/videobuf2-core.h:827 include/media/videobuf2-core.h:857
#: include/media/videobuf2-core.h:878 include/media/videobuf2-core.h:889
#: include/media/videobuf2-core.h:972 include/media/videobuf2-core.h:1010
#: include/media/videobuf2-core.h:1020 include/media/videobuf2-core.h:1035
#: include/media/videobuf2-core.h:1060 include/media/videobuf2-core.h:1082
#: include/media/videobuf2-core.h:1103 include/media/videobuf2-core.h:1113
#: include/media/videobuf2-core.h:1134 include/media/videobuf2-core.h:1153
#: include/media/videobuf2-core.h:1159 include/media/videobuf2-core.h:1168
#: include/media/videobuf2-core.h:1186 include/media/videobuf2-core.h:1198
#: include/media/videobuf2-core.h:1209 include/media/videobuf2-core.h:1267
#: include/media/videobuf2-core.h:1276 include/media/videobuf2-core.h:1285
#: include/media/videobuf2-core.h:1317 include/media/videobuf2-core.h:1325
msgid "pointer to :c:type:`struct vb2_queue <vb2_queue>` with videobuf2 queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:753
msgid ""
"This function is intended to be used with suspend/resume operations. It "
"discards all 'done' buffers as they would be too old to be requested after "
"resume."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:757
msgid ""
"Drivers must stop the hardware and synchronize with interrupt handlers and/"
"or delayed works before calling this function to make sure no buffer will be "
"touched by the driver and/or hardware."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:765
msgid "wait until all buffers are given back to vb2."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:767
msgid ""
"This function will wait until all buffers that have been given to the driver "
"by :c:type:`vb2_ops->buf_queue <vb2_ops>` are given back to vb2 with "
"vb2_buffer_done(). It doesn't call :c:type:`vb2_ops->wait_prepare "
"<vb2_ops>`/:c:type:`vb2_ops->wait_finish <vb2_ops>` pair. It is intended to "
"be called with all locks taken, for example from :c:type:`vb2_ops-"
">stop_streaming <vb2_ops>` callback."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:777
msgid "query video buffer information."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:779 include/media/videobuf2-core.h:858
#: include/media/videobuf2-core.h:890 include/media/videobuf2-core.h:976
#: include/media/videobuf2-core.h:1125
msgid "pointer to struct :c:type:`vb2_buffer`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:781 include/media/videobuf2-core.h:860
#: include/media/videobuf2-core.h:892 include/media/videobuf2-core.h:920
msgid "``void *pb``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:780
msgid "buffer struct passed from userspace."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:781
msgid ""
"Videobuf2 core helper to implement VIDIOC_QUERYBUF() operation. It is called "
"internally by VB2 by an API-specific handler, like ``videobuf2-v4l2.h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:784 include/media/videobuf2-core.h:865
msgid "The passed buffer should have been verified."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:786
msgid "This function fills the relevant information for the userspace."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:788 include/media/videobuf2-core.h:819
#: include/media/videobuf2-core.h:845 include/media/videobuf2-core.h:871
#: include/media/videobuf2-core.h:882 include/media/videobuf2-core.h:909
#: include/media/videobuf2-core.h:935 include/media/videobuf2-core.h:950
#: include/media/videobuf2-core.h:965 include/media/videobuf2-core.h:985
msgid "**Return**"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:789 include/media/videobuf2-core.h:820
#: include/media/videobuf2-core.h:846 include/media/videobuf2-core.h:872
#: include/media/videobuf2-core.h:882 include/media/videobuf2-core.h:910
#: include/media/videobuf2-core.h:936 include/media/videobuf2-core.h:951
#: include/media/videobuf2-core.h:966 include/media/videobuf2-core.h:987
msgid "returns zero on success; an error code otherwise."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:794
msgid "Initiate streaming."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:797 include/media/videobuf2-core.h:829
#: include/media/videobuf2-core.h:1327
msgid "``enum vb2_memory memory``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:796 include/media/videobuf2-core.h:828
msgid "memory type, as defined by :c:type:`enum vb2_memory <vb2_memory>`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:798 include/media/videobuf2-core.h:830
#: include/media/videobuf2-core.h:979
msgid "``unsigned int flags``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:797
msgid ""
"auxiliary queue/buffer management flags. Currently, the only used flag is "
"``V4L2_MEMORY_FLAG_NON_COHERENT``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:800 include/media/videobuf2-core.h:831
msgid "``unsigned int *count``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:799 include/media/videobuf2-core.h:830
msgid "requested buffer count."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:800
msgid ""
"Videobuf2 core helper to implement VIDIOC_REQBUF() operation. It is called "
"internally by VB2 by an API-specific handler, like ``videobuf2-v4l2.h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:107 include/media/videobuf2-v4l2.h:130
#: include/media/videobuf2-v4l2.h:170 include/media/videobuf2-v4l2.h:192
#: include/media/videobuf2-v4l2.h:209
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:803 include/media/videobuf2-core.h:839
#: include/media/videobuf2-core.h:897 include/media/videobuf2-core.h:927
msgid "This function:"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:805
msgid "verifies streaming parameters passed from the userspace;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:806
msgid "sets up the queue;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:807
msgid ""
"negotiates number of buffers and planes per buffer with the driver to be "
"used during streaming;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:809
msgid ""
"allocates internal buffer structures (:c:type:`struct vb2_buffer "
"<vb2_buffer>`), according to the agreed parameters;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:811
msgid ""
"for MMAP memory type, allocates actual video memory, using the memory "
"handling/allocation routines provided during queue initialization."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:814
msgid "If req->count is 0, all the memory will be freed instead."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:816
msgid ""
"If the queue has been allocated previously by a previous vb2_core_reqbufs() "
"call and the queue is not busy, memory will be reallocated."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:826
msgid "Allocate buffers and any required auxiliary structs"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:829
msgid "auxiliary queue/buffer management flags."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:832
msgid "``unsigned int requested_planes``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:831
msgid "number of planes requested."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:833
msgid "``const unsigned int requested_sizes[]``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:832
msgid "array with the size of the planes."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:834
msgid "``unsigned int *first_index``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:833
msgid ""
"index of the first created buffer, all allocated buffers have indices in the "
"range [first_index..first_index+count-1]"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:835
msgid ""
"Videobuf2 core helper to implement VIDIOC_CREATE_BUFS() operation. It is "
"called internally by VB2 by an API-specific handler, like ``videobuf2-v4l2."
"h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:841
msgid "verifies parameter sanity;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:842
msgid "calls the :c:type:`vb2_ops->queue_setup <vb2_ops>` queue operation;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:843
msgid "performs any necessary memory allocations."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:855
msgid "Pass ownership of a buffer from userspace to the kernel."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:859
msgid ""
"buffer structure passed from userspace to :c:type:`v4l2_ioctl_ops-"
">vidioc_prepare_buf <v4l2_ioctl_ops>` handler in driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:861
msgid ""
"Videobuf2 core helper to implement VIDIOC_PREPARE_BUF() operation. It is "
"called internally by VB2 by an API-specific handler, like ``videobuf2-v4l2."
"h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:867
msgid ""
"This function calls vb2_ops->buf_prepare callback in the driver (if "
"provided), in which driver-specific buffer initialization can be performed."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:880
msgid "``unsigned int start``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:879
msgid "first index of the range of buffers to remove."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:881
msgid "``unsigned int count``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:880
msgid "number of buffers to remove."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:123
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:887
msgid "Queue a buffer from userspace"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:891
msgid ""
"buffer structure passed from userspace to v4l2_ioctl_ops->vidioc_qbuf "
"handler in driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:894 include/media/videobuf2-core.h:1348
msgid "``struct media_request *req``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:893
msgid "pointer to :c:type:`struct media_request <media_request>`, may be NULL."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:894
msgid ""
"Videobuf2 core helper to implement VIDIOC_QBUF() operation. It is called "
"internally by VB2 by an API-specific handler, like ``videobuf2-v4l2.h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:899
msgid ""
"If **req** is non-NULL, then the buffer will be bound to this media request "
"and it returns. The buffer will be prepared and queued to the driver (i.e. "
"the next two steps) when the request itself is queued."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:135
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:903
msgid ""
"if necessary, calls :c:type:`vb2_ops->buf_prepare <vb2_ops>` callback in the "
"driver (if provided), in which driver-specific buffer initialization can be "
"performed;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:138
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:906
msgid ""
"if streaming is on, queues the buffer in driver by the means of :c:type:"
"`vb2_ops->buf_queue <vb2_ops>` callback for processing."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:160
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:916
msgid "Dequeue a buffer to the userspace"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:919
msgid "``unsigned int *pindex``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:918
msgid "pointer to the buffer index. May be NULL"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:919
msgid ""
"buffer structure passed from userspace to v4l2_ioctl_ops->vidioc_dqbuf "
"handler in driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:165
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:922
msgid "``bool nonblocking``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:921
msgid ""
"if true, this call will not sleep waiting for a buffer if no buffers ready "
"for dequeuing are present. Normally the driver would be passing (file-"
">f_flags & O_NONBLOCK) here."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:924
msgid ""
"Videobuf2 core helper to implement VIDIOC_DQBUF() operation. It is called "
"internally by VB2 by an API-specific handler, like ``videobuf2-v4l2.h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:929
msgid ""
"calls buf_finish callback in the driver (if provided), in which driver can "
"perform any additional operations that may be required before returning the "
"buffer to userspace, such as cache sync,"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:176
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:932
msgid ""
"the buffer struct members are filled with relevant information for the "
"userspace."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:942
msgid "Implements VB2 stream ON logic"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:262
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:946 include/media/videobuf2-core.h:960
#: include/media/videobuf2-core.h:976 include/media/videobuf2-core.h:1328
msgid "``unsigned int type``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:945 include/media/videobuf2-core.h:959
msgid ""
"type of the queue to be started. For V4L2, this is defined by :c:type:`enum "
"v4l2_buf_type <v4l2_buf_type>` type."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:947
msgid ""
"Videobuf2 core helper to implement VIDIOC_STREAMON() operation. It is called "
"internally by VB2 by an API-specific handler, like ``videobuf2-v4l2.h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:956
msgid "Implements VB2 stream OFF logic"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:961
msgid ""
"Videobuf2 core helper to implement VIDIOC_STREAMOFF() operation. It is "
"called internally by VB2 by an API-specific handler, like ``videobuf2-v4l2."
"h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:971
msgid "Export a buffer as a file descriptor."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:974
msgid "``int *fd``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:973
msgid "pointer to the file descriptor associated with DMABUF (set by driver)."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:978
msgid "``unsigned int plane``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:977
msgid "index of the plane to be exported, 0 for single plane queues"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:978
msgid ""
"file flags for newly created file, as defined at include/uapi/asm-generic/"
"fcntl.h. Currently, the only used flag is ``O_CLOEXEC``. is supported, refer "
"to manual of open syscall for more details."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:982
msgid ""
"Videobuf2 core helper to implement VIDIOC_EXPBUF() operation. It is called "
"internally by VB2 by an API-specific handler, like ``videobuf2-v4l2.h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:223
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:993
msgid "initialize a videobuf2 queue"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:994
msgid ""
"pointer to :c:type:`struct vb2_queue <vb2_queue>` with videobuf2 queue. This "
"structure should be allocated in driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:996
msgid ""
"The :c:type:`vb2_queue` structure should be allocated by the driver. The "
"driver is responsible of clearing it's content and setting initial values "
"for some required entries before calling this function."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1002
msgid ""
"The following fields at **q** should be set before calling this function: :c:"
"type:`vb2_queue->ops <vb2_queue>`, :c:type:`vb2_queue->mem_ops "
"<vb2_queue>`, :c:type:`vb2_queue->type <vb2_queue>`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:249
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1009
msgid "stop streaming, release the queue and free memory"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1011
msgid ""
"This function stops streaming and performs necessary clean ups, including "
"freeing video buffer memory. The driver is responsible for freeing the :c:"
"type:`struct vb2_queue <vb2_queue>` itself."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1019
msgid "signal a fatal error on the queue"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1021
msgid ""
"Flag that a fatal unrecoverable error has occurred and wake up all processes "
"waiting on the queue. Polling will now set ``EPOLLERR`` and queuing and "
"dequeuing buffers will return ``-EIO``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1025
msgid ""
"The error flag will be cleared when canceling the queue, either from "
"vb2_streamoff() or vb2_queue_release(). Drivers should thus not call this "
"function before starting the stream, otherwise the error flag will remain "
"set until the queue is released when closing the device node."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1034 include/media/videobuf2-core.h:1059
msgid "map video buffers into application address space."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1037
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1036
msgid ""
"pointer to :c:type:`struct vm_area_struct <vm_area_struct>` with the vma "
"passed to the mmap file operation handler in the driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1038
msgid ""
"Should be called from mmap file operation handler of a driver. This function "
"maps one plane of one of the available video buffers to userspace. To map "
"whole video memory allocated on reqbufs, this function has to be called once "
"per each plane per each buffer previously allocated."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1043
msgid ""
"When the userspace application calls mmap, it passes to it an offset "
"returned to it earlier by the means of :c:type:`v4l2_ioctl_ops-"
">vidioc_querybuf <v4l2_ioctl_ops>` handler. That offset acts as a "
"\"cookie\", which is then used to identify the plane to be mapped."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1048
msgid ""
"This function finds a plane with a matching offset and a mapping is "
"performed by the means of a provided memory operation."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1051
msgid ""
"The return values from this function are intended to be directly returned "
"from the mmap handler in driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1062
msgid "``unsigned long addr``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1061
msgid "memory address."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1063
msgid "``unsigned long len``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1062
msgid "buffer size."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1064
msgid "``unsigned long pgoff``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1063
msgid "page offset."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1065
msgid "``unsigned long flags``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1064
msgid "memory flags."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1065
msgid ""
"This function is used in noMMU platforms to propose address mapping for a "
"given buffer. It's intended to be used as a handler for the :c:type:"
"`file_operations->get_unmapped_area <file_operations>` operation."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1069
msgid ""
"This is called by the mmap() syscall routines will call this to get a "
"proposed address for the mapping, when ``!CONFIG_MMU``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1081
msgid "implements poll syscall() logic."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:278 include/media/videobuf2-v4l2.h:308
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1084
msgid "``struct file *file``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1083
msgid ""
":c:type:`struct file <file>` argument passed to the poll file operation "
"handler."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:279
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1086
msgid "``poll_table *wait``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1085
msgid ""
":c:type:`poll_table` wait argument passed to the poll file operation handler."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:279
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1087
msgid ""
"This function implements poll file operation handler for a driver. For "
"CAPTURE queues, if a buffer is ready to be dequeued, the userspace will be "
"informed that the file descriptor of a video device is available for "
"reading. For OUTPUT queues, if a buffer is ready to be dequeued, the file "
"descriptor will be reported as available for writing."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:289
#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1094
msgid ""
"The return values from this function are intended to be directly returned "
"from poll handler in driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1102
msgid "implements read() syscall logic."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1105
msgid "``char __user *data``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1104 include/media/videobuf2-core.h:1114
msgid "pointed to target userspace buffer"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1106 include/media/videobuf2-core.h:1116
msgid "``size_t count``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1105
msgid "number of bytes to read"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1107 include/media/videobuf2-core.h:1117
msgid "``loff_t *ppos``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1106 include/media/videobuf2-core.h:1116
msgid "file handle position tracking pointer"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1108 include/media/videobuf2-core.h:1118
msgid "``int nonblock``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1107 include/media/videobuf2-core.h:1117
msgid "mode selector (1 means blocking calls, 0 means nonblocking)"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1112
msgid "implements write() syscall logic."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1115
msgid "``const char __user *data``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1115
msgid "number of bytes to write"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1125
msgid "**Typedef**: callback function for use with vb2_thread."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1128
msgid "**Syntax**"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1130
msgid "``int vb2_thread_fnc (struct vb2_buffer *vb, void *priv)``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1127 include/media/videobuf2-core.h:1137
msgid "``void *priv``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1126
msgid "pointer to a private data."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1127
msgid "This is called whenever a buffer is dequeued in the thread."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1133
msgid "start a thread for the given queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1136
msgid "``vb2_thread_fnc fnc``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1135
msgid ":c:type:`vb2_thread_fnc` callback function."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1136
msgid "priv pointer passed to the callback function."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1138
msgid "``const char *thread_name``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1137
msgid "the name of the thread. This will be prefixed with \"vb2-\"."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1138
msgid ""
"This starts a thread that will queue and dequeue until an error occurs or "
"vb2_thread_stop() is called."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1143
msgid ""
"This function should not be used for anything else but the videobuf2-dvb "
"support. If you think you have another good use-case for this, then please "
"contact the linux-media mailing list first."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1152
msgid "stop the thread for the given queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1158
msgid "return streaming status of the queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1167
msgid "return true if fileio is active."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1169
msgid ""
"This returns true if read() or write() is used to stream the data as opposed "
"to stream I/O. This is almost never an important distinction, except in rare "
"cases. One such case is that using read() or write() to stream a format "
"using ``V4L2_FIELD_ALTERNATE`` is not allowed since there is no way you can "
"pass the field information of each buffer to/from userspace. A driver that "
"supports this field format should check for this in the :c:type:`vb2_ops-"
">queue_setup <vb2_ops>` op and reject it if this function returns true."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1185
msgid "get the number of buffer in a queue"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1197
msgid "return busy status of the queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1199
msgid "This function checks if queue has any buffers allocated."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1208
msgid "return driver private data associated with the queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1217
msgid "set bytesused for the plane **plane_no**."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1220 include/media/videobuf2-core.h:1241
msgid "plane number for which payload should be set."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1222
msgid "``unsigned long size``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1221
msgid "payload in bytes."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1238
msgid "get bytesused for the plane plane_no"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1252
msgid "return plane size in bytes."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1255
msgid "plane number for which size should be returned."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1266
msgid "return streaming status of driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1275
msgid "clear last buffer dequeued flag of queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1284
msgid "get a buffer from a queue"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1287
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1286
msgid "buffer index"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1287
msgid ""
"This function obtains a buffer from a queue, by its index. Keep in mind that "
"there is no refcounting involved in this operation, so the buffer lifetime "
"should be taken into consideration."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1313
msgid ""
"return true if the buffer is in use and the queue cannot be freed (by the "
"means of VIDIOC_REQBUFS(0)) call."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1316
msgid "buffer for which plane size should be returned."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1322
msgid ""
"Check whether the memory type and buffer type passed to a buffer operation "
"are compatible with the queue."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1326
msgid "memory model, as defined by enum :c:type:`vb2_memory`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1327
msgid ""
"private buffer type whose content is defined by the vb2-core caller. For "
"example, for V4L2, it should match the types defined on enum :c:type:"
"`v4l2_buf_type`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1335
msgid "return true if the object is a buffer"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1341
msgid "``struct media_request_object *obj``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1337
msgid "the request object."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1342
msgid "return the number of buffers in the request"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:8:
#: include/media/videobuf2-core.h:1344
msgid "the request."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:29
msgid "video buffer information for v4l2."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:31
msgid "``vb2_buf``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:32
msgid "embedded struct :c:type:`vb2_buffer`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:32
msgid "``flags``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:33
msgid "buffer informational flags."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:33
msgid "``field``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:34
msgid ""
"field order of the image in the buffer, as defined by :c:type:`enum "
"v4l2_field <v4l2_field>`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:35
msgid "``timecode``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:36
msgid "frame timecode."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:36
msgid "``sequence``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:37
msgid "sequence count of this frame."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:37
msgid "``request_fd``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:38
msgid "the request_fd associated with this buffer"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:38
msgid "``is_held``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:39
msgid "if true, then this capture buffer was held"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:39
msgid "``planes``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:40
msgid "plane information (userptr/fd, length, bytesused, data_offset)."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:40
msgid ""
"Should contain enough information to be able to cover all the fields of :c:"
"type:`struct v4l2_buffer <v4l2_buffer>` at ``videodev2.h``."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:66
msgid "Find a buffer with given timestamp"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:70
msgid "``u64 timestamp``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:69
msgid "the timestamp to find."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:70
msgid "Returns the buffer with the given **timestamp**, or NULL if not found."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:78
msgid ""
"Wrapper for vb2_core_reqbufs() that also verifies the memory and type values."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:83
msgid "``struct v4l2_requestbuffers *req``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:82
msgid ""
":c:type:`struct v4l2_requestbuffers <v4l2_requestbuffers>` passed from "
"userspace to :c:type:`v4l2_ioctl_ops->vidioc_reqbufs <v4l2_ioctl_ops>` "
"handler in driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:88
msgid ""
"Wrapper for vb2_core_create_bufs() that also verifies the memory and type "
"values."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:93
msgid "``struct v4l2_create_buffers *create``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:92
msgid ""
"creation parameters, passed from userspace to :c:type:`v4l2_ioctl_ops-"
">vidioc_create_bufs <v4l2_ioctl_ops>` handler in driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:98
msgid "Pass ownership of a buffer from userspace to the kernel"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:102 include/media/videobuf2-v4l2.h:126
msgid "``struct media_device *mdev``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:101 include/media/videobuf2-v4l2.h:125
msgid "pointer to :c:type:`struct media_device <media_device>`, may be NULL."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:103 include/media/videobuf2-v4l2.h:127
#: include/media/videobuf2-v4l2.h:163
msgid "``struct v4l2_buffer *b``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:102
msgid ""
"buffer structure passed from userspace to :c:type:`v4l2_ioctl_ops-"
">vidioc_prepare_buf <v4l2_ioctl_ops>` handler in driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:104
msgid ""
"Should be called from :c:type:`v4l2_ioctl_ops->vidioc_prepare_buf "
"<v4l2_ioctl_ops>` ioctl handler of a driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:109
msgid "verifies the passed buffer,"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:110
msgid ""
"calls :c:type:`vb2_ops->buf_prepare <vb2_ops>` callback in the driver (if "
"provided), in which driver-specific buffer initialization can be performed."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:112
msgid ""
"if **b->request_fd** is non-zero and **mdev->ops->req_queue** is set, then "
"bind the prepared buffer to the request."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:115
msgid ""
"The return values from this function are intended to be directly returned "
"from :c:type:`v4l2_ioctl_ops->vidioc_prepare_buf <v4l2_ioctl_ops>` handler "
"in driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:126
msgid ""
"buffer structure passed from userspace to :c:type:`v4l2_ioctl_ops-"
">vidioc_qbuf <v4l2_ioctl_ops>` handler in driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:128
msgid ""
"Should be called from :c:type:`v4l2_ioctl_ops->vidioc_qbuf <v4l2_ioctl_ops>` "
"handler of a driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:132 include/media/videobuf2-v4l2.h:172
msgid "verifies the passed buffer;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:133
msgid ""
"if **b->request_fd** is non-zero and **mdev->ops->req_queue** is set, then "
"bind the buffer to the request."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:141
msgid ""
"The return values from this function are intended to be directly returned "
"from :c:type:`v4l2_ioctl_ops->vidioc_qbuf <v4l2_ioctl_ops>` handler in "
"driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:149
msgid "Export a buffer as a file descriptor"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:152
msgid "``struct v4l2_exportbuffer *eb``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:151
msgid ""
"export buffer structure passed from userspace to :c:type:`v4l2_ioctl_ops-"
">vidioc_expbuf <v4l2_ioctl_ops>` handler in driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:153
msgid ""
"The return values from this function are intended to be directly returned "
"from :c:type:`v4l2_ioctl_ops->vidioc_expbuf <v4l2_ioctl_ops>` handler in "
"driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:162
msgid ""
"buffer structure passed from userspace to :c:type:`v4l2_ioctl_ops-"
">vidioc_dqbuf <v4l2_ioctl_ops>` handler in driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:164
msgid ""
"if true, this call will not sleep waiting for a buffer if no buffers ready "
"for dequeuing are present. Normally the driver would be passing (:c:type:"
"`file->f_flags <file>` & ``O_NONBLOCK``) here"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:167
msgid ""
"Should be called from :c:type:`v4l2_ioctl_ops->vidioc_dqbuf "
"<v4l2_ioctl_ops>` ioctl handler of a driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:173
msgid ""
"calls :c:type:`vb2_ops->buf_finish <vb2_ops>` callback in the driver (if "
"provided), in which driver can perform any additional operations that may be "
"required before returning the buffer to userspace, such as cache sync;"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:179
msgid ""
"The return values from this function are intended to be directly returned "
"from :c:type:`v4l2_ioctl_ops->vidioc_dqbuf <v4l2_ioctl_ops>` handler in "
"driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:186
msgid "start streaming"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:189 include/media/videobuf2-v4l2.h:207
msgid "``enum v4l2_buf_type type``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:188
msgid ""
"type argument passed from userspace to vidioc_streamon handler, as defined "
"by :c:type:`enum v4l2_buf_type <v4l2_buf_type>`."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:190
msgid ""
"Should be called from :c:type:`v4l2_ioctl_ops->vidioc_streamon "
"<v4l2_ioctl_ops>` handler of a driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:194
msgid "verifies current state"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:195
msgid "passes any previously queued buffers to the driver and starts streaming"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:197
msgid ""
"The return values from this function are intended to be directly returned "
"from :c:type:`v4l2_ioctl_ops->vidioc_streamon <v4l2_ioctl_ops>` handler in "
"the driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:204
msgid "stop streaming"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:206
msgid "type argument passed from userspace to vidioc_streamoff handler"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:207
msgid "Should be called from vidioc_streamoff handler of a driver."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:211
msgid "verifies current state,"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:212
msgid ""
"stop streaming and dequeues any queued buffers, including those previously "
"passed to the driver (after waiting for the driver to finish)."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:215
msgid ""
"This call can be used for pausing playback. The return values from this "
"function are intended to be directly returned from vidioc_streamoff handler "
"in the driver"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:225
msgid ""
"The vb2_queue structure should be allocated by the driver. The driver is "
"responsible of clearing it's content and setting initial values for some "
"required entries before calling this function. q->ops, q->mem_ops, q->type "
"and q->io_modes are mandatory. Please refer to the struct vb2_queue "
"description in include/media/videobuf2-core.h for more information."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:236
msgid "initialize a videobuf2 queue with a name"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:239
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:238
msgid "the queue name"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:239
msgid ""
"This function initializes the vb2_queue exactly like vb2_queue_init(), and "
"additionally sets the queue name. The queue name is used for logging "
"purpose, and should uniquely identify the queue within the context of the "
"device it belongs to. This is useful to attribute kernel log messages to the "
"right queue for m2m devices or other devices that handle multiple queues."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:251
msgid ""
"This function stops streaming and performs necessary clean ups, including "
"freeing video buffer memory. The driver is responsible for freeing the "
"vb2_queue structure itself."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:259
msgid "change the type of an inactive vb2_queue"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:261
msgid "the type to change to (V4L2_BUF_TYPE_VIDEO_*)"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:262
msgid ""
"This function changes the type of the vb2_queue. This is only possible if "
"the queue is not busy (i.e. no buffers have been allocated)."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:265
msgid ""
"vb2_queue_change_type() can be used to support multiple buffer types using "
"the same queue. The driver can implement v4l2_ioctl_ops.vidioc_reqbufs and "
"v4l2_ioctl_ops.vidioc_create_bufs functions and call vb2_queue_change_type() "
"before calling vb2_ioctl_reqbufs() or vb2_ioctl_create_bufs(), and thus "
"\"lock\" the buffer type until the buffers have been released."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:275
msgid "implements poll userspace operation"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:277
msgid "file argument passed to the poll file operation handler"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:278
msgid "wait argument passed to the poll file operation handler"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:286
msgid ""
"If the driver uses struct v4l2_fh, then vb2_poll() will also check for any "
"pending events."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:305
msgid "check if the queue is busy"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:307
msgid "file through which the vb2 queue access is performed"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:308
msgid ""
"The queue is considered busy if it has an owner and the owner is not the "
"**file**."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:311
msgid ""
"Queue ownership is acquired and checked by some of the v4l2_ioctl_ops "
"helpers below. Drivers can also use this function directly when they need to "
"open-code ioctl handlers, for instance to add additional checks between the "
"queue ownership test and the call to the corresponding vb2 operation."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:356
msgid "unregister the video device and release queue"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:362
msgid "``struct video_device *vdev``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:358
msgid "pointer to :c:type:`struct video_device <video_device>`"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:359
msgid ""
"If the driver uses vb2_fop_release()/_vb2_fop_release(), then it should use "
"vb2_video_unregister_device() instead of video_unregister_device()."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:362
msgid ""
"This function will call video_unregister_device() and then release the "
"vb2_queue if streaming is in progress. This will stop streaming and this "
"will simplify the unbind sequence since after this call all subdevs will "
"have stopped streaming as well."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:371
msgid "helper function to lock a struct :c:type:`vb2_queue`"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:377 include/media/videobuf2-v4l2.h:386
msgid "``struct vb2_queue *vq``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:373 include/media/videobuf2-v4l2.h:382
msgid "pointer to :c:type:`struct vb2_queue <vb2_queue>`"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:374 include/media/videobuf2-v4l2.h:383
msgid "..note:: only use if vq->lock is non-NULL."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:10:
#: include/media/videobuf2-v4l2.h:380
msgid "helper function to unlock a struct :c:type:`vb2_queue`"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:22
msgid "common vma refcount tracking handler."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:24
msgid "``refcount``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:25
msgid "pointer to :c:type:`refcount_t` entry in the buffer."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:26
msgid "callback to function that decreases buffer refcount."
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:26
msgid "``arg``"
msgstr ""

#: ../../../driver-api/media/v4l2-videobuf2:12:
#: include/media/videobuf2-memops.h:27
msgid "argument for **put** callback."
msgstr ""
