# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/pci/pci.rst:2
msgid "PCI Support Library"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:184
msgid "returns maximum PCI bus number of given bus' children"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:148
#: ../drivers/pci/devres.c:179 ../drivers/pci/devres.c:209
#: ../drivers/pci/devres.c:275 ../drivers/pci/devres.c:320
#: ../drivers/pci/devres.c:366 ../drivers/pci/devres.c:400
#: ../drivers/pci/devres.c:423 ../drivers/pci/devres.c:525
#: ../drivers/pci/devres.c:575 ../drivers/pci/devres.c:601
#: ../drivers/pci/devres.c:650 ../drivers/pci/devres.c:671
#: ../drivers/pci/devres.c:716 ../drivers/pci/devres.c:793
#: ../drivers/pci/devres.c:824 ../../../driver-api/pci/pci:13:
#: ../drivers/pci/pci-driver.c:37 ../drivers/pci/pci-driver.c:98
#: ../drivers/pci/pci-driver.c:1427 ../drivers/pci/pci-driver.c:1457
#: ../drivers/pci/pci-driver.c:1478 ../drivers/pci/pci-driver.c:1526
#: ../drivers/pci/pci-driver.c:1546 ../../../driver-api/pci/pci:16:
#: ../drivers/pci/remove.c:141 ../../../driver-api/pci/pci:19:
#: ../drivers/pci/search.c:137 ../drivers/pci/search.c:162
#: ../drivers/pci/search.c:185 ../drivers/pci/search.c:218
#: ../drivers/pci/search.c:329 ../drivers/pci/search.c:354
#: ../drivers/pci/search.c:388 ../drivers/pci/search.c:417
#: ../drivers/pci/search.c:448 ../../../driver-api/pci/pci:22:
#: ../drivers/pci/msi/msi.c:135 ../drivers/pci/msi/msi.c:147
#: ../drivers/pci/msi/msi.c:477 ../../../driver-api/pci/pci:25:
#: ../drivers/pci/bus.c:253 ../drivers/pci/bus.c:343 ../drivers/pci/bus.c:396
#: ../drivers/pci/bus.c:465 ../drivers/pci/bus.c:486
#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:191
#: ../drivers/pci/access.c:285 ../drivers/pci/access.c:305
#: ../drivers/pci/access.c:329 ../../../driver-api/pci/pci:31:
#: ../drivers/pci/irq.c:23 ../drivers/pci/irq.c:67 ../drivers/pci/irq.c:126
#: ../drivers/pci/irq.c:240 ../drivers/pci/irq.c:253
#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2328
#: ../drivers/pci/probe.c:2892 ../drivers/pci/probe.c:3235
#: ../drivers/pci/probe.c:3522 ../../../driver-api/pci/pci:37:
#: ../drivers/pci/slot.c:193 ../drivers/pci/slot.c:313
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:26
#: ../drivers/pci/rebar.c:45 ../drivers/pci/rebar.c:103
#: ../drivers/pci/rebar.c:134 ../drivers/pci/rebar.c:154
#: ../drivers/pci/rebar.c:279 ../../../driver-api/pci/pci:43:
#: ../drivers/pci/rom.c:20 ../drivers/pci/rom.c:56 ../drivers/pci/rom.c:130
#: ../drivers/pci/rom.c:185 ../../../driver-api/pci/pci:46:
#: ../drivers/pci/iov.c:59 ../drivers/pci/iov.c:1159 ../drivers/pci/iov.c:1177
#: ../drivers/pci/iov.c:1192 ../drivers/pci/iov.c:1207
#: ../drivers/pci/iov.c:1248 ../drivers/pci/iov.c:1278
#: ../drivers/pci/iov.c:1295 ../drivers/pci/iov.c:1331
#: ../drivers/pci/iov.c:1360 ../../../driver-api/pci/pci:49:
#: ../drivers/pci/pci-sysfs.c:925 ../drivers/pci/pci-sysfs.c:950
#: ../drivers/pci/pci-sysfs.c:975 ../drivers/pci/pci-sysfs.c:995
#: ../drivers/pci/pci-sysfs.c:1015 ../drivers/pci/pci-sysfs.c:1027
#: ../drivers/pci/pci-sysfs.c:1102 ../drivers/pci/pci-sysfs.c:1212
#: ../drivers/pci/pci-sysfs.c:1296 ../drivers/pci/pci-sysfs.c:1335
#: ../drivers/pci/pci-sysfs.c:1360 ../drivers/pci/pci-sysfs.c:1704
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:188
#: ../drivers/pci/pci.c:210 ../drivers/pci/pci.c:464 ../drivers/pci/pci.c:495
#: ../drivers/pci/pci.c:522 ../drivers/pci/pci.c:543 ../drivers/pci/pci.c:563
#: ../drivers/pci/pci.c:626 ../drivers/pci/pci.c:645 ../drivers/pci/pci.c:668
#: ../drivers/pci/pci.c:701 ../drivers/pci/pci.c:733 ../drivers/pci/pci.c:776
#: ../drivers/pci/pci.c:1179 ../drivers/pci/pci.c:1586
#: ../drivers/pci/pci.c:1741 ../drivers/pci/pci.c:1831
#: ../drivers/pci/pci.c:1868 ../drivers/pci/pci.c:1909
#: ../drivers/pci/pci.c:1945 ../drivers/pci/pci.c:2032
#: ../drivers/pci/pci.c:2104 ../drivers/pci/pci.c:2118
#: ../drivers/pci/pci.c:2195 ../drivers/pci/pci.c:2235
#: ../drivers/pci/pci.c:2333 ../drivers/pci/pci.c:2437
#: ../drivers/pci/pci.c:2574 ../drivers/pci/pci.c:2592
#: ../drivers/pci/pci.c:2674 ../drivers/pci/pci.c:2703
#: ../drivers/pci/pci.c:2748 ../drivers/pci/pci.c:2863
#: ../drivers/pci/pci.c:3094 ../drivers/pci/pci.c:3111
#: ../drivers/pci/pci.c:3666 ../drivers/pci/pci.c:3749
#: ../drivers/pci/pci.c:3823 ../drivers/pci/pci.c:3844
#: ../drivers/pci/pci.c:3882 ../drivers/pci/pci.c:3897
#: ../drivers/pci/pci.c:3913 ../drivers/pci/pci.c:3928
#: ../drivers/pci/pci.c:3947 ../drivers/pci/pci.c:4029
#: ../drivers/pci/pci.c:4065 ../drivers/pci/pci.c:4139
#: ../drivers/pci/pci.c:4153 ../drivers/pci/pci.c:4163
#: ../drivers/pci/pci.c:4201 ../drivers/pci/pci.c:4232
#: ../drivers/pci/pci.c:4251 ../drivers/pci/pci.c:4288
#: ../drivers/pci/pci.c:4313 ../drivers/pci/pci.c:4329
#: ../drivers/pci/pci.c:4357 ../drivers/pci/pci.c:4787
#: ../drivers/pci/pci.c:5028 ../drivers/pci/pci.c:5115
#: ../drivers/pci/pci.c:5162 ../drivers/pci/pci.c:5196
#: ../drivers/pci/pci.c:5466 ../drivers/pci/pci.c:5569
#: ../drivers/pci/pci.c:5607 ../drivers/pci/pci.c:5620
#: ../drivers/pci/pci.c:5643 ../drivers/pci/pci.c:5666
#: ../drivers/pci/pci.c:5713 ../drivers/pci/pci.c:5729
#: ../drivers/pci/pci.c:5780 ../drivers/pci/pci.c:5796
#: ../drivers/pci/pci.c:5842 ../drivers/pci/pci.c:5949
#: ../drivers/pci/pci.c:5963 ../drivers/pci/pci.c:6042
#: ../drivers/pci/pci.c:6054 ../drivers/pci/pci.c:6519
#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:163
#: ../drivers/pci/tph.c:239 ../drivers/pci/tph.c:284 ../drivers/pci/tph.c:346
#: ../drivers/pci/tph.c:368 ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:341
#: ../drivers/pci/hotplug/pci_hotplug_core.c:374
#: ../drivers/pci/hotplug/pci_hotplug_core.c:419
#: ../drivers/pci/hotplug/pci_hotplug_core.c:448
#: ../drivers/pci/hotplug/pci_hotplug_core.c:462
#: ../drivers/pci/hotplug/pci_hotplug_core.c:477 ../../../driver-api/pci/pci:7:
#: ../drivers/pci/iomap.c:19 ../drivers/pci/iomap.c:65
#: ../drivers/pci/iomap.c:114 ../drivers/pci/iomap.c:134
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:187
#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:255
#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:193
#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2894
#: ../drivers/pci/probe.c:3237 ../drivers/pci/probe.c:3524
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:190
#: ../drivers/pci/pci.c:497 ../drivers/pci/pci.c:5571
#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:340
#: ../drivers/pci/hotplug/pci_hotplug_core.c:373
msgid "``struct pci_bus *bus``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:185
msgid "pointer to PCI bus structure to search"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:149
#: ../drivers/pci/devres.c:180 ../drivers/pci/devres.c:209
#: ../drivers/pci/devres.c:274 ../drivers/pci/devres.c:322
#: ../drivers/pci/devres.c:367 ../drivers/pci/devres.c:399
#: ../drivers/pci/devres.c:424 ../drivers/pci/devres.c:528
#: ../drivers/pci/devres.c:575 ../drivers/pci/devres.c:604
#: ../drivers/pci/devres.c:650 ../drivers/pci/devres.c:674
#: ../drivers/pci/devres.c:719 ../drivers/pci/devres.c:795
#: ../drivers/pci/devres.c:828 ../../../driver-api/pci/pci:13:
#: ../drivers/pci/pci-driver.c:43 ../drivers/pci/pci-driver.c:98
#: ../drivers/pci/pci-driver.c:1428 ../drivers/pci/pci-driver.c:1456
#: ../drivers/pci/pci-driver.c:1477 ../drivers/pci/pci-driver.c:1525
#: ../drivers/pci/pci-driver.c:1545 ../../../driver-api/pci/pci:16:
#: ../drivers/pci/remove.c:140 ../../../driver-api/pci/pci:19:
#: ../drivers/pci/search.c:137 ../drivers/pci/search.c:161
#: ../drivers/pci/search.c:187 ../drivers/pci/search.c:221
#: ../drivers/pci/search.c:332 ../drivers/pci/search.c:355
#: ../drivers/pci/search.c:388 ../drivers/pci/search.c:417
#: ../drivers/pci/search.c:448 ../../../driver-api/pci/pci:22:
#: ../drivers/pci/msi/msi.c:476 ../../../driver-api/pci/pci:25:
#: ../drivers/pci/bus.c:259 ../drivers/pci/bus.c:342 ../drivers/pci/bus.c:395
#: ../drivers/pci/bus.c:466 ../drivers/pci/bus.c:487
#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:191
#: ../drivers/pci/access.c:284 ../drivers/pci/access.c:304
#: ../drivers/pci/access.c:328 ../../../driver-api/pci/pci:31:
#: ../drivers/pci/irq.c:3 ../drivers/pci/irq.c:68 ../drivers/pci/irq.c:126
#: ../drivers/pci/irq.c:239 ../drivers/pci/irq.c:252
#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2327
#: ../drivers/pci/probe.c:2892 ../drivers/pci/probe.c:3234
#: ../drivers/pci/probe.c:3521 ../../../driver-api/pci/pci:37:
#: ../drivers/pci/slot.c:195 ../drivers/pci/slot.c:312
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:25
#: ../drivers/pci/rebar.c:103 ../drivers/pci/rebar.c:154
#: ../drivers/pci/rebar.c:281 ../../../driver-api/pci/pci:43:
#: ../drivers/pci/rom.c:19 ../drivers/pci/rom.c:55 ../drivers/pci/rom.c:132
#: ../drivers/pci/rom.c:185 ../../../driver-api/pci/pci:46:
#: ../drivers/pci/iov.c:59 ../drivers/pci/iov.c:1159 ../drivers/pci/iov.c:1191
#: ../drivers/pci/iov.c:1206 ../drivers/pci/iov.c:1248
#: ../drivers/pci/iov.c:1277 ../drivers/pci/iov.c:1295
#: ../drivers/pci/iov.c:1332 ../drivers/pci/iov.c:1361
#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:929
#: ../drivers/pci/pci-sysfs.c:954 ../drivers/pci/pci-sysfs.c:977
#: ../drivers/pci/pci-sysfs.c:997 ../drivers/pci/pci-sysfs.c:1015
#: ../drivers/pci/pci-sysfs.c:1026 ../drivers/pci/pci-sysfs.c:1104
#: ../drivers/pci/pci-sysfs.c:1211 ../drivers/pci/pci-sysfs.c:1295
#: ../drivers/pci/pci-sysfs.c:1339 ../drivers/pci/pci-sysfs.c:1364
#: ../drivers/pci/pci-sysfs.c:1703 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:187 ../drivers/pci/pci.c:209 ../drivers/pci/pci.c:464
#: ../drivers/pci/pci.c:496 ../drivers/pci/pci.c:523 ../drivers/pci/pci.c:543
#: ../drivers/pci/pci.c:562 ../drivers/pci/pci.c:627 ../drivers/pci/pci.c:645
#: ../drivers/pci/pci.c:669 ../drivers/pci/pci.c:702 ../drivers/pci/pci.c:734
#: ../drivers/pci/pci.c:776 ../drivers/pci/pci.c:1586 ../drivers/pci/pci.c:1868
#: ../drivers/pci/pci.c:2103 ../drivers/pci/pci.c:2117
#: ../drivers/pci/pci.c:2194 ../drivers/pci/pci.c:2235
#: ../drivers/pci/pci.c:2437 ../drivers/pci/pci.c:2575
#: ../drivers/pci/pci.c:2592 ../drivers/pci/pci.c:2674
#: ../drivers/pci/pci.c:2703 ../drivers/pci/pci.c:2747
#: ../drivers/pci/pci.c:2863 ../drivers/pci/pci.c:3093
#: ../drivers/pci/pci.c:3110 ../drivers/pci/pci.c:3669
#: ../drivers/pci/pci.c:3750 ../drivers/pci/pci.c:3826
#: ../drivers/pci/pci.c:3844 ../drivers/pci/pci.c:3913
#: ../drivers/pci/pci.c:3928 ../drivers/pci/pci.c:3949
#: ../drivers/pci/pci.c:4029 ../drivers/pci/pci.c:4064
#: ../drivers/pci/pci.c:4138 ../drivers/pci/pci.c:4162
#: ../drivers/pci/pci.c:4200 ../drivers/pci/pci.c:4231
#: ../drivers/pci/pci.c:4250 ../drivers/pci/pci.c:4288
#: ../drivers/pci/pci.c:4312 ../drivers/pci/pci.c:4328
#: ../drivers/pci/pci.c:4357 ../drivers/pci/pci.c:4786
#: ../drivers/pci/pci.c:5028 ../drivers/pci/pci.c:5114
#: ../drivers/pci/pci.c:5161 ../drivers/pci/pci.c:5195
#: ../drivers/pci/pci.c:5465 ../drivers/pci/pci.c:5568
#: ../drivers/pci/pci.c:5606 ../drivers/pci/pci.c:5619
#: ../drivers/pci/pci.c:5642 ../drivers/pci/pci.c:5667
#: ../drivers/pci/pci.c:5712 ../drivers/pci/pci.c:5730
#: ../drivers/pci/pci.c:5779 ../drivers/pci/pci.c:5797
#: ../drivers/pci/pci.c:5845 ../drivers/pci/pci.c:5948
#: ../drivers/pci/pci.c:5962 ../drivers/pci/pci.c:6041
#: ../drivers/pci/pci.c:6054 ../../../driver-api/pci/pci:52:
#: ../drivers/pci/tph.c:242 ../drivers/pci/tph.c:285 ../drivers/pci/tph.c:368
#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:345
#: ../drivers/pci/hotplug/pci_hotplug_core.c:378
#: ../drivers/pci/hotplug/pci_hotplug_core.c:418
#: ../drivers/pci/hotplug/pci_hotplug_core.c:447
#: ../drivers/pci/hotplug/pci_hotplug_core.c:461
#: ../drivers/pci/hotplug/pci_hotplug_core.c:476 ../../../driver-api/pci/pci:7:
#: ../drivers/pci/iomap.c:21 ../drivers/pci/iomap.c:67
#: ../drivers/pci/iomap.c:115 ../drivers/pci/iomap.c:135
msgid "**Description**"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:186
msgid ""
"Given a PCI bus, returns the highest PCI bus number present in the set "
"including the given PCI bus and its list of child PCI buses."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:206
msgid "return and clear error bits in PCI_STATUS"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:277
#: ../drivers/pci/devres.c:322 ../drivers/pci/devres.c:368
#: ../drivers/pci/devres.c:402 ../drivers/pci/devres.c:425
#: ../drivers/pci/devres.c:527 ../drivers/pci/devres.c:577
#: ../drivers/pci/devres.c:603 ../drivers/pci/devres.c:652
#: ../drivers/pci/devres.c:673 ../drivers/pci/devres.c:718
#: ../drivers/pci/devres.c:795 ../drivers/pci/devres.c:826
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:105
#: ../drivers/pci/rebar.c:136 ../drivers/pci/rebar.c:156
#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:22
#: ../drivers/pci/rom.c:58 ../drivers/pci/rom.c:132 ../drivers/pci/rom.c:187
#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1214
#: ../drivers/pci/pci-sysfs.c:1298 ../drivers/pci/pci-sysfs.c:1706
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:212
#: ../drivers/pci/pci.c:3751 ../drivers/pci/pci.c:3825
#: ../drivers/pci/pci.c:3846 ../drivers/pci/pci.c:3884
#: ../drivers/pci/pci.c:3899 ../drivers/pci/pci.c:3915
#: ../drivers/pci/pci.c:3930 ../drivers/pci/pci.c:3949
#: ../drivers/pci/pci.c:4290 ../drivers/pci/pci.c:5609
#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:165
#: ../drivers/pci/tph.c:241 ../drivers/pci/tph.c:286 ../drivers/pci/tph.c:348
#: ../drivers/pci/tph.c:370
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:123
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:276
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1156
#: ../drivers/pci/iov.c:1174 ../drivers/pci/iov.c:1189
#: ../drivers/pci/iov.c:1204 ../drivers/pci/iov.c:1292
#: ../drivers/pci/iov.c:1328 ../drivers/pci/iov.c:1357
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:207
#: ../drivers/pci/pci.c:3663
msgid "the PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:208
msgid "Returns error bits set in PCI_STATUS and clears them."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:460
#: ../drivers/pci/pci.c:491
msgid "query for devices' capabilities"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:97
#: ../drivers/pci/pci-driver.c:1528 ../drivers/pci/pci-driver.c:1548
#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:143
#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:479
#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:345
#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:287
#: ../drivers/pci/access.c:307 ../drivers/pci/access.c:331
#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:25
#: ../drivers/pci/irq.c:69 ../drivers/pci/irq.c:128 ../drivers/pci/irq.c:242
#: ../drivers/pci/irq.c:255 ../../../driver-api/pci/pci:34:
#: ../drivers/pci/probe.c:2330 ../../../driver-api/pci/pci:40:
#: ../drivers/pci/rebar.c:281 ../../../driver-api/pci/pci:46:
#: ../drivers/pci/iov.c:61 ../drivers/pci/iov.c:1161 ../drivers/pci/iov.c:1179
#: ../drivers/pci/iov.c:1194 ../drivers/pci/iov.c:1209
#: ../drivers/pci/iov.c:1250 ../drivers/pci/iov.c:1280
#: ../drivers/pci/iov.c:1297 ../drivers/pci/iov.c:1333
#: ../drivers/pci/iov.c:1362 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:466 ../drivers/pci/pci.c:524 ../drivers/pci/pci.c:545
#: ../drivers/pci/pci.c:565 ../drivers/pci/pci.c:628 ../drivers/pci/pci.c:647
#: ../drivers/pci/pci.c:670 ../drivers/pci/pci.c:703 ../drivers/pci/pci.c:778
#: ../drivers/pci/pci.c:1181 ../drivers/pci/pci.c:1588
#: ../drivers/pci/pci.c:1743 ../drivers/pci/pci.c:1833
#: ../drivers/pci/pci.c:1870 ../drivers/pci/pci.c:1911
#: ../drivers/pci/pci.c:1947 ../drivers/pci/pci.c:2034
#: ../drivers/pci/pci.c:2106 ../drivers/pci/pci.c:2120
#: ../drivers/pci/pci.c:2197 ../drivers/pci/pci.c:2237
#: ../drivers/pci/pci.c:2335 ../drivers/pci/pci.c:2439
#: ../drivers/pci/pci.c:2594 ../drivers/pci/pci.c:2676
#: ../drivers/pci/pci.c:2705 ../drivers/pci/pci.c:2750
#: ../drivers/pci/pci.c:2865 ../drivers/pci/pci.c:3096
#: ../drivers/pci/pci.c:3113 ../drivers/pci/pci.c:3668
#: ../drivers/pci/pci.c:4141 ../drivers/pci/pci.c:4155
#: ../drivers/pci/pci.c:4165 ../drivers/pci/pci.c:4203
#: ../drivers/pci/pci.c:4234 ../drivers/pci/pci.c:4253
#: ../drivers/pci/pci.c:4315 ../drivers/pci/pci.c:4331
#: ../drivers/pci/pci.c:4359 ../drivers/pci/pci.c:4789
#: ../drivers/pci/pci.c:5030 ../drivers/pci/pci.c:5117
#: ../drivers/pci/pci.c:5164 ../drivers/pci/pci.c:5198
#: ../drivers/pci/pci.c:5622 ../drivers/pci/pci.c:5645
#: ../drivers/pci/pci.c:5668 ../drivers/pci/pci.c:5715
#: ../drivers/pci/pci.c:5731 ../drivers/pci/pci.c:5782
#: ../drivers/pci/pci.c:5798 ../drivers/pci/pci.c:5844
#: ../drivers/pci/pci.c:5951 ../drivers/pci/pci.c:5965
#: ../drivers/pci/pci.c:6044 ../drivers/pci/pci.c:6056
#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:21
#: ../drivers/pci/iomap.c:67 ../drivers/pci/iomap.c:116
#: ../drivers/pci/iomap.c:136
msgid "``struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2325
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:461
#: ../drivers/pci/pci.c:493 ../drivers/pci/pci.c:519 ../drivers/pci/pci.c:540
#: ../drivers/pci/pci.c:560 ../drivers/pci/pci.c:623 ../drivers/pci/pci.c:642
#: ../drivers/pci/pci.c:665 ../drivers/pci/pci.c:698 ../drivers/pci/pci.c:773
#: ../drivers/pci/pci.c:5617 ../drivers/pci/pci.c:5640
#: ../drivers/pci/pci.c:5663 ../drivers/pci/pci.c:5710
#: ../drivers/pci/pci.c:5726 ../drivers/pci/pci.c:5777
#: ../drivers/pci/pci.c:5793 ../drivers/pci/pci.c:5840
#: ../drivers/pci/pci.c:5946 ../drivers/pci/pci.c:5960
#: ../drivers/pci/pci.c:6039 ../../../driver-api/pci/pci:52:
#: ../drivers/pci/tph.c:160
msgid "PCI device to query"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:463
#: ../drivers/pci/pci.c:495 ../drivers/pci/pci.c:522 ../drivers/pci/pci.c:542
#: ../drivers/pci/pci.c:668
msgid "``int cap``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:462
#: ../drivers/pci/pci.c:494 ../drivers/pci/pci.c:521 ../drivers/pci/pci.c:541
msgid "capability code"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:463
msgid ""
"Tell if a device supports a given PCI capability. Returns the address of the "
"requested capability structure within the device's PCI configuration space "
"or 0 in case the device does not support it.  Possible values for **cap** "
"include:"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:468
msgid ""
"``PCI_CAP_ID_PM``           Power Management ``PCI_CAP_ID_AGP``          "
"Accelerated Graphics Port ``PCI_CAP_ID_VPD``          Vital Product Data "
"``PCI_CAP_ID_SLOTID``       Slot Identification ``PCI_CAP_ID_MSI``          "
"Message Signalled Interrupts ``PCI_CAP_ID_CHSWP``        CompactPCI HotSwap "
"``PCI_CAP_ID_PCIX``         PCI-X ``PCI_CAP_ID_EXP``          PCI Express"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:492
msgid "the PCI bus to query"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:184
#: ../drivers/pci/search.c:218 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:494
msgid "``unsigned int devfn``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:495
msgid ""
"Like pci_find_capability() but works for PCI devices that do not have a "
"pci_dev structure set up yet."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:498
msgid ""
"Returns the address of the requested capability structure within the "
"device's PCI configuration space or 0 in case the device does not support it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:518
#: ../drivers/pci/pci.c:539
msgid "Find an extended capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:521
msgid "``u16 start``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:520
msgid "address at which to start looking (0 to start at beginning of list)"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:522
msgid ""
"Returns the address of the next matching extended capability structure "
"within the device's PCI configuration space or 0 if the device does not "
"support it.  Some capabilities can occur several times, e.g., the vendor-"
"specific capability, and this provides a way to find them all."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:542
msgid ""
"Returns the address of the requested extended capability structure within "
"the device's PCI configuration space or 0 if the device does not support "
"it.  Possible values for **cap** include:"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:546
msgid ""
"``PCI_EXT_CAP_ID_ERR``         Advanced Error Reporting "
"``PCI_EXT_CAP_ID_VC``          Virtual Channel "
"``PCI_EXT_CAP_ID_DSN``         Device Serial Number "
"``PCI_EXT_CAP_ID_PWR``         Power Budgeting"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:559
msgid "Read and return the 8-byte Device Serial Number"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:561
msgid ""
"Looks up the PCI_EXT_CAP_ID_DSN and reads the 8 bytes of the Device Serial "
"Number."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:564
msgid "Returns the DSN, or zero if the capability does not exist."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:622
#: ../drivers/pci/pci.c:641
msgid "query a device's HyperTransport capabilities"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:625
msgid "``u8 pos``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:624
msgid "Position from which to continue searching"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:626
#: ../drivers/pci/pci.c:644
msgid "``int ht_cap``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:625
#: ../drivers/pci/pci.c:643
msgid "HyperTransport capability code"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:626
msgid ""
"To be used in conjunction with pci_find_ht_capability() to search for all "
"capabilities matching **ht_cap**. **pos** should always be a value returned "
"from pci_find_ht_capability()."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:630
msgid ""
"NB. To be 100% safe against broken PCI devices, the caller should take steps "
"to avoid an infinite loop."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:644
msgid ""
"Tell if a device supports a given HyperTransport capability. Returns an "
"address within the device's PCI configuration space or 0 in case the device "
"does not support the request capability. The address points to the PCI "
"capability, of type PCI_CAP_ID_HT, which has a HyperTransport capability "
"matching **ht_cap**."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:664
msgid "Find a vendor-specific extended capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:667
#: ../drivers/pci/pci.c:700
msgid "``u16 vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:666
msgid "Vendor ID for which capability is defined"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:667
msgid "Vendor-specific capability ID"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:668
msgid ""
"If **dev** has Vendor ID **vendor**, search for a VSEC capability with VSEC "
"ID **cap**. If found, return the capability offset in config space; "
"otherwise return 0."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:697
msgid "Find DVSEC for vendor"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:699
msgid "Vendor ID to match for the DVSEC"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:701
msgid "``u16 dvsec``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:700
msgid "Designated Vendor-specific capability ID"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:701
msgid ""
"If DVSEC has Vendor ID **vendor** and DVSEC ID **dvsec** return the "
"capability offset in config space; otherwise return 0."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:729
msgid "return resource region of parent bus of given region"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1480
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:735
msgid "``const struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:731
msgid "PCI device structure contains resources to be searched"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:208
#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:252
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:733
#: ../drivers/pci/pci.c:775 ../drivers/pci/pci.c:4067
msgid "``struct resource *res``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:732
msgid "child resource record for which parent is sought"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:733
msgid ""
"For given resource region of given device, return the resource region of "
"parent bus the given region is contained in."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:772
msgid "Return matching PCI device resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:774
msgid "Resource to look for"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:775
msgid ""
"Goes over standard PCI resources (BARs) and checks if the given resource is "
"partially or fully contained in any of them. In that case the matching "
"resource is returned, ``NULL`` otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1175
msgid "Use platform to change device power state"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1176
#: ../drivers/pci/pci.c:1583 ../drivers/pci/pci.c:2330
#: ../drivers/pci/pci.c:2434
msgid "PCI device to handle."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1178
#: ../drivers/pci/pci.c:1585 ../drivers/pci/pci.c:2332
#: ../drivers/pci/pci.c:2573
msgid "``pci_power_t state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1177
msgid "State to put the device into."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1582
msgid "Set the power state of a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1584
msgid "PCI power state (D0, D1, D2, D3hot) to put the device into."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1585
msgid ""
"Transition a device to a new power state, using the platform firmware and/or "
"the device's PCI PM registers."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1588
msgid ""
"RETURN VALUE: -EINVAL if the requested state is invalid. -EIO if device does "
"not support PCI PM or its PM capabilities register has a wrong version, or "
"device doesn't support the requested state. 0 if the transition is to D1 or "
"D2 but D1 and D2 are not supported. 0 if device already is in the requested "
"state. 0 if the transition is to D3 but D3 is not supported. 0 if device's "
"power state has been successfully changed."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1737
msgid "save the PCI configuration space of a device before suspending"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1739
#: ../drivers/pci/pci.c:1828 ../drivers/pci/pci.c:1866
#: ../drivers/pci/pci.c:1906 ../drivers/pci/pci.c:1943
msgid "PCI device that we're dealing with"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1827
msgid "Restore the saved state of a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1864
msgid "Allocate and return an opaque struct containing the device saved state."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1867
msgid "Return NULL if no state or error."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1905
msgid "Reload the provided save state into struct pci_dev."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1908
msgid "``struct pci_saved_state *state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1907
msgid "Saved state returned from pci_store_saved_state()"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1941
msgid ""
"Reload the save state pointed to by state, and free the memory allocated for "
"it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1945
msgid "``struct pci_saved_state **state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1944
msgid "Pointer to saved state returned from pci_store_saved_state()"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2028
msgid "Resume abandoned device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2029
msgid "PCI device to be resumed"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:532
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2031
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2031
msgid ""
"This function is a backend of pci_default_resume() and is not supposed to be "
"called by normal code, write proper resume handler and use it instead."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2100
msgid "Initialize a device for use with Memory space"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:363
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2101
#: ../drivers/pci/pci.c:2115
msgid "PCI device to be initialized"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2102
msgid ""
"Initialize device before it's used by a driver. Ask low-level code to enable "
"Memory resources. Wake up the device if it was suspended. Beware, this "
"function can fail."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2114
msgid "Initialize device before it's used by a driver."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2116
msgid ""
"Initialize device before it's used by a driver. Ask low-level code to enable "
"I/O and memory. Wake up the device if it was suspended. Beware, this "
"function can fail."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2120
msgid ""
"Note we don't actually enable the device many times if we call this function "
"repeatedly (we just increment the count)."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2191
msgid "Disable PCI device after use"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2192
msgid "PCI device to be disabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2193
msgid ""
"Signal to the system that the PCI device is not in use by the system "
"anymore.  This only involves disabling PCI bus-mastering, if active."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2196
msgid ""
"Note we don't actually disable the device until all callers of "
"pci_enable_device() have called pci_disable_device()."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2231
msgid "set reset state for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2232
msgid "the PCIe device reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2234
msgid "``enum pcie_reset_state state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2233
msgid "Reset state to enter into"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2234
msgid "Sets the PCI reset state for the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2329
msgid "check the capability of PCI device to generate PME#"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2331
msgid "PCI state from which device will issue PME#."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2433
msgid "enable or disable PCI device's PME# function"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2436
#: ../drivers/pci/pci.c:2574 ../drivers/pci/pci.c:2591
msgid "``bool enable``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2435
msgid "'true' to enable PME# generation; 'false' to disable it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2436
msgid ""
"The caller must verify that the device is capable of generating PME# before "
"calling this function with **enable** equal to 'true'."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2570
msgid "change wakeup settings for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2576
msgid "``struct pci_dev *pci_dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2571
msgid "Target device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2572
msgid "PCI state from which device will issue wakeup events"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2573
msgid "Whether or not to enable event generation"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2574
msgid ""
"If **enable** is set, check device_may_wakeup() for the device before "
"calling __pci_enable_wake() for it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2588
msgid "enable/disable device to wake up from D3_hot or D3_cold"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2589
msgid "PCI device to prepare"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2590
msgid "True to enable wake-up event generation; false to disable"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2591
msgid ""
"Many drivers want the device to wake up the system from D3_hot or D3_cold "
"and this function allows them to set that up cleanly - pci_enable_wake() "
"should not be called twice in a row to enable wake-up due to PCI PM vs ACPI "
"ordering constraints."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2596
msgid ""
"This function only returns error code if the device is not allowed to wake "
"up the system from sleep or it is not capable of generating PME# from both "
"D3_hot and D3_cold and the platform is unable to enable wake-up power for it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2670
msgid "prepare PCI device for system-wide transition into a sleep state"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2672
#: ../drivers/pci/pci.c:2701
msgid "Device to handle."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2673
msgid ""
"Choose the power state appropriate for the device depending on whether it "
"can wake up the system and/or is power manageable by the platform (PCI_D3hot "
"is the default) and put the device into that state."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2699
msgid "turn PCI device on during system-wide transition into working state"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2702
msgid "Disable device's system wake-up capability and put it into D0."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2744
msgid "Check if device can generate run-time wake-up events."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2745
msgid "Device to check."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2746
msgid ""
"Return true if the device itself is capable of generating wake-up events "
"(through the platform or using the native PCIe PME) or if the device "
"supports PME and one of its upstream bridges can generate wake-up events."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2859
msgid "Choose the power state of a PCI device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2860
msgid "Target PCI device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2862
msgid "``pm_message_t state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2861
msgid "Target state for the whole system."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2862
msgid "Returns PCI power state suitable for **dev** and **state**."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3090
msgid "Enable D3cold for device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3091
#: ../drivers/pci/pci.c:3108
msgid "PCI device to handle"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3092
msgid ""
"This function can be used in drivers to enable D3cold from the device they "
"handle.  It also updates upstream PCI bridge PM capabilities accordingly."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3107
msgid "Disable D3cold for device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3109
msgid ""
"This function can be used in drivers to disable D3cold from the device they "
"handle.  It also updates upstream PCI bridge PM capabilities accordingly."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3662
msgid "enable AtomicOp requests to root port"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3665
msgid "``u32 cap_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3664
msgid ""
"mask of desired AtomicOp sizes, including one or more of: "
"PCI_EXP_DEVCAP2_ATOMIC_COMP32 PCI_EXP_DEVCAP2_ATOMIC_COMP64 "
"PCI_EXP_DEVCAP2_ATOMIC_COMP128"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3668
msgid ""
"Return 0 if all upstream bridges support AtomicOp routing, egress blocking "
"is disabled on all upstream ports, and the root port supports the requested "
"completion capabilities (32-bit, 64-bit and/or 128-bit AtomicOp completion), "
"or negative otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3745
msgid "Release a PCI bar"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3746
msgid ""
"PCI device whose resources were previously reserved by pci_request_region()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:524
#: ../drivers/pci/devres.c:600 ../drivers/pci/devres.c:649
#: ../drivers/pci/devres.c:715 ../drivers/pci/devres.c:823
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:102
#: ../drivers/pci/rebar.c:133 ../drivers/pci/rebar.c:153
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3749
#: ../drivers/pci/pci.c:3822 ../../../driver-api/pci/pci:7:
#: ../drivers/pci/iomap.c:18 ../drivers/pci/iomap.c:64
#: ../drivers/pci/iomap.c:113 ../drivers/pci/iomap.c:133
msgid "``int bar``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3748
msgid "BAR to release"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3749
msgid ""
"Releases the PCI I/O and memory resources previously reserved by a "
"successful call to pci_request_region().  Call this function only after all "
"use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3819
msgid "Reserve PCI I/O and memory resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3820
#: ../drivers/pci/pci.c:3879 ../drivers/pci/pci.c:3925
#: ../drivers/pci/pci.c:3944
msgid "PCI device whose resources are to be reserved"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3821
msgid "BAR to be reserved"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:601
#: ../drivers/pci/devres.c:671 ../drivers/pci/devres.c:716
#: ../drivers/pci/devres.c:792 ../../../driver-api/pci/pci:37:
#: ../drivers/pci/slot.c:193 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:3823 ../drivers/pci/pci.c:3882
#: ../drivers/pci/pci.c:3897 ../drivers/pci/pci.c:3927
#: ../drivers/pci/pci.c:3946 ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:342
#: ../drivers/pci/hotplug/pci_hotplug_core.c:375
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3822
msgid "name of the driver requesting the resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:275
#: ../drivers/pci/devres.c:320 ../drivers/pci/devres.c:365
#: ../drivers/pci/devres.c:422 ../drivers/pci/devres.c:526
#: ../drivers/pci/devres.c:602 ../drivers/pci/devres.c:672
#: ../drivers/pci/devres.c:717 ../drivers/pci/devres.c:793
#: ../drivers/pci/devres.c:826 ../../../driver-api/pci/pci:13:
#: ../drivers/pci/pci-driver.c:49 ../../../driver-api/pci/pci:19:
#: ../drivers/pci/search.c:424 ../../../driver-api/pci/pci:40:
#: ../drivers/pci/rebar.c:27 ../drivers/pci/rebar.c:44
#: ../drivers/pci/rebar.c:104 ../drivers/pci/rebar.c:135
#: ../drivers/pci/rebar.c:155 ../drivers/pci/rebar.c:290
#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:130
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1337
#: ../drivers/pci/iov.c:1363 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:3824 ../drivers/pci/pci.c:3883
#: ../drivers/pci/pci.c:3898 ../drivers/pci/pci.c:3947
#: ../drivers/pci/pci.c:4165 ../drivers/pci/pci.c:4201
#: ../drivers/pci/pci.c:4233 ../drivers/pci/pci.c:5949
#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:162
#: ../drivers/pci/tph.c:244 ../drivers/pci/tph.c:288 ../drivers/pci/tph.c:345
#: ../drivers/pci/tph.c:376
msgid "**Return**"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:365
#: ../drivers/pci/devres.c:672 ../drivers/pci/devres.c:793
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3824
#: ../drivers/pci/pci.c:3883 ../drivers/pci/pci.c:3898
#: ../drivers/pci/pci.c:3947
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3825
msgid ""
"Mark the PCI region associated with PCI device **pdev** BAR **bar** as being "
"reserved by owner **name**. Do not access any address inside the PCI regions "
"unless this call returns successfully."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3829
#: ../drivers/pci/pci.c:3931 ../drivers/pci/pci.c:3955
msgid ""
"Returns 0 on success, or ``EBUSY`` on error.  A warning message is also "
"printed on failure."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3840
msgid "Release selected PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3841
msgid "PCI device whose resources were previously reserved"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3843
#: ../drivers/pci/pci.c:3881 ../drivers/pci/pci.c:3896
msgid "``int bars``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3842
msgid "Bitmask of BARs to be released"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3843
msgid ""
"Release selected PCI I/O and memory resources previously reserved. Call this "
"function only after all use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3878
msgid "Reserve selected PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3880
msgid "Bitmask of BARs to be requested"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:670
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3881
msgid "Name of the driver requesting the resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3893
msgid "Request regions exclusively"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3894
msgid "PCI device to request regions from"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3895
msgid "bit mask of BARs to request"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:791
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3896
#: ../drivers/pci/pci.c:3926 ../drivers/pci/pci.c:3945
msgid "name of the driver requesting the resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3909
msgid "Release reserved PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3910
msgid ""
"PCI device whose resources were previously reserved by pci_request_regions()"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3912
msgid ""
"Releases all PCI I/O and memory resources previously reserved by a "
"successful call to pci_request_regions().  Call this function only after all "
"use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3924
#: ../drivers/pci/pci.c:3943
msgid "Reserve PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3927
#: ../drivers/pci/pci.c:3948
msgid ""
"Mark all PCI regions associated with PCI device **pdev** as being reserved "
"by owner **name**. Do not access any address inside the PCI regions unless "
"this call returns successfully."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3952
msgid ""
"pci_request_regions_exclusive() will mark the region so that /dev/mem and "
"the sysfs MMIO access will not be allowed."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4025
msgid "Remap the memory mapped I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:147
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4031
msgid "``const struct resource *res``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:146
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4026
msgid "Resource describing the I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:148
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4028
msgid "``phys_addr_t phys_addr``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:147
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4027
msgid "physical address of range to be mapped"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4028
msgid ""
"Remap the memory mapped I/O space described by the **res** and the CPU "
"physical address **phys_addr** into virtual address space.  Only "
"architectures that have memory mapped IO functions defined (and the "
"PCI_IOBASE value defined) should call this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4061
msgid "Unmap the memory mapped I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4062
msgid "resource to be unmapped"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4063
msgid ""
"Unmap the CPU virtual address **res** from virtual address space.  Only "
"architectures that have memory mapped IO functions defined (and the "
"PCI_IOBASE value defined) should call this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4135
msgid "enables bus-mastering for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4136
msgid "the PCI device to enable"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4137
msgid ""
"Enables bus-mastering on the device and calls pcibios_set_master() to do the "
"needed arch specific settings."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4149
msgid "disables bus-mastering for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4150
#: ../drivers/pci/pci.c:4248
msgid "the PCI device to disable"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4159
msgid "ensure the CACHE_LINE_SIZE register is programmed"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4160
msgid "the PCI device for which MWI is to be enabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4161
msgid ""
"Helper function for pci_set_mwi. Originally copied from drivers/net/acenic."
"c. Copyright 1998-2001 by Jes Sorensen, <jes**trained**-monkey.org>."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:276
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4166
#: ../drivers/pci/pci.c:4202 ../drivers/pci/pci.c:4234
msgid "An appropriate -ERRNO error value on error, or zero for success."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4197
#: ../drivers/pci/pci.c:4228
msgid "enables memory-write-invalidate PCI transaction"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:272
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4198
#: ../drivers/pci/pci.c:4229
msgid "the PCI device for which MWI is enabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4199
msgid "Enables the Memory-Write-Invalidate transaction in ``PCI_COMMAND``."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4230
msgid ""
"Enables the Memory-Write-Invalidate transaction in ``PCI_COMMAND``. Callers "
"are not required to check the return value."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4247
msgid "disables Memory-Write-Invalidate for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4249
msgid "Disables PCI Memory-Write-Invalidate transaction on the device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4284
msgid "enables/disables PCI INTx for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:317
#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:237
#: ../drivers/pci/irq.c:250 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:4285 ../drivers/pci/pci.c:4310
msgid "the PCI device to operate on"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:319
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4287
msgid "``int enable``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:318
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4286
msgid "boolean: whether to enable or disable PCI INTx"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4287
msgid "Enables/disables PCI INTx for device **pdev**"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4309
msgid "wait for pending transaction"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4311
msgid "Return 0 if transaction is pending 1 otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4325
#: ../drivers/pci/pci.c:4353
msgid "initiate a PCIe function level reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4326
#: ../drivers/pci/pci.c:4354
msgid "device to reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4327
msgid ""
"Initiate a function level reset unconditionally on **dev** without checking "
"any flags and DEVCAP"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4356
msgid "``bool probe``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4355
msgid "if true, return 0 if device can be reset this way"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4356
msgid "Initiate a function level reset on **dev**."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4783
msgid "Reset the secondary bus on a PCI bridge."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4784
msgid "Bridge device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4785
msgid ""
"Use the bridge control register to assert reset on the secondary bus. "
"Devices on the secondary bus are left in power-on state."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5024
msgid "reset a PCI device function while holding the **dev** mutex lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5026
#: ../drivers/pci/pci.c:5112 ../drivers/pci/pci.c:5159
#: ../drivers/pci/pci.c:5193
msgid "PCI device to reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5027
#: ../drivers/pci/pci.c:5113 ../drivers/pci/pci.c:5160
msgid ""
"Some devices allow an individual function to be reset without affecting "
"other functions in the same device.  The PCI device must be responsive to "
"PCI config space in order to use this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5031
msgid ""
"The device function is presumed to be unused and the caller is holding the "
"device mutex lock when this function is called."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5034
msgid ""
"Resetting the device will make the contents of PCI configuration space "
"random, so any caller of this must be prepared to reinitialise the device "
"including MSI, bus mastering, BARs, decoding IO and memory spaces, etc."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5039
#: ../drivers/pci/pci.c:5122 ../drivers/pci/pci.c:5170
msgid ""
"Returns 0 if the device function was successfully reset or negative if the "
"device doesn't support resetting a single function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5111
#: ../drivers/pci/pci.c:5158 ../drivers/pci/pci.c:5192
msgid "quiesce and reset a PCI device function"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5117
msgid ""
"This function does not just reset the PCI portion of a device, but clears "
"all the state associated with the device.  This function differs from "
"__pci_reset_function_locked() in that it saves and restores device state "
"over the reset and takes the PCI device lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5164
msgid ""
"This function does not just reset the PCI portion of a device, but clears "
"all the state associated with the device.  This function differs from "
"__pci_reset_function_locked() in that it saves and restores device state "
"over the reset.  It also differs from pci_reset_function() in that it "
"requires the PCI device lock to be held."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5194
msgid "Same as above, except return -EAGAIN if unable to lock device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5462
msgid "probe whether a PCI slot can be reset"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:315
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5468
msgid "``struct pci_slot *slot``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5463
msgid "PCI slot to probe"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5464
msgid ""
"Return 0 if slot can be reset, negative if a slot reset is not supported."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5565
msgid "probe whether a PCI bus can be reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5566
msgid "PCI bus to probe"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5567
msgid "Return 0 if bus can be reset, negative if a bus reset is not supported."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5603
msgid "Try to reset a PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5604
msgid "top level PCI device to reset via slot/bus"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5605
msgid "Same as above except return -EAGAIN if the bus cannot be locked"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5616
msgid "get PCI-X maximum designed memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5618
msgid ""
"Returns mmrbc: maximum designed memory read count in bytes or appropriate "
"error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5639
msgid "get PCI-X maximum memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5641
msgid ""
"Returns mmrbc: maximum memory read count in bytes or appropriate error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5662
msgid "set PCI-X maximum memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5665
msgid "``int mmrbc``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5664
msgid ""
"maximum memory read count in bytes valid values are 512, 1024, 2048, 4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5666
msgid ""
"If possible sets maximum memory read byte count, some bridges have errata "
"that prevent this."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5709
msgid "get PCI Express read request size"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5711
msgid ""
"Returns maximum memory read request in bytes or appropriate error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5725
msgid "set PCI Express maximum memory read request"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5728
msgid "``int rq``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5727
msgid ""
"maximum memory read count in bytes valid values are 128, 256, 512, 1024, "
"2048, 4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5729
msgid "If possible sets maximum memory read request in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5776
msgid "get PCI Express maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5778
msgid "Returns maximum payload size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5792
msgid "set PCI Express maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5795
msgid "``int mps``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5794
msgid ""
"maximum payload size in bytes valid values are 128, 256, 512, 1024, 2048, "
"4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5796
msgid "If possible sets maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5838
msgid ""
"determine minimum link settings of a PCIe device and its bandwidth limitation"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5842
msgid "``struct pci_dev **limiting_dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5841
msgid "storage for device causing the bandwidth limitation"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5843
msgid "``enum pci_bus_speed *speed``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5842
msgid "storage for speed of limiting device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5844
msgid "``enum pcie_link_width *width``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5843
msgid "storage for width of limiting device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5844
msgid ""
"Walk up the PCI device chain and find the point where the minimum bandwidth "
"is available.  Return the bandwidth available there and (if limiting_dev, "
"speed, and width pointers are supplied) information about that point.  The "
"bandwidth returned is in Mb/s, i.e., megabits/second of raw bandwidth."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5945
msgid "query for the PCI device's link speed capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5947
msgid "Query the PCI device speed capability."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5950
msgid "the maximum link speed supported by the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5959
msgid "query for the PCI device's link width capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5961
msgid ""
"Query the PCI device width capability.  Return the maximum link width "
"supported by the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6038
msgid "Report the PCI device's link speed and width"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6040
msgid "Report the available bandwidth at the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6050
msgid "Make BAR mask from the type of resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6051
msgid "the PCI device for which BAR mask is made"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6053
msgid "``unsigned long flags``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6052
msgid "resource type mask to be selected"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6053
msgid "This helper routine makes bar mask from the type of resource."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6515
msgid "allocate a PCI domain number per constraints"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6521
msgid "``u32 hint``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6516
msgid ""
"desired domain, 0 if any ID in the range of **min** to **max** is acceptable"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6518
msgid "``u32 min``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6517
msgid "minimum allowable domain"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6519
msgid "``u32 max``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6518
msgid "maximum allowable domain, no IDs higher than INT_MAX will be returned"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:15
#: ../drivers/pci/iomap.c:110
msgid "create a virtual mapping cookie for a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:16
#: ../drivers/pci/iomap.c:62 ../drivers/pci/iomap.c:111
#: ../drivers/pci/iomap.c:131
msgid "PCI device that owns the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:17
#: ../drivers/pci/iomap.c:63 ../drivers/pci/iomap.c:112
#: ../drivers/pci/iomap.c:132
msgid "BAR number"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:824
#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:19
#: ../drivers/pci/iomap.c:65
msgid "``unsigned long offset``"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:18
#: ../drivers/pci/iomap.c:64
msgid "map memory at the given offset in BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:525
#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:20
#: ../drivers/pci/iomap.c:66 ../drivers/pci/iomap.c:114
#: ../drivers/pci/iomap.c:134
msgid "``unsigned long maxlen``"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:19
#: ../drivers/pci/iomap.c:65
msgid "max length of the memory to map"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:20
#: ../drivers/pci/iomap.c:114
msgid ""
"Using this function you will get a __iomem address to your device BAR. You "
"can access it using ioread*() and iowrite*(). These functions hide the "
"details if this is a MMIO or PIO address space and will just do what you "
"expect from them in the correct way."
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:25
#: ../drivers/pci/iomap.c:72
msgid ""
"**maxlen** specifies the maximum length to map. If you want to get access to "
"the complete BAR from offset to the end, pass ``0`` here."
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:61
#: ../drivers/pci/iomap.c:130
msgid "create a virtual WC mapping cookie for a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:66
#: ../drivers/pci/iomap.c:134
msgid ""
"Using this function you will get a __iomem address to your device BAR. You "
"can access it using ioread*() and iowrite*(). These functions hide the "
"details if this is a MMIO or PIO address space and will just do what you "
"expect from them in the correct way. When possible write combining is used."
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:113
#: ../drivers/pci/iomap.c:133
msgid "length of the memory to map"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:119
#: ../drivers/pci/iomap.c:140
msgid ""
"**maxlen** specifies the maximum length to map. If you want to get access to "
"the complete BAR without checking for its length first, pass ``0`` here."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:144
msgid "Managed pci_remap_iospace()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:150
#: ../drivers/pci/devres.c:181 ../drivers/pci/devres.c:211
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:145
#: ../drivers/pci/devres.c:176
msgid "Generic device to remap IO address for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:148
msgid ""
"Managed pci_remap_iospace().  Map is automatically unmapped on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:175
msgid "Managed pci_remap_cfgspace()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:178
msgid "``resource_size_t offset``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:177
msgid "Resource address to map"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:179
#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:253
msgid "``resource_size_t size``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:178
msgid "Size of map"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:179
msgid ""
"Managed pci_remap_cfgspace().  Map is automatically unmapped on driver "
"detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:205
msgid "check, request region and ioremap cfg resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:206
msgid "generic device to handle the resource for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:207
msgid "configuration space resource to be handled"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:208
msgid ""
"Checks that a resource is a valid memory region, requests the memory region "
"and ioremaps with pci_remap_cfgspace() API that ensures the proper PCI "
"configuration space memory attributes are guaranteed."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:212
msgid "All operations are managed and will be undone on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:214
msgid ""
"Returns a pointer to the remapped memory or an IOMEM_ERR_PTR() encoded error "
"code on failure. Usage example::"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:271
msgid "a device-managed pci_set_mwi()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:273
msgid "Managed pci_set_mwi()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:316
msgid "managed pci_intx()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:320
msgid "0 on success, -ENOMEM on error."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:321
msgid ""
"Enable/disable PCI INTx for device **pdev**. Restore the original state on "
"driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:362
msgid "Managed pci_enable_device()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:366
msgid ""
"Managed pci_enable_device(). Device will automatically be disabled on driver "
"detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:396
msgid "Pin managed PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:397
msgid "PCI device to pin"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:398
msgid ""
"Pin managed PCI device **pdev**. Pinned device won't be disabled on driver "
"detach. **pdev** must have been enabled with pcim_enable_device()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:419
msgid "access iomap allocation table (DEPRECATED)"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:420
msgid "PCI device to access iomap table for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:422
msgid "Const pointer to array of __iomem pointers on success, NULL on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:424
msgid ""
"Access iomap allocation table for **dev**.  If iomap table doesn't exist and "
"**pdev** is managed, it will be allocated.  All iomaps recorded in the iomap "
"table are automatically unmapped on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:429
msgid ""
"This function might sleep when the table is first allocated but can be "
"safely called without context and guaranteed to succeed once allocated."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:433
msgid ""
"This function is DEPRECATED. Do not use it in new code. Instead, obtain a "
"mapping's address directly from one of the pcim_* mapping functions. For"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:436
msgid "**example**"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:436
msgid "void __iomem \\*mappy = pcim_iomap(pdev, bar, length);"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:521
msgid "Managed pcim_iomap()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:522
msgid "PCI device to iomap for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:523
msgid "BAR to iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:524
msgid "Maximum length of iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:526
msgid "__iomem pointer on success, NULL on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:527
msgid ""
"Managed pci_iomap(). Map is automatically unmapped on driver detach. If "
"desired, unmap manually only with pcim_iounmap()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:530
msgid "This SHOULD only be used once per BAR."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:533
msgid ""
"Contrary to the other pcim_* functions, this function does not return an "
"IOMEM_ERR_PTR() on failure, but a simple NULL. This is done for backwards "
"compatibility."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:571
msgid "Managed pci_iounmap()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:572
msgid "PCI device to iounmap for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:574
msgid "``void __iomem *addr``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:573
msgid "Address to unmap"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:574
msgid ""
"Managed pci_iounmap(). **addr** must have been mapped using a pcim_* mapping "
"function."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:597
msgid "Request and iomap a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:598
#: ../drivers/pci/devres.c:668 ../drivers/pci/devres.c:790
#: ../drivers/pci/devres.c:821
msgid "PCI device to map IO resources for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:599
msgid "Index of a BAR to map"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:600
#: ../drivers/pci/devres.c:715
msgid "Name of the driver requesting the resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:602
#: ../drivers/pci/devres.c:826
msgid "__iomem pointer on success, an IOMEM_ERR_PTR on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:603
msgid ""
"Mapping and region will get automatically released on driver detach. If "
"desired, release manually only with pcim_iounmap_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:646
msgid "Unmap and release a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:647
#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:20
#: ../drivers/pci/irq.c:64
msgid "PCI device to operate on"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:648
msgid "Index of BAR to unmap and release"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:649
msgid ""
"Unmap a BAR and release its region manually. Only pass BARs that were "
"previously mapped by pcim_iomap_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:667
msgid "Request and iomap PCI BARs (DEPRECATED)"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:670
msgid "``int mask``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:669
msgid "Mask of BARs to request and iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:673
msgid "Request and iomap regions specified by **mask**."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:675
msgid ""
"This function is DEPRECATED. Do not use it in new code. Use "
"pcim_iomap_region() instead."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:712
msgid "Request a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:713
msgid "PCI device to request region for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:714
msgid "Index of BAR to request"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:717
msgid "0 on success, a negative error code on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:718
msgid "Request region specified by **bar**."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:720
msgid ""
"The region will automatically be released on driver detach. If desired, "
"release manually only with pcim_release_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:789
msgid "Request all regions"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:794
msgid ""
"Requested regions will automatically be released at driver detach. If "
"desired, release individual regions with pcim_release_region() or all of "
"them at once with pcim_release_all_regions()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:820
msgid "Create a ranged __iomap mapping within a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:822
msgid "Index of the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:823
msgid "Offset from the begin of the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:825
msgid "``unsigned long len``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:824
msgid "Length in bytes for the mapping"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:827
msgid ""
"Creates a new IO-Mapping within the specified **bar**, ranging from "
"**offset** to **offset** + **len**."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:830
msgid ""
"The mapping will automatically get unmapped on driver detach. If desired, "
"release manually only with pcim_iounmap()."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:33
msgid "add a new PCI device ID to this driver and re-probe devices"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:39
#: ../drivers/pci/pci-driver.c:1429 ../drivers/pci/pci-driver.c:1459
msgid "``struct pci_driver *drv``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:34
msgid "target pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:36
#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:331
#: ../drivers/pci/search.c:356
msgid "``unsigned int vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:35
msgid "PCI vendor ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:37
#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:328
#: ../drivers/pci/search.c:353
msgid "``unsigned int device``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:36
msgid "PCI device ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:38
msgid "``unsigned int subvendor``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:37
msgid "PCI subvendor ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:39
msgid "``unsigned int subdevice``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:38
msgid "PCI subdevice ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:40
#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:390
#: ../drivers/pci/search.c:419
msgid "``unsigned int class``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:39
msgid "PCI class"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:41
msgid "``unsigned int class_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:40
msgid "PCI class mask"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:42
msgid "``unsigned long driver_data``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:41
msgid "private driver data"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:42
msgid ""
"Adds a new dynamic pci device ID to this driver and causes the driver to "
"probe for all devices again.  **drv** must have been registered prior to "
"calling this function."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:46
msgid "**Context**"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:47
msgid "Does GFP_KERNEL allocation."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:50
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:94
msgid "See if a PCI device matches a given pci_id table"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:100
#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:450
msgid "``const struct pci_device_id *ids``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:95
msgid "array of PCI device ID structures to search in"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:96
msgid "the PCI device structure to match against."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:97
msgid ""
"Used by a driver to check whether a PCI device is in its list of supported "
"devices.  Returns the matching pci_device_id structure or ``NULL`` if there "
"is no match."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:101
msgid ""
"Deprecated; don't use this as it will not catch any dynamic IDs that a "
"driver might want to check for."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1423
msgid "register a new pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1424
msgid "the driver structure to register"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1426
#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:343
#: ../drivers/pci/hotplug/pci_hotplug_core.c:376
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1425
msgid "owner module of drv"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1427
#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:344
#: ../drivers/pci/hotplug/pci_hotplug_core.c:377
msgid "``const char *mod_name``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1426
msgid "module name string"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1427
msgid ""
"Adds the driver structure to the list of registered drivers. Returns a "
"negative value on error, otherwise 0. If no error occurred, the driver "
"remains registered even if no device was claimed during registration."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1453
msgid "unregister a pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1454
msgid "the driver structure to unregister"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1455
msgid ""
"Deletes the driver structure from the list of registered PCI drivers, gives "
"it a chance to clean up by calling its remove() function for each device it "
"was responsible for, and marks those devices as driverless."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1474
msgid "get the pci_driver of a device"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1475
msgid "the device to query"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1476
msgid ""
"Returns the appropriate pci_driver structure or ``NULL`` if there is no "
"registered driver for the device."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1522
msgid "increments the reference count of the pci device structure"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1523
msgid "the device being referenced"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1524
msgid "Each live reference to a device should be refcounted."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1526
msgid ""
"Drivers for PCI devices should normally record such references in their "
"probe() methods, when they bind to a device, and release them by calling "
"pci_dev_put(), in their disconnect() methods."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1530
msgid ""
"A pointer to the device with the incremented reference counter is returned."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1542
msgid "release a use of the pci device structure"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1543
msgid "device that's been disconnected"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1544
msgid ""
"Must be called when a user of a device is finished with it.  When the last "
"user of the device calls this function, the memory of the device is freed."
msgstr ""

#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:137
msgid "remove a PCI device and any children"
msgstr ""

#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:138
msgid "the device to remove"
msgstr ""

#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:139
msgid ""
"Remove a PCI device from the device lists, informing the drivers that the "
"device has been removed.  We also remove any subordinate buses and children "
"in a depth-first manner."
msgstr ""

#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:143
msgid ""
"For each device we remove, delete the device structure from the device "
"lists, remove the /proc entry, and notify userspace (/sbin/hotplug)."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:133
msgid "locate PCI bus from a given domain and bus number"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:139
#: ../drivers/pci/search.c:220
msgid "``int domain``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:134
msgid "number of PCI domain to search"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:136
msgid "``int busnr``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:135
msgid "number of desired PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:136
msgid ""
"Given a PCI bus number and domain number, the desired PCI bus is located in "
"the global list of PCI buses.  If the bus is found, a pointer to its data "
"structure is returned.  If no bus is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:158
msgid "begin or continue searching for a PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:164
msgid "``const struct pci_bus *from``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:159
msgid "Previous PCI bus found, or ``NULL`` for new search."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:160
msgid ""
"Iterates through the list of known PCI buses.  A new search is initiated by "
"passing ``NULL`` as the **from** argument.  Otherwise if **from** is not "
"``NULL``, searches continue from next device on the global list."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:181
msgid "locate PCI device for a given PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:182
#: ../drivers/pci/search.c:216
msgid "PCI bus on which desired PCI device resides"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:183
#: ../drivers/pci/search.c:217
msgid ""
"encodes number of PCI slot in which the desired PCI device resides and the "
"logical device number within that slot in case of multi-function devices."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:186
msgid ""
"Given a PCI bus and slot/function number, the desired PCI device is located "
"in the list of PCI devices. If the device is found, its reference count is "
"increased and this function returns a pointer to its data structure.  The "
"caller must decrement the reference count by calling pci_dev_put(). If no "
"device is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:214
msgid "locate PCI device for a given PCI domain (segment), bus, and slot"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:215
msgid "PCI domain/segment on which the PCI device resides."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:217
msgid "``unsigned int bus``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:220
msgid ""
"Given a PCI domain, bus, and slot/function number, the desired PCI device is "
"located in the list of PCI devices. If the device is found, its reference "
"count is increased and this function returns a pointer to its data "
"structure.  The caller must decrement the reference count by calling "
"pci_dev_put().  If no device is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:325
msgid ""
"begin or continue searching for a PCI device by vendor/subvendor/device/"
"subdevice id"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:326
#: ../drivers/pci/search.c:351
msgid "PCI vendor id to match, or ``PCI_ANY_ID`` to match all vendor ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:327
#: ../drivers/pci/search.c:352
msgid "PCI device id to match, or ``PCI_ANY_ID`` to match all device ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:329
msgid "``unsigned int ss_vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:328
msgid ""
"PCI subsystem vendor id to match, or ``PCI_ANY_ID`` to match all vendor ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:330
msgid "``unsigned int ss_device``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:329
msgid ""
"PCI subsystem device id to match, or ``PCI_ANY_ID`` to match all device ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:331
#: ../drivers/pci/search.c:354 ../drivers/pci/search.c:387
#: ../drivers/pci/search.c:416
msgid "``struct pci_dev *from``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:330
#: ../drivers/pci/search.c:353 ../drivers/pci/search.c:386
#: ../drivers/pci/search.c:415
msgid "Previous PCI device found in search, or ``NULL`` for new search."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:331
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **vendor**, **device**, **ss_vendor** and **ss_device**, a "
"pointer to its device structure is returned, and the reference count to the "
"device is incremented.  Otherwise, ``NULL`` is returned.  A new search is "
"initiated by passing ``NULL`` as the **from** argument.  Otherwise if "
"**from** is not ``NULL``, searches continue from next device on the global "
"list. The reference count for **from** is always decremented if it is not "
"``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:350
msgid "begin or continue searching for a PCI device by vendor/device id"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:354
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **vendor** and **device**, the reference count to the device "
"is incremented and a pointer to its device structure is returned. Otherwise, "
"``NULL`` is returned.  A new search is initiated by passing ``NULL`` as the "
"**from** argument.  Otherwise if **from** is not ``NULL``, searches continue "
"from next device on the global list.  The reference count for **from** is "
"always decremented if it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:384
msgid "begin or continue searching for a PCI device by class"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:385
msgid "search for a PCI device with this class designation"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:387
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **class**, the reference count to the device is incremented "
"and a pointer to its device structure is returned. Otherwise, ``NULL`` is "
"returned. A new search is initiated by passing ``NULL`` as the **from** "
"argument. Otherwise if **from** is not ``NULL``, searches continue from next "
"device on the global list.  The reference count for **from** is always "
"decremented if it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:413
msgid "searching for a PCI device by matching against the base class code only"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:414
msgid "search for a PCI device with this base class code"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:416
msgid ""
"Iterates through the list of known PCI devices. If a PCI device is found "
"with a matching base class code, the reference count to the device is "
"incremented. See pci_match_one_device() to figure out how does this works. A "
"new search is initiated by passing ``NULL`` as the **from** argument. "
"Otherwise if **from** is not ``NULL``, searches continue from next device on "
"the global list. The reference count for **from** is always decremented if "
"it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:425
msgid "A pointer to a matched PCI device, ``NULL`` Otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:444
msgid "Returns 1 if device matching the device list is present, 0 if not."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:445
msgid ""
"A pointer to a null terminated list of struct pci_device_id structures that "
"describe the type of PCI device the caller is trying to find."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:447
msgid ""
"Obvious fact: You do not have a reference to any device that might be found "
"by this function, so if that device is removed from the system right after "
"this function is finished, the value will be stale.  Use this function to "
"find devices that are usually built into a system, or for a general hint as "
"to if another device happens to be present at this specific moment in time."
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:131
msgid "Generic IRQ chip callback to mask PCI/MSI interrupts"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:137
#: ../drivers/pci/msi/msi.c:149
msgid "``struct irq_data *data``"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:132
#: ../drivers/pci/msi/msi.c:144
msgid "pointer to irqdata associated to that interrupt"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:143
msgid "Generic IRQ chip callback to unmask PCI/MSI interrupts"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:473
msgid "Return the number of MSI vectors a device can send"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:474
msgid "device to report about"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:475
msgid ""
"This function returns the number of MSI vectors a device requested via "
"Multiple Message Capable register. It returns a negative errno if the device "
"is not capable sending MSI interrupts. Otherwise, the call succeeds and "
"returns a power of two, up to a maximum of 2^5 (32), according to the MSI "
"specification."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:249
msgid "allocate a resource from a parent bus"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:250
msgid "PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:251
msgid "resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:252
msgid "size of resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:254
msgid "``resource_size_t align``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:253
msgid "alignment of resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:255
msgid "``resource_size_t min``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:254
msgid "minimum /proc/iomem address to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:256
msgid "``unsigned long type_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:255
msgid "IORESOURCE_* type flags"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:257
msgid "``resource_alignf alignf``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:256
msgid "resource alignment function"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:258
msgid "``void *alignf_data``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:257
msgid "data argument for resource alignment function"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:258
msgid ""
"Given the PCI bus a device resides on, the size, minimum address, alignment "
"and type, try to find an acceptable resource allocation for a specific "
"device resource."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:339
msgid "start driver for a single device"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:340
msgid "device to add"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:341
msgid "This adds add sysfs entries and start device drivers"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:392
msgid "start driver for PCI devices"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:398
msgid "``const struct pci_bus *bus``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:393
msgid "bus to check for new devices"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:394
msgid "Start driver for PCI devices and add some sysfs entries."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:461
#: ../drivers/pci/bus.c:482
msgid "walk devices on/under bus, calling callback."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:467
#: ../drivers/pci/bus.c:488
msgid "``struct pci_bus *top``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:462
#: ../drivers/pci/bus.c:483
msgid "bus whose devices should be walked"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:464
#: ../drivers/pci/bus.c:485
msgid "``int (*cb)(struct pci_dev *, void *)``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:463
#: ../drivers/pci/bus.c:484
msgid "callback to be called for each device found"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:465
#: ../drivers/pci/bus.c:486
msgid "``void *userdata``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:464
#: ../drivers/pci/bus.c:485
msgid "arbitrary pointer to be passed to callback"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:465
msgid ""
"Walk the given bus, including any bridged devices on buses under this bus.  "
"Call the provided callback on each device found."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:469
msgid ""
"We check the return of **cb** each time. If it returns anything other than "
"0, we break out."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:486
msgid "Same semantics as pci_walk_bus(), but walks the bus in reverse order."
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:187
msgid "Set raw operations of pci bus"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:188
msgid "pci bus struct"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:190
msgid "``struct pci_ops *ops``"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:189
msgid "new raw operations"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:190
msgid "Return previous raw operations"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:281
msgid "Lock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:282
#: ../drivers/pci/access.c:302 ../drivers/pci/access.c:326
msgid "pci device struct"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:283
msgid ""
"When access is locked, any userspace reads or writes to config space and "
"concurrent lock requests will sleep until access is allowed via "
"pci_cfg_access_unlock() again."
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:301
msgid "try to lock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:303
msgid ""
"Same as pci_cfg_access_lock, but will return 0 if access is already locked, "
"1 otherwise. This function can be used from atomic contexts."
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:325
msgid "Unlock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:327
msgid "This function allows PCI config accesses to resume."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:19
msgid "allocate an interrupt line for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:22
#: ../drivers/pci/irq.c:66
msgid "``unsigned int nr``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:21
#: ../drivers/pci/irq.c:65
msgid "device-relative interrupt vector index (0-based)."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:23
msgid "``irq_handler_t handler``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:22
msgid ""
"Function to be called when the IRQ occurs. Primary handler for threaded "
"interrupts. If NULL and thread_fn != NULL the default primary handler is "
"installed."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:27
msgid "``irq_handler_t thread_fn``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:26
msgid ""
"Function called from the IRQ handler thread If NULL, no IRQ thread is created"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:29
#: ../drivers/pci/irq.c:67
msgid "``void *dev_id``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:28
msgid "Cookie passed back to the handler function"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:30
msgid "``const char *fmt``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:29
msgid "Printf-like format string naming the handler"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:31
msgid "``...``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:30
msgid ""
"This call allocates interrupt resources and enables the interrupt line and "
"IRQ handling. From the point this call is made **handler** and **thread_fn** "
"may be invoked.  All interrupts requested using this function might be "
"shared."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:34
msgid "**dev_id** must not be NULL and must be globally unique."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:63
msgid "free an interrupt allocated with pci_request_irq"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:66
msgid "Device identity to free"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:67
msgid ""
"Remove an interrupt handler. The handler is removed and if the interrupt "
"line is no longer in use by any driver it is disabled.  The caller must "
"ensure the interrupt is disabled on the device before calling this function. "
"The function does not return until any executing interrupts for this IRQ "
"have completed."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:73
msgid "This function must not be called from interrupt context."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:122
msgid "swizzle INTx all the way to root bridge"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:125
msgid "``u8 *pinp``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:124
msgid "pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:125
msgid ""
"Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI "
"bridges all the way up to a PCI root bus."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:236
msgid "mask INTx on pending interrupt"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:238
msgid ""
"Check if the device dev has its INTx line asserted, mask it and return true "
"in that case. False is returned if no interrupt was pending."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:249
msgid "unmask INTx if no interrupt is pending"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:251
msgid ""
"Check if the device dev has its INTx line asserted, unmask it if not and "
"return true. False is returned and the mask remains active if there was "
"still an interrupt pending."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2324
msgid "Probe for PCIe relaxed ordering enable"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2326
msgid "Returns true if the device has enabled relaxed ordering attribute."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2888
msgid "Scan a PCI slot on a bus for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2889
#: ../drivers/pci/probe.c:3519
msgid "PCI bus to scan"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2891
msgid "``int devfn``"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2890
msgid "slot number to scan (must have zero function)"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2891
msgid ""
"Scan a PCI slot on the specified PCI bus for devices, adding discovered "
"devices to the **bus->devices** list.  New devices will not have is_added "
"set."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2895
msgid "Returns the number of new devices found."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3231
msgid "Scan devices below a bus"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3232
msgid "Bus to scan for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3233
msgid ""
"Scans devices below **bus** including subordinate buses. Returns new "
"subordinate number including all the found devices."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3518
msgid "Scan a PCI bus for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3520
msgid ""
"Scan a PCI bus and child buses for new devices, add them, and enable them."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3523
msgid "Returns the max number of subordinate bus discovered."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:189
msgid "create or increment refcount for physical PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:195
msgid "``struct pci_bus *parent``"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:190
msgid "struct pci_bus of parent bridge"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:192
msgid "``int slot_nr``"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:191
msgid "PCI_SLOT(pci_dev->devfn) or -1 for placeholder"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:192
msgid "user visible string presented in /sys/bus/pci/slots/<name>"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:194
msgid "``struct hotplug_slot *hotplug``"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:193
msgid "set if caller is hotplug driver, NULL otherwise"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:194
msgid ""
"PCI slots have first class attributes such as address, speed, width, and a :"
"c:type:`struct pci_slot <pci_slot>` is used to manage them. This interface "
"will either return a new :c:type:`struct pci_slot <pci_slot>` to the caller, "
"or if the pci_slot already exists, its refcount will be incremented."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:199
msgid "Slots are uniquely identified by a **pci_bus**, **slot_nr** tuple."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:201
msgid ""
"There are known platforms with broken firmware that assign the same name to "
"multiple slots. Workaround these broken platforms by renaming the slots on "
"behalf of the caller. If firmware assigns name N to multiple slots:"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:206
msgid ""
"The first slot is assigned N The second slot is assigned N-1 The third slot "
"is assigned N-2 etc."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:211
msgid ""
"Placeholder slots: In most cases, **pci_bus**, **slot_nr** will be "
"sufficient to uniquely identify a slot. There is one notable exception - "
"pSeries (rpaphp), where the **slot_nr** cannot be determined until a device "
"is actually inserted into the slot. In this scenario, the caller may pass -1 "
"for **slot_nr**."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:217
msgid ""
"The following semantics are imposed when the caller passes **slot_nr** == "
"-1. First, we no longer check for an existing ``struct`` pci_slot, as there "
"may be many slots with **slot_nr** of -1.  The other change in semantics is "
"user-visible, which is the 'address' parameter presented in sysfs will "
"consist solely of a dddd:bb tuple, where dddd is the PCI domain of the "
"``struct`` pci_bus and bb is the bus number. In other words, the devfn of "
"the 'placeholder' slot will not be displayed."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:309
msgid "decrement refcount for physical PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:310
msgid "struct pci_slot to decrement"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:311
msgid ""
"``struct`` pci_slot is refcounted, so destroying them is really easy; we "
"just call kobject_put on its kobj and let our release methods do the rest."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:22
msgid "Convert size in bytes to PCI BAR Size"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:28
msgid "``u64 bytes``"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:23
msgid "size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:24
msgid ""
"Convert size in bytes to encoded BAR Size in Resizable BAR Capability (PCIe "
"r6.2, sec. 7.8.6.3)."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:28
#: ../drivers/pci/rebar.c:42
msgid "encoded BAR Size as defined in the PCIe spec (0=1MB, 31=128TB)"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:41
msgid "Convert encoded BAR Size to size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:47
#: ../drivers/pci/rebar.c:134 ../drivers/pci/rebar.c:279
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1331
msgid "``int size``"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:44
msgid "BAR size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:99
msgid "get possible sizes for Resizable BAR"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:100
#: ../drivers/pci/rebar.c:131 ../drivers/pci/rebar.c:151
#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:237
#: ../drivers/pci/tph.c:281 ../drivers/pci/tph.c:343 ../drivers/pci/tph.c:365
msgid "PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:101
#: ../drivers/pci/rebar.c:152
msgid "BAR to query"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:102
msgid "Get the possible sizes of a resizable BAR as bitmask."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:105
msgid ""
"A bitmask of possible sizes (bit 0=1MB, bit 31=128TB), or ``0`` if BAR isn't "
"resizable."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:130
msgid "check if size is supported for BAR"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:132
msgid "BAR to check"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:133
msgid "encoded size as defined in the PCIe spec (0=1MB, 31=128TB)"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:135
msgid ""
"``true`` if **bar** is resizable and **size** is supported, otherwise "
"``false``."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:150
msgid "get the maximum supported size of a BAR"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:153
msgid "Get the largest supported size of a resizable BAR as a size."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:156
msgid ""
"the encoded maximum BAR size as defined in the PCIe spec (0=1MB, 31=128TB), "
"or ``-NOENT`` on error."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:275
msgid "reconfigure a Resizable BAR and resources"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:278
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1330
#: ../drivers/pci/iov.c:1359
msgid "``int resno``"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:277
msgid "index of the BAR to be resized"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:278
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1330
msgid "new size as defined in the spec (0=1MB, 31=128TB)"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:280
msgid "``int exclude_bars``"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:279
msgid "a mask of BARs that should not be released"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:280
msgid ""
"Reconfigure **resno** to **size** and re-run resource assignment algorithm "
"with the new size."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:283
msgid ""
"Prior to resize, release **dev** resources that share a bridge window with "
"**resno**.  This unpins the bridge window resource to allow changing it."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:286
msgid ""
"The caller may prevent releasing a particular BAR by providing "
"**exclude_bars** mask, but this may result in the resize operation failing "
"due to insufficient space."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:291
msgid ""
"0 on success, or negative on error. In case of an error, the resources are "
"restored to their original places."
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:16
msgid "enable ROM decoding for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:17
msgid "PCI device to enable"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:18
msgid ""
"Enable ROM decoding on **dev**.  This involves simply turning on the last "
"bit of the PCI ROM BAR.  Note that some cards may share address decoders "
"between the ROM and other resources, so enabling it may disable access to "
"MMIO registers or other card memory."
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:52
msgid "disable ROM decoding for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:53
msgid "PCI device to disable"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:54
msgid ""
"Disable ROM decoding on a PCI device by turning off the last bit in the ROM "
"BAR."
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:126
msgid "map a PCI ROM to kernel space"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:127
#: ../drivers/pci/rom.c:182
msgid "pointer to pci device struct"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:129
msgid "``size_t *size``"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:128
msgid "pointer to receive size of pci window over ROM"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:130
msgid "kernel virtual pointer to image of ROM"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:131
msgid ""
"Map a PCI ROM into kernel space. If ROM is boot video ROM, the shadow BIOS "
"copy will be returned instead of the actual ROM."
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:181
msgid "unmap the ROM from kernel space"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:184
msgid "``void __iomem *rom``"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:183
msgid "virtual address of the previous mapping"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:184
msgid "Remove a mapping of a previously mapped ROM"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:55
msgid "Return the drvdata of a PF"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:56
msgid "VF pci_dev"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:58
msgid "``struct pci_driver *pf_driver``"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:57
msgid "Device driver required to own the PF"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:58
msgid ""
"This must be called from a context that ensures that a VF driver is "
"attached. The value returned is invalid once the VF driver completes its "
"remove() callback."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:62
msgid ""
"Locking is achieved by the driver core. A VF driver cannot be probed until "
"pci_enable_sriov() is called and pci_disable_sriov() does not return until "
"all VF drivers have completed their remove()."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:66
msgid ""
"The PF driver must call pci_disable_sriov() before it begins to destroy the "
"drvdata."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1155
msgid "enable the SR-IOV capability"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1158
#: ../drivers/pci/iov.c:1294
msgid "``int nr_virtfn``"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1157
msgid "number of virtual functions to enable"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1158
msgid "Returns 0 on success, or negative on failure."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1173
msgid "disable the SR-IOV capability"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1188
msgid "return number of VFs associated with a PF device_release_driver"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1190
msgid "Returns number of VFs, or 0 if SR-IOV is not enabled."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1203
msgid "returns number of VFs are assigned to a guest"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1205
msgid ""
"Returns number of VFs belonging to this device that are assigned to a guest. "
"If device is not a physical function returns 0."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1244
msgid "reduce the TotalVFs available"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1245
#: ../drivers/pci/iov.c:1275
msgid "the PCI PF device"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1247
msgid "``u16 numvfs``"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1246
msgid "number that should be used for TotalVFs supported"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1247
msgid ""
"Should be called from PF driver's probe routine with device's mutex held."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1250
msgid ""
"Returns 0 if PF is an SRIOV-capable device and value of numvfs valid. If not "
"a PF return -ENOSYS; if numvfs is invalid return -EINVAL; if VFs already "
"enabled, return -EBUSY."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1274
msgid "get total VFs supported on this device"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1276
msgid ""
"For a PCIe device with SRIOV support, return the PCIe SRIOV capability value "
"of TotalVFs or the value of driver_max_VFs if the driver reduced it.  "
"Otherwise 0."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1291
msgid "helper to configure SR-IOV"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1293
msgid "number of virtual functions to enable, 0 to disable"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1294
msgid ""
"Enable or disable SR-IOV for devices that don't require any PF setup before "
"enabling SR-IOV.  Return value is negative on error, or number of VFs "
"allocated on success."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1327
msgid "set a new size for a VF BAR"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1329
#: ../drivers/pci/iov.c:1358
msgid "the resource number"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1331
msgid ""
"Set the new size of a VF BAR that supports VF resizable BAR capability. "
"Unlike pci_resize_resource(), this does not cause the resource that reserves "
"the MMIO space (originally up to total_VFs) to be resized, which means that "
"following calls to pci_enable_sriov() can fail if the resources no longer "
"fit."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1338
msgid "0 on success, or negative on failure."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1356
msgid "get VF BAR sizes allowing to create up to num_vfs"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1360
msgid "``int num_vfs``"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1359
msgid "number of VFs"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1360
msgid ""
"Get the sizes of a VF resizable BAR that can accommodate **num_vfs** within "
"the currently assigned size of the resource **resno**."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1364
msgid ""
"A bitmask of sizes in format defined in the spec (bit 0=1MB, bit 31=128TB)."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:921
msgid "read byte(s) from legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:927
#: ../drivers/pci/pci-sysfs.c:952 ../drivers/pci/pci-sysfs.c:977
#: ../drivers/pci/pci-sysfs.c:997 ../drivers/pci/pci-sysfs.c:1337
#: ../drivers/pci/pci-sysfs.c:1362
msgid "``struct file *filp``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:922
#: ../drivers/pci/pci-sysfs.c:947 ../drivers/pci/pci-sysfs.c:972
#: ../drivers/pci/pci-sysfs.c:992
msgid "open sysfs file"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:924
#: ../drivers/pci/pci-sysfs.c:949 ../drivers/pci/pci-sysfs.c:974
#: ../drivers/pci/pci-sysfs.c:994 ../drivers/pci/pci-sysfs.c:1104
#: ../drivers/pci/pci-sysfs.c:1334 ../drivers/pci/pci-sysfs.c:1359
msgid "``struct kobject *kobj``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:923
#: ../drivers/pci/pci-sysfs.c:948
msgid "kobject corresponding to file to read from"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:925
#: ../drivers/pci/pci-sysfs.c:950 ../drivers/pci/pci-sysfs.c:1335
#: ../drivers/pci/pci-sysfs.c:1360
msgid "``const struct bin_attribute *bin_attr``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:924
#: ../drivers/pci/pci-sysfs.c:949 ../drivers/pci/pci-sysfs.c:974
#: ../drivers/pci/pci-sysfs.c:994 ../drivers/pci/pci-sysfs.c:1334
#: ../drivers/pci/pci-sysfs.c:1359
msgid "struct bin_attribute for this file"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:926
#: ../drivers/pci/pci-sysfs.c:951 ../drivers/pci/pci-sysfs.c:1336
#: ../drivers/pci/pci-sysfs.c:1361
msgid "``char *buf``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:925
msgid "buffer to store results"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:927
#: ../drivers/pci/pci-sysfs.c:952 ../drivers/pci/pci-sysfs.c:1337
#: ../drivers/pci/pci-sysfs.c:1362
msgid "``loff_t off``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:926
#: ../drivers/pci/pci-sysfs.c:951
msgid "offset into legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:928
#: ../drivers/pci/pci-sysfs.c:953 ../drivers/pci/pci-sysfs.c:1338
#: ../drivers/pci/pci-sysfs.c:1363
msgid "``size_t count``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:927
#: ../drivers/pci/pci-sysfs.c:1362
msgid "number of bytes to read"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:928
msgid ""
"Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific "
"callback routine (pci_legacy_read)."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:946
msgid "write byte(s) to legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:950
msgid "buffer containing value to be written"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:952
msgid "number of bytes to write"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:953
msgid ""
"Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific "
"callback routine (pci_legacy_write)."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:971
msgid "map legacy PCI memory into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:973
#: ../drivers/pci/pci-sysfs.c:993
msgid "kobject corresponding to device to be mapped"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:975
#: ../drivers/pci/pci-sysfs.c:995 ../drivers/pci/pci-sysfs.c:1101
msgid "``const struct bin_attribute *attr``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:976
#: ../drivers/pci/pci-sysfs.c:996 ../drivers/pci/pci-sysfs.c:1102
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:975
#: ../drivers/pci/pci-sysfs.c:995
msgid "struct vm_area_struct passed to mmap"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:976
msgid ""
"Uses an arch specific callback, pci_mmap_legacy_mem_page_range, to mmap "
"legacy memory space (first meg of bus space) into application virtual memory "
"space."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:991
msgid "map legacy PCI IO into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:996
msgid ""
"Uses an arch specific callback, pci_mmap_legacy_io_page_range, to mmap "
"legacy IO space (first meg of bus space) into application virtual memory "
"space. Returns -ENOSYS if the operation isn't supported"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1011
msgid "adjustment of legacy file attributes"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1017
#: ../drivers/pci/pci-sysfs.c:1029
msgid "``struct pci_bus *b``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1012
#: ../drivers/pci/pci-sysfs.c:1024
msgid "bus to create files under"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1014
msgid "``enum pci_mmap_state mmap_type``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1013
msgid "I/O port or memory"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1014
msgid "Stub implementation. Can be overridden by arch if necessary."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1023
msgid "create legacy I/O port and memory files"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1025
msgid ""
"Some platforms allow access to legacy I/O port and ISA memory space on a per-"
"bus basis.  This routine creates the files and ties them into their "
"associated read, write and mmap files from pci-sysfs.c"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1029
msgid ""
"On error unwind, but don't propagate the error to the caller as it is ok to "
"set up the PCI bus without these files."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1098
msgid "map a PCI resource into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1099
msgid "kobject for mapping"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1100
msgid "struct bin_attribute for the file being mapped"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1101
msgid "struct vm_area_struct passed into the mmap"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1103
msgid "``int write_combine``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1102
msgid "1 for write_combine mapping"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1103
msgid ""
"Use the regular PCI mapping routines to map a PCI resource into userspace."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1208
msgid "cleanup resource files"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1209
msgid "dev to cleanup"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1210
msgid ""
"If we created resource files for **pdev**, remove them from sysfs and free "
"their resources."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1292
msgid "create resource files in sysfs for **dev**"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1293
msgid "dev in question"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1294
msgid ""
"Walk the resources in **pdev** creating files for each resource available."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1331
msgid "used to enable access to the PCI ROM display"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1332
#: ../drivers/pci/pci-sysfs.c:1357
msgid "sysfs file"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1333
#: ../drivers/pci/pci-sysfs.c:1358
msgid "kernel object handle"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1335
msgid "user input"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1336
#: ../drivers/pci/pci-sysfs.c:1361
msgid "file offset"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1337
msgid "number of byte in input"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1338
msgid "writing anything except 0 enables it"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1356
msgid "read a PCI ROM"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1360
msgid "where to put the data we read from the ROM"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1363
msgid ""
"Put **count** bytes starting at **off** into **buf** from the ROM in the PCI "
"device corresponding to **kobj**."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1700
msgid "cleanup PCI specific sysfs files"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1701
msgid "device whose entries we should free"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1702
msgid "Cleanup when **pdev** is removed from sysfs."
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:159
msgid "Return the device's ST table location"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:162
msgid ""
"PCI_TPH_LOC_NONE - Not present PCI_TPH_LOC_CAP  - Located in the TPH "
"Requester Extended Capability PCI_TPH_LOC_MSIX - Located in the MSI-X Table"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:235
msgid ""
"Retrieve Steering Tag for a target memory associated with a specific CPU"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:239
msgid "``enum tph_mem_type mem_type``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:238
msgid "target memory type (volatile or persistent RAM)"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:240
msgid "``unsigned int cpu_uid``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:239
msgid "associated CPU id"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:241
msgid "``u16 *tag``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:240
msgid "Steering Tag to be returned"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:241
msgid ""
"Return the Steering Tag for a target memory that is associated with a "
"specific CPU as indicated by cpu_uid."
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:245
#: ../drivers/pci/tph.c:289
msgid "0 if success, otherwise negative value (-errno)"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:280
msgid "Set Steering Tag in the ST table entry"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:283
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:282
msgid "ST table entry index"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:284
msgid "``u16 tag``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:283
msgid "Steering Tag to be written"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:284
msgid ""
"Figure out the proper location of ST table, either in the MSI-X table or in "
"the TPH Extended Capability space, and write the Steering Tag into the ST "
"entry pointed by index."
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:342
msgid "Turn off TPH support for device"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:345
msgid "none"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:364
msgid "Enable TPH support for device using a specific ST mode"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:367
msgid "``int mode``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:366
msgid "ST mode to enable. Current supported modes include:"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:367
msgid "PCI_TPH_ST_NS_MODE: NO ST Mode"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:368
msgid "PCI_TPH_ST_IV_MODE: Interrupt Vector Mode"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:369
msgid "PCI_TPH_ST_DS_MODE: Device Specific Mode"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:371
msgid ""
"Check whether the mode is actually supported by the device before enabling "
"and return an error if not. Additionally determine what types of requests, "
"TPH or extended TPH, can be issued by the device based on its TPH requester "
"capability and the Root Port's completer capability."
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:377
msgid "0 on success, otherwise negative value (-errno)"
msgstr ""

#: ../../../driver-api/pci/pci.rst:56
msgid "PCI Hotplug Support Library"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:337
msgid "register a hotplug_slot with the PCI hotplug subsystem"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:343
#: ../drivers/pci/hotplug/pci_hotplug_core.c:376
#: ../drivers/pci/hotplug/pci_hotplug_core.c:421
#: ../drivers/pci/hotplug/pci_hotplug_core.c:450
#: ../drivers/pci/hotplug/pci_hotplug_core.c:464
#: ../drivers/pci/hotplug/pci_hotplug_core.c:479
msgid "``struct hotplug_slot *slot``"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:338
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to register"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:339
#: ../drivers/pci/hotplug/pci_hotplug_core.c:372
msgid "bus this slot is on"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:341
#: ../drivers/pci/hotplug/pci_hotplug_core.c:374
msgid "``int devnr``"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:340
msgid "device number"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:341
#: ../drivers/pci/hotplug/pci_hotplug_core.c:374
msgid "name registered with kobject core"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:342
#: ../drivers/pci/hotplug/pci_hotplug_core.c:375
msgid "caller module owner"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:343
#: ../drivers/pci/hotplug/pci_hotplug_core.c:376
msgid "caller module name"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:344
msgid ""
"Prepares a hotplug slot for in-kernel use and immediately publishes it to "
"user space in one go.  Drivers may alternatively carry out the two steps "
"separately by invoking pci_hp_initialize() and pci_hp_add()."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:348
msgid "Returns 0 if successful, anything else for an error."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:370
msgid "prepare hotplug slot for in-kernel use"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:371
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to initialize"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:373
msgid "slot number"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:377
msgid ""
"Allocate and fill in a PCI slot for use by a hotplug driver.  Once this has "
"been called, the driver may invoke hotplug_slot_name() to get the slot's "
"unique name.  The driver must be prepared to handle a ->reset_slot callback "
"from this point on."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:382
#: ../drivers/pci/hotplug/pci_hotplug_core.c:421
msgid "Returns 0 on success or a negative int on error."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:415
msgid "publish hotplug slot to user space"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:416
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to publish"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:417
msgid ""
"Make a hotplug slot's sysfs interface available and inform user space of its "
"addition by sending a uevent.  The hotplug driver must be prepared to handle "
"all :c:type:`struct hotplug_slot_ops <hotplug_slot_ops>` callbacks from this "
"point on."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:444
msgid "deregister a hotplug_slot with the PCI hotplug subsystem"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:445
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to deregister"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:446
msgid ""
"The **slot** must have been registered with the pci hotplug subsystem "
"previously with a call to pci_hp_register()."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:458
msgid "unpublish hotplug slot from user space"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:459
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to unpublish"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:460
msgid "Remove a hotplug slot's sysfs interface."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:473
msgid "remove hotplug slot from in-kernel use"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:474
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to destroy"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:475
msgid ""
"Destroy a PCI slot used by a hotplug driver.  Once this has been called, the "
"driver may no longer invoke hotplug_slot_name() to get the slot's unique "
"name.  The driver no longer needs to handle a ->reset_slot callback from "
"this point on."
msgstr ""
