# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-21 08:55+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/pci/pci.rst:2
msgid "PCI Support Library"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:184
msgid "returns maximum PCI bus number of given bus' children"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:148
#: drivers/pci/devres.c:179 drivers/pci/devres.c:209 drivers/pci/devres.c:275
#: drivers/pci/devres.c:320 drivers/pci/devres.c:366 drivers/pci/devres.c:400
#: drivers/pci/devres.c:423 drivers/pci/devres.c:525 drivers/pci/devres.c:575
#: drivers/pci/devres.c:601 drivers/pci/devres.c:650 drivers/pci/devres.c:671
#: drivers/pci/devres.c:716 drivers/pci/devres.c:793 drivers/pci/devres.c:824
#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:37
#: drivers/pci/pci-driver.c:98 drivers/pci/pci-driver.c:1425
#: drivers/pci/pci-driver.c:1455 drivers/pci/pci-driver.c:1476
#: drivers/pci/pci-driver.c:1524 drivers/pci/pci-driver.c:1544
#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:134
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:137
#: drivers/pci/search.c:162 drivers/pci/search.c:185 drivers/pci/search.c:218
#: drivers/pci/search.c:290 drivers/pci/search.c:321 drivers/pci/search.c:342
#: drivers/pci/search.c:371 drivers/pci/search.c:402
#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:135
#: drivers/pci/msi/msi.c:147 drivers/pci/msi/msi.c:477
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:252 drivers/pci/bus.c:342
#: drivers/pci/bus.c:392 drivers/pci/bus.c:440 ../../../driver-api/pci/pci:28:
#: drivers/pci/access.c:191 drivers/pci/access.c:285 drivers/pci/access.c:305
#: drivers/pci/access.c:329 ../../../driver-api/pci/pci:31:
#: drivers/pci/irq.c:23 drivers/pci/irq.c:67 drivers/pci/irq.c:126
#: drivers/pci/irq.c:240 drivers/pci/irq.c:253 ../../../driver-api/pci/pci:34:
#: drivers/pci/probe.c:2291 drivers/pci/probe.c:2852 drivers/pci/probe.c:3196
#: drivers/pci/probe.c:3483 ../../../driver-api/pci/pci:37:
#: drivers/pci/slot.c:193 drivers/pci/slot.c:313
#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:20 drivers/pci/rom.c:56
#: drivers/pci/rom.c:130 drivers/pci/rom.c:185 ../../../driver-api/pci/pci:43:
#: drivers/pci/iov.c:59 drivers/pci/iov.c:1159 drivers/pci/iov.c:1177
#: drivers/pci/iov.c:1192 drivers/pci/iov.c:1207 drivers/pci/iov.c:1248
#: drivers/pci/iov.c:1278 drivers/pci/iov.c:1295 drivers/pci/iov.c:1331
#: drivers/pci/iov.c:1373 ../../../driver-api/pci/pci:46:
#: drivers/pci/pci-sysfs.c:925 drivers/pci/pci-sysfs.c:950
#: drivers/pci/pci-sysfs.c:975 drivers/pci/pci-sysfs.c:995
#: drivers/pci/pci-sysfs.c:1015 drivers/pci/pci-sysfs.c:1027
#: drivers/pci/pci-sysfs.c:1102 drivers/pci/pci-sysfs.c:1212
#: drivers/pci/pci-sysfs.c:1296 drivers/pci/pci-sysfs.c:1335
#: drivers/pci/pci-sysfs.c:1360 drivers/pci/pci-sysfs.c:1717
#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:229 drivers/pci/tph.c:274
#: drivers/pci/tph.c:336 drivers/pci/tph.c:358 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:188 drivers/pci/pci.c:210 drivers/pci/pci.c:464
#: drivers/pci/pci.c:495 drivers/pci/pci.c:522 drivers/pci/pci.c:543
#: drivers/pci/pci.c:563 drivers/pci/pci.c:626 drivers/pci/pci.c:645
#: drivers/pci/pci.c:668 drivers/pci/pci.c:701 drivers/pci/pci.c:733
#: drivers/pci/pci.c:776 drivers/pci/pci.c:1179 drivers/pci/pci.c:1586
#: drivers/pci/pci.c:1741 drivers/pci/pci.c:1857 drivers/pci/pci.c:1897
#: drivers/pci/pci.c:1938 drivers/pci/pci.c:1974 drivers/pci/pci.c:2061
#: drivers/pci/pci.c:2133 drivers/pci/pci.c:2147 drivers/pci/pci.c:2224
#: drivers/pci/pci.c:2264 drivers/pci/pci.c:2362 drivers/pci/pci.c:2466
#: drivers/pci/pci.c:2603 drivers/pci/pci.c:2621 drivers/pci/pci.c:2703
#: drivers/pci/pci.c:2732 drivers/pci/pci.c:2777 drivers/pci/pci.c:2892
#: drivers/pci/pci.c:3123 drivers/pci/pci.c:3140 drivers/pci/pci.c:3739
#: drivers/pci/pci.c:3814 drivers/pci/pci.c:3897 drivers/pci/pci.c:3971
#: drivers/pci/pci.c:3992 drivers/pci/pci.c:4030 drivers/pci/pci.c:4045
#: drivers/pci/pci.c:4061 drivers/pci/pci.c:4076 drivers/pci/pci.c:4095
#: drivers/pci/pci.c:4177 drivers/pci/pci.c:4213 drivers/pci/pci.c:4287
#: drivers/pci/pci.c:4301 drivers/pci/pci.c:4311 drivers/pci/pci.c:4349
#: drivers/pci/pci.c:4380 drivers/pci/pci.c:4399 drivers/pci/pci.c:4436
#: drivers/pci/pci.c:4461 drivers/pci/pci.c:4477 drivers/pci/pci.c:4505
#: drivers/pci/pci.c:4935 drivers/pci/pci.c:5176 drivers/pci/pci.c:5263
#: drivers/pci/pci.c:5310 drivers/pci/pci.c:5344 drivers/pci/pci.c:5614
#: drivers/pci/pci.c:5717 drivers/pci/pci.c:5755 drivers/pci/pci.c:5768
#: drivers/pci/pci.c:5791 drivers/pci/pci.c:5814 drivers/pci/pci.c:5861
#: drivers/pci/pci.c:5877 drivers/pci/pci.c:5928 drivers/pci/pci.c:5944
#: drivers/pci/pci.c:5990 drivers/pci/pci.c:6097 drivers/pci/pci.c:6111
#: drivers/pci/pci.c:6190 drivers/pci/pci.c:6202
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:341
#: drivers/pci/hotplug/pci_hotplug_core.c:374
#: drivers/pci/hotplug/pci_hotplug_core.c:419
#: drivers/pci/hotplug/pci_hotplug_core.c:448
#: drivers/pci/hotplug/pci_hotplug_core.c:462
#: drivers/pci/hotplug/pci_hotplug_core.c:477 ../../../driver-api/pci/pci:7:
#: drivers/pci/iomap.c:19 drivers/pci/iomap.c:65 drivers/pci/iomap.c:114
#: drivers/pci/iomap.c:134
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:187
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:254
#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:193
#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2854
#: drivers/pci/probe.c:3198 drivers/pci/probe.c:3485
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:190 drivers/pci/pci.c:497
#: drivers/pci/pci.c:5719 ../../../driver-api/pci/pci:55:
#: drivers/pci/hotplug/pci_hotplug_core.c:340
#: drivers/pci/hotplug/pci_hotplug_core.c:373
msgid "``struct pci_bus *bus``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:185
msgid "pointer to PCI bus structure to search"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:149
#: drivers/pci/devres.c:180 drivers/pci/devres.c:209 drivers/pci/devres.c:274
#: drivers/pci/devres.c:322 drivers/pci/devres.c:367 drivers/pci/devres.c:399
#: drivers/pci/devres.c:424 drivers/pci/devres.c:528 drivers/pci/devres.c:575
#: drivers/pci/devres.c:604 drivers/pci/devres.c:650 drivers/pci/devres.c:674
#: drivers/pci/devres.c:719 drivers/pci/devres.c:795 drivers/pci/devres.c:828
#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:43
#: drivers/pci/pci-driver.c:98 drivers/pci/pci-driver.c:1426
#: drivers/pci/pci-driver.c:1454 drivers/pci/pci-driver.c:1475
#: drivers/pci/pci-driver.c:1523 drivers/pci/pci-driver.c:1543
#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:133
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:137
#: drivers/pci/search.c:161 drivers/pci/search.c:187 drivers/pci/search.c:221
#: drivers/pci/search.c:293 drivers/pci/search.c:322 drivers/pci/search.c:342
#: drivers/pci/search.c:371 drivers/pci/search.c:402
#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:476
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:258 drivers/pci/bus.c:341
#: drivers/pci/bus.c:391 drivers/pci/bus.c:441 ../../../driver-api/pci/pci:28:
#: drivers/pci/access.c:191 drivers/pci/access.c:284 drivers/pci/access.c:304
#: drivers/pci/access.c:328 ../../../driver-api/pci/pci:31: drivers/pci/irq.c:3
#: drivers/pci/irq.c:68 drivers/pci/irq.c:126 drivers/pci/irq.c:239
#: drivers/pci/irq.c:252 ../../../driver-api/pci/pci:34:
#: drivers/pci/probe.c:2290 drivers/pci/probe.c:2852 drivers/pci/probe.c:3195
#: drivers/pci/probe.c:3482 ../../../driver-api/pci/pci:37:
#: drivers/pci/slot.c:195 drivers/pci/slot.c:312
#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:19 drivers/pci/rom.c:55
#: drivers/pci/rom.c:132 drivers/pci/rom.c:185 ../../../driver-api/pci/pci:43:
#: drivers/pci/iov.c:59 drivers/pci/iov.c:1159 drivers/pci/iov.c:1191
#: drivers/pci/iov.c:1206 drivers/pci/iov.c:1248 drivers/pci/iov.c:1277
#: drivers/pci/iov.c:1295 drivers/pci/iov.c:1332 drivers/pci/iov.c:1374
#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:929
#: drivers/pci/pci-sysfs.c:954 drivers/pci/pci-sysfs.c:977
#: drivers/pci/pci-sysfs.c:997 drivers/pci/pci-sysfs.c:1015
#: drivers/pci/pci-sysfs.c:1026 drivers/pci/pci-sysfs.c:1104
#: drivers/pci/pci-sysfs.c:1211 drivers/pci/pci-sysfs.c:1295
#: drivers/pci/pci-sysfs.c:1339 drivers/pci/pci-sysfs.c:1364
#: drivers/pci/pci-sysfs.c:1716 ../../../driver-api/pci/pci:49:
#: drivers/pci/tph.c:232 drivers/pci/tph.c:275 drivers/pci/tph.c:358
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:187 drivers/pci/pci.c:209
#: drivers/pci/pci.c:464 drivers/pci/pci.c:496 drivers/pci/pci.c:523
#: drivers/pci/pci.c:543 drivers/pci/pci.c:562 drivers/pci/pci.c:627
#: drivers/pci/pci.c:645 drivers/pci/pci.c:669 drivers/pci/pci.c:702
#: drivers/pci/pci.c:734 drivers/pci/pci.c:776 drivers/pci/pci.c:1586
#: drivers/pci/pci.c:1897 drivers/pci/pci.c:2132 drivers/pci/pci.c:2146
#: drivers/pci/pci.c:2223 drivers/pci/pci.c:2264 drivers/pci/pci.c:2466
#: drivers/pci/pci.c:2604 drivers/pci/pci.c:2621 drivers/pci/pci.c:2703
#: drivers/pci/pci.c:2732 drivers/pci/pci.c:2776 drivers/pci/pci.c:2892
#: drivers/pci/pci.c:3122 drivers/pci/pci.c:3139 drivers/pci/pci.c:3739
#: drivers/pci/pci.c:3817 drivers/pci/pci.c:3898 drivers/pci/pci.c:3974
#: drivers/pci/pci.c:3992 drivers/pci/pci.c:4061 drivers/pci/pci.c:4076
#: drivers/pci/pci.c:4097 drivers/pci/pci.c:4177 drivers/pci/pci.c:4212
#: drivers/pci/pci.c:4286 drivers/pci/pci.c:4310 drivers/pci/pci.c:4348
#: drivers/pci/pci.c:4379 drivers/pci/pci.c:4398 drivers/pci/pci.c:4436
#: drivers/pci/pci.c:4460 drivers/pci/pci.c:4476 drivers/pci/pci.c:4505
#: drivers/pci/pci.c:4934 drivers/pci/pci.c:5176 drivers/pci/pci.c:5262
#: drivers/pci/pci.c:5309 drivers/pci/pci.c:5343 drivers/pci/pci.c:5613
#: drivers/pci/pci.c:5716 drivers/pci/pci.c:5754 drivers/pci/pci.c:5767
#: drivers/pci/pci.c:5790 drivers/pci/pci.c:5815 drivers/pci/pci.c:5860
#: drivers/pci/pci.c:5878 drivers/pci/pci.c:5927 drivers/pci/pci.c:5945
#: drivers/pci/pci.c:5993 drivers/pci/pci.c:6096 drivers/pci/pci.c:6110
#: drivers/pci/pci.c:6189 drivers/pci/pci.c:6202
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:345
#: drivers/pci/hotplug/pci_hotplug_core.c:378
#: drivers/pci/hotplug/pci_hotplug_core.c:418
#: drivers/pci/hotplug/pci_hotplug_core.c:447
#: drivers/pci/hotplug/pci_hotplug_core.c:461
#: drivers/pci/hotplug/pci_hotplug_core.c:476 ../../../driver-api/pci/pci:7:
#: drivers/pci/iomap.c:21 drivers/pci/iomap.c:67 drivers/pci/iomap.c:115
#: drivers/pci/iomap.c:135
msgid "**Description**"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:186
msgid ""
"Given a PCI bus, returns the highest PCI bus number present in the set "
"including the given PCI bus and its list of child PCI buses."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:206
msgid "return and clear error bits in PCI_STATUS"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:277
#: drivers/pci/devres.c:322 drivers/pci/devres.c:368 drivers/pci/devres.c:402
#: drivers/pci/devres.c:425 drivers/pci/devres.c:527 drivers/pci/devres.c:577
#: drivers/pci/devres.c:603 drivers/pci/devres.c:652 drivers/pci/devres.c:673
#: drivers/pci/devres.c:718 drivers/pci/devres.c:795 drivers/pci/devres.c:826
#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:22 drivers/pci/rom.c:58
#: drivers/pci/rom.c:132 drivers/pci/rom.c:187 ../../../driver-api/pci/pci:46:
#: drivers/pci/pci-sysfs.c:1214 drivers/pci/pci-sysfs.c:1298
#: drivers/pci/pci-sysfs.c:1719 ../../../driver-api/pci/pci:49:
#: drivers/pci/tph.c:231 drivers/pci/tph.c:276 drivers/pci/tph.c:338
#: drivers/pci/tph.c:360 ../../../driver-api/pci/pci:4: drivers/pci/pci.c:212
#: drivers/pci/pci.c:3741 drivers/pci/pci.c:3899 drivers/pci/pci.c:3973
#: drivers/pci/pci.c:3994 drivers/pci/pci.c:4032 drivers/pci/pci.c:4047
#: drivers/pci/pci.c:4063 drivers/pci/pci.c:4078 drivers/pci/pci.c:4097
#: drivers/pci/pci.c:4438 drivers/pci/pci.c:5757
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:123
#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1156
#: drivers/pci/iov.c:1174 drivers/pci/iov.c:1189 drivers/pci/iov.c:1204
#: drivers/pci/iov.c:1292 drivers/pci/iov.c:1328 drivers/pci/iov.c:1370
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:207 drivers/pci/pci.c:3811
msgid "the PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:208
msgid "Returns error bits set in PCI_STATUS and clears them."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:460 drivers/pci/pci.c:491
msgid "query for devices' capabilities"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:97
#: drivers/pci/pci-driver.c:1526 drivers/pci/pci-driver.c:1546
#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:136
#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:479
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:344
#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:287
#: drivers/pci/access.c:307 drivers/pci/access.c:331
#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:25 drivers/pci/irq.c:69
#: drivers/pci/irq.c:128 drivers/pci/irq.c:242 drivers/pci/irq.c:255
#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2293
#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:61 drivers/pci/iov.c:1161
#: drivers/pci/iov.c:1179 drivers/pci/iov.c:1194 drivers/pci/iov.c:1209
#: drivers/pci/iov.c:1250 drivers/pci/iov.c:1280 drivers/pci/iov.c:1297
#: drivers/pci/iov.c:1333 drivers/pci/iov.c:1375 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:466 drivers/pci/pci.c:524 drivers/pci/pci.c:545
#: drivers/pci/pci.c:565 drivers/pci/pci.c:628 drivers/pci/pci.c:647
#: drivers/pci/pci.c:670 drivers/pci/pci.c:703 drivers/pci/pci.c:778
#: drivers/pci/pci.c:1181 drivers/pci/pci.c:1588 drivers/pci/pci.c:1743
#: drivers/pci/pci.c:1859 drivers/pci/pci.c:1899 drivers/pci/pci.c:1940
#: drivers/pci/pci.c:1976 drivers/pci/pci.c:2063 drivers/pci/pci.c:2135
#: drivers/pci/pci.c:2149 drivers/pci/pci.c:2226 drivers/pci/pci.c:2266
#: drivers/pci/pci.c:2364 drivers/pci/pci.c:2468 drivers/pci/pci.c:2623
#: drivers/pci/pci.c:2705 drivers/pci/pci.c:2734 drivers/pci/pci.c:2779
#: drivers/pci/pci.c:2894 drivers/pci/pci.c:3125 drivers/pci/pci.c:3142
#: drivers/pci/pci.c:3816 drivers/pci/pci.c:4289 drivers/pci/pci.c:4303
#: drivers/pci/pci.c:4313 drivers/pci/pci.c:4351 drivers/pci/pci.c:4382
#: drivers/pci/pci.c:4401 drivers/pci/pci.c:4463 drivers/pci/pci.c:4479
#: drivers/pci/pci.c:4507 drivers/pci/pci.c:4937 drivers/pci/pci.c:5178
#: drivers/pci/pci.c:5265 drivers/pci/pci.c:5312 drivers/pci/pci.c:5346
#: drivers/pci/pci.c:5770 drivers/pci/pci.c:5793 drivers/pci/pci.c:5816
#: drivers/pci/pci.c:5863 drivers/pci/pci.c:5879 drivers/pci/pci.c:5930
#: drivers/pci/pci.c:5946 drivers/pci/pci.c:5992 drivers/pci/pci.c:6099
#: drivers/pci/pci.c:6113 drivers/pci/pci.c:6192 drivers/pci/pci.c:6204
#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:21 drivers/pci/iomap.c:67
#: drivers/pci/iomap.c:116 drivers/pci/iomap.c:136
msgid "``struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2288
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:461 drivers/pci/pci.c:493
#: drivers/pci/pci.c:519 drivers/pci/pci.c:540 drivers/pci/pci.c:560
#: drivers/pci/pci.c:623 drivers/pci/pci.c:642 drivers/pci/pci.c:665
#: drivers/pci/pci.c:698 drivers/pci/pci.c:773 drivers/pci/pci.c:5765
#: drivers/pci/pci.c:5788 drivers/pci/pci.c:5811 drivers/pci/pci.c:5858
#: drivers/pci/pci.c:5874 drivers/pci/pci.c:5925 drivers/pci/pci.c:5941
#: drivers/pci/pci.c:5988 drivers/pci/pci.c:6094 drivers/pci/pci.c:6108
#: drivers/pci/pci.c:6187
msgid "PCI device to query"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:463 drivers/pci/pci.c:495
#: drivers/pci/pci.c:522 drivers/pci/pci.c:542 drivers/pci/pci.c:668
msgid "``int cap``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:462 drivers/pci/pci.c:494
#: drivers/pci/pci.c:521 drivers/pci/pci.c:541
msgid "capability code"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:463
msgid ""
"Tell if a device supports a given PCI capability. Returns the address of the "
"requested capability structure within the device's PCI configuration space "
"or 0 in case the device does not support it.  Possible values for **cap** "
"include:"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:468
msgid ""
"``PCI_CAP_ID_PM``           Power Management ``PCI_CAP_ID_AGP``          "
"Accelerated Graphics Port ``PCI_CAP_ID_VPD``          Vital Product Data "
"``PCI_CAP_ID_SLOTID``       Slot Identification ``PCI_CAP_ID_MSI``          "
"Message Signalled Interrupts ``PCI_CAP_ID_CHSWP``        CompactPCI HotSwap "
"``PCI_CAP_ID_PCIX``         PCI-X ``PCI_CAP_ID_EXP``          PCI Express"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:492
msgid "the PCI bus to query"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:184
#: drivers/pci/search.c:218 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:494
msgid "``unsigned int devfn``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:495
msgid ""
"Like pci_find_capability() but works for PCI devices that do not have a "
"pci_dev structure set up yet."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:498
msgid ""
"Returns the address of the requested capability structure within the "
"device's PCI configuration space or 0 in case the device does not support it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:518 drivers/pci/pci.c:539
msgid "Find an extended capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:521
msgid "``u16 start``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:520
msgid "address at which to start looking (0 to start at beginning of list)"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:522
msgid ""
"Returns the address of the next matching extended capability structure "
"within the device's PCI configuration space or 0 if the device does not "
"support it.  Some capabilities can occur several times, e.g., the vendor-"
"specific capability, and this provides a way to find them all."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:542
msgid ""
"Returns the address of the requested extended capability structure within "
"the device's PCI configuration space or 0 if the device does not support "
"it.  Possible values for **cap** include:"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:546
msgid ""
"``PCI_EXT_CAP_ID_ERR``         Advanced Error Reporting "
"``PCI_EXT_CAP_ID_VC``          Virtual Channel "
"``PCI_EXT_CAP_ID_DSN``         Device Serial Number "
"``PCI_EXT_CAP_ID_PWR``         Power Budgeting"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:559
msgid "Read and return the 8-byte Device Serial Number"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:561
msgid ""
"Looks up the PCI_EXT_CAP_ID_DSN and reads the 8 bytes of the Device Serial "
"Number."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:564
msgid "Returns the DSN, or zero if the capability does not exist."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:622 drivers/pci/pci.c:641
msgid "query a device's HyperTransport capabilities"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:625
msgid "``u8 pos``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:624
msgid "Position from which to continue searching"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:626 drivers/pci/pci.c:644
msgid "``int ht_cap``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:625 drivers/pci/pci.c:643
msgid "HyperTransport capability code"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:626
msgid ""
"To be used in conjunction with pci_find_ht_capability() to search for all "
"capabilities matching **ht_cap**. **pos** should always be a value returned "
"from pci_find_ht_capability()."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:630
msgid ""
"NB. To be 100% safe against broken PCI devices, the caller should take steps "
"to avoid an infinite loop."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:644
msgid ""
"Tell if a device supports a given HyperTransport capability. Returns an "
"address within the device's PCI configuration space or 0 in case the device "
"does not support the request capability. The address points to the PCI "
"capability, of type PCI_CAP_ID_HT, which has a HyperTransport capability "
"matching **ht_cap**."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:664
msgid "Find a vendor-specific extended capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:667 drivers/pci/pci.c:700
msgid "``u16 vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:666
msgid "Vendor ID for which capability is defined"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:667
msgid "Vendor-specific capability ID"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:668
msgid ""
"If **dev** has Vendor ID **vendor**, search for a VSEC capability with VSEC "
"ID **cap**. If found, return the capability offset in config space; "
"otherwise return 0."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:697
msgid "Find DVSEC for vendor"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:699
msgid "Vendor ID to match for the DVSEC"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:701
msgid "``u16 dvsec``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:700
msgid "Designated Vendor-specific capability ID"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:701
msgid ""
"If DVSEC has Vendor ID **vendor** and DVSEC ID **dvsec** return the "
"capability offset in config space; otherwise return 0."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:729
msgid "return resource region of parent bus of given region"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1478
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:735
msgid "``const struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:731
msgid "PCI device structure contains resources to be searched"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:208
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:251
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:733 drivers/pci/pci.c:775
#: drivers/pci/pci.c:4215
msgid "``struct resource *res``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:732
msgid "child resource record for which parent is sought"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:733
msgid ""
"For given resource region of given device, return the resource region of "
"parent bus the given region is contained in."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:772
msgid "Return matching PCI device resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:774
msgid "Resource to look for"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:775
msgid ""
"Goes over standard PCI resources (BARs) and checks if the given resource is "
"partially or fully contained in any of them. In that case the matching "
"resource is returned, ``NULL`` otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1175
msgid "Use platform to change device power state"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1176 drivers/pci/pci.c:1583
#: drivers/pci/pci.c:2359 drivers/pci/pci.c:2463
msgid "PCI device to handle."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1178 drivers/pci/pci.c:1585
#: drivers/pci/pci.c:2361 drivers/pci/pci.c:2602
msgid "``pci_power_t state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1177
msgid "State to put the device into."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1582
msgid "Set the power state of a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1584
msgid "PCI power state (D0, D1, D2, D3hot) to put the device into."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1585
msgid ""
"Transition a device to a new power state, using the platform firmware and/or "
"the device's PCI PM registers."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1588
msgid ""
"RETURN VALUE: -EINVAL if the requested state is invalid. -EIO if device does "
"not support PCI PM or its PM capabilities register has a wrong version, or "
"device doesn't support the requested state. 0 if the transition is to D1 or "
"D2 but D1 and D2 are not supported. 0 if device already is in the requested "
"state. 0 if the transition is to D3 but D3 is not supported. 0 if device's "
"power state has been successfully changed."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1737
msgid "save the PCI configuration space of a device before suspending"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1739 drivers/pci/pci.c:1854
#: drivers/pci/pci.c:1895 drivers/pci/pci.c:1935 drivers/pci/pci.c:1972
msgid "PCI device that we're dealing with"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1853
msgid "Restore the saved state of a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1893
msgid "Allocate and return an opaque struct containing the device saved state."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1896
msgid "Return NULL if no state or error."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1934
msgid "Reload the provided save state into struct pci_dev."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1937
msgid "``struct pci_saved_state *state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1936
msgid "Saved state returned from pci_store_saved_state()"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1970
msgid ""
"Reload the save state pointed to by state, and free the memory allocated for "
"it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1974
msgid "``struct pci_saved_state **state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1973
msgid "Pointer to saved state returned from pci_store_saved_state()"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2057
msgid "Resume abandoned device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2058
msgid "PCI device to be resumed"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:532
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2060
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2060
msgid ""
"This function is a backend of pci_default_resume() and is not supposed to be "
"called by normal code, write proper resume handler and use it instead."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2129
msgid "Initialize a device for use with Memory space"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:363
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2130 drivers/pci/pci.c:2144
msgid "PCI device to be initialized"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2131
msgid ""
"Initialize device before it's used by a driver. Ask low-level code to enable "
"Memory resources. Wake up the device if it was suspended. Beware, this "
"function can fail."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2143
msgid "Initialize device before it's used by a driver."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2145
msgid ""
"Initialize device before it's used by a driver. Ask low-level code to enable "
"I/O and memory. Wake up the device if it was suspended. Beware, this "
"function can fail."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2149
msgid ""
"Note we don't actually enable the device many times if we call this function "
"repeatedly (we just increment the count)."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2220
msgid "Disable PCI device after use"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2221
msgid "PCI device to be disabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2222
msgid ""
"Signal to the system that the PCI device is not in use by the system "
"anymore.  This only involves disabling PCI bus-mastering, if active."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2225
msgid ""
"Note we don't actually disable the device until all callers of "
"pci_enable_device() have called pci_disable_device()."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2260
msgid "set reset state for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2261
msgid "the PCIe device reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2263
msgid "``enum pcie_reset_state state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2262
msgid "Reset state to enter into"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2263
msgid "Sets the PCI reset state for the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2358
msgid "check the capability of PCI device to generate PME#"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2360
msgid "PCI state from which device will issue PME#."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2462
msgid "enable or disable PCI device's PME# function"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2465 drivers/pci/pci.c:2603
#: drivers/pci/pci.c:2620
msgid "``bool enable``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2464
msgid "'true' to enable PME# generation; 'false' to disable it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2465
msgid ""
"The caller must verify that the device is capable of generating PME# before "
"calling this function with **enable** equal to 'true'."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2599
msgid "change wakeup settings for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2605
msgid "``struct pci_dev *pci_dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2600
msgid "Target device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2601
msgid "PCI state from which device will issue wakeup events"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2602
msgid "Whether or not to enable event generation"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2603
msgid ""
"If **enable** is set, check device_may_wakeup() for the device before "
"calling __pci_enable_wake() for it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2617
msgid "enable/disable device to wake up from D3_hot or D3_cold"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2618
msgid "PCI device to prepare"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2619
msgid "True to enable wake-up event generation; false to disable"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2620
msgid ""
"Many drivers want the device to wake up the system from D3_hot or D3_cold "
"and this function allows them to set that up cleanly - pci_enable_wake() "
"should not be called twice in a row to enable wake-up due to PCI PM vs ACPI "
"ordering constraints."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2625
msgid ""
"This function only returns error code if the device is not allowed to wake "
"up the system from sleep or it is not capable of generating PME# from both "
"D3_hot and D3_cold and the platform is unable to enable wake-up power for it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2699
msgid "prepare PCI device for system-wide transition into a sleep state"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2701 drivers/pci/pci.c:2730
msgid "Device to handle."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2702
msgid ""
"Choose the power state appropriate for the device depending on whether it "
"can wake up the system and/or is power manageable by the platform (PCI_D3hot "
"is the default) and put the device into that state."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2728
msgid "turn PCI device on during system-wide transition into working state"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2731
msgid "Disable device's system wake-up capability and put it into D0."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2773
msgid "Check if device can generate run-time wake-up events."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2774
msgid "Device to check."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2775
msgid ""
"Return true if the device itself is capable of generating wake-up events "
"(through the platform or using the native PCIe PME) or if the device "
"supports PME and one of its upstream bridges can generate wake-up events."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2888
msgid "Choose the power state of a PCI device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2889
msgid "Target PCI device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2891
msgid "``pm_message_t state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2890
msgid "Target state for the whole system."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2891
msgid "Returns PCI power state suitable for **dev** and **state**."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3119
msgid "Enable D3cold for device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3120 drivers/pci/pci.c:3137
msgid "PCI device to handle"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3121
msgid ""
"This function can be used in drivers to enable D3cold from the device they "
"handle.  It also updates upstream PCI bridge PM capabilities accordingly."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3136
msgid "Disable D3cold for device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3138
msgid ""
"This function can be used in drivers to disable D3cold from the device they "
"handle.  It also updates upstream PCI bridge PM capabilities accordingly."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3735
msgid "get possible sizes for BAR"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:227 drivers/pci/tph.c:271
#: drivers/pci/tph.c:333 drivers/pci/tph.c:355 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:3736
msgid "PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:524
#: drivers/pci/devres.c:600 drivers/pci/devres.c:649 drivers/pci/devres.c:715
#: drivers/pci/devres.c:823 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:3738 drivers/pci/pci.c:3897 drivers/pci/pci.c:3970
#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:18 drivers/pci/iomap.c:64
#: drivers/pci/iomap.c:113 drivers/pci/iomap.c:133
msgid "``int bar``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3737
msgid "BAR to query"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3738
msgid ""
"Get the possible sizes of a resizable BAR as bitmask defined in the spec "
"(bit 0=1MB, bit 31=128TB). Returns 0 if BAR isn't resizable."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3810
msgid "enable AtomicOp requests to root port"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3813
msgid "``u32 cap_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3812
msgid ""
"mask of desired AtomicOp sizes, including one or more of: "
"PCI_EXP_DEVCAP2_ATOMIC_COMP32 PCI_EXP_DEVCAP2_ATOMIC_COMP64 "
"PCI_EXP_DEVCAP2_ATOMIC_COMP128"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3816
msgid ""
"Return 0 if all upstream bridges support AtomicOp routing, egress blocking "
"is disabled on all upstream ports, and the root port supports the requested "
"completion capabilities (32-bit, 64-bit and/or 128-bit AtomicOp completion), "
"or negative otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3893
msgid "Release a PCI bar"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3894
msgid ""
"PCI device whose resources were previously reserved by pci_request_region()"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3896
msgid "BAR to release"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3897
msgid ""
"Releases the PCI I/O and memory resources previously reserved by a "
"successful call to pci_request_region().  Call this function only after all "
"use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3967
msgid "Reserve PCI I/O and memory resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3968 drivers/pci/pci.c:4027
#: drivers/pci/pci.c:4073 drivers/pci/pci.c:4092
msgid "PCI device whose resources are to be reserved"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3969
msgid "BAR to be reserved"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:601
#: drivers/pci/devres.c:671 drivers/pci/devres.c:716 drivers/pci/devres.c:792
#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:193
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3971 drivers/pci/pci.c:4030
#: drivers/pci/pci.c:4045 drivers/pci/pci.c:4075 drivers/pci/pci.c:4094
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:342
#: drivers/pci/hotplug/pci_hotplug_core.c:375
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3970
msgid "name of the driver requesting the resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:275
#: drivers/pci/devres.c:320 drivers/pci/devres.c:365 drivers/pci/devres.c:422
#: drivers/pci/devres.c:526 drivers/pci/devres.c:602 drivers/pci/devres.c:672
#: drivers/pci/devres.c:717 drivers/pci/devres.c:793 drivers/pci/devres.c:826
#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:49
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:378
#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:130
#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1337
#: drivers/pci/iov.c:1376 ../../../driver-api/pci/pci:49: drivers/pci/tph.c:234
#: drivers/pci/tph.c:278 drivers/pci/tph.c:335 drivers/pci/tph.c:366
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3972 drivers/pci/pci.c:4031
#: drivers/pci/pci.c:4046 drivers/pci/pci.c:4095 drivers/pci/pci.c:4313
#: drivers/pci/pci.c:4349 drivers/pci/pci.c:4381 drivers/pci/pci.c:6097
msgid "**Return**"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:365
#: drivers/pci/devres.c:672 drivers/pci/devres.c:793
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3972 drivers/pci/pci.c:4031
#: drivers/pci/pci.c:4046 drivers/pci/pci.c:4095
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3973
msgid ""
"Mark the PCI region associated with PCI device **pdev** BAR **bar** as being "
"reserved by owner **name**. Do not access any address inside the PCI regions "
"unless this call returns successfully."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3977 drivers/pci/pci.c:4079
#: drivers/pci/pci.c:4103
msgid ""
"Returns 0 on success, or ``EBUSY`` on error.  A warning message is also "
"printed on failure."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3988
msgid "Release selected PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3989
msgid "PCI device whose resources were previously reserved"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3991 drivers/pci/pci.c:4029
#: drivers/pci/pci.c:4044
msgid "``int bars``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3990
msgid "Bitmask of BARs to be released"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3991
msgid ""
"Release selected PCI I/O and memory resources previously reserved. Call this "
"function only after all use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4026
msgid "Reserve selected PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4028
msgid "Bitmask of BARs to be requested"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:670
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4029
msgid "Name of the driver requesting the resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4041
msgid "Request regions exclusively"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4042
msgid "PCI device to request regions from"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4043
msgid "bit mask of BARs to request"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:791
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4044 drivers/pci/pci.c:4074
#: drivers/pci/pci.c:4093
msgid "name of the driver requesting the resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4057
msgid "Release reserved PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4058
msgid ""
"PCI device whose resources were previously reserved by pci_request_regions()"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4060
msgid ""
"Releases all PCI I/O and memory resources previously reserved by a "
"successful call to pci_request_regions().  Call this function only after all "
"use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4072 drivers/pci/pci.c:4091
msgid "Reserve PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4075 drivers/pci/pci.c:4096
msgid ""
"Mark all PCI regions associated with PCI device **pdev** as being reserved "
"by owner **name**. Do not access any address inside the PCI regions unless "
"this call returns successfully."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4100
msgid ""
"pci_request_regions_exclusive() will mark the region so that /dev/mem and "
"the sysfs MMIO access will not be allowed."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4173
msgid "Remap the memory mapped I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:147
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4179
msgid "``const struct resource *res``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:146
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4174
msgid "Resource describing the I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:148
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4176
msgid "``phys_addr_t phys_addr``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:147
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4175
msgid "physical address of range to be mapped"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4176
msgid ""
"Remap the memory mapped I/O space described by the **res** and the CPU "
"physical address **phys_addr** into virtual address space.  Only "
"architectures that have memory mapped IO functions defined (and the "
"PCI_IOBASE value defined) should call this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4209
msgid "Unmap the memory mapped I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4210
msgid "resource to be unmapped"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4211
msgid ""
"Unmap the CPU virtual address **res** from virtual address space.  Only "
"architectures that have memory mapped IO functions defined (and the "
"PCI_IOBASE value defined) should call this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4283
msgid "enables bus-mastering for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4284
msgid "the PCI device to enable"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4285
msgid ""
"Enables bus-mastering on the device and calls pcibios_set_master() to do the "
"needed arch specific settings."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4297
msgid "disables bus-mastering for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4298 drivers/pci/pci.c:4396
msgid "the PCI device to disable"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4307
msgid "ensure the CACHE_LINE_SIZE register is programmed"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4308
msgid "the PCI device for which MWI is to be enabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4309
msgid ""
"Helper function for pci_set_mwi. Originally copied from drivers/net/acenic."
"c. Copyright 1998-2001 by Jes Sorensen, <jes**trained**-monkey.org>."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:276
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4314 drivers/pci/pci.c:4350
#: drivers/pci/pci.c:4382
msgid "An appropriate -ERRNO error value on error, or zero for success."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4345 drivers/pci/pci.c:4376
msgid "enables memory-write-invalidate PCI transaction"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:272
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4346 drivers/pci/pci.c:4377
msgid "the PCI device for which MWI is enabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4347
msgid "Enables the Memory-Write-Invalidate transaction in ``PCI_COMMAND``."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4378
msgid ""
"Enables the Memory-Write-Invalidate transaction in ``PCI_COMMAND``. Callers "
"are not required to check the return value."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4395
msgid "disables Memory-Write-Invalidate for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4397
msgid "Disables PCI Memory-Write-Invalidate transaction on the device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4432
msgid "enables/disables PCI INTx for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:317
#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:237 drivers/pci/irq.c:250
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4433 drivers/pci/pci.c:4458
msgid "the PCI device to operate on"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:319
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4435
msgid "``int enable``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:318
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4434
msgid "boolean: whether to enable or disable PCI INTx"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4435
msgid "Enables/disables PCI INTx for device **pdev**"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4457
msgid "wait for pending transaction"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4459
msgid "Return 0 if transaction is pending 1 otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4473 drivers/pci/pci.c:4501
msgid "initiate a PCIe function level reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4474 drivers/pci/pci.c:4502
msgid "device to reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4475
msgid ""
"Initiate a function level reset unconditionally on **dev** without checking "
"any flags and DEVCAP"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4504
msgid "``bool probe``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4503
msgid "if true, return 0 if device can be reset this way"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4504
msgid "Initiate a function level reset on **dev**."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4931
msgid "Reset the secondary bus on a PCI bridge."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4932
msgid "Bridge device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4933
msgid ""
"Use the bridge control register to assert reset on the secondary bus. "
"Devices on the secondary bus are left in power-on state."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5172
msgid "reset a PCI device function while holding the **dev** mutex lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5174 drivers/pci/pci.c:5260
#: drivers/pci/pci.c:5307 drivers/pci/pci.c:5341
msgid "PCI device to reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5175 drivers/pci/pci.c:5261
#: drivers/pci/pci.c:5308
msgid ""
"Some devices allow an individual function to be reset without affecting "
"other functions in the same device.  The PCI device must be responsive to "
"PCI config space in order to use this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5179
msgid ""
"The device function is presumed to be unused and the caller is holding the "
"device mutex lock when this function is called."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5182
msgid ""
"Resetting the device will make the contents of PCI configuration space "
"random, so any caller of this must be prepared to reinitialise the device "
"including MSI, bus mastering, BARs, decoding IO and memory spaces, etc."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5187 drivers/pci/pci.c:5270
#: drivers/pci/pci.c:5318
msgid ""
"Returns 0 if the device function was successfully reset or negative if the "
"device doesn't support resetting a single function."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5259 drivers/pci/pci.c:5306
#: drivers/pci/pci.c:5340
msgid "quiesce and reset a PCI device function"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5265
msgid ""
"This function does not just reset the PCI portion of a device, but clears "
"all the state associated with the device.  This function differs from "
"__pci_reset_function_locked() in that it saves and restores device state "
"over the reset and takes the PCI device lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5312
msgid ""
"This function does not just reset the PCI portion of a device, but clears "
"all the state associated with the device.  This function differs from "
"__pci_reset_function_locked() in that it saves and restores device state "
"over the reset.  It also differs from pci_reset_function() in that it "
"requires the PCI device lock to be held."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5342
msgid "Same as above, except return -EAGAIN if unable to lock device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5610
msgid "probe whether a PCI slot can be reset"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:315
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5616
msgid "``struct pci_slot *slot``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5611
msgid "PCI slot to probe"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5612
msgid ""
"Return 0 if slot can be reset, negative if a slot reset is not supported."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5713
msgid "probe whether a PCI bus can be reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5714
msgid "PCI bus to probe"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5715
msgid "Return 0 if bus can be reset, negative if a bus reset is not supported."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5751
msgid "Try to reset a PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5752
msgid "top level PCI device to reset via slot/bus"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5753
msgid "Same as above except return -EAGAIN if the bus cannot be locked"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5764
msgid "get PCI-X maximum designed memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5766
msgid ""
"Returns mmrbc: maximum designed memory read count in bytes or appropriate "
"error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5787
msgid "get PCI-X maximum memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5789
msgid ""
"Returns mmrbc: maximum memory read count in bytes or appropriate error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5810
msgid "set PCI-X maximum memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5813
msgid "``int mmrbc``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5812
msgid ""
"maximum memory read count in bytes valid values are 512, 1024, 2048, 4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5814
msgid ""
"If possible sets maximum memory read byte count, some bridges have errata "
"that prevent this."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5857
msgid "get PCI Express read request size"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5859
msgid ""
"Returns maximum memory read request in bytes or appropriate error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5873
msgid "set PCI Express maximum memory read request"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5876
msgid "``int rq``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5875
msgid ""
"maximum memory read count in bytes valid values are 128, 256, 512, 1024, "
"2048, 4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5877
msgid "If possible sets maximum memory read request in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5924
msgid "get PCI Express maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5926
msgid "Returns maximum payload size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5940
msgid "set PCI Express maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5943
msgid "``int mps``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5942
msgid ""
"maximum payload size in bytes valid values are 128, 256, 512, 1024, 2048, "
"4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5944
msgid "If possible sets maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5986
msgid ""
"determine minimum link settings of a PCIe device and its bandwidth limitation"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5990
msgid "``struct pci_dev **limiting_dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5989
msgid "storage for device causing the bandwidth limitation"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5991
msgid "``enum pci_bus_speed *speed``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5990
msgid "storage for speed of limiting device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5992
msgid "``enum pcie_link_width *width``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5991
msgid "storage for width of limiting device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5992
msgid ""
"Walk up the PCI device chain and find the point where the minimum bandwidth "
"is available.  Return the bandwidth available there and (if limiting_dev, "
"speed, and width pointers are supplied) information about that point.  The "
"bandwidth returned is in Mb/s, i.e., megabits/second of raw bandwidth."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6093
msgid "query for the PCI device's link speed capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6095
msgid "Query the PCI device speed capability."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6098
msgid "the maximum link speed supported by the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6107
msgid "query for the PCI device's link width capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6109
msgid ""
"Query the PCI device width capability.  Return the maximum link width "
"supported by the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6186
msgid "Report the PCI device's link speed and width"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6188
msgid "Report the available bandwidth at the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6198
msgid "Make BAR mask from the type of resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6199
msgid "the PCI device for which BAR mask is made"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6201
msgid "``unsigned long flags``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6200
msgid "resource type mask to be selected"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6201
msgid "This helper routine makes bar mask from the type of resource."
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:15
#: drivers/pci/iomap.c:110
msgid "create a virtual mapping cookie for a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:16 drivers/pci/iomap.c:62
#: drivers/pci/iomap.c:111 drivers/pci/iomap.c:131
msgid "PCI device that owns the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:17 drivers/pci/iomap.c:63
#: drivers/pci/iomap.c:112 drivers/pci/iomap.c:132
msgid "BAR number"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:824
#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:19 drivers/pci/iomap.c:65
msgid "``unsigned long offset``"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:18 drivers/pci/iomap.c:64
msgid "map memory at the given offset in BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:525
#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:20 drivers/pci/iomap.c:66
#: drivers/pci/iomap.c:114 drivers/pci/iomap.c:134
msgid "``unsigned long maxlen``"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:19 drivers/pci/iomap.c:65
msgid "max length of the memory to map"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:20
#: drivers/pci/iomap.c:114
msgid ""
"Using this function you will get a __iomem address to your device BAR. You "
"can access it using ioread*() and iowrite*(). These functions hide the "
"details if this is a MMIO or PIO address space and will just do what you "
"expect from them in the correct way."
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:25 drivers/pci/iomap.c:72
msgid ""
"**maxlen** specifies the maximum length to map. If you want to get access to "
"the complete BAR from offset to the end, pass ``0`` here."
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:61
#: drivers/pci/iomap.c:130
msgid "create a virtual WC mapping cookie for a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:66
#: drivers/pci/iomap.c:134
msgid ""
"Using this function you will get a __iomem address to your device BAR. You "
"can access it using ioread*() and iowrite*(). These functions hide the "
"details if this is a MMIO or PIO address space and will just do what you "
"expect from them in the correct way. When possible write combining is used."
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:113
#: drivers/pci/iomap.c:133
msgid "length of the memory to map"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:119
#: drivers/pci/iomap.c:140
msgid ""
"**maxlen** specifies the maximum length to map. If you want to get access to "
"the complete BAR without checking for its length first, pass ``0`` here."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:144
msgid "Managed pci_remap_iospace()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:150
#: drivers/pci/devres.c:181 drivers/pci/devres.c:211
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:145
#: drivers/pci/devres.c:176
msgid "Generic device to remap IO address for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:148
msgid ""
"Managed pci_remap_iospace().  Map is automatically unmapped on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:175
msgid "Managed pci_remap_cfgspace()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:178
msgid "``resource_size_t offset``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:177
msgid "Resource address to map"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:179
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:252
msgid "``resource_size_t size``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:178
msgid "Size of map"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:179
msgid ""
"Managed pci_remap_cfgspace().  Map is automatically unmapped on driver "
"detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:205
msgid "check, request region and ioremap cfg resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:206
msgid "generic device to handle the resource for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:207
msgid "configuration space resource to be handled"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:208
msgid ""
"Checks that a resource is a valid memory region, requests the memory region "
"and ioremaps with pci_remap_cfgspace() API that ensures the proper PCI "
"configuration space memory attributes are guaranteed."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:212
msgid "All operations are managed and will be undone on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:214
msgid ""
"Returns a pointer to the remapped memory or an IOMEM_ERR_PTR() encoded error "
"code on failure. Usage example::"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:271
msgid "a device-managed pci_set_mwi()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:273
msgid "Managed pci_set_mwi()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:316
msgid "managed pci_intx()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:320
msgid "0 on success, -ENOMEM on error."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:321
msgid ""
"Enable/disable PCI INTx for device **pdev**. Restore the original state on "
"driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:362
msgid "Managed pci_enable_device()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:366
msgid ""
"Managed pci_enable_device(). Device will automatically be disabled on driver "
"detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:396
msgid "Pin managed PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:397
msgid "PCI device to pin"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:398
msgid ""
"Pin managed PCI device **pdev**. Pinned device won't be disabled on driver "
"detach. **pdev** must have been enabled with pcim_enable_device()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:419
msgid "access iomap allocation table (DEPRECATED)"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:420
msgid "PCI device to access iomap table for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:422
msgid "Const pointer to array of __iomem pointers on success, NULL on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:424
msgid ""
"Access iomap allocation table for **dev**.  If iomap table doesn't exist and "
"**pdev** is managed, it will be allocated.  All iomaps recorded in the iomap "
"table are automatically unmapped on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:429
msgid ""
"This function might sleep when the table is first allocated but can be "
"safely called without context and guaranteed to succeed once allocated."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:433
msgid ""
"This function is DEPRECATED. Do not use it in new code. Instead, obtain a "
"mapping's address directly from one of the pcim_* mapping functions. For"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:436
msgid "**example**"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:436
msgid "void __iomem \\*mappy = pcim_iomap(pdev, bar, length);"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:521
msgid "Managed pcim_iomap()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:522
msgid "PCI device to iomap for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:523
msgid "BAR to iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:524
msgid "Maximum length of iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:526
msgid "__iomem pointer on success, NULL on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:527
msgid ""
"Managed pci_iomap(). Map is automatically unmapped on driver detach. If "
"desired, unmap manually only with pcim_iounmap()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:530
msgid "This SHOULD only be used once per BAR."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:533
msgid ""
"Contrary to the other pcim_* functions, this function does not return an "
"IOMEM_ERR_PTR() on failure, but a simple NULL. This is done for backwards "
"compatibility."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:571
msgid "Managed pci_iounmap()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:572
msgid "PCI device to iounmap for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:574
msgid "``void __iomem *addr``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:573
msgid "Address to unmap"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:574
msgid ""
"Managed pci_iounmap(). **addr** must have been mapped using a pcim_* mapping "
"function."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:597
msgid "Request and iomap a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:598
#: drivers/pci/devres.c:668 drivers/pci/devres.c:790 drivers/pci/devres.c:821
msgid "PCI device to map IO resources for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:599
msgid "Index of a BAR to map"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:600
#: drivers/pci/devres.c:715
msgid "Name of the driver requesting the resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:602
#: drivers/pci/devres.c:826
msgid "__iomem pointer on success, an IOMEM_ERR_PTR on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:603
msgid ""
"Mapping and region will get automatically released on driver detach. If "
"desired, release manually only with pcim_iounmap_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:646
msgid "Unmap and release a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:647
#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:20 drivers/pci/irq.c:64
msgid "PCI device to operate on"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:648
msgid "Index of BAR to unmap and release"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:649
msgid ""
"Unmap a BAR and release its region manually. Only pass BARs that were "
"previously mapped by pcim_iomap_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:667
msgid "Request and iomap PCI BARs (DEPRECATED)"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:670
msgid "``int mask``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:669
msgid "Mask of BARs to request and iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:673
msgid "Request and iomap regions specified by **mask**."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:675
msgid ""
"This function is DEPRECATED. Do not use it in new code. Use "
"pcim_iomap_region() instead."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:712
msgid "Request a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:713
msgid "PCI device to request region for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:714
msgid "Index of BAR to request"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:717
msgid "0 on success, a negative error code on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:718
msgid "Request region specified by **bar**."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:720
msgid ""
"The region will automatically be released on driver detach. If desired, "
"release manually only with pcim_release_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:789
msgid "Request all regions"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:794
msgid ""
"Requested regions will automatically be released at driver detach. If "
"desired, release individual regions with pcim_release_region() or all of "
"them at once with pcim_release_all_regions()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:820
msgid "Create a ranged __iomap mapping within a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:822
msgid "Index of the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:823
msgid "Offset from the begin of the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:825
msgid "``unsigned long len``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:824
msgid "Length in bytes for the mapping"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:827
msgid ""
"Creates a new IO-Mapping within the specified **bar**, ranging from "
"**offset** to **offset** + **len**."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:830
msgid ""
"The mapping will automatically get unmapped on driver detach. If desired, "
"release manually only with pcim_iounmap()."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:33
msgid "add a new PCI device ID to this driver and re-probe devices"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:39
#: drivers/pci/pci-driver.c:1427 drivers/pci/pci-driver.c:1457
msgid "``struct pci_driver *drv``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:34
msgid "target pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:36
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:292
#: drivers/pci/search.c:323
msgid "``unsigned int vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:35
msgid "PCI vendor ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:37
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:289
#: drivers/pci/search.c:320
msgid "``unsigned int device``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:36
msgid "PCI device ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:38
msgid "``unsigned int subvendor``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:37
msgid "PCI subvendor ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:39
msgid "``unsigned int subdevice``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:38
msgid "PCI subdevice ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:40
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:344
#: drivers/pci/search.c:373
msgid "``unsigned int class``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:39
msgid "PCI class"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:41
msgid "``unsigned int class_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:40
msgid "PCI class mask"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:42
msgid "``unsigned long driver_data``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:41
msgid "private driver data"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:42
msgid ""
"Adds a new dynamic pci device ID to this driver and causes the driver to "
"probe for all devices again.  **drv** must have been registered prior to "
"calling this function."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:46
msgid "**Context**"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:47
msgid "Does GFP_KERNEL allocation."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:50
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:94
msgid "See if a PCI device matches a given pci_id table"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:100
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:404
msgid "``const struct pci_device_id *ids``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:95
msgid "array of PCI device ID structures to search in"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:96
msgid "the PCI device structure to match against."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:97
msgid ""
"Used by a driver to check whether a PCI device is in its list of supported "
"devices.  Returns the matching pci_device_id structure or ``NULL`` if there "
"is no match."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:101
msgid ""
"Deprecated; don't use this as it will not catch any dynamic IDs that a "
"driver might want to check for."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1421
msgid "register a new pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1422
msgid "the driver structure to register"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1424
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:343
#: drivers/pci/hotplug/pci_hotplug_core.c:376
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1423
msgid "owner module of drv"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1425
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:344
#: drivers/pci/hotplug/pci_hotplug_core.c:377
msgid "``const char *mod_name``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1424
msgid "module name string"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1425
msgid ""
"Adds the driver structure to the list of registered drivers. Returns a "
"negative value on error, otherwise 0. If no error occurred, the driver "
"remains registered even if no device was claimed during registration."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1451
msgid "unregister a pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1452
msgid "the driver structure to unregister"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1453
msgid ""
"Deletes the driver structure from the list of registered PCI drivers, gives "
"it a chance to clean up by calling its remove() function for each device it "
"was responsible for, and marks those devices as driverless."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1472
msgid "get the pci_driver of a device"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1473
msgid "the device to query"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1474
msgid ""
"Returns the appropriate pci_driver structure or ``NULL`` if there is no "
"registered driver for the device."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1520
msgid "increments the reference count of the pci device structure"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1521
msgid "the device being referenced"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1522
msgid "Each live reference to a device should be refcounted."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1524
msgid ""
"Drivers for PCI devices should normally record such references in their "
"probe() methods, when they bind to a device, and release them by calling "
"pci_dev_put(), in their disconnect() methods."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1528
msgid ""
"A pointer to the device with the incremented reference counter is returned."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1540
msgid "release a use of the pci device structure"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1541
msgid "device that's been disconnected"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1542
msgid ""
"Must be called when a user of a device is finished with it.  When the last "
"user of the device calls this function, the memory of the device is freed."
msgstr ""

#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:130
msgid "remove a PCI device and any children"
msgstr ""

#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:131
msgid "the device to remove"
msgstr ""

#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:132
msgid ""
"Remove a PCI device from the device lists, informing the drivers that the "
"device has been removed.  We also remove any subordinate buses and children "
"in a depth-first manner."
msgstr ""

#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:136
msgid ""
"For each device we remove, delete the device structure from the device "
"lists, remove the /proc entry, and notify userspace (/sbin/hotplug)."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:133
msgid "locate PCI bus from a given domain and bus number"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:139
#: drivers/pci/search.c:220
msgid "``int domain``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:134
msgid "number of PCI domain to search"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:136
msgid "``int busnr``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:135
msgid "number of desired PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:136
msgid ""
"Given a PCI bus number and domain number, the desired PCI bus is located in "
"the global list of PCI buses.  If the bus is found, a pointer to its data "
"structure is returned.  If no bus is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:158
msgid "begin or continue searching for a PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:164
msgid "``const struct pci_bus *from``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:159
msgid "Previous PCI bus found, or ``NULL`` for new search."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:160
msgid ""
"Iterates through the list of known PCI buses.  A new search is initiated by "
"passing ``NULL`` as the **from** argument.  Otherwise if **from** is not "
"``NULL``, searches continue from next device on the global list."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:181
msgid "locate PCI device for a given PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:182
#: drivers/pci/search.c:216
msgid "PCI bus on which desired PCI device resides"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:183
#: drivers/pci/search.c:217
msgid ""
"encodes number of PCI slot in which the desired PCI device resides and the "
"logical device number within that slot in case of multi-function devices."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:186
msgid ""
"Given a PCI bus and slot/function number, the desired PCI device is located "
"in the list of PCI devices. If the device is found, its reference count is "
"increased and this function returns a pointer to its data structure.  The "
"caller must decrement the reference count by calling pci_dev_put(). If no "
"device is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:214
msgid "locate PCI device for a given PCI domain (segment), bus, and slot"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:215
msgid "PCI domain/segment on which the PCI device resides."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:217
msgid "``unsigned int bus``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:220
msgid ""
"Given a PCI domain, bus, and slot/function number, the desired PCI device is "
"located in the list of PCI devices. If the device is found, its reference "
"count is increased and this function returns a pointer to its data "
"structure.  The caller must decrement the reference count by calling "
"pci_dev_put().  If no device is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:286
msgid ""
"begin or continue searching for a PCI device by vendor/subvendor/device/"
"subdevice id"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:287
#: drivers/pci/search.c:318
msgid "PCI vendor id to match, or ``PCI_ANY_ID`` to match all vendor ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:288
#: drivers/pci/search.c:319
msgid "PCI device id to match, or ``PCI_ANY_ID`` to match all device ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:290
msgid "``unsigned int ss_vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:289
msgid ""
"PCI subsystem vendor id to match, or ``PCI_ANY_ID`` to match all vendor ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:291
msgid "``unsigned int ss_device``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:290
msgid ""
"PCI subsystem device id to match, or ``PCI_ANY_ID`` to match all device ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:292
#: drivers/pci/search.c:321 drivers/pci/search.c:341 drivers/pci/search.c:370
msgid "``struct pci_dev *from``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:291
#: drivers/pci/search.c:320 drivers/pci/search.c:340 drivers/pci/search.c:369
msgid "Previous PCI device found in search, or ``NULL`` for new search."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:292
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **vendor**, **device**, **ss_vendor** and **ss_device**, a "
"pointer to its device structure is returned, and the reference count to the "
"device is incremented.  Otherwise, ``NULL`` is returned.  A new search is "
"initiated by passing ``NULL`` as the **from** argument.  Otherwise if "
"**from** is not ``NULL``, searches continue from next device on the global "
"list. The reference count for **from** is always decremented if it is not "
"``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:317
msgid "begin or continue searching for a PCI device by vendor/device id"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:321
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **vendor** and **device**, the reference count to the device "
"is incremented and a pointer to its device structure is returned. Otherwise, "
"``NULL`` is returned.  A new search is initiated by passing ``NULL`` as the "
"**from** argument.  Otherwise if **from** is not ``NULL``, searches continue "
"from next device on the global list.  The reference count for **from** is "
"always decremented if it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:338
msgid "begin or continue searching for a PCI device by class"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:339
msgid "search for a PCI device with this class designation"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:341
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **class**, the reference count to the device is incremented "
"and a pointer to its device structure is returned. Otherwise, ``NULL`` is "
"returned. A new search is initiated by passing ``NULL`` as the **from** "
"argument. Otherwise if **from** is not ``NULL``, searches continue from next "
"device on the global list.  The reference count for **from** is always "
"decremented if it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:367
msgid "searching for a PCI device by matching against the base class code only"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:368
msgid "search for a PCI device with this base class code"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:370
msgid ""
"Iterates through the list of known PCI devices. If a PCI device is found "
"with a matching base class code, the reference count to the device is "
"incremented. See pci_match_one_device() to figure out how does this works. A "
"new search is initiated by passing ``NULL`` as the **from** argument. "
"Otherwise if **from** is not ``NULL``, searches continue from next device on "
"the global list. The reference count for **from** is always decremented if "
"it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:379
msgid "A pointer to a matched PCI device, ``NULL`` Otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:398
msgid "Returns 1 if device matching the device list is present, 0 if not."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:399
msgid ""
"A pointer to a null terminated list of struct pci_device_id structures that "
"describe the type of PCI device the caller is trying to find."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:401
msgid ""
"Obvious fact: You do not have a reference to any device that might be found "
"by this function, so if that device is removed from the system right after "
"this function is finished, the value will be stale.  Use this function to "
"find devices that are usually built into a system, or for a general hint as "
"to if another device happens to be present at this specific moment in time."
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:131
msgid "Generic IRQ chip callback to mask PCI/MSI interrupts"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:137
#: drivers/pci/msi/msi.c:149
msgid "``struct irq_data *data``"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:132
#: drivers/pci/msi/msi.c:144
msgid "pointer to irqdata associated to that interrupt"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:143
msgid "Generic IRQ chip callback to unmask PCI/MSI interrupts"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:473
msgid "Return the number of MSI vectors a device can send"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:474
msgid "device to report about"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:475
msgid ""
"This function returns the number of MSI vectors a device requested via "
"Multiple Message Capable register. It returns a negative errno if the device "
"is not capable sending MSI interrupts. Otherwise, the call succeeds and "
"returns a power of two, up to a maximum of 2^5 (32), according to the MSI "
"specification."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:248
msgid "allocate a resource from a parent bus"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:249
msgid "PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:250
msgid "resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:251
msgid "size of resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:253
msgid "``resource_size_t align``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:252
msgid "alignment of resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:254
msgid "``resource_size_t min``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:253
msgid "minimum /proc/iomem address to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:255
msgid "``unsigned long type_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:254
msgid "IORESOURCE_* type flags"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:256
msgid "``resource_alignf alignf``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:255
msgid "resource alignment function"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:257
msgid "``void *alignf_data``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:256
msgid "data argument for resource alignment function"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:257
msgid ""
"Given the PCI bus a device resides on, the size, minimum address, alignment "
"and type, try to find an acceptable resource allocation for a specific "
"device resource."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:338
msgid "start driver for a single device"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:339
msgid "device to add"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:340
msgid "This adds add sysfs entries and start device drivers"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:388
msgid "start driver for PCI devices"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:394
msgid "``const struct pci_bus *bus``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:389
msgid "bus to check for new devices"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:390
msgid "Start driver for PCI devices and add some sysfs entries."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:436
msgid "walk devices on/under bus, calling callback."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:442
msgid "``struct pci_bus *top``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:437
msgid "bus whose devices should be walked"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:439
msgid "``int (*cb)(struct pci_dev *, void *)``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:438
msgid "callback to be called for each device found"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:440
msgid "``void *userdata``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:439
msgid "arbitrary pointer to be passed to callback"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:440
msgid ""
"Walk the given bus, including any bridged devices on buses under this bus.  "
"Call the provided callback on each device found."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:444
msgid ""
"We check the return of **cb** each time. If it returns anything other than "
"0, we break out."
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:187
msgid "Set raw operations of pci bus"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:188
msgid "pci bus struct"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:190
msgid "``struct pci_ops *ops``"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:189
msgid "new raw operations"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:190
msgid "Return previous raw operations"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:281
msgid "Lock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:282
#: drivers/pci/access.c:302 drivers/pci/access.c:326
msgid "pci device struct"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:283
msgid ""
"When access is locked, any userspace reads or writes to config space and "
"concurrent lock requests will sleep until access is allowed via "
"pci_cfg_access_unlock() again."
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:301
msgid "try to lock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:303
msgid ""
"Same as pci_cfg_access_lock, but will return 0 if access is already locked, "
"1 otherwise. This function can be used from atomic contexts."
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:325
msgid "Unlock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:327
msgid "This function allows PCI config accesses to resume."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:19
msgid "allocate an interrupt line for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:22 drivers/pci/irq.c:66
msgid "``unsigned int nr``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:21 drivers/pci/irq.c:65
msgid "device-relative interrupt vector index (0-based)."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:23
msgid "``irq_handler_t handler``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:22
msgid ""
"Function to be called when the IRQ occurs. Primary handler for threaded "
"interrupts. If NULL and thread_fn != NULL the default primary handler is "
"installed."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:27
msgid "``irq_handler_t thread_fn``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:26
msgid ""
"Function called from the IRQ handler thread If NULL, no IRQ thread is created"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:29 drivers/pci/irq.c:67
msgid "``void *dev_id``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:28
msgid "Cookie passed back to the handler function"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:30
msgid "``const char *fmt``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:29
msgid "Printf-like format string naming the handler"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:31
msgid "``...``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:30
msgid ""
"This call allocates interrupt resources and enables the interrupt line and "
"IRQ handling. From the point this call is made **handler** and **thread_fn** "
"may be invoked.  All interrupts requested using this function might be "
"shared."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:34
msgid "**dev_id** must not be NULL and must be globally unique."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:63
msgid "free an interrupt allocated with pci_request_irq"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:66
msgid "Device identity to free"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:67
msgid ""
"Remove an interrupt handler. The handler is removed and if the interrupt "
"line is no longer in use by any driver it is disabled.  The caller must "
"ensure the interrupt is disabled on the device before calling this function. "
"The function does not return until any executing interrupts for this IRQ "
"have completed."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:73
msgid "This function must not be called from interrupt context."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:122
msgid "swizzle INTx all the way to root bridge"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:125
msgid "``u8 *pinp``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:124
msgid "pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:125
msgid ""
"Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI "
"bridges all the way up to a PCI root bus."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:236
msgid "mask INTx on pending interrupt"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:238
msgid ""
"Check if the device dev has its INTx line asserted, mask it and return true "
"in that case. False is returned if no interrupt was pending."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:249
msgid "unmask INTx if no interrupt is pending"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:251
msgid ""
"Check if the device dev has its INTx line asserted, unmask it if not and "
"return true. False is returned and the mask remains active if there was "
"still an interrupt pending."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2287
msgid "Probe for PCIe relaxed ordering enable"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2289
msgid "Returns true if the device has enabled relaxed ordering attribute."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2848
msgid "Scan a PCI slot on a bus for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2849
#: drivers/pci/probe.c:3480
msgid "PCI bus to scan"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2851
msgid "``int devfn``"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2850
msgid "slot number to scan (must have zero function)"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2851
msgid ""
"Scan a PCI slot on the specified PCI bus for devices, adding discovered "
"devices to the **bus->devices** list.  New devices will not have is_added "
"set."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2855
msgid "Returns the number of new devices found."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3192
msgid "Scan devices below a bus"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3193
msgid "Bus to scan for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3194
msgid ""
"Scans devices below **bus** including subordinate buses. Returns new "
"subordinate number including all the found devices."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3479
msgid "Scan a PCI bus for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3481
msgid ""
"Scan a PCI bus and child buses for new devices, add them, and enable them."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3484
msgid "Returns the max number of subordinate bus discovered."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:189
msgid "create or increment refcount for physical PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:195
msgid "``struct pci_bus *parent``"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:190
msgid "struct pci_bus of parent bridge"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:192
msgid "``int slot_nr``"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:191
msgid "PCI_SLOT(pci_dev->devfn) or -1 for placeholder"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:192
msgid "user visible string presented in /sys/bus/pci/slots/<name>"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:194
msgid "``struct hotplug_slot *hotplug``"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:193
msgid "set if caller is hotplug driver, NULL otherwise"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:194
msgid ""
"PCI slots have first class attributes such as address, speed, width, and a :"
"c:type:`struct pci_slot <pci_slot>` is used to manage them. This interface "
"will either return a new :c:type:`struct pci_slot <pci_slot>` to the caller, "
"or if the pci_slot already exists, its refcount will be incremented."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:199
msgid "Slots are uniquely identified by a **pci_bus**, **slot_nr** tuple."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:201
msgid ""
"There are known platforms with broken firmware that assign the same name to "
"multiple slots. Workaround these broken platforms by renaming the slots on "
"behalf of the caller. If firmware assigns name N to multiple slots:"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:206
msgid ""
"The first slot is assigned N The second slot is assigned N-1 The third slot "
"is assigned N-2 etc."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:211
msgid ""
"Placeholder slots: In most cases, **pci_bus**, **slot_nr** will be "
"sufficient to uniquely identify a slot. There is one notable exception - "
"pSeries (rpaphp), where the **slot_nr** cannot be determined until a device "
"is actually inserted into the slot. In this scenario, the caller may pass -1 "
"for **slot_nr**."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:217
msgid ""
"The following semantics are imposed when the caller passes **slot_nr** == "
"-1. First, we no longer check for an existing ``struct`` pci_slot, as there "
"may be many slots with **slot_nr** of -1.  The other change in semantics is "
"user-visible, which is the 'address' parameter presented in sysfs will "
"consist solely of a dddd:bb tuple, where dddd is the PCI domain of the "
"``struct`` pci_bus and bb is the bus number. In other words, the devfn of "
"the 'placeholder' slot will not be displayed."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:309
msgid "decrement refcount for physical PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:310
msgid "struct pci_slot to decrement"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:311
msgid ""
"``struct`` pci_slot is refcounted, so destroying them is really easy; we "
"just call kobject_put on its kobj and let our release methods do the rest."
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:16
msgid "enable ROM decoding for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:17
msgid "PCI device to enable"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:18
msgid ""
"Enable ROM decoding on **dev**.  This involves simply turning on the last "
"bit of the PCI ROM BAR.  Note that some cards may share address decoders "
"between the ROM and other resources, so enabling it may disable access to "
"MMIO registers or other card memory."
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:52
msgid "disable ROM decoding for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:53
msgid "PCI device to disable"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:54
msgid ""
"Disable ROM decoding on a PCI device by turning off the last bit in the ROM "
"BAR."
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:126
msgid "map a PCI ROM to kernel space"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:127 drivers/pci/rom.c:182
msgid "pointer to pci device struct"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:129
msgid "``size_t *size``"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:128
msgid "pointer to receive size of pci window over ROM"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:130
msgid "kernel virtual pointer to image of ROM"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:131
msgid ""
"Map a PCI ROM into kernel space. If ROM is boot video ROM, the shadow BIOS "
"copy will be returned instead of the actual ROM."
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:181
msgid "unmap the ROM from kernel space"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:184
msgid "``void __iomem *rom``"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:183
msgid "virtual address of the previous mapping"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:184
msgid "Remove a mapping of a previously mapped ROM"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:55
msgid "Return the drvdata of a PF"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:56
msgid "VF pci_dev"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:58
msgid "``struct pci_driver *pf_driver``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:57
msgid "Device driver required to own the PF"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:58
msgid ""
"This must be called from a context that ensures that a VF driver is "
"attached. The value returned is invalid once the VF driver completes its "
"remove() callback."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:62
msgid ""
"Locking is achieved by the driver core. A VF driver cannot be probed until "
"pci_enable_sriov() is called and pci_disable_sriov() does not return until "
"all VF drivers have completed their remove()."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:66
msgid ""
"The PF driver must call pci_disable_sriov() before it begins to destroy the "
"drvdata."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1155
msgid "enable the SR-IOV capability"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1158
#: drivers/pci/iov.c:1294
msgid "``int nr_virtfn``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1157
msgid "number of virtual functions to enable"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1158
msgid "Returns 0 on success, or negative on failure."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1173
msgid "disable the SR-IOV capability"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1188
msgid "return number of VFs associated with a PF device_release_driver"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1190
msgid "Returns number of VFs, or 0 if SR-IOV is not enabled."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1203
msgid "returns number of VFs are assigned to a guest"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1205
msgid ""
"Returns number of VFs belonging to this device that are assigned to a guest. "
"If device is not a physical function returns 0."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1244
msgid "reduce the TotalVFs available"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1245
#: drivers/pci/iov.c:1275
msgid "the PCI PF device"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1247
msgid "``u16 numvfs``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1246
msgid "number that should be used for TotalVFs supported"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1247
msgid ""
"Should be called from PF driver's probe routine with device's mutex held."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1250
msgid ""
"Returns 0 if PF is an SRIOV-capable device and value of numvfs valid. If not "
"a PF return -ENOSYS; if numvfs is invalid return -EINVAL; if VFs already "
"enabled, return -EBUSY."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1274
msgid "get total VFs supported on this device"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1276
msgid ""
"For a PCIe device with SRIOV support, return the PCIe SRIOV capability value "
"of TotalVFs or the value of driver_max_VFs if the driver reduced it.  "
"Otherwise 0."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1291
msgid "helper to configure SR-IOV"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1293
msgid "number of virtual functions to enable, 0 to disable"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1294
msgid ""
"Enable or disable SR-IOV for devices that don't require any PF setup before "
"enabling SR-IOV.  Return value is negative on error, or number of VFs "
"allocated on success."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1327
msgid "set a new size for a VF BAR"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1330
#: drivers/pci/iov.c:1372
msgid "``int resno``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1329
#: drivers/pci/iov.c:1371
msgid "the resource number"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1331
msgid "``int size``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1330
msgid "new size as defined in the spec (0=1MB, 31=128TB)"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1331
msgid ""
"Set the new size of a VF BAR that supports VF resizable BAR capability. "
"Unlike pci_resize_resource(), this does not cause the resource that reserves "
"the MMIO space (originally up to total_VFs) to be resized, which means that "
"following calls to pci_enable_sriov() can fail if the resources no longer "
"fit."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1338
msgid "0 on success, or negative on failure."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1369
msgid "get VF BAR sizes allowing to create up to num_vfs"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1373
msgid "``int num_vfs``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1372
msgid "number of VFs"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1373
msgid ""
"Get the sizes of a VF resizable BAR that can accommodate **num_vfs** within "
"the currently assigned size of the resource **resno**."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1377
msgid ""
"A bitmask of sizes in format defined in the spec (bit 0=1MB, bit 31=128TB)."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:921
msgid "read byte(s) from legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:927
#: drivers/pci/pci-sysfs.c:952 drivers/pci/pci-sysfs.c:977
#: drivers/pci/pci-sysfs.c:997 drivers/pci/pci-sysfs.c:1337
#: drivers/pci/pci-sysfs.c:1362
msgid "``struct file *filp``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:922
#: drivers/pci/pci-sysfs.c:947 drivers/pci/pci-sysfs.c:972
#: drivers/pci/pci-sysfs.c:992
msgid "open sysfs file"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:924
#: drivers/pci/pci-sysfs.c:949 drivers/pci/pci-sysfs.c:974
#: drivers/pci/pci-sysfs.c:994 drivers/pci/pci-sysfs.c:1104
#: drivers/pci/pci-sysfs.c:1334 drivers/pci/pci-sysfs.c:1359
msgid "``struct kobject *kobj``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:923
#: drivers/pci/pci-sysfs.c:948
msgid "kobject corresponding to file to read from"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:925
#: drivers/pci/pci-sysfs.c:950 drivers/pci/pci-sysfs.c:1335
#: drivers/pci/pci-sysfs.c:1360
msgid "``const struct bin_attribute *bin_attr``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:924
#: drivers/pci/pci-sysfs.c:949 drivers/pci/pci-sysfs.c:974
#: drivers/pci/pci-sysfs.c:994 drivers/pci/pci-sysfs.c:1334
#: drivers/pci/pci-sysfs.c:1359
msgid "struct bin_attribute for this file"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:926
#: drivers/pci/pci-sysfs.c:951 drivers/pci/pci-sysfs.c:1336
#: drivers/pci/pci-sysfs.c:1361
msgid "``char *buf``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:925
msgid "buffer to store results"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:927
#: drivers/pci/pci-sysfs.c:952 drivers/pci/pci-sysfs.c:1337
#: drivers/pci/pci-sysfs.c:1362
msgid "``loff_t off``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:926
#: drivers/pci/pci-sysfs.c:951
msgid "offset into legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:928
#: drivers/pci/pci-sysfs.c:953 drivers/pci/pci-sysfs.c:1338
#: drivers/pci/pci-sysfs.c:1363
msgid "``size_t count``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:927
#: drivers/pci/pci-sysfs.c:1362
msgid "number of bytes to read"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:928
msgid ""
"Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific "
"callback routine (pci_legacy_read)."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:946
msgid "write byte(s) to legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:950
msgid "buffer containing value to be written"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:952
msgid "number of bytes to write"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:953
msgid ""
"Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific "
"callback routine (pci_legacy_write)."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:971
msgid "map legacy PCI memory into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:973
#: drivers/pci/pci-sysfs.c:993
msgid "kobject corresponding to device to be mapped"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:975
#: drivers/pci/pci-sysfs.c:995 drivers/pci/pci-sysfs.c:1101
msgid "``const struct bin_attribute *attr``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:976
#: drivers/pci/pci-sysfs.c:996 drivers/pci/pci-sysfs.c:1102
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:975
#: drivers/pci/pci-sysfs.c:995
msgid "struct vm_area_struct passed to mmap"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:976
msgid ""
"Uses an arch specific callback, pci_mmap_legacy_mem_page_range, to mmap "
"legacy memory space (first meg of bus space) into application virtual memory "
"space."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:991
msgid "map legacy PCI IO into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:996
msgid ""
"Uses an arch specific callback, pci_mmap_legacy_io_page_range, to mmap "
"legacy IO space (first meg of bus space) into application virtual memory "
"space. Returns -ENOSYS if the operation isn't supported"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1011
msgid "adjustment of legacy file attributes"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1017
#: drivers/pci/pci-sysfs.c:1029
msgid "``struct pci_bus *b``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1012
#: drivers/pci/pci-sysfs.c:1024
msgid "bus to create files under"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1014
msgid "``enum pci_mmap_state mmap_type``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1013
msgid "I/O port or memory"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1014
msgid "Stub implementation. Can be overridden by arch if necessary."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1023
msgid "create legacy I/O port and memory files"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1025
msgid ""
"Some platforms allow access to legacy I/O port and ISA memory space on a per-"
"bus basis.  This routine creates the files and ties them into their "
"associated read, write and mmap files from pci-sysfs.c"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1029
msgid ""
"On error unwind, but don't propagate the error to the caller as it is ok to "
"set up the PCI bus without these files."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1098
msgid "map a PCI resource into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1099
msgid "kobject for mapping"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1100
msgid "struct bin_attribute for the file being mapped"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1101
msgid "struct vm_area_struct passed into the mmap"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1103
msgid "``int write_combine``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1102
msgid "1 for write_combine mapping"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1103
msgid ""
"Use the regular PCI mapping routines to map a PCI resource into userspace."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1208
msgid "cleanup resource files"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1209
msgid "dev to cleanup"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1210
msgid ""
"If we created resource files for **pdev**, remove them from sysfs and free "
"their resources."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1292
msgid "create resource files in sysfs for **dev**"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1293
msgid "dev in question"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1294
msgid ""
"Walk the resources in **pdev** creating files for each resource available."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1331
msgid "used to enable access to the PCI ROM display"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1332
#: drivers/pci/pci-sysfs.c:1357
msgid "sysfs file"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1333
#: drivers/pci/pci-sysfs.c:1358
msgid "kernel object handle"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1335
msgid "user input"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1336
#: drivers/pci/pci-sysfs.c:1361
msgid "file offset"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1337
msgid "number of byte in input"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1338
msgid "writing anything except 0 enables it"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1356
msgid "read a PCI ROM"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1360
msgid "where to put the data we read from the ROM"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1363
msgid ""
"Put **count** bytes starting at **off** into **buf** from the ROM in the PCI "
"device corresponding to **kobj**."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1713
msgid "cleanup PCI specific sysfs files"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1714
msgid "device whose entries we should free"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1715
msgid "Cleanup when **pdev** is removed from sysfs."
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:225
msgid ""
"Retrieve Steering Tag for a target memory associated with a specific CPU"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:229
msgid "``enum tph_mem_type mem_type``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:228
msgid "target memory type (volatile or persistent RAM)"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:230
msgid "``unsigned int cpu_uid``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:229
msgid "associated CPU id"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:231
msgid "``u16 *tag``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:230
msgid "Steering Tag to be returned"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:231
msgid ""
"Return the Steering Tag for a target memory that is associated with a "
"specific CPU as indicated by cpu_uid."
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:235 drivers/pci/tph.c:279
msgid "0 if success, otherwise negative value (-errno)"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:270
msgid "Set Steering Tag in the ST table entry"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:273
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:272
msgid "ST table entry index"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:274
msgid "``u16 tag``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:273
msgid "Steering Tag to be written"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:274
msgid ""
"Figure out the proper location of ST table, either in the MSI-X table or in "
"the TPH Extended Capability space, and write the Steering Tag into the ST "
"entry pointed by index."
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:332
msgid "Turn off TPH support for device"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:335
msgid "none"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:354
msgid "Enable TPH support for device using a specific ST mode"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:357
msgid "``int mode``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:356
msgid "ST mode to enable. Current supported modes include:"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:357
msgid "PCI_TPH_ST_NS_MODE: NO ST Mode"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:358
msgid "PCI_TPH_ST_IV_MODE: Interrupt Vector Mode"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:359
msgid "PCI_TPH_ST_DS_MODE: Device Specific Mode"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:361
msgid ""
"Check whether the mode is actually supported by the device before enabling "
"and return an error if not. Additionally determine what types of requests, "
"TPH or extended TPH, can be issued by the device based on its TPH requester "
"capability and the Root Port's completer capability."
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:367
msgid "0 on success, otherwise negative value (-errno)"
msgstr ""

#: ../../../driver-api/pci/pci.rst:53
msgid "PCI Hotplug Support Library"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:337
msgid "register a hotplug_slot with the PCI hotplug subsystem"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:343
#: drivers/pci/hotplug/pci_hotplug_core.c:376
#: drivers/pci/hotplug/pci_hotplug_core.c:421
#: drivers/pci/hotplug/pci_hotplug_core.c:450
#: drivers/pci/hotplug/pci_hotplug_core.c:464
#: drivers/pci/hotplug/pci_hotplug_core.c:479
msgid "``struct hotplug_slot *slot``"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:338
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to register"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:339
#: drivers/pci/hotplug/pci_hotplug_core.c:372
msgid "bus this slot is on"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:341
#: drivers/pci/hotplug/pci_hotplug_core.c:374
msgid "``int devnr``"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:340
msgid "device number"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:341
#: drivers/pci/hotplug/pci_hotplug_core.c:374
msgid "name registered with kobject core"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:342
#: drivers/pci/hotplug/pci_hotplug_core.c:375
msgid "caller module owner"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:343
#: drivers/pci/hotplug/pci_hotplug_core.c:376
msgid "caller module name"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:344
msgid ""
"Prepares a hotplug slot for in-kernel use and immediately publishes it to "
"user space in one go.  Drivers may alternatively carry out the two steps "
"separately by invoking pci_hp_initialize() and pci_hp_add()."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:348
msgid "Returns 0 if successful, anything else for an error."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:370
msgid "prepare hotplug slot for in-kernel use"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:371
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to initialize"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:373
msgid "slot number"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:377
msgid ""
"Allocate and fill in a PCI slot for use by a hotplug driver.  Once this has "
"been called, the driver may invoke hotplug_slot_name() to get the slot's "
"unique name.  The driver must be prepared to handle a ->reset_slot callback "
"from this point on."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:382
#: drivers/pci/hotplug/pci_hotplug_core.c:421
msgid "Returns 0 on success or a negative int on error."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:415
msgid "publish hotplug slot to user space"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:416
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to publish"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:417
msgid ""
"Make a hotplug slot's sysfs interface available and inform user space of its "
"addition by sending a uevent.  The hotplug driver must be prepared to handle "
"all :c:type:`struct hotplug_slot_ops <hotplug_slot_ops>` callbacks from this "
"point on."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:444
msgid "deregister a hotplug_slot with the PCI hotplug subsystem"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:445
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to deregister"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:446
msgid ""
"The **slot** must have been registered with the pci hotplug subsystem "
"previously with a call to pci_hp_register()."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:458
msgid "unpublish hotplug slot from user space"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:459
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to unpublish"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:460
msgid "Remove a hotplug slot's sysfs interface."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:473
msgid "remove hotplug slot from in-kernel use"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:474
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to destroy"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:475
msgid ""
"Destroy a PCI slot used by a hotplug driver.  Once this has been called, the "
"driver may no longer invoke hotplug_slot_name() to get the slot's unique "
"name.  The driver no longer needs to handle a ->reset_slot callback from "
"this point on."
msgstr ""
