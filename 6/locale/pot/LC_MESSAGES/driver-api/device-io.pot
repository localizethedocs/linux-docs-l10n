# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/device-io.rst:11
msgid "Bus-Independent Device Accesses"
msgstr ""

#: ../../../driver-api/device-io.rst:0
msgid "Author"
msgstr ""

#: ../../../driver-api/device-io.rst:13
msgid "Matthew Wilcox"
msgstr ""

#: ../../../driver-api/device-io.rst:14
msgid "Alan Cox"
msgstr ""

#: ../../../driver-api/device-io.rst:17
msgid "Introduction"
msgstr ""

#: ../../../driver-api/device-io.rst:19
msgid ""
"Linux provides an API which abstracts performing IO across all buses and "
"devices, allowing device drivers to be written independently of bus type."
msgstr ""

#: ../../../driver-api/device-io.rst:24
msgid "Memory Mapped IO"
msgstr ""

#: ../../../driver-api/device-io.rst:27
msgid "Getting Access to the Device"
msgstr ""

#: ../../../driver-api/device-io.rst:29
msgid ""
"The most widely supported form of IO is memory mapped IO. That is, a part of "
"the CPU's address space is interpreted not as accesses to memory, but as "
"accesses to a device. Some architectures define devices to be at a fixed "
"address, but most have some method of discovering devices. The PCI bus walk "
"is a good example of such a scheme. This document does not cover how to "
"receive such an address, but assumes you are starting with one. Physical "
"addresses are of type unsigned long."
msgstr ""

#: ../../../driver-api/device-io.rst:37
msgid ""
"This address should not be used directly. Instead, to get an address "
"suitable for passing to the accessor functions described below, you should "
"call ioremap(). An address suitable for accessing the device will be "
"returned to you."
msgstr ""

#: ../../../driver-api/device-io.rst:42
msgid ""
"After you've finished using the device (say, in your module's exit routine), "
"call iounmap() in order to return the address space to the kernel. Most "
"architectures allocate new address space each time you call ioremap(), and "
"they can run out unless you call iounmap()."
msgstr ""

#: ../../../driver-api/device-io.rst:49
msgid "Accessing the device"
msgstr ""

#: ../../../driver-api/device-io.rst:51
msgid ""
"The part of the interface most used by drivers is reading and writing memory-"
"mapped registers on the device. Linux provides interfaces to read and write "
"8-bit, 16-bit, 32-bit and 64-bit quantities. Due to a historical accident, "
"these are named byte, word, long and quad accesses. Both read and write "
"accesses are supported; there is no prefetch support at this time."
msgstr ""

#: ../../../driver-api/device-io.rst:58
msgid ""
"The functions are named readb(), readw(), readl(), readq(), readb_relaxed(), "
"readw_relaxed(), readl_relaxed(), readq_relaxed(), writeb(), writew(), "
"writel() and writeq()."
msgstr ""

#: ../../../driver-api/device-io.rst:62
msgid ""
"Some devices (such as framebuffers) would like to use larger transfers than "
"8 bytes at a time. For these devices, the memcpy_toio(), memcpy_fromio() and "
"memset_io() functions are provided. Do not use memset or memcpy on IO "
"addresses; they are not guaranteed to copy data in order."
msgstr ""

#: ../../../driver-api/device-io.rst:68
msgid ""
"The read and write functions are defined to be ordered. That is the compiler "
"is not permitted to reorder the I/O sequence. When the ordering can be "
"compiler optimised, you can use __readb() and friends to indicate the "
"relaxed ordering. Use this with care."
msgstr ""

#: ../../../driver-api/device-io.rst:73
msgid ""
"While the basic functions are defined to be synchronous with respect to each "
"other and ordered with respect to each other the buses the devices sit on "
"may themselves have asynchronicity. In particular many authors are burned by "
"the fact that PCI bus writes are posted asynchronously. A driver author must "
"issue a read from the same device to ensure that writes have occurred in the "
"specific cases the author cares. This kind of property cannot be hidden from "
"driver writers in the API. In some cases, the read used to flush the device "
"may be expected to fail (if the card is resetting, for example). In that "
"case, the read should be done from config space, which is guaranteed to soft-"
"fail if the card doesn't respond."
msgstr ""

#: ../../../driver-api/device-io.rst:85
msgid ""
"The following is an example of flushing a write to a device when the driver "
"would like to ensure the write's effects are visible prior to continuing "
"execution::"
msgstr ""

#: ../../../driver-api/device-io.rst:106
msgid ""
"PCI ordering rules also guarantee that PIO read responses arrive after any "
"outstanding DMA writes from that bus, since for some devices the result of a "
"readb() call may signal to the driver that a DMA transaction is complete. In "
"many cases, however, the driver may want to indicate that the next readb() "
"call has no relation to any previous DMA writes performed by the device. The "
"driver can use readb_relaxed() for these cases, although only some platforms "
"will honor the relaxed semantics. Using the relaxed read functions will "
"provide significant performance benefits on platforms that support it. The "
"qla2xxx driver provides examples of how to use readX_relaxed(). In many "
"cases, a majority of the driver's readX() calls can safely be converted to "
"readX_relaxed() calls, since only a few will indicate or depend on DMA "
"completion."
msgstr ""

#: ../../../driver-api/device-io.rst:120
msgid "Port Space Accesses"
msgstr ""

#: ../../../driver-api/device-io.rst:123
msgid "Port Space Explained"
msgstr ""

#: ../../../driver-api/device-io.rst:125
msgid ""
"Another form of IO commonly supported is Port Space. This is a range of "
"addresses separate to the normal memory address space. Access to these "
"addresses is generally not as fast as accesses to the memory mapped "
"addresses, and it also has a potentially smaller address space."
msgstr ""

#: ../../../driver-api/device-io.rst:130
msgid ""
"Unlike memory mapped IO, no preparation is required to access port space."
msgstr ""

#: ../../../driver-api/device-io.rst:134
msgid "Accessing Port Space"
msgstr ""

#: ../../../driver-api/device-io.rst:136
msgid ""
"Accesses to this space are provided through a set of functions which allow 8-"
"bit, 16-bit and 32-bit accesses; also known as byte, word and long. These "
"functions are inb(), inw(), inl(), outb(), outw() and outl()."
msgstr ""

#: ../../../driver-api/device-io.rst:142
msgid ""
"Some variants are provided for these functions. Some devices require that "
"accesses to their ports are slowed down. This functionality is provided by "
"appending a ``_p`` to the end of the function. There are also equivalents to "
"memcpy. The ins() and outs() functions copy bytes, words or longs to the "
"given port."
msgstr ""

#: ../../../driver-api/device-io.rst:150
msgid "__iomem pointer tokens"
msgstr ""

#: ../../../driver-api/device-io.rst:152
msgid ""
"The data type for an MMIO address is an ``__iomem`` qualified pointer, such "
"as ``void __iomem *reg``. On most architectures it is a regular pointer that "
"points to a virtual memory address and can be offset or dereferenced, but in "
"portable code, it must only be passed from and to functions that explicitly "
"operated on an ``__iomem`` token, in particular the ioremap() and readl()/"
"writel() functions. The 'sparse' semantic code checker can be used to verify "
"that this is done correctly."
msgstr ""

#: ../../../driver-api/device-io.rst:160
msgid ""
"While on most architectures, ioremap() creates a page table entry for an "
"uncached virtual address pointing to the physical MMIO address, some "
"architectures require special instructions for MMIO, and the ``__iomem`` "
"pointer just encodes the physical address or an offsettable cookie that is "
"interpreted by readl()/writel()."
msgstr ""

#: ../../../driver-api/device-io.rst:167
msgid "Differences between I/O access functions"
msgstr ""

#: ../../../driver-api/device-io.rst:169
msgid ""
"readq(), readl(), readw(), readb(), writeq(), writel(), writew(), writeb()"
msgstr ""

#: ../../../driver-api/device-io.rst:171
msgid ""
"These are the most generic accessors, providing serialization against other "
"MMIO accesses and DMA accesses as well as fixed endianness for accessing "
"little-endian PCI devices and on-chip peripherals. Portable device drivers "
"should generally use these for any access to ``__iomem`` pointers."
msgstr ""

#: ../../../driver-api/device-io.rst:176
msgid ""
"Note that posted writes are not strictly ordered against a spinlock, see "
"Documentation/driver-api/io_ordering.rst."
msgstr ""

#: ../../../driver-api/device-io.rst:179
msgid ""
"readq_relaxed(), readl_relaxed(), readw_relaxed(), readb_relaxed(), "
"writeq_relaxed(), writel_relaxed(), writew_relaxed(), writeb_relaxed()"
msgstr ""

#: ../../../driver-api/device-io.rst:182
msgid ""
"On architectures that require an expensive barrier for serializing against "
"DMA, these \"relaxed\" versions of the MMIO accessors only serialize against "
"each other, but contain a less expensive barrier operation. A device driver "
"might use these in a particularly performance sensitive fast path, with a "
"comment that explains why the usage in a specific location is safe without "
"the extra barriers."
msgstr ""

#: ../../../driver-api/device-io.rst:189
msgid ""
"See memory-barriers.txt for a more detailed discussion on the precise "
"ordering guarantees of the non-relaxed and relaxed versions."
msgstr ""

#: ../../../driver-api/device-io.rst:192
msgid ""
"ioread64(), ioread32(), ioread16(), ioread8(), iowrite64(), iowrite32(), "
"iowrite16(), iowrite8()"
msgstr ""

#: ../../../driver-api/device-io.rst:195
msgid ""
"These are an alternative to the normal readl()/writel() functions, with "
"almost identical behavior, but they can also operate on ``__iomem`` tokens "
"returned for mapping PCI I/O space with pci_iomap() or ioport_map(). On "
"architectures that require special instructions for I/O port access, this "
"adds a small overhead for an indirect function call implemented in lib/iomap."
"c, while on other architectures, these are simply aliases."
msgstr ""

#: ../../../driver-api/device-io.rst:202
msgid ""
"ioread64be(), ioread32be(), ioread16be() iowrite64be(), iowrite32be(), "
"iowrite16be()"
msgstr ""

#: ../../../driver-api/device-io.rst:205
msgid ""
"These behave in the same way as the ioread32()/iowrite32() family, but with "
"reversed byte order, for accessing devices with big-endian MMIO registers. "
"Device drivers that can operate on either big-endian or little-endian "
"registers may have to implement a custom wrapper function that picks one or "
"the other depending on which device was found."
msgstr ""

#: ../../../driver-api/device-io.rst:211
msgid ""
"Note: On some architectures, the normal readl()/writel() functions "
"traditionally assume that devices are the same endianness as the CPU, while "
"using a hardware byte-reverse on the PCI bus when running a big-endian "
"kernel. Drivers that use readl()/writel() this way are generally not "
"portable, but tend to be limited to a particular SoC."
msgstr ""

#: ../../../driver-api/device-io.rst:217
msgid ""
"hi_lo_readq(), lo_hi_readq(), hi_lo_readq_relaxed(), lo_hi_readq_relaxed(), "
"ioread64_lo_hi(), ioread64_hi_lo(), ioread64be_lo_hi(), ioread64be_hi_lo(), "
"hi_lo_writeq(), lo_hi_writeq(), hi_lo_writeq_relaxed(), "
"lo_hi_writeq_relaxed(), iowrite64_lo_hi(), iowrite64_hi_lo(), "
"iowrite64be_lo_hi(), iowrite64be_hi_lo()"
msgstr ""

#: ../../../driver-api/device-io.rst:222
msgid ""
"Some device drivers have 64-bit registers that cannot be accessed atomically "
"on 32-bit architectures but allow two consecutive 32-bit accesses instead. "
"Since it depends on the particular device which of the two halves has to be "
"accessed first, a helper is provided for each combination of 64-bit "
"accessors with either low/high or high/low word ordering. A device driver "
"must include either <linux/io-64-nonatomic-lo-hi.h> or <linux/io-64-"
"nonatomic-hi-lo.h> to get the function definitions along with helpers that "
"redirect the normal readq()/writeq() to them on architectures that do not "
"provide 64-bit access natively."
msgstr ""

#: ../../../driver-api/device-io.rst:232
msgid ""
"__raw_readq(), __raw_readl(), __raw_readw(), __raw_readb(), __raw_writeq(), "
"__raw_writel(), __raw_writew(), __raw_writeb()"
msgstr ""

#: ../../../driver-api/device-io.rst:235
msgid ""
"These are low-level MMIO accessors without barriers or byteorder changes and "
"architecture specific behavior. Accesses are usually atomic in the sense "
"that a four-byte __raw_readl() does not get split into individual byte "
"loads, but multiple consecutive accesses can be combined on the bus. In "
"portable code, it is only safe to use these to access memory behind a device "
"bus but not MMIO registers, as there are no ordering guarantees with regard "
"to other MMIO accesses or even spinlocks. The byte order is generally the "
"same as for normal memory, so unlike the other functions, these can be used "
"to copy data between kernel memory and device memory."
msgstr ""

#: ../../../driver-api/device-io.rst:245
msgid "inl(), inw(), inb(), outl(), outw(), outb()"
msgstr ""

#: ../../../driver-api/device-io.rst:247
msgid ""
"PCI I/O port resources traditionally require separate helpers as they are "
"implemented using special instructions on the x86 architecture. On most "
"other architectures, these are mapped to readl()/writel() style accessors "
"internally, usually pointing to a fixed area in virtual memory. Instead of "
"an ``__iomem`` pointer, the address is a 32-bit integer token to identify a "
"port number. PCI requires I/O port access to be non-posted, meaning that an "
"outb() must complete before the following code executes, while a normal "
"writeb() may still be in progress. On architectures that correctly implement "
"this, I/O port access is therefore ordered against spinlocks. Many non-x86 "
"PCI host bridge implementations and CPU architectures however fail to "
"implement non-posted I/O space on PCI, so they can end up being posted on "
"such hardware."
msgstr ""

#: ../../../driver-api/device-io.rst:259
msgid ""
"In some architectures, the I/O port number space has a 1:1 mapping to "
"``__iomem`` pointers, but this is not recommended and device drivers should "
"not rely on that for portability. Similarly, an I/O port number as described "
"in a PCI base address register may not correspond to the port number as seen "
"by a device driver. Portable drivers need to read the port number for the "
"resource provided by the kernel."
msgstr ""

#: ../../../driver-api/device-io.rst:266
msgid ""
"There are no direct 64-bit I/O port accessors, but pci_iomap() in "
"combination with ioread64/iowrite64 can be used instead."
msgstr ""

#: ../../../driver-api/device-io.rst:269
msgid "inl_p(), inw_p(), inb_p(), outl_p(), outw_p(), outb_p()"
msgstr ""

#: ../../../driver-api/device-io.rst:271
msgid ""
"On ISA devices that require specific timing, the _p versions of the I/O "
"accessors add a small delay. On architectures that do not have ISA buses, "
"these are aliases to the normal inb/outb helpers."
msgstr ""

#: ../../../driver-api/device-io.rst:275
msgid ""
"readsq, readsl, readsw, readsb writesq, writesl, writesw, writesb "
"ioread64_rep, ioread32_rep, ioread16_rep, ioread8_rep iowrite64_rep, "
"iowrite32_rep, iowrite16_rep, iowrite8_rep insl, insw, insb, outsl, outsw, "
"outsb"
msgstr ""

#: ../../../driver-api/device-io.rst:281
msgid ""
"These are helpers that access the same address multiple times, usually to "
"copy data between kernel memory byte stream and a FIFO buffer. Unlike the "
"normal MMIO accessors, these do not perform a byteswap on big-endian "
"kernels, so the first byte in the FIFO register corresponds to the first "
"byte in the memory buffer regardless of the architecture."
msgstr ""

#: ../../../driver-api/device-io.rst:288
msgid "Device memory mapping modes"
msgstr ""

#: ../../../driver-api/device-io.rst:290
msgid ""
"Some architectures support multiple modes for mapping device memory. "
"ioremap_*() variants provide a common abstraction around these architecture-"
"specific modes, with a shared set of semantics."
msgstr ""

#: ../../../driver-api/device-io.rst:294
msgid ""
"ioremap() is the most common mapping type, and is applicable to typical "
"device memory (e.g. I/O registers). Other modes can offer weaker or stronger "
"guarantees, if supported by the architecture. From most to least common, "
"they are as follows:"
msgstr ""

#: ../../../driver-api/device-io.rst:300 ../../../driver-api/device-io.rst:444
msgid "ioremap()"
msgstr ""

#: ../../../driver-api/device-io.rst:302
msgid ""
"The default mode, suitable for most memory-mapped devices, e.g. control "
"registers. Memory mapped using ioremap() has the following characteristics:"
msgstr ""

#: ../../../driver-api/device-io.rst:305
msgid ""
"Uncached - CPU-side caches are bypassed, and all reads and writes are "
"handled directly by the device"
msgstr ""

#: ../../../driver-api/device-io.rst:307
msgid ""
"No speculative operations - the CPU may not issue a read or write to this "
"memory, unless the instruction that does so has been reached in committed "
"program flow."
msgstr ""

#: ../../../driver-api/device-io.rst:310
msgid ""
"No reordering - The CPU may not reorder accesses to this memory mapping with "
"respect to each other. On some architectures, this relies on barriers in "
"readl_relaxed()/writel_relaxed()."
msgstr ""

#: ../../../driver-api/device-io.rst:313
msgid ""
"No repetition - The CPU may not issue multiple reads or writes for a single "
"program instruction."
msgstr ""

#: ../../../driver-api/device-io.rst:315
msgid ""
"No write-combining - Each I/O operation results in one discrete read or "
"write being issued to the device, and multiple writes are not combined into "
"larger writes. This may or may not be enforced when using __raw I/O "
"accessors or pointer dereferences."
msgstr ""

#: ../../../driver-api/device-io.rst:319
msgid ""
"Non-executable - The CPU is not allowed to speculate instruction execution "
"from this memory (it probably goes without saying, but you're also not "
"allowed to jump into device memory)."
msgstr ""

#: ../../../driver-api/device-io.rst:323
msgid ""
"On many platforms and buses (e.g. PCI), writes issued through ioremap() "
"mappings are posted, which means that the CPU does not wait for the write to "
"actually reach the target device before retiring the write instruction."
msgstr ""

#: ../../../driver-api/device-io.rst:327
msgid ""
"On many platforms, I/O accesses must be aligned with respect to the access "
"size; failure to do so will result in an exception or unpredictable results."
msgstr ""

#: ../../../driver-api/device-io.rst:331 ../../../driver-api/device-io.rst:448
msgid "ioremap_wc()"
msgstr ""

#: ../../../driver-api/device-io.rst:333
msgid ""
"Maps I/O memory as normal memory with write combining. Unlike ioremap(),"
msgstr ""

#: ../../../driver-api/device-io.rst:335
msgid ""
"The CPU may speculatively issue reads from the device that the program "
"didn't actually execute, and may choose to basically read whatever it wants."
msgstr ""

#: ../../../driver-api/device-io.rst:337
msgid ""
"The CPU may reorder operations as long as the result is consistent from the "
"program's point of view."
msgstr ""

#: ../../../driver-api/device-io.rst:339
msgid ""
"The CPU may write to the same location multiple times, even when the program "
"issued a single write."
msgstr ""

#: ../../../driver-api/device-io.rst:341
msgid "The CPU may combine several writes into a single larger write."
msgstr ""

#: ../../../driver-api/device-io.rst:343
msgid ""
"This mode is typically used for video framebuffers, where it can increase "
"performance of writes. It can also be used for other blocks of memory in "
"devices (e.g. buffers or shared memory), but care must be taken as accesses "
"are not guaranteed to be ordered with respect to normal ioremap() MMIO "
"register accesses without explicit barriers."
msgstr ""

#: ../../../driver-api/device-io.rst:349
msgid ""
"On a PCI bus, it is usually safe to use ioremap_wc() on MMIO areas marked as "
"``IORESOURCE_PREFETCH``, but it may not be used on those without the flag. "
"For on-chip devices, there is no corresponding flag, but a driver can use "
"ioremap_wc() on a device that is known to be safe."
msgstr ""

#: ../../../driver-api/device-io.rst:355 ../../../driver-api/device-io.rst:450
msgid "ioremap_wt()"
msgstr ""

#: ../../../driver-api/device-io.rst:357
msgid ""
"Maps I/O memory as normal memory with write-through caching. Like "
"ioremap_wc(), but also,"
msgstr ""

#: ../../../driver-api/device-io.rst:360
msgid ""
"The CPU may cache writes issued to and reads from the device, and serve "
"reads from that cache."
msgstr ""

#: ../../../driver-api/device-io.rst:363
msgid ""
"This mode is sometimes used for video framebuffers, where drivers still "
"expect writes to reach the device in a timely manner (and not be stuck in "
"the CPU cache), but reads may be served from the cache for efficiency. "
"However, it is rarely useful these days, as framebuffer drivers usually "
"perform writes only, for which ioremap_wc() is more efficient (as it doesn't "
"needlessly trash the cache). Most drivers should not use this."
msgstr ""

#: ../../../driver-api/device-io.rst:371 ../../../driver-api/device-io.rst:442
msgid "ioremap_np()"
msgstr ""

#: ../../../driver-api/device-io.rst:373
msgid ""
"Like ioremap(), but explicitly requests non-posted write semantics. On some "
"architectures and buses, ioremap() mappings have posted write semantics, "
"which means that writes can appear to \"complete\" from the point of view of "
"the CPU before the written data actually arrives at the target device. "
"Writes are still ordered with respect to other writes and reads from the "
"same device, but due to the posted write semantics, this is not the case "
"with respect to other devices. ioremap_np() explicitly requests non-posted "
"semantics, which means that the write instruction will not appear to "
"complete until the device has received (and to some platform-specific extent "
"acknowledged) the written data."
msgstr ""

#: ../../../driver-api/device-io.rst:383
msgid ""
"This mapping mode primarily exists to cater for platforms with bus fabrics "
"that require this particular mapping mode to work correctly. These platforms "
"set the ``IORESOURCE_MEM_NONPOSTED`` flag for a resource that requires "
"ioremap_np() semantics and portable drivers should use an abstraction that "
"automatically selects it where appropriate (see the `Higher-level ioremap "
"abstractions`_ section below)."
msgstr ""

#: ../../../driver-api/device-io.rst:390
msgid ""
"The bare ioremap_np() is only available on some architectures; on others, it "
"always returns NULL. Drivers should not normally use it, unless they are "
"platform-specific or they derive benefit from non-posted writes where "
"supported, and can fall back to ioremap() otherwise. The normal approach to "
"ensure posted write completion is to do a dummy read after a write as "
"explained in `Accessing the device`_, which works with ioremap() on all "
"platforms."
msgstr ""

#: ../../../driver-api/device-io.rst:398
msgid ""
"ioremap_np() should never be used for PCI drivers. PCI memory space writes "
"are always posted, even on architectures that otherwise implement "
"ioremap_np(). Using ioremap_np() for PCI BARs will at best result in posted "
"write semantics, and at worst result in complete breakage."
msgstr ""

#: ../../../driver-api/device-io.rst:403
msgid ""
"Note that non-posted write semantics are orthogonal to CPU-side ordering "
"guarantees. A CPU may still choose to issue other reads or writes before a "
"non-posted write instruction retires. See the previous section on MMIO "
"access functions for details on the CPU side of things."
msgstr ""

#: ../../../driver-api/device-io.rst:409 ../../../driver-api/device-io.rst:446
msgid "ioremap_uc()"
msgstr ""

#: ../../../driver-api/device-io.rst:411
msgid ""
"ioremap_uc() is only meaningful on old x86-32 systems with the PAT "
"extension, and on ia64 with its slightly unconventional ioremap() behavior, "
"everywhere elss ioremap_uc() defaults to return NULL."
msgstr ""

#: ../../../driver-api/device-io.rst:416
msgid ""
"Portable drivers should avoid the use of ioremap_uc(), use ioremap() instead."
msgstr ""

#: ../../../driver-api/device-io.rst:419 ../../../driver-api/device-io.rst:452
msgid "ioremap_cache()"
msgstr ""

#: ../../../driver-api/device-io.rst:421
msgid ""
"ioremap_cache() effectively maps I/O memory as normal RAM. CPU write-back "
"caches can be used, and the CPU is free to treat the device as if it were a "
"block of RAM. This should never be used for device memory which has side "
"effects of any kind, or which does not return the data previously written on "
"read."
msgstr ""

#: ../../../driver-api/device-io.rst:427
msgid ""
"It should also not be used for actual RAM, as the returned pointer is an "
"``__iomem`` token. memremap() can be used for mapping normal RAM that is "
"outside of the linear kernel memory area to a regular pointer."
msgstr ""

#: ../../../driver-api/device-io.rst:431
msgid "Portable drivers should avoid the use of ioremap_cache()."
msgstr ""

#: ../../../driver-api/device-io.rst:434
msgid "Architecture example"
msgstr ""

#: ../../../driver-api/device-io.rst:436
msgid ""
"Here is how the above modes map to memory attribute settings on the ARM64 "
"architecture:"
msgstr ""

#: ../../../driver-api/device-io.rst:440
msgid "API"
msgstr ""

#: ../../../driver-api/device-io.rst:440
msgid "Memory region type and cacheability"
msgstr ""

#: ../../../driver-api/device-io.rst:442
msgid "Device-nGnRnE"
msgstr ""

#: ../../../driver-api/device-io.rst:444
msgid "Device-nGnRE"
msgstr ""

#: ../../../driver-api/device-io.rst:446
msgid "(not implemented)"
msgstr ""

#: ../../../driver-api/device-io.rst:448
msgid "Normal-Non Cacheable"
msgstr ""

#: ../../../driver-api/device-io.rst:450
msgid "(not implemented; fallback to ioremap)"
msgstr ""

#: ../../../driver-api/device-io.rst:452
msgid "Normal-Write-Back Cacheable"
msgstr ""

#: ../../../driver-api/device-io.rst:456
msgid "Higher-level ioremap abstractions"
msgstr ""

#: ../../../driver-api/device-io.rst:458
msgid ""
"Instead of using the above raw ioremap() modes, drivers are encouraged to "
"use higher-level APIs. These APIs may implement platform-specific logic to "
"automatically choose an appropriate ioremap mode on any given bus, allowing "
"for a platform-agnostic driver to work on those platforms without any "
"special cases. At the time of this writing, the following ioremap() wrappers "
"have such logic:"
msgstr ""

#: ../../../driver-api/device-io.rst:465
msgid "devm_ioremap_resource()"
msgstr ""

#: ../../../driver-api/device-io.rst:467
msgid ""
"Can automatically select ioremap_np() over ioremap() according to platform "
"requirements, if the ``IORESOURCE_MEM_NONPOSTED`` flag is set on the struct "
"resource. Uses devres to automatically unmap the resource when the driver "
"probe() function fails or a device in unbound from its driver."
msgstr ""

#: ../../../driver-api/device-io.rst:472 ../../../driver-api/device-io.rst:501
msgid "Documented in Documentation/driver-api/driver-model/devres.rst."
msgstr ""

#: ../../../driver-api/device-io.rst:474
msgid "of_address_to_resource()"
msgstr ""

#: ../../../driver-api/device-io.rst:476
msgid ""
"Automatically sets the ``IORESOURCE_MEM_NONPOSTED`` flag for platforms that "
"require non-posted writes for certain buses (see the nonposted-mmio and "
"posted-mmio device tree properties)."
msgstr ""

#: ../../../driver-api/device-io.rst:480
msgid "of_iomap()"
msgstr ""

#: ../../../driver-api/device-io.rst:482
msgid ""
"Maps the resource described in a ``reg`` property in the device tree, doing "
"all required translations. Automatically selects ioremap_np() according to "
"platform requirements, as above."
msgstr ""

#: ../../../driver-api/device-io.rst:486
msgid "pci_ioremap_bar(), pci_ioremap_wc_bar()"
msgstr ""

#: ../../../driver-api/device-io.rst:488
msgid ""
"Maps the resource described in a PCI base address without having to extract "
"the physical address first."
msgstr ""

#: ../../../driver-api/device-io.rst:491
msgid "pci_iomap(), pci_iomap_wc()"
msgstr ""

#: ../../../driver-api/device-io.rst:493
msgid ""
"Like pci_ioremap_bar()/pci_ioremap_bar(), but also works on I/O space when "
"used together with ioread32()/iowrite32() and similar accessors"
msgstr ""

#: ../../../driver-api/device-io.rst:496
msgid "pcim_iomap()"
msgstr ""

#: ../../../driver-api/device-io.rst:498
msgid ""
"Like pci_iomap(), but uses devres to automatically unmap the resource when "
"the driver probe() function fails or a device in unbound from its driver"
msgstr ""

#: ../../../driver-api/device-io.rst:503
msgid ""
"Not using these wrappers may make drivers unusable on certain platforms with "
"stricter rules for mapping I/O memory."
msgstr ""

#: ../../../driver-api/device-io.rst:507
msgid "Generalizing Access to System and I/O Memory"
msgstr ""

#: ../../../driver-api/device-io:509: include/linux/iosys-map.h:14
msgid ""
"When accessing a memory region, depending on its location, users may have to "
"access it with I/O operations or memory load/store operations. For example, "
"copying to system memory could be done with memcpy(), copying to I/O memory "
"would be done with memcpy_toio()."
msgstr ""

#: ../../../driver-api/device-io:509: include/linux/iosys-map.h:27
msgid ""
"The user of such pointer may not have information about the mapping of that "
"region or may want to have a single code path to handle operations on that "
"buffer, regardless if it's located in system or IO memory. The type :c:type:"
"`struct iosys_map <iosys_map>` and its helpers abstract that so the buffer "
"can be passed around to other drivers or have separate duties inside the "
"same driver for allocation, read and write operations."
msgstr ""

#: ../../../driver-api/device-io:509: include/linux/iosys-map.h:34
msgid ""
"Open-coding access to :c:type:`struct iosys_map <iosys_map>` is considered "
"bad style. Rather than accessing its fields directly, use one of the "
"provided helper functions, or implement your own. For example, instances of :"
"c:type:`struct iosys_map <iosys_map>` can be initialized statically with "
"IOSYS_MAP_INIT_VADDR(), or at runtime with iosys_map_set_vaddr(). These "
"helpers will set an address in system memory."
msgstr ""

#: ../../../driver-api/device-io:509: include/linux/iosys-map.h:47
msgid ""
"To set an address in I/O memory, use IOSYS_MAP_INIT_VADDR_IOMEM() or "
"iosys_map_set_vaddr_iomem()."
msgstr ""

#: ../../../driver-api/device-io:509: include/linux/iosys-map.h:56
msgid ""
"Instances of struct iosys_map do not have to be cleaned up, but can be "
"cleared to NULL with iosys_map_clear(). Cleared mappings always refer to "
"system memory."
msgstr ""

#: ../../../driver-api/device-io:509: include/linux/iosys-map.h:64
msgid ""
"Test if a mapping is valid with either iosys_map_is_set() or "
"iosys_map_is_null()."
msgstr ""

#: ../../../driver-api/device-io:509: include/linux/iosys-map.h:72
msgid ""
"Instances of :c:type:`struct iosys_map <iosys_map>` can be compared for "
"equality with iosys_map_is_equal(). Mappings that point to different memory "
"spaces, system or I/O, are never equal. That's even true if both spaces are "
"located in the same address space, both mappings contain the same address "
"value, or both mappings refer to NULL."
msgstr ""

#: ../../../driver-api/device-io:509: include/linux/iosys-map.h:86
msgid ""
"A set up instance of struct iosys_map can be used to access or manipulate "
"the buffer memory. Depending on the location of the memory, the provided "
"helpers will pick the correct operations. Data can be copied into the memory "
"with iosys_map_memcpy_to(). The address can be manipulated with "
"iosys_map_incr()."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:103
msgid "Pointer to IO/system memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:107
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:117
msgid "**Members**"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:104
msgid "``vaddr_iomem``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:105
msgid "The buffer's address if in I/O memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:105
msgid "``vaddr``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:106
msgid "The buffer's address if in system memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:106
msgid "``is_iomem``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:107
msgid "True if the buffer is located in I/O memory, or false otherwise."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:120
msgid "``IOSYS_MAP_INIT_VADDR (vaddr_)``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:118
msgid "Initializes struct iosys_map to an address in system memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:122
#: include/linux/iosys-map.h:132 include/linux/iosys-map.h:142
#: include/linux/iosys-map.h:181 include/linux/iosys-map.h:194
#: include/linux/iosys-map.h:208 include/linux/iosys-map.h:230
#: include/linux/iosys-map.h:247 include/linux/iosys-map.h:262
#: include/linux/iosys-map.h:275 include/linux/iosys-map.h:295
#: include/linux/iosys-map.h:315 include/linux/iosys-map.h:331
#: include/linux/iosys-map.h:380 include/linux/iosys-map.h:404
#: include/linux/iosys-map.h:425 include/linux/iosys-map.h:493
#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:121
#: arch/x86/include/asm/io.h:140 arch/x86/include/asm/io.h:186
#: arch/x86/include/asm/io.h:383
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:124
msgid "``vaddr_``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:119
#: include/linux/iosys-map.h:179
msgid "A system-memory address"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:130
msgid "``IOSYS_MAP_INIT_VADDR_IOMEM (vaddr_iomem_)``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:128
msgid "Initializes struct iosys_map to an address in I/O memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:134
msgid "``vaddr_iomem_``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:129
#: include/linux/iosys-map.h:192
msgid "An I/O-memory address"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:140
msgid "``IOSYS_MAP_INIT_OFFSET (map_, offset_)``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:138
msgid "Initializes struct iosys_map from another iosys_map"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:144
msgid "``map_``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:139
msgid "The dma-buf mapping structure to copy from"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:141
msgid "``offset_``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:140
msgid "Offset to add to the other mapping"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:142
#: include/linux/iosys-map.h:181 include/linux/iosys-map.h:194
#: include/linux/iosys-map.h:208 include/linux/iosys-map.h:229
#: include/linux/iosys-map.h:246 include/linux/iosys-map.h:261
#: include/linux/iosys-map.h:277 include/linux/iosys-map.h:297
#: include/linux/iosys-map.h:315 include/linux/iosys-map.h:333
#: include/linux/iosys-map.h:382 include/linux/iosys-map.h:407
#: include/linux/iosys-map.h:429 include/linux/iosys-map.h:498
#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:120
#: arch/x86/include/asm/io.h:139 arch/x86/include/asm/io.h:186
#: arch/x86/include/asm/io.h:384
msgid "**Description**"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:141
msgid ""
"Initializes a new iosys_map struct based on another passed as argument. It "
"does a shallow copy of the struct so it's possible to update the back "
"storage without changing where the original map points to. It is the "
"equivalent of doing:"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:151
msgid "Example usage:"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:162
msgid ""
"The advantage of using the initializer over just increasing the offset with "
"iosys_map_incr() like above is that the new map will always point to the "
"right place of the buffer during its scope. It reduces the risk of updating "
"the wrong part of the buffer and having no compiler warning about that. If "
"the assignment to IOSYS_MAP_INIT_OFFSET() is forgotten, the compiler can "
"warn about the use of uninitialized variable."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:177
msgid "Sets a iosys mapping structure to an address in system memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:183
#: include/linux/iosys-map.h:196 include/linux/iosys-map.h:264
#: include/linux/iosys-map.h:317
msgid "``struct iosys_map *map``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:178
#: include/linux/iosys-map.h:191 include/linux/iosys-map.h:205
#: include/linux/iosys-map.h:227 include/linux/iosys-map.h:244
#: include/linux/iosys-map.h:259 include/linux/iosys-map.h:272
#: include/linux/iosys-map.h:293 include/linux/iosys-map.h:312
#: include/linux/iosys-map.h:328 include/linux/iosys-map.h:378
#: include/linux/iosys-map.h:402 include/linux/iosys-map.h:423
#: include/linux/iosys-map.h:491
msgid "The iosys_map structure"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:180
msgid "``void *vaddr``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:180
msgid "Sets the address and clears the I/O-memory flag."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:190
msgid "Sets a iosys mapping structure to an address in I/O memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:193
msgid "``void __iomem *vaddr_iomem``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:193
msgid "Sets the address and the I/O-memory flag."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:204
msgid "Compares two iosys mapping structures for equality"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:210
msgid "``const struct iosys_map *lhs``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:207
msgid "``const struct iosys_map *rhs``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:206
msgid "A iosys_map structure to compare with"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:207
msgid ""
"Two iosys mapping structures are equal if they both refer to the same type "
"of memory and to the same address within that memory."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:210
#: include/linux/iosys-map.h:231 include/linux/iosys-map.h:248
#: include/linux/iosys-map.h:385 include/linux/iosys-map.h:478
msgid "**Return**"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:211
msgid "True is both structures are equal, or false otherwise."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:226
msgid "Tests for a iosys mapping to be NULL"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:232
#: include/linux/iosys-map.h:249
msgid "``const struct iosys_map *map``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:228
msgid ""
"Depending on the state of struct iosys_map.is_iomem, tests if the mapping is "
"NULL."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:232
msgid "True if the mapping is NULL, or false otherwise."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:243
msgid "Tests if the iosys mapping has been set"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:245
msgid ""
"Depending on the state of struct iosys_map.is_iomem, tests if the mapping "
"has been set."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:249
msgid "True if the mapping is been set, or false otherwise."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:258
msgid "Clears a iosys mapping structure"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:260
msgid ""
"Clears all fields to zero, including struct iosys_map.is_iomem, so mapping "
"structures that were set to point to I/O memory are reset for system memory. "
"Pointers are cleared to NULL. This is the default."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:271
msgid "Memcpy into offset of iosys_map"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:277
#: include/linux/iosys-map.h:333
msgid "``struct iosys_map *dst``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:274
msgid "``size_t dst_offset``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:273
#: include/linux/iosys-map.h:294
msgid "The offset from which to copy"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:275
#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:382
msgid "``const void *src``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:274
msgid "The source buffer"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:276
#: include/linux/iosys-map.h:296 include/linux/iosys-map.h:332
msgid "``size_t len``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:275
#: include/linux/iosys-map.h:295
msgid "The number of byte in src"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:276
msgid ""
"Copies data into a iosys_map with an offset. The source buffer is in system "
"memory. Depending on the buffer's location, the helper picks the correct "
"method of accessing the memory."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:291
msgid "Memcpy from iosys_map into system memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:297
msgid "``void *dst``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:292
msgid "Destination in system memory"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:294
msgid "``const struct iosys_map *src``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:295
msgid "``size_t src_offset``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:296
msgid ""
"Copies data from a iosys_map with an offset. The dest buffer is in system "
"memory. Depending on the mapping location, the helper picks the correct "
"method of accessing the memory."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:311
msgid "Increments the address stored in a iosys mapping"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:314
msgid "``size_t incr``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:313
msgid "The number of bytes to increment"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:314
msgid ""
"Increments the address stored in a iosys mapping. Depending on the buffer's "
"location, the correct value will be updated."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:327
msgid "Memset iosys_map"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:330
msgid "``size_t offset``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:329
msgid "Offset from dst where to start setting value"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:331
msgid "``int value``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:330
msgid "The value to set"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:331
msgid "The number of bytes to set in dst"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:332
msgid ""
"Set value in iosys_map. Depending on the buffer's location, the helper picks "
"the correct method of accessing the memory."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:378
msgid "``iosys_map_rd (map__, offset__, type__)``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:376
msgid "Read a C-type value from the iosys_map"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:382
#: include/linux/iosys-map.h:406 include/linux/iosys-map.h:427
#: include/linux/iosys-map.h:495
msgid "``map__``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:380
#: include/linux/iosys-map.h:404
msgid "``offset__``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:379
msgid "The offset from which to read"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:381
#: include/linux/iosys-map.h:405
msgid "``type__``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:380
msgid "Type of the value being read"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:381
msgid ""
"Read a C type value (u8, u16, u32 and u64) from iosys_map. For other types "
"or if pointer may be unaligned (and problematic for the architecture "
"supported), use iosys_map_memcpy_from()."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:386
#: include/linux/iosys-map.h:479
msgid "The value read from the mapping."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:402
msgid "``iosys_map_wr (map__, offset__, type__, val__)``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:400
msgid "Write a C-type value to the iosys_map"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:403
msgid "The offset from the mapping to write to"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:404
msgid "Type of the value being written"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:406
#: include/linux/iosys-map.h:497
msgid "``val__``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:405
#: include/linux/iosys-map.h:496
msgid "Value to write"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:406
msgid ""
"Write a C type value (u8, u16, u32 and u64) to the iosys_map. For other "
"types or if pointer may be unaligned (and problematic for the architecture "
"supported), use iosys_map_memcpy_to()"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:423
msgid "``iosys_map_rd_field (map__, struct_offset__, struct_type__, field__)``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:421
msgid "Read a member from a struct in the iosys_map"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:425
#: include/linux/iosys-map.h:493
msgid "``struct_offset__``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:424
#: include/linux/iosys-map.h:492
msgid "Offset from the beginning of the map, where the struct is located"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:427
#: include/linux/iosys-map.h:495
msgid "``struct_type__``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:426
#: include/linux/iosys-map.h:494
msgid "The struct describing the layout of the mapping"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:428
#: include/linux/iosys-map.h:496
msgid "``field__``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:427
#: include/linux/iosys-map.h:495
msgid "Member of the struct to read"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:428
msgid ""
"Read a value from iosys_map considering its layout is described by a C "
"struct starting at **struct_offset__**. The field offset and size is "
"calculated and its value read. If the field access would incur in un-aligned "
"access, then either iosys_map_memcpy_from() needs to be used or the "
"architecture must support it. For example: suppose there is a **struct** foo "
"defined as below and the value ``foo.field2.inner2`` needs to be read from "
"the iosys_map:"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:446
msgid ""
"This is the expected memory layout of a buffer using iosys_map_rd_field():"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:449
msgid "Address"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:449
msgid "Content"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:451
msgid "buffer + 0000"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:451
msgid "start of mmapped buffer pointed by iosys_map"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:454
#: include/linux/iosys-map.h:458 include/linux/iosys-map.h:462
#: include/linux/iosys-map.h:466
msgid "..."
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:456
msgid "buffer + ``struct_offset__``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:456
msgid "start of ``struct foo``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:460
msgid "buffer + wwww"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:460
msgid "``foo.field2.inner2``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:464
msgid "buffer + yyyy"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:464
msgid "end of ``struct foo``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:468
msgid "buffer + zzzz"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:468
msgid "end of mmaped buffer"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:471
msgid ""
"Values automatically calculated by this macro or not needed are denoted by "
"wwww, yyyy and zzzz. This is the code to read that value:"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:491
msgid ""
"``iosys_map_wr_field (map__, struct_offset__, struct_type__, field__, "
"val__)``"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:489
msgid "Write to a member of a struct in the iosys_map"
msgstr ""

#: ../../../driver-api/device-io:512: include/linux/iosys-map.h:497
msgid ""
"Write a value to the iosys_map considering its layout is described by a C "
"struct starting at **struct_offset__**. The field offset and size is "
"calculated and the **val__** is written. If the field access would incur in "
"un-aligned access, then either iosys_map_memcpy_to() needs to be used or the "
"architecture must support it. Refer to iosys_map_rd_field() for expected "
"usage and memory layout."
msgstr ""

#: ../../../driver-api/device-io.rst:516
msgid "Public Functions Provided"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:117
msgid "map virtual addresses to physical"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:123
msgid "``volatile void *address``"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:118
#: arch/x86/include/asm/io.h:137
msgid "address to remap"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:119
msgid ""
"The returned physical address is the physical (CPU) mapping for the memory "
"address given. It is only valid to use this function on addresses directly "
"mapped or allocated via kmalloc."
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:123
msgid ""
"This function does not give bus mappings for DMA transfers. In almost all "
"conceivable cases a device driver should not be using this function"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:136
msgid "map physical address to virtual"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:142
msgid "``phys_addr_t address``"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:138
msgid ""
"The returned virtual address is a current CPU mapping for the memory address "
"given. It is only valid to use this function on addresses that have a kernel "
"mapping"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:142
msgid ""
"This function does not handle bus mappings for DMA transfers. In almost all "
"conceivable cases a device driver should not be using this function"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:182
msgid "map bus memory into CPU space"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:188
msgid "``resource_size_t offset``"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:183
msgid "bus address of the memory"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:185
msgid "``unsigned long size``"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:184
msgid "size of the resource to map"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:185
msgid ""
"ioremap performs a platform specific sequence of operations to make bus "
"memory CPU accessible via the readb/readw/readl/writeb/ writew/writel "
"functions and the other mmio helpers. The returned address is not guaranteed "
"to be usable directly as a virtual address."
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:191
msgid ""
"If the area you are trying to map is a PCI BAR you should have a look at "
"pci_iomap()."
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:379
msgid "copy data to single MMIO location, in 512-bit units"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:385
msgid "``void __iomem *dst``"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:380
msgid "destination, in MMIO space (must be 512-bit aligned)"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:381
msgid "source"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:383
msgid "``size_t count``"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:382
msgid "number of 512 bits quantities to submit"
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:383
msgid ""
"Submit data from kernel space to MMIO space, in units of 512 bits at a "
"time.  Order of access is not guaranteed, nor is a memory barrier performed "
"afterwards."
msgstr ""

#: ../../../driver-api/device-io:518: arch/x86/include/asm/io.h:387
msgid ""
"Warning: Do not use this helper unless your driver has checked that the CPU "
"instruction is supported on the platform."
msgstr ""
