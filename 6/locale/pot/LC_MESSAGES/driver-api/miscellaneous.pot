# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/miscellaneous.rst:2
msgid "Parallel Port Devices"
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:296
msgid "``parport_register_driver (driver)``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:237
#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:294
msgid "register a parallel port device driver"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:241
#: drivers/parport/share.c:318 drivers/parport/share.c:363
#: drivers/parport/share.c:385 drivers/parport/share.c:400
#: drivers/parport/share.c:497 drivers/parport/share.c:544
#: drivers/parport/share.c:614 drivers/parport/share.c:817
#: drivers/parport/share.c:887 drivers/parport/share.c:918
#: drivers/parport/share.c:949 drivers/parport/share.c:1065
#: drivers/parport/share.c:1131 ../../../driver-api/miscellaneous:13:
#: drivers/parport/daisy.c:231 drivers/parport/daisy.c:291
#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:326
#: drivers/tty/serial/8250/8250_core.c:582
#: drivers/tty/serial/8250/8250_core.c:606
#: drivers/tty/serial/8250/8250_core.c:690
#: drivers/tty/serial/8250/8250_core.c:875
#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:123
#: include/linux/pwm.h:181 include/linux/pwm.h:215 include/linux/pwm.h:240
#: include/linux/pwm.h:362 include/linux/pwm.h:405 include/linux/pwm.h:433
#: include/linux/pwm.h:454 include/linux/pwm.h:473
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:218
#: drivers/pwm/core.c:296 drivers/pwm/core.c:406 drivers/pwm/core.c:721
#: drivers/pwm/core.c:765 drivers/pwm/core.c:790 drivers/pwm/core.c:839
#: drivers/pwm/core.c:1894 drivers/pwm/core.c:2041 drivers/pwm/core.c:2061
#: drivers/pwm/core.c:2089 drivers/pwm/core.c:2391 drivers/pwm/core.c:2472
#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:298
#: include/linux/parport.h:331 include/linux/parport.h:395
#: include/linux/parport.h:424 ../../../driver-api/miscellaneous:7:
#: drivers/parport/ieee1284.c:53 drivers/parport/ieee1284.c:136
#: drivers/parport/ieee1284.c:307 drivers/parport/ieee1284.c:570
#: drivers/parport/ieee1284.c:661 drivers/parport/ieee1284.c:758
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:300
msgid "``driver``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:238
#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:295
msgid "structure describing the driver"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:242
#: drivers/parport/share.c:318 drivers/parport/share.c:362
#: drivers/parport/share.c:384 drivers/parport/share.c:402
#: drivers/parport/share.c:496 drivers/parport/share.c:543
#: drivers/parport/share.c:616 drivers/parport/share.c:816
#: drivers/parport/share.c:886 drivers/parport/share.c:917
#: drivers/parport/share.c:948 drivers/parport/share.c:1064
#: drivers/parport/share.c:1130 ../../../driver-api/miscellaneous:13:
#: drivers/parport/daisy.c:231 drivers/parport/daisy.c:290
#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:325
#: drivers/tty/serial/8250/8250_core.c:581
#: drivers/tty/serial/8250/8250_core.c:605
#: drivers/tty/serial/8250/8250_core.c:689
#: drivers/tty/serial/8250/8250_core.c:874
#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:37
#: include/linux/pwm.h:61 include/linux/pwm.h:123 include/linux/pwm.h:181
#: include/linux/pwm.h:215 include/linux/pwm.h:241
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:219
#: drivers/pwm/core.c:297 drivers/pwm/core.c:408 drivers/pwm/core.c:790
#: drivers/pwm/core.c:838 drivers/pwm/core.c:1894 drivers/pwm/core.c:2061
#: drivers/pwm/core.c:2090 drivers/pwm/core.c:2391 drivers/pwm/core.c:2471
#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:297
#: include/linux/parport.h:330 include/linux/parport.h:394
#: include/linux/parport.h:423 ../../../driver-api/miscellaneous:7:
#: drivers/parport/ieee1284.c:53 drivers/parport/ieee1284.c:137
#: drivers/parport/ieee1284.c:307 drivers/parport/ieee1284.c:571
#: drivers/parport/ieee1284.c:662 drivers/parport/ieee1284.c:758
msgid "**Description**"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:241
#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:296
msgid ""
"This can be called by a parallel port device driver in order to receive "
"notifications about ports being found in the system, as well as ports no "
"longer available."
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:300
msgid ""
"The **driver** structure is allocated by the caller and must not be "
"deallocated until after calling parport_unregister_driver()."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:251
#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:303
msgid ""
"If using the non device model: The driver's attach() function may block.  "
"The port that attach() is given will be valid for the duration of the "
"callback, but if the driver wants to take a copy of the pointer it must call "
"parport_get_port() to do so.  Calling parport_register_device() on that port "
"will do this for you."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:258
#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:310
msgid ""
"The driver's detach() function may block.  The port that detach() is given "
"will be valid for the duration of the callback, but if the driver wants to "
"take a copy of the pointer it must call parport_get_port() to do so."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:264
#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:316
msgid ""
"Returns 0 on success. The non device model will always succeeds. but the new "
"device model can fail and will return the error code."
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:329
msgid "``module_parport_driver (__parport_driver)``"
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:327
msgid "Helper macro for registering a modular parport driver"
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:333
msgid "``__parport_driver``"
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:328
msgid "struct parport_driver to be used"
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:329
msgid ""
"Helper macro for parport drivers which do not do anything special in module "
"init and exit. This eliminates a lot of boilerplate. Each module may only "
"use this macro once, and calling it replaces module_init() and module_exit()."
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:391
#: include/linux/parport.h:420
msgid "relinquish a parallel port temporarily"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:819
#: drivers/parport/share.c:951 drivers/parport/share.c:1067
#: drivers/parport/share.c:1133 ../../../driver-api/miscellaneous:13:
#: drivers/parport/daisy.c:293 ../../../driver-api/miscellaneous:4:
#: include/linux/parport.h:397 include/linux/parport.h:426
#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:760
msgid "``struct pardevice *dev``"
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:392
#: include/linux/parport.h:421
msgid "a device on the parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:393
msgid ""
"This function relinquishes the port if it would be helpful to other drivers "
"to do so.  Afterwards it tries to reclaim the port using parport_claim(), "
"and the return value is the same as for parport_claim().  If it fails, the "
"port is left unclaimed and it is the driver's responsibility to reclaim the "
"port."
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:399
msgid ""
"The parport_yield() and parport_yield_blocking() functions are for marking "
"points in the driver at which other drivers may claim the port and use their "
"devices.  Yielding the port is similar to releasing it and reclaiming it, "
"but is more efficient because no action is taken if there are no other "
"devices needing the port.  In fact, nothing is done even if there are other "
"devices waiting but the current device is still within its \"timeslice\".  "
"The default timeslice is half a second, but it can be adjusted via the /proc "
"interface."
msgstr ""

#: ../../../driver-api/miscellaneous:4: include/linux/parport.h:422
msgid ""
"This function relinquishes the port if it would be helpful to other drivers "
"to do so.  Afterwards it tries to reclaim the port using "
"parport_claim_or_block(), and the return value is the same as for "
"parport_claim_or_block()."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:49
msgid "wait for an event on a parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:365
#: drivers/parport/share.c:387 drivers/parport/share.c:499
#: drivers/parport/share.c:546 drivers/parport/share.c:616
#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:55
#: drivers/parport/ieee1284.c:138 drivers/parport/ieee1284.c:309
#: drivers/parport/ieee1284.c:572 drivers/parport/ieee1284.c:663
msgid "``struct parport *port``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:50
msgid "port to wait on"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:52
msgid "``signed long timeout``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:51
msgid "time to wait (in jiffies)"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:52
msgid ""
"This function waits for up to **timeout** jiffies for an interrupt to occur "
"on a parallel port.  If the port timeout is set to zero, it returns "
"immediately."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:56
msgid ""
"If an interrupt occurs before the timeout period elapses, this function "
"returns zero immediately.  If it times out, it returns one.  An error code "
"less than zero indicates an error (most likely a pending signal), and the "
"calling code should finish what it's doing as soon as it can."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:132
msgid "wait for status lines to change in 35ms"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:133
msgid "port to watch"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:135
msgid "``unsigned char mask``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:134
msgid "status lines to watch"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:136
msgid "``unsigned char result``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:135
msgid "desired values of chosen status lines"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:136
msgid ""
"This function waits until the masked status lines have the desired values, "
"or until 35ms have elapsed (see IEEE 1284-1994 page 24 to 25 for why this "
"value in particular is hardcoded). The **mask** and **result** parameters "
"are bitmasks, with the bits defined by the constants in parport.h: "
"``PARPORT_STATUS_BUSY``, and so on."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:143
msgid ""
"The port is polled quickly to start off with, in anticipation of a fast "
"response from the peripheral.  This fast polling time is configurable "
"(using /proc), and defaults to 500usec. If the timeout for this port (see "
"parport_set_timeout()) is zero, the fast polling time is 35ms, and this "
"function does not call schedule()."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:150
msgid ""
"If the timeout for this port is non-zero, after the fast polling fails it "
"uses parport_wait_event() to wait for up to 10ms, waking up if an interrupt "
"occurs."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:303
msgid "negotiate an IEEE 1284 mode"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:304
msgid "port to use"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:306
msgid "``int mode``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:305
msgid "mode to negotiate to"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:306
msgid ""
"Use this to negotiate to a particular IEEE 1284 transfer mode. The **mode** "
"parameter should be one of the constants in parport.h starting "
"``IEEE1284_MODE_xxx``."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:310
msgid ""
"The return value is 0 if the peripheral has accepted the negotiation to the "
"mode specified, -1 if the peripheral is not IEEE 1284 compliant (or not "
"present), or 1 if the peripheral has rejected the negotiation."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:566
msgid "write a block of data to a parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:567
msgid "port to write to"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:569
msgid "``const void *buffer``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:568
#: drivers/parport/ieee1284.c:659
msgid "data buffer (in kernel space)"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:570
#: drivers/parport/ieee1284.c:661
msgid "``size_t len``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:569
#: drivers/parport/ieee1284.c:660
msgid "number of bytes of data to transfer"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:570
msgid ""
"This will write up to **len** bytes of **buffer** to the port specified, "
"using the IEEE 1284 transfer mode most recently negotiated to (using "
"parport_negotiate()), as long as that mode supports forward transfers (host "
"to peripheral)."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:575
msgid ""
"It is the caller's responsibility to ensure that the first **len** bytes of "
"**buffer** are valid."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:578
#: drivers/parport/ieee1284.c:669
msgid ""
"This function returns the number of bytes transferred (if zero or positive), "
"or else an error code."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:657
msgid "read a block of data from a parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:658
msgid "port to read from"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:660
msgid "``void *buffer``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:661
msgid ""
"This will read up to **len** bytes of **buffer** to the port specified, "
"using the IEEE 1284 transfer mode most recently negotiated to (using "
"parport_negotiate()), as long as that mode supports reverse transfers "
"(peripheral to host)."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:666
msgid ""
"It is the caller's responsibility to ensure that the first **len** bytes of "
"**buffer** are available to write to."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:754
msgid "set the inactivity timeout for a device"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:755
msgid "device on a port"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:757
msgid "``long inactivity``"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:756
msgid "inactivity timeout (in jiffies)"
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:757
msgid ""
"This sets the inactivity timeout for a particular device on a port.  This "
"affects functions like parport_wait_peripheral(). The special value 0 means "
"not to call schedule() while dealing with this device."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:762
msgid "The return value is the previous inactivity timeout."
msgstr ""

#: ../../../driver-api/miscellaneous:7: drivers/parport/ieee1284.c:764
msgid "Any callers of parport_wait_event() for this device are woken up."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:243
#: drivers/parport/share.c:320
msgid "``struct parport_driver *drv``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:240
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2390
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:239
msgid "owner module of drv"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:241
msgid "``const char *mod_name``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:240
msgid "module name string"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:245
msgid "If devmodel is true then the new device model is used for registration."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:248
msgid ""
"The **drv** structure is allocated by the caller and must not be deallocated "
"until after calling parport_unregister_driver()."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:314
msgid "deregister a parallel port device driver"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:315
msgid ""
"structure describing the driver that was given to parport_register_driver()"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:317
msgid ""
"This should be called by a parallel port device driver that has registered "
"itself using parport_register_driver() when it is about to be unloaded."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:321
msgid ""
"When it returns, the driver's attach() routine will no longer be called, and "
"for each port that attach() was called for, the detach() routine will have "
"been called."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:325
msgid ""
"All the driver's attach() and detach() calls are guaranteed to have finished "
"by the time this function returns."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:359
msgid "increment a port's reference count"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:360
#: drivers/parport/share.c:382
msgid "the port"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:361
msgid ""
"This ensures that a struct parport pointer remains valid until the matching "
"parport_put_port() call."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:381
msgid "decrement a port's reference count"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:383
msgid ""
"This should be called once for each call to parport_get_port(), once the "
"port is no longer needed. When the reference count reaches zero (port is no "
"longer used), free_port is called."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:396
msgid "register a parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:402
#: drivers/parport/share.c:920
msgid "``unsigned long base``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:397
#: drivers/parport/share.c:915
msgid "base I/O address"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:399
msgid "``int irq``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:398
msgid "IRQ line"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:400
msgid "``int dma``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:399
msgid "DMA channel"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:401
msgid "``struct parport_operations *ops``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:400
msgid "pointer to the port driver's port operations structure"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:401
msgid ""
"When a parallel port (lowlevel) driver finds a port that should be made "
"available to parallel port device drivers, it should call "
"parport_register_port().  The **base**, **irq**, and **dma** parameters are "
"for the convenience of port drivers, and for ports where they aren't "
"meaningful needn't be set to anything special.  They can be altered "
"afterwards by adjusting the relevant members of the parport structure that "
"is returned and represents the port.  They should not be tampered with after "
"calling parport_announce_port, however."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:411
msgid ""
"If there are parallel port device drivers in the system that have registered "
"themselves using parport_register_driver(), they are not told about the port "
"at this time; that is done by parport_announce_port()."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:416
msgid ""
"The **ops** structure is allocated by the caller, and must not be "
"deallocated before calling parport_remove_port()."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:419
msgid ""
"If there is no memory to allocate a new parport structure, this function "
"will return ``NULL``."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:493
msgid "tell device drivers about a parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:494
msgid "parallel port to announce"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:495
msgid ""
"After a port driver has registered a parallel port with "
"parport_register_port, and performed any necessary initialisation or "
"adjustments, it should call parport_announce_port() in order to notify all "
"device drivers that have called parport_register_driver().  Their attach() "
"functions will be called, with **port** as the parameter."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:540
msgid "deregister a parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:541
msgid "parallel port to deregister"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:542
msgid ""
"When a parallel port driver is forcibly unloaded, or a parallel port becomes "
"inaccessible, the port driver must call this function in order to deal with "
"device drivers that still want to use it."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:547
msgid ""
"The parport structure associated with the port has its operations structure "
"replaced with one containing 'null' operations that return errors or just "
"don't do anything."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:551
msgid ""
"Any drivers that have registered themselves using parport_register_driver() "
"are notified that the port is no longer accessible by having their detach() "
"routines called with **port** as the parameter."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:610
msgid "register a device on a parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:611
msgid "port to which the device is attached"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:613
#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:230
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:612
msgid "a name to refer to the device"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:614
msgid "``const struct pardev_cb *par_dev_cb``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:613
msgid "struct containing callbacks"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:615
msgid "``int id``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:614
msgid "device number to be given to the device"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:615
msgid ""
"This function, called by parallel port device drivers, declares that a "
"device is connected to a port, and tells the system all it needs to know."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:619
msgid ""
"The struct pardev_cb contains pointer to callbacks. preemption callback "
"function, **preempt**, is called when this device driver has claimed access "
"to the port but another device driver wants to use it.  It is given, "
"**private**, as its parameter, and should return zero if it is willing for "
"the system to release the port to another driver on its behalf. If it wants "
"to keep control of the port it should return non-zero, and no action will be "
"taken. It is good manners for the driver to try to release the port at the "
"earliest opportunity after its preemption callback rejects a preemption "
"attempt. Note that if a preemption callback is happy for preemption to go "
"ahead, there is no need to release the port; it is done automatically. This "
"function may not block, as it may be called from interrupt context. If the "
"device driver does not support preemption, **preempt** can be ``NULL``."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:634
msgid ""
"The wake-up (\"kick\") callback function, **wakeup**, is called when the "
"port is available to be claimed for exclusive access; that is, "
"parport_claim() is guaranteed to succeed when called from inside the wake-up "
"callback function.  If the driver wants to claim the port it should do so; "
"otherwise, it need not take any action.  This function may not block, as it "
"may be called from interrupt context.  If the device driver does not want to "
"be explicitly invited to claim the port in this way, **wakeup** can be "
"``NULL``."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:644
msgid ""
"The interrupt handler, **irq_func**, is called when an interrupt arrives "
"from the parallel port.  Note that if a device driver wants to use "
"interrupts it should use parport_enable_irq(), and can also check the irq "
"member of the parport structure representing the port."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:650
msgid ""
"The parallel port (lowlevel) driver is the one that has called request_irq() "
"and whose interrupt handler is called first. This handler does whatever "
"needs to be done to the hardware to acknowledge the interrupt (for PC-style "
"ports there is nothing special to be done).  It then tells the IEEE 1284 "
"code about the interrupt, which may involve reacting to an IEEE 1284 event "
"depending on the current IEEE 1284 phase.  After this, it calls "
"**irq_func**.  Needless to say, **irq_func** will be called from interrupt "
"context, and may not block."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:660
msgid ""
"The ``PARPORT_DEV_EXCL`` flag is for preventing port sharing, and so should "
"only be used when sharing the port with other device drivers is impossible "
"and would lead to incorrect behaviour. Use it sparingly!  Normally, "
"**flags** will be zero."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:665
msgid ""
"This function returns a pointer to a structure that represents the device on "
"the port, or ``NULL`` if there is not enough memory to allocate space for "
"that structure."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:813
msgid "deregister a device on a parallel port"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:814
msgid "pointer to structure representing device"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:815
msgid "This undoes the effect of parport_register_device()."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:883
msgid "find a parallel port by number"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:889
msgid "``int number``"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:884
msgid "parallel port number"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:885
msgid ""
"This returns the parallel port with the specified number, or ``NULL`` if "
"there is none."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:888
msgid ""
"There is an implicit parport_get_port() done already; to throw away the "
"reference to the port that parport_find_number() gives you, use "
"parport_put_port()."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:914
msgid "find a parallel port by base address"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:916
msgid ""
"This returns the parallel port with the specified base address, or ``NULL`` "
"if there is none."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:919
msgid ""
"There is an implicit parport_get_port() done already; to throw away the "
"reference to the port that parport_find_base() gives you, use "
"parport_put_port()."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:945
#: drivers/parport/share.c:1061
msgid "claim access to a parallel port device"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:946
#: drivers/parport/share.c:1062
msgid "pointer to structure representing a device on the port"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:947
msgid ""
"This function will not block and so can be used from interrupt context.  If "
"parport_claim() succeeds in claiming access to the port it returns zero and "
"the port is available to use.  It may fail (returning non-zero) if the port "
"is in use by another driver and that driver is not willing to relinquish "
"control of the port."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:1063
msgid ""
"This behaves like parport_claim(), but will block if necessary to wait for "
"the port to be free.  A return value of 1 indicates that it slept; 0 means "
"that it succeeded without needing to sleep.  A negative error code indicates "
"failure."
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:1127
msgid "give up access to a parallel port device"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:1128
msgid "pointer to structure representing parallel port device"
msgstr ""

#: ../../../driver-api/miscellaneous:10: drivers/parport/share.c:1129
msgid ""
"This function cannot fail, but it should not be called without the port "
"claimed.  Similarly, if the port is already claimed you should not try "
"claiming it again."
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:227
msgid "find a device by canonical device number"
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:233
msgid "``int devnum``"
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:228
msgid "canonical device number"
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:229
msgid "name to associate with the device"
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:230
msgid ""
"This function is similar to parport_register_device(), except that it "
"locates a device by its number rather than by the port it is attached to."
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:234
msgid ""
"All parameters except for **devnum** are the same as for "
"parport_register_device().  The return value is the same as for "
"parport_register_device()."
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:287
msgid "close a device opened with parport_open()"
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:288
msgid "device to close"
msgstr ""

#: ../../../driver-api/miscellaneous:13: drivers/parport/daisy.c:289
msgid ""
"This is to parport_open() as parport_unregister_device() is to "
"parport_register_device()."
msgstr ""

#: ../../../driver-api/miscellaneous.rst:17
msgid "16x50 UART Driver"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:322
msgid "retrieve struct uart_8250_port"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:328
#: drivers/tty/serial/8250/8250_core.c:584
#: drivers/tty/serial/8250/8250_core.c:608
#: drivers/tty/serial/8250/8250_core.c:877
msgid "``int line``"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:323
#: drivers/tty/serial/8250/8250_core.c:579
#: drivers/tty/serial/8250/8250_core.c:603
#: drivers/tty/serial/8250/8250_core.c:872
msgid "serial line number"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:324
msgid ""
"This function retrieves struct uart_8250_port for the specific line. This "
"struct *must* *not* be used to perform a 8250 or serial core operation which "
"is not accessible otherwise. Its only purpose is to make the struct "
"accessible to the runtime-pm callbacks for context suspend/restore. The lock "
"assumption made here is none because runtime-pm suspend/resume callbacks "
"should not be invoked if there is any operation performed on the port."
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:578
msgid "suspend one serial port"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:580
msgid "Suspend one serial port."
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:602
msgid "resume one serial port"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:604
msgid "Resume one serial port."
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:686
msgid "register a serial port"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:692
msgid "``const struct uart_8250_port *up``"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:687
msgid "serial port template"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:688
msgid ""
"Configure the serial port specified by the request. If the port exists and "
"is in use, it is hung up and unregistered first."
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:692
msgid ""
"The port is then probed and if necessary the IRQ is autodetected If this "
"fails an error is returned."
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:695
msgid "On success the port is ready to use and the line number is returned."
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:871
msgid "remove a 16x50 serial port at runtime"
msgstr ""

#: ../../../driver-api/miscellaneous:19:
#: drivers/tty/serial/8250/8250_core.c:873
msgid ""
"Remove one serial port.  This may not be called from interrupt context.  We "
"hand the port back to the our control."
msgstr ""

#: ../../../driver-api/miscellaneous.rst:22
msgid "See serial/driver.rst for related APIs."
msgstr ""

#: ../../../driver-api/miscellaneous.rst:25
msgid "Pulse-Width Modulation (PWM)"
msgstr ""

#: ../../../driver-api/miscellaneous.rst:27
msgid ""
"Pulse-width modulation is a modulation technique primarily used to control "
"power supplied to electrical devices."
msgstr ""

#: ../../../driver-api/miscellaneous.rst:30
msgid ""
"The PWM framework provides an abstraction for providers and consumers of PWM "
"signals. A controller that provides one or more PWM signals is registered "
"as :c:type:`struct pwm_chip <pwm_chip>`. Providers are expected to embed "
"this structure in a driver-specific structure. This structure contains "
"fields that describe a particular chip."
msgstr ""

#: ../../../driver-api/miscellaneous.rst:36
msgid ""
"A chip exposes one or more PWM signal sources, each of which exposed as a :c:"
"type:`struct pwm_device <pwm_device>`. Operations can be performed on PWM "
"devices to control the period, duty cycle, polarity and active state of the "
"signal."
msgstr ""

#: ../../../driver-api/miscellaneous.rst:41
msgid ""
"Note that PWM devices are exclusive resources: they can always only be used "
"by one consumer at a time."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:17
msgid "polarity of a PWM signal"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:21
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:23
msgid "``PWM_POLARITY_NORMAL``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:24
msgid ""
"a high signal for the duration of the duty- cycle, followed by a low signal "
"for the remainder of the pulse period"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:28
msgid "``PWM_POLARITY_INVERSED``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:29
msgid ""
"a low signal for the duration of the duty- cycle, followed by a high signal "
"for the remainder of the pulse period"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:31
msgid "board-dependent PWM arguments"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:35
#: include/linux/pwm.h:58 include/linux/pwm.h:102 include/linux/pwm.h:272
#: include/linux/pwm.h:284 include/linux/pwm.h:319
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:42
#: include/linux/pwm.h:66 include/linux/pwm.h:114 include/linux/pwm.h:279
#: include/linux/pwm.h:299 include/linux/pwm.h:339
msgid "**Members**"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:32
#: include/linux/pwm.h:269
msgid "``period``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:33
msgid "reference period"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:33
msgid "``polarity``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:34
msgid "reference polarity"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:34
msgid ""
"This structure describes board-dependent arguments attached to a PWM device. "
"These arguments are usually retrieved from the PWM lookup table or device "
"tree."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:38
msgid ""
"Do not confuse this with the PWM state: PWM arguments represent the initial "
"configuration that users want to use on this PWM device rather than the "
"current PWM hardware state."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:54
msgid "description of a PWM waveform"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:55
msgid "``period_length_ns``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:56
msgid "PWM period"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:56
msgid "``duty_length_ns``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:57
msgid "PWM duty cycle"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:57
msgid "``duty_offset_ns``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:58
msgid "offset of the rising edge from the period's start"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:58
msgid ""
"This is a representation of a PWM waveform alternative to struct pwm_state "
"below. It's more expressive than struct pwm_state as it contains a "
"duty_offset_ns and so can represent offsets other than zero (with .polarity "
"= PWM_POLARITY_NORMAL) and period - duty_cycle (.polarity = "
"PWM_POLARITY_INVERSED)."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:64
msgid ""
"Note there is no explicit bool for enabled. A \"disabled\" PWM is "
"represented by .period_length_ns = 0. Note further that the behaviour of a "
"\"disabled\" PWM is undefined. Depending on the hardware's capabilities it "
"might drive the active or inactive level, go high-z or even continue to "
"toggle."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:69
msgid "The unit for all three members is nanoseconds."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:98
msgid "PWM channel object"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:99
msgid "``label``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:100
msgid "name of the PWM device"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:100
msgid "``flags``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:101
msgid "flags associated with the PWM device"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:101
msgid "``hwpwm``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:102
msgid "per-chip relative index of the PWM device"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:102
msgid "``chip``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:103
msgid "PWM chip providing this PWM device"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:103
msgid "``args``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:104
msgid "PWM arguments"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:104
msgid "``state``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:105
msgid "last applied state"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:105
msgid "``last``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:106
msgid "last implemented state (for PWM_DEBUG)"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:119
msgid "retrieve the current PWM state"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:125
#: include/linux/pwm.h:183
msgid "``const struct pwm_device *pwm``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:120
#: include/linux/pwm.h:178 include/linux/pwm.h:402 include/linux/pwm.h:430
#: include/linux/pwm.h:451 include/linux/pwm.h:470
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:216
#: drivers/pwm/core.c:294 drivers/pwm/core.c:404 drivers/pwm/core.c:719
#: drivers/pwm/core.c:763 drivers/pwm/core.c:787 drivers/pwm/core.c:836
#: drivers/pwm/core.c:2038
msgid "PWM device"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:122
#: include/linux/pwm.h:180 include/linux/pwm.h:242
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:789
msgid "``struct pwm_state *state``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:121
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:788
msgid "state to fill with the current PWM state"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:122
msgid ""
"The returned PWM state represents the state that was applied by a previous "
"call to pwm_apply_might_sleep(). Drivers may have to slightly tweak that "
"state before programming it to hardware. If pwm_apply_might_sleep() was "
"never called, this returns either the current hardware state (if supported) "
"or the default settings."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:177
msgid "prepare a new state to be applied with pwm_apply_might_sleep()"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:179
msgid "state to fill with the prepared PWM state"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:180
msgid ""
"This functions prepares a state that can later be tweaked and applied to the "
"PWM device with pwm_apply_might_sleep(). This is a convenient function that "
"first retrieves the current PWM state and the replaces the period and "
"polarity fields with the reference values defined in pwm->args. Once the "
"function returns, you can adjust the ->enabled and ->duty_cycle fields "
"according to your needs before calling pwm_apply_might_sleep()."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:187
msgid ""
"->duty_cycle is initially set to zero to avoid cases where the current -"
">duty_cycle value exceed the pwm_args->period one, which would trigger an "
"error if the user calls pwm_apply_might_sleep() without adjusting -"
">duty_cycle first."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:211
msgid "Get a relative duty cycle value"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:217
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:721
#: drivers/pwm/core.c:765
msgid "``const struct pwm_state *state``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:212
msgid "PWM state to extract the duty cycle from"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:214
#: include/linux/pwm.h:240
msgid "``unsigned int scale``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:213
msgid "target scale of the relative duty cycle"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:214
msgid ""
"This functions converts the absolute duty cycle stored in **state** "
"(expressed in nanosecond) into a value relative to the period."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:217
msgid ""
"For example if you want to get the duty_cycle expressed in percent, call:"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:219
msgid ""
"pwm_get_state(pwm, :c:type:`state`); duty = pwm_get_relative_duty_cycle(:c:"
"type:`state`, 100);"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:222
#: include/linux/pwm.h:249 include/linux/pwm.h:361 include/linux/pwm.h:406
#: include/linux/pwm.h:432 include/linux/pwm.h:472
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:239
#: drivers/pwm/core.c:299 drivers/pwm/core.c:437 drivers/pwm/core.c:722
#: drivers/pwm/core.c:766 drivers/pwm/core.c:792 drivers/pwm/core.c:841
#: drivers/pwm/core.c:1900 drivers/pwm/core.c:2063 drivers/pwm/core.c:2092
#: drivers/pwm/core.c:2393
msgid "**Return**"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:223
msgid "rounded relative duty cycle multiplied by **scale**"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:236
msgid "Set a relative duty cycle value"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:237
msgid "PWM state to fill"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:239
msgid "``unsigned int duty_cycle``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:238
msgid "relative duty cycle value"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:239
msgid "scale in which **duty_cycle** is expressed"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:240
msgid ""
"This functions converts a relative into an absolute duty cycle (expressed in "
"nanoseconds), and puts the result in state->duty_cycle."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:243
msgid "For example if you want to configure a 50% duty cycle, call:"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:245
msgid ""
"pwm_init_state(pwm, :c:type:`state`); pwm_set_relative_duty_cycle(:c:type:"
"`state`, 50, 100); pwm_apply_might_sleep(pwm, :c:type:`state`);"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:250
msgid ""
"0 on success or ``-EINVAL`` if **duty_cycle** and/or **scale** are "
"inconsistent (**scale** == 0 or **duty_cycle** > **scale**)"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:268
msgid "PWM capture data"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:270
msgid "period of the PWM signal (in nanoseconds)"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:270
msgid "``duty_cycle``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:271
msgid "duty cycle of the PWM signal (in nanoseconds)"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:280
msgid "PWM controller operations"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:281
msgid "``request``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:282
msgid "optional hook for requesting a PWM"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:282
msgid "``free``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:283
msgid "optional hook for freeing a PWM"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:283
msgid "``capture``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:284
msgid "capture and report PWM signal"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:284
msgid "``sizeof_wfhw``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:285
msgid "size (in bytes) of driver specific waveform presentation"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:285
msgid "``round_waveform_tohw``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:286
msgid "convert a struct pwm_waveform to driver specific presentation"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:286
msgid "``round_waveform_fromhw``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:287
msgid "convert a driver specific waveform presentation to struct pwm_waveform"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:287
msgid "``read_waveform``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:288
msgid "read driver specific waveform presentation from hardware"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:288
msgid "``write_waveform``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:289
msgid "write driver specific waveform presentation to hardware"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:289
msgid "``apply``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:290
msgid "atomically apply a new PWM config"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:290
msgid "``get_state``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:291
msgid "get the current PWM state."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:315
msgid "abstract a PWM controller"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:316
msgid "``dev``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:317
msgid "device providing the PWMs"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:317
msgid "``cdev``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:318
msgid ":c:type:`struct cdev <cdev>` for this device"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:318
msgid "``ops``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:319
msgid "callbacks for this PWM controller"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:319
msgid "``owner``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:320
msgid "module providing this chip"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:320
msgid "``id``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:321
msgid "unique number of this PWM chip"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:321
msgid "``npwm``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:322
msgid "number of PWMs controlled by this chip"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:322
msgid "``of_xlate``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:323
msgid "request a PWM device given a device tree PWM specifier"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:323
msgid "``atomic``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:324
msgid "can the driver's ->apply() be called in atomic context"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:324
msgid "``uses_pwmchip_alloc``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:325
msgid "signals if pwmchip_allow was used to allocate this chip"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:325
msgid "``operational``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:326
msgid "signals if the chip can be used (or is already deregistered)"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:326
msgid "``nonatomic_lock``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:327
msgid "mutex for nonatomic chips"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:327
msgid "``atomic_lock``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:328
msgid "mutex for atomic chips"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:328
msgid "``pwms``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:329
msgid "array of PWM devices allocated by the framework"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:358
msgid "checks if the given chip supports waveform callbacks"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:364
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2393
#: drivers/pwm/core.c:2474
msgid "``struct pwm_chip *chip``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:359
msgid "The pwm_chip to test"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:361
msgid ""
"true iff the pwm chip support the waveform functions like "
"pwm_set_waveform_might_sleep() and pwm_round_waveform_might_sleep()"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:401
msgid "change a PWM device configuration"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:407
#: include/linux/pwm.h:435 include/linux/pwm.h:456 include/linux/pwm.h:475
#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:220
#: drivers/pwm/core.c:298 drivers/pwm/core.c:408 drivers/pwm/core.c:723
#: drivers/pwm/core.c:767 drivers/pwm/core.c:792 drivers/pwm/core.c:841
#: drivers/pwm/core.c:2043
msgid "``struct pwm_device *pwm``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:404
msgid "``int duty_ns``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:403
msgid "\"on\" time (in nanoseconds)"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:405
msgid "``int period_ns``"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:404
msgid "duration (in nanoseconds) of one cycle"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:406
#: include/linux/pwm.h:432 ../../../driver-api/miscellaneous:47:
#: drivers/pwm/core.c:793 drivers/pwm/core.c:842 drivers/pwm/core.c:2394
msgid "0 on success or a negative error code on failure."
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:429
msgid "start a PWM output toggling"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:450
msgid "stop a PWM output toggling"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:469
msgid "is pwm_apply_atomic() supported?"
msgstr ""

#: ../../../driver-api/miscellaneous:44: include/linux/pwm.h:472
msgid "false if pwm_apply_atomic() can be called from atomic context."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:214
msgid "Query hardware capabilities Cannot be used in atomic context."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:218
#: drivers/pwm/core.c:296
msgid "``struct pwm_waveform *wf``"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:217
msgid "waveform to round and output parameter"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:218
msgid ""
"Typically a given waveform cannot be implemented exactly by hardware, e.g. "
"because hardware only supports coarse period resolution or no duty_offset. "
"This function returns the actually implemented waveform if you pass **wf** "
"to pwm_set_waveform_might_sleep() now."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:223
msgid ""
"Note however that the world doesn't stop turning when you call it, so when "
"doing::"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:229
msgid ""
"the latter might fail, e.g. because an input clock changed its rate between "
"these two calls and the waveform determined by "
"pwm_round_waveform_might_sleep() cannot be implemented any more."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:233
msgid ""
"Usually all values passed in **wf** are rounded down to the nearest possible "
"value (in the order period_length_ns, duty_length_ns and then "
"duty_offset_ns). Only if this isn't possible, a value might grow. See the "
"documentation for pwm_set_waveform_might_sleep() for a more formal "
"description."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:240
msgid ""
"0 on success, 1 if at least one value had to be rounded up or a negative "
"errno."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:243
#: drivers/pwm/core.c:302 drivers/pwm/core.c:441 drivers/pwm/core.c:724
#: drivers/pwm/core.c:768 drivers/pwm/core.c:795 drivers/pwm/core.c:844
msgid "**Context**"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:242
#: drivers/pwm/core.c:301 drivers/pwm/core.c:440 drivers/pwm/core.c:723
#: drivers/pwm/core.c:794 drivers/pwm/core.c:843
msgid "May sleep."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:292
msgid ""
"Query hardware about current configuration Cannot be used in atomic context."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:295
msgid "output parameter"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:296
msgid ""
"Stores the current configuration of the PWM in **wf**. Note this is the "
"equivalent of pwm_get_state_hw() (and not pwm_get_state()) for pwm_waveform."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:300
msgid "0 on success or a negative errno"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:402
msgid "Apply a new waveform Cannot be used in atomic context."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:406
msgid "``const struct pwm_waveform *wf``"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:405
msgid "The waveform to apply"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:407
msgid "``bool exact``"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:406
msgid "If true no rounding is allowed"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:407
msgid ""
"Typically a requested waveform cannot be implemented exactly, e.g. because "
"you requested .period_length_ns = 100 ns, but the hardware can only set "
"periods that are a multiple of 8.5 ns. With that hardware passing **exact** "
"= true results in pwm_set_waveform_might_sleep() failing and returning -"
"EDOM. If **exact** = false you get a period of 93.5 ns (i.e. the biggest "
"period not bigger than the requested value). Note that even with **exact** = "
"true, some rounding by less than 1 ns is possible/needed. In the above "
"example requesting .period_length_ns = 94 and **exact** = true, you get the "
"hardware configured with period = 93.5 ns."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:417
msgid ""
"Let C be the set of possible hardware configurations for a given PWM device, "
"consisting of tuples (p, d, o) where p is the period length, d is the duty "
"length and o the duty offset."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:421
msgid ""
"The following algorithm is implemented to pick the hardware setting (p, d, "
"o) ∈ C for a given request (p', d', o') with **exact** = false::"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:428
msgid ""
"In words: The chosen period length is the maximal possible period length not "
"bigger than the requested period length and if that doesn't exist, the "
"minimal period length. The chosen duty length is the maximal possible duty "
"length that is compatible with the chosen period length and isn't bigger "
"than the requested duty length. Again if such a value doesn't exist, the "
"minimal duty length compatible with the chosen period is picked. After that "
"the duty offset compatible with the chosen period and duty length is chosen "
"in the same way."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:438
msgid ""
"0 on success, -EDOM if setting failed due to the exact waveform not being "
"possible (if **exact**), or a different negative errno on failure."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:717
msgid ""
"atomically apply a new state to a PWM device Cannot be used in atomic "
"context."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:720
#: drivers/pwm/core.c:764
msgid "new state to apply"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:722
#: drivers/pwm/core.c:766
msgid "0 on success, or a negative errno"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:761
msgid ""
"apply a new state to a PWM device from atomic context Not all PWM devices "
"support this function, check with pwm_might_sleep()."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:767
msgid "Any"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:786
msgid "get the current PWM state from hardware"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:789
msgid ""
"Similar to pwm_get_state() but reads the current PWM state from hardware "
"instead of the requested state."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:835
msgid "adjust the current PWM config to the PWM arguments"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:837
msgid ""
"This function will adjust the PWM config to the PWM arguments provided by "
"the DT or PWM lookup table. This is particularly useful to adapt the "
"bootloader config to the Linux one."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:1890
msgid "look up and request a PWM device"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:1896
#: drivers/pwm/core.c:2063 drivers/pwm/core.c:2091
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:1891
#: drivers/pwm/core.c:2058 drivers/pwm/core.c:2086
msgid "device for PWM consumer"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:1893
#: drivers/pwm/core.c:2060 drivers/pwm/core.c:2089
msgid "``const char *con_id``"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:1892
#: drivers/pwm/core.c:2059 drivers/pwm/core.c:2088
msgid "consumer name"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:1893
msgid ""
"Lookup is first attempted using DT. If the device was not instantiated from "
"a device tree, a PWM chip and a relative index is looked up via a table "
"supplied by board setup code (see pwm_add_table())."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:1897
msgid ""
"Once a PWM chip has been found the specified PWM device will be requested "
"and is ready to be used."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:1901
#: drivers/pwm/core.c:2064 drivers/pwm/core.c:2093
msgid ""
"A pointer to the requested PWM device or an ERR_PTR()-encoded error code on "
"failure."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2037
msgid "release a PWM device"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2057
msgid "resource managed pwm_get()"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2060
msgid ""
"This function performs like pwm_get() but the acquired PWM device will "
"automatically be released on driver detach."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2085
msgid "request a resource managed PWM from firmware node"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2088
msgid "``struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2087
msgid "firmware node to get the PWM from"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2089
msgid ""
"Returns the PWM device parsed from the firmware node. See of_pwm_get() and "
"acpi_pwm_get() for a detailed description."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2387
msgid "register a new PWM chip"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2388
msgid "the PWM chip to add"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2389
msgid "reference to the module providing the chip."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2390
msgid ""
"Register a new PWM chip. **owner** is supposed to be THIS_MODULE, use the "
"pwmchip_add wrapper to do this right."
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2468
msgid "remove a PWM chip"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2469
msgid "the PWM chip to remove"
msgstr ""

#: ../../../driver-api/miscellaneous:47: drivers/pwm/core.c:2470
msgid "Removes a PWM chip."
msgstr ""
