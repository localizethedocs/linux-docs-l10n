# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/infrastructure.rst:2
msgid "Device drivers infrastructure"
msgstr ""

#: ../../../driver-api/infrastructure.rst:5
msgid "The Basic Device Driver-Model Structures"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:51
msgid "interfaces to device functions"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:28
#: include/linux/uio_driver.h:63 include/linux/uio_driver.h:94
#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:29
#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:30
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:56
#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:24
#: include/linux/device/faux.h:39 ../../../driver-api/infrastructure:50:
#: drivers/base/node.c:78 drivers/base/node.c:256
#: ../../../driver-api/infrastructure:7: include/linux/device.h:55
#: include/linux/device.h:104 include/linux/device.h:118
#: include/linux/device.h:390 include/linux/device.h:404
#: include/linux/device.h:463 include/linux/device.h:485
#: include/linux/device.h:698
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:42
#: include/linux/uio_driver.h:73 include/linux/uio_driver.h:112
#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:55
#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:47
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:80
#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:30
#: include/linux/device/faux.h:46 ../../../driver-api/infrastructure:50:
#: drivers/base/node.c:89 drivers/base/node.c:264
#: ../../../driver-api/infrastructure:7: include/linux/device.h:65
#: include/linux/device.h:112 include/linux/device.h:125
#: include/linux/device.h:399 include/linux/device.h:413
#: include/linux/device.h:473 include/linux/device.h:567
#: include/linux/device.h:714
msgid "**Members**"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:25
#: include/linux/uio_driver.h:60 include/linux/uio_driver.h:92
#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:27
#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:27
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:53
#: ../../../driver-api/infrastructure:7: include/linux/device.h:52
msgid "``name``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:53
msgid "name of the device function"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:53
msgid "``subsys``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:54
msgid "subsystem of the devices to attach to"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:254
#: ../../../driver-api/infrastructure:7: include/linux/device.h:54
msgid "``node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:55
msgid "the list of functions registered at the subsystem"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:55
msgid "``add_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:56
#: include/linux/device.h:57
msgid "device hookup to device function handler"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:56
msgid "``remove_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:133
#: include/linux/uio_driver.h:153 ../../../driver-api/infrastructure:11:
#: include/linux/device/bus.h:71 include/linux/device/bus.h:284
#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:46
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:45
#: include/linux/device/driver.h:91 ../../../driver-api/infrastructure:23:
#: drivers/base/init.c:3 ../../../driver-api/infrastructure:26:
#: include/linux/device/driver.h:254 include/linux/device/driver.h:281
#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:43
#: drivers/base/driver.c:115 drivers/base/driver.c:143
#: drivers/base/driver.c:221 drivers/base/driver.c:268
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3
#: drivers/base/core.c:677 drivers/base/core.c:954 drivers/base/core.c:972
#: drivers/base/core.c:2393 drivers/base/core.c:2866 drivers/base/core.c:3080
#: drivers/base/core.c:3140 drivers/base/core.c:3548 drivers/base/core.c:3754
#: drivers/base/core.c:3779 drivers/base/core.c:3823 drivers/base/core.c:3909
#: drivers/base/core.c:3999 drivers/base/core.c:4029 drivers/base/core.c:4060
#: drivers/base/core.c:4094 drivers/base/core.c:4259 drivers/base/core.c:4320
#: drivers/base/core.c:4463 drivers/base/core.c:4483 drivers/base/core.c:4719
#: drivers/base/core.c:5037 drivers/base/core.c:5085 drivers/base/core.c:5136
#: drivers/base/core.c:5181 drivers/base/core.c:5263
#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:3
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:258
#: drivers/base/class.c:296 drivers/base/class.c:315 drivers/base/class.c:345
#: drivers/base/class.c:376 drivers/base/class.c:393 drivers/base/class.c:440
#: drivers/base/class.c:569 drivers/base/class.c:628
#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:25
#: include/linux/device/faux.h:45 ../../../driver-api/infrastructure:47:
#: drivers/base/faux.c:113 drivers/base/faux.c:192 drivers/base/faux.c:217
#: ../../../driver-api/infrastructure:50: drivers/base/node.c:672
#: drivers/base/node.c:720 ../../../driver-api/infrastructure:53:
#: drivers/base/transport_class.c:42 drivers/base/transport_class.c:62
#: drivers/base/transport_class.c:84 drivers/base/transport_class.c:110
#: drivers/base/transport_class.c:137 drivers/base/transport_class.c:189
#: drivers/base/transport_class.c:220 drivers/base/transport_class.c:259
#: drivers/base/transport_class.c:288 ../../../driver-api/infrastructure:56:
#: drivers/base/dd.c:3 drivers/base/dd.c:285 drivers/base/dd.c:388
#: drivers/base/dd.c:485 drivers/base/dd.c:1062 drivers/base/dd.c:1120
#: drivers/base/dd.c:1227 drivers/base/dd.c:1306
#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:151
#: include/linux/platform_device.h:179 include/linux/platform_device.h:210
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:158
#: drivers/base/platform.c:248 drivers/base/platform.c:330
#: drivers/base/platform.c:464 drivers/base/platform.c:485
#: drivers/base/platform.c:546 drivers/base/platform.c:574
#: drivers/base/platform.c:601 drivers/base/platform.c:629
#: drivers/base/platform.c:654 drivers/base/platform.c:742
#: drivers/base/platform.c:787 drivers/base/platform.c:804
#: drivers/base/platform.c:899 drivers/base/platform.c:971
#: drivers/base/platform.c:1024 drivers/base/platform.c:1065
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:344
#: drivers/base/bus.c:384 drivers/base/bus.c:436 drivers/base/bus.c:780
#: drivers/base/bus.c:794 drivers/base/bus.c:852 drivers/base/bus.c:940
#: drivers/base/bus.c:1268 drivers/base/bus.c:1293 drivers/base/bus.c:1317
#: drivers/base/bus.c:1366 ../../../driver-api/infrastructure:74:
#: kernel/dma/mapping.c:67 kernel/dma/mapping.c:87 kernel/dma/mapping.c:241
#: kernel/dma/mapping.c:269 kernel/dma/mapping.c:450 kernel/dma/mapping.c:539
#: kernel/dma/mapping.c:563 kernel/dma/mapping.c:948
#: ../../../driver-api/infrastructure:7: include/linux/device.h:60
#: include/linux/device.h:145 include/linux/device.h:167
#: include/linux/device.h:177 include/linux/device.h:187
#: include/linux/device.h:196 include/linux/device.h:205
#: include/linux/device.h:214 include/linux/device.h:225
#: include/linux/device.h:238 include/linux/device.h:250
#: include/linux/device.h:262 include/linux/device.h:289
#: include/linux/device.h:505 include/linux/device.h:754
#: include/linux/device.h:1000 include/linux/device.h:1015
#: include/linux/device.h:1047 include/linux/device.h:1068
#: ../../../driver-api/infrastructure:80: drivers/pnp/core.c:45
#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:335
#: drivers/pnp/manager.c:359 drivers/pnp/manager.c:381
#: drivers/pnp/manager.c:407 ../../../driver-api/infrastructure:98:
#: drivers/uio/uio.c:977 drivers/uio/uio.c:1073
msgid "**Description**"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:57
msgid ""
"Simple interfaces attached to a subsystem. Multiple interfaces can attach to "
"a subsystem and its devices. Unlike drivers, they do not exclusively claim "
"or control devices. Interfaces usually represent a specific functionality of "
"a subsystem/class of devices."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:100
msgid "Interface for exporting device attributes."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:101
#: include/linux/device.h:115
msgid "``attr``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:102
msgid "sysfs attribute definition."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:102
msgid "``show``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:103
msgid "Show handler."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:103
msgid "``store``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:104
msgid "Store handler."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:114
msgid "Exported device attribute with extra context."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:116
msgid "Exported device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:116
msgid "``var``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:117
msgid "Pointer to context."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:141
msgid "``DEVICE_ATTR (_name, _mode, _show, _store)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:139
msgid "Define a device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:133
#: include/linux/uio_driver.h:153 ../../../driver-api/infrastructure:23:
#: drivers/base/init.c:20 ../../../driver-api/infrastructure:26:
#: include/linux/device/driver.h:167 include/linux/device/driver.h:179
#: include/linux/device/driver.h:192 include/linux/device/driver.h:205
#: include/linux/device/driver.h:224 include/linux/device/driver.h:248
#: include/linux/device/driver.h:274 ../../../driver-api/infrastructure:29:
#: drivers/base/driver.c:38 drivers/base/driver.c:113 drivers/base/driver.c:141
#: drivers/base/driver.c:179 drivers/base/driver.c:197
#: drivers/base/driver.c:222 drivers/base/driver.c:269
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:545
#: drivers/base/core.c:673 drivers/base/core.c:955 drivers/base/core.c:972
#: drivers/base/core.c:2394 drivers/base/core.c:2866 drivers/base/core.c:3043
#: drivers/base/core.c:3067 drivers/base/core.c:3080 drivers/base/core.c:3097
#: drivers/base/core.c:3112 drivers/base/core.c:3141 drivers/base/core.c:3486
#: drivers/base/core.c:3549 drivers/base/core.c:3755 drivers/base/core.c:3780
#: drivers/base/core.c:3794 drivers/base/core.c:3824 drivers/base/core.c:3910
#: drivers/base/core.c:3999 drivers/base/core.c:4029 drivers/base/core.c:4059
#: drivers/base/core.c:4094 drivers/base/core.c:4259 drivers/base/core.c:4321
#: drivers/base/core.c:4387 drivers/base/core.c:4422 drivers/base/core.c:4463
#: drivers/base/core.c:4483 drivers/base/core.c:4583 drivers/base/core.c:4718
#: drivers/base/core.c:5035 drivers/base/core.c:5083 drivers/base/core.c:5136
#: drivers/base/core.c:5181 drivers/base/core.c:5202 drivers/base/core.c:5226
#: drivers/base/core.c:5263 ../../../driver-api/infrastructure:35:
#: drivers/base/syscore.c:22 drivers/base/syscore.c:34
#: drivers/base/syscore.c:47 drivers/base/syscore.c:91
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:103
#: include/linux/device/class.h:115 include/linux/device/class.h:127
#: include/linux/device/class.h:139 include/linux/device/class.h:153
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:259
#: drivers/base/class.c:297 drivers/base/class.c:313 drivers/base/class.c:346
#: drivers/base/class.c:377 drivers/base/class.c:391 drivers/base/class.c:438
#: drivers/base/class.c:570 drivers/base/class.c:593 drivers/base/class.c:604
#: drivers/base/class.c:616 drivers/base/class.c:628
#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:104
#: drivers/base/faux.c:187 drivers/base/faux.c:218
#: ../../../driver-api/infrastructure:50: drivers/base/node.c:330
#: drivers/base/node.c:673 drivers/base/node.c:718
#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:42
#: drivers/base/transport_class.c:62 drivers/base/transport_class.c:84
#: drivers/base/transport_class.c:110 drivers/base/transport_class.c:138
#: drivers/base/transport_class.c:189 drivers/base/transport_class.c:220
#: drivers/base/transport_class.c:259 drivers/base/transport_class.c:288
#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:281
#: drivers/base/dd.c:389 drivers/base/dd.c:486 drivers/base/dd.c:770
#: drivers/base/dd.c:1063 drivers/base/dd.c:1120 drivers/base/dd.c:1228
#: drivers/base/dd.c:1307 ../../../driver-api/infrastructure:59:
#: include/linux/platform_device.h:144 include/linux/platform_device.h:177
#: include/linux/platform_device.h:207 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:52 drivers/base/platform.c:91
#: drivers/base/platform.c:116 drivers/base/platform.c:134
#: drivers/base/platform.c:158 drivers/base/platform.c:248
#: drivers/base/platform.c:278 drivers/base/platform.c:326
#: drivers/base/platform.c:419 drivers/base/platform.c:464
#: drivers/base/platform.c:485 drivers/base/platform.c:502
#: drivers/base/platform.c:547 drivers/base/platform.c:574
#: drivers/base/platform.c:600 drivers/base/platform.c:628
#: drivers/base/platform.c:655 drivers/base/platform.c:743
#: drivers/base/platform.c:772 drivers/base/platform.c:788
#: drivers/base/platform.c:803 drivers/base/platform.c:861
#: drivers/base/platform.c:876 drivers/base/platform.c:898
#: drivers/base/platform.c:966 drivers/base/platform.c:1023
#: drivers/base/platform.c:1065 drivers/base/platform.c:1499
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:158
#: include/linux/device/bus.h:172 include/linux/device/bus.h:184
#: include/linux/device/bus.h:196 include/linux/device/bus.h:208
#: include/linux/device/bus.h:223 ../../../driver-api/infrastructure:68:
#: drivers/base/bus.c:342 drivers/base/bus.c:382 drivers/base/bus.c:434
#: drivers/base/bus.c:781 drivers/base/bus.c:795 drivers/base/bus.c:853
#: drivers/base/bus.c:941 drivers/base/bus.c:1268 drivers/base/bus.c:1293
#: drivers/base/bus.c:1317 drivers/base/bus.c:1367
#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:65
#: kernel/dma/mapping.c:84 kernel/dma/mapping.c:238 kernel/dma/mapping.c:267
#: kernel/dma/mapping.c:451 kernel/dma/mapping.c:540 kernel/dma/mapping.c:559
#: kernel/dma/mapping.c:949 ../../../driver-api/infrastructure:7:
#: include/linux/device.h:143 include/linux/device.h:165
#: include/linux/device.h:178 include/linux/device.h:188
#: include/linux/device.h:197 include/linux/device.h:206
#: include/linux/device.h:215 include/linux/device.h:224
#: include/linux/device.h:237 include/linux/device.h:249
#: include/linux/device.h:261 include/linux/device.h:289
#: include/linux/device.h:728 include/linux/device.h:741
#: include/linux/device.h:755 include/linux/device.h:1000
#: include/linux/device.h:1016 include/linux/device.h:1046
#: include/linux/device.h:1069 ../../../driver-api/infrastructure:80:
#: drivers/pnp/core.c:46 ../../../driver-api/infrastructure:83:
#: drivers/pnp/card.c:295 drivers/pnp/card.c:347 drivers/pnp/card.c:385
#: drivers/pnp/card.c:419 ../../../driver-api/infrastructure:86:
#: drivers/pnp/driver.c:295 ../../../driver-api/infrastructure:89:
#: drivers/pnp/manager.c:336 drivers/pnp/manager.c:360
#: drivers/pnp/manager.c:382 drivers/pnp/manager.c:408
#: ../../../driver-api/infrastructure:92: drivers/pnp/support.c:20
#: ../../../driver-api/infrastructure:98: drivers/uio/uio.c:431
#: drivers/uio/uio.c:976 drivers/uio/uio.c:1072 drivers/uio/uio.c:1105
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:145
#: include/linux/device.h:167 include/linux/device.h:180
#: include/linux/device.h:190 include/linux/device.h:199
#: include/linux/device.h:208 include/linux/device.h:217
#: include/linux/device.h:226 include/linux/device.h:239
#: include/linux/device.h:251 include/linux/device.h:263
msgid "``_name``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:140
#: include/linux/device.h:162 include/linux/device.h:175
#: include/linux/device.h:185 include/linux/device.h:194
#: include/linux/device.h:203 include/linux/device.h:212
#: include/linux/device.h:221 include/linux/device.h:234
#: include/linux/device.h:246 include/linux/device.h:258
msgid "Attribute name."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:142
#: include/linux/device.h:164 include/linux/device.h:223
#: include/linux/device.h:236 include/linux/device.h:248
#: include/linux/device.h:260
msgid "``_mode``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:141
#: include/linux/device.h:163 include/linux/device.h:222
#: include/linux/device.h:235 include/linux/device.h:247
#: include/linux/device.h:259
msgid "File mode."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:143
#: include/linux/device.h:165
msgid "``_show``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:142
#: include/linux/device.h:164
msgid "Show handler. Optional, but mandatory if attribute is readable."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:144
#: include/linux/device.h:166
msgid "``_store``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:143
#: include/linux/device.h:165
msgid "Store handler. Optional, but mandatory if attribute is writable."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:144
msgid "Convenience macro for defining a struct device_attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:146
msgid ""
"For example, ``DEVICE_ATTR(foo, 0644, foo_show, foo_store);`` expands to:"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:163
msgid "``DEVICE_ATTR_PREALLOC (_name, _mode, _show, _store)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:161
msgid "Define a preallocated device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:166
msgid "Like DEVICE_ATTR(), but ``SYSFS_PREALLOC`` is set on **_mode**."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:176
msgid "``DEVICE_ATTR_RW (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:174
msgid "Define a read-write device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:176
msgid ""
"Like DEVICE_ATTR(), but **_mode** is 0644, **_show** is <_name>_show, and "
"**_store** is <_name>_store."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:186
msgid "``DEVICE_ATTR_ADMIN_RW (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:184
msgid "Define an admin-only read-write device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:186
msgid "Like DEVICE_ATTR_RW(), but **_mode** is 0600."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:195
msgid "``DEVICE_ATTR_RO (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:193
msgid "Define a readable device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:195
msgid ""
"Like DEVICE_ATTR(), but **_mode** is 0444 and **_show** is <_name>_show."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:204
msgid "``DEVICE_ATTR_ADMIN_RO (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:202
msgid "Define an admin-only readable device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:204
msgid "Like DEVICE_ATTR_RO(), but **_mode** is 0400."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:213
msgid "``DEVICE_ATTR_WO (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:211
msgid "Define an admin-only writable device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:213
msgid ""
"Like DEVICE_ATTR(), but **_mode** is 0200 and **_store** is <_name>_store."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:222
msgid "``DEVICE_ULONG_ATTR (_name, _mode, _var)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:220
msgid "Define a device attribute backed by an unsigned long."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:224
#: include/linux/device.h:237 include/linux/device.h:249
#: include/linux/device.h:261
msgid "``_var``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:223
msgid "Identifier of unsigned long."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:224
msgid ""
"Like DEVICE_ATTR(), but **_show** and **_store** are automatically provided "
"such that reads and writes to the attribute from userspace affect **_var**."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:235
msgid "``DEVICE_INT_ATTR (_name, _mode, _var)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:233
msgid "Define a device attribute backed by an int."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:236
msgid "Identifier of int."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:237
msgid "Like DEVICE_ULONG_ATTR(), but **_var** is an int."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:247
msgid "``DEVICE_BOOL_ATTR (_name, _mode, _var)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:245
msgid "Define a device attribute backed by a bool."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:248
msgid "Identifier of bool."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:249
msgid "Like DEVICE_ULONG_ATTR(), but **_var** is a bool."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:259
msgid "``DEVICE_STRING_ATTR_RO (_name, _mode, _var)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:257
msgid "Define a device attribute backed by a r/o string."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:260
msgid "Identifier of string."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:261
msgid ""
"Like DEVICE_ULONG_ATTR(), but **_var** is a string. Because the length of "
"the string allocation is unknown, the attribute must be read-only."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:287
msgid "``devm_alloc_percpu (dev, type)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:285
msgid "Resource-managed alloc_percpu"
msgstr ""

#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:21
#: ../../../driver-api/infrastructure:50: drivers/base/node.c:76
#: drivers/base/node.c:253 ../../../driver-api/infrastructure:7:
#: include/linux/device.h:291 include/linux/device.h:1048
#: include/linux/device.h:1071
msgid "``dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:286
msgid "Device to allocate per-cpu memory for"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:288
#: include/linux/device.h:490
msgid "``type``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:287
msgid "Type to allocate per-cpu memory for"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:288
msgid ""
"Managed alloc_percpu. Per-cpu memory allocated with this function is "
"automatically freed on driver detach."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:45
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:674
#: drivers/base/core.c:5226 ../../../driver-api/infrastructure:47:
#: drivers/base/faux.c:123 drivers/base/faux.c:200
#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:280
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:53
#: drivers/base/platform.c:95 drivers/base/platform.c:119
#: drivers/base/platform.c:138 drivers/base/platform.c:168
#: drivers/base/platform.c:257 drivers/base/platform.c:277
#: drivers/base/platform.c:332 drivers/base/platform.c:465
#: drivers/base/platform.c:487 drivers/base/platform.c:502
#: drivers/base/platform.c:1028 ../../../driver-api/infrastructure:74:
#: kernel/dma/mapping.c:89 ../../../driver-api/infrastructure:7:
#: include/linux/device.h:291 include/linux/device.h:740
msgid "**Return**"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:90
#: ../../../driver-api/infrastructure:7: include/linux/device.h:292
msgid "Pointer to allocated memory on success, NULL on failure."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:356
msgid "Device driver presence tracking information."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:258
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:28
#: ../../../driver-api/infrastructure:7: include/linux/device.h:360
#: include/linux/device.h:374 include/linux/device.h:416
#: include/linux/device.h:437 include/linux/device.h:450
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:362
msgid "``DL_DEV_NO_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:363
msgid "There is no driver attached to the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:365
msgid "``DL_DEV_PROBING``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:366
msgid "A driver is probing."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:368
msgid "``DL_DEV_DRIVER_BOUND``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:369
msgid "The driver has been bound to the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:371
msgid "``DL_DEV_UNBINDING``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:372
msgid "The driver is unbinding from the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:370
msgid ""
"Whether the device is removable. The criteria for a device to be classified "
"as removable is determined by its subsystem or bus."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:376
msgid "``DEVICE_REMOVABLE_NOT_SUPPORTED``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:377
msgid "This attribute is not supported for this device (default)."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:380
msgid "``DEVICE_REMOVABLE_UNKNOWN``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:381
msgid "Device location is Unknown."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:383
msgid "``DEVICE_FIXED``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:384
msgid "Device is not removable by the user."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:386
msgid "``DEVICE_REMOVABLE``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:387
msgid "Device is removable by the user."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:386
msgid "Device data related to device links."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:387
msgid "``suppliers``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:388
msgid "List of links to supplier devices."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:388
msgid "``consumers``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:389
msgid "List of links to consumer devices."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:389
msgid "``defer_sync``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:390
msgid "Hook to global list of devices that have deferred sync_state."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:390
#: include/linux/device.h:700
msgid "``status``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:391
msgid "Driver status information."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:400
msgid "Device data related to MSI"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:401
msgid "``domain``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:402
msgid "The MSI interrupt domain associated to the device"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:402
msgid "``data``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:403
msgid "Pointer to MSI device data"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:412
msgid ""
"Describes which panel surface of the system's housing the device connection "
"point resides on."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:418
msgid "``DEVICE_PANEL_TOP``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:419
msgid "Device connection point is on the top panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:421
msgid "``DEVICE_PANEL_BOTTOM``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:422
msgid "Device connection point is on the bottom panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:424
msgid "``DEVICE_PANEL_LEFT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:425
msgid "Device connection point is on the left panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:427
msgid "``DEVICE_PANEL_RIGHT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:428
msgid "Device connection point is on the right panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:430
msgid "``DEVICE_PANEL_FRONT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:431
msgid "Device connection point is on the front panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:433
msgid "``DEVICE_PANEL_BACK``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:434
msgid "Device connection point is on the back panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:436
msgid "``DEVICE_PANEL_UNKNOWN``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:437
msgid "The panel with device connection point is unknown."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:433
msgid ""
"Describes vertical position of the device connection point on the panel "
"surface."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:439
msgid "``DEVICE_VERT_POS_UPPER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:440
msgid "Device connection point is at upper part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:442
msgid "``DEVICE_VERT_POS_CENTER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:443
#: include/linux/device.h:456
msgid "Device connection point is at center part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:445
msgid "``DEVICE_VERT_POS_LOWER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:446
msgid "Device connection point is at lower part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:446
msgid ""
"Describes horizontal position of the device connection point on the panel "
"surface."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:452
msgid "``DEVICE_HORI_POS_LEFT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:453
msgid "Device connection point is at left part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:455
msgid "``DEVICE_HORI_POS_CENTER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:458
msgid "``DEVICE_HORI_POS_RIGHT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:459
msgid "Device connection point is at right part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:459
msgid ""
"Device data related to physical location of the device connection point."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:461
msgid "``panel``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:462
msgid ""
"Panel surface of the system's housing that the device connection point "
"resides on."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:463
msgid "``vertical_position``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:464
msgid "Vertical position of the device connection point within the panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:465
msgid "``horizontal_position``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:466
msgid "Horizontal position of the device connection point within the panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:467
msgid "``dock``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:468
msgid ""
"Set if the device connection point resides in a docking station or port "
"replicator."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:469
msgid "``lid``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:470
msgid ""
"Set if this device connection point resides on the lid of laptop system."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:481
msgid "The basic device structure"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:488
msgid "``kobj``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:489
msgid "A top-level, abstract class from which other classes are derived."
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:135
#: include/linux/uio_driver.h:155 ../../../driver-api/infrastructure:7:
#: include/linux/device.h:482
msgid "``parent``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:483
msgid ""
"The device's \"parent\" device, the device to which it is attached. In most "
"cases, a parent device is some sort of bus or host controller. If parent is "
"NULL, the device, is a top-level device, which is not usually what you want."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:86
#: ../../../driver-api/infrastructure:7: include/linux/device.h:486
msgid "``p``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:487
msgid ""
"Holds the private data of the driver core portions of the device. See the "
"comment of the struct device_private for detail."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:489
msgid "``init_name``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:490
msgid "Initial name of the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:491
msgid ""
"The type of device. This identifies the device type and carries type-"
"specific information."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:54
#: ../../../driver-api/infrastructure:7: include/linux/device.h:494
msgid "``bus``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:495
msgid "Type of bus device is on."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:495
msgid "``driver``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:496
msgid "Which driver has allocated this"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:496
msgid "``platform_data``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:497
msgid "Platform data specific to the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:504
msgid "``driver_data``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:505
msgid "Private pointer for driver specific info."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:493
msgid "``mutex``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:494
msgid "Mutex to synchronize calls to its driver."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:505
msgid "``links``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:506
msgid "Links to suppliers and consumers of this device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:506
msgid "``power``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:507
msgid ""
"For device power management. See Documentation/driver-api/pm/devices.rst for "
"details."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:508
msgid "``pm_domain``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:509
msgid ""
"Provide callbacks that are executed during system suspend, hibernation, "
"system resume and during runtime PM transitions along with subsystem-level "
"and driver-level callbacks."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:511
msgid "``em_pd``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:512
msgid "device's energy model performance domain"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:512
msgid "``pins``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:513
msgid ""
"For device pin management. See Documentation/driver-api/pin-control.rst for "
"details."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:514
msgid "``msi``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:515
msgid "MSI related data"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:516
msgid "``dma_ops``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:517
msgid "DMA mapping operations for this device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:517
msgid "``dma_mask``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:518
msgid "Dma mask (if dma'ble device)."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:518
msgid "``coherent_dma_mask``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:519
msgid ""
"Like dma_mask, but for alloc_coherent mapping as not all hardware supports "
"64-bit addresses for consistent allocations such descriptors."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:521
msgid "``bus_dma_limit``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:522
msgid ""
"Limit of an upstream bridge or bus which imposes a smaller DMA limit than "
"the device itself supports."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:523
msgid "``dma_range_map``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:524
msgid "map for DMA memory ranges relative to that of RAM"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:524
msgid "``dma_parms``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:525
msgid ""
"A low level driver may set these to teach IOMMU code about segment "
"limitations."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:526
msgid "``dma_pools``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:527
msgid "Dma pools (if dma'ble device)."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:527
msgid "``dma_mem``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:528
msgid "Internal for coherent mem override."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:528
msgid "``cma_area``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:529
msgid "Contiguous memory area for dma allocations"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:529
msgid "``dma_io_tlb_mem``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:530
msgid "Software IO TLB allocator.  Not for driver use."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:530
msgid "``dma_io_tlb_pools``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:531
msgid "List of transient swiotlb memory pools."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:531
msgid "``dma_io_tlb_lock``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:532
msgid "Protects changes to the list of active pools."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:532
msgid "``dma_uses_io_tlb``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:533
msgid "``true`` if device has used the software IO TLB."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:533
msgid "``archdata``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:534
msgid "For arch-specific additions."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:534
msgid "``of_node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:535
msgid "Associated device tree node."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:535
msgid "``fwnode``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:536
msgid "Associated device node supplied by platform firmware."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:515
msgid "``numa_node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:516
msgid "NUMA node this device is close to."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:536
msgid "``devt``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:537
msgid "For creating the sysfs \"dev\"."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:537
msgid "``id``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:538
msgid "device instance"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:538
msgid "``devres_lock``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:539
msgid "Spinlock to protect the resource of the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:539
msgid "``devres_head``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:540
msgid "The resources list of the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:540
msgid "``class``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:541
msgid "The class of the device."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:77
#: ../../../driver-api/infrastructure:7: include/linux/device.h:541
msgid "``groups``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:542
msgid "Optional attribute groups."
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:102
#: ../../../driver-api/infrastructure:7: include/linux/device.h:542
msgid "``release``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:543
msgid ""
"Callback to free the device after all references have gone away. This should "
"be set by the allocator of the device (i.e. the bus driver that discovered "
"the device)."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:545
msgid "``iommu_group``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:546
msgid "IOMMU group the device belongs to."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:546
msgid "``iommu``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:547
msgid "Per device generic IOMMU runtime data"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:547
msgid "``physical_location``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:548
msgid ""
"Describes physical location of the device connection point in the system "
"housing."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:549
msgid "``removable``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:550
msgid ""
"Whether the device can be removed from the system. This should be set by the "
"subsystem / bus driver that discovered the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:553
msgid "``offline_disabled``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:554
msgid "If set, the device is permanently online."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:54
#: ../../../driver-api/infrastructure:7: include/linux/device.h:554
msgid "``offline``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:555
msgid "Set after successful invocation of bus type's .offline()."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:555
msgid "``of_node_reused``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:556
msgid "Set if the device-tree node is shared with an ancestor device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:557
msgid "``state_synced``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:558
msgid ""
"The hardware state of this device has been synced to match the software "
"state of this device by calling the driver/bus sync_state() callback."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:560
msgid "``can_match``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:561
msgid ""
"The device has matched with a driver at least once or it is in a bus (like "
"AMBA) which can't check for matching drivers until other devices probe "
"successfully."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:563
msgid "``dma_coherent``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:564
msgid ""
"this particular device is dma coherent, even if the architecture supports "
"non-coherent devices."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:565
msgid "``dma_ops_bypass``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:566
msgid ""
"If set to ``true`` then the dma_ops are bypassed for the streaming DMA "
"operations (->map_* / ->unmap_* / ->sync_*), and optionall (if the coherent "
"mask is large enough) also for dma allocations.  This flag is managed by the "
"dma ops instance from ->dma_supported."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:570
msgid "``dma_skip_sync``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:571
msgid "DMA sync operations can be skipped for coherent buffers."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:571
msgid "``dma_iommu``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:572
msgid ""
"Device is using default IOMMU implementation for DMA and doesn't rely on "
"dma_ops structure."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:576
msgid "**Example**"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:497
msgid "For devices on custom boards, as typical of embedded"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:498
msgid ""
"and SOC based hardware, Linux often uses platform_data to point to board-"
"specific structures describing devices and how they are wired.  That can "
"include what ports are available, chip variants, which GPIO pins act in what "
"additional roles, and so on.  This shrinks the \"Board Support "
"Packages\" (BSPs) and minimizes board-specific #ifdefs in drivers."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:573
msgid ""
"At the lowest level, every device in a Linux system is represented by an "
"instance of struct device. The device structure contains the information "
"that the device model core needs to model the system. Most subsystems, "
"however, track additional information about the devices they host. As a "
"result, it is rare for devices to be represented by bare device structures; "
"instead, that structure, like kobject structures, is usually embedded within "
"a higher-level representation of the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:694
msgid "Device link representation."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:695
msgid "``supplier``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:696
msgid "The device on the supplier end of the link."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:696
msgid "``s_node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:697
msgid "Hook to the supplier device's list of links to consumers."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:697
msgid "``consumer``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:698
msgid "The device on the consumer end of the link."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:698
msgid "``c_node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:699
msgid "Hook to the consumer device's list of links to suppliers."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:699
msgid "``link_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:700
msgid "device used to expose link details in sysfs"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:701
msgid "The state of the link (with respect to the presence of drivers)."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:701
msgid "``flags``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:672
#: ../../../driver-api/infrastructure:7: include/linux/device.h:702
msgid "Link flags."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:702
msgid "``rpm_active``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:703
msgid "Whether or not the consumer device is runtime-PM-active."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:703
msgid "``kref``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:704
msgid "Count repeated addition of the same link."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:704
msgid "``rm_work``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:705
msgid "Work structure used for removing the link."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:705
msgid "``supplier_preactivated``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:706
msgid "Supplier has been made active before consumer probe."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:724
msgid "Returns true when the device DMA is translated by an IOMMU"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:40
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2868
#: drivers/base/core.c:3045 drivers/base/core.c:3069 drivers/base/core.c:3082
#: drivers/base/core.c:3099 drivers/base/core.c:3114 drivers/base/core.c:3143
#: drivers/base/core.c:3488 drivers/base/core.c:3551 drivers/base/core.c:3757
#: drivers/base/core.c:3782 drivers/base/core.c:3796 drivers/base/core.c:3826
#: drivers/base/core.c:3912 drivers/base/core.c:4323 drivers/base/core.c:4485
#: drivers/base/core.c:4585 drivers/base/core.c:4720 drivers/base/core.c:5138
#: drivers/base/core.c:5183 drivers/base/core.c:5204 drivers/base/core.c:5228
#: drivers/base/core.c:5265 ../../../driver-api/infrastructure:41:
#: drivers/base/class.c:604 drivers/base/class.c:616
#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:140
#: drivers/base/transport_class.c:191 drivers/base/transport_class.c:222
#: drivers/base/transport_class.c:261 drivers/base/transport_class.c:290
#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:283
#: drivers/base/dd.c:391 drivers/base/dd.c:488 drivers/base/dd.c:1065
#: drivers/base/dd.c:1119 drivers/base/dd.c:1309
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:797
#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:67
#: kernel/dma/mapping.c:86 kernel/dma/mapping.c:240 kernel/dma/mapping.c:269
#: kernel/dma/mapping.c:453 kernel/dma/mapping.c:542 kernel/dma/mapping.c:561
#: kernel/dma/mapping.c:951 ../../../driver-api/infrastructure:7:
#: include/linux/device.h:730
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:726
msgid "Device to perform the check on"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:737
msgid "Return a device's name."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2396
#: drivers/base/core.c:5037 drivers/base/core.c:5085
#: ../../../driver-api/infrastructure:7: include/linux/device.h:743
#: include/linux/device.h:757
msgid "``const struct device *dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:738
msgid "Device with name to get."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:739
msgid "The kobject name of the device, or its initial name if unavailable."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:751
msgid "Return a device's bus/class name, if at all possible"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:752
msgid "struct device to get the bus/class name of"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:753
msgid ""
"Will return the name of the bus/class the device is attached to.  If it is "
"not attached to a bus/class, an empty string will be returned."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:996
msgid "device iterator for locating a child device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4001
#: drivers/base/core.c:4031 drivers/base/core.c:4061 drivers/base/core.c:4096
#: drivers/base/core.c:4386 drivers/base/core.c:4421
#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:106
#: drivers/base/faux.c:187 ../../../driver-api/infrastructure:59:
#: include/linux/platform_device.h:146 include/linux/platform_device.h:209
#: ../../../driver-api/infrastructure:7: include/linux/device.h:1002
#: include/linux/device.h:1018 ../../../driver-api/infrastructure:98:
#: drivers/uio/uio.c:975 drivers/uio/uio.c:1071
msgid "``struct device *parent``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4091
#: ../../../driver-api/infrastructure:7: include/linux/device.h:997
#: include/linux/device.h:1013
msgid "parent struct device"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:167
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4261
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:103
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:261
#: drivers/base/class.c:572 ../../../driver-api/infrastructure:47:
#: drivers/base/faux.c:106 drivers/base/faux.c:189
#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:145
#: include/linux/platform_device.h:179 include/linux/platform_device.h:206
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:137
#: drivers/base/platform.c:419 drivers/base/platform.c:463
#: drivers/base/platform.c:484 drivers/base/platform.c:576
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:159
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1319
#: ../../../driver-api/infrastructure:7: include/linux/device.h:999
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:998
msgid "name of the child device"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:999
msgid ""
"This is similar to the device_find_child() function above, but it returns a "
"reference to a device that has the name **name**."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3152
#: drivers/base/core.c:3561 drivers/base/core.c:3763 drivers/base/core.c:3828
#: drivers/base/core.c:4103 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:771 ../../../driver-api/infrastructure:68:
#: drivers/base/bus.c:350 drivers/base/bus.c:441
#: ../../../driver-api/infrastructure:7: include/linux/device.h:1002
#: include/linux/device.h:1017
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4104
#: ../../../driver-api/infrastructure:7: include/linux/device.h:1003
#: include/linux/device.h:1018
msgid "you will need to drop the reference with put_device() after use."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1012
msgid "device iterator for locating a child device, if any."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1014
msgid ""
"This is similar to the device_find_child() function above, but it returns a "
"reference to a child device, if any."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1044
msgid "``device_lock_set_class (dev, key)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1042
msgid "Specify a temporary lock class while a device is attached to a driver"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1044
#: include/linux/device.h:1066
msgid "device to modify"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1046
msgid "``key``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1045
msgid "lock class key data"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1046
msgid ""
"This must be called with the device_lock() already held, for example from "
"driver ->probe(). Take care to only override the default lockdep_no_validate "
"class."
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1067
msgid "``device_lock_reset_class (dev)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1065
msgid "Return a device to the default lockdep novalidate state"
msgstr ""

#: ../../../driver-api/infrastructure:7: include/linux/device.h:1067
msgid ""
"This must be called with the device_lock() already held, for example from "
"driver ->remove()."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:25
msgid "The bus type of the device"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:28
msgid "The name of the bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:28
msgid "``dev_name``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:29
msgid "Used for subsystems to enumerate devices like (\"foo``u``\", dev->id)."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:29
msgid "``bus_groups``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:30
msgid "Default attributes of the bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:30
#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:29
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:79
msgid "``dev_groups``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:31
msgid "Default attributes of the devices on the bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:31
msgid "``drv_groups``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:32
msgid "Default attributes of the device drivers on the bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:32
msgid "``match``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:33
msgid ""
"Called, perhaps multiple times, whenever a new device or driver is added for "
"this bus. It should return a positive value if the given device can be "
"handled by the given driver and zero otherwise. It may also return error "
"code if determining that the driver supports the device is not possible. In "
"case of -EPROBE_DEFER it will queue the device for deferred probing."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:38
msgid "``uevent``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:39
msgid ""
"Called when a device is added, removed, or a few other things that generate "
"uevents to add the environment variables."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:40
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:61
#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:36
msgid "``probe``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:41
msgid ""
"Called when a new device or driver add to this bus, and callback the "
"specific driver's probe to initial the matched device."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:42
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:64
msgid "``sync_state``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:43
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:65
msgid ""
"Called to sync device state to software state after all the state tracking "
"consumers linked to this device (present at the time of late_initcall) have "
"successfully bound to a driver. If the device has no consumers, this "
"function will be called at late_initcall_sync level. If the device has "
"consumers that are never bound to a driver, this function will never get "
"called until they do."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:49
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:71
#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:41
msgid "``remove``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:50
msgid "Called when a device removed from this bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:50
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:73
msgid "``shutdown``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:51
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:74
msgid "Called at shut-down time to quiesce the device."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:51
msgid "``irq_get_affinity``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:52
msgid "Get IRQ affinity mask for the device on this bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:53
msgid "``online``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:54
msgid "Called to put the device back online (after offlining it)."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:55
msgid "Called to put the device offline for hot-removal. May fail."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:56
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:74
msgid "``suspend``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:57
msgid "Called when a device on this bus wants to go to sleep mode."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:57
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:76
msgid "``resume``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:58
msgid "Called to bring a device on this bus out of sleep mode."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:58
msgid "``num_vf``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:59
msgid ""
"Called to find out how many virtual functions a device on this bus supports."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:60
msgid "``dma_configure``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:61
msgid "Called to setup DMA configuration on a device on this bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:62
msgid "``dma_cleanup``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:63
msgid "Called to cleanup DMA configuration on a device on this bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:64
#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:42
#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:81
msgid "``pm``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:65
msgid ""
"Power management operations of this bus, callback the specific device "
"driver's pm-ops."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:66
msgid "``need_parent_lock``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:67
msgid ""
"When probing or removing a device on this bus, the device core should lock "
"the device's parent."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:68
msgid ""
"A bus is a channel between the processor and one or more devices. For the "
"purposes of the device model, all devices are connected via a bus, even if "
"it is an internal, virtual, \"platform\" bus. Buses can plug into each "
"other. A USB controller is usually a PCI device, for example. The device "
"model represents the actual connections between buses and the devices they "
"control. A bus is represented by the bus_type structure. It contains the "
"name, the default attributes, the bus' methods, PM operations, and the "
"driver core's private data."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:254
msgid "Bus Notifier events that have happened"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:260
msgid "``BUS_NOTIFY_ADD_DEVICE``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:261
msgid "device is added to this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:263
msgid "``BUS_NOTIFY_DEL_DEVICE``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:264
msgid "device is about to be removed from this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:266
msgid "``BUS_NOTIFY_REMOVED_DEVICE``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:267
msgid "device is successfully removed from this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:269
msgid "``BUS_NOTIFY_BIND_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:270
msgid "a driver is about to be bound to this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:272
msgid "``BUS_NOTIFY_BOUND_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:273
msgid "a driver is successfully bound to this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:275
msgid "``BUS_NOTIFY_UNBIND_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:276
msgid "a driver is about to be unbound from this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:278
msgid "``BUS_NOTIFY_UNBOUND_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:279
msgid "a driver is successfully unbound from this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:281
msgid "``BUS_NOTIFY_DRIVER_NOT_BOUND``"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:282
msgid "a driver failed to be bound to this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:263
msgid ""
"These are the value passed to a bus notifier when a specific event happens."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:265
msgid ""
"Note that bus notifiers are likely to be called with the device lock already "
"held by the driver core, so be careful in any notifier callback as to what "
"you do with the device structure."
msgstr ""

#: ../../../driver-api/infrastructure:11: include/linux/device/bus.h:269
msgid ""
"All bus notifiers are called with the target struct device * as an argument."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:26
msgid "device classes"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:28
msgid "Name of the class."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:28
msgid "``class_groups``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:29
msgid "Default attributes of this class."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:30
msgid "Default attributes of the devices that belong to the class."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:30
msgid "``dev_uevent``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:31
msgid ""
"Called when a device is added, removed from this class, or a few other "
"things that generate uevents to add the environment variables."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:33
msgid "``devnode``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:34
msgid "Callback to provide the devtmpfs."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:34
msgid "``class_release``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:35
msgid "Called to release this class."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:35
msgid "``dev_release``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:36
msgid "Called to release the device."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:36
msgid "``shutdown_pre``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:37
msgid "Called at shut-down time before driver shutdown."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:37
msgid "``ns_type``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:38
msgid "Callbacks so sysfs can detemine namespaces."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:38
msgid "``namespace``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:39
msgid "Namespace of the device belongs to this class."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:39
msgid "``get_ownership``"
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:40
msgid ""
"Allows class to specify uid/gid of the sysfs directories for the devices "
"belonging to the class. Usually tied to device's namespace."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:43
msgid "The default device power management operations of this class."
msgstr ""

#: ../../../driver-api/infrastructure:14: include/linux/device/class.h:43
msgid ""
"A class is a higher-level view of a device that abstracts out low-level "
"implementation details. Drivers may see a SCSI disk or an ATA disk, but, at "
"the class level, they are all simply disks. Classes allow user space to work "
"with devices based on what they do, rather than how they are connected or "
"how they work."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:24
msgid ""
"device driver probe type to try Device drivers may opt in for special "
"handling of their respective probe routines. This tells the core what to "
"expect and prefer."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:30
msgid "``PROBE_DEFAULT_STRATEGY``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:31
msgid ""
"Used by drivers that work equally well whether probed synchronously or "
"asynchronously."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:34
msgid "``PROBE_PREFER_ASYNCHRONOUS``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:35
msgid ""
"Drivers for \"slow\" devices which probing order is not essential for "
"booting the system may opt into executing their probes asynchronously."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:39
msgid "``PROBE_FORCE_SYNCHRONOUS``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:40
msgid ""
"Use this to annotate drivers that need their probe routines to run "
"synchronously with driver and device registration (with the exception of -"
"EPROBE_DEFER handling - re-probing always ends up being done asynchronously)."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:38
msgid ""
"Note that the end goal is to switch the kernel to use asynchronous probing "
"by default, so annotating drivers with ``PROBE_PREFER_ASYNCHRONOUS`` is a "
"temporary measure that allows us to speed up boot process while we are "
"validating the rest of the drivers."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:52
msgid "The basic device driver structure"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:54
msgid "Name of the device driver."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:55
msgid "The bus which the device of this driver belongs to."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:55
msgid "``owner``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:56
msgid "The module owner."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:56
msgid "``mod_name``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:57
msgid "Used for built-in modules."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:57
msgid "``suppress_bind_attrs``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:58
msgid "Disables bind/unbind via sysfs."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:58
msgid "``probe_type``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:59
msgid "Type of the probe (synchronous or asynchronous) to use."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:59
msgid "``of_match_table``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:60
msgid "The open firmware table."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:60
msgid "``acpi_match_table``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:61
msgid "The ACPI match table."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:62
msgid ""
"Called to query the existence of a specific device, whether this driver can "
"work with it, and bind the driver to a specific device."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:72
msgid ""
"Called when the device is removed from the system to unbind a device from "
"this driver."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:75
msgid "Called to put the device to sleep mode. Usually to a low power state."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:77
msgid "Called to bring a device from sleep mode."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:78
msgid "Default attributes that get created by the driver core automatically."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:80
msgid ""
"Additional attributes attached to device instance once it is bound to the "
"driver."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:82
msgid "Power management operations of the device which matched this driver."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:83
msgid "``coredump``"
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:84
msgid ""
"Called when sysfs entry is written to. The device driver is expected to call "
"the dev_coredump API resulting in a uevent."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:87
msgid ""
"Driver core's private data, no one other than the driver core can touch this."
msgstr ""

#: ../../../driver-api/infrastructure:17: include/linux/device/driver.h:88
msgid ""
"The device driver-model tracks all of the drivers known to the system. The "
"main reason for this tracking is to enable the driver core to match up "
"drivers with new devices. Once drivers are known objects within the system, "
"however, a number of other things become possible. Device drivers can export "
"information and configuration variables that are independent of any specific "
"device."
msgstr ""

#: ../../../driver-api/infrastructure.rst:21
msgid "Device Drivers Base"
msgstr ""

#: ../../../driver-api/infrastructure:23: drivers/base/init.c:16
msgid "initialize driver model."
msgstr ""

#: ../../../driver-api/infrastructure:23: drivers/base/init.c:22
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:547
#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:49
#: drivers/base/syscore.c:93 ../../../driver-api/infrastructure:56:
#: drivers/base/dd.c:772
msgid "``void``"
msgstr ""

#: ../../../driver-api/infrastructure:23: drivers/base/init.c:1
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:1
#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:1
#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1
msgid "no arguments"
msgstr ""

#: ../../../driver-api/infrastructure:23: drivers/base/init.c:17
msgid ""
"Call the driver model init functions to initialize their subsystems. Called "
"early from init/main.c."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:163
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:99
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:154
msgid "device iterator for locating a particular device of a specific name."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:169
#: include/linux/device/driver.h:181 include/linux/device/driver.h:207
#: include/linux/device/driver.h:226 ../../../driver-api/infrastructure:29:
#: drivers/base/driver.c:143 drivers/base/driver.c:181
#: drivers/base/driver.c:199 ../../../driver-api/infrastructure:56:
#: drivers/base/dd.c:1122 drivers/base/dd.c:1230
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1499
msgid "``const struct device_driver *drv``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:165
#: include/linux/device/driver.h:177 include/linux/device/driver.h:190
#: include/linux/device/driver.h:203 include/linux/device/driver.h:222
msgid "the driver we're iterating"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:166
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:102
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:158
msgid "name of the device to match"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:175
msgid "device iterator for locating a particular device by of_node pointer."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:179
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:115
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:172
msgid "``const struct device_node *np``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:178
msgid "of_node pointer to match."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:188
msgid "device iterator for locating a particular device by fwnode pointer."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:194
#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:115
#: drivers/base/driver.c:224 drivers/base/driver.c:271
msgid "``struct device_driver *drv``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:192
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:127
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:184
msgid "``const struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:191
msgid "fwnode pointer to match."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:201
msgid "device iterator for locating a particular device by devt."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:205
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4387
#: drivers/base/core.c:4422 drivers/base/core.c:4462
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:139
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:196
msgid "``dev_t devt``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:204
msgid "devt pointer to match."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:220
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:149
msgid ""
"device iterator for locating a particular device matching the ACPI_COMPANION "
"device."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:224
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:153
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:223
msgid "``const struct acpi_device *adev``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:223
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:152
msgid "ACPI_COMPANION device to match."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:246
msgid "``module_driver (__driver, __register, __unregister, ...)``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:244
msgid ""
"Helper macro for drivers that don't do anything special in module init/exit. "
"This eliminates a lot of boilerplate. Each module may only use this macro "
"once, and calling it replaces module_init() and module_exit()."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:250
#: include/linux/device/driver.h:276
msgid "``__driver``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:249
#: include/linux/device/driver.h:277
msgid "driver name"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:251
#: include/linux/device/driver.h:279
msgid "``__register``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:250
#: include/linux/device/driver.h:278
msgid "register function for this driver type"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:252
msgid "``__unregister``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:251
msgid "unregister function for this driver type"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:253
#: include/linux/device/driver.h:280 ../../../driver-api/infrastructure:32:
#: drivers/base/core.c:3486 drivers/base/core.c:4390 drivers/base/core.c:4426
#: drivers/base/core.c:5036 drivers/base/core.c:5084
msgid "``...``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:252
msgid "Additional arguments to be passed to __register and __unregister."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:253
#: include/linux/device/driver.h:280
msgid ""
"Use this macro to construct bus specific macros for registering drivers, and "
"do not use it on its own."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:272
msgid "``builtin_driver (__driver, __register, ...)``"
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:270
msgid ""
"Helper macro for drivers that don't do anything special in init and have no "
"exit. This eliminates some boilerplate. Each driver may only use this macro "
"once, and calling it replaces device_initcall (or in some cases, the legacy "
"__initcall). This is meant to be a direct parallel of module_driver() above "
"but without the __exit stuff that is not used for builtin cases."
msgstr ""

#: ../../../driver-api/infrastructure:26: include/linux/device/driver.h:279
msgid "Additional arguments to be passed to __register"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:34
msgid "Helper to set or clear driver override."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:35
msgid "Device to change"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:37
msgid "``const char **override``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:36
msgid ""
"Address of string to change (e.g. :c:type:`device->driver_override "
"<device>`); The contents will be freed and hold newly allocated override."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:39
msgid "``const char *s``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:38
msgid ""
"NUL-terminated string, new driver name to force a match, pass empty string "
"to clear it (\"\" or \"\\n\", where the latter is only for sysfs interface)."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:42
msgid "``size_t len``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:41
msgid "length of **s**"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:42
msgid ""
"Helper to set or clear driver override in a device, intended for the cases "
"when the driver_override field is allocated by driver/bus code."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:46
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1029
msgid "0 on success or a negative error code on failure."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:109
msgid "Iterator for devices bound to a driver."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:110
msgid "Driver we're iterating."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:112
#: drivers/base/driver.c:140 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:1501 ../../../driver-api/infrastructure:65:
#: include/linux/device/bus.h:158 ../../../driver-api/infrastructure:68:
#: drivers/base/bus.c:341 drivers/base/bus.c:381
msgid "``struct device *start``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:111
#: drivers/base/driver.c:139 ../../../driver-api/infrastructure:41:
#: drivers/base/class.c:436 ../../../driver-api/infrastructure:65:
#: include/linux/device/bus.h:157 ../../../driver-api/infrastructure:68:
#: drivers/base/bus.c:380
msgid "Device to begin with"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:113
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3998
#: drivers/base/core.c:4028 drivers/base/core.c:4059
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:391
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:342
#: drivers/base/bus.c:434
msgid "``void *data``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:112
msgid "Data to pass to the callback."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:114
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4000
#: drivers/base/core.c:4030 drivers/base/core.c:4061
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:392
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:343
msgid "``device_iter_t fn``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:113
msgid "Function to call for each device."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:114
msgid "Iterate over the **drv**'s list of devices calling **fn** for each one."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:137
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4090
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:378
msgid "device iterator for locating a particular device."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:138
msgid "The device's driver"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:141
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4093
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:438
#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:149
#: include/linux/platform_device.h:208 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:627 drivers/base/platform.c:968
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:382
msgid "``const void *data``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:140
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4093
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:381
msgid "Data to pass to match function"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:142
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4095
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:439
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:383
msgid "``device_match_t match``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:141
#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4092
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:382
msgid "Callback function to check device"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:142
msgid ""
"This is similar to the driver_for_each_device() function above, but it "
"returns a reference to a device that is 'found' for later use, as determined "
"by the **match** callback."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:146
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:443
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:387
msgid ""
"The callback should return 0 if the device doesn't match and non-zero if it "
"does.  If the callback returns non-zero, this function will return to the "
"caller and not iterate over any more devices."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:175
msgid "create sysfs file for driver."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:176
#: drivers/base/driver.c:194 drivers/base/driver.c:266
#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1225
msgid "driver."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:178
#: drivers/base/driver.c:196
msgid "``const struct driver_attribute *attr``"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:177
#: drivers/base/driver.c:195
msgid "driver attribute descriptor."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:193
msgid "remove sysfs file for driver."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:218
msgid "register driver with bus"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:219
msgid "driver to register"
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:220
msgid ""
"We pass off most of the work to the bus_add_driver() call, since most of the "
"things we have to do deal with the bus structures."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:265
msgid "remove driver from system."
msgstr ""

#: ../../../driver-api/infrastructure:29: drivers/base/driver.c:267
msgid "Again, we pass off most of the work to the bus-level call."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:541
msgid "Wait for ongoing devlink removal jobs to terminate"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:669
msgid "Create a link between two devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:675
msgid "``struct device *consumer``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:670
#: drivers/base/core.c:969
msgid "Consumer end of the link."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:672
#: drivers/base/core.c:971
msgid "``struct device *supplier``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:671
#: drivers/base/core.c:970
msgid "Supplier end of the link."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:673
msgid "``u32 flags``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:674
msgid ""
"On success, a device_link struct will be returned. On error or invalid flag "
"settings, NULL will be returned."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:676
msgid ""
"The caller is responsible for the proper synchronization of the link "
"creation with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will "
"cause the runtime PM framework to take the link into account.  Second, if "
"the DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices "
"will be forced into the active meta state and reference-counted upon the "
"creation of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE "
"will be ignored."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:684
msgid ""
"If DL_FLAG_STATELESS is set in **flags**, the caller of this function is "
"expected to release the link returned by it directly with the help of either "
"device_link_del() or device_link_remove()."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:688
msgid ""
"If that flag is not set, however, the caller of this function is handing the "
"management of the link over to the driver core entirely and its return value "
"can only be used to check whether or not the link is present.  In that case, "
"the DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER device link "
"flags can be used to indicate to the driver core when the link can be safely "
"deleted.  Namely, setting one of them in **flags** indicates to the driver "
"core that the link is not going to be used (by the given caller of this "
"function) after unbinding the consumer or supplier driver, respectively, "
"from its device, so the link can be deleted at that point.  If none of them "
"is set, the link will be maintained until one of the devices pointed to by "
"it (either the consumer or the supplier) is unregistered."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:700
msgid ""
"Also, if DL_FLAG_STATELESS, DL_FLAG_AUTOREMOVE_CONSUMER and "
"DL_FLAG_AUTOREMOVE_SUPPLIER are not set in **flags** (that is, a persistent "
"managed device link is being added), the DL_FLAG_AUTOPROBE_CONSUMER flag can "
"be used to request the driver core to automatically probe for a consumer "
"driver after successfully binding a driver to the supplier device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:706
msgid ""
"The combination of DL_FLAG_STATELESS and one of DL_FLAG_AUTOREMOVE_CONSUMER, "
"DL_FLAG_AUTOREMOVE_SUPPLIER, or DL_FLAG_AUTOPROBE_CONSUMER set in **flags** "
"at the same time is invalid and will cause NULL to be returned upfront. "
"However, if a device link between the given **consumer** and **supplier** "
"pair exists already when this function is called for them, the existing link "
"will be returned regardless of its current type and status (the link's flags "
"may be modified then).  The caller of this function is then expected to "
"treat the link as though it has just been created, so (in particular) if "
"DL_FLAG_STATELESS was passed in **flags**, the link needs to be released "
"explicitly when not needed any more (as stated above)."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:717
msgid ""
"A side effect of the link creation is re-ordering of dpm_list and the "
"devices_kset list by moving the consumer device and all devices depending on "
"it to the ends of these lists (that does not happen to devices that have not "
"been registered when this function is called)."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:722
msgid ""
"The supplier device is required to be registered when this function is "
"called and NULL will be returned if that is not the case.  The consumer "
"device need not be registered, however."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:951
#: drivers/base/core.c:968
msgid "Delete a stateless link between two devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:957
msgid "``struct device_link *link``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:952
msgid "Device link to delete."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:953
msgid ""
"The caller must ensure proper synchronization of this function with runtime "
"PM.  If the link was added multiple times, it needs to be deleted as often. "
"Care is required for hotplugged devices:  Their links are purged on removal "
"and calling device_link_del() is then no longer allowed."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:974
msgid "``void *consumer``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:971
msgid ""
"The caller must ensure proper synchronization of this function with runtime "
"PM."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2390
msgid "Return a device's driver name, if at all possible"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2391
msgid "struct device to get the name of"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2392
msgid ""
"Will return the device's driver's name if it is bound to a device.  If the "
"device is not bound to a driver, it will return the name of the bus it is "
"attached to.  If it is not attached to a bus either, an empty string will be "
"returned."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2862
msgid "given a device, create a managed attribute group"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2863
msgid "The device to create the group for"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2865
msgid "``const struct attribute_group *grp``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2864
msgid "The attribute group to create"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2865
msgid ""
"This function creates a group for the first time.  It will explicitly warn "
"and error if any of the attribute files being created already exist."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:2868
#: drivers/base/core.c:4722
msgid "Returns 0 on success or error code on failure."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3039
msgid "create sysfs attribute file for device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3040
#: drivers/base/core.c:3064 drivers/base/core.c:3077 drivers/base/core.c:3094
#: drivers/base/core.c:3109 drivers/base/core.c:3138 drivers/base/core.c:3546
#: drivers/base/core.c:3777 drivers/base/core.c:3821 drivers/base/core.c:4715
#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:483
#: drivers/base/dd.c:1060 drivers/base/dd.c:1304
msgid "device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3042
#: drivers/base/core.c:3066 drivers/base/core.c:3079
msgid "``const struct device_attribute *attr``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3041
#: drivers/base/core.c:3065 drivers/base/core.c:3078
msgid "device attribute descriptor."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3063
msgid "remove sysfs attribute file."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3076
msgid "remove sysfs attribute file from its own method."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3079
msgid "See kernfs_remove_self() for details."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3093
msgid "create sysfs binary attribute file for device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3096
#: drivers/base/core.c:3111
msgid "``const struct bin_attribute *attr``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3095
#: drivers/base/core.c:3110
msgid "device binary attribute descriptor."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3108
msgid "remove sysfs binary attribute file"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3137
msgid "init device structure."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3139
msgid ""
"This prepares the device for use by other layers by initializing its fields. "
"It is the first half of device_register(), if called by that function, "
"though it can also be called separately, so one may use **dev**'s fields. In "
"particular, get_device()/put_device() may be used for reference counting of "
"**dev** after calling this function."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3147
msgid ""
"All fields in **dev** must be initialized by the caller to 0, except for "
"those explicitly set to some other value.  The simplest approach is to use "
"kzalloc() to allocate the structure containing **dev**."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3153
msgid ""
"Use put_device() to give up your reference instead of freeing **dev** "
"directly once you have called this function."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3482
msgid "set a device name"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3483
msgid "device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3485
#: drivers/base/core.c:4389 drivers/base/core.c:4425 drivers/base/core.c:5035
#: drivers/base/core.c:5083
msgid "``const char *fmt``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3484
msgid "format string for the device's name"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3545
msgid "add device to device hierarchy."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3547
msgid ""
"This is part 2 of device_register(), though may be called separately _iff_ "
"device_initialize() has been called separately."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3550
msgid ""
"This adds **dev** to the kobject hierarchy via kobject_add(), adds it to the "
"global and sibling lists for the device, then adds it to the other relevant "
"subsystems of the driver model."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3554
msgid ""
"Do not call this routine or device_register() more than once for any device "
"structure.  The driver model core is not designed to work with devices that "
"get unregistered and then spring back to life. (Among other things, it's "
"very hard to guarantee that all references to the previous incarnation of "
"**dev** have been dropped.)  Allocate and register a fresh new struct device "
"instead."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3562
msgid ""
"_Never_ directly free **dev** after calling this function, even if it "
"returned an error! Always use put_device() to give up your reference instead."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3566
msgid ""
"Rule of thumb is: if device_add() succeeds, you should call device_del() "
"when you want to get rid of it. If device_add() has *not* succeeded, use "
"*only* put_device() to drop the reference count."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3751
msgid "register a device with the system."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3752
msgid "pointer to the device structure"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3753
msgid ""
"This happens in two clean steps - initialize the device and add it to the "
"system. The two steps can be called separately, but this is the easiest and "
"most common. I.e. you should only call the two helpers separately if have a "
"clearly defined need to use and refcount the device before it is added to "
"the hierarchy."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3760
msgid ""
"For more information, see the kerneldoc for device_initialize() and "
"device_add()."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3764
msgid ""
"_Never_ directly free **dev** after calling this function, even if it "
"returned an error! Always use put_device() to give up the reference "
"initialized in this function instead."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3776
msgid "increment reference count for device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3778
msgid ""
"This simply forwards the call to kobject_get(), though we do take care to "
"provide for the case that we get a NULL pointer passed in."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3790
msgid "decrement reference count."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3791
msgid "device in question."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3820
msgid "delete device from system."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3822
msgid ""
"This is the first part of the device unregistration sequence. This removes "
"the device from the lists we control from here, has it removed from the "
"other driver model subsystems it was added to in device_add(), and removes "
"it from the kobject hierarchy."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3829
msgid ""
"this should be called manually _iff_ device_add() was also called manually."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3906
msgid "unregister device from system."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3907
msgid "device going away."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3908
msgid ""
"We do this in two parts, like we do device_register(). First, we remove it "
"from all the subsystems with device_del(), then we decrement the reference "
"count via put_device(). If that is the final reference count, the device "
"will be cleaned up via device_release() above. Otherwise, the structure will "
"stick around until the final reference to the device is dropped."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3995
msgid "device child iterator."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3996
#: drivers/base/core.c:4026 drivers/base/core.c:4056
msgid "parent struct device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3998
#: drivers/base/core.c:4028 drivers/base/core.c:4059
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:341
msgid "data for the callback."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3997
#: drivers/base/core.c:4027 drivers/base/core.c:4058
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:342
msgid "function to be called for each device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:3999
#: drivers/base/core.c:4029
msgid ""
"Iterate over **parent**'s child devices, and call **fn** for each, passing "
"it **data**."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4002
#: drivers/base/core.c:4032 ../../../driver-api/infrastructure:41:
#: drivers/base/class.c:397 ../../../driver-api/infrastructure:68:
#: drivers/base/bus.c:347
msgid ""
"We check the return of **fn** each time. If it returns anything other than "
"0, we break out and return that value."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4025
#: drivers/base/core.c:4055
msgid "device child iterator in reversed order."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4058
msgid "``struct device *from``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4057
msgid "optional starting point in child list"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4060
msgid ""
"Iterate over **parent**'s child devices, starting at **from**, and call "
"**fn** for each, passing it **data**. This helper is identical to "
"device_for_each_child_reverse() when **from** is NULL."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4064
msgid ""
"**fn** is checked each iteration. If it returns anything other than 0, "
"iteration stop and that value is returned to the caller of "
"device_for_each_child_reverse_from();"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4094
msgid ""
"This is similar to the device_for_each_child() function above, but it "
"returns a reference to a device that is 'found' for later use, as determined "
"by the **match** callback."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4098
msgid ""
"The callback should return 0 if the device doesn't match and non-zero if it "
"does.  If the callback returns non-zero and a reference to the current "
"device can be obtained, this function will return to the caller and not "
"iterate over any more devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4255
msgid "allocate and register a root device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4256
msgid "root device name"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4258
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:860
#: drivers/base/platform.c:1023 ../../../driver-api/infrastructure:98:
#: drivers/uio/uio.c:978 drivers/uio/uio.c:1074
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4257
msgid "owner module of the root device, usually THIS_MODULE"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4258
msgid ""
"This function allocates a root device and registers it using "
"device_register(). In order to free the returned device, use "
"root_device_unregister()."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4262
msgid ""
"Root devices are dummy devices which allow other devices to be grouped "
"under /sys/devices. Use this function to allocate a root device and then use "
"it as the parent of any device which should appear under /sys/devices/{name}"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4267
msgid ""
"The /sys/devices/{name} directory will also contain a 'module' symlink which "
"points to the **owner** directory in sysfs."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4271
#: drivers/base/core.c:4400 drivers/base/core.c:4438
msgid ""
"Returns :c:type:`struct device <device>` pointer on success, or ERR_PTR() on "
"error."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4273
#: drivers/base/core.c:4487
msgid "**Note**"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4274
msgid "You probably want to use root_device_register()."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4317
msgid "unregister and free a root device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4318
msgid "device going away"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4319
msgid ""
"This function unregisters and cleans up a device that was created by "
"root_device_register()."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4383
#: drivers/base/core.c:4418
msgid "creates a device and registers it with sysfs"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4389
#: drivers/base/core.c:4424 drivers/base/core.c:4465
#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:105
#: include/linux/device/class.h:117 include/linux/device/class.h:129
#: include/linux/device/class.h:141 include/linux/device/class.h:155
#: ../../../driver-api/infrastructure:41: drivers/base/class.c:312
#: drivers/base/class.c:393 drivers/base/class.c:440 drivers/base/class.c:630
msgid "``const struct class *class``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4384
#: drivers/base/core.c:4419
msgid "pointer to the struct class that this device should be registered to"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4385
#: drivers/base/core.c:4420
msgid "pointer to the parent struct device of this new device, if any"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4386
#: drivers/base/core.c:4421
msgid "the dev_t for the char device to be added"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4388
#: drivers/base/core.c:4423
msgid "``void *drvdata``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4387
#: drivers/base/core.c:4422
msgid "the data to be added to the device for callbacks"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4388
#: drivers/base/core.c:4424
msgid "string for the device's name"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4389
msgid ""
"This function can be used by char device classes.  A struct device will be "
"created in sysfs, registered to the specified class."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4392
#: drivers/base/core.c:4430
msgid ""
"A \"dev\" file will be created, showing the dev_t for the device, if the "
"dev_t is not 0,0. If a pointer to a parent struct device is passed in, the "
"newly created struct device will be a child of that device in sysfs. The "
"pointer to the struct device will be returned from the call. Any further "
"sysfs files that might be required can be created using this pointer."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4424
#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:111
#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1267
#: drivers/base/bus.c:1292
msgid "``const struct attribute_group **groups``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4423
msgid "NULL-terminated list of attribute groups to be created"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4425
msgid ""
"This function can be used by char device classes.  A struct device will be "
"created in sysfs, registered to the specified class. Additional attributes "
"specified in the groups parameter will also be created automatically."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4459
msgid "removes a device that was created with device_create()"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4460
msgid "pointer to the struct class that this device was registered with"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4461
msgid "the dev_t of the device that was previously registered"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4462
msgid ""
"This call unregisters and cleans up a device that was created with a call to "
"device_create()."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4479
msgid "renames a device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4480
msgid "the pointer to the struct device to be renamed"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4482
msgid "``const char *new_name``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4481
msgid "the new name of the device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4482
msgid ""
"It is the responsibility of the caller to provide mutual exclusion between "
"two different calls of device_rename on the same device to ensure that "
"new_name is valid and won't conflict with other devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4488
msgid ""
"given that some subsystems (networking and infiniband) use this function, "
"with no immediate plans for this to change, we cannot assume or require that "
"this function not be called at all."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4492
msgid ""
"However, if you're writing new code, do not call this function. The "
"following text from Kay Sievers offers some insight:"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4495
msgid ""
"Renaming devices is racy at many levels, symlinks and other stuff are not "
"replaced atomically, and you get a \"move\" uevent, but it's not easy to "
"connect the event to the old and new device. Device nodes are not renamed at "
"all, there isn't even support for that in the kernel now."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4500
msgid ""
"In the meantime, during renaming, your target name might be taken by another "
"driver, creating conflicts. Or the old name is taken directly after you "
"renamed it -- then you get events for the same DEVPATH, before you even see "
"the \"move\" event. It's just a mess, and nothing new should ever rely on "
"kernel device renaming. Besides that, it's not even implemented now for "
"other things than (driver-core wise very simple) network devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4507
msgid ""
"Make up a \"real\" name in the driver before you register anything, or add "
"some other attributes for userspace to find the device, or use udev to add "
"symlinks -- but never rename kernel devices later, it's a complete mess. We "
"don't even want to get into that and try to implement the missing pieces in "
"the core. We really have other pieces to fix in the driver core mess. :)"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4579
msgid "moves a device to a new parent"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4580
msgid "the pointer to the struct device to be moved"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4582
msgid "``struct device *new_parent``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4581
msgid "the new parent of the device (can be NULL)"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4583
msgid "``enum dpm_order dpm_order``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4582
msgid "how to reorder the dpm_list"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4714
msgid "change the owner of an existing device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4717
msgid "``kuid_t kuid``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4716
msgid "new owner's kuid"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4718
msgid "``kgid_t kgid``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4717
msgid "new owner's kgid"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:4718
msgid ""
"This changes the owner of **dev** and its corresponding sysfs entries to "
"**kuid**/**kgid**. This function closely mirrors how **dev** was added via "
"driver core."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5031
#: drivers/base/core.c:5079
msgid "probe error check and log helper"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5032
#: drivers/base/core.c:5080
msgid "the pointer to the struct device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5034
#: drivers/base/core.c:5082
msgid "``int err``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5033
#: drivers/base/core.c:5081
msgid "error value to test"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5034
#: drivers/base/core.c:5082
msgid "printf-style format string"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5035
#: drivers/base/core.c:5083
msgid "arguments as specified in the format string"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5036
msgid ""
"This helper implements common pattern present in probe functions for error "
"checking: print debug or error message depending if the error value is -"
"EPROBE_DEFER and propagate error upwards. In case of -EPROBE_DEFER it sets "
"also defer probe reason, which can be checked later by reading "
"devices_deferred debugfs attribute. It replaces the following code sequence::"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5049
#: drivers/base/core.c:5097
msgid "with::"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5053
msgid ""
"Using this helper in your probe function is totally fine even if **err** is "
"known to never be -EPROBE_DEFER. The benefit compared to a normal dev_err() "
"is the standardized format of the error code, which is emitted symbolically "
"(i.e. you get \"EAGAIN\" instead of \"-35\"), and having the error code "
"returned allows more compact error paths."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5060
#: drivers/base/core.c:5108
msgid "Returns **err**."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5084
msgid ""
"This helper implements common pattern present in probe functions for error "
"checking: print debug or warning message depending if the error value is -"
"EPROBE_DEFER and propagate error upwards. In case of -EPROBE_DEFER it sets "
"also defer probe reason, which can be checked later by reading "
"devices_deferred debugfs attribute. It replaces the following code sequence::"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5101
msgid ""
"Using this helper in your probe function is totally fine even if **err** is "
"known to never be -EPROBE_DEFER. The benefit compared to a normal dev_warn() "
"is the standardized format of the error code, which is emitted symbolically "
"(i.e. you get \"EAGAIN\" instead of \"-35\"), and having the error code "
"returned allows more compact error paths."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5132
msgid "Change the primary firmware node of a given device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5133
#: drivers/base/core.c:5178
msgid "Device to handle."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5135
#: drivers/base/core.c:5180
msgid "``struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5134
msgid "New primary firmware node of the device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5135
msgid ""
"Set the device's firmware node pointer to **fwnode**, but if a secondary "
"firmware node of the device is present, preserve it."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5138
msgid "Valid fwnode cases are:"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5139
msgid "primary --> secondary --> -ENODEV"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5140
msgid "primary --> NULL"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5141
msgid "secondary --> -ENODEV"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5142
msgid "NULL"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5177
msgid "Change the secondary firmware node of a given device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5179
msgid "New secondary firmware node of the device."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5180
msgid ""
"If a primary firmware node of the device is present, set its secondary "
"pointer to **fwnode**.  Otherwise, set the device's firmware node pointer to "
"**fwnode**."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5198
msgid "Remove an of_node from a device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5199
msgid "device whose device tree node is being removed"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5222
msgid "Add an of_node to an existing device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5223
msgid "device whose device tree node is being added"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5225
msgid "``struct device_node *of_node``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5224
msgid "of_node to add"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5226
msgid "0 on success or error code on failure."
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5259
msgid "reuse device-tree node of another device"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5260
msgid "device whose device-tree node is being set"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5262
msgid "``const struct device *dev2``"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5261
msgid "device whose device-tree node is being reused"
msgstr ""

#: ../../../driver-api/infrastructure:32: drivers/base/core.c:5262
msgid ""
"Takes another reference to the new device-tree node after first dropping any "
"reference held to the old node."
msgstr ""

#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:18
msgid "Register a set of system core operations."
msgstr ""

#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:24
#: drivers/base/syscore.c:36
msgid "``struct syscore_ops *ops``"
msgstr ""

#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:19
msgid "System core operations to register."
msgstr ""

#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:30
msgid "Unregister a set of system core operations."
msgstr ""

#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:31
msgid "System core operations to unregister."
msgstr ""

#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:43
msgid "Execute all the registered system core suspend callbacks."
msgstr ""

#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:44
#: drivers/base/syscore.c:88
msgid "This function is executed with one CPU on-line and disabled interrupts."
msgstr ""

#: ../../../driver-api/infrastructure:35: drivers/base/syscore.c:87
msgid "Execute all the registered system core resume callbacks."
msgstr ""

#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:101
#: include/linux/device/class.h:113 include/linux/device/class.h:125
#: include/linux/device/class.h:137 include/linux/device/class.h:151
msgid "class type"
msgstr ""

#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:111
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:168
msgid "device iterator for locating a particular device matching the of_node."
msgstr ""

#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:114
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:171
msgid "of_node of the device to match."
msgstr ""

#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:123
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:180
msgid "device iterator for locating a particular device matching the fwnode."
msgstr ""

#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:126
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:183
msgid "fwnode of the device to match."
msgstr ""

#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:135
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:192
msgid ""
"device iterator for locating a particular device matching the device type."
msgstr ""

#: ../../../driver-api/infrastructure:38: include/linux/device/class.h:138
#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:195
msgid "device type of the device to match."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:255
msgid "create a struct class structure"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:256
msgid "pointer to a string for the name of this class."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:257
msgid ""
"This is used to create a struct class pointer that can then be used in calls "
"to device_create()."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:260
msgid ""
"Returns :c:type:`struct class <class>` pointer on success, or ERR_PTR() on "
"error."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:262
msgid ""
"Note, the pointer created here is to be destroyed when finished by making a "
"call to class_destroy()."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:293
msgid "destroys a struct class structure"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:299
msgid "``const struct class *cls``"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:294
msgid "pointer to the struct class that is to be destroyed"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:295
msgid ""
"Note, the pointer to be destroyed must have been created with a call to "
"class_create()."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:309
msgid "initialize class device iterator"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:315
#: drivers/base/class.c:348 drivers/base/class.c:379
msgid "``struct class_dev_iter *iter``"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:310
msgid "class iterator to initialize"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:311
msgid "the class we wanna iterate over"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:313
#: drivers/base/class.c:390 drivers/base/class.c:437
msgid "``const struct device *start``"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:312
msgid "the device to start iterating from, if any"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:314
msgid "``const struct device_type *type``"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:313
msgid "device_type of the devices to iterate over, NULL for all"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:314
msgid ""
"Initialize class iterator **iter** such that it iterates over devices of "
"**class**.  If **start** is set, the list iteration will start there, "
"otherwise if it is NULL, the iteration starts at the beginning of the list."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:342
msgid "iterate to the next device"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:343
msgid "class iterator to proceed"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:344
msgid ""
"Proceed **iter** to the next device and return it.  Returns NULL if "
"iteration is complete."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:347
msgid ""
"The returned device is referenced and won't be released till iterator is "
"proceed to the next device or exited.  The caller is free to do whatever it "
"wants to do with the device including calling back into class code."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:373
msgid "finish iteration"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:374
msgid "class iterator to finish"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:375
msgid ""
"Finish an iteration.  Always call this function after iteration is complete "
"whether the iteration ran till the end or not."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:387
msgid "device iterator"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:388
#: drivers/base/class.c:435
msgid "the class we're iterating"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:389
msgid "the device to start with in the list, if any."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:390
msgid "data for the callback"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:391
msgid "function to be called for each device"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:392
msgid ""
"Iterate over **class**'s list of devices, and call **fn** for each, passing "
"it **data**.  If **start** is set, the list iteration will start there, "
"otherwise if it is NULL, the iteration starts at the beginning of the list."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:400
msgid ""
"**fn** is allowed to do anything including calling back into class code.  "
"There's no locking restriction."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:434
msgid "device iterator for locating a particular device"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:437
msgid "data for the match function"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:438
msgid "function to check device"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:439
msgid ""
"This is similar to the class_for_each_dev() function above, but it returns a "
"reference to a device that is 'found' for later use, as determined by the "
"**match** callback."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:447
msgid "Note, you will need to drop the reference with put_device() after use."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:449
msgid ""
"**match** is allowed to do anything including calling back into class code.  "
"There's no locking restriction."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:566
msgid "register a compatibility class"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:567
msgid "the name of the class"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:568
msgid ""
"Compatibility class are meant as a temporary user-space compatibility "
"workaround when converting a family of class devices to a bus devices."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:589
msgid "unregister a compatibility class"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:595
#: drivers/base/class.c:606 drivers/base/class.c:618
msgid "``struct class_compat *cls``"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:590
msgid "the class to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:600
msgid "create a compatibility class device link to a bus device"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:602
#: drivers/base/class.c:614
msgid "the compatibility class"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:603
#: drivers/base/class.c:615
msgid "the target bus device"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:612
msgid "remove a compatibility class device link to a bus device"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:624
msgid ""
"determine if at this moment in time, a class is registered in the driver "
"core or not."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:626
msgid "the class to check"
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:627
msgid ""
"Returns a boolean to state if the class is registered in the driver core or "
"not.  Note that the value could switch right after this call is made, so "
"only use this in places where you \"know\" it is safe to do so (usually to "
"determine if the specific class has been registered yet or not)."
msgstr ""

#: ../../../driver-api/infrastructure:41: drivers/base/class.c:632
msgid "Be careful in using this."
msgstr ""

#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:20
msgid "a \"faux\" device"
msgstr ""

#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:22
msgid "internal struct device of the object"
msgstr ""

#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:22
msgid ""
"A simple faux device that can be created/destroyed.  To be used when a "
"driver only needs to have a device to \"hang\" something off.  This can be "
"used for downloading firmware or other basic tasks.  Use this instead of a "
"struct platform_device if the device has no resources assigned to it at all."
msgstr ""

#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:35
msgid "a set of callbacks for a struct faux_device"
msgstr ""

#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:37
msgid ""
"called when a faux device is probed by the driver core before the device is "
"fully bound to the internal faux bus code.  If probe succeeds, return 0, "
"otherwise return a negative error number to stop the probe sequence from "
"succeeding."
msgstr ""

#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:42
msgid "called when a faux device is removed from the system"
msgstr ""

#: ../../../driver-api/infrastructure:44: include/linux/device/faux.h:42
msgid "Both **probe** and **remove** are optional, if not needed, set to NULL."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:100
msgid ""
"Create and register with the driver core a faux device and populate the "
"device with an initial set of sysfs attributes."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:103
#: drivers/base/faux.c:184
msgid ""
"The name of the device we are adding, must be unique for all faux devices."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:105
#: drivers/base/faux.c:186
msgid ""
"Pointer to a potential parent struct device.  If set to NULL, the device "
"will be created in the \"root\" of the faux device tree in sysfs."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:109
#: drivers/base/faux.c:190
msgid "``const struct faux_device_ops *faux_ops``"
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:108
#: drivers/base/faux.c:189
msgid ""
"struct faux_device_ops that the new device will call back into, can be NULL."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:110
msgid ""
"The set of sysfs attributes that will be created for this device when it is "
"registered with the driver core."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:112
#: drivers/base/faux.c:191
msgid ""
"Create a new faux device and register it in the driver core properly. If "
"present, callbacks in **faux_ops** will be called with the device that for "
"the caller to do something with at the proper time given the device's "
"lifecycle."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:117
msgid ""
"Note, when this function is called, the functions specified in struct "
"faux_ops can be called before the function returns, so be prepared for "
"everything to be properly initialized before that point in time.  If the "
"probe callback (if one is present) does NOT succeed, the creation of the "
"device will fail and NULL will be returned."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:124
#: drivers/base/faux.c:201
msgid "NULL if an error happened with creating the device"
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:125
#: drivers/base/faux.c:202
msgid "pointer to a valid struct faux_device that is registered with sysfs"
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:183
msgid "create and register with the driver core a faux device"
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:196
msgid ""
"Note, when this function is called, the functions specified in struct "
"faux_ops can be called before the function returns, so be prepared for "
"everything to be properly initialized before that point in time."
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:214
msgid "destroy a faux device"
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:220
msgid "``struct faux_device *faux_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:215
msgid "faux device to destroy"
msgstr ""

#: ../../../driver-api/infrastructure:47: drivers/base/faux.c:216
msgid ""
"Unregisters and cleans up a device that was created with a call to "
"faux_device_create()"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:74
msgid "Access class device to hold user visible relationships to other nodes."
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:77
msgid "Device for this memory access class"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:77
msgid "``list_node``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:78
msgid "List element in the node's access list"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:78
msgid "``access``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:79
msgid "The access class rank"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:79
msgid "``coord``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:80
msgid "Heterogeneous memory performance coordinates"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:252
msgid "Internal tracking for memory node caches"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:254
msgid "Device represeting the cache level"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:255
msgid "List element for tracking in the node"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:255
msgid "``cache_attrs``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:256
msgid "Attributes for this cache level"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:326
msgid "add cache attribute to a memory node"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:332
msgid "``unsigned int nid``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:327
msgid "Node identifier that has new cache attributes"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:329
msgid "``struct node_cache_attrs *cache_attrs``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:328
msgid "Attributes for the cache being added"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:669
msgid "unregister a node device"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:675
msgid "``struct node *node``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:670
msgid "node going away"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:671
msgid ""
"Unregisters a node device **node**.  All the devices on the node must be "
"unregistered before calling this function."
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:714
msgid "link memory node to its compute node for a given access class."
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:720
msgid "``unsigned int mem_nid``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:716
msgid "Memory node number"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:718
msgid "``unsigned int cpu_nid``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:717
msgid "Cpu  node number"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:719
msgid "``enum access_coordinate_class access``"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:718
msgid "Access class to register"
msgstr ""

#: ../../../driver-api/infrastructure:50: drivers/base/node.c:720
msgid ""
"For use with platforms that may have separate memory and compute nodes. This "
"function will export node relationships linking which memory initiator nodes "
"can access memory targets at a given ranked access class."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:38
msgid "register an initial transport class"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:44
#: drivers/base/transport_class.c:64
msgid "``struct transport_class *tclass``"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:40
msgid "a pointer to the transport class structure to be initialised"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:41
msgid ""
"The transport class contains an embedded class which is used to identify "
"it.  The caller should initialise this structure with zeros and then generic "
"class must have been initialised with the actual transport class unique "
"name.  There's a macro DECLARE_TRANSPORT_CLASS() to do this (declared "
"classes still must be registered)."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:48
msgid "Returns 0 on success or error on failure."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:58
msgid "unregister a previously registered class"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:60
msgid "The transport class to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:61
msgid ""
"Must be called prior to deallocating the memory for the transport class."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:80
msgid "register an anonymous class"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:86
#: drivers/base/transport_class.c:112
msgid "``struct anon_transport_class *atc``"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:82
msgid "The anon transport class to register"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:83
msgid ""
"The anonymous transport class contains both a transport class and a "
"container.  The idea of an anonymous class is that it never actually has any "
"device attributes associated with it (and thus saves on container storage).  "
"So it can only be used for triggering events.  Use prezero and then use "
"DECLARE_ANON_TRANSPORT_CLASS() to initialise the anon transport class "
"storage."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:106
msgid "unregister an anon class"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:108
msgid "Pointer to the anon transport class to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:109
msgid ""
"Must be called prior to deallocating the memory for the anon transport class."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:134
msgid ""
"declare a new dev for transport class association but don't make it visible "
"yet."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:135
#: drivers/base/transport_class.c:187
msgid "the generic device representing the entity being added"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:136
msgid ""
"Usually, dev represents some component in the HBA system (either the HBA "
"itself or a device remote across the HBA bus).  This routine is simply a "
"trigger point to see if any set of transport classes wishes to associate "
"with the added device.  This allocates storage for the class device and "
"initialises it, but does not yet add it to the system or add attributes to "
"it (you do this with transport_add_device).  If you have no need for a "
"separate setup and add operations, use transport_register_device (see "
"transport_class.h)."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:185
msgid "declare a new dev for transport class association"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:188
msgid ""
"Usually, dev represents some component in the HBA system (either the HBA "
"itself or a device remote across the HBA bus).  This routine is simply a "
"trigger point used to add the device to the system and register attributes "
"for it."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:216
msgid "configure an already set up device"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:218
msgid "generic device representing device to be configured"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:219
msgid ""
"The idea of configure is simply to provide a point within the setup process "
"to allow the transport class to extract information from a device after it "
"has been setup.  This is used in SCSI because we have to have a setup device "
"to begin using the HBA, but after we send the initial inquiry, we use "
"configure to extract the device parameters.  The device need not have been "
"added to be configured."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:255
msgid "remove the visibility of a device"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:257
msgid "generic device to remove"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:258
msgid ""
"This call removes the visibility of the device (to the user from sysfs), but "
"does not destroy it.  To eliminate a device entirely you must also call "
"transport_destroy_device.  If you don't need to do remove and destroy as "
"separate operations, use transport_unregister_device() (see transport_class."
"h) which will perform both calls for you."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:284
msgid "destroy a removed device"
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:286
msgid "device to eliminate from the transport class."
msgstr ""

#: ../../../driver-api/infrastructure:53: drivers/base/transport_class.c:287
msgid ""
"This call triggers the elimination of storage associated with the transport "
"classdev.  Note: all it really does is relinquish a reference to the "
"classdev.  The memory will not be freed until the last reference goes to "
"zero.  Note also that the classdev retains a reference count on dev, so dev "
"too will remain for as long as the transport class device remains around."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:277
msgid "Check deferred probe state"
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:278
#: drivers/base/dd.c:386 ../../../driver-api/infrastructure:74:
#: kernel/dma/mapping.c:448 kernel/dma/mapping.c:537 kernel/dma/mapping.c:946
msgid "device to check"
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:280
msgid "-ENODEV if initcalls have completed and modules are disabled."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:281
msgid ""
"-ETIMEDOUT if the deferred probe timeout was set and has expired and modules "
"are enabled."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:283
msgid "-EPROBE_DEFER in other cases."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:285
msgid ""
"Drivers or subsystems can opt-in to calling this function instead of "
"directly returning -EPROBE_DEFER."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:385
msgid "Check if device is bound to a driver"
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:387
msgid ""
"Returns true if passed device has already finished probing successfully "
"against a driver."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:390
#: drivers/base/dd.c:491
msgid "This function must be called with the device lock held."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:482
msgid "bind a driver to one device."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:484
msgid ""
"Allow manual attachment of a driver to a device. Caller must have already "
"set **dev->driver**."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:487
msgid ""
"Note that this does not modify the bus reference count. Please verify that "
"is accounted for before calling this. (It is ok to call with no other effort "
"from a driver's probe() method.)"
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:493
msgid "Callers should prefer to use device_driver_attach() instead."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:767
msgid "Wait for device probing to be completed."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1059
msgid "try to attach device to a driver."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1061
msgid ""
"Walk the list of drivers that the bus has and call driver_probe_device() for "
"each pair. If a compatible pair is found, break out and return."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1065
msgid ""
"Returns 1 if the device was bound to a driver; 0 if no matching driver was "
"found; -ENODEV if the device is not registered."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1069
msgid "When called for a USB interface, **dev->parent** lock must be held."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1116
msgid "attach a specific driver to a specific device"
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1117
msgid "Driver to attach"
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1118
msgid "Device to attach it to"
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1119
msgid ""
"Manually attach driver to a device. Will acquire both **dev** lock and **dev-"
">parent** lock if needed. Returns 0 on success, -ERR on failure."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1224
msgid "try to bind driver to devices."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1226
msgid ""
"Walk the list of devices that the bus has on it and try to match the driver "
"with each one.  If driver_probe_device() returns 0 and the **dev->driver** "
"is set, we've found a compatible pair."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1303
msgid "manually detach device from driver."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1305
msgid ""
"Manually detach device from driver. When called for a USB interface, **dev-"
">parent** lock must be held."
msgstr ""

#: ../../../driver-api/infrastructure:56: drivers/base/dd.c:1308
msgid ""
"If this function is to be called with **dev->parent** lock held, ensure that "
"the device's consumers are unbound in advance or that their locks can be "
"acquired under the **dev->parent** lock."
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:140
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:799
msgid "add a platform-level device with resources and platform-specific data"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:143
#: include/linux/platform_device.h:204
msgid "parent device for the device we're adding"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:144
#: include/linux/platform_device.h:174 include/linux/platform_device.h:205
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:571
msgid "base name of the device we're adding"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:146
#: include/linux/platform_device.h:176 include/linux/platform_device.h:207
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:573
msgid "``int id``"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:145
#: include/linux/platform_device.h:175 include/linux/platform_device.h:206
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:572
msgid "instance id"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:147
#: include/linux/platform_device.h:177 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:599
msgid "``const struct resource *res``"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:146
#: include/linux/platform_device.h:176 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:598 drivers/base/platform.c:965
msgid "set of resources that needs to be allocated for the device"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:148
#: include/linux/platform_device.h:178 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:52 drivers/base/platform.c:157
#: drivers/base/platform.c:247 drivers/base/platform.c:600
msgid "``unsigned int num``"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:147
#: include/linux/platform_device.h:177 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:599 drivers/base/platform.c:966
msgid "number of resources"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:148
#: include/linux/platform_device.h:207 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:626 drivers/base/platform.c:967
msgid "platform specific data for this platform device"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:150
#: include/linux/platform_device.h:209 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:628 drivers/base/platform.c:969
#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:64
#: kernel/dma/mapping.c:83 kernel/dma/mapping.c:561
msgid "``size_t size``"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:149
#: include/linux/platform_device.h:208 ../../../driver-api/infrastructure:62:
#: drivers/base/platform.c:627 drivers/base/platform.c:968
msgid "size of platform specific data"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:150
#: include/linux/platform_device.h:191 include/linux/platform_device.h:215
#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:803
#: drivers/base/platform.c:973
msgid ""
"Returns :c:type:`struct platform_device <platform_device>` pointer on "
"success, or ERR_PTR() on error."
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:173
msgid "add a platform-level device and its resources"
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:178
#: include/linux/platform_device.h:209
msgid ""
"This function creates a simple platform device that requires minimal "
"resource and memory management. Canned release function freeing memory "
"allocated for the device allows drivers using such devices to be unloaded "
"without waiting for the last reference to the device to be dropped."
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:184
msgid ""
"This interface is primarily intended for use with legacy drivers which probe "
"hardware directly.  Because such drivers create sysfs device nodes "
"themselves, rather than letting system infrastructure handle such device "
"enumeration tasks, they don't fully conform to the Linux driver model. In "
"particular, when such drivers are built as modules, they can't be "
"\"hotplugged\"."
msgstr ""

#: ../../../driver-api/infrastructure:59: include/linux/platform_device.h:203
msgid "add a platform-level device with platform-specific data"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:48
msgid "get a resource for a device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:54
#: drivers/base/platform.c:160 drivers/base/platform.c:250
#: drivers/base/platform.c:280 drivers/base/platform.c:328
#: drivers/base/platform.c:421 drivers/base/platform.c:466
#: drivers/base/platform.c:487
msgid "``struct platform_device *dev``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:49
#: drivers/base/platform.c:155 drivers/base/platform.c:245
#: drivers/base/platform.c:275 drivers/base/platform.c:416
#: drivers/base/platform.c:461 drivers/base/platform.c:482
msgid "platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:51
#: drivers/base/platform.c:418
msgid "``unsigned int type``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:50
#: drivers/base/platform.c:417
msgid "resource type"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:51
#: drivers/base/platform.c:92 drivers/base/platform.c:117
msgid "resource index"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:53
msgid "a pointer to the resource or NULL on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:87
msgid "call devm_ioremap_resource() for a platform device and get resource"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:93
#: drivers/base/platform.c:118 drivers/base/platform.c:136
#: drivers/base/platform.c:549 drivers/base/platform.c:602
#: drivers/base/platform.c:630 drivers/base/platform.c:657
#: drivers/base/platform.c:745 drivers/base/platform.c:774
#: drivers/base/platform.c:790
msgid "``struct platform_device *pdev``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:90
#: drivers/base/platform.c:115 drivers/base/platform.c:134
msgid ""
"platform device to use both for memory resource lookup as well as resource "
"management"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:93
#: drivers/base/platform.c:118
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:94
msgid "``struct resource **res``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:93
msgid "optional output parameter to store a pointer to the obtained resource."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:95
#: drivers/base/platform.c:119 drivers/base/platform.c:138
msgid ""
"a pointer to the remapped memory or an ERR_PTR() encoded error code on "
"failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:112
msgid "call devm_ioremap_resource() for a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:130
msgid ""
"call devm_ioremap_resource for a platform device, retrieve the resource by "
"name"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:136
msgid "name of the resource"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:154
msgid "get an optional IRQ for a device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:156
#: drivers/base/platform.c:246
msgid "IRQ number index"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:157
msgid ""
"Gets an IRQ for a platform device. Device drivers should check the return "
"value for errors so as to not pass a negative integer value to the "
"request_irq() APIs. This is the same as platform_get_irq(), except that it "
"does not print an error message if an IRQ can not be obtained."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:162
#: drivers/base/platform.c:251
msgid "For example::"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:169
#: drivers/base/platform.c:258 drivers/base/platform.c:466
#: drivers/base/platform.c:488
msgid "non-zero IRQ number on success, negative error number on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:244
msgid "get an IRQ for a device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:247
msgid ""
"Gets an IRQ for a platform device and prints an error message if finding the "
"IRQ fails. Device drivers should check the return value for errors so as to "
"not pass a negative integer value to the request_irq() APIs."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:274
msgid "Count the number of IRQs a platform device uses"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:277
msgid "Number of IRQs a platform device uses or EPROBE_DEFER"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:322
msgid ""
"devm method to get a set of IRQs for a device using an interrupt affinity "
"descriptor"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:324
msgid "platform device pointer"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:326
msgid "``struct irq_affinity *affd``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:325
msgid "affinity descriptor"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:327
msgid "``unsigned int minvec``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:326
msgid "minimum count of interrupt vectors"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:328
msgid "``unsigned int maxvec``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:327
msgid "maximum count of interrupt vectors"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:329
msgid "``int **irqs``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:328
msgid "pointer holder for IRQ numbers"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:329
msgid ""
"Gets a set of IRQs for a platform device, and updates IRQ afffinty according "
"to the passed affinity descriptor"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:333
msgid "Number of vectors on success, negative error number on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:415
msgid "get a resource for a device by name"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:418
msgid "resource name"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:460
msgid "get an IRQ for a device by name"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:462
#: drivers/base/platform.c:483
msgid "IRQ name"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:463
msgid ""
"Get an IRQ like platform_get_irq(), but then by name rather then by index."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:481
msgid "get an optional IRQ for a device by name"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:484
msgid ""
"Get an optional IRQ by name like platform_get_irq_byname(). Except that it "
"does not print an error message if an IRQ can not be obtained."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:498
msgid "add a numbers of platform devices"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:504
msgid "``struct platform_device **devs``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:499
msgid "array of platform devices to add"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:501
msgid "``int num``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:500
msgid "number of platform devices in array"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:502
msgid "0 on success, negative error number on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:543
msgid "destroy a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:544
msgid "platform device to free"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:545
msgid ""
"Free all memory associated with a platform device.  This function must "
"_only_ be externally called in error cases.  All other usage is a bug."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:570
msgid "create a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:573
msgid ""
"Create a platform device object which can have other objects attached to it, "
"and which will have attached objects freed when it is released."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:596
msgid "add resources to a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:597
#: drivers/base/platform.c:625
msgid "platform device allocated by platform_device_alloc to add resources to"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:600
msgid ""
"Add a copy of the resources to the platform device.  The memory associated "
"with the resources will be freed when the platform device is released."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:624
msgid "add platform-specific data to a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:628
msgid ""
"Add a copy of platform specific data to the platform device's platform_data "
"pointer.  The memory associated with the platform data will be freed when "
"the platform device is released."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:651
msgid "add a platform device to device hierarchy"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:652
#: drivers/base/platform.c:769
msgid "platform device we're adding"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:653
msgid ""
"This is part 2 of platform_device_register(), though may be called "
"separately _iff_ pdev was allocated by platform_device_alloc()."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:739
msgid "remove a platform-level device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:740
msgid "platform device we're removing"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:741
msgid ""
"Note that this function will also release all memory- and port-based "
"resources owned by the device (**dev->resource**).  This function must "
"_only_ be externally called in error cases.  All other usage is a bug."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:768
msgid "add a platform-level device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:771
msgid ""
"_Never_ directly free **pdev** after calling this function, even if it "
"returned an error! Always use platform_device_put() to give up the reference "
"initialised in this function instead."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:784
msgid "unregister a platform-level device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:785
msgid "platform device we're unregistering"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:786
msgid ""
"Unregistration is done in 2 steps. First we release all resources and remove "
"it from the subsystem, then we drop reference count by calling "
"platform_device_put()."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:805
msgid "``const struct platform_device_info *pdevinfo``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:802
msgid "data used to create device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:857
msgid "register a driver for platform-level devices"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:863
#: drivers/base/platform.c:878 drivers/base/platform.c:900
msgid "``struct platform_driver *drv``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:858
#: drivers/base/platform.c:873 drivers/base/platform.c:895
#: drivers/base/platform.c:963
msgid "platform driver structure"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:859
msgid "owning module/driver"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:872
msgid "unregister a driver for platform-level devices"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:894
msgid "register driver for non-hotpluggable device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:897
#: drivers/base/platform.c:965
msgid "``int (*probe)(struct platform_device *)``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:896
#: drivers/base/platform.c:964
msgid "the driver probe routine, probably from an __init section"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:898
#: drivers/base/platform.c:970
msgid "``struct module *module``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:897
#: drivers/base/platform.c:969
msgid "module which will be the owner of the driver"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:898
msgid ""
"Use this instead of platform_driver_register() when you know the device is "
"not hotpluggable and has already been registered, and you want to remove its "
"run-once probe() infrastructure from memory after the driver has bound to "
"the device."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:903
msgid ""
"One typical use for this would be with drivers for controllers integrated "
"into system-on-chip processors, where the controller devices have been "
"configured as part of board setup."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:907
msgid "Note that this is incompatible with deferred probing."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:909
msgid ""
"Returns zero if the driver registered and bound to a device, else returns a "
"negative error code and with the driver not registered."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:962
msgid "register driver and create corresponding device"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:968
msgid "``struct platform_driver *driver``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:966
msgid "``struct resource *res``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:967
msgid "``unsigned int n_res``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:970
msgid ""
"Use this in legacy-style modules that probe hardware directly and register a "
"single platform device and corresponding platform driver."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1019
msgid "register an array of platform drivers"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1025
#: drivers/base/platform.c:1067
msgid "``struct platform_driver * const *drivers``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1020
msgid "an array of drivers to register"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1022
#: drivers/base/platform.c:1064
msgid "``unsigned int count``"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1021
msgid "the number of drivers to register"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1022
msgid "module owning the drivers"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1023
msgid ""
"Registers platform drivers specified by an array. On failure to register a "
"driver, all previously registered drivers will be unregistered. Callers of "
"this API should use platform_unregister_drivers() to unregister drivers in "
"the reverse order."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1061
msgid "unregister an array of platform drivers"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1062
msgid "an array of drivers to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1063
msgid "the number of drivers to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1064
msgid ""
"Unregisters platform drivers specified by an array. This is typically used "
"to complement an earlier call to platform_register_drivers(). Drivers are "
"unregistered in the reverse order in which they were registered."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1495
msgid "Find a platform device with a given driver."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1497
msgid "The device to start the search from."
msgstr ""

#: ../../../driver-api/infrastructure:62: drivers/base/platform.c:1498
msgid "The device driver to look for."
msgstr ""

#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:160
#: include/linux/device/bus.h:174 include/linux/device/bus.h:186
#: include/linux/device/bus.h:198 include/linux/device/bus.h:210
#: include/linux/device/bus.h:225 ../../../driver-api/infrastructure:68:
#: drivers/base/bus.c:344 drivers/base/bus.c:384 drivers/base/bus.c:436
#: drivers/base/bus.c:783 drivers/base/bus.c:855 drivers/base/bus.c:943
#: drivers/base/bus.c:1316 drivers/base/bus.c:1369
msgid "``const struct bus_type *bus``"
msgstr ""

#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:156
#: include/linux/device/bus.h:170 include/linux/device/bus.h:182
#: include/linux/device/bus.h:194 include/linux/device/bus.h:206
#: include/linux/device/bus.h:221 ../../../driver-api/infrastructure:68:
#: drivers/base/bus.c:379
msgid "bus type"
msgstr ""

#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:204
msgid "Find the next device after a given device in a given bus."
msgstr ""

#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:208
msgid "``struct device *cur``"
msgstr ""

#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:207
msgid "device to begin the search with."
msgstr ""

#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:219
msgid ""
"device iterator for locating a particular device matching the ACPI COMPANION "
"device."
msgstr ""

#: ../../../driver-api/infrastructure:65: include/linux/device/bus.h:222
msgid "ACPI COMPANION device to match."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:338
msgid "device iterator."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:339
msgid "bus type."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:340
msgid "device to start iterating from."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:343
msgid ""
"Iterate over **bus**'s list of devices, and call **fn** for each, passing it "
"**data**. If **start** is not NULL, we use that device to begin iterating "
"from."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:351
msgid ""
"The device that returns a non-zero value is not retained in any way, nor is "
"its refcount incremented. If the caller needs to retain this data, it should "
"do so, and increment the reference count in the supplied callback."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:383
msgid ""
"This is similar to the bus_for_each_dev() function above, but it returns a "
"reference to a device that is 'found' for later use, as determined by the "
"**match** callback."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:430
msgid "driver iterator"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:431
msgid "bus we're dealing with."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:433
msgid "``struct device_driver *start``"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:432
msgid "driver to start iterating on."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:433
msgid "data to pass to the callback."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:435
msgid "``int (*fn)(struct device_driver *, void *)``"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:434
msgid "function to call for each driver."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:435
msgid ""
"This is nearly identical to the device iterator above. We iterate over each "
"driver that belongs to **bus**, and call **fn** for each. If **fn** returns "
"anything but 0, we break out and return it. If **start** is not NULL, we use "
"it as the head of the list."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:442
msgid ""
"we don't return the driver that returns a non-zero value, nor do we leave "
"the reference count incremented for that driver. If the caller needs to know "
"that info, it must set it in the callback. It must also be sure to increment "
"the refcount so it doesn't disappear before returning to the caller."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:777
msgid "rescan devices on the bus for possible drivers"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:778
msgid "the bus to scan."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:779
msgid ""
"This function will look for devices on the bus with no driver attached and "
"rescan it against existing drivers to see if it matches any by calling "
"device_attach() for the unbound devices."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:791
msgid "remove driver for a device and probe for a new driver"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:792
msgid "the device to reprobe"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:793
msgid ""
"This function detaches the attached driver (if any) for the given device and "
"restarts the driver probing process.  It is intended to use if probing "
"criteria changed during a devices lifetime and driver attachment should "
"change accordingly."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:849
msgid "register a driver-core subsystem"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:850
msgid "bus to register"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:851
msgid ""
"Once we have that, we register the bus with the kobject infrastructure, then "
"register the children subsystems it has: the devices and drivers that belong "
"to the subsystem."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:937
msgid "remove a bus from the system"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:938
msgid "bus."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:939
msgid ""
"Unregister the child subsystems and the bus itself. Finally, we call "
"bus_put() to release the refcount"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1264
msgid "register a subsystem at /sys/devices/system/"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1270
#: drivers/base/bus.c:1295
msgid "``const struct bus_type *subsys``"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1265
msgid "system subsystem"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1266
#: drivers/base/bus.c:1291
msgid "default attributes for the root device"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1267
msgid ""
"All 'system' subsystems have a /sys/devices/system/<name> root device with "
"the name of the subsystem. The root device can carry subsystem- wide "
"attributes. All registered devices are below this single root device and are "
"named after the subsystem with a simple enumeration number appended. The "
"registered devices are not explicitly named; only 'id' in the device needs "
"to be set."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1274
msgid ""
"Do not use this interface for anything new, it exists for compatibility with "
"bad ideas only. New subsystems should use plain subsystems; and add the "
"subsystem-wide attributes should be added to the subsystem directory itself "
"and not some create fake root-device placed in /sys/devices/system/<name>."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1289
msgid "register a subsystem at /sys/devices/virtual/"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1290
msgid "virtual subsystem"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1292
msgid ""
"All 'virtual' subsystems have a /sys/devices/system/<name> root device with "
"the name of the subsystem.  The root device can carry subsystem-wide "
"attributes.  All registered devices are below this single root device. "
"There's no restriction on device naming.  This is for kernel software "
"constructs which need sysfs interface."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1313
msgid "locate driver on a bus by its name."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1314
msgid "name of the driver."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1315
msgid "bus to scan for the driver."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1316
msgid ""
"Call kset_find_obj() to iterate over list of drivers on a bus to find driver "
"by name. Return driver if found."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1319
msgid ""
"This routine provides no locking to prevent the driver it returns from being "
"unregistered or unloaded while the caller is using it. The caller is "
"responsible for preventing this."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1363
msgid "return a pointer to the \"device root\" of a bus"
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1364
msgid "bus to return the device root of."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1365
msgid ""
"If a bus has a \"device root\" structure, return it, WITH THE REFERENCE "
"COUNT INCREMENTED."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1368
msgid ""
"Note, when finished with the device, a call to put_device() is required."
msgstr ""

#: ../../../driver-api/infrastructure:68: drivers/base/bus.c:1370
msgid ""
"If the device root is not present (or bus is not a valid pointer), NULL will "
"be returned."
msgstr ""

#: ../../../driver-api/infrastructure.rst:72
msgid "Device Drivers DMA Management"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:61
msgid "Managed dma_free_coherent()"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:62
msgid "Device to free coherent memory for"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:63
#: kernel/dma/mapping.c:82
msgid "Size of allocation"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:65
msgid "``void *vaddr``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:64
msgid "Virtual address of the memory to free"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:66
msgid "``dma_addr_t dma_handle``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:65
msgid "DMA handle of the memory to free"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:66
msgid "Managed dma_free_coherent()."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:80
msgid "Managed dma_alloc_attrs()"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:81
msgid "Device to allocate non_coherent memory for"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:84
msgid "``dma_addr_t *dma_handle``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:83
msgid "Out argument for allocated DMA handle"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:85
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:84
msgid "Allocation flags"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:86
#: kernel/dma/mapping.c:240 kernel/dma/mapping.c:268 kernel/dma/mapping.c:562
msgid "``unsigned long attrs``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:85
msgid "Flags in the DMA_ATTR_* namespace."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:86
msgid ""
"Managed dma_alloc_attrs().  Memory allocated using this function will be "
"automatically released on driver detach."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:234
#: kernel/dma/mapping.c:263
msgid "Map the given buffer for DMA"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:235
#: kernel/dma/mapping.c:264
msgid "The device for which to perform the DMA operation"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:237
msgid "``struct scatterlist *sg``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:236
#: kernel/dma/mapping.c:265
msgid "The sg_table object describing the buffer"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:238
msgid "``int nents``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:237
msgid "Number of entries to map"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:239
#: kernel/dma/mapping.c:267
msgid "``enum dma_data_direction dir``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:238
#: kernel/dma/mapping.c:266
msgid "DMA direction"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:239
#: kernel/dma/mapping.c:267
msgid "Optional DMA attributes for the map operation"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:240
msgid ""
"Maps a buffer described by a scatterlist passed in the sg argument with "
"nents segments for the **dir** DMA operation by the **dev** device."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:243
msgid ""
"Returns the number of mapped entries (which can be less than nents) on "
"success. Zero is returned for any error."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:246
msgid ""
"dma_unmap_sg_attrs() should be used to unmap the buffer with the original sg "
"and original nents (not the value returned by this funciton)."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:266
msgid "``struct sg_table *sgt``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:268
msgid ""
"Maps a buffer described by a scatterlist stored in the given sg_table object "
"for the **dir** DMA operation by the **dev** device. After success, the "
"ownership for the buffer is transferred to the DMA domain.  One has to call "
"dma_sync_sgtable_for_cpu() or dma_unmap_sgtable() to move the ownership of "
"the buffer back to the CPU domain before touching the buffer by the CPU."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:275
msgid ""
"Returns 0 on success or a negative error code on error. The following error "
"codes are supported with the given meaning:"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:278
msgid ""
"An invalid argument, unaligned access or other error in usage. Will not "
"succeed if retried."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:280
msgid ""
"Insufficient resources (like memory or IOVA space) to complete the mapping. "
"Should succeed if retried later."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:282
msgid ""
"Legacy error code with an unknown meaning. eg. this is returned if a lower "
"level call returned DMA_MAPPING_ERROR."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:285
msgid ""
"The DMA device cannot access P2PDMA memory specified in the sg_table. This "
"will not succeed if retried."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:447
msgid "does this device need dma_unmap_* operations"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:449
msgid ""
"If this function returns ``false``, drivers can skip calling dma_unmap_* "
"after finishing an I/O.  This function must be called after all mappings "
"that might need to be unmapped have been performed."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:536
msgid "check if a given device supports dma_mmap_*"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:538
msgid ""
"Returns ``true`` if **dev** supports dma_mmap_coherent() and "
"dma_mmap_attrs() to map DMA allocations to userspace."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:555
msgid "map a coherent DMA allocation into user space"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:556
msgid "valid struct device pointer, or NULL for ISA and EISA-like devices"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:558
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:557
msgid "vm_area_struct describing requested user mapping"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:559
msgid "``void *cpu_addr``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:558
msgid "kernel CPU-view address returned from dma_alloc_attrs"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:560
msgid "``dma_addr_t dma_addr``"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:559
msgid "device-view address returned from dma_alloc_attrs"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:560
msgid "size of memory originally requested in dma_alloc_attrs"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:561
msgid "attributes of mapping properties requested in dma_alloc_attrs"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:562
msgid ""
"Map a coherent DMA buffer previously allocated by dma_alloc_attrs into user "
"space.  The coherent DMA buffer must not be freed by the driver until the "
"user space mapping has been released."
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:945
msgid "return if the device is addressing limited"
msgstr ""

#: ../../../driver-api/infrastructure:74: kernel/dma/mapping.c:947
msgid ""
"Return ``true`` if the devices DMA mask is too small to address all memory "
"in the system, else ``false``.  Lack of addressing bits is the prime reason "
"for bounce buffering, but might not be the only one."
msgstr ""

#: ../../../driver-api/infrastructure.rst:78
msgid "Device drivers PnP support"
msgstr ""

#: ../../../driver-api/infrastructure:80: drivers/pnp/core.c:42
msgid "adds a pnp protocol to the pnp layer"
msgstr ""

#: ../../../driver-api/infrastructure:80: drivers/pnp/core.c:48
msgid "``struct pnp_protocol *protocol``"
msgstr ""

#: ../../../driver-api/infrastructure:80: drivers/pnp/core.c:43
msgid "pointer to the corresponding pnp_protocol structure"
msgstr ""

#: ../../../driver-api/infrastructure:80: drivers/pnp/core.c:44
msgid "Ex protocols: ISAPNP, PNPBIOS, etc"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:291
msgid "Searches for a PnP device under the specified card"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:297
msgid "``struct pnp_card_link *clink``"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:292
msgid "pointer to the card link, cannot be NULL"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:294
#: ../../../driver-api/infrastructure:86: drivers/pnp/driver.c:294
msgid "``const char *id``"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:293
msgid ""
"pointer to a PnP ID structure that explains the rules for finding the device"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:295
msgid "``struct pnp_dev *from``"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:294
msgid ""
"Starting place to search from. If NULL it will start from the beginning."
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:343
msgid "call this when the driver no longer needs the device"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:349
#: ../../../driver-api/infrastructure:86: drivers/pnp/driver.c:297
#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:338
#: drivers/pnp/manager.c:362 drivers/pnp/manager.c:384
#: drivers/pnp/manager.c:410 ../../../driver-api/infrastructure:92:
#: drivers/pnp/support.c:22
msgid "``struct pnp_dev *dev``"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:344
msgid "pointer to the PnP device structure"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:381
msgid "registers a PnP card driver with the PnP Layer"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:387
#: drivers/pnp/card.c:421
msgid "``struct pnp_card_driver *drv``"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:382
msgid "pointer to the driver to register"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:415
msgid "unregisters a PnP card driver from the PnP Layer"
msgstr ""

#: ../../../driver-api/infrastructure:83: drivers/pnp/card.c:416
msgid "pointer to the driver to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:86: drivers/pnp/driver.c:291
msgid "adds an EISA id to the specified device"
msgstr ""

#: ../../../driver-api/infrastructure:86: drivers/pnp/driver.c:292
#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:333
#: drivers/pnp/manager.c:357 drivers/pnp/manager.c:379
#: drivers/pnp/manager.c:405
msgid "pointer to the desired device"
msgstr ""

#: ../../../driver-api/infrastructure:86: drivers/pnp/driver.c:293
msgid "pointer to an EISA id string"
msgstr ""

#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:332
msgid "low-level start of the PnP device"
msgstr ""

#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:334
msgid "assumes that resources have already been allocated"
msgstr ""

#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:356
msgid "low-level disable of the PnP device"
msgstr ""

#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:358
msgid "does not free resources"
msgstr ""

#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:378
msgid "activates a PnP device for use"
msgstr ""

#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:380
msgid "does not validate or set resources so be careful."
msgstr ""

#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:404
msgid "disables device"
msgstr ""

#: ../../../driver-api/infrastructure:89: drivers/pnp/manager.c:406
msgid ""
"inform the correct pnp protocol so that resources can be used by other "
"devices"
msgstr ""

#: ../../../driver-api/infrastructure:92: drivers/pnp/support.c:16
msgid "Determines if a device is active based on its current resources"
msgstr ""

#: ../../../driver-api/infrastructure:92: drivers/pnp/support.c:18
msgid "pointer to the desired PnP device"
msgstr ""

#: ../../../driver-api/infrastructure.rst:96
msgid "Userspace IO devices"
msgstr ""

#: ../../../driver-api/infrastructure:98: drivers/uio/uio.c:427
msgid "trigger an interrupt event"
msgstr ""

#: ../../../driver-api/infrastructure:98: drivers/uio/uio.c:433
#: drivers/uio/uio.c:976 drivers/uio/uio.c:1072 drivers/uio/uio.c:1107
msgid "``struct uio_info *info``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:90
#: include/linux/uio_driver.h:131 include/linux/uio_driver.h:151
#: ../../../driver-api/infrastructure:98: drivers/uio/uio.c:428
#: drivers/uio/uio.c:975 drivers/uio/uio.c:1071 drivers/uio/uio.c:1102
msgid "UIO device capabilities"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:129
#: ../../../driver-api/infrastructure:98: drivers/uio/uio.c:972
msgid "register a new userspace IO device"
msgstr ""

#: ../../../driver-api/infrastructure:98: drivers/uio/uio.c:973
#: drivers/uio/uio.c:1069
msgid "module that creates the new device"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:130
#: include/linux/uio_driver.h:150 ../../../driver-api/infrastructure:98:
#: drivers/uio/uio.c:974 drivers/uio/uio.c:1070
msgid "parent device"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:132
#: include/linux/uio_driver.h:152 ../../../driver-api/infrastructure:98:
#: drivers/uio/uio.c:976 drivers/uio/uio.c:1072
msgid "returns zero on success or a negative error code."
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:149
#: ../../../driver-api/infrastructure:98: drivers/uio/uio.c:1068
msgid "Resource managed uio_register_device()"
msgstr ""

#: ../../../driver-api/infrastructure:98: drivers/uio/uio.c:1101
msgid "unregister a industrial IO device"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:24
msgid "description of a UIO memory region"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:26
msgid "name of the memory region for identification"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:26
msgid "``addr``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:27
msgid ""
"address of the device's memory rounded to page size (phys_addr is used since "
"addr can be logical, virtual, or physical & phys_addr_t should always be "
"large enough to handle any of the address types)"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:31
msgid "``dma_addr``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:32
msgid ""
"DMA handle set by dma_alloc_coherent, used with UIO_MEM_DMA_COHERENT only "
"(**addr** should be the void * returned from the same dma_alloc_coherent "
"call)"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:34
msgid "``offs``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:35
msgid "offset of device memory within the page"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:35
#: include/linux/uio_driver.h:62
msgid "``size``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:36
msgid "size of IO (multiple of page size)"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:36
msgid "``memtype``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:37
msgid "type of memory addr points to"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:37
msgid "``internal_addr``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:38
msgid "ioremap-ped version of addr, for driver internal use"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:38
msgid "``dma_device``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:39
msgid ""
"device struct that was passed to dma_alloc_coherent, used with "
"UIO_MEM_DMA_COHERENT only"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:40
msgid "``map``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:41
#: include/linux/uio_driver.h:65
msgid "for use by the UIO core only."
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:59
msgid "description of a UIO port region"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:61
msgid "name of the port region for identification"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:61
msgid "``start``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:62
msgid "start of port region"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:63
msgid "size of port region"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:63
msgid "``porttype``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:64
msgid "type of port (see UIO_PORT_* below)"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:64
msgid "``portio``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:91
msgid "``uio_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:92
msgid "the UIO device this info belongs to"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:93
msgid "device name"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:93
msgid "``version``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:94
msgid "device driver version"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:94
msgid "``mem``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:95
msgid "list of mappable memory regions, size==0 for end of list"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:95
msgid "``port``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:96
msgid "list of port regions, size==0 for end of list"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:96
msgid "``irq``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:97
msgid "interrupt number or UIO_IRQ_CUSTOM"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:97
msgid "``irq_flags``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:98
msgid "flags for request_irq()"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:98
msgid "``priv``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:99
msgid "optional private data"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:99
msgid "``handler``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:100
msgid "the device's irq handler"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:100
msgid "``mmap``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:101
msgid "mmap operation for this uio device"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:101
msgid "``open``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:102
msgid "open operation for this uio device"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:103
msgid "release operation for this uio device"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:103
msgid "``irqcontrol``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:104
msgid "disable/enable irqs when 0/1 is written to /dev/uioX"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:131
msgid "``uio_register_device (parent, info)``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:132
#: include/linux/uio_driver.h:152
msgid "``info``"
msgstr ""

#: ../../../driver-api/infrastructure:101: include/linux/uio_driver.h:151
msgid "``devm_uio_register_device (parent, info)``"
msgstr ""
