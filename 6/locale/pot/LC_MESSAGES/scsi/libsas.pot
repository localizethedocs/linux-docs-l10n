# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scsi/libsas.rst:5
msgid "SAS Layer"
msgstr ""

#: ../../../scsi/libsas.rst:7
msgid ""
"The SAS Layer is a management infrastructure which manages SAS LLDDs.  It "
"sits between SCSI Core and SAS LLDDs.  The layout is as follows: while SCSI "
"Core is concerned with SAM/SPC issues, and a SAS LLDD+sequencer is concerned "
"with phy/OOB/link management, the SAS layer is concerned with:"
msgstr ""

#: ../../../scsi/libsas.rst:13
msgid "SAS Phy/Port/HA event management (LLDD generates, SAS Layer processes),"
msgstr ""

#: ../../../scsi/libsas.rst:15
msgid "SAS Port management (creation/destruction),"
msgstr ""

#: ../../../scsi/libsas.rst:16
msgid "SAS Domain discovery and revalidation,"
msgstr ""

#: ../../../scsi/libsas.rst:17
msgid "SAS Domain device management,"
msgstr ""

#: ../../../scsi/libsas.rst:18
msgid "SCSI Host registration/unregistration,"
msgstr ""

#: ../../../scsi/libsas.rst:19
msgid "Device registration with SCSI Core (SAS) or libata (SATA), and"
msgstr ""

#: ../../../scsi/libsas.rst:21
msgid "Expander management and exporting expander control to user space."
msgstr ""

#: ../../../scsi/libsas.rst:24
msgid ""
"A SAS LLDD is a PCI device driver.  It is concerned with phy/OOB management, "
"and vendor specific tasks and generates events to the SAS layer."
msgstr ""

#: ../../../scsi/libsas.rst:28
msgid "The SAS Layer does most SAS tasks as outlined in the SAS 1.1 spec."
msgstr ""

#: ../../../scsi/libsas.rst:31
msgid ""
"The sas_ha_struct describes the SAS LLDD to the SAS layer. Most of it is "
"used by the SAS Layer but a few fields need to be initialized by the LLDDs."
msgstr ""

#: ../../../scsi/libsas.rst:35
msgid ""
"After initializing your hardware, from the probe() function you call "
"sas_register_ha(). It will register your LLDD with the SCSI subsystem, "
"creating a SCSI host and it will register your SAS driver with the sysfs SAS "
"tree it creates. It will then return.  Then you enable your phys to actually "
"start OOB (at which point your driver will start calling the notify_* event "
"callbacks)."
msgstr ""

#: ../../../scsi/libsas.rst:44
msgid "Structure descriptions"
msgstr ""

#: ../../../scsi/libsas.rst:47
msgid "``struct sas_phy``"
msgstr ""

#: ../../../scsi/libsas.rst:49
msgid "Normally this is statically embedded to your driver's phy structure::"
msgstr ""

#: ../../../scsi/libsas.rst:58
msgid ""
"And then all the phys are an array of my_phy in your HA struct (shown below)."
msgstr ""

#: ../../../scsi/libsas.rst:61
msgid ""
"Then as you go along and initialize your phys you also initialize the "
"sas_phy struct, along with your own phy structure."
msgstr ""

#: ../../../scsi/libsas.rst:65
msgid ""
"In general, the phys are managed by the LLDD and the ports are managed by "
"the SAS layer.  So the phys are initialized and updated by the LLDD and the "
"ports are initialized and updated by the SAS layer."
msgstr ""

#: ../../../scsi/libsas.rst:70
msgid ""
"There is a scheme where the LLDD can RW certain fields, and the SAS layer "
"can only read such ones, and vice versa. The idea is to avoid unnecessary "
"locking."
msgstr ""

#: ../../../scsi/libsas.rst:74
msgid "enabled"
msgstr ""

#: ../../../scsi/libsas.rst:75
msgid "must be set (0/1)"
msgstr ""

#: ../../../scsi/libsas.rst:77
msgid "id"
msgstr ""

#: ../../../scsi/libsas.rst:78
msgid "must be set [0,MAX_PHYS)]"
msgstr ""

#: ../../../scsi/libsas.rst:80
msgid "class, proto, type, role, oob_mode, linkrate"
msgstr ""

#: ../../../scsi/libsas.rst:81
msgid "must be set"
msgstr ""

#: ../../../scsi/libsas.rst:83
msgid "oob_mode"
msgstr ""

#: ../../../scsi/libsas.rst:84
msgid "you set this when OOB has finished and then notify the SAS Layer."
msgstr ""

#: ../../../scsi/libsas.rst:87 ../../../scsi/libsas.rst:167
msgid "sas_addr"
msgstr ""

#: ../../../scsi/libsas.rst:88
msgid ""
"this normally points to an array holding the sas address of the phy, "
"possibly somewhere in your my_phy struct."
msgstr ""

#: ../../../scsi/libsas.rst:92
msgid "attached_sas_addr"
msgstr ""

#: ../../../scsi/libsas.rst:93
msgid ""
"set this when you (LLDD) receive an IDENTIFY frame or a FIS frame, _before_ "
"notifying the SAS layer.  The idea is that sometimes the LLDD may want to "
"fake or provide a different SAS address on that phy/port and this allows it "
"to do this.  At best you should copy the sas address from the IDENTIFY frame "
"or maybe generate a SAS address for SATA directly attached devices.  The "
"Discover process may later change this."
msgstr ""

#: ../../../scsi/libsas.rst:102
msgid "frame_rcvd"
msgstr ""

#: ../../../scsi/libsas.rst:103
msgid ""
"this is where you copy the IDENTIFY/FIS frame when you get it; you lock, "
"copy, set frame_rcvd_size and unlock the lock, and then call the event.  It "
"is a pointer since there's no way to know your hw frame size _exactly_, so "
"you define the actual array in your phy struct and let this pointer point to "
"it.  You copy the frame from your DMAable memory to that area holding the "
"lock."
msgstr ""

#: ../../../scsi/libsas.rst:111
msgid "sas_prim"
msgstr ""

#: ../../../scsi/libsas.rst:112
msgid ""
"this is where primitives go when they're received.  See sas.h. Grab the "
"lock, set the primitive, release the lock, notify."
msgstr ""

#: ../../../scsi/libsas.rst:116
msgid "port"
msgstr ""

#: ../../../scsi/libsas.rst:117
msgid ""
"this points to the sas_port if the phy belongs to a port -- the LLDD only "
"reads this. It points to the sas_port this phy is part of.  Set by the SAS "
"Layer."
msgstr ""

#: ../../../scsi/libsas.rst:121
msgid "ha"
msgstr ""

#: ../../../scsi/libsas.rst:122
msgid "may be set; the SAS layer sets it anyway."
msgstr ""

#: ../../../scsi/libsas.rst:124
msgid "lldd_phy"
msgstr ""

#: ../../../scsi/libsas.rst:125
msgid ""
"you should set this to point to your phy so you can find your way around "
"faster when the SAS layer calls one of your callbacks and passes you a phy.  "
"If the sas_phy is embedded you can also use container_of -- whatever you "
"prefer."
msgstr ""

#: ../../../scsi/libsas.rst:133
msgid "``struct sas_port``"
msgstr ""

#: ../../../scsi/libsas.rst:135
msgid ""
"The LLDD doesn't set any fields of this struct -- it only reads them.  They "
"should be self explanatory."
msgstr ""

#: ../../../scsi/libsas.rst:138
msgid ""
"phy_mask is 32 bit, this should be enough for now, as I haven't heard of a "
"HA having more than 8 phys."
msgstr ""

#: ../../../scsi/libsas.rst:141
msgid "lldd_port"
msgstr ""

#: ../../../scsi/libsas.rst:142
msgid ""
"I haven't found use for that -- maybe other LLDD who wish to have internal "
"port representation can make use of this."
msgstr ""

#: ../../../scsi/libsas.rst:147
msgid "``struct sas_ha_struct``"
msgstr ""

#: ../../../scsi/libsas.rst:149
msgid ""
"It normally is statically declared in your own LLDD structure describing "
"your adapter::"
msgstr ""

#: ../../../scsi/libsas.rst:162
msgid "What needs to be initialized (sample function given below)."
msgstr ""

#: ../../../scsi/libsas.rst:165
msgid "pcidev"
msgstr ""

#: ../../../scsi/libsas.rst:168
msgid ""
"since the SAS layer doesn't want to mess with memory allocation, etc, this "
"points to statically allocated array somewhere (say in your host adapter "
"structure) and holds the SAS address of the host adapter as given by you or "
"the manufacturer, etc."
msgstr ""

#: ../../../scsi/libsas.rst:175
msgid "sas_port"
msgstr ""

#: ../../../scsi/libsas.rst:177
msgid "sas_phy"
msgstr ""

#: ../../../scsi/libsas.rst:178
msgid ""
"an array of pointers to structures. (see note above on sas_addr). These must "
"be set.  See more notes below."
msgstr ""

#: ../../../scsi/libsas.rst:182
msgid "num_phys"
msgstr ""

#: ../../../scsi/libsas.rst:183
msgid ""
"the number of phys present in the sas_phy array, and the number of ports "
"present in the sas_port array.  There can be a maximum num_phys ports (one "
"per port) so we drop the num_ports, and only use num_phys."
msgstr ""

#: ../../../scsi/libsas.rst:189
msgid "The event interface::"
msgstr ""

#: ../../../scsi/libsas.rst:195
msgid "The port notification::"
msgstr ""

#: ../../../scsi/libsas.rst:201
msgid ""
"If the LLDD wants notification when a port has been formed or deformed it "
"sets those to a function satisfying the type."
msgstr ""

#: ../../../scsi/libsas.rst:204
msgid ""
"A SAS LLDD should also implement at least one of the Task Management "
"Functions (TMFs) described in SAM::"
msgstr ""

#: ../../../scsi/libsas.rst:215
msgid "For more information please read SAM from T10.org."
msgstr ""

#: ../../../scsi/libsas.rst:217
msgid "Port and Adapter management::"
msgstr ""

#: ../../../scsi/libsas.rst:223
msgid "A SAS LLDD should implement at least one of those."
msgstr ""

#: ../../../scsi/libsas.rst:225
msgid "Phy management::"
msgstr ""

#: ../../../scsi/libsas.rst:230
msgid "lldd_ha"
msgstr ""

#: ../../../scsi/libsas.rst:231
msgid ""
"set this to point to your HA struct. You can also use container_of if you "
"embedded it as shown above."
msgstr ""

#: ../../../scsi/libsas.rst:234
msgid ""
"A sample initialization and registration function can look like this (called "
"last thing from probe()) *but* before you enable the phys to do OOB::"
msgstr ""

#: ../../../scsi/libsas.rst:277
msgid "SAS 1.1 does not define I_T Nexus Reset TMF."
msgstr ""

#: ../../../scsi/libsas.rst:280
msgid "Events"
msgstr ""

#: ../../../scsi/libsas.rst:282
msgid ""
"Events are **the only way** a SAS LLDD notifies the SAS layer of anything.  "
"There is no other method or way a LLDD to tell the SAS layer of anything "
"happening internally or in the SAS domain."
msgstr ""

#: ../../../scsi/libsas.rst:287
msgid "Phy events::"
msgstr ""

#: ../../../scsi/libsas.rst:294
msgid "Port events, passed on a _phy_::"
msgstr ""

#: ../../../scsi/libsas.rst:302
msgid "Host Adapter event:"
msgstr ""

#: ../../../scsi/libsas.rst:303 ../../../scsi/libsas.rst:315
msgid "HAE_RESET"
msgstr ""

#: ../../../scsi/libsas.rst:305
msgid "A SAS LLDD should be able to generate"
msgstr ""

#: ../../../scsi/libsas.rst:307
msgid "at least one event from group C (choice),"
msgstr ""

#: ../../../scsi/libsas.rst:308
msgid "events marked M (mandatory) are mandatory (only one),"
msgstr ""

#: ../../../scsi/libsas.rst:309
msgid ""
"events marked E (expander) if it wants the SAS layer to handle domain "
"revalidation (only one such)."
msgstr ""

#: ../../../scsi/libsas.rst:311
msgid "Unmarked events are optional."
msgstr ""

#: ../../../scsi/libsas.rst:313
msgid "Meaning:"
msgstr ""

#: ../../../scsi/libsas.rst:316
msgid "when your HA got internal error and was reset."
msgstr ""

#: ../../../scsi/libsas.rst:318
msgid "PORTE_BYTES_DMAED"
msgstr ""

#: ../../../scsi/libsas.rst:319
msgid "on receiving an IDENTIFY/FIS frame"
msgstr ""

#: ../../../scsi/libsas.rst:321
msgid "PORTE_BROADCAST_RCVD"
msgstr ""

#: ../../../scsi/libsas.rst:322
msgid "on receiving a primitive"
msgstr ""

#: ../../../scsi/libsas.rst:324
msgid "PORTE_LINK_RESET_ERR"
msgstr ""

#: ../../../scsi/libsas.rst:325
msgid "timer expired, loss of signal, loss of DWS, etc. [1]_"
msgstr ""

#: ../../../scsi/libsas.rst:327
msgid "PORTE_TIMER_EVENT"
msgstr ""

#: ../../../scsi/libsas.rst:328
msgid "DWS reset timeout timer expired [1]_"
msgstr ""

#: ../../../scsi/libsas.rst:330
msgid "PORTE_HARD_RESET"
msgstr ""

#: ../../../scsi/libsas.rst:331
msgid "Hard Reset primitive received."
msgstr ""

#: ../../../scsi/libsas.rst:333
msgid "PHYE_LOSS_OF_SIGNAL"
msgstr ""

#: ../../../scsi/libsas.rst:334
msgid "the device is gone [1]_"
msgstr ""

#: ../../../scsi/libsas.rst:336
msgid "PHYE_OOB_DONE"
msgstr ""

#: ../../../scsi/libsas.rst:337
msgid "OOB went fine and oob_mode is valid"
msgstr ""

#: ../../../scsi/libsas.rst:339
msgid "PHYE_OOB_ERROR"
msgstr ""

#: ../../../scsi/libsas.rst:340
msgid "Error while doing OOB, the device probably got disconnected. [1]_"
msgstr ""

#: ../../../scsi/libsas.rst:343
msgid "PHYE_SPINUP_HOLD"
msgstr ""

#: ../../../scsi/libsas.rst:344
msgid "SATA is present, COMWAKE not sent."
msgstr ""

#: ../../../scsi/libsas.rst:346
msgid ""
"should set/clear the appropriate fields in the phy, or alternatively call "
"the inlined sas_phy_disconnected() which is just a helper, from their "
"tasklet."
msgstr ""

#: ../../../scsi/libsas.rst:350
msgid "The Execute Command SCSI RPC::"
msgstr ""

#: ../../../scsi/libsas.rst:354
msgid ""
"Used to queue a task to the SAS LLDD.  @task is the task to be executed. "
"@gfp_mask is the gfp_mask defining the context of the caller."
msgstr ""

#: ../../../scsi/libsas.rst:357
msgid "This function should implement the Execute Command SCSI RPC,"
msgstr ""

#: ../../../scsi/libsas.rst:359
msgid ""
"That is, when lldd_execute_task() is called, the command go out on the "
"transport *immediately*.  There is *no* queuing of any sort and at any level "
"in a SAS LLDD."
msgstr ""

#: ../../../scsi/libsas.rst:363
msgid "Returns:"
msgstr ""

#: ../../../scsi/libsas.rst:365
msgid "-SAS_QUEUE_FULL, -ENOMEM, nothing was queued;"
msgstr ""

#: ../../../scsi/libsas.rst:366
msgid "0, the task(s) were queued."
msgstr ""

#: ../../../scsi/libsas.rst:381
msgid "Discovery"
msgstr ""

#: ../../../scsi/libsas.rst:383
msgid "The sysfs tree has the following purposes:"
msgstr ""

#: ../../../scsi/libsas.rst:385
msgid ""
"It shows you the physical layout of the SAS domain at the current time, i.e. "
"how the domain looks in the physical world right now."
msgstr ""

#: ../../../scsi/libsas.rst:388
msgid "Shows some device parameters _at_discovery_time_."
msgstr ""

#: ../../../scsi/libsas.rst:390
msgid ""
"This is a link to the tree(1) program, very useful in viewing the SAS "
"domain: ftp://mama.indstate.edu/linux/tree/"
msgstr ""

#: ../../../scsi/libsas.rst:394
msgid ""
"I expect user space applications to actually create a graphical interface of "
"this."
msgstr ""

#: ../../../scsi/libsas.rst:397
msgid ""
"That is, the sysfs domain tree doesn't show or keep state if you e.g., "
"change the meaning of the READY LED MEANING setting, but it does show you "
"the current connection status of the domain device."
msgstr ""

#: ../../../scsi/libsas.rst:402
msgid ""
"Keeping internal device state changes is responsibility of upper layers "
"(Command set drivers) and user space."
msgstr ""

#: ../../../scsi/libsas.rst:405
msgid ""
"When a device or devices are unplugged from the domain, this is reflected in "
"the sysfs tree immediately, and the device(s) removed from the system."
msgstr ""

#: ../../../scsi/libsas.rst:409
msgid ""
"The structure domain_device describes any device in the SAS domain.  It is "
"completely managed by the SAS layer.  A task points to a domain device, this "
"is how the SAS LLDD knows where to send the task(s) to.  A SAS LLDD only "
"reads the contents of the domain_device structure, but it never creates or "
"destroys one."
msgstr ""

#: ../../../scsi/libsas.rst:417
msgid "Expander management from User Space"
msgstr ""

#: ../../../scsi/libsas.rst:419
msgid ""
"In each expander directory in sysfs, there is a file called \"smp_portal\".  "
"It is a binary sysfs attribute file, which implements an SMP portal (Note: "
"this is *NOT* an SMP port), to which user space applications can send SMP "
"requests and receive SMP responses."
msgstr ""

#: ../../../scsi/libsas.rst:425
msgid "Functionality is deceptively simple:"
msgstr ""

#: ../../../scsi/libsas.rst:427
msgid ""
"Build the SMP frame you want to send. The format and layout is described in "
"the SAS spec.  Leave the CRC field equal 0."
msgstr ""

#: ../../../scsi/libsas.rst:430
msgid "open(2)"
msgstr ""

#: ../../../scsi/libsas.rst:432
msgid "Open the expander's SMP portal sysfs file in RW mode."
msgstr ""

#: ../../../scsi/libsas.rst:434
msgid "write(2)"
msgstr ""

#: ../../../scsi/libsas.rst:436
msgid "Write the frame you built in 1."
msgstr ""

#: ../../../scsi/libsas.rst:438
msgid "read(2)"
msgstr ""

#: ../../../scsi/libsas.rst:440
msgid ""
"Read the amount of data you expect to receive for the frame you built. If "
"you receive different amount of data you expected to receive, then there was "
"some kind of error."
msgstr ""

#: ../../../scsi/libsas.rst:444
msgid "close(2)"
msgstr ""

#: ../../../scsi/libsas.rst:446
msgid ""
"All this process is shown in detail in the function do_smp_func() and its "
"callers, in the file \"expander_conf.c\"."
msgstr ""

#: ../../../scsi/libsas.rst:449
msgid "The kernel functionality is implemented in the file \"sas_expander.c\"."
msgstr ""

#: ../../../scsi/libsas.rst:452
msgid ""
"The program \"expander_conf.c\" implements this. It takes one argument, the "
"sysfs file name of the SMP portal to the expander, and gives expander "
"information, including routing tables."
msgstr ""

#: ../../../scsi/libsas.rst:457
msgid ""
"The SMP portal gives you complete control of the expander, so please be "
"careful."
msgstr ""
