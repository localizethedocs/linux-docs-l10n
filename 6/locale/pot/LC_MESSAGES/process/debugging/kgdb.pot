# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../process/debugging/kgdb.rst:3
msgid "Using kgdb, kdb and the kernel debugger internals"
msgstr ""

#: ../../../process/debugging/kgdb.rst:0
msgid "Author"
msgstr ""

#: ../../../process/debugging/kgdb.rst:5
msgid "Jason Wessel"
msgstr ""

#: ../../../process/debugging/kgdb.rst:8
msgid "Introduction"
msgstr ""

#: ../../../process/debugging/kgdb.rst:10
msgid ""
"The kernel has two different debugger front ends (kdb and kgdb) which "
"interface to the debug core. It is possible to use either of the debugger "
"front ends and dynamically transition between them if you configure the "
"kernel properly at compile and runtime."
msgstr ""

#: ../../../process/debugging/kgdb.rst:15
msgid ""
"Kdb is simplistic shell-style interface which you can use on a system "
"console with a keyboard or serial console. You can use it to inspect memory, "
"registers, process lists, dmesg, and even set breakpoints to stop in a "
"certain location. Kdb is not a source level debugger, although you can set "
"breakpoints and execute some basic kernel run control. Kdb is mainly aimed "
"at doing some analysis to aid in development or diagnosing kernel problems. "
"You can access some symbols by name in kernel built-ins or in kernel modules "
"if the code was built with ``CONFIG_KALLSYMS``."
msgstr ""

#: ../../../process/debugging/kgdb.rst:25
msgid ""
"Kgdb is intended to be used as a source level debugger for the Linux kernel. "
"It is used along with gdb to debug a Linux kernel. The expectation is that "
"gdb can be used to \"break in\" to the kernel to inspect memory, variables "
"and look through call stack information similar to the way an application "
"developer would use gdb to debug an application. It is possible to place "
"breakpoints in kernel code and perform some limited execution stepping."
msgstr ""

#: ../../../process/debugging/kgdb.rst:33
msgid ""
"Two machines are required for using kgdb. One of these machines is a "
"development machine and the other is the target machine. The kernel to be "
"debugged runs on the target machine. The development machine runs an "
"instance of gdb against the vmlinux file which contains the symbols (not a "
"boot image such as bzImage, zImage, uImage...). In gdb the developer "
"specifies the connection parameters and connects to kgdb. The type of "
"connection a developer makes with gdb depends on the availability of kgdb I/"
"O modules compiled as built-ins or loadable kernel modules in the test "
"machine's kernel."
msgstr ""

#: ../../../process/debugging/kgdb.rst:44
msgid "Compiling a kernel"
msgstr ""

#: ../../../process/debugging/kgdb.rst:46
msgid "In order to enable compilation of kdb, you must first enable kgdb."
msgstr ""

#: ../../../process/debugging/kgdb.rst:48
msgid ""
"The kgdb test compile options are described in the kgdb test suite chapter."
msgstr ""

#: ../../../process/debugging/kgdb.rst:52
msgid "Kernel config options for kgdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:54
msgid ""
"To enable ``CONFIG_KGDB`` you should look under :menuselection:`Kernel "
"hacking --> Kernel debugging` and select :menuselection:`KGDB: kernel "
"debugger`."
msgstr ""

#: ../../../process/debugging/kgdb.rst:58
msgid ""
"While it is not a hard requirement that you have symbols in your vmlinux "
"file, gdb tends not to be very useful without the symbolic data, so you will "
"want to turn on ``CONFIG_DEBUG_INFO`` which is called :menuselection:"
"`Compile the kernel with debug info` in the config menu."
msgstr ""

#: ../../../process/debugging/kgdb.rst:63
msgid ""
"It is advised, but not required, that you turn on the "
"``CONFIG_FRAME_POINTER`` kernel option which is called :menuselection:"
"`Compile the kernel with frame pointers` in the config menu. This option "
"inserts code into the compiled executable which saves the frame information "
"in registers or on the stack at different points which allows a debugger "
"such as gdb to more accurately construct stack back traces while debugging "
"the kernel."
msgstr ""

#: ../../../process/debugging/kgdb.rst:70
msgid ""
"If the architecture that you are using supports the kernel option "
"``CONFIG_STRICT_KERNEL_RWX``, you should consider turning it off. This "
"option will prevent the use of software breakpoints because it marks certain "
"regions of the kernel's memory space as read-only. If kgdb supports it for "
"the architecture you are using, you can use hardware breakpoints if you "
"desire to run with the ``CONFIG_STRICT_KERNEL_RWX`` option turned on, else "
"you need to turn off this option."
msgstr ""

#: ../../../process/debugging/kgdb.rst:78
msgid ""
"Next you should choose one or more I/O drivers to interconnect the debugging "
"host and debugged target. Early boot debugging requires a KGDB I/O driver "
"that supports early debugging and the driver must be built into the kernel "
"directly. Kgdb I/O driver configuration takes place via kernel or module "
"parameters which you can learn more about in the section that describes the "
"parameter kgdboc."
msgstr ""

#: ../../../process/debugging/kgdb.rst:85
msgid ""
"Here is an example set of ``.config`` symbols to enable or disable for kgdb::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:93
msgid "Kernel config options for kdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:95
msgid ""
"Kdb is quite a bit more complex than the simple gdbstub sitting on top of "
"the kernel's debug core. Kdb must implement a shell, and also adds some "
"helper functions in other parts of the kernel, responsible for printing out "
"interesting data such as what you would see if you ran ``lsmod``, or ``ps``. "
"In order to build kdb into the kernel you follow the same steps as you would "
"for kgdb."
msgstr ""

#: ../../../process/debugging/kgdb.rst:102
msgid ""
"The main config option for kdb is ``CONFIG_KGDB_KDB`` which is called :"
"menuselection:`KGDB_KDB: include kdb frontend for kgdb` in the config menu. "
"In theory you would have already also selected an I/O driver such as the "
"``CONFIG_KGDB_SERIAL_CONSOLE`` interface if you plan on using kdb on a "
"serial port, when you were configuring kgdb."
msgstr ""

#: ../../../process/debugging/kgdb.rst:108
msgid ""
"If you want to use a PS/2-style keyboard with kdb, you would select "
"``CONFIG_KDB_KEYBOARD`` which is called :menuselection:`KGDB_KDB: keyboard "
"as input device` in the config menu. The ``CONFIG_KDB_KEYBOARD`` option is "
"not used for anything in the gdb interface to kgdb. The "
"``CONFIG_KDB_KEYBOARD`` option only works with kdb."
msgstr ""

#: ../../../process/debugging/kgdb.rst:114
msgid "Here is an example set of ``.config`` symbols to enable/disable kdb::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:124
msgid "Kernel Debugger Boot Arguments"
msgstr ""

#: ../../../process/debugging/kgdb.rst:126
msgid ""
"This section describes the various runtime kernel parameters that affect the "
"configuration of the kernel debugger. The following chapter covers using kdb "
"and kgdb as well as providing some examples of the configuration parameters."
msgstr ""

#: ../../../process/debugging/kgdb.rst:132
msgid "Kernel parameter: kgdboc"
msgstr ""

#: ../../../process/debugging/kgdb.rst:134
msgid ""
"The kgdboc driver was originally an abbreviation meant to stand for \"kgdb "
"over console\". Today it is the primary mechanism to configure how to "
"communicate from gdb to kgdb as well as the devices you want to use to "
"interact with the kdb shell."
msgstr ""

#: ../../../process/debugging/kgdb.rst:139
msgid ""
"For kgdb/gdb, kgdboc is designed to work with a single serial port. It is "
"intended to cover the circumstance where you want to use a serial console as "
"your primary console as well as using it to perform kernel debugging. It is "
"also possible to use kgdb on a serial port which is not designated as a "
"system console. Kgdboc may be configured as a kernel built-in or a kernel "
"loadable module. You can only make use of ``kgdbwait`` and early debugging "
"if you build kgdboc into the kernel as a built-in."
msgstr ""

#: ../../../process/debugging/kgdb.rst:148
msgid ""
"Optionally you can elect to activate kms (Kernel Mode Setting) integration. "
"When you use kms with kgdboc and you have a video driver that has atomic "
"mode setting hooks, it is possible to enter the debugger on the graphics "
"console. When the kernel execution is resumed, the previous graphics mode "
"will be restored. This integration can serve as a useful tool to aid in "
"diagnosing crashes or doing analysis of memory with kdb while allowing the "
"full graphics console applications to run."
msgstr ""

#: ../../../process/debugging/kgdb.rst:157
msgid "kgdboc arguments"
msgstr ""

#: ../../../process/debugging/kgdb.rst:159
msgid "Usage::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:163
msgid ""
"The order listed above must be observed if you use any of the optional "
"configurations together."
msgstr ""

#: ../../../process/debugging/kgdb.rst:166
msgid "Abbreviations:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:168
msgid "kms = Kernel Mode Setting"
msgstr ""

#: ../../../process/debugging/kgdb.rst:170
msgid "kbd = Keyboard"
msgstr ""

#: ../../../process/debugging/kgdb.rst:172
msgid ""
"You can configure kgdboc to use the keyboard, and/or a serial device "
"depending on if you are using kdb and/or kgdb, in one of the following "
"scenarios. The order listed above must be observed if you use any of the "
"optional configurations together. Using kms + only gdb is generally not a "
"useful combination."
msgstr ""

#: ../../../process/debugging/kgdb.rst:179
msgid "Using loadable module or built-in"
msgstr ""

#: ../../../process/debugging/kgdb.rst:181
msgid "As a kernel built-in:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:183
msgid "Use the kernel boot argument::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:187
msgid "As a kernel loadable module:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:189
msgid "Use the command::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:193
msgid ""
"Here are two examples of how you might format the kgdboc string. The first "
"is for an x86 target using the first serial port. The second example is for "
"the ARM Versatile AB using the second serial port."
msgstr ""

#: ../../../process/debugging/kgdb.rst:197
msgid "``kgdboc=ttyS0,115200``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:199
msgid "``kgdboc=ttyAMA1,115200``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:202
msgid "Configure kgdboc at runtime with sysfs"
msgstr ""

#: ../../../process/debugging/kgdb.rst:204
msgid ""
"At run time you can enable or disable kgdboc by writing parameters into "
"sysfs. Here are two examples:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:207
msgid "Enable kgdboc on ttyS0::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:211
msgid "Disable kgdboc::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:217
msgid ""
"You do not need to specify the baud if you are configuring the console on "
"tty which is already configured or open."
msgstr ""

#: ../../../process/debugging/kgdb.rst:221
msgid "More examples"
msgstr ""

#: ../../../process/debugging/kgdb.rst:223
msgid ""
"You can configure kgdboc to use the keyboard, and/or a serial device "
"depending on if you are using kdb and/or kgdb, in one of the following "
"scenarios."
msgstr ""

#: ../../../process/debugging/kgdb.rst:227
msgid "kdb and kgdb over only a serial port::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:231
#: ../../../process/debugging/kgdb.rst:239
#: ../../../process/debugging/kgdb.rst:649
msgid "Example::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:235
msgid "kdb and kgdb with keyboard and a serial port::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:243
msgid "kdb with a keyboard::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:247
msgid "kdb with kernel mode setting::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:251
msgid "kdb with kernel mode setting and kgdb over a serial port::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:257
msgid ""
"Kgdboc does not support interrupting the target via the gdb remote protocol. "
"You must manually send a `SysRq-G` unless you have a proxy that splits "
"console output to a terminal program. A console proxy has a separate TCP "
"port for the debugger and a separate TCP port for the \"human\" console. The "
"proxy can take care of sending the `SysRq-G` for you."
msgstr ""

#: ../../../process/debugging/kgdb.rst:264
msgid ""
"When using kgdboc with no debugger proxy, you can end up connecting the "
"debugger at one of two entry points. If an exception occurs after you have "
"loaded kgdboc, a message should print on the console stating it is waiting "
"for the debugger. In this case you disconnect your terminal program and then "
"connect the debugger in its place. If you want to interrupt the target "
"system and forcibly enter a debug session you have to issue a `Sysrq` "
"sequence and then type the letter `g`. Then you disconnect the terminal "
"session and connect gdb. Your options if you don't like this are to hack gdb "
"to send the `SysRq-G` for you as well as on the initial connect, or to use a "
"debugger proxy that allows an unmodified gdb to do the debugging."
msgstr ""

#: ../../../process/debugging/kgdb.rst:277
msgid "Kernel parameter: ``kgdboc_earlycon``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:279
msgid ""
"If you specify the kernel parameter ``kgdboc_earlycon`` and your serial "
"driver registers a boot console that supports polling (doesn't need "
"interrupts and implements a nonblocking read() function) kgdb will attempt "
"to work using the boot console until it can transition to the regular tty "
"driver specified by the ``kgdboc`` parameter."
msgstr ""

#: ../../../process/debugging/kgdb.rst:285
msgid ""
"Normally there is only one boot console (especially that implements the "
"read() function) so just adding ``kgdboc_earlycon`` on its own is sufficient "
"to make this work. If you have more than one boot console you can add the "
"boot console's name to differentiate. Note that names that are registered "
"through the boot console layer and the tty layer are not the same for the "
"same port."
msgstr ""

#: ../../../process/debugging/kgdb.rst:292
msgid "For instance, on one board to be explicit you might do::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:296
msgid ""
"If the only boot console on the device was \"qcom_geni\", you could "
"simplify::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:301
msgid "Kernel parameter: ``kgdbwait``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:303
msgid ""
"The Kernel command line option ``kgdbwait`` makes kgdb wait for a debugger "
"connection during booting of a kernel. You can only use this option if you "
"compiled a kgdb I/O driver into the kernel and you specified the I/O driver "
"configuration as a kernel command line option. The kgdbwait parameter should "
"always follow the configuration parameter for the kgdb I/O driver in the "
"kernel command line else the I/O driver will not be configured prior to "
"asking the kernel to use it to wait."
msgstr ""

#: ../../../process/debugging/kgdb.rst:311
msgid ""
"The kernel will stop and wait as early as the I/O driver and architecture "
"allows when you use this option. If you build the kgdb I/O driver as a "
"loadable kernel module kgdbwait will not do anything."
msgstr ""

#: ../../../process/debugging/kgdb.rst:316
msgid "Kernel parameter: ``kgdbcon``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:318
msgid ""
"The ``kgdbcon`` feature allows you to see printk() messages inside gdb while "
"gdb is connected to the kernel. Kdb does not make use of the kgdbcon feature."
msgstr ""

#: ../../../process/debugging/kgdb.rst:322
msgid ""
"Kgdb supports using the gdb serial protocol to send console messages to the "
"debugger when the debugger is connected and running. There are two ways to "
"activate this feature."
msgstr ""

#: ../../../process/debugging/kgdb.rst:326
msgid "Activate with the kernel command line option::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:330
msgid "Use sysfs before configuring an I/O driver::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:336
msgid ""
"If you do this after you configure the kgdb I/O driver, the setting will not "
"take effect until the next point the I/O is reconfigured."
msgstr ""

#: ../../../process/debugging/kgdb.rst:342
msgid ""
"You cannot use kgdboc + kgdbcon on a tty that is an active system console. "
"An example of incorrect usage is::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:347
msgid ""
"It is possible to use this option with kgdboc on a tty that is not a system "
"console."
msgstr ""

#: ../../../process/debugging/kgdb.rst:351
msgid "Run time parameter: ``kgdbreboot``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:353
msgid ""
"The kgdbreboot feature allows you to change how the debugger deals with the "
"reboot notification. You have 3 choices for the behavior. The default "
"behavior is always set to 0."
msgstr ""

#: ../../../process/debugging/kgdb.rst:362
msgid "1"
msgstr ""

#: ../../../process/debugging/kgdb.rst:363
msgid "``echo -1 > /sys/module/debug_core/parameters/kgdbreboot``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:364
msgid "Ignore the reboot notification entirely."
msgstr ""

#: ../../../process/debugging/kgdb.rst:366
msgid "2"
msgstr ""

#: ../../../process/debugging/kgdb.rst:367
msgid "``echo 0 > /sys/module/debug_core/parameters/kgdbreboot``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:368
msgid "Send the detach message to any attached debugger client."
msgstr ""

#: ../../../process/debugging/kgdb.rst:370
msgid "3"
msgstr ""

#: ../../../process/debugging/kgdb.rst:371
msgid "``echo 1 > /sys/module/debug_core/parameters/kgdbreboot``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:372
msgid "Enter the debugger on reboot notify."
msgstr ""

#: ../../../process/debugging/kgdb.rst:375
msgid "Kernel parameter: ``nokaslr``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:377
msgid ""
"If the architecture that you are using enables KASLR by default, you should "
"consider turning it off.  KASLR randomizes the virtual address where the "
"kernel image is mapped and confuses gdb which resolves addresses of kernel "
"symbols from the symbol table of vmlinux."
msgstr ""

#: ../../../process/debugging/kgdb.rst:384
msgid "Using kdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:387
msgid "Quick start for kdb on a serial port"
msgstr ""

#: ../../../process/debugging/kgdb.rst:389
msgid "This is a quick example of how to use kdb."
msgstr ""

#: ../../../process/debugging/kgdb.rst:391
#: ../../../process/debugging/kgdb.rst:451
#: ../../../process/debugging/kgdb.rst:520
msgid "Configure kgdboc at boot using kernel parameters::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:395
#: ../../../process/debugging/kgdb.rst:455
#: ../../../process/debugging/kgdb.rst:524
msgid "OR"
msgstr ""

#: ../../../process/debugging/kgdb.rst:397
msgid ""
"Configure kgdboc after the kernel has booted; assuming you are using a "
"serial port console::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:402
#: ../../../process/debugging/kgdb.rst:461
msgid ""
"Enter the kernel debugger manually or by waiting for an oops or fault. There "
"are several ways you can enter the kernel debugger manually; all involve "
"using the `SysRq-G`, which means you must have enabled "
"``CONFIG_MAGIC_SYSRQ=y`` in your kernel config."
msgstr ""

#: ../../../process/debugging/kgdb.rst:407
#: ../../../process/debugging/kgdb.rst:466
#: ../../../process/debugging/kgdb.rst:538
msgid "When logged in as root or with a super user session you can run::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:411
#: ../../../process/debugging/kgdb.rst:542
msgid "Example using minicom 2.2"
msgstr ""

#: ../../../process/debugging/kgdb.rst:413
#: ../../../process/debugging/kgdb.rst:544
msgid "Press: `CTRL-A` `f` `g`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:415
#: ../../../process/debugging/kgdb.rst:546
msgid ""
"When you have telneted to a terminal server that supports sending a remote "
"break"
msgstr ""

#: ../../../process/debugging/kgdb.rst:418
#: ../../../process/debugging/kgdb.rst:549
msgid "Press: `CTRL-]`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:420
#: ../../../process/debugging/kgdb.rst:551
msgid "Type in: ``send break``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:422
#: ../../../process/debugging/kgdb.rst:553
msgid "Press: `Enter` `g`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:424
msgid ""
"From the kdb prompt you can run the ``help`` command to see a complete list "
"of the commands that are available."
msgstr ""

#: ../../../process/debugging/kgdb.rst:427
msgid "Some useful commands in kdb include:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:430
msgid "``lsmod``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:430
msgid "Shows where kernel modules are loaded"
msgstr ""

#: ../../../process/debugging/kgdb.rst:431
msgid "``ps``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:431
msgid "Displays only the active processes"
msgstr ""

#: ../../../process/debugging/kgdb.rst:432
msgid "``ps A``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:432
msgid "Shows all the processes"
msgstr ""

#: ../../../process/debugging/kgdb.rst:433
msgid "``summary``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:433
msgid "Shows kernel version info and memory usage"
msgstr ""

#: ../../../process/debugging/kgdb.rst:434
msgid "``bt``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:434
msgid "Get a backtrace of the current process using dump_stack()"
msgstr ""

#: ../../../process/debugging/kgdb.rst:435
msgid "``dmesg``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:435
msgid "View the kernel syslog buffer"
msgstr ""

#: ../../../process/debugging/kgdb.rst:436
msgid "``go``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:436
msgid "Continue the system"
msgstr ""

#: ../../../process/debugging/kgdb.rst:439
msgid ""
"When you are done using kdb you need to consider rebooting the system or "
"using the ``go`` command to resuming normal kernel execution. If you have "
"paused the kernel for a lengthy period of time, applications that rely on "
"timely networking or anything to do with real wall clock time could be "
"adversely affected, so you should take this into consideration when using "
"the kernel debugger."
msgstr ""

#: ../../../process/debugging/kgdb.rst:447
msgid "Quick start for kdb using a keyboard connected console"
msgstr ""

#: ../../../process/debugging/kgdb.rst:449
msgid "This is a quick example of how to use kdb with a keyboard."
msgstr ""

#: ../../../process/debugging/kgdb.rst:457
#: ../../../process/debugging/kgdb.rst:526
msgid "Configure kgdboc after the kernel has booted::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:470
msgid "Example using a laptop keyboard:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:472
#: ../../../process/debugging/kgdb.rst:486
msgid "Press and hold down: `Alt`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:474
msgid "Press and hold down: `Fn`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:476
#: ../../../process/debugging/kgdb.rst:488
msgid "Press and release the key with the label: `SysRq`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:478
msgid "Release: `Fn`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:480
#: ../../../process/debugging/kgdb.rst:490
msgid "Press and release: `g`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:482
#: ../../../process/debugging/kgdb.rst:492
msgid "Release: `Alt`"
msgstr ""

#: ../../../process/debugging/kgdb.rst:484
msgid "Example using a PS/2 101-key keyboard"
msgstr ""

#: ../../../process/debugging/kgdb.rst:494
msgid ""
"Now type in a kdb command such as ``help``, ``dmesg``, ``bt`` or ``go`` to "
"continue kernel execution."
msgstr ""

#: ../../../process/debugging/kgdb.rst:498
msgid "Using kgdb / gdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:500
msgid ""
"In order to use kgdb you must activate it by passing configuration "
"information to one of the kgdb I/O drivers. If you do not pass any "
"configuration information kgdb will not do anything at all. Kgdb will only "
"actively hook up to the kernel trap hooks if a kgdb I/O driver is loaded and "
"configured. If you unconfigure a kgdb I/O driver, kgdb will unregister all "
"the kernel hook points."
msgstr ""

#: ../../../process/debugging/kgdb.rst:507
msgid ""
"All kgdb I/O drivers can be reconfigured at run time, if ``CONFIG_SYSFS`` "
"and ``CONFIG_MODULES`` are enabled, by echo'ing a new config string to ``/"
"sys/module/<driver>/parameter/<option>``. The driver can be unconfigured by "
"passing an empty string. You cannot change the configuration while the "
"debugger is attached. Make sure to detach the debugger with the ``detach`` "
"command prior to trying to unconfigure a kgdb I/O driver."
msgstr ""

#: ../../../process/debugging/kgdb.rst:516
msgid "Connecting with gdb to a serial port"
msgstr ""

#: ../../../process/debugging/kgdb.rst:518
msgid "Configure kgdboc"
msgstr ""

#: ../../../process/debugging/kgdb.rst:530
msgid "Stop kernel execution (break into the debugger)"
msgstr ""

#: ../../../process/debugging/kgdb.rst:532
msgid ""
"In order to connect to gdb via kgdboc, the kernel must first be stopped. "
"There are several ways to stop the kernel which include using kgdbwait as a "
"boot argument, via a `SysRq-G`, or running the kernel until it takes an "
"exception where it waits for the debugger to attach."
msgstr ""

#: ../../../process/debugging/kgdb.rst:555
msgid "Connect from gdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:557
msgid "Example (using a directly connected port)::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:564
msgid "Example (kgdb to a terminal server on TCP port 2012)::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:570
msgid ""
"Once connected, you can debug a kernel the way you would debug an "
"application program."
msgstr ""

#: ../../../process/debugging/kgdb.rst:573
msgid ""
"If you are having problems connecting or something is going seriously wrong "
"while debugging, it will most often be the case that you want to enable gdb "
"to be verbose about its target communications. You do this prior to issuing "
"the ``target remote`` command by typing in::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:580
msgid ""
"Remember if you continue in gdb, and need to \"break in\" again, you need to "
"issue an other `SysRq-G`. It is easy to create a simple entry point by "
"putting a breakpoint at ``sys_sync`` and then you can run ``sync`` from a "
"shell or script to break into the debugger."
msgstr ""

#: ../../../process/debugging/kgdb.rst:586
msgid "kgdb and kdb interoperability"
msgstr ""

#: ../../../process/debugging/kgdb.rst:588
msgid ""
"It is possible to transition between kdb and kgdb dynamically. The debug "
"core will remember which you used the last time and automatically start in "
"the same mode."
msgstr ""

#: ../../../process/debugging/kgdb.rst:593
msgid "Switching between kdb and kgdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:596
msgid "Switching from kgdb to kdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:598
msgid ""
"There are two ways to switch from kgdb to kdb: you can use gdb to issue a "
"maintenance packet, or you can blindly type the command ``$3#33``. Whenever "
"the kernel debugger stops in kgdb mode it will print the message ``KGDB or "
"$3#33 for KDB``. It is important to note that you have to type the sequence "
"correctly in one pass. You cannot type a backspace or delete because kgdb "
"will interpret that as part of the debug stream."
msgstr ""

#: ../../../process/debugging/kgdb.rst:605
msgid "Change from kgdb to kdb by blindly typing::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:609
msgid "Change from kgdb to kdb with gdb::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:615
msgid ""
"Now you must kill gdb. Typically you press `CTRL-Z` and issue the command::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:621
msgid "Change from kdb to kgdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:623
msgid ""
"There are two ways you can change from kdb to kgdb. You can manually enter "
"kgdb mode by issuing the kgdb command from the kdb shell prompt, or you can "
"connect gdb while the kdb shell prompt is active. The kdb shell looks for "
"the typical first commands that gdb would issue with the gdb remote protocol "
"and if it sees one of those commands it automatically changes into kgdb mode."
msgstr ""

#: ../../../process/debugging/kgdb.rst:630
msgid "From kdb issue the command::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:634
msgid ""
"At the kdb prompt, disconnect the terminal program and connect gdb in its "
"place."
msgstr ""

#: ../../../process/debugging/kgdb.rst:638
msgid "Running kdb commands from gdb"
msgstr ""

#: ../../../process/debugging/kgdb.rst:640
msgid ""
"It is possible to run a limited set of kdb commands from gdb, using the gdb "
"monitor command. You don't want to execute any of the run control or "
"breakpoint operations, because it can disrupt the state of the kernel "
"debugger. You should be using gdb for breakpoints and run control operations "
"if you have gdb connected. The more useful commands to run are things like "
"lsmod, dmesg, ps or possibly some of the memory information commands. To see "
"all the kdb commands you can run ``monitor help``."
msgstr ""

#: ../../../process/debugging/kgdb.rst:663
msgid "kgdb Test Suite"
msgstr ""

#: ../../../process/debugging/kgdb.rst:665
msgid ""
"When kgdb is enabled in the kernel config you can also elect to enable the "
"config parameter ``KGDB_TESTS``. Turning this on will enable a special kgdb "
"I/O module which is designed to test the kgdb internal functions."
msgstr ""

#: ../../../process/debugging/kgdb.rst:669
msgid ""
"The kgdb tests are mainly intended for developers to test the kgdb internals "
"as well as a tool for developing a new kgdb architecture specific "
"implementation. These tests are not really for end users of the Linux "
"kernel. The primary source of documentation would be to look in the "
"``drivers/misc/kgdbts.c`` file."
msgstr ""

#: ../../../process/debugging/kgdb.rst:675
msgid ""
"The kgdb test suite can also be configured at compile time to run the core "
"set of tests by setting the kernel config parameter ``KGDB_TESTS_ON_BOOT``. "
"This particular option is aimed at automated regression testing and does not "
"require modifying the kernel boot config arguments. If this is turned on, "
"the kgdb test suite can be disabled by specifying ``kgdbts=`` as a kernel "
"boot argument."
msgstr ""

#: ../../../process/debugging/kgdb.rst:683
msgid "Kernel Debugger Internals"
msgstr ""

#: ../../../process/debugging/kgdb.rst:686
msgid "Architecture Specifics"
msgstr ""

#: ../../../process/debugging/kgdb.rst:688
msgid "The kernel debugger is organized into a number of components:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:690
msgid "The debug core"
msgstr ""

#: ../../../process/debugging/kgdb.rst:692
msgid ""
"The debug core is found in ``kernel/debugger/debug_core.c``. It contains:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:695
msgid ""
"A generic OS exception handler which includes sync'ing the processors into a "
"stopped state on an multi-CPU system."
msgstr ""

#: ../../../process/debugging/kgdb.rst:698
msgid "The API to talk to the kgdb I/O drivers"
msgstr ""

#: ../../../process/debugging/kgdb.rst:700
msgid "The API to make calls to the arch-specific kgdb implementation"
msgstr ""

#: ../../../process/debugging/kgdb.rst:702
msgid ""
"The logic to perform safe memory reads and writes to memory while using the "
"debugger"
msgstr ""

#: ../../../process/debugging/kgdb.rst:705
msgid ""
"A full implementation for software breakpoints unless overridden by the arch"
msgstr ""

#: ../../../process/debugging/kgdb.rst:708
msgid "The API to invoke either the kdb or kgdb frontend to the debug core."
msgstr ""

#: ../../../process/debugging/kgdb.rst:711
msgid "The structures and callback API for atomic kernel mode setting."
msgstr ""

#: ../../../process/debugging/kgdb.rst:713
msgid "kgdboc is where the kms callbacks are invoked."
msgstr ""

#: ../../../process/debugging/kgdb.rst:715
msgid "kgdb arch-specific implementation"
msgstr ""

#: ../../../process/debugging/kgdb.rst:717
msgid ""
"This implementation is generally found in ``arch/*/kernel/kgdb.c``. As an "
"example, ``arch/x86/kernel/kgdb.c`` contains the specifics to implement HW "
"breakpoint as well as the initialization to dynamically register and "
"unregister for the trap handlers on this architecture. The arch-specific "
"portion implements:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:723
msgid ""
"contains an arch-specific trap catcher which invokes kgdb_handle_exception() "
"to start kgdb about doing its work"
msgstr ""

#: ../../../process/debugging/kgdb.rst:726
msgid "translation to and from gdb specific packet format to struct pt_regs"
msgstr ""

#: ../../../process/debugging/kgdb.rst:728
msgid "Registration and unregistration of architecture specific trap hooks"
msgstr ""

#: ../../../process/debugging/kgdb.rst:731
msgid "Any special exception handling and cleanup"
msgstr ""

#: ../../../process/debugging/kgdb.rst:733
msgid "NMI exception handling and cleanup"
msgstr ""

#: ../../../process/debugging/kgdb.rst:735
msgid "(optional) HW breakpoints"
msgstr ""

#: ../../../process/debugging/kgdb.rst:737
msgid "gdbstub frontend (aka kgdb)"
msgstr ""

#: ../../../process/debugging/kgdb.rst:739
msgid "The gdbstub is located in ``kernel/debug/gdbstub.c``. It contains:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:741
msgid "All the logic to implement the gdb serial protocol"
msgstr ""

#: ../../../process/debugging/kgdb.rst:743
msgid "kdb frontend"
msgstr ""

#: ../../../process/debugging/kgdb.rst:745
msgid ""
"The kdb debugger shell is broken down into a number of components. The kdb "
"core is located in kernel/debug/kdb. There are a number of helper functions "
"in some of the other kernel components to make it possible for kdb to "
"examine and report information about the kernel without taking locks that "
"could cause a kernel deadlock. The kdb core implements the following "
"functionality."
msgstr ""

#: ../../../process/debugging/kgdb.rst:752
msgid "A simple shell"
msgstr ""

#: ../../../process/debugging/kgdb.rst:754
msgid "The kdb core command set"
msgstr ""

#: ../../../process/debugging/kgdb.rst:756
msgid "A registration API to register additional kdb shell commands."
msgstr ""

#: ../../../process/debugging/kgdb.rst:758
msgid ""
"A good example of a self-contained kdb module is the ``ftdump`` command for "
"dumping the ftrace buffer. See: ``kernel/trace/trace_kdb.c``"
msgstr ""

#: ../../../process/debugging/kgdb.rst:762
msgid ""
"For an example of how to dynamically register a new kdb command you can "
"build the kdb_hello.ko kernel module from ``samples/kdb/kdb_hello.c``. To "
"build this example you can set ``CONFIG_SAMPLES=y`` and "
"``CONFIG_SAMPLE_KDB=m`` in your kernel config. Later run ``modprobe "
"kdb_hello`` and the next time you enter the kdb shell, you can run the "
"``hello`` command."
msgstr ""

#: ../../../process/debugging/kgdb.rst:769
msgid ""
"The implementation for kdb_printf() which emits messages directly to I/O "
"drivers, bypassing the kernel log."
msgstr ""

#: ../../../process/debugging/kgdb.rst:772
msgid "SW / HW breakpoint management for the kdb shell"
msgstr ""

#: ../../../process/debugging/kgdb.rst:774
msgid "kgdb I/O driver"
msgstr ""

#: ../../../process/debugging/kgdb.rst:776
msgid ""
"Each kgdb I/O driver has to provide an implementation for the following:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:779
msgid "configuration via built-in or module"
msgstr ""

#: ../../../process/debugging/kgdb.rst:781
msgid "dynamic configuration and kgdb hook registration calls"
msgstr ""

#: ../../../process/debugging/kgdb.rst:783
msgid "read and write character interface"
msgstr ""

#: ../../../process/debugging/kgdb.rst:785
msgid "A cleanup handler for unconfiguring from the kgdb core"
msgstr ""

#: ../../../process/debugging/kgdb.rst:787
msgid "(optional) Early debug methodology"
msgstr ""

#: ../../../process/debugging/kgdb.rst:789
msgid ""
"Any given kgdb I/O driver has to operate very closely with the hardware and "
"must do it in such a way that does not enable interrupts or change other "
"parts of the system context without completely restoring them. The kgdb core "
"will repeatedly \"poll\" a kgdb I/O driver for characters when it needs "
"input. The I/O driver is expected to return immediately if there is no data "
"available. Doing so allows for the future possibility to touch watchdog "
"hardware in such a way as to have a target system not reset when these are "
"enabled."
msgstr ""

#: ../../../process/debugging/kgdb.rst:798
msgid ""
"If you are intent on adding kgdb architecture specific support for a new "
"architecture, the architecture should define ``HAVE_ARCH_KGDB`` in the "
"architecture specific Kconfig file. This will enable kgdb for the "
"architecture, and at that point you must create an architecture specific "
"kgdb implementation."
msgstr ""

#: ../../../process/debugging/kgdb.rst:804
msgid ""
"There are a few flags which must be set on every architecture in their ``asm/"
"kgdb.h`` file. These are:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:807
msgid "``NUMREGBYTES``:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:808
msgid ""
"The size in bytes of all of the registers, so that we can ensure they will "
"all fit into a packet."
msgstr ""

#: ../../../process/debugging/kgdb.rst:811
msgid "``BUFMAX``:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:812
msgid ""
"The size in bytes of the buffer GDB will read into. This must be larger than "
"NUMREGBYTES."
msgstr ""

#: ../../../process/debugging/kgdb.rst:815
msgid "``CACHE_FLUSH_IS_SAFE``:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:816
msgid ""
"Set to 1 if it is always safe to call flush_cache_range or "
"flush_icache_range. On some architectures, these functions may not be safe "
"to call on SMP since we keep other CPUs in a holding pattern."
msgstr ""

#: ../../../process/debugging/kgdb.rst:821
msgid ""
"There are also the following functions for the common backend, found in "
"``kernel/kgdb.c``, that must be supplied by the architecture-specific "
"backend unless marked as (optional), in which case a default function maybe "
"used if the architecture does not need to provide a specific implementation."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:28
msgid "(optional) exit kgdb_handle_exception early"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:32
#: include/linux/kgdb.h:47 include/linux/kgdb.h:112 include/linux/kgdb.h:120
#: include/linux/kgdb.h:128 include/linux/kgdb.h:138 include/linux/kgdb.h:153
#: include/linux/kgdb.h:163 include/linux/kgdb.h:185 include/linux/kgdb.h:196
#: include/linux/kgdb.h:207 include/linux/kgdb.h:220 include/linux/kgdb.h:236
msgid "**Parameters**"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:34
msgid "``int exception``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:29
msgid "Exception vector number"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:31
#: include/linux/kgdb.h:127 include/linux/kgdb.h:152 include/linux/kgdb.h:166
#: include/linux/kgdb.h:222
msgid "``struct pt_regs *regs``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:30
#: include/linux/kgdb.h:217
msgid "Current :c:type:`struct pt_regs <pt_regs>`."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:3
#: include/linux/kgdb.h:32 include/linux/kgdb.h:128 include/linux/kgdb.h:138
#: include/linux/kgdb.h:153 include/linux/kgdb.h:167 include/linux/kgdb.h:195
#: include/linux/kgdb.h:220
msgid "**Description**"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:31
msgid ""
"On some architectures it is required to skip a breakpoint exception when it "
"occurs after a breakpoint has been removed. This can be implemented in the "
"architecture specific portion of kgdb."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:43
msgid "compiled in breakpoint"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:49
#: include/linux/kgdb.h:114 include/linux/kgdb.h:122 include/linux/kgdb.h:209
#: include/linux/kgdb.h:238
msgid "``void``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:1
msgid "no arguments"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:44
msgid ""
"This will be implemented as a static inline per architecture.  This function "
"is called by the kgdb core to execute an architecture specific trap to cause "
"kgdb to enter the exception processing."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:108
#: include/linux/kgdb.h:232
msgid "Perform any architecture specific initialization."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:109
msgid ""
"This function will handle the initialization of any architecture specific "
"callbacks."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:116
msgid "Perform any architecture specific uninitalization."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:117
msgid ""
"This function will handle the uninitalization of any architecture specific "
"callbacks, for dynamic registration and unregistration."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:124
#: include/linux/kgdb.h:134
msgid "Convert ptrace regs to GDB regs"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:130
#: include/linux/kgdb.h:140 include/linux/kgdb.h:155
msgid "``unsigned long *gdb_regs``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:125
#: include/linux/kgdb.h:135
msgid "A pointer to hold the registers in the order GDB wants."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:126
#: include/linux/kgdb.h:165
msgid "The :c:type:`struct pt_regs <pt_regs>` of the current process."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:127
msgid ""
"Convert the pt_regs in **regs** into the format for registers that GDB "
"expects, stored in **gdb_regs**."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:137
msgid "``struct task_struct *p``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:136
msgid "The :c:type:`struct task_struct <task_struct>` of the desired process."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:137
msgid ""
"Convert the register values of the sleeping process in **p** to the format "
"that GDB expects. This function is called when kgdb does not have access to "
"the :c:type:`struct pt_regs <pt_regs>` and therefore it should fill the gdb "
"registers **gdb_regs** with what has been saved in :c:type:`struct "
"thread_struct <thread_struct>` thread field during switch_to."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:149
msgid "Convert GDB regs to ptrace regs."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:150
msgid "A pointer to hold the registers we've received from GDB."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:151
msgid ""
"A pointer to a :c:type:`struct pt_regs <pt_regs>` to hold these values in."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:152
msgid ""
"Convert the GDB regs in **gdb_regs** into the pt_regs, and store them in "
"**regs**."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:159
msgid "Handle architecture specific GDB packets."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:165
msgid "``int vector``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:160
msgid "The error vector of the exception that happened."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:162
msgid "``int signo``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:161
msgid "The signal number of the exception that happened."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:163
msgid "``int err_code``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:162
msgid "The error code of the exception that happened."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:164
#: include/linux/kgdb.h:187
msgid "``char *remcom_in_buffer``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:163
#: include/linux/kgdb.h:183
msgid "The buffer of the packet we have read."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:165
#: include/linux/kgdb.h:185
msgid "``char *remcom_out_buffer``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:164
#: include/linux/kgdb.h:184
msgid "The buffer of ``BUFMAX`` bytes to write a packet into."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:166
msgid ""
"This function MUST handle the 'c' and 's' command packets, as well packets "
"to set / remove a hardware breakpoint, if used. If there are additional "
"packets which the hardware needs to handle, they are handled here.  The code "
"should return -1 if it wants to process more packets, and a ``0`` or ``1`` "
"if it wants to exit from the kgdb callback."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:181
msgid "Handle architecture specific GDB XML packets."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:192
msgid "Call kgdb_nmicallback() on the current CPU"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:198
msgid "``void *ignored``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:193
msgid "This parameter is only here to match the prototype."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:194
msgid ""
"If you're using the default implementation of kgdb_roundup_cpus() this "
"function will be called per CPU.  If you don't implement "
"kgdb_call_nmi_hook() a default will be used."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:203
msgid "Get other CPUs into a holding pattern"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:204
msgid ""
"On SMP systems, we need to get the attention of the other CPUs and get them "
"into a known state.  This should do what is needed to get the other CPUs to "
"call kgdb_wait(). Note that on some arches, the NMI approach is not used for "
"rounding up all the CPUs.  Normally those architectures can just not "
"implement this and get the default."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:210
msgid "On non-SMP systems, this is not called."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:216
msgid "Generic call back to the program counter"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:219
msgid "``unsigned long pc``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:218
msgid "The new value for the program counter"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:219
msgid ""
"This function handles updating the program counter and requires an "
"architecture specific implementation."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:233
msgid ""
"This function will handle the late initialization of any architecture "
"specific callbacks.  This is an optional function for handling things like "
"late initialization of hw breakpoints.  The default implementation does "
"nothing."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:243
msgid "Describe architecture specific values."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:247
#: include/linux/kgdb.h:279
msgid "**Definition**::"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:261
#: include/linux/kgdb.h:293
msgid "**Members**"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:244
msgid "``gdb_bpt_instr``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:245
msgid "The instruction to trigger a breakpoint."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:245
msgid "``flags``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:246
msgid "Flags for the breakpoint, currently just ``KGDB_HW_BREAKPOINT``."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:246
msgid "``set_breakpoint``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:247
msgid "Allow an architecture to specify how to set a software breakpoint."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:248
msgid "``remove_breakpoint``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:249
msgid "Allow an architecture to specify how to remove a software breakpoint."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:250
msgid "``set_hw_breakpoint``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:251
msgid "Allow an architecture to specify how to set a hardware breakpoint."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:252
msgid "``remove_hw_breakpoint``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:253
msgid "Allow an architecture to specify how to remove a hardware breakpoint."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:254
msgid "``disable_hw_break``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:255
msgid ""
"Allow an architecture to specify how to disable hardware breakpoints for a "
"single cpu."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:256
msgid "``remove_all_hw_break``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:257
msgid ""
"Allow an architecture to specify how to remove all hardware breakpoints."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:258
msgid "``correct_hw_break``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:259
msgid ""
"Allow an architecture to specify how to correct the hardware debug registers."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:275
msgid "Describe the interface for an I/O driver to talk with KGDB."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:276
msgid "``name``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:277
msgid "Name of the I/O driver."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:277
msgid "``read_char``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:278
msgid "Pointer to a function that will return one char."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:278
msgid "``write_char``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:279
msgid "Pointer to a function that will write one char."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:279
msgid "``flush``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:280
msgid "Pointer to a function that will flush any pending writes."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:280
msgid "``init``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:281
msgid "Pointer to a function that will initialize the device."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:281
msgid "``deinit``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:282
msgid ""
"Pointer to a function that will deinit the device. Implies that this I/O "
"driver is temporary and expects to be replaced. Called when an I/O driver is "
"replaced or explicitly unregistered."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:284
msgid "``pre_exception``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:285
msgid "Pointer to a function that will do any prep work for the I/O driver."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:286
msgid "``post_exception``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:287
msgid "Pointer to a function that will do any cleanup work for the I/O driver."
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:288
msgid "``cons``"
msgstr ""

#: ../../../process/debugging/kgdb:827: include/linux/kgdb.h:289
msgid "valid if the I/O device is a console; else NULL."
msgstr ""

#: ../../../process/debugging/kgdb.rst:831
msgid "kgdboc internals"
msgstr ""

#: ../../../process/debugging/kgdb.rst:834
msgid "kgdboc and uarts"
msgstr ""

#: ../../../process/debugging/kgdb.rst:836
msgid ""
"The kgdboc driver is actually a very thin driver that relies on the "
"underlying low level to the hardware driver having \"polling hooks\" to "
"which the tty driver is attached. In the initial implementation of kgdboc "
"the serial_core was changed to expose a low level UART hook for doing polled "
"mode reading and writing of a single character while in an atomic context. "
"When kgdb makes an I/O request to the debugger, kgdboc invokes a callback in "
"the serial core which in turn uses the callback in the UART driver."
msgstr ""

#: ../../../process/debugging/kgdb.rst:845
msgid ""
"When using kgdboc with a UART, the UART driver must implement two callbacks "
"in the struct uart_ops. Example from ``drivers/8250.c``::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:856
msgid ""
"Any implementation specifics around creating a polling driver use the "
"``#ifdef CONFIG_CONSOLE_POLL``, as shown above. Keep in mind that polling "
"hooks have to be implemented in such a way that they can be called from an "
"atomic context and have to restore the state of the UART chip on return such "
"that the system can return to normal when the debugger detaches. You need to "
"be very careful with any kind of lock you consider, because failing here is "
"most likely going to mean pressing the reset button."
msgstr ""

#: ../../../process/debugging/kgdb.rst:866
msgid "kgdboc and keyboards"
msgstr ""

#: ../../../process/debugging/kgdb.rst:868
msgid ""
"The kgdboc driver contains logic to configure communications with an "
"attached keyboard. The keyboard infrastructure is only compiled into the "
"kernel when ``CONFIG_KDB_KEYBOARD=y`` is set in the kernel configuration."
msgstr ""

#: ../../../process/debugging/kgdb.rst:872
msgid ""
"The core polled keyboard driver for PS/2 type keyboards is in ``drivers/char/"
"kdb_keyboard.c``. This driver is hooked into the debug core when kgdboc "
"populates the callback in the array called :c:expr:`kdb_poll_funcs[]`. The "
"kdb_get_kbd_char() is the top-level function which polls hardware for single "
"character input."
msgstr ""

#: ../../../process/debugging/kgdb.rst:879
msgid "kgdboc and kms"
msgstr ""

#: ../../../process/debugging/kgdb.rst:881
msgid ""
"The kgdboc driver contains logic to request the graphics display to switch "
"to a text context when you are using ``kgdboc=kms,kbd``, provided that you "
"have a video driver which has a frame buffer console and atomic kernel mode "
"setting support."
msgstr ""

#: ../../../process/debugging/kgdb.rst:886
msgid ""
"Every time the kernel debugger is entered it calls kgdboc_pre_exp_handler() "
"which in turn calls con_debug_enter() in the virtual console layer. On "
"resuming kernel execution, the kernel debugger calls "
"kgdboc_post_exp_handler() which in turn calls con_debug_leave()."
msgstr ""

#: ../../../process/debugging/kgdb.rst:892
msgid ""
"Any video driver that wants to be compatible with the kernel debugger and "
"the atomic kms callbacks must implement the ``mode_set_base_atomic``, "
"``fb_debug_enter`` and ``fb_debug_leave operations``. For the "
"``fb_debug_enter`` and ``fb_debug_leave`` the option exists to use the "
"generic drm fb helper functions or implement something custom for the "
"hardware. The following example shows the initialization of the ."
"mode_set_base_atomic operation in drivers/gpu/drm/i915/intel_display.c::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:909
msgid ""
"Here is an example of how the i915 driver initializes the fb_debug_enter and "
"fb_debug_leave functions to use the generic drm helpers in ``drivers/gpu/drm/"
"i915/intel_fb.c``::"
msgstr ""

#: ../../../process/debugging/kgdb.rst:923
msgid "Credits"
msgstr ""

#: ../../../process/debugging/kgdb.rst:925
msgid "The following people have contributed to this document:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:927
msgid "Amit Kale <amitkale@linsyssoft.com>"
msgstr ""

#: ../../../process/debugging/kgdb.rst:929
msgid "Tom Rini <trini@kernel.crashing.org>"
msgstr ""

#: ../../../process/debugging/kgdb.rst:931
msgid "In March 2008 this document was completely rewritten by:"
msgstr ""

#: ../../../process/debugging/kgdb.rst:933
#: ../../../process/debugging/kgdb.rst:937
msgid "Jason Wessel <jason.wessel@windriver.com>"
msgstr ""

#: ../../../process/debugging/kgdb.rst:935
msgid "In Jan 2010 this document was updated to include kdb."
msgstr ""
