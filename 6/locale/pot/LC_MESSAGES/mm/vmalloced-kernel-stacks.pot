# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/vmalloced-kernel-stacks.rst:5
msgid "Virtually Mapped Kernel Stack Support"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:0
msgid "Author"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:7
msgid "Shuah Khan <skhan@linuxfoundation.org>"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:12
msgid "Overview"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:14
msgid ""
"This is a compilation of information from the code and original patch series "
"that introduced the `Virtually Mapped Kernel Stacks feature <https://lwn.net/"
"Articles/694348/>`"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:19
msgid "Introduction"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:21
msgid ""
"Kernel stack overflows are often hard to debug and make the kernel "
"susceptible to exploits. Problems could show up at a later time making it "
"difficult to isolate and root-cause."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:25
msgid ""
"Virtually mapped kernel stacks with guard pages cause kernel stack overflows "
"to be caught immediately rather than causing difficult to diagnose "
"corruptions."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:29
msgid ""
"HAVE_ARCH_VMAP_STACK and VMAP_STACK configuration options enable support for "
"virtually mapped stacks with guard pages. This feature causes reliable "
"faults when the stack overflows. The usability of the stack trace after "
"overflow and response to the overflow itself is architecture dependent."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:36
msgid ""
"As of this writing, arm64, powerpc, riscv, s390, um, and x86 have support "
"for VMAP_STACK."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:40
msgid "HAVE_ARCH_VMAP_STACK"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:42
msgid ""
"Architectures that can support Virtually Mapped Kernel Stacks should enable "
"this bool configuration option. The requirements are:"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:45
msgid ""
"vmalloc space must be large enough to hold many kernel stacks. This may rule "
"out many 32-bit architectures."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:47
msgid ""
"Stacks in vmalloc space need to work reliably.  For example, if vmap page "
"tables are created on demand, either this mechanism needs to work while the "
"stack points to a virtual address with unpopulated page tables or arch code "
"(switch_to() and switch_mm(), most likely) needs to ensure that the stack's "
"page table entries are populated before running on a possibly unpopulated "
"stack."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:53
msgid ""
"If the stack overflows into a guard page, something reasonable should "
"happen. The definition of \"reasonable\" is flexible, but instantly "
"rebooting without logging anything would be unfriendly."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:58
msgid "VMAP_STACK"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:60
msgid ""
"When enabled, the VMAP_STACK bool configuration option allocates virtually "
"mapped task stacks. This option depends on HAVE_ARCH_VMAP_STACK."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:63
msgid ""
"Enable this if you want the use virtually-mapped kernel stacks with guard "
"pages. This causes kernel stack overflows to be caught immediately rather "
"than causing difficult-to-diagnose corruption."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:69
msgid ""
"Using this feature with KASAN requires architecture support for backing "
"virtual mappings with real shadow memory, and KASAN_VMALLOC must be enabled."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:75
msgid ""
"VMAP_STACK is enabled, it is not possible to run DMA on stack allocated data."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:78
msgid ""
"Kernel configuration options and dependencies keep changing. Refer to the "
"latest code base:"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:81
msgid ""
"`Kconfig <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/"
"tree/arch/Kconfig>`"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:84
msgid "Allocation"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:86
msgid ""
"When a new kernel thread is created, a thread stack is allocated from "
"virtually contiguous memory pages from the page level allocator. These pages "
"are mapped into contiguous kernel virtual space with PAGE_KERNEL protections."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:91
msgid ""
"alloc_thread_stack_node() calls __vmalloc_node_range() to allocate stack "
"with PAGE_KERNEL protections."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:94
msgid ""
"Allocated stacks are cached and later reused by new threads, so memcg "
"accounting is performed manually on assigning/releasing stacks to tasks. "
"Hence, __vmalloc_node_range is called without __GFP_ACCOUNT."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:97
msgid ""
"vm_struct is cached to be able to find when thread free is initiated in "
"interrupt context. free_thread_stack() can be called in interrupt context."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:100
msgid ""
"On arm64, all VMAP's stacks need to have the same alignment to ensure that "
"VMAP'd stack overflow detection works correctly. Arch specific vmap stack "
"allocator takes care of this detail."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:103
msgid ""
"This does not address interrupt stacks - according to the original patch"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:105
msgid ""
"Thread stack allocation is initiated from clone(), fork(), vfork(), "
"kernel_thread() via kernel_clone(). These are a few hints for searching the "
"code base to understand when and how a thread stack is allocated."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:109
msgid ""
"Bulk of the code is in: `kernel/fork.c <https://git.kernel.org/pub/scm/linux/"
"kernel/git/torvalds/linux.git/tree/kernel/fork.c>`."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:112
msgid ""
"stack_vm_area pointer in task_struct keeps track of the virtually allocated "
"stack and a non-null stack_vm_area pointer serves as an indication that the "
"virtually mapped kernel stacks are enabled."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:121
msgid "Stack overflow handling"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:123
msgid ""
"Leading and trailing guard pages help detect stack overflows. When the stack "
"overflows into the guard pages, handlers have to be careful not to overflow "
"the stack again. When handlers are called, it is likely that very little "
"stack space is left."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:128
msgid ""
"On x86, this is done by handling the page fault indicating the kernel stack "
"overflow on the double-fault stack."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:132
msgid "Testing VMAP allocation with guard pages"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:134
msgid ""
"How do we ensure that VMAP_STACK is actually allocating with a leading and "
"trailing guard page? The following lkdtm tests can help detect any "
"regressions."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:144
msgid "Conclusions"
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:146
msgid ""
"A percpu cache of vmalloced stacks appears to be a bit faster than a high-"
"order stack allocation, at least when the cache hits."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:148
msgid ""
"THREAD_INFO_IN_TASK gets rid of arch-specific thread_info entirely and "
"simply embed the thread_info (containing only flags) and 'int cpu' into "
"task_struct."
msgstr ""

#: ../../../mm/vmalloced-kernel-stacks.rst:151
msgid ""
"The thread stack can be freed as soon as the task is dead (without waiting "
"for RCU) and then, if vmapped stacks are in use, cache the entire stack for "
"reuse on the same cpu."
msgstr ""
