# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/damon/api.rst:5
msgid "API Reference"
msgstr ""

#: ../../../mm/damon/api.rst:7
msgid ""
"Kernel space programs can use every feature of DAMON using below APIs.  All "
"you need to do is including ``damon.h``, which is located in ``include/linux/"
"`` of the source tree."
msgstr ""

#: ../../../mm/damon/api.rst:12
msgid "Structures"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:29
msgid "Represents an address region of [**start**, **end**)."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:33 include/linux/damon.h:43
#: include/linux/damon.h:53 include/linux/damon.h:93 include/linux/damon.h:167
#: include/linux/damon.h:197 include/linux/damon.h:281
#: include/linux/damon.h:309 include/linux/damon.h:380
#: include/linux/damon.h:415 include/linux/damon.h:437
#: include/linux/damon.h:455 include/linux/damon.h:471
#: include/linux/damon.h:573 include/linux/damon.h:664
#: include/linux/damon.h:689 include/linux/damon.h:731
msgid "**Definition**::"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:40 include/linux/damon.h:50
#: include/linux/damon.h:64 include/linux/damon.h:102 include/linux/damon.h:180
#: include/linux/damon.h:210 include/linux/damon.h:291
#: include/linux/damon.h:320 include/linux/damon.h:395
#: include/linux/damon.h:422 include/linux/damon.h:448
#: include/linux/damon.h:463 include/linux/damon.h:492
#: include/linux/damon.h:588 include/linux/damon.h:673
#: include/linux/damon.h:700 include/linux/damon.h:742
msgid "**Members**"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:30
msgid "``start``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:31
msgid "Start address of the region (inclusive)."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:31
msgid "``end``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:32
msgid "End address of the region (exclusive)."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:39
msgid "Represents size for filter to operate on [**min**, **max**]."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:40
msgid "``min``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:41
msgid "Min size (inclusive)."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:41
msgid "``max``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:42
msgid "Max size (inclusive)."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:49
msgid "Represents a monitoring target region."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:50
msgid "``ar``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:51
msgid "The address range of the region."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:51
msgid "``sampling_addr``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:52
msgid "Address of the sample for the next access check."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:52
msgid "``nr_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:53
msgid "Access frequency of this region."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:53
msgid "``nr_accesses_bp``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:54
msgid ""
"**nr_accesses** in basis point (0.01%) that updated for each sampling "
"interval."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:55 include/linux/damon.h:93
#: include/linux/damon.h:169 include/linux/damon.h:386
#: include/linux/damon.h:479
msgid "``list``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:56 include/linux/damon.h:94
#: include/linux/damon.h:170 include/linux/damon.h:387
#: include/linux/damon.h:480
msgid "List head for siblings."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:56
msgid "``age``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:57
msgid "Age of this region."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:60 include/linux/damon.h:97
#: include/linux/damon.h:147 include/linux/damon.h:165
#: include/linux/damon.h:173 include/linux/damon.h:206
#: include/linux/damon.h:286 include/linux/damon.h:316
#: include/linux/damon.h:374 include/linux/damon.h:390
#: include/linux/damon.h:418 include/linux/damon.h:458
#: include/linux/damon.h:483 include/linux/damon.h:584
#: include/linux/damon.h:669 include/linux/damon.h:698
#: include/linux/damon.h:757 ../../../mm/damon/api:20: mm/damon/core.c:68
#: mm/damon/core.c:95 mm/damon/core.c:682 mm/damon/core.c:731
#: mm/damon/core.c:788 mm/damon/core.c:1200 mm/damon/core.c:1305
#: mm/damon/core.c:1403 mm/damon/core.c:1442 mm/damon/core.c:2736
#: mm/damon/core.c:2807
msgid "**Description**"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:57
msgid ""
"**nr_accesses** is reset to zero for every :c:type:`damon_attrs-"
">aggr_interval <damon_attrs>` and be increased for every :c:type:"
"`damon_attrs->sample_interval <damon_attrs>` if an access to the region "
"during the last sampling interval is found.  The update of this field should "
"not be done with direct access but with the helper function, "
"damon_update_region_access_rate()."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:63
msgid ""
"**nr_accesses_bp** is another representation of **nr_accesses** in basis "
"point (1 in 10,000) that updated for every :c:type:`damon_attrs-"
">sample_interval <damon_attrs>` in a manner similar to moving sum.  By the "
"algorithm, this value becomes **nr_accesses** * 10000 for every :c:type:"
"`struct damon_attrs <damon_attrs>`->aggr_interval.  This can be used when "
"the aggregation interval is too huge and therefore cannot wait for it before "
"getting the access monitoring results."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:70
msgid ""
"**age** is initially zero, increased for each aggregation interval, and "
"reset to zero again if the access frequency is significantly changed.  If "
"two regions are merged into a new region, both **nr_accesses** and **age** "
"of the new region are set as region size-weighted average of those of the "
"two regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:89
msgid "Represents a monitoring target."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:90
msgid "``pid``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:91
msgid "The PID of the virtual address space to monitor."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:91
msgid "``nr_regions``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:92
msgid "Number of monitoring target regions of this target."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:92
msgid "``regions_list``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:93
msgid "Head of the monitoring target regions of this target."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:94
msgid ""
"Each monitoring context could have multiple targets.  For example, a context "
"for virtual memory address spaces could have multiple target processes.  The "
"**pid** should be set for appropriate :c:type:`struct damon_operations "
"<damon_operations>` including the virtual address spaces monitoring "
"operations."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:108
msgid ""
"Represents an action of a Data Access Monitoring-based Operation Scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:112
#: include/linux/damon.h:148 include/linux/damon.h:268
#: include/linux/damon.h:345 include/linux/damon.h:557
msgid "**Constants**"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:114
msgid "``DAMOS_WILLNEED``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:115
msgid "Call ``madvise()`` for the region with MADV_WILLNEED."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:117
msgid "``DAMOS_COLD``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:118
msgid "Call ``madvise()`` for the region with MADV_COLD."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:120
msgid "``DAMOS_PAGEOUT``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:121
msgid "Call ``madvise()`` for the region with MADV_PAGEOUT."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:123
msgid "``DAMOS_HUGEPAGE``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:124
msgid "Call ``madvise()`` for the region with MADV_HUGEPAGE."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:126
msgid "``DAMOS_NOHUGEPAGE``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:127
msgid "Call ``madvise()`` for the region with MADV_NOHUGEPAGE."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:129
msgid "``DAMOS_LRU_PRIO``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:130
msgid "Prioritize the region on its LRU lists."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:132
msgid "``DAMOS_LRU_DEPRIO``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:133
msgid "Deprioritize the region on its LRU lists."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:135
msgid "``DAMOS_MIGRATE_HOT``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:136
msgid "Migrate the regions prioritizing warmer regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:138
msgid "``DAMOS_MIGRATE_COLD``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:139
msgid "Migrate the regions prioritizing colder regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:141
msgid "``DAMOS_STAT``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:142
msgid "Do nothing but count the stat."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:144
msgid "``NR_DAMOS_ACTIONS``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:145
msgid "Total number of DAMOS actions"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:122
msgid ""
"The support of each action is up to running :c:type:`struct damon_operations "
"<damon_operations>`. :c:type:`enum DAMON_OPS_VADDR <DAMON_OPS_VADDR>` and :c:"
"type:`enum DAMON_OPS_FVADDR <DAMON_OPS_FVADDR>` supports all actions except :"
"c:type:`enum DAMOS_LRU_PRIO <DAMOS_LRU_PRIO>` and :c:type:`enum "
"DAMOS_LRU_DEPRIO <DAMOS_LRU_DEPRIO>`.  :c:type:`enum DAMON_OPS_PADDR "
"<DAMON_OPS_PADDR>` supports only :c:type:`enum DAMOS_PAGEOUT "
"<DAMOS_PAGEOUT>`, :c:type:`enum DAMOS_LRU_PRIO <DAMOS_LRU_PRIO>`, :c:type:"
"`enum DAMOS_LRU_DEPRIO <DAMOS_LRU_DEPRIO>`, and :c:type:`DAMOS_STAT`."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:144
msgid "Represents the metric to be used as the goal"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:150
msgid "``DAMOS_QUOTA_USER_INPUT``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:151
msgid "User-input value."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:153
msgid "``DAMOS_QUOTA_SOME_MEM_PSI_US``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:154
msgid "System level some memory PSI in us."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:156
msgid "``DAMOS_QUOTA_NODE_MEM_USED_BP``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:157
msgid "MemUsed ratio of a node."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:159
msgid "``DAMOS_QUOTA_NODE_MEM_FREE_BP``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:160
msgid "MemFree ratio of a node."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:162
msgid "``NR_DAMOS_QUOTA_GOAL_METRICS``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:163
msgid "Number of DAMOS quota goal metrics."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:151
msgid ""
"Metrics equal to larger than **NR_DAMOS_QUOTA_GOAL_METRICS** are unsupported."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:163
msgid "DAMOS scheme quota auto-tuning goal."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:164
#: include/linux/damon.h:278
msgid "``metric``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:165
msgid "Metric to be used for representing the goal."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:165
msgid "``target_value``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:166
msgid "Target value of **metric** to achieve with the tuning."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:166
msgid "``current_value``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:167
msgid "Current value of **metric**."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:2
msgid "anonymous"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:167
msgid "``last_psi_total``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:168
msgid "Last measured total PSI"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:168
msgid "``nid``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:169
msgid "Node id."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:170
msgid ""
"Data structure for getting the current score of the quota tuning goal.  The "
"score is calculated by how close **current_value** and **target_value** "
"are.  Then the score is entered to DAMON's internal feedback loop mechanism "
"to get the auto-tuned quota."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:175
msgid ""
"If **metric** is DAMOS_QUOTA_USER_INPUT, **current_value** should be "
"manually entered by the user, probably inside the kdamond callbacks.  "
"Otherwise, DAMON sets **current_value** with self-measured value of "
"**metric**."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:193
msgid "Controls the aggressiveness of the given scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:194
msgid "``reset_interval``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:195
msgid "Charge reset interval in milliseconds."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:195
msgid "``ms``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:196
msgid "Maximum milliseconds that the scheme can use."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:196
msgid "``sz``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:197
msgid "Maximum bytes of memory that the action can be applied."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:197
msgid "``goals``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:198
msgid "Head of quota tuning goals (:c:type:`damos_quota_goal`) list."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:198
msgid "``esz``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:199
msgid "Effective size quota in bytes."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:200
msgid "``weight_sz``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:201
msgid "Weight of the region's size for prioritization."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:201
msgid "``weight_nr_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:202
msgid "Weight of the region's nr_accesses for prioritization."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:202
msgid "``weight_age``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:203
msgid "Weight of the region's age for prioritization."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:203
msgid ""
"To avoid consuming too much CPU time or IO resources for applying the :c:"
"type:`struct damos <damos>`->action to large memory, DAMON allows users to "
"set time and/or size quotas.  The quotas can be set by writing non-zero "
"values to :c:type:`ms` and :c:type:`sz`, respectively.  If the time quota is "
"set, DAMON tries to use only up to :c:type:`ms` milliseconds within :c:type:"
"`reset_interval` for applying the action.  If the size quota is set, DAMON "
"tries to apply the action only up to :c:type:`sz` bytes within :c:type:"
"`reset_interval`."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:211
msgid ""
"To convince the different types of quotas and goals, DAMON internally "
"converts those into one single size quota called \"effective quota\".  DAMON "
"internally uses it as the only one real quota.  The conversion is made as "
"follows."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:216
msgid ""
"The time quota is transformed to a size quota using estimated throughput of "
"the scheme's action.  DAMON then compares it against :c:type:`sz` and uses "
"smaller one as the effective quota."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:220
msgid ""
"If **goals** is not empty, DAMON calculates yet another size quota based on "
"the goals using its internal feedback loop algorithm, for every "
"**reset_interval**. Then, if the new size quota is smaller than the "
"effective quota, it uses the new size quota as the effective quota."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:225
msgid "The resulting effective size quota in bytes is set to **esz**."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:227
msgid ""
"For selecting regions within the quota, DAMON prioritizes current scheme's "
"target memory regions using the :c:type:`struct damon_operations "
"<damon_operations>`->get_scheme_score. You could customize the "
"prioritization logic by setting :c:type:`weight_sz`, :c:type:"
"`weight_nr_accesses`, and :c:type:`weight_age`, because monitoring "
"operations are encouraged to respect those."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:264
msgid "Represents the watermark metric."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:270
msgid "``DAMOS_WMARK_NONE``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:271
msgid "Ignore the watermarks of the given scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:273
msgid "``DAMOS_WMARK_FREE_MEM_RATE``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:274
msgid "Free memory rate of the system in [0,1000]."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:276
msgid "``NR_DAMOS_WMARK_METRICS``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:277
msgid "Total number of DAMOS watermark metrics"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:277
msgid "Controls when a given scheme should be activated."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:279
msgid "Metric for the watermarks."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:279
msgid "``interval``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:280
msgid "Watermarks check time interval in microseconds."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:280
msgid "``high``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:281
msgid "High watermark."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:281
msgid "``mid``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:282
msgid "Middle watermark."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:282
msgid "``low``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:283
msgid "Low watermark."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:283
msgid ""
"If :c:type:`metric` is :c:type:`DAMOS_WMARK_NONE`, the scheme is always "
"active.  Being active means DAMON does monitoring and applying the action of "
"the scheme to appropriate memory regions.  Else, DAMON checks :c:type:"
"`metric` of the system for at least every :c:type:`interval` microseconds "
"and works as below."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:288
msgid ""
"If :c:type:`metric` is higher than :c:type:`high`, the scheme is "
"inactivated.  If :c:type:`metric` is between :c:type:`mid` and :c:type:"
"`low`, the scheme is activated.  If :c:type:`metric` is lower than :c:type:"
"`low`, the scheme is inactivated."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:305
msgid "Statistics on a given scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:306
msgid "``nr_tried``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:307
msgid "Total number of regions that the scheme is tried to be applied."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:307
msgid "``sz_tried``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:308
msgid "Total size of regions that the scheme is tried to be applied."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:308
msgid "``nr_applied``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:309
msgid "Total number of regions that the scheme is applied."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:309
msgid "``sz_applied``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:310
msgid "Total size of regions that the scheme is applied."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:310
msgid "``sz_ops_filter_passed``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:311
msgid "Total bytes that passed ops layer-handled DAMOS filters."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:312
msgid "``qt_exceeds``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:313
msgid "Total number of times the quota of the scheme has exceeded."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:313
msgid ""
"\"Tried an action to a region\" in this context means the DAMOS core logic "
"determined the region as eligible to apply the action.  The access pattern (:"
"c:type:`struct damos_access_pattern <damos_access_pattern>`), quotas (:c:"
"type:`struct damos_quota <damos_quota>`), watermarks (:c:type:`struct "
"damos_watermarks <damos_watermarks>`) and filters (:c:type:`struct "
"damos_filter <damos_filter>`) that handled on core logic can affect this.  "
"The core logic asks the operation set (:c:type:`struct damon_operations "
"<damon_operations>`) to apply the action to the region."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:320
msgid ""
"\"Applied an action to a region\" in this context means the operation set (:"
"c:type:`struct damon_operations <damon_operations>`) successfully applied "
"the action to the region, at least to a part of the region.  The filters (:c:"
"type:`struct damos_filter <damos_filter>`) that handled on operation set "
"layer and type of the action and pages of the region can affect this.  For "
"example, if a filter is set to exclude anonymous pages and the region has "
"only anonymous pages, the region will be failed at applying the action.  If "
"the action is :c:type:`DAMOS_PAGEOUT` and all pages of the region are "
"already paged out, the region will be failed at applying the action."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:341
msgid "Type of memory for :c:type:`struct damos_filter <damos_filter>`"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:347
msgid "``DAMOS_FILTER_TYPE_ANON``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:348
msgid "Anonymous pages."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:350
msgid "``DAMOS_FILTER_TYPE_ACTIVE``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:351
msgid "Active pages."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:353
msgid "``DAMOS_FILTER_TYPE_MEMCG``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:354
msgid "Specific memcg's pages."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:356
msgid "``DAMOS_FILTER_TYPE_YOUNG``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:357
msgid "Recently accessed pages."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:359
msgid "``DAMOS_FILTER_TYPE_HUGEPAGE_SIZE``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:360
msgid "Page is part of a hugepage."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:362
msgid "``DAMOS_FILTER_TYPE_UNMAPPED``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:363
msgid "Unmapped pages."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:365
msgid "``DAMOS_FILTER_TYPE_ADDR``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:366
msgid "Address range."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:368
msgid "``DAMOS_FILTER_TYPE_TARGET``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:369
msgid "Data Access Monitoring target."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:371
msgid "``NR_DAMOS_FILTER_TYPES``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:372
msgid "Number of filter types."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:351
msgid ""
"The anon pages type and memcg type filters are handled by underlying :c:type:"
"`struct damon_operations <damon_operations>` as a part of scheme action "
"trying, and therefore accounted as 'tried'.  In contrast, other types are "
"handled by core layer before trying of the action and therefore not "
"accounted as 'tried'."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:356
msgid ""
"The support of the filters that handled by :c:type:`struct damon_operations "
"<damon_operations>` depend on the running :c:type:`struct damon_operations "
"<damon_operations>`. :c:type:`enum DAMON_OPS_PADDR <DAMON_OPS_PADDR>` "
"supports both anon pages type and memcg type filters, while :c:type:`enum "
"DAMON_OPS_VADDR <DAMON_OPS_VADDR>` and :c:type:`enum DAMON_OPS_FVADDR "
"<DAMON_OPS_FVADDR>` don't support any of the two types."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:376
msgid "DAMOS action target memory filter."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:377
msgid "``type``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:378
msgid "Type of the target memory."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:378
msgid "``matching``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:379
msgid "Whether this is for **type**-matching memory."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:379
msgid "``allow``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:380
msgid "Whether to include or exclude the **matching** memory."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:380
msgid "``memcg_id``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:381
msgid "Memcg id of the question if **type** is DAMOS_FILTER_MEMCG."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:381
msgid "``addr_range``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:382
msgid "Address range if **type** is DAMOS_FILTER_TYPE_ADDR."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:382
msgid "``target_idx``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:383
msgid ""
"Index of the :c:type:`struct damon_target <damon_target>` of :c:type:"
"`damon_ctx->adaptive_targets <damon_ctx>` if **type** is "
"DAMOS_FILTER_TYPE_TARGET."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:385
msgid "``sz_range``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:386
msgid "Size range if **type** is DAMOS_FILTER_TYPE_HUGEPAGE_SIZE."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:387
msgid ""
"Before applying the :c:type:`damos->action <damos>` to a memory region, "
"DAMOS checks if each byte of the region matches to this given condition and "
"avoid applying the action if so.  Support of each filter type depends on the "
"running :c:type:`struct damon_operations <damon_operations>` and the type.  "
"Refer to :c:type:`enum damos_filter_type <damos_filter_type>` for more "
"details."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:411
msgid "Control damos_walk()."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:413
msgid "``walk_fn``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:414
msgid "Function to be called back for each region."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:414
msgid "``data``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:415
msgid "Data that will be passed to walk functions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:415
msgid ""
"Control damos_walk(), which requests specific kdamond to invoke the given "
"function to each region that eligible to apply actions of the kdamond's "
"schemes.  Refer to damos_walk() for more details."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:433
msgid "Target access pattern of the given scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:434
msgid "``min_sz_region``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:435
msgid "Minimum size of target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:435
msgid "``max_sz_region``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:436
msgid "Maximum size of target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:436
msgid "``min_nr_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:437
msgid "Minimum ``->nr_accesses`` of target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:437
msgid "``max_nr_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:438
msgid "Maximum ``->nr_accesses`` of target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:438
msgid "``min_age_region``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:439
msgid "Minimum age of target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:439
msgid "``max_age_region``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:440
msgid "Maximum age of target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:451
msgid "Migration destination nodes and their weights."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:452
msgid "``node_id_arr``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:453
msgid "Array of migration destination node ids."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:453
msgid "``weight_arr``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:454
msgid "Array of migration weights for **node_id_arr**."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:454
msgid "``nr_dests``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:455
msgid "Length of the **node_id_arr** and **weight_arr** arrays."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:455
msgid ""
"**node_id_arr** is an array of the ids of migration destination nodes. "
"**weight_arr** is an array of the weights for those.  The weights in "
"**weight_arr** are for nodes in **node_id_arr** of same array index."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:467
msgid "Represents a Data Access Monitoring-based Operation Scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:468
msgid "``pattern``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:469
msgid "Access pattern of target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:469
msgid "``action``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:470
msgid ":c:type:`damos_action` to be applied to the target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:470
msgid "``apply_interval_us``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:471
msgid "The time between applying the **action**."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:471
msgid "``quota``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:472
msgid "Control the aggressiveness of this scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:472
msgid "``wmarks``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:473
msgid "Watermarks for automated (in)activation of this scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:1
msgid "``{unnamed_struct}``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:474
msgid "``target_nid``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:475
msgid "Destination node if **action** is \"migrate_{hot,cold}\"."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:473
msgid "``migrate_dests``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:474
msgid "Destination nodes if **action** is \"migrate_{hot,cold}\"."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:475
msgid "``filters``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:476
msgid ""
"Additional set of :c:type:`struct damos_filter <damos_filter>` for :c:type:"
"`action`."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:476
msgid "``ops_filters``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:477
msgid ""
"ops layer handling :c:type:`struct damos_filter <damos_filter>` objects list."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:477
msgid "``last_applied``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:478
msgid "Last **action** applied ops-managing entity."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:478
msgid "``stat``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:479
msgid "Statistics of this scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:480
msgid ""
"For each **apply_interval_us**, DAMON finds regions which fit in the :c:type:"
"`pattern` and applies :c:type:`action` to those. To avoid consuming too much "
"CPU time or IO resources for the :c:type:`action`, :c:type:`quota` is used."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:484
msgid ""
"If **apply_interval_us** is zero, :c:type:`damon_attrs->aggr_interval "
"<damon_attrs>` is used instead."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:486
msgid ""
"To do the work only when needed, schemes can be activated for specific "
"system situations using :c:type:`wmarks`.  If all schemes that registered to "
"the monitoring context are inactive, DAMON stops monitoring either, and just "
"repeatedly checks the watermarks."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:491
msgid ""
"**migrate_dests** specifies multiple migration target nodes with different "
"weights for migrate_hot or migrate_cold actions.  **target_nid** is ignored "
"if this is set."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:495
msgid ""
"**target_nid** is used to set the migration target node for migrate_hot or "
"migrate_cold actions, and **migrate_dests** is unset."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:498
msgid ""
"Before applying the :c:type:`action` to a memory region, :c:type:`struct "
"damon_operations <damon_operations>` implementation could check pages of the "
"region and skip :c:type:`action` to respect :c:type:`filters`"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:502
msgid ""
"The minimum entity that **action** can be applied depends on the underlying :"
"c:type:`struct damon_operations <damon_operations>`.  Since it may not be "
"aligned with the core layer abstract, namely :c:type:`struct damon_region "
"<damon_region>`, :c:type:`struct damon_operations <damon_operations>` could "
"apply **action** to same entity multiple times.  Large folios that "
"underlying on multiple :c:type:`struct damon <damon>` region objects could "
"be such examples.  The :c:type:`struct damon_operations <damon_operations>` "
"can use **last_applied** to avoid that.  DAMOS core logic unsets "
"**last_applied** when each regions walking for applying the scheme is "
"finished."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:511
msgid ""
"After applying the :c:type:`action` to each region, :c:type:`stat_count` "
"and :c:type:`stat_sz` is updated to reflect the number of regions and total "
"size of regions that the :c:type:`action` is applied."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:553
msgid "Identifier for each monitoring operations implementation"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:559
msgid "``DAMON_OPS_VADDR``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:560
msgid "Monitoring operations for virtual address spaces"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:562
msgid "``DAMON_OPS_FVADDR``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:563
msgid "Monitoring operations for only fixed ranges of virtual address spaces"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:566
msgid "``DAMON_OPS_PADDR``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:567
msgid "Monitoring operations for the physical address space"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:569
msgid "``NR_DAMON_OPS``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:570
msgid "Number of monitoring operations implementations"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:569
msgid "Monitoring operations for given use cases."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:571
msgid "``id``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:572
msgid "Identifier of this operations set."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:572
msgid "``init``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:573
msgid "Initialize operations-related data structures."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:573
msgid "``update``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:574
msgid "Update operations-related data structures."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:574
msgid "``prepare_access_checks``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:575
msgid "Prepare next access check of target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:575
msgid "``check_accesses``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:576
msgid "Check the accesses to target regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:576
msgid "``get_scheme_score``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:577
msgid "Get the score of a region for a scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:577
msgid "``apply_scheme``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:578
msgid "Apply a DAMON-based operation scheme."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:578
msgid "``target_valid``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:579
msgid "Determine if the target is valid."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:579
msgid "``cleanup_target``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:580
msgid "Clean up each target before deallocation."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:580
msgid "``cleanup``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:581
msgid "Clean up the context."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:581
msgid ""
"DAMON can be extended for various address spaces and usages.  For this, "
"users should register the low level operations for their target address "
"space and usecase via the :c:type:`damon_ctx.ops <damon_ctx>`.  Then, the "
"monitoring thread (:c:type:`damon_ctx.kdamond <damon_ctx>`) calls **init** "
"and **prepare_access_checks** before starting the monitoring, **update** "
"after each :c:type:`damon_attrs.ops_update_interval <damon_attrs>`, and "
"**check_accesses**, **target_valid** and **prepare_access_checks** after "
"each :c:type:`damon_attrs.sample_interval <damon_attrs>`."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:589
msgid ""
"Each :c:type:`struct damon_operations <damon_operations>` instance having "
"valid **id** can be registered via damon_register_ops() and selected by "
"damon_select_ops() later. **init** should initialize operations-related data "
"structures.  For example, this could be used to construct proper monitoring "
"target regions and link those to **damon_ctx.adaptive_targets**. **update** "
"should update the operations-related data structures.  For example, this "
"could be used to update monitoring target regions for current status. "
"**prepare_access_checks** should manipulate the monitoring regions to be "
"prepared for the next access check. **check_accesses** should check the "
"accesses to each region that made after the last preparation and update the "
"number of observed accesses of each region. It should also return max number "
"of observed accesses that made as a result of its update.  The value will be "
"used for regions adjustment threshold. **get_scheme_score** should return "
"the priority score of a region for a scheme as an integer in [0, :c:type:"
"`DAMOS_MAX_SCORE`]. **apply_scheme** is called from **kdamond** when a "
"region for user provided DAMON-based operation scheme is found.  It should "
"apply the scheme's action to the region and return bytes of the region that "
"the action is successfully applied.  It should also report how many bytes of "
"the region has passed filters (:c:type:`struct damos_filter <damos_filter>`) "
"that handled by itself. **target_valid** should check whether the target is "
"still valid for the monitoring. **cleanup_target** is called before the "
"target will be deallocated. **cleanup** is called from **kdamond** just "
"before its termination."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:660
msgid "Monitoring intervals auto-tuning goal."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:662
msgid "``access_bp``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:663
msgid "Access events observation ratio to achieve in bp."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:663
msgid "``aggrs``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:664
msgid "Number of aggregations to achieve **access_bp** within."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:664
msgid "``min_sample_us``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:665
msgid "Minimum resulting sampling interval in microseconds."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:665
msgid "``max_sample_us``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:666
msgid "Maximum resulting sampling interval in microseconds."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:666
msgid ""
"DAMON automatically tunes :c:type:`damon_attrs->sample_interval "
"<damon_attrs>` and :c:type:`damon_attrs->aggr_interval <damon_attrs>` aiming "
"the ratio in bp (1/10,000) of DAMON-observed access events to theoretical "
"maximum amount within **aggrs** aggregations be same to **access_bp**.  The "
"logic increases :c:type:`damon_attrs->aggr_interval <damon_attrs>` and :c:"
"type:`damon_attrs->sampling_interval <damon_attrs>` in same ratio if the "
"current access events observation ratio is lower than the target for each "
"**aggrs** aggregations, and vice versa."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:674
msgid ""
"If **aggrs** is zero, the tuning is disabled and hence this struct is "
"ignored."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:685
#: include/linux/damon.h:732
msgid "Monitoring attributes for accuracy/overhead control."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:687
msgid "``sample_interval``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:688
msgid "The time between access samplings."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:688
msgid "``aggr_interval``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:689
msgid "The time between monitor results aggregations."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:689
msgid "``ops_update_interval``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:690
msgid "The time between monitoring operations updates."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:690
msgid "``intervals_goal``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:691
msgid "Intervals auto-tuning goal."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:691
msgid "``min_nr_regions``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:692
msgid "The minimum number of adaptive monitoring regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:693
msgid "``max_nr_regions``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:694
msgid "The maximum number of adaptive monitoring regions."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:695
msgid ""
"For each **sample_interval**, DAMON checks whether each region is accessed "
"or not during the last **sample_interval**.  If such access is found, DAMON "
"aggregates the information by increasing :c:type:`damon_region->nr_accesses "
"<damon_region>` for **aggr_interval** time.  For each **aggr_interval**, the "
"count is reset.  DAMON also checks whether the target memory regions need "
"update (e.g., by ``mmap()`` calls from the application, in case of virtual "
"memory monitoring) and applies the changes for each "
"**ops_update_interval**.  All time intervals are in micro-seconds.  Please "
"refer to :c:type:`struct damon_operations <damon_operations>` and :c:type:"
"`struct damon_call_control <damon_call_control>` for more detail."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:727
msgid ""
"Represents a context for each monitoring. This is the main interface that "
"allows users to set the attributes and get the results of the monitoring."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:731
msgid "``attrs``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:732
msgid "``kdamond``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:733
msgid "Kernel thread who does the monitoring."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:733
msgid "``kdamond_lock``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:734
msgid "Mutex for the synchronizations with **kdamond**."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:750
msgid "``ops``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:751
msgid "Set of monitoring operations for given use cases."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:752
msgid "``adaptive_targets``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:753
msgid "Head of monitoring targets (:c:type:`damon_target`) list."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:753
msgid "``schemes``"
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:754
msgid "Head of schemes (:c:type:`damos`) list."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:734
msgid ""
"For each monitoring context, one kernel thread for the monitoring is "
"created.  The pointer to the thread is stored in **kdamond**."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:737
msgid ""
"Once started, the monitoring thread runs until explicitly required to be "
"terminated or every monitoring target is invalid.  The validity of the "
"targets is checked via the :c:type:`damon_operations.target_valid "
"<damon_operations>` of **ops**.  The termination can also be explicitly "
"requested by calling damon_stop(). The thread sets **kdamond** to NULL when "
"it terminates. Therefore, users can know whether the monitoring is ongoing "
"or terminated by reading **kdamond**. Reads and writes to **kdamond** from "
"outside of the monitoring thread must be protected by **kdamond_lock**."
msgstr ""

#: ../../../mm/damon/api:14: include/linux/damon.h:746
msgid ""
"Note that the monitoring thread protects only **kdamond** via "
"**kdamond_lock**. Accesses to other fields must be protected by themselves."
msgstr ""

#: ../../../mm/damon/api.rst:18
msgid "Functions"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:47
msgid "Check if a given damon_operations is registered."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:51 mm/damon/core.c:69
#: mm/damon/core.c:95 mm/damon/core.c:288 mm/damon/core.c:682
#: mm/damon/core.c:730 mm/damon/core.c:788 mm/damon/core.c:951
#: mm/damon/core.c:1200 mm/damon/core.c:1238 mm/damon/core.c:1304
#: mm/damon/core.c:1367 mm/damon/core.c:1387 mm/damon/core.c:1403
#: mm/damon/core.c:1442 mm/damon/core.c:2734 mm/damon/core.c:2806
msgid "**Parameters**"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:53 mm/damon/core.c:94
msgid "``enum damon_ops_id id``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:48
msgid "Id of the damon_operations to check if registered."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:50 mm/damon/core.c:70
#: mm/damon/core.c:97 mm/damon/core.c:287 mm/damon/core.c:686
#: mm/damon/core.c:1311 mm/damon/core.c:1367 mm/damon/core.c:1386
#: mm/damon/core.c:1414 mm/damon/core.c:1455 mm/damon/core.c:2741
msgid "**Return**"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:50
msgid "true if the ops is set, false otherwise."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:65
msgid "Register a monitoring operations set to DAMON."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:71
msgid "``struct damon_operations *ops``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:66
msgid "monitoring operations set to register."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:67
msgid ""
"This function registers a monitoring operations set of valid :c:type:`struct "
"damon_operations <damon_operations>`->id so that others can find and use "
"them later."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:71 mm/damon/core.c:98
#: mm/damon/core.c:687 mm/damon/core.c:1312 mm/damon/core.c:1367
#: mm/damon/core.c:1415 mm/damon/core.c:1456 mm/damon/core.c:2742
msgid "0 on success, negative error code otherwise."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:91
msgid "Select a monitoring operations to use with the context."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:97 mm/damon/core.c:684
#: mm/damon/core.c:732 mm/damon/core.c:1389 mm/damon/core.c:1405
#: mm/damon/core.c:1444
msgid "``struct damon_ctx *ctx``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:92
msgid "monitoring context to use the operations."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:93
msgid "id of the registered monitoring operations to select."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:94
msgid ""
"This function finds registered monitoring operations set of **id** and make "
"**ctx** to use it."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:284
msgid "Return if the filter is ops-hndled one."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:290
msgid "``enum damos_filter_type type``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:285
msgid "type of the filter."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:287
msgid ""
"true if the filter of **type** needs to be handled by ops layer, false "
"otherwise."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:678
msgid "Set attributes for the monitoring."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:679 mm/damon/core.c:727
msgid "monitoring context"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:681 mm/damon/core.c:2806
msgid "``struct damon_attrs *attrs``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:680
msgid "monitoring attributes"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:681
msgid ""
"This function should be called while the kdamond is not running, an access "
"check results aggregation is not ongoing (e.g., from damon_call()."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:684
msgid "Every time interval is in micro-seconds."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:726
msgid "Set data access monitoring based operation schemes."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:729
msgid "``struct damos **schemes``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:728
msgid "array of the schemes"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:730
msgid "``ssize_t nr_schemes``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:729
msgid "number of entries in **schemes**"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:730
msgid ""
"This function should not be called while the kdamond of the context is "
"running."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:784
msgid "Commit DAMOS quota goals to another quota."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:790
msgid "``struct damos_quota *dst``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:785
msgid "The commit destination DAMOS quota."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:787
msgid "``struct damos_quota *src``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:786
msgid "The commit source DAMOS quota."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:787
msgid ""
"Copies user-specified parameters for quota goals from **src** to **dst**.  "
"Users should use this function for quota goals-level parameters update of "
"running DAMON contexts, instead of manual in-place updates."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:791 mm/damon/core.c:1204
msgid ""
"This function should be called from parameters-update safe context, like "
"damon_call()."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:947
msgid ""
"decide whether to reject memory that didn't match with any given filter."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:953
msgid "``struct list_head *filters``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:949
msgid "Given DAMOS filters of a group."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1196
msgid "Commit parameters of a DAMON context to another."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1202
msgid "``struct damon_ctx *dst``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1197
msgid "The commit destination DAMON context."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1199
msgid "``struct damon_ctx *src``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1198
msgid "The commit source DAMON context."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1199
msgid ""
"This function copies user-specified parameters from **src** to **dst** and "
"update the internal status and results accordingly.  Users should use this "
"function for context-level parameters update of running context, instead of "
"manual in-place updates."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1234
msgid "Return number of currently running contexts."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1240
msgid "``void``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1
msgid "no arguments"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1300
msgid "Starts the monitorings for a given group of contexts."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1306 mm/damon/core.c:1369
msgid "``struct damon_ctx **ctxs``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1301
msgid "an array of the pointers for contexts to start monitoring"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1303 mm/damon/core.c:1366
msgid "``int nr_ctxs``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1302 mm/damon/core.c:1365
msgid "size of **ctxs**"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1304
msgid "``bool exclusive``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1303
msgid "exclusiveness of this contexts group"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1304
msgid ""
"This function starts a group of monitoring threads for a group of monitoring "
"contexts.  One thread per each context is created and run in parallel.  The "
"caller should handle synchronization between the threads by itself.  If "
"**exclusive** is true and a group of threads that created by other "
"'damon_start()' call is currently running, this function does nothing but "
"returns -EBUSY."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1363
msgid "Stops the monitorings for a given group of contexts."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1364
msgid "an array of the pointers for contexts to stop monitoring"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1383
msgid "Returns if a given DAMON context is running."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1384
msgid "The DAMON context to see if running."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1386
msgid "true if **ctx** is running, false otherwise."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1399
msgid "Invoke a given function on DAMON worker thread (kdamond)."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1400
msgid "DAMON context to call the function for."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1402
msgid "``struct damon_call_control *control``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1401
msgid "Control variable of the call request."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1402
msgid ""
"Ask DAMON worker thread (kdamond) of **ctx** to call a function with an "
"argument data that respectively passed via :c:type:`damon_call_control->fn "
"<damon_call_control>` and :c:type:`damon_call_control->data "
"<damon_call_control>` of **control**.  If :c:type:`damon_call_control-"
">repeat <damon_call_control>` of **control** is set, further wait until the "
"kdamond finishes handling of the request.  Otherwise, return as soon as the "
"request is made."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1408
msgid ""
"The kdamond executes the function with the argument in the main loop, just "
"after a sampling of the iteration is finished.  The function can hence "
"safely access the internal data of the :c:type:`struct damon_ctx "
"<damon_ctx>` without additional synchronization.  The return value of the "
"function will be saved in :c:type:`damon_call_control->return_code "
"<damon_call_control>`."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1438
msgid "Invoke a given functions while DAMOS walk regions."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1439
msgid "DAMON context to call the functions for."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1441
msgid "``struct damos_walk_control *control``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1440
msgid "Control variable of the walk request."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1441
msgid ""
"Ask DAMON worker thread (kdamond) of **ctx** to call a function for each "
"region that the kdamond will apply DAMOS action to, and wait until the "
"kdamond finishes handling of the request."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:1445
msgid ""
"The kdamond executes the given function in the main loop, for each region "
"just after it applied any DAMOS actions of **ctx** to it.  The invocation is "
"made only within one :c:type:`damos->apply_interval_us <damos>` since "
"damos_walk() invocation, for each scheme.  The given callback function can "
"hence safely access the internal data of :c:type:`struct damon_ctx "
"<damon_ctx>` and :c:type:`struct damon_region <damon_region>` that each of "
"the scheme will apply the action for next interval, without additional "
"synchronizations against the kdamond.  If every scheme of **ctx** passed at "
"least one :c:type:`damos->apply_interval_us <damos>`, kdamond marks the "
"request as completed so that damos_walk() can wakeup and return."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2730
msgid ""
"Set the region of the given monitoring target as requested, or biggest "
"'System RAM'."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2736
msgid "``struct damon_target *t``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2732
msgid "The monitoring target to set the region."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2734
msgid "``unsigned long *start``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2733
msgid "The pointer to the start address of the region."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2735
msgid "``unsigned long *end``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2734
msgid "The pointer to the end address of the region."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2735
msgid ""
"This function sets the region of **t** as requested by **start** and "
"**end**.  If the values of **start** and **end** are zero, however, this "
"function finds the biggest 'System RAM' resource and sets the region to "
"cover the resource.  In the latter case, this function saves the start and "
"end addresses of the resource in **start** and **end**, respectively."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2802
msgid "Update the access rate of a region."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2808
msgid "``struct damon_region *r``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2803
msgid "The DAMON region to update for its access check result."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2805
msgid "``bool accessed``"
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2804
msgid "Whether the region has accessed during last sampling interval."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2805
msgid "The damon_attrs of the DAMON context."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2806
msgid ""
"Update the access rate of a region with the region's last sampling interval "
"access check result."
msgstr ""

#: ../../../mm/damon/api:20: mm/damon/core.c:2809
msgid ""
"Usually this will be called by :c:type:`damon_operations->check_accesses "
"<damon_operations>` callback."
msgstr ""
