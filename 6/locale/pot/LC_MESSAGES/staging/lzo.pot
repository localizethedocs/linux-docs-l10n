# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../staging/lzo.rst:3
msgid "LZO stream format as understood by Linux's LZO decompressor"
msgstr ""

#: ../../../staging/lzo.rst:6
msgid "Introduction"
msgstr ""

#: ../../../staging/lzo.rst:8
msgid ""
"This is not a specification. No specification seems to be publicly available "
"for the LZO stream format. This document describes what input format the LZO "
"decompressor as implemented in the Linux kernel understands. The file "
"subject of this analysis is lib/lzo/lzo1x_decompress_safe.c. No analysis was "
"made on the compressor nor on any other implementations though it seems "
"likely that the format matches the standard one. The purpose of this "
"document is to better understand what the code does in order to propose more "
"efficient fixes for future bug reports."
msgstr ""

#: ../../../staging/lzo.rst:18
msgid "Description"
msgstr ""

#: ../../../staging/lzo.rst:20
msgid ""
"The stream is composed of a series of instructions, operands, and data. The "
"instructions consist in a few bits representing an opcode, and bits forming "
"the operands for the instruction, whose size and position depend on the "
"opcode and on the number of literals copied by previous instruction. The "
"operands are used to indicate:"
msgstr ""

#: ../../../staging/lzo.rst:26
msgid "a distance when copying data from the dictionary (past output buffer)"
msgstr ""

#: ../../../staging/lzo.rst:27
msgid "a length (number of bytes to copy from dictionary)"
msgstr ""

#: ../../../staging/lzo.rst:28
msgid ""
"the number of literals to copy, which is retained in variable \"state\" as a "
"piece of information for next instructions."
msgstr ""

#: ../../../staging/lzo.rst:31
msgid ""
"Optionally depending on the opcode and operands, extra data may follow. "
"These extra data can be a complement for the operand (eg: a length or a "
"distance encoded on larger values), or a literal to be copied to the output "
"buffer."
msgstr ""

#: ../../../staging/lzo.rst:35
msgid ""
"The first byte of the block follows a different encoding from other bytes, "
"it seems to be optimized for literal use only, since there is no dictionary "
"yet prior to that byte."
msgstr ""

#: ../../../staging/lzo.rst:39
msgid ""
"Lengths are always encoded on a variable size starting with a small number "
"of bits in the operand. If the number of bits isn't enough to represent the "
"length, up to 255 may be added in increments by consuming more bytes with a "
"rate of at most 255 per extra byte (thus the compression ratio cannot exceed "
"around 255:1). The variable length encoding using #bits is always the same::"
msgstr ""

#: ../../../staging/lzo.rst:53
msgid ""
"For references to the dictionary, distances are relative to the output "
"pointer. Distances are encoded using very few bits belonging to certain "
"ranges, resulting in multiple copy instructions using different encodings. "
"Certain encodings involve one extra byte, others involve two extra bytes "
"forming a little-endian 16-bit quantity (marked LE16 below)."
msgstr ""

#: ../../../staging/lzo.rst:59
msgid ""
"After any instruction except the large literal copy, 0, 1, 2 or 3 literals "
"are copied before starting the next instruction. The number of literals that "
"were copied may change the meaning and behaviour of the next instruction. In "
"practice, only one instruction needs to know whether 0, less than 4, or more "
"literals were copied. This is the information stored in the <state> variable "
"in this implementation. This number of immediate literals to be copied is "
"generally encoded in the last two bits of the instruction but may also be "
"taken from the last two bits of an extra operand (eg: distance)."
msgstr ""

#: ../../../staging/lzo.rst:68
msgid ""
"End of stream is declared when a block copy of distance 0 is seen. Only one "
"instruction may encode this distance (0001HLLL), it takes one LE16 operand "
"for the distance, thus requiring 3 bytes."
msgstr ""

#: ../../../staging/lzo.rst:74
msgid ""
"In the code some length checks are missing because certain instructions are "
"called under the assumption that a certain number of bytes follow because it "
"has already been guaranteed before parsing the instructions. They just have "
"to \"refill\" this credit if they consume extra bytes. This is an "
"implementation design choice independent on the algorithm or encoding."
msgstr ""

#: ../../../staging/lzo.rst:81
msgid "Versions"
msgstr ""

#: ../../../staging/lzo.rst:83
msgid "0: Original version 1: LZO-RLE"
msgstr ""

#: ../../../staging/lzo.rst:86
msgid ""
"Version 1 of LZO implements an extension to encode runs of zeros using run "
"length encoding. This improves speed for data with many zeros, which is a "
"common case for zram. This modifies the bitstream in a backwards compatible "
"way (v1 can correctly decompress v0 compressed data, but v0 cannot read v1 "
"data)."
msgstr ""

#: ../../../staging/lzo.rst:91
msgid ""
"For maximum compatibility, both versions are available under different names "
"(lzo and lzo-rle). Differences in the encoding are noted in this document "
"with e.g.: version 1 only."
msgstr ""

#: ../../../staging/lzo.rst:96
msgid "Byte sequences"
msgstr ""

#: ../../../staging/lzo.rst:98
msgid "First byte encoding::"
msgstr ""

#: ../../../staging/lzo.rst:120
msgid "Instruction encoding::"
msgstr ""

#: ../../../staging/lzo.rst:194
msgid "Authors"
msgstr ""

#: ../../../staging/lzo.rst:196
msgid ""
"This document was written by Willy Tarreau <w@1wt.eu> on 2014/07/19 during "
"an analysis of the decompression code available in Linux 3.16-rc5, and "
"updated by Dave Rodgman <dave.rodgman@arm.com> on 2018/10/30 to introduce "
"run-length encoding. The code is tricky, it is possible that this document "
"contains mistakes or that a few corner cases were overlooked. In any case, "
"please report any doubt, fix, or proposed updates to the author(s) so that "
"the document can be updated."
msgstr ""
