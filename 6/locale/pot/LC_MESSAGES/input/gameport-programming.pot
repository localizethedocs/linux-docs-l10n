# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../input/gameport-programming.rst:3
msgid "Programming gameport drivers"
msgstr ""

#: ../../../input/gameport-programming.rst:6
msgid "A basic classic gameport"
msgstr ""

#: ../../../input/gameport-programming.rst:8
msgid ""
"If the gameport doesn't provide more than the inb()/outb() functionality, "
"the code needed to register it with the joystick drivers is simple::"
msgstr ""

#: ../../../input/gameport-programming.rst:16
msgid ""
"Make sure struct gameport is initialized to 0 in all other fields. The "
"gameport generic code will take care of the rest."
msgstr ""

#: ../../../input/gameport-programming.rst:19
msgid ""
"If your hardware supports more than one io address, and your driver can "
"choose which one to program the hardware to, starting from the more exotic "
"addresses is preferred, because the likelihood of clashing with the standard "
"0x201 address is smaller."
msgstr ""

#: ../../../input/gameport-programming.rst:24
msgid ""
"E.g. if your driver supports addresses 0x200, 0x208, 0x210 and 0x218, then "
"0x218 would be the address of first choice."
msgstr ""

#: ../../../input/gameport-programming.rst:27
msgid ""
"If your hardware supports a gameport address that is not mapped to ISA io "
"space (is above 0x1000), use that one, and don't map the ISA mirror."
msgstr ""

#: ../../../input/gameport-programming.rst:30
msgid ""
"Also, always request_region() on the whole io space occupied by the "
"gameport. Although only one ioport is really used, the gameport usually "
"occupies from one to sixteen addresses in the io space."
msgstr ""

#: ../../../input/gameport-programming.rst:34
msgid ""
"Please also consider enabling the gameport on the card in the ->open() "
"callback if the io is mapped to ISA space - this way it'll occupy the io "
"space only when something really is using it. Disable it again in the -"
">close() callback. You also can select the io address in the ->open() "
"callback, so that it doesn't fail if some of the possible addresses are "
"already occupied by other gameports."
msgstr ""

#: ../../../input/gameport-programming.rst:42
msgid "Memory mapped gameport"
msgstr ""

#: ../../../input/gameport-programming.rst:44
msgid ""
"When a gameport can be accessed through MMIO, this way is preferred, because "
"it is faster, allowing more reads per second. Registering such a gameport "
"isn't as easy as a basic IO one, but not so much complex::"
msgstr ""

#: ../../../input/gameport-programming.rst:67
msgid "Cooked mode gameport"
msgstr ""

#: ../../../input/gameport-programming.rst:69
msgid ""
"There are gameports that can report the axis values as numbers, that means "
"the driver doesn't have to measure them the old way - an ADC is built into "
"the gameport. To register a cooked gameport::"
msgstr ""

#: ../../../input/gameport-programming.rst:94
msgid ""
"The only confusing thing here is the fuzz value. Best determined by "
"experimentation, it is the amount of noise in the ADC data. Perfect "
"gameports can set this to zero, most common have fuzz between 8 and 32. See "
"analog.c and input.c for handling of fuzz - the fuzz value determines the "
"size of a gaussian filter window that is used to eliminate the noise in the "
"data."
msgstr ""

#: ../../../input/gameport-programming.rst:102
msgid "More complex gameports"
msgstr ""

#: ../../../input/gameport-programming.rst:104
msgid ""
"Gameports can support both raw and cooked modes. In that case combine either "
"examples 1+2 or 1+3. Gameports can support internal calibration - see below, "
"and also lightning.c and analog.c on how that works. If your driver supports "
"more than one gameport instance simultaneously, use the ->private member of "
"the gameport struct to point to your data."
msgstr ""

#: ../../../input/gameport-programming.rst:111
msgid "Unregistering a gameport"
msgstr ""

#: ../../../input/gameport-programming.rst:113
msgid "Simple::"
msgstr ""

#: ../../../input/gameport-programming.rst:118
msgid "The gameport structure"
msgstr ""

#: ../../../input/gameport-programming.rst:126
msgid ""
"A private pointer for free use in the gameport driver. (Not the joystick "
"driver!)"
msgstr ""

#: ../../../input/gameport-programming.rst:133
msgid ""
"Driver's name as set by driver calling gameport_set_name(). Informational "
"purpose only."
msgstr ""

#: ../../../input/gameport-programming.rst:140
msgid ""
"gameport's physical name/description as set by driver calling "
"gameport_set_phys(). Informational purpose only."
msgstr ""

#: ../../../input/gameport-programming.rst:147
msgid ""
"I/O address for use with raw mode. You have to either set this, or ->read() "
"to some value if your gameport supports raw mode."
msgstr ""

#: ../../../input/gameport-programming.rst:154
msgid "Raw mode speed of the gameport reads in thousands of reads per second."
msgstr ""

#: ../../../input/gameport-programming.rst:160
msgid ""
"If the gameport supports cooked mode, this should be set to a value that "
"represents the amount of noise in the data. See :ref:"
"`gameport_pgm_cooked_mode`."
msgstr ""

#: ../../../input/gameport-programming.rst:168
msgid ""
"Trigger. This function should trigger the ns558 oneshots. If set to NULL, "
"outb(0xff, io) will be used."
msgstr ""

#: ../../../input/gameport-programming.rst:175
msgid ""
"Read the buttons and ns558 oneshot bits. If set to NULL, inb(io) will be "
"used instead."
msgstr ""

#: ../../../input/gameport-programming.rst:182
msgid ""
"If the gameport supports cooked mode, it should point this to its cooked "
"read function. It should fill axes[0..3] with four values of the joystick "
"axes and buttons[0] with four bits representing the buttons."
msgstr ""

#: ../../../input/gameport-programming.rst:190
msgid ""
"Function for calibrating the ADC hardware. When called, axes[0..3] should be "
"pre-filled by cooked data by the caller, max[0..3] should be pre-filled with "
"expected maximums for each axis. The calibrate() function should set the "
"sensitivity of the ADC hardware so that the maximums fit in its range and "
"recompute the axes[] values to match the new sensitivity or re-read them "
"from the hardware so that they give valid values."
msgstr ""

#: ../../../input/gameport-programming.rst:201
msgid ""
"Open() serves two purposes. First a driver either opens the port in raw or "
"in cooked mode, the open() callback can decide which modes are supported. "
"Second, resource allocation can happen here. The port can also be enabled "
"here. Prior to this call, other fields of the gameport struct (namely the io "
"member) need not to be valid."
msgstr ""

#: ../../../input/gameport-programming.rst:211
msgid ""
"Close() should free the resources allocated by open, possibly disabling the "
"gameport."
msgstr ""

#: ../../../input/gameport-programming.rst:227
msgid "For internal use by the gameport layer."
msgstr ""

#: ../../../input/gameport-programming.rst:233
msgid "Enjoy!"
msgstr ""
