# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/drm-vm-bind-async.rst:5 ../../../gpu/drm-vm-bind-async.rst:77
msgid "Asynchronous VM_BIND"
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:8
msgid "Nomenclature:"
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:10
msgid ""
"``VRAM``: On-device memory. Sometimes referred to as device local memory."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:12
msgid ""
"``gpu_vm``: A virtual GPU address space. Typically per process, but can be "
"shared by multiple processes."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:15
msgid ""
"``VM_BIND``: An operation or a list of operations to modify a gpu_vm using "
"an IOCTL. The operations include mapping and unmapping system- or VRAM "
"memory."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:19
msgid ""
"``syncobj``: A container that abstracts synchronization objects. The "
"synchronization objects can be either generic, like dma-fences or driver "
"specific. A syncobj typically indicates the type of the underlying "
"synchronization object."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:24
msgid ""
"``in-syncobj``: Argument to a VM_BIND IOCTL, the VM_BIND operation waits for "
"these before starting."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:27
msgid ""
"``out-syncobj``: Argument to a VM_BIND_IOCTL, the VM_BIND operation signals "
"these when the bind operation is complete."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:30
msgid ""
"``dma-fence``: A cross-driver synchronization object. A basic understanding "
"of dma-fences is required to digest this document. Please refer to the ``DMA "
"Fences`` section of the :doc:`dma-buf doc </driver-api/dma-buf>`."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:35
msgid ""
"``memory fence``: A synchronization object, different from a dma-fence. A "
"memory fence uses the value of a specified memory location to determine "
"signaled status. A memory fence can be awaited and signaled by both the GPU "
"and CPU. Memory fences are sometimes referred to as user-fences, userspace-"
"fences or gpu futexes and do not necessarily obey the dma-fence rule of "
"signaling within a \"reasonable amount of time\". The kernel should thus "
"avoid waiting for memory fences with locks held."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:43
msgid ""
"``long-running workload``: A workload that may take more than the current "
"stipulated dma-fence maximum signal delay to complete and which therefore "
"needs to set the gpu_vm or the GPU execution context in a certain mode that "
"disallows completion dma-fences."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:48
msgid ""
"``exec function``: An exec function is a function that revalidates all "
"affected gpu_vmas, submits a GPU command batch and registers the dma_fence "
"representing the GPU command's activity with all affected dma_resvs. For "
"completeness, although not covered by this document, it's worth mentioning "
"that an exec function may also be the revalidation worker that is used by "
"some drivers in compute / long-running mode."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:56
msgid ""
"``bind context``: A context identifier used for the VM_BIND operation. "
"VM_BIND operations that use the same bind context can be assumed, where it "
"matters, to complete in order of submission. No such assumptions can be made "
"for VM_BIND operations using separate bind contexts."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:61
msgid "``UMD``: User-mode driver."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:63
msgid "``KMD``: Kernel-mode driver."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:67
msgid "Synchronous / Asynchronous VM_BIND operation"
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:70
msgid "Synchronous VM_BIND"
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:71
msgid ""
"With Synchronous VM_BIND, the VM_BIND operations all complete before the "
"IOCTL returns. A synchronous VM_BIND takes neither in-fences nor out-fences. "
"Synchronous VM_BIND may block and wait for GPU operations; for example swap-"
"in or clearing, or even previous binds."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:78
msgid ""
"Asynchronous VM_BIND accepts both in-syncobjs and out-syncobjs. While the "
"IOCTL may return immediately, the VM_BIND operations wait for the in-"
"syncobjs before modifying the GPU page-tables, and signal the out-syncobjs "
"when the modification is done in the sense that the next exec function that "
"awaits for the out-syncobjs will see the change. Errors are reported "
"synchronously. In low-memory situations the implementation may block, "
"performing the VM_BIND synchronously, because there might not be enough "
"memory immediately available for preparing the asynchronous operation."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:88
msgid ""
"If the VM_BIND IOCTL takes a list or an array of operations as an argument, "
"the in-syncobjs needs to signal before the first operation starts to "
"execute, and the out-syncobjs signal after the last operation completes. "
"Operations in the operation list can be assumed, where it matters, to "
"complete in order."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:94
msgid ""
"Since asynchronous VM_BIND operations may use dma-fences embedded in out-"
"syncobjs and internally in KMD to signal bind completion,  any memory fences "
"given as VM_BIND in-fences need to be awaited synchronously before the "
"VM_BIND ioctl returns, since dma-fences, required to signal in a reasonable "
"amount of time, can never be made to depend on memory fences that don't have "
"such a restriction."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:101
msgid ""
"The purpose of an Asynchronous VM_BIND operation is for user-mode drivers to "
"be able to pipeline interleaved gpu_vm modifications and exec functions. For "
"long-running workloads, such pipelining of a bind operation is not allowed "
"and any in-fences need to be awaited synchronously. The reason for this is "
"twofold. First, any memory fences gated by a long-running workload and used "
"as in-syncobjs for the VM_BIND operation will need to be awaited "
"synchronously anyway (see above). Second, any dma-fences used as in-syncobjs "
"for VM_BIND operations for long-running workloads will not allow for "
"pipelining anyway since long-running workloads don't allow for dma-fences as "
"out-syncobjs, so while theoretically possible the use of them is "
"questionable and should be rejected until there is a valuable use-case. Note "
"that this is not a limitation imposed by dma-fence rules, but rather a "
"limitation imposed to keep KMD implementation simple. It does not affect "
"using dma-fences as dependencies for the long-running workload itself, which "
"is allowed by dma-fence rules, but rather for the VM_BIND operation only."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:119
msgid ""
"An asynchronous VM_BIND operation may take substantial time to complete and "
"signal the out_fence. In particular if the operation is deeply pipelined "
"behind other VM_BIND operations and workloads submitted using exec "
"functions. In that case, UMD might want to avoid a subsequent VM_BIND "
"operation to be queued behind the first one if there are no explicit "
"dependencies. In order to circumvent such a queue-up, a VM_BIND "
"implementation may allow for VM_BIND contexts to be created. For each "
"context, VM_BIND operations will be guaranteed to complete in the order they "
"were submitted, but that is not the case for VM_BIND operations executing on "
"separate VM_BIND contexts. Instead KMD will attempt to execute such VM_BIND "
"operations in parallel but leaving no guarantee that they will actually be "
"executed in parallel. There may be internal implicit dependencies that only "
"KMD knows about, for example page-table structure changes. A way to attempt "
"to avoid such internal dependencies is to have different VM_BIND contexts "
"use separate regions of a VM."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:136
msgid ""
"Also for VM_BINDS for long-running gpu_vms the user-mode driver should "
"typically select memory fences as out-fences since that gives greater "
"flexibility for the kernel mode driver to inject other operations into the "
"bind / unbind operations. Like for example inserting breakpoints into batch "
"buffers. The workload execution can then easily be pipelined behind the bind "
"completion using the memory out-fence as the signal condition for a GPU "
"semaphore embedded by UMD in the workload."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:144
msgid ""
"There is no difference in the operations supported or in multi-operation "
"support between asynchronous VM_BIND and synchronous VM_BIND."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:148
msgid "Multi-operation VM_BIND IOCTL error handling and interrupts"
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:150
msgid ""
"The VM_BIND operations of the IOCTL may error for various reasons, for "
"example due to lack of resources to complete and due to interrupted waits. "
"In these situations UMD should preferably restart the IOCTL after taking "
"suitable action. If UMD has over-committed a memory resource, an -ENOSPC "
"error will be returned, and UMD may then unbind resources that are not used "
"at the moment and rerun the IOCTL. On -EINTR, UMD should simply rerun the "
"IOCTL and on -ENOMEM user-space may either attempt to free known system "
"memory resources or fail. In case of UMD deciding to fail a bind operation, "
"due to an error return, no additional action is needed to clean up the "
"failed operation, and the VM is left in the same state as it was before the "
"failing IOCTL. Unbind operations are guaranteed not to return any errors due "
"to resource constraints, but may return errors due to, for example, invalid "
"arguments or the gpu_vm being banned. In the case an unexpected error "
"happens during the asynchronous bind process, the gpu_vm will be banned, and "
"attempts to use it after banning will return -ENOENT."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:171
msgid "Example: The Xe VM_BIND uAPI"
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:173
msgid ""
"Starting with the VM_BIND operation struct, the IOCTL call can take zero, "
"one or many such operations. A zero number means only the synchronization "
"part of the IOCTL is carried out: an asynchronous VM_BIND updates the "
"syncobjects, whereas a sync VM_BIND waits for the implicit dependencies to "
"be fulfilled."
msgstr ""

#: ../../../gpu/drm-vm-bind-async.rst:257
msgid ""
"The VM_BIND IOCTL argument itself, looks like follows. Note that for "
"synchronous VM_BIND, the num_syncs and syncs fields must be zero. Here the "
"``exec_queue_id`` field is the VM_BIND context discussed previously that is "
"used to facilitate out-of-order VM_BINDs."
msgstr ""
