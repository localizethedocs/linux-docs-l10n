# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm64/memory.rst:3
msgid "Memory Layout on AArch64 Linux"
msgstr ""

#: ../../../arch/arm64/memory.rst:5
msgid "Author: Catalin Marinas <catalin.marinas@arm.com>"
msgstr ""

#: ../../../arch/arm64/memory.rst:7
msgid ""
"This document describes the virtual memory layout used by the AArch64 Linux "
"kernel. The architecture allows up to 4 levels of translation tables with a "
"4KB page size and up to 3 levels with a 64KB page size."
msgstr ""

#: ../../../arch/arm64/memory.rst:11
msgid ""
"AArch64 Linux uses either 3 levels or 4 levels of translation tables with "
"the 4KB page configuration, allowing 39-bit (512GB) or 48-bit (256TB) "
"virtual addresses, respectively, for both user and kernel. With 64KB pages, "
"only 2 levels of translation tables, allowing 42-bit (4TB) virtual address, "
"are used but the memory layout is the same."
msgstr ""

#: ../../../arch/arm64/memory.rst:17
msgid ""
"ARMv8.2 adds optional support for Large Virtual Address space. This is only "
"available when running with a 64KB page size and expands the number of "
"descriptors in the first level of translation."
msgstr ""

#: ../../../arch/arm64/memory.rst:21
msgid ""
"TTBRx selection is given by bit 55 of the virtual address. The "
"swapper_pg_dir contains only kernel (global) mappings while the user pgd "
"contains only user (non-global) mappings.  The swapper_pg_dir address is "
"written to TTBR1 and never written to TTBR0."
msgstr ""

#: ../../../arch/arm64/memory.rst:26
msgid ""
"When using KVM without the Virtualization Host Extensions, the hypervisor "
"maps kernel pages in EL2 at a fixed (and potentially random) offset from the "
"linear mapping. See the kern_hyp_va macro and kvm_update_va_mask function "
"for more details. MMIO devices such as GICv2 gets mapped next to the HYP "
"idmap page, as do vectors when ARM64_SPECTRE_V3A is enabled for particular "
"CPUs."
msgstr ""

#: ../../../arch/arm64/memory.rst:33
msgid ""
"When using KVM with the Virtualization Host Extensions, no additional "
"mappings are created, since the host kernel runs directly in EL2."
msgstr ""

#: ../../../arch/arm64/memory.rst:37
msgid "52-bit VA support in the kernel"
msgstr ""

#: ../../../arch/arm64/memory.rst:38
msgid ""
"If the ARMv8.2-LVA optional feature is present, and we are running with a "
"64KB page size; then it is possible to use 52-bits of address space for both "
"userspace and kernel addresses. However, any kernel binary that supports 52-"
"bit must also be able to fall back to 48-bit at early boot time if the "
"hardware feature is not present."
msgstr ""

#: ../../../arch/arm64/memory.rst:44
msgid ""
"This fallback mechanism necessitates the kernel .text to be in the higher "
"addresses such that they are invariant to 48/52-bit VAs. Due to the kasan "
"shadow being a fraction of the entire kernel VA space, the end of the kasan "
"shadow must also be in the higher half of the kernel VA space for both 48/52-"
"bit. (Switching from 48-bit to 52-bit, the end of the kasan shadow is "
"invariant and dependent on ~0UL, whilst the start address will \"grow\" "
"towards the lower addresses)."
msgstr ""

#: ../../../arch/arm64/memory.rst:52
msgid ""
"In order to optimise phys_to_virt and virt_to_phys, the PAGE_OFFSET is kept "
"constant at 0xFFF0000000000000 (corresponding to 52-bit), this obviates the "
"need for an extra variable read. The physvirt offset and vmemmap offsets are "
"computed at early boot to enable this logic."
msgstr ""

#: ../../../arch/arm64/memory.rst:58
msgid ""
"As a single binary will need to support both 48-bit and 52-bit VA spaces, "
"the VMEMMAP must be sized large enough for 52-bit VAs and also must be sized "
"large enough to accommodate a fixed PAGE_OFFSET."
msgstr ""

#: ../../../arch/arm64/memory.rst:62
msgid ""
"Most code in the kernel should not need to consider the VA_BITS, for code "
"that does need to know the VA size the variables are defined as follows:"
msgstr ""

#: ../../../arch/arm64/memory.rst:66
msgid "VA_BITS         constant        the *maximum* VA space size"
msgstr ""

#: ../../../arch/arm64/memory.rst:68
msgid "VA_BITS_MIN     constant        the *minimum* VA space size"
msgstr ""

#: ../../../arch/arm64/memory.rst:70
msgid "vabits_actual   variable        the *actual* VA space size"
msgstr ""

#: ../../../arch/arm64/memory.rst:73
msgid ""
"Maximum and minimum sizes can be useful to ensure that buffers are sized "
"large enough or that addresses are positioned close enough for the \"worst\" "
"case."
msgstr ""

#: ../../../arch/arm64/memory.rst:78
msgid "52-bit userspace VAs"
msgstr ""

#: ../../../arch/arm64/memory.rst:79
msgid ""
"To maintain compatibility with software that relies on the ARMv8.0 VA space "
"maximum size of 48-bits, the kernel will, by default, return virtual "
"addresses to userspace from a 48-bit range."
msgstr ""

#: ../../../arch/arm64/memory.rst:83
msgid ""
"Software can \"opt-in\" to receiving VAs from a 52-bit space by specifying "
"an mmap hint parameter that is larger than 48-bit."
msgstr ""

#: ../../../arch/arm64/memory.rst:86
msgid "For example:"
msgstr ""

#: ../../../arch/arm64/memory.rst:92
msgid ""
"It is also possible to build a debug kernel that returns addresses from a 52-"
"bit space by enabling the following kernel config options:"
msgstr ""

#: ../../../arch/arm64/memory.rst:99
msgid ""
"Note that this option is only intended for debugging applications and should "
"not be used in production."
msgstr ""
