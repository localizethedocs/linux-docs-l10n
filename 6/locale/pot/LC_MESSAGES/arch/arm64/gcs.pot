# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm64/gcs.rst:3
msgid "Guarded Control Stack support for AArch64 Linux"
msgstr ""

#: ../../../arch/arm64/gcs.rst:5
msgid ""
"This document outlines briefly the interface provided to userspace by Linux "
"in order to support use of the ARM Guarded Control Stack (GCS) feature."
msgstr ""

#: ../../../arch/arm64/gcs.rst:8
msgid ""
"This is an outline of the most important features and issues only and not "
"intended to be exhaustive."
msgstr ""

#: ../../../arch/arm64/gcs.rst:14
msgid "1.  General"
msgstr ""

#: ../../../arch/arm64/gcs.rst:16
msgid ""
"GCS is an architecture feature intended to provide greater protection "
"against return oriented programming (ROP) attacks and to simplify the "
"implementation of features that need to collect stack traces such as "
"profiling."
msgstr ""

#: ../../../arch/arm64/gcs.rst:21
msgid ""
"When GCS is enabled a separate guarded control stack is maintained by the PE "
"which is writeable only through specific GCS operations.  This stores the "
"call stack only, when a procedure call instruction is performed the current "
"PC is pushed onto the GCS and on RET the address in the LR is verified "
"against that on the top of the GCS."
msgstr ""

#: ../../../arch/arm64/gcs.rst:27
msgid ""
"When active the current GCS pointer is stored in the system register "
"GCSPR_EL0.  This is readable by userspace but can only be updated via "
"specific GCS instructions."
msgstr ""

#: ../../../arch/arm64/gcs.rst:31
msgid ""
"The architecture provides instructions for switching between guarded control "
"stacks with checks to ensure that the new stack is a valid target for "
"switching."
msgstr ""

#: ../../../arch/arm64/gcs.rst:35
msgid ""
"The functionality of GCS is similar to that provided by the x86 Shadow Stack "
"feature, due to sharing of userspace interfaces the ABI refers to shadow "
"stacks rather than GCS."
msgstr ""

#: ../../../arch/arm64/gcs.rst:39
msgid ""
"Support for GCS is reported to userspace via HWCAP_GCS in the aux vector "
"AT_HWCAP entry."
msgstr ""

#: ../../../arch/arm64/gcs.rst:42
msgid ""
"GCS is enabled per thread.  While there is support for disabling GCS at "
"runtime this should be done with great care."
msgstr ""

#: ../../../arch/arm64/gcs.rst:45
msgid "GCS memory access faults are reported as normal memory access faults."
msgstr ""

#: ../../../arch/arm64/gcs.rst:47
msgid ""
"GCS specific errors (those reported with EC 0x2d) will be reported as "
"SIGSEGV with a si_code of SEGV_CPERR (control protection error)."
msgstr ""

#: ../../../arch/arm64/gcs.rst:50
msgid "GCS is supported only for AArch64."
msgstr ""

#: ../../../arch/arm64/gcs.rst:52
msgid ""
"On systems where GCS is supported GCSPR_EL0 is always readable by EL0 "
"regardless of the GCS configuration for the thread."
msgstr ""

#: ../../../arch/arm64/gcs.rst:55
msgid ""
"The architecture supports enabling GCS without verifying that return values "
"in LR match those in the GCS, the LR will be ignored.  This is not supported "
"by Linux."
msgstr ""

#: ../../../arch/arm64/gcs.rst:62
msgid "2.  Enabling and disabling Guarded Control Stacks"
msgstr ""

#: ../../../arch/arm64/gcs.rst:64
msgid ""
"GCS is enabled and disabled for a thread via the PR_SET_SHADOW_STACK_STATUS "
"prctl(), this takes a single flags argument specifying which GCS features "
"should be used."
msgstr ""

#: ../../../arch/arm64/gcs.rst:68
msgid ""
"When set PR_SHADOW_STACK_ENABLE flag allocates a Guarded Control Stack and "
"enables GCS for the thread, enabling the functionality controlled by "
"GCSCRE0_EL1.{nTR, RVCHKEN, PCRSEL}."
msgstr ""

#: ../../../arch/arm64/gcs.rst:72
msgid ""
"When set the PR_SHADOW_STACK_PUSH flag enables the functionality controlled "
"by GCSCRE0_EL1.PUSHMEn, allowing explicit GCS pushes."
msgstr ""

#: ../../../arch/arm64/gcs.rst:75
msgid ""
"When set the PR_SHADOW_STACK_WRITE flag enables the functionality controlled "
"by GCSCRE0_EL1.STREn, allowing explicit stores to the Guarded Control Stack."
msgstr ""

#: ../../../arch/arm64/gcs.rst:78
msgid ""
"Any unknown flags will cause PR_SET_SHADOW_STACK_STATUS to return -EINVAL."
msgstr ""

#: ../../../arch/arm64/gcs.rst:80
msgid ""
"PR_LOCK_SHADOW_STACK_STATUS is passed a bitmask of features with the same "
"values as used for PR_SET_SHADOW_STACK_STATUS.  Any future changes to the "
"status of the specified GCS mode bits will be rejected."
msgstr ""

#: ../../../arch/arm64/gcs.rst:84
msgid ""
"PR_LOCK_SHADOW_STACK_STATUS allows any bit to be locked, this allows "
"userspace to prevent changes to any future features."
msgstr ""

#: ../../../arch/arm64/gcs.rst:87
msgid ""
"There is no support for a process to remove a lock that has been set for it."
msgstr ""

#: ../../../arch/arm64/gcs.rst:90
msgid ""
"PR_SET_SHADOW_STACK_STATUS and PR_LOCK_SHADOW_STACK_STATUS affect only the "
"thread that called them, any other running threads will be unaffected."
msgstr ""

#: ../../../arch/arm64/gcs.rst:93
msgid ""
"New threads inherit the GCS configuration of the thread that created them."
msgstr ""

#: ../../../arch/arm64/gcs.rst:95
msgid "GCS is disabled on exec()."
msgstr ""

#: ../../../arch/arm64/gcs.rst:97
msgid ""
"The current GCS configuration for a thread may be read with the "
"PR_GET_SHADOW_STACK_STATUS prctl(), this returns the same flags that are "
"passed to PR_SET_SHADOW_STACK_STATUS."
msgstr ""

#: ../../../arch/arm64/gcs.rst:101
msgid ""
"If GCS is disabled for a thread after having previously been enabled then "
"the stack will remain allocated for the lifetime of the thread.  At present "
"any attempt to reenable GCS for the thread will be rejected, this may be "
"revisited in future."
msgstr ""

#: ../../../arch/arm64/gcs.rst:106
msgid ""
"It should be noted that since enabling GCS will result in GCS becoming "
"active immediately it is not normally possible to return from the function "
"that invoked the prctl() that enabled GCS.  It is expected that the normal "
"usage will be that GCS is enabled very early in execution of a program."
msgstr ""

#: ../../../arch/arm64/gcs.rst:114
msgid "3.  Allocation of Guarded Control Stacks"
msgstr ""

#: ../../../arch/arm64/gcs.rst:116
msgid ""
"When GCS is enabled for a thread a new Guarded Control Stack will be "
"allocated for it of half the standard stack size or 2 gigabytes, whichever "
"is smaller."
msgstr ""

#: ../../../arch/arm64/gcs.rst:120
msgid ""
"When a new thread is created by a thread which has GCS enabled then a new "
"Guarded Control Stack will be allocated for the new thread with half the "
"size of the standard stack."
msgstr ""

#: ../../../arch/arm64/gcs.rst:124
msgid ""
"When a stack is allocated by enabling GCS or during thread creation then the "
"top 8 bytes of the stack will be initialised to 0 and GCSPR_EL0 will be set "
"to point to the address of this 0 value, this can be used to detect the top "
"of the stack."
msgstr ""

#: ../../../arch/arm64/gcs.rst:129
msgid ""
"Additional Guarded Control Stacks can be allocated using the "
"map_shadow_stack() system call."
msgstr ""

#: ../../../arch/arm64/gcs.rst:132
msgid ""
"Stacks allocated using map_shadow_stack() can optionally have an end of "
"stack marker and cap placed at the top of the stack.  If the flag "
"SHADOW_STACK_SET_TOKEN is specified a cap will be placed on the stack, if "
"SHADOW_STACK_SET_MARKER is not specified the cap will be the top 8 bytes of "
"the stack and if it is specified then the cap will be the next 8 bytes.  "
"While specifying just SHADOW_STACK_SET_MARKER by itself is valid since the "
"marker is all bits 0 it has no observable effect."
msgstr ""

#: ../../../arch/arm64/gcs.rst:140
msgid ""
"Stacks allocated using map_shadow_stack() must have a size which is a "
"multiple of 8 bytes larger than 8 bytes and must be 8 bytes aligned."
msgstr ""

#: ../../../arch/arm64/gcs.rst:143
msgid ""
"An address can be specified to map_shadow_stack(), if one is provided then "
"it must be aligned to a page boundary."
msgstr ""

#: ../../../arch/arm64/gcs.rst:146
msgid ""
"When a thread is freed the Guarded Control Stack initially allocated for "
"that thread will be freed.  Note carefully that if the stack has been "
"switched this may not be the stack currently in use by the thread."
msgstr ""

#: ../../../arch/arm64/gcs.rst:152
msgid "4.  Signal handling"
msgstr ""

#: ../../../arch/arm64/gcs.rst:154
msgid ""
"A new signal frame record gcs_context encodes the current GCS mode and "
"pointer for the interrupted context on signal delivery.  This will always be "
"present on systems that support GCS."
msgstr ""

#: ../../../arch/arm64/gcs.rst:158
msgid ""
"The record contains a flag field which reports the current GCS configuration "
"for the interrupted context as PR_GET_SHADOW_STACK_STATUS would."
msgstr ""

#: ../../../arch/arm64/gcs.rst:161
msgid ""
"The signal handler is run with the same GCS configuration as the interrupted "
"context."
msgstr ""

#: ../../../arch/arm64/gcs.rst:164
msgid ""
"When GCS is enabled for the interrupted thread a signal handling specific "
"GCS cap token will be written to the GCS, this is an architectural GCS cap "
"with the token type (bits 0..11) all clear.  The GCSPR_EL0 reported in the "
"signal frame will point to this cap token."
msgstr ""

#: ../../../arch/arm64/gcs.rst:169
msgid "The signal handler will use the same GCS as the interrupted context."
msgstr ""

#: ../../../arch/arm64/gcs.rst:171
msgid ""
"When GCS is enabled on signal entry a frame with the address of the signal "
"return handler will be pushed onto the GCS, allowing return from the signal "
"handler via RET as normal.  This will not be reported in the gcs_context in "
"the signal frame."
msgstr ""

#: ../../../arch/arm64/gcs.rst:178
msgid "5.  Signal return"
msgstr ""

#: ../../../arch/arm64/gcs.rst:180
msgid "When returning from a signal handler:"
msgstr ""

#: ../../../arch/arm64/gcs.rst:182
msgid ""
"If there is a gcs_context record in the signal frame then the GCS flags and "
"GCSPR_EL0 will be restored from that context prior to further validation."
msgstr ""

#: ../../../arch/arm64/gcs.rst:186
msgid ""
"If there is no gcs_context record in the signal frame then the GCS "
"configuration will be unchanged."
msgstr ""

#: ../../../arch/arm64/gcs.rst:189
msgid ""
"If GCS is enabled on return from a signal handler then GCSPR_EL0 must point "
"to a valid GCS signal cap record, this will be popped from the GCS prior to "
"signal return."
msgstr ""

#: ../../../arch/arm64/gcs.rst:193
msgid ""
"If the GCS configuration is locked when returning from a signal then any "
"attempt to change the GCS configuration will be treated as an error.  This "
"is true even if GCS was not enabled prior to signal entry."
msgstr ""

#: ../../../arch/arm64/gcs.rst:197
msgid ""
"GCS may be disabled via signal return but any attempt to enable GCS via "
"signal return will be rejected."
msgstr ""

#: ../../../arch/arm64/gcs.rst:202
msgid "6.  ptrace extensions"
msgstr ""

#: ../../../arch/arm64/gcs.rst:204
msgid ""
"A new regset NT_ARM_GCS is defined for use with PTRACE_GETREGSET and "
"PTRACE_SETREGSET."
msgstr ""

#: ../../../arch/arm64/gcs.rst:207
msgid ""
"The GCS mode, including enable and disable, may be configured via ptrace. If "
"GCS is enabled via ptrace no new GCS will be allocated for the thread."
msgstr ""

#: ../../../arch/arm64/gcs.rst:210
msgid "Configuration via ptrace ignores locking of GCS mode bits."
msgstr ""

#: ../../../arch/arm64/gcs.rst:214
msgid "7.  ELF coredump extensions"
msgstr ""

#: ../../../arch/arm64/gcs.rst:216
msgid ""
"NT_ARM_GCS notes will be added to each coredump for each thread of the "
"dumped process.  The contents will be equivalent to the data that would have "
"been read if a PTRACE_GETREGSET of the corresponding type were executed for "
"each thread when the coredump was generated."
msgstr ""

#: ../../../arch/arm64/gcs.rst:224
msgid "8.  /proc extensions"
msgstr ""

#: ../../../arch/arm64/gcs.rst:226
msgid ""
"Guarded Control Stack pages will include \"ss\" in their VmFlags in /proc/"
"<pid>/smaps."
msgstr ""
