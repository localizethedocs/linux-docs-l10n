# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/s390/cds.rst:3
msgid "Linux for S/390 and zSeries"
msgstr ""

#: ../../../arch/s390/cds.rst:5
msgid "Common Device Support (CDS) Device Driver I/O Support Routines"
msgstr ""

#: ../../../arch/s390/cds.rst:8
msgid "Authors:"
msgstr ""

#: ../../../arch/s390/cds.rst:9
msgid "Ingo Adlung"
msgstr ""

#: ../../../arch/s390/cds.rst:10
msgid "Cornelia Huck"
msgstr ""

#: ../../../arch/s390/cds.rst:12
msgid "Copyright, IBM Corp. 1999-2002"
msgstr ""

#: ../../../arch/s390/cds.rst:15
msgid "Introduction"
msgstr ""

#: ../../../arch/s390/cds.rst:17
msgid ""
"This document describes the common device support routines for Linux/390. "
"Different than other hardware architectures, ESA/390 has defined a unified I/"
"O access method. This gives relief to the device drivers as they don't have "
"to deal with different bus types, polling versus interrupt processing, "
"shared versus non-shared interrupt processing, DMA versus port I/O (PIO), "
"and other hardware features more. However, this implies that either every "
"single device driver needs to implement the hardware I/O attachment "
"functionality itself, or the operating system provides for a unified method "
"to access the hardware, providing all the functionality that every single "
"device driver would have to provide itself."
msgstr ""

#: ../../../arch/s390/cds.rst:28
msgid ""
"The document does not intend to explain the ESA/390 hardware architecture in "
"every detail.This information can be obtained from the ESA/390 Principles of "
"Operation manual (IBM Form. No. SA22-7201)."
msgstr ""

#: ../../../arch/s390/cds.rst:32
msgid ""
"In order to build common device support for ESA/390 I/O interfaces, a "
"functional layer was introduced that provides generic I/O access methods to "
"the hardware."
msgstr ""

#: ../../../arch/s390/cds.rst:36
msgid ""
"The common device support layer comprises the I/O support routines defined "
"below. Some of them implement common Linux device driver interfaces, while "
"some of them are ESA/390 platform specific."
msgstr ""

#: ../../../arch/s390/cds.rst:40 ../../../arch/s390/cds.rst:88
msgid "Note:"
msgstr ""

#: ../../../arch/s390/cds.rst:41
msgid ""
"In order to write a driver for S/390, you also need to look into the "
"interface described in Documentation/arch/s390/driver-model.rst."
msgstr ""

#: ../../../arch/s390/cds.rst:44
msgid "Note for porting drivers from 2.4:"
msgstr ""

#: ../../../arch/s390/cds.rst:46
msgid "The major changes are:"
msgstr ""

#: ../../../arch/s390/cds.rst:48
msgid "The functions use a ccw_device instead of an irq (subchannel)."
msgstr ""

#: ../../../arch/s390/cds.rst:49
msgid ""
"All drivers must define a ccw_driver (see driver-model.txt) and the "
"associated functions."
msgstr ""

#: ../../../arch/s390/cds.rst:51
msgid "request_irq() and free_irq() are no longer done by the driver."
msgstr ""

#: ../../../arch/s390/cds.rst:52
msgid ""
"The oper_handler is (kindof) replaced by the probe() and set_online() "
"functions of the ccw_driver."
msgstr ""

#: ../../../arch/s390/cds.rst:54
msgid ""
"The not_oper_handler is (kindof) replaced by the remove() and set_offline() "
"functions of the ccw_driver."
msgstr ""

#: ../../../arch/s390/cds.rst:56
msgid "The channel device layer is gone."
msgstr ""

#: ../../../arch/s390/cds.rst:57
msgid ""
"The interrupt handlers must be adapted to use a ccw_device as argument. "
"Moreover, they don't return a devstat, but an irb."
msgstr ""

#: ../../../arch/s390/cds.rst:59
msgid ""
"Before initiating an io, the options must be set via "
"ccw_device_set_options()."
msgstr ""

#: ../../../arch/s390/cds.rst:60
msgid ""
"Instead of calling read_dev_chars()/read_conf_data(), the driver issues the "
"channel program and handles the interrupt itself."
msgstr ""

#: ../../../arch/s390/cds.rst:63
msgid "ccw_device_get_ciw()"
msgstr ""

#: ../../../arch/s390/cds.rst:64
msgid "get commands from extended sense data."
msgstr ""

#: ../../../arch/s390/cds.rst:66
msgid ""
"ccw_device_start(), ccw_device_start_timeout(), ccw_device_start_key(), "
"ccw_device_start_key_timeout()"
msgstr ""

#: ../../../arch/s390/cds.rst:67
msgid "initiate an I/O request."
msgstr ""

#: ../../../arch/s390/cds.rst:69
msgid "ccw_device_resume()"
msgstr ""

#: ../../../arch/s390/cds.rst:70
msgid "resume channel program execution."
msgstr ""

#: ../../../arch/s390/cds.rst:72
msgid "ccw_device_halt()"
msgstr ""

#: ../../../arch/s390/cds.rst:73
msgid "terminate the current I/O request processed on the device."
msgstr ""

#: ../../../arch/s390/cds.rst:75
msgid "do_IRQ()"
msgstr ""

#: ../../../arch/s390/cds.rst:76
msgid ""
"generic interrupt routine. This function is called by the interrupt entry "
"routine whenever an I/O interrupt is presented to the system. The do_IRQ() "
"routine determines the interrupt status and calls the device specific "
"interrupt handler according to the rules (flags) defined during I/O request "
"initiation with do_IO()."
msgstr ""

#: ../../../arch/s390/cds.rst:82
msgid ""
"The next chapters describe the functions other than do_IRQ() in more "
"details. The do_IRQ() interface is not described, as it is called from the "
"Linux/390 first level interrupt handler only and does not comprise a device "
"driver callable interface. Instead, the functional description of do_IO() "
"also describes the input to the device specific interrupt handler."
msgstr ""

#: ../../../arch/s390/cds.rst:89
msgid "All explanations apply also to the 64 bit architecture s390x."
msgstr ""

#: ../../../arch/s390/cds.rst:93
msgid "Common Device Support (CDS) for Linux/390 Device Drivers"
msgstr ""

#: ../../../arch/s390/cds.rst:96
msgid "General Information"
msgstr ""

#: ../../../arch/s390/cds.rst:98
msgid ""
"The following chapters describe the I/O related interface routines the "
"Linux/390 common device support (CDS) provides to allow for device specific "
"driver implementations on the IBM ESA/390 hardware platform. Those "
"interfaces intend to provide the functionality required by every device "
"driver implementation to allow to drive a specific hardware device on the "
"ESA/390 platform. Some of the interface routines are specific to Linux/390 "
"and some of them can be found on other Linux platforms implementations too. "
"Miscellaneous function prototypes, data declarations, and macro definitions "
"can be found in the architecture specific C header file linux/arch/s390/"
"include/asm/irq.h."
msgstr ""

#: ../../../arch/s390/cds.rst:110
msgid "Overview of CDS interface concepts"
msgstr ""

#: ../../../arch/s390/cds.rst:112
msgid ""
"Different to other hardware platforms, the ESA/390 architecture doesn't "
"define interrupt lines managed by a specific interrupt controller and bus "
"systems that may or may not allow for shared interrupts, DMA processing, "
"etc.. Instead, the ESA/390 architecture has implemented a so called channel "
"subsystem, that provides a unified view of the devices physically attached "
"to the systems. Though the ESA/390 hardware platform knows about a huge "
"variety of different peripheral attachments like disk devices (aka. DASDs), "
"tapes, communication controllers, etc. they can all be accessed by a well "
"defined access method and they are presenting I/O completion a unified way : "
"I/O interruptions. Every single device is uniquely identified to the system "
"by a so called subchannel, where the ESA/390 architecture allows for 64k "
"devices be attached."
msgstr ""

#: ../../../arch/s390/cds.rst:124
msgid ""
"Linux, however, was first built on the Intel PC architecture, with its two "
"cascaded 8259 programmable interrupt controllers (PICs), that allow for a "
"maximum of 15 different interrupt lines. All devices attached to such a "
"system share those 15 interrupt levels. Devices attached to the ISA bus "
"system must not share interrupt levels (aka. IRQs), as the ISA bus bases on "
"edge triggered interrupts. MCA, EISA, PCI and other bus systems base on "
"level triggered interrupts, and therewith allow for shared IRQs. However, if "
"multiple devices present their hardware status by the same (shared) IRQ, the "
"operating system has to call every single device driver registered on this "
"IRQ in order to determine the device driver owning the device that raised "
"the interrupt."
msgstr ""

#: ../../../arch/s390/cds.rst:135
msgid ""
"Up to kernel 2.4, Linux/390 used to provide interfaces via the IRQ "
"(subchannel). For internal use of the common I/O layer, these are still "
"there. However, device drivers should use the new calling interface via the "
"ccw_device only."
msgstr ""

#: ../../../arch/s390/cds.rst:139
msgid ""
"During its startup the Linux/390 system checks for peripheral devices. Each "
"of those devices is uniquely defined by a so called subchannel by the "
"ESA/390 channel subsystem. While the subchannel numbers are system "
"generated, each subchannel also takes a user defined attribute, the so "
"called device number. Both subchannel number and device number cannot exceed "
"65535. During sysfs initialisation, the information about control unit type "
"and device types that imply specific I/O commands (channel command words - "
"CCWs) in order to operate the device are gathered. Device drivers can "
"retrieve this set of hardware information during their initialization step "
"to recognize the devices they support using the information saved in the "
"struct ccw_device given to them. This methods implies that Linux/390 doesn't "
"require to probe for free (not armed) interrupt request lines (IRQs) to "
"drive its devices with. Where applicable, the device drivers can use issue "
"the READ DEVICE CHARACTERISTICS ccw to retrieve device characteristics in "
"its online routine."
msgstr ""

#: ../../../arch/s390/cds.rst:154
msgid ""
"In order to allow for easy I/O initiation the CDS layer provides a "
"ccw_device_start() interface that takes a device specific channel program "
"(one or more CCWs) as input sets up the required architecture specific "
"control blocks and initiates an I/O request on behalf of the device driver. "
"The ccw_device_start() routine allows to specify whether it expects the CDS "
"layer to notify the device driver for every interrupt it observes, or with "
"final status only. See ccw_device_start() for more details. A device driver "
"must never issue ESA/390 I/O commands itself, but must use the Linux/390 CDS "
"interfaces instead."
msgstr ""

#: ../../../arch/s390/cds.rst:163
msgid ""
"For long running I/O request to be canceled, the CDS layer provides the "
"ccw_device_halt() function. Some devices require to initially issue a HALT "
"SUBCHANNEL (HSCH) command without having pending I/O requests. This function "
"is also covered by ccw_device_halt()."
msgstr ""

#: ../../../arch/s390/cds.rst:169
msgid "get_ciw() - get command information word"
msgstr ""

#: ../../../arch/s390/cds.rst:171
msgid ""
"This call enables a device driver to get information about supported "
"commands from the extended SenseID data."
msgstr ""

#: ../../../arch/s390/cds.rst:180 ../../../arch/s390/cds.rst:232
#: ../../../arch/s390/cds.rst:430 ../../../arch/s390/cds.rst:463
#: ../../../arch/s390/cds.rst:503
msgid "cdev"
msgstr ""

#: ../../../arch/s390/cds.rst:180
msgid "The ccw_device for which the command is to be retrieved."
msgstr ""

#: ../../../arch/s390/cds.rst:181
msgid "cmd"
msgstr ""

#: ../../../arch/s390/cds.rst:181
msgid "The command type to be retrieved."
msgstr ""

#: ../../../arch/s390/cds.rst:184
msgid "ccw_device_get_ciw() returns:"
msgstr ""

#: ../../../arch/s390/cds.rst:187
msgid "NULL"
msgstr ""

#: ../../../arch/s390/cds.rst:187
msgid "No extended data available, invalid device or command not found."
msgstr ""

#: ../../../arch/s390/cds.rst:188
msgid "!NULL"
msgstr ""

#: ../../../arch/s390/cds.rst:188
msgid "The command requested."
msgstr ""

#: ../../../arch/s390/cds.rst:195
msgid ""
"The ccw_device_start() routines is the I/O request front-end processor. All "
"device driver I/O requests must be issued using this routine. A device "
"driver must not issue ESA/390 I/O commands itself. Instead the "
"ccw_device_start() routine provides all interfaces required to drive "
"arbitrary devices."
msgstr ""

#: ../../../arch/s390/cds.rst:200
msgid ""
"This description also covers the status information passed to the device "
"driver's interrupt handler as this is related to the rules (flags) defined "
"with the associated I/O request when calling ccw_device_start()."
msgstr ""

#: ../../../arch/s390/cds.rst:232
msgid "ccw_device the I/O is destined for"
msgstr ""

#: ../../../arch/s390/cds.rst:233
msgid "cpa"
msgstr ""

#: ../../../arch/s390/cds.rst:233
msgid "logical start address of channel program"
msgstr ""

#: ../../../arch/s390/cds.rst:234
msgid "user_intparm"
msgstr ""

#: ../../../arch/s390/cds.rst:234
msgid ""
"user specific interrupt information; will be presented back to the device "
"driver's interrupt handler. Allows a device driver to associate the "
"interrupt with a particular I/O request."
msgstr ""

#: ../../../arch/s390/cds.rst:238
msgid "lpm"
msgstr ""

#: ../../../arch/s390/cds.rst:238
msgid ""
"defines the channel path to be used for a specific I/O request. A value of 0 "
"will make cio use the opm."
msgstr ""

#: ../../../arch/s390/cds.rst:240
msgid "key"
msgstr ""

#: ../../../arch/s390/cds.rst:240
msgid ""
"the storage key to use for the I/O (useful for operating on a storage with a "
"storage key != default key)"
msgstr ""

#: ../../../arch/s390/cds.rst:242
msgid "flag"
msgstr ""

#: ../../../arch/s390/cds.rst:242
msgid "defines the action to be performed for I/O processing"
msgstr ""

#: ../../../arch/s390/cds.rst:243
msgid "expires"
msgstr ""

#: ../../../arch/s390/cds.rst:243
msgid ""
"timeout value in jiffies. The common I/O layer will terminate the running "
"program after this and call the interrupt handler with ERR_PTR(-ETIMEDOUT) "
"as irb."
msgstr ""

#: ../../../arch/s390/cds.rst:248
msgid "Possible flag values are:"
msgstr ""

#: ../../../arch/s390/cds.rst:251
msgid "DOIO_ALLOW_SUSPEND"
msgstr ""

#: ../../../arch/s390/cds.rst:251
msgid "channel program may become suspended"
msgstr ""

#: ../../../arch/s390/cds.rst:252
msgid "DOIO_DENY_PREFETCH"
msgstr ""

#: ../../../arch/s390/cds.rst:252
msgid ""
"don't allow for CCW prefetch; usually this implies the channel program might "
"become modified"
msgstr ""

#: ../../../arch/s390/cds.rst:255
msgid "DOIO_SUPPRESS_INTER"
msgstr ""

#: ../../../arch/s390/cds.rst:255
msgid "don't call the handler on intermediate status"
msgstr ""

#: ../../../arch/s390/cds.rst:258
msgid ""
"The cpa parameter points to the first format 1 CCW of a channel program::"
msgstr ""

#: ../../../arch/s390/cds.rst:267
msgid "with the following CCW flags values defined:"
msgstr ""

#: ../../../arch/s390/cds.rst:270
msgid "CCW_FLAG_DC"
msgstr ""

#: ../../../arch/s390/cds.rst:270
msgid "data chaining"
msgstr ""

#: ../../../arch/s390/cds.rst:271
msgid "CCW_FLAG_CC"
msgstr ""

#: ../../../arch/s390/cds.rst:271
msgid "command chaining"
msgstr ""

#: ../../../arch/s390/cds.rst:272
msgid "CCW_FLAG_SLI"
msgstr ""

#: ../../../arch/s390/cds.rst:272
msgid "suppress incorrect length"
msgstr ""

#: ../../../arch/s390/cds.rst:273
msgid "CCW_FLAG_SKIP"
msgstr ""

#: ../../../arch/s390/cds.rst:273
msgid "skip"
msgstr ""

#: ../../../arch/s390/cds.rst:274
msgid "CCW_FLAG_PCI"
msgstr ""

#: ../../../arch/s390/cds.rst:274
msgid "PCI"
msgstr ""

#: ../../../arch/s390/cds.rst:275
msgid "CCW_FLAG_IDA"
msgstr ""

#: ../../../arch/s390/cds.rst:275
msgid "indirect addressing"
msgstr ""

#: ../../../arch/s390/cds.rst:276
msgid "CCW_FLAG_SUSPEND"
msgstr ""

#: ../../../arch/s390/cds.rst:276
msgid "suspend"
msgstr ""

#: ../../../arch/s390/cds.rst:280
msgid ""
"Via ccw_device_set_options(), the device driver may specify the following "
"options for the device:"
msgstr ""

#: ../../../arch/s390/cds.rst:284
msgid "DOIO_EARLY_NOTIFICATION"
msgstr ""

#: ../../../arch/s390/cds.rst:284
msgid "allow for early interrupt notification"
msgstr ""

#: ../../../arch/s390/cds.rst:285
msgid "DOIO_REPORT_ALL"
msgstr ""

#: ../../../arch/s390/cds.rst:285
msgid "report all interrupt conditions"
msgstr ""

#: ../../../arch/s390/cds.rst:289
msgid "The ccw_device_start() function returns:"
msgstr ""

#: ../../../arch/s390/cds.rst:292 ../../../arch/s390/cds.rst:436
#: ../../../arch/s390/cds.rst:472 ../../../arch/s390/cds.rst:510
msgid "0"
msgstr ""

#: ../../../arch/s390/cds.rst:292
msgid "successful completion or request successfully initiated"
msgstr ""

#: ../../../arch/s390/cds.rst:293 ../../../arch/s390/cds.rst:437
#: ../../../arch/s390/cds.rst:473
msgid "-EBUSY"
msgstr ""

#: ../../../arch/s390/cds.rst:293
msgid ""
"The device is currently processing a previous I/O request, or there is a "
"status pending at the device."
msgstr ""

#: ../../../arch/s390/cds.rst:295 ../../../arch/s390/cds.rst:438
#: ../../../arch/s390/cds.rst:474 ../../../arch/s390/cds.rst:511
msgid "-ENODEV"
msgstr ""

#: ../../../arch/s390/cds.rst:295
msgid ""
"cdev is invalid, the device is not operational or the ccw_device is not "
"online."
msgstr ""

#: ../../../arch/s390/cds.rst:299
msgid ""
"When the I/O request completes, the CDS first level interrupt handler will "
"accumulate the status in a struct irb and then call the device interrupt "
"handler. The intparm field will contain the value the device driver has "
"associated with a particular I/O request. If a pending device status was "
"recognized, intparm will be set to 0 (zero). This may happen during I/O "
"initiation or delayed by an alert status notification. In any case this "
"status is not related to the current (last) I/O request. In case of a "
"delayed status notification no special interrupt will be presented to "
"indicate I/O completion as the I/O request was never started, even though "
"ccw_device_start() returned with successful completion."
msgstr ""

#: ../../../arch/s390/cds.rst:309
msgid ""
"The irb may contain an error value, and the device driver should check for "
"this first:"
msgstr ""

#: ../../../arch/s390/cds.rst:313
msgid "-ETIMEDOUT"
msgstr ""

#: ../../../arch/s390/cds.rst:313
msgid ""
"the common I/O layer terminated the request after the specified timeout value"
msgstr ""

#: ../../../arch/s390/cds.rst:315
msgid "-EIO"
msgstr ""

#: ../../../arch/s390/cds.rst:315
msgid "the common I/O layer terminated the request due to an error state"
msgstr ""

#: ../../../arch/s390/cds.rst:318
msgid ""
"If the concurrent sense flag in the extended status word (esw) in the irb is "
"set, the field erw.scnt in the esw describes the number of device specific "
"sense bytes available in the extended control word irb->scsw.ecw[]. No "
"device sensing by the device driver itself is required."
msgstr ""

#: ../../../arch/s390/cds.rst:323
msgid ""
"The device interrupt handler can use the following definitions to "
"investigate the primary unit check source coded in sense byte 0 :"
msgstr ""

#: ../../../arch/s390/cds.rst:327
msgid "SNS0_CMD_REJECT"
msgstr ""

#: ../../../arch/s390/cds.rst:327
msgid "0x80"
msgstr ""

#: ../../../arch/s390/cds.rst:328
msgid "SNS0_INTERVENTION_REQ"
msgstr ""

#: ../../../arch/s390/cds.rst:328
msgid "0x40"
msgstr ""

#: ../../../arch/s390/cds.rst:329
msgid "SNS0_BUS_OUT_CHECK"
msgstr ""

#: ../../../arch/s390/cds.rst:329
msgid "0x20"
msgstr ""

#: ../../../arch/s390/cds.rst:330
msgid "SNS0_EQUIPMENT_CHECK"
msgstr ""

#: ../../../arch/s390/cds.rst:330
msgid "0x10"
msgstr ""

#: ../../../arch/s390/cds.rst:331
msgid "SNS0_DATA_CHECK"
msgstr ""

#: ../../../arch/s390/cds.rst:331
msgid "0x08"
msgstr ""

#: ../../../arch/s390/cds.rst:332
msgid "SNS0_OVERRUN"
msgstr ""

#: ../../../arch/s390/cds.rst:332
msgid "0x04"
msgstr ""

#: ../../../arch/s390/cds.rst:333
msgid "SNS0_INCOMPL_DOMAIN"
msgstr ""

#: ../../../arch/s390/cds.rst:333
msgid "0x01"
msgstr ""

#: ../../../arch/s390/cds.rst:336
msgid ""
"Depending on the device status, multiple of those values may be set "
"together. Please refer to the device specific documentation for details."
msgstr ""

#: ../../../arch/s390/cds.rst:339
msgid ""
"The irb->scsw.cstat field provides the (accumulated) subchannel status :"
msgstr ""

#: ../../../arch/s390/cds.rst:342
msgid "SCHN_STAT_PCI"
msgstr ""

#: ../../../arch/s390/cds.rst:342
msgid "program controlled interrupt"
msgstr ""

#: ../../../arch/s390/cds.rst:343
msgid "SCHN_STAT_INCORR_LEN"
msgstr ""

#: ../../../arch/s390/cds.rst:343
msgid "incorrect length"
msgstr ""

#: ../../../arch/s390/cds.rst:344
msgid "SCHN_STAT_PROG_CHECK"
msgstr ""

#: ../../../arch/s390/cds.rst:344
msgid "program check"
msgstr ""

#: ../../../arch/s390/cds.rst:345
msgid "SCHN_STAT_PROT_CHECK"
msgstr ""

#: ../../../arch/s390/cds.rst:345
msgid "protection check"
msgstr ""

#: ../../../arch/s390/cds.rst:346
msgid "SCHN_STAT_CHN_DATA_CHK"
msgstr ""

#: ../../../arch/s390/cds.rst:346
msgid "channel data check"
msgstr ""

#: ../../../arch/s390/cds.rst:347
msgid "SCHN_STAT_CHN_CTRL_CHK"
msgstr ""

#: ../../../arch/s390/cds.rst:347
msgid "channel control check"
msgstr ""

#: ../../../arch/s390/cds.rst:348
msgid "SCHN_STAT_INTF_CTRL_CHK"
msgstr ""

#: ../../../arch/s390/cds.rst:348
msgid "interface control check"
msgstr ""

#: ../../../arch/s390/cds.rst:349
msgid "SCHN_STAT_CHAIN_CHECK"
msgstr ""

#: ../../../arch/s390/cds.rst:349
msgid "chaining check"
msgstr ""

#: ../../../arch/s390/cds.rst:352
msgid "The irb->scsw.dstat field provides the (accumulated) device status :"
msgstr ""

#: ../../../arch/s390/cds.rst:355
msgid "DEV_STAT_ATTENTION"
msgstr ""

#: ../../../arch/s390/cds.rst:355
msgid "attention"
msgstr ""

#: ../../../arch/s390/cds.rst:356
msgid "DEV_STAT_STAT_MOD"
msgstr ""

#: ../../../arch/s390/cds.rst:356
msgid "status modifier"
msgstr ""

#: ../../../arch/s390/cds.rst:357
msgid "DEV_STAT_CU_END"
msgstr ""

#: ../../../arch/s390/cds.rst:357
msgid "control unit end"
msgstr ""

#: ../../../arch/s390/cds.rst:358
msgid "DEV_STAT_BUSY"
msgstr ""

#: ../../../arch/s390/cds.rst:358
msgid "busy"
msgstr ""

#: ../../../arch/s390/cds.rst:359
msgid "DEV_STAT_CHN_END"
msgstr ""

#: ../../../arch/s390/cds.rst:359
msgid "channel end"
msgstr ""

#: ../../../arch/s390/cds.rst:360
msgid "DEV_STAT_DEV_END"
msgstr ""

#: ../../../arch/s390/cds.rst:360
msgid "device end"
msgstr ""

#: ../../../arch/s390/cds.rst:361
msgid "DEV_STAT_UNIT_CHECK"
msgstr ""

#: ../../../arch/s390/cds.rst:361
msgid "unit check"
msgstr ""

#: ../../../arch/s390/cds.rst:362
msgid "DEV_STAT_UNIT_EXCEP"
msgstr ""

#: ../../../arch/s390/cds.rst:362
msgid "unit exception"
msgstr ""

#: ../../../arch/s390/cds.rst:365
msgid ""
"Please see the ESA/390 Principles of Operation manual for details on the "
"individual flag meanings."
msgstr ""

#: ../../../arch/s390/cds.rst:368 ../../../arch/s390/cds.rst:443
#: ../../../arch/s390/cds.rst:478
msgid "Usage Notes:"
msgstr ""

#: ../../../arch/s390/cds.rst:370
msgid ""
"ccw_device_start() must be called disabled and with the ccw device lock held."
msgstr ""

#: ../../../arch/s390/cds.rst:372
msgid ""
"The device driver is allowed to issue the next ccw_device_start() call from "
"within its interrupt handler already. It is not required to schedule a "
"bottom-half, unless a non deterministically long running error recovery "
"procedure or similar needs to be scheduled. During I/O processing the "
"Linux/390 generic I/O device driver support has already obtained the IRQ "
"lock, i.e. the handler must not try to obtain it again when calling "
"ccw_device_start() or we end in a deadlock situation!"
msgstr ""

#: ../../../arch/s390/cds.rst:380
msgid ""
"If a device driver relies on an I/O request to be completed prior to start "
"the next it can reduce I/O processing overhead by chaining a NoOp I/O "
"command CCW_CMD_NOOP to the end of the submitted CCW chain. This will force "
"Channel-End and Device-End status to be presented together, with a single "
"interrupt. However, this should be used with care as it implies the channel "
"will remain busy, not being able to process I/O requests for other devices "
"on the same channel. Therefore e.g. read commands should never use this "
"technique, as the result will be presented by a single interrupt anyway."
msgstr ""

#: ../../../arch/s390/cds.rst:389
msgid ""
"In order to minimize I/O overhead, a device driver should use the "
"DOIO_REPORT_ALL  only if the device can report intermediate interrupt "
"information prior to device-end the device driver urgently relies on. In "
"this case all I/O interruptions are presented to the device driver until "
"final status is recognized."
msgstr ""

#: ../../../arch/s390/cds.rst:395
msgid ""
"If a device is able to recover from asynchronously presented I/O errors, it "
"can perform overlapping I/O using the DOIO_EARLY_NOTIFICATION flag. While "
"some devices always report channel-end and device-end together, with a "
"single interrupt, others present primary status (channel-end) when the "
"channel is ready for the next I/O request and secondary status (device-end) "
"when the data transmission has been completed at the device."
msgstr ""

#: ../../../arch/s390/cds.rst:402
msgid ""
"Above flag allows to exploit this feature, e.g. for communication devices "
"that can handle lost data on the network to allow for enhanced I/O "
"processing."
msgstr ""

#: ../../../arch/s390/cds.rst:405
msgid ""
"Unless the channel subsystem at any time presents a secondary status "
"interrupt, exploiting this feature will cause only primary status interrupts "
"to be presented to the device driver while overlapping I/O is performed. "
"When a secondary status without error (alert status) is presented, this "
"indicates successful completion for all overlapping ccw_device_start() "
"requests that have been issued since the last secondary (final) status."
msgstr ""

#: ../../../arch/s390/cds.rst:412
msgid ""
"Channel programs that intend to set the suspend flag on a channel command "
"word (CCW)  must start the I/O operation with the DOIO_ALLOW_SUSPEND option "
"or the suspend flag will cause a channel program check. At the time the "
"channel program becomes suspended an intermediate interrupt will be "
"generated by the channel subsystem."
msgstr ""

#: ../../../arch/s390/cds.rst:418
msgid "ccw_device_resume() - Resume Channel Program Execution"
msgstr ""

#: ../../../arch/s390/cds.rst:420
msgid ""
"If a device driver chooses to suspend the current channel program execution "
"by setting the CCW suspend flag on a particular CCW, the channel program "
"execution is suspended. In order to resume channel program execution the CIO "
"layer provides the ccw_device_resume() routine."
msgstr ""

#: ../../../arch/s390/cds.rst:430
msgid "ccw_device the resume operation is requested for"
msgstr ""

#: ../../../arch/s390/cds.rst:433
msgid "The ccw_device_resume() function returns:"
msgstr ""

#: ../../../arch/s390/cds.rst:436
msgid "suspended channel program is resumed"
msgstr ""

#: ../../../arch/s390/cds.rst:437
msgid "status pending"
msgstr ""

#: ../../../arch/s390/cds.rst:438
msgid "cdev invalid or not-operational subchannel"
msgstr ""

#: ../../../arch/s390/cds.rst:439 ../../../arch/s390/cds.rst:475
#: ../../../arch/s390/cds.rst:512
msgid "-EINVAL"
msgstr ""

#: ../../../arch/s390/cds.rst:439
msgid "resume function not applicable"
msgstr ""

#: ../../../arch/s390/cds.rst:440
msgid "-ENOTCONN"
msgstr ""

#: ../../../arch/s390/cds.rst:440
msgid "there is no I/O request pending for completion"
msgstr ""

#: ../../../arch/s390/cds.rst:445
msgid ""
"Please have a look at the ccw_device_start() usage notes for more details on "
"suspended channel programs."
msgstr ""

#: ../../../arch/s390/cds.rst:448
msgid "ccw_device_halt() - Halt I/O Request Processing"
msgstr ""

#: ../../../arch/s390/cds.rst:450
msgid ""
"Sometimes a device driver might need a possibility to stop the processing of "
"a long-running channel program or the device might require to initially "
"issue a halt subchannel (HSCH) I/O command. For those purposes the "
"ccw_device_halt() command is provided."
msgstr ""

#: ../../../arch/s390/cds.rst:455
msgid ""
"ccw_device_halt() must be called disabled and with the ccw device lock held."
msgstr ""

#: ../../../arch/s390/cds.rst:463
msgid "ccw_device the halt operation is requested for"
msgstr ""

#: ../../../arch/s390/cds.rst:464 ../../../arch/s390/cds.rst:504
msgid "intparm"
msgstr ""

#: ../../../arch/s390/cds.rst:464
msgid ""
"interruption parameter; value is only used if no I/O is outstanding, "
"otherwise the intparm associated with the I/O request is returned"
msgstr ""

#: ../../../arch/s390/cds.rst:469
msgid "The ccw_device_halt() function returns:"
msgstr ""

#: ../../../arch/s390/cds.rst:472 ../../../arch/s390/cds.rst:510
msgid "request successfully initiated"
msgstr ""

#: ../../../arch/s390/cds.rst:473
msgid "the device is currently busy, or status pending."
msgstr ""

#: ../../../arch/s390/cds.rst:474
msgid "cdev invalid."
msgstr ""

#: ../../../arch/s390/cds.rst:475 ../../../arch/s390/cds.rst:512
msgid "The device is not operational or the ccw device is not online."
msgstr ""

#: ../../../arch/s390/cds.rst:480
msgid ""
"A device driver may write a never-ending channel program by writing a "
"channel program that at its end loops back to its beginning by means of a "
"transfer in channel (TIC)   command (CCW_CMD_TIC). Usually this is performed "
"by network device drivers by setting the PCI CCW flag (CCW_FLAG_PCI). Once "
"this CCW is executed a program controlled interrupt (PCI) is generated. The "
"device driver can then perform an appropriate action. Prior to interrupt of "
"an outstanding read to a network device (with or without PCI flag) a "
"ccw_device_halt() is required to end the pending operation."
msgstr ""

#: ../../../arch/s390/cds.rst:493
msgid ""
"In order to terminate all I/O processing at the subchannel, the clear "
"subchannel (CSCH) command is used. It can be issued via ccw_device_clear()."
msgstr ""

#: ../../../arch/s390/cds.rst:496
msgid ""
"ccw_device_clear() must be called disabled and with the ccw device lock held."
msgstr ""

#: ../../../arch/s390/cds.rst:503
msgid "ccw_device the clear operation is requested for"
msgstr ""

#: ../../../arch/s390/cds.rst:504
msgid "interruption parameter (see ccw_device_halt())"
msgstr ""

#: ../../../arch/s390/cds.rst:507
msgid "The ccw_device_clear() function returns:"
msgstr ""

#: ../../../arch/s390/cds.rst:511
msgid "cdev invalid"
msgstr ""

#: ../../../arch/s390/cds.rst:516
msgid "Miscellaneous Support Routines"
msgstr ""

#: ../../../arch/s390/cds.rst:518
msgid ""
"This chapter describes various routines to be used in a Linux/390 device "
"driver programming environment."
msgstr ""

#: ../../../arch/s390/cds.rst:521
msgid "get_ccwdev_lock()"
msgstr ""

#: ../../../arch/s390/cds.rst:523
msgid ""
"Get the address of the device specific lock. This is then used in "
"spin_lock() / spin_unlock() calls."
msgstr ""

#: ../../../arch/s390/cds.rst:530
msgid "Get the mask of the path currently available for cdev."
msgstr ""
