# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/rv/monitor_sched.rst:2
msgid "Scheduler monitors"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:4
msgid "Name: sched"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:5
msgid "Type: container for multiple monitors"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:6
msgid ""
"Author: Gabriele Monaco <gmonaco@redhat.com>, Daniel Bristot de Oliveira "
"<bristot@kernel.org>"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:9
msgid "Description"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:11
msgid ""
"Monitors describing complex systems, such as the scheduler, can easily grow "
"to the point where they are just hard to understand because of the many "
"possible state transitions. Often it is possible to break such descriptions "
"into smaller monitors, sharing some or all events. Enabling those smaller "
"monitors concurrently is, in fact, testing the system as if we had one "
"single larger monitor. Splitting models into multiple specification is not "
"only easier to understand, but gives some more clues when we see errors."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:20
msgid ""
"The sched monitor is a set of specifications to describe the scheduler "
"behaviour. It includes several per-cpu and per-task monitors that work "
"independently to verify different specifications the scheduler should follow."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:24
msgid ""
"To make this system as straightforward as possible, sched specifications are "
"*nested* monitors, whereas sched itself is a *container*. From the interface "
"perspective, sched includes other monitors as sub-directories, enabling/"
"disabling or setting reactors to sched, propagates the change to all "
"monitors, however single monitors can be used independently as well."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:30
msgid ""
"It is important that future modules are built after their container (sched, "
"in this case), otherwise the linker would not respect the order and the "
"nesting wouldn't work as expected. To do so, simply add them after sched in "
"the Makefile."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:36
msgid "Specifications"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:38
msgid ""
"The specifications included in sched are currently a work in progress, "
"adapting the ones defined in by Daniel Bristot in [1]."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:41
msgid "Currently we included the following:"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:44
msgid "Monitor sco"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:46
msgid ""
"The scheduling context operations (sco) monitor ensures changes in a task "
"state happen only in thread context::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:65
msgid "Monitor snroc"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:67
msgid ""
"The set non runnable on its own context (snroc) monitor ensures changes in a "
"task state happens only in the respective task's context. This is a per-task "
"monitor::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:86
msgid "Monitor scpd"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:88
msgid ""
"The schedule called with preemption disabled (scpd) monitor ensures schedule "
"is called with preemption disabled::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:107
msgid "Monitor snep"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:109
msgid ""
"The schedule does not enable preempt (snep) monitor ensures a schedule call "
"does not enable preemption::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:128
msgid "Monitor sts"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:130
msgid ""
"The schedule implies task switch (sts) monitor ensures a task switch happens "
"only in scheduling context and up to once, as well as scheduling occurs with "
"interrupts enabled but no task switch can happen before interrupts are "
"disabled. When the next task picked for execution is the same as the "
"previously running one, no real task switch occurs but interrupts are "
"disabled nonetheless::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:178
msgid "Monitor nrp"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:180
msgid ""
"The need resched preempts (nrp) monitor ensures preemption requires "
"``need_resched``. Only kernel preemption is considered, since preemption "
"while returning to userspace, for this monitor, is indistinguishable from "
"``sched_switch_yield`` (described in the sssw monitor). A kernel preemption "
"is whenever ``__schedule`` is called with the preemption flag set to true (e."
"g. from preempt_enable or exiting from interrupts). This type of preemption "
"occurs after the need for ``rescheduling`` has been set. This is not valid "
"for the *lazy* variant of the flag, which causes only userspace preemption. "
"A ``schedule_entry_preempt`` may involve a task switch or not, in the latter "
"case, a task goes through the scheduler from a preemption context but it is "
"picked as the next task to run. Since the scheduler runs, this clears the "
"need to reschedule. The ``any_thread_running`` state does not imply the "
"monitored task is not running as this monitor does not track the outcome of "
"scheduling."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:195
msgid ""
"In theory, a preemption can only occur after the ``need_resched`` flag is "
"set. In practice, however, it is possible to see a preemption where the flag "
"is not set. This can happen in one specific condition::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:206
msgid ""
"In the situation above, standard preemption starts (e.g. from preempt_enable "
"when the flag is set), an interrupt occurs before scheduling and, on its "
"exit path, it schedules, which clears the ``need_resched`` flag. When the "
"preempted task runs again, the standard preemption started earlier resumes, "
"although the flag is no longer set. The monitor considers this a "
"``nested_preemption``, this allows another preemption without re-setting the "
"flag. This condition relaxes the monitor constraints and may catch false "
"negatives (i.e. no real ``nested_preemptions``) but makes the monitor more "
"robust and able to validate other scenarios. For simplicity, the monitor "
"starts in ``preempt_irq``, although no interrupt occurred, as the situation "
"above is hard to pinpoint::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:253
msgid ""
"Due to how the ``need_resched`` flag on the preemption count works on arm64, "
"this monitor is unstable on that architecture, as it often records "
"preemption when the flag is not set, even in presence of the workaround "
"above. For the time being, the monitor is disabled by default on arm64."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:259
msgid "Monitor sssw"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:261
msgid ""
"The set state sleep and wakeup (sssw) monitor ensures ``set_state`` to "
"sleepable leads to sleeping and sleeping tasks require wakeup. It includes "
"the following types of switch:"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:265
msgid ""
"``switch_suspend``: a task puts itself to sleep, this can happen only after "
"explicitly setting the task to ``sleepable``. After a task is suspended, it "
"needs to be woken up (``waking`` state) before being switched in again. "
"Setting the task's state to ``sleepable`` can be reverted before switching "
"if it is woken up or set to ``runnable``."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:271
msgid ""
"``switch_blocking``: a special case of a ``switch_suspend`` where the task "
"is waiting on a sleeping RT lock (``PREEMPT_RT`` only), it is common to see "
"wakeup and set state events racing with each other and this leads the model "
"to perceive this type of switch when the task is not set to sleepable. This "
"is a limitation of the model in SMP system and workarounds may slow down the "
"system."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:277
msgid ""
"``switch_preempt``: a task switch as a result of kernel preemption "
"(``schedule_entry_preempt`` in the nrp model)."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:280
msgid ""
"``switch_yield``: a task explicitly calls the scheduler or is preempted "
"while returning to userspace. It can happen after a ``yield`` system call, "
"from the idle task or if the ``need_resched`` flag is set. By definition, a "
"task cannot yield while ``sleepable`` as that would be a suspension. A "
"special case of a yield occurs when a task in ``TASK_INTERRUPTIBLE`` calls "
"the scheduler while a signal is pending. The task doesn't go through the "
"usual blocking/waking and is set back to runnable, the resulting switch (if "
"there) looks like a yield to the ``signal_wakeup`` state and is followed by "
"the signal delivery. From this state, the monitor expects a signal even if "
"it sees a wakeup event, although not necessary, to rule out false negatives."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:292
msgid ""
"This monitor doesn't include a running state, ``sleepable`` and ``runnable`` "
"are only referring to the task's desired state, which could be scheduled out "
"(e.g. due to preemption). However, it does include the event "
"``sched_switch_in`` to represent when a task is allowed to become running. "
"This can be triggered also by preemption, but cannot occur after the task "
"got to ``sleeping`` before a ``wakeup`` occurs::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:345
msgid "Monitor opid"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:347
msgid ""
"The operations with preemption and irq disabled (opid) monitor ensures "
"operations like ``wakeup`` and ``need_resched`` occur with interrupts and "
"preemption disabled or during interrupt context, in such case preemption may "
"not be disabled explicitly. ``need_resched`` can be set by some RCU "
"internals functions, in which case it doesn't match a task wakeup and might "
"occur with only interrupts disabled::"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:392
msgid ""
"This monitor is designed to work on ``PREEMPT_RT`` kernels, the special case "
"of events occurring in interrupt context is a shortcut to identify valid "
"scenarios where the preemption tracepoints might not be visible, during "
"interrupts preemption is always disabled. On non- ``PREEMPT_RT`` kernels, "
"the interrupts might invoke a softirq to set ``need_resched`` and wake up a "
"task. This is another special case that is currently not supported by the "
"monitor."
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:400
msgid "References"
msgstr ""

#: ../../../trace/rv/monitor_sched.rst:402
msgid "[1] - https://bristot.me/linux-task-model"
msgstr ""
