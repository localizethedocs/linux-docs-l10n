# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scheduler/sched-deadline.rst:3
msgid "Deadline Task Scheduling"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:31
msgid "0. WARNING"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:33
msgid ""
"Fiddling with these settings can result in an unpredictable or even unstable "
"system behavior. As for -rt (group) scheduling, it is assumed that root "
"users know what they're doing."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:39
msgid "1. Overview"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:41
msgid ""
"The SCHED_DEADLINE policy contained inside the sched_dl scheduling class is "
"basically an implementation of the Earliest Deadline First (EDF) scheduling "
"algorithm, augmented with a mechanism (called Constant Bandwidth Server, "
"CBS) that makes it possible to isolate the behavior of tasks between each "
"other."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:48
msgid "2. Scheduling algorithm"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:51
msgid "2.1 Main algorithm"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:53
msgid ""
"SCHED_DEADLINE [18] uses three parameters, named \"runtime\", \"period\", "
"and \"deadline\", to schedule tasks. A SCHED_DEADLINE task should receive "
"\"runtime\" microseconds of execution time every \"period\" microseconds, "
"and these \"runtime\" microseconds are available within \"deadline\" "
"microseconds from the beginning of the period.  In order to implement this "
"behavior, every time the task wakes up, the scheduler computes a "
"\"scheduling deadline\" consistent with the guarantee (using the CBS[2,3] "
"algorithm). Tasks are then scheduled using EDF[1] on these scheduling "
"deadlines (the task with the earliest scheduling deadline is selected for "
"execution). Notice that the task actually receives \"runtime\" time units "
"within \"deadline\" if a proper \"admission control\" strategy (see Section "
"\"4. Bandwidth management\") is used (clearly, if the system is overloaded "
"this guarantee cannot be respected)."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:66
msgid ""
"Summing up, the CBS[2,3] algorithm assigns scheduling deadlines to tasks so "
"that each task runs for at most its runtime every period, avoiding any "
"interference between different tasks (bandwidth isolation), while the EDF[1] "
"algorithm selects the task with the earliest scheduling deadline as the one "
"to be executed next. Thanks to this feature, tasks that do not strictly "
"comply with the \"traditional\" real-time task model (see Section 3) can "
"effectively use the new policy."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:74
msgid ""
"In more details, the CBS algorithm assigns scheduling deadlines to tasks in "
"the following way:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:77
msgid ""
"Each SCHED_DEADLINE task is characterized by the \"runtime\", \"deadline\", "
"and \"period\" parameters;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:80
msgid ""
"The state of the task is described by a \"scheduling deadline\", and a "
"\"remaining runtime\". These two parameters are initially set to 0;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:83
msgid ""
"When a SCHED_DEADLINE task wakes up (becomes ready for execution), the "
"scheduler checks if::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:90
msgid ""
"then, if the scheduling deadline is smaller than the current time, or this "
"condition is verified, the scheduling deadline and the remaining runtime are "
"re-initialized as"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:94
msgid ""
"scheduling deadline = current time + deadline remaining runtime = runtime"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:97
msgid ""
"otherwise, the scheduling deadline and the remaining runtime are left "
"unchanged;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:100
msgid ""
"When a SCHED_DEADLINE task executes for an amount of time t, its remaining "
"runtime is decreased as::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:105
msgid ""
"(technically, the runtime is decreased at every tick, or when the task is "
"descheduled / preempted);"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:108
msgid ""
"When the remaining runtime becomes less or equal than 0, the task is said to "
"be \"throttled\" (also known as \"depleted\" in real-time literature) and "
"cannot be scheduled until its scheduling deadline. The \"replenishment "
"time\" for this task (see next item) is set to be equal to the current value "
"of the scheduling deadline;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:114
msgid ""
"When the current time is equal to the replenishment time of a throttled "
"task, the scheduling deadline and the remaining runtime are updated as::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:121
msgid ""
"The SCHED_FLAG_DL_OVERRUN flag in sched_attr's sched_flags field allows a "
"task to get informed about runtime overruns through the delivery of SIGXCPU "
"signals."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:127
msgid "2.2 Bandwidth reclaiming"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:129
msgid ""
"Bandwidth reclaiming for deadline tasks is based on the GRUB (Greedy "
"Reclamation of Unused Bandwidth) algorithm [15, 16, 17] and it is enabled "
"when flag SCHED_FLAG_RECLAIM is set."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:133
msgid ""
"The following diagram illustrates the state names for tasks handled by GRUB::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:153
msgid "A task can be in one of the following states:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:155
msgid "ActiveContending: if it is ready for execution (or executing);"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:157
msgid ""
"ActiveNonContending: if it just blocked and has not yet surpassed the 0-lag "
"time;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:160
msgid "Inactive: if it is blocked and has surpassed the 0-lag time."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:162
msgid "State transitions:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:164
msgid ""
"When a task blocks, it does not become immediately inactive since its "
"bandwidth cannot be immediately reclaimed without breaking the real-time "
"guarantees. It therefore enters a transitional state called "
"ActiveNonContending. The scheduler arms the \"inactive timer\" to fire at "
"the 0-lag time, when the task's bandwidth can be reclaimed without breaking "
"the real-time guarantees."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:171
msgid ""
"The 0-lag time for a task entering the ActiveNonContending state is computed "
"as::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:178
msgid ""
"where runtime is the remaining runtime, while dl_runtime and dl_period are "
"the reservation parameters."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:181
msgid ""
"If the task wakes up before the inactive timer fires, the task re-enters the "
"ActiveContending state and the \"inactive timer\" is canceled. In addition, "
"if the task wakes up on a different runqueue, then the task's utilization "
"must be removed from the previous runqueue's active utilization and must be "
"added to the new runqueue's active utilization. In order to avoid races "
"between a task waking up on a runqueue while the \"inactive timer\" is "
"running on a different CPU, the \"dl_non_contending\" flag is used to "
"indicate that a task is not on a runqueue but is active (so, the flag is set "
"when the task blocks and is cleared when the \"inactive timer\" fires or "
"when the task  wakes up)."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:192
msgid ""
"When the \"inactive timer\" fires, the task enters the Inactive state and "
"its utilization is removed from the runqueue's active utilization."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:195
msgid ""
"When an inactive task wakes up, it enters the ActiveContending state and its "
"utilization is added to the active utilization of the runqueue where it has "
"been enqueued."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:199
msgid ""
"For each runqueue, the algorithm GRUB keeps track of two different "
"bandwidths:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:201
msgid ""
"Active bandwidth (running_bw): this is the sum of the bandwidths of all "
"tasks in active state (i.e., ActiveContending or ActiveNonContending);"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:204
msgid ""
"Total bandwidth (this_bw): this is the sum of all tasks \"belonging\" to the "
"runqueue, including the tasks in Inactive state."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:207
msgid ""
"Maximum usable bandwidth (max_bw): This is the maximum bandwidth usable by "
"deadline tasks and is currently set to the RT capacity."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:211
msgid ""
"The algorithm reclaims the bandwidth of the tasks in Inactive state. It does "
"so by decrementing the runtime of the executing task Ti at a pace equal to"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:215
msgid "dq = -(max{ Ui, (Umax - Uinact - Uextra) } / Umax) dt"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:217
msgid "where:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:219
msgid "Ui is the bandwidth of task Ti;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:220
msgid ""
"Umax is the maximum reclaimable utilization (subjected to RT throttling "
"limits);"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:222
msgid ""
"Uinact is the (per runqueue) inactive utilization, computed as (this_bq - "
"running_bw);"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:224
msgid ""
"Uextra is the (per runqueue) extra reclaimable utilization (subjected to RT "
"throttling limits)."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:228
msgid ""
"Let's now see a trivial example of two deadline tasks with runtime equal to "
"4 and period equal to 8 (i.e., bandwidth equal to 0.5)::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:291
msgid "2.3 Energy-aware scheduling"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:293
msgid ""
"When cpufreq's schedutil governor is selected, SCHED_DEADLINE implements the "
"GRUB-PA [19] algorithm, reducing the CPU operating frequency to the minimum "
"value that still allows to meet the deadlines. This behavior is currently "
"implemented only for ARM architectures."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:298
msgid ""
"A particular care must be taken in case the time needed for changing "
"frequency is of the same order of magnitude of the reservation period. In "
"such cases, setting a fixed CPU frequency results in a lower amount of "
"deadline misses."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:304
msgid "3. Scheduling Real-Time Tasks"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:312
msgid ""
"This section contains a (not-thorough) summary on classical deadline "
"scheduling theory, and how it applies to SCHED_DEADLINE. The reader can "
"\"safely\" skip to Section 4 if only interested in seeing how the scheduling "
"policy can be used. Anyway, we strongly recommend to come back here and "
"continue reading (once the urge for testing is satisfied :P) to be sure of "
"fully understanding all technical details."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:321
msgid ""
"There are no limitations on what kind of task can exploit this new "
"scheduling discipline, even if it must be said that it is particularly "
"suited for periodic or sporadic real-time tasks that need guarantees on "
"their timing behavior, e.g., multimedia, streaming, control applications, "
"etc."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:327
msgid "3.1 Definitions"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:329
msgid ""
"A typical real-time task is composed of a repetition of computation phases "
"(task instances, or jobs) which are activated on a periodic or sporadic "
"fashion. Each job J_j (where J_j is the j^th job of the task) is "
"characterized by an arrival time r_j (the time when the job starts), an "
"amount of computation time c_j needed to finish the job, and a job absolute "
"deadline d_j, which is the time within which the job should be finished. The "
"maximum execution time max{c_j} is called \"Worst Case Execution "
"Time\" (WCET) for the task. A real-time task can be periodic with period P "
"if r_{j+1} = r_j + P, or sporadic with minimum inter-arrival time P is "
"r_{j+1} >= r_j + P. Finally, d_j = r_j + D, where D is the task's relative "
"deadline. Summing up, a real-time task can be described as"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:342
msgid "Task = (WCET, D, P)"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:344
msgid ""
"The utilization of a real-time task is defined as the ratio between its WCET "
"and its period (or minimum inter-arrival time), and represents the fraction "
"of CPU time needed to execute the task."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:348
msgid ""
"If the total utilization U=sum(WCET_i/P_i) is larger than M (with M equal to "
"the number of CPUs), then the scheduler is unable to respect all the "
"deadlines. Note that total utilization is defined as the sum of the "
"utilizations WCET_i/P_i over all the real-time tasks in the system. When "
"considering multiple real-time tasks, the parameters of the i-th task are "
"indicated with the \"_i\" suffix. Moreover, if the total utilization is "
"larger than M, then we risk starving non- real-time tasks by real-time "
"tasks. If, instead, the total utilization is smaller than M, then non real-"
"time tasks will not be starved and the system might be able to respect all "
"the deadlines. As a matter of fact, in this case it is possible to provide "
"an upper bound for tardiness (defined as the maximum between 0 and the "
"difference between the finishing time of a job and its absolute deadline). "
"More precisely, it can be proven that using a global EDF scheduler the "
"maximum tardiness of each task is smaller or equal than"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:366
msgid "((M − 1) · WCET_max − WCET_min)/(M − (M − 2) · U_max) + WCET_max"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:368
msgid ""
"where WCET_max = max{WCET_i} is the maximum WCET, WCET_min=min{WCET_i} is "
"the minimum WCET, and U_max = max{WCET_i/P_i} is the maximum utilization[12]."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:373
msgid "3.2 Schedulability Analysis for Uniprocessor Systems"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:375
msgid ""
"If M=1 (uniprocessor system), or in case of partitioned scheduling (each "
"real-time task is statically assigned to one and only one CPU), it is "
"possible to formally check if all the deadlines are respected. If D_i = P_i "
"for all tasks, then EDF is able to respect all the deadlines of all the "
"tasks executing on a CPU if and only if the total utilization of the tasks "
"running on such a CPU is smaller or equal than 1. If D_i != P_i for some "
"task, then it is possible to define the density of a task as WCET_i/min{D_i,"
"P_i}, and EDF is able to respect all the deadlines of all the tasks running "
"on a CPU if the sum of the densities of the tasks running on such a CPU is "
"smaller or equal than 1:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:386
msgid "sum(WCET_i / min{D_i, P_i}) <= 1"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:388
msgid ""
"It is important to notice that this condition is only sufficient, and not "
"necessary: there are task sets that are schedulable, but do not respect the "
"condition. For example, consider the task set {Task_1,Task_2} composed by "
"Task_1=(50ms,50ms,100ms) and Task_2=(10ms,100ms,100ms). EDF is clearly able "
"to schedule the two tasks without missing any deadline (Task_1 is scheduled "
"as soon as it is released, and finishes just in time to respect its "
"deadline; Task_2 is scheduled immediately after Task_1, hence its response "
"time cannot be larger than 50ms + 10ms = 60ms) even if"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:397
msgid "50 / min{50,100} + 10 / min{100, 100} = 50 / 50 + 10 / 100 = 1.1"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:399
msgid ""
"Of course it is possible to test the exact schedulability of tasks with D_i !"
"= P_i (checking a condition that is both sufficient and necessary), but this "
"cannot be done by comparing the total utilization or density with a "
"constant. Instead, the so called \"processor demand\" approach can be used, "
"computing the total amount of CPU time h(t) needed by all the tasks to "
"respect all of their deadlines in a time interval of size t, and comparing "
"such a time with the interval size t. If h(t) is smaller than t (that is, "
"the amount of time needed by the tasks in a time interval of size t is "
"smaller than the size of the interval) for all the possible values of t, "
"then EDF is able to schedule the tasks respecting all of their deadlines. "
"Since performing this check for all possible values of t is impossible, it "
"has been proven[4,5,6] that it is sufficient to perform the test for values "
"of t between 0 and a maximum value L. The cited papers contain all of the "
"mathematical details and explain how to compute h(t) and L. In any case, "
"this kind of analysis is too complex as well as too time-consuming to be "
"performed on-line. Hence, as explained in Section 4 Linux uses an admission "
"test based on the tasks' utilizations."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:418
msgid "3.3 Schedulability Analysis for Multiprocessor Systems"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:420
msgid ""
"On multiprocessor systems with global EDF scheduling (non partitioned "
"systems), a sufficient test for schedulability can not be based on the "
"utilizations or densities: it can be shown that even if D_i = P_i task sets "
"with utilizations slightly larger than 1 can miss deadlines regardless of "
"the number of CPUs."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:426
msgid ""
"Consider a set {Task_1,...Task_{M+1}} of M+1 tasks on a system with M CPUs, "
"with the first task Task_1=(P,P,P) having period, relative deadline and WCET "
"equal to P. The remaining M tasks Task_i=(e,P-1,P-1) have an arbitrarily "
"small worst case execution time (indicated as \"e\" here) and a period "
"smaller than the one of the first task. Hence, if all the tasks activate at "
"the same time t, global EDF schedules these M tasks first (because their "
"absolute deadlines are equal to t + P - 1, hence they are smaller than the "
"absolute deadline of Task_1, which is t + P). As a result, Task_1 can be "
"scheduled only at time t + e, and will finish at time t + e + P, after its "
"absolute deadline. The total utilization of the task set is U = M · e / (P - "
"1) + P / P = M · e / (P - 1) + 1, and for small values of e this can become "
"very close to 1. This is known as \"Dhall's effect\"[7]. Note: the example "
"in the original paper by Dhall has been slightly simplified here (for "
"example, Dhall more correctly computed lim_{e->0}U)."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:442
msgid ""
"More complex schedulability tests for global EDF have been developed in real-"
"time literature[8,9], but they are not based on a simple comparison between "
"total utilization (or density) and a fixed constant. If all tasks have D_i = "
"P_i, a sufficient schedulability condition can be expressed in a simple way:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:448
msgid "sum(WCET_i / P_i) <= M - (M - 1) · U_max"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:450
msgid ""
"where U_max = max{WCET_i / P_i}[10]. Notice that for U_max = 1, M - (M - 1) "
"· U_max becomes M - M + 1 = 1 and this schedulability condition just "
"confirms the Dhall's effect. A more complete survey of the literature about "
"schedulability tests for multi-processor real-time scheduling can be found "
"in [11]."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:456
msgid ""
"As seen, enforcing that the total utilization is smaller than M does not "
"guarantee that global EDF schedules the tasks without missing any deadline "
"(in other words, global EDF is not an optimal scheduling algorithm). "
"However, a total utilization smaller than M is enough to guarantee that non "
"real-time tasks are not starved and that the tardiness of real-time tasks "
"has an upper bound[12] (as previously noted). Different bounds on the "
"maximum tardiness experienced by real-time tasks have been developed in "
"various papers[13,14], but the theoretical result that is important for "
"SCHED_DEADLINE is that if the total utilization is smaller or equal than M "
"then the response times of the tasks are limited."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:468
msgid "3.4 Relationship with SCHED_DEADLINE Parameters"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:470
msgid ""
"Finally, it is important to understand the relationship between the "
"SCHED_DEADLINE scheduling parameters described in Section 2 (runtime, "
"deadline and period) and the real-time task parameters (WCET, D, P) "
"described in this section. Note that the tasks' temporal constraints are "
"represented by its absolute deadlines d_j = r_j + D described above, while "
"SCHED_DEADLINE schedules the tasks according to scheduling deadlines (see "
"Section 2). If an admission test is used to guarantee that the scheduling "
"deadlines are respected, then SCHED_DEADLINE can be used to schedule real-"
"time tasks guaranteeing that all the jobs' deadlines of a task are "
"respected. In order to do this, a task must be scheduled by setting:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:482
msgid "runtime >= WCET"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:483
msgid "deadline = D"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:484
msgid "period <= P"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:486
msgid ""
"IOW, if runtime >= WCET and if period is <= P, then the scheduling deadlines "
"and the absolute deadlines (d_j) coincide, so a proper admission control "
"allows to respect the jobs' absolute deadlines for this task (this is what "
"is called \"hard schedulability property\" and is an extension of Lemma 1 of "
"[2]). Notice that if runtime > deadline the admission control will surely "
"reject this task, as it is not possible to respect its temporal constraints."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:493
msgid "References:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:495
msgid ""
"1 - C. L. Liu and J. W. Layland. Scheduling algorithms for multiprogram-"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:496
msgid ""
"ming in a hard-real-time environment. Journal of the Association for "
"Computing Machinery, 20(1), 1973."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:498
msgid "2 - L. Abeni , G. Buttazzo. Integrating Multimedia Applications in Hard"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:499
msgid ""
"Real-Time Systems. Proceedings of the 19th IEEE Real-time Systems Symposium, "
"1998. http://retis.sssup.it/~giorgio/paps/1998/rtss98-cbs.pdf"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:501
msgid "3 - L. Abeni. Server Mechanisms for Multimedia Applications. ReTiS Lab"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:502
msgid "Technical Report. http://disi.unitn.it/~abeni/tr-98-01.pdf"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:503
msgid "4 - J. Y. Leung and M.L. Merril. A Note on Preemptive Scheduling of"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:504
msgid ""
"Periodic, Real-Time Tasks. Information Processing Letters, vol. 11, no. 3, "
"pp. 115-118, 1980."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:506
msgid "5 - S. K. Baruah, A. K. Mok and L. E. Rosier. Preemptively Scheduling"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:507
msgid ""
"Hard-Real-Time Sporadic Tasks on One Processor. Proceedings of the 11th IEEE "
"Real-time Systems Symposium, 1990."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:509
msgid ""
"6 - S. K. Baruah, L. E. Rosier and R. R. Howell. Algorithms and Complexity"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:510
msgid ""
"Concerning the Preemptive Scheduling of Periodic Real-Time tasks on One "
"Processor. Real-Time Systems Journal, vol. 4, no. 2, pp 301-324, 1990."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:513
msgid ""
"7 - S. J. Dhall and C. L. Liu. On a real-time scheduling problem. Operations"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:514
msgid "research, vol. 26, no. 1, pp 127-140, 1978."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:515
msgid "8 - T. Baker. Multiprocessor EDF and Deadline Monotonic Schedulability"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:516
msgid ""
"Analysis. Proceedings of the 24th IEEE Real-Time Systems Symposium, 2003."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:517
msgid "9 - T. Baker. An Analysis of EDF Schedulability on a Multiprocessor."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:518
msgid ""
"IEEE Transactions on Parallel and Distributed Systems, vol. 16, no. 8, pp "
"760-768, 2005."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:520
msgid "10 - J. Goossens, S. Funk and S. Baruah, Priority-Driven Scheduling of"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:521
msgid ""
"Periodic Task Systems on Multiprocessors. Real-Time Systems Journal, vol. "
"25, no. 2–3, pp. 187–205, 2003."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:523
msgid "11 - R. Davis and A. Burns. A Survey of Hard Real-Time Scheduling for"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:524
msgid ""
"Multiprocessor Systems. ACM Computing Surveys, vol. 43, no. 4, 2011. http://"
"www-users.cs.york.ac.uk/~robdavis/papers/MPSurveyv5.0.pdf"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:526
msgid "12 - U. C. Devi and J. H. Anderson. Tardiness Bounds under Global EDF"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:527
msgid ""
"Scheduling on a Multiprocessor. Real-Time Systems Journal, vol. 32, no. 2, "
"pp 133-189, 2008."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:529
msgid "13 - P. Valente and G. Lipari. An Upper Bound to the Lateness of Soft"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:530
msgid ""
"Real-Time Tasks Scheduled by EDF on Multiprocessors. Proceedings of the 26th "
"IEEE Real-Time Systems Symposium, 2005."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:532
msgid "14 - J. Erickson, U. Devi and S. Baruah. Improved tardiness bounds for"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:533
msgid ""
"Global EDF. Proceedings of the 22nd Euromicro Conference on Real-Time "
"Systems, 2010."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:535
msgid "15 - G. Lipari, S. Baruah, Greedy reclamation of unused bandwidth in"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:536
msgid ""
"constant-bandwidth servers, 12th IEEE Euromicro Conference on Real-Time "
"Systems, 2000."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:538
msgid ""
"16 - L. Abeni, J. Lelli, C. Scordino, L. Palopoli, Greedy CPU reclaiming for"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:539
msgid ""
"SCHED DEADLINE. In Proceedings of the Real-Time Linux Workshop (RTLWS), "
"Dusseldorf, Germany, 2014."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:541
msgid ""
"17 - L. Abeni, G. Lipari, A. Parri, Y. Sun, Multicore CPU reclaiming: "
"parallel"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:542
msgid ""
"or sequential?. In Proceedings of the 31st Annual ACM Symposium on Applied "
"Computing, 2016."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:544
msgid ""
"18 - J. Lelli, C. Scordino, L. Abeni, D. Faggioli, Deadline scheduling in the"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:545
msgid ""
"Linux kernel, Software: Practice and Experience, 46(6): 821-839, June 2016."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:547
msgid ""
"19 - C. Scordino, L. Abeni, J. Lelli, Energy-Aware Real-Time Scheduling in"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:548
msgid ""
"the Linux Kernel, 33rd ACM/SIGAPP Symposium On Applied Computing (SAC 2018), "
"Pau, France, April 2018."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:553
msgid "4. Bandwidth management"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:555
msgid ""
"As previously mentioned, in order for -deadline scheduling to be effective "
"and useful (that is, to be able to provide \"runtime\" time units within "
"\"deadline\"), it is important to have some method to keep the allocation of "
"the available fractions of CPU time to the various tasks under control. This "
"is usually called \"admission control\" and if it is not performed, then no "
"guarantee can be given on the actual scheduling of the -deadline tasks."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:562
msgid ""
"As already stated in Section 3, a necessary condition to be respected to "
"correctly schedule a set of real-time tasks is that the total utilization is "
"smaller than M. When talking about -deadline tasks, this requires that the "
"sum of the ratio between runtime and period for all tasks is smaller than M. "
"Notice that the ratio runtime/period is equivalent to the utilization of a "
"\"traditional\" real-time task, and is also often referred to as "
"\"bandwidth\". The interface used to control the CPU bandwidth that can be "
"allocated to -deadline tasks is similar to the one already used for -rt "
"tasks with real-time group scheduling (a.k.a. RT-throttling - see "
"Documentation/scheduler/sched-rt-group.rst), and is based on readable/ "
"writable control files located in procfs (for system wide settings). Notice "
"that per-group settings (controlled through cgroupfs) are still not defined "
"for -deadline tasks, because more discussion is needed in order to figure "
"out how we want to manage SCHED_DEADLINE bandwidth at the task group level."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:579
msgid ""
"A main difference between deadline bandwidth management and RT-throttling is "
"that -deadline tasks have bandwidth on their own (while -rt ones don't!), "
"and thus we don't need a higher level throttling mechanism to enforce the "
"desired bandwidth. In other words, this means that interface parameters are "
"only used at admission control time (i.e., when the user calls "
"sched_setattr()). Scheduling is then performed considering actual tasks' "
"parameters, so that CPU bandwidth is allocated to SCHED_DEADLINE tasks "
"respecting their needs in terms of granularity. Therefore, using this simple "
"interface we can put a cap on total utilization of -deadline tasks (i.e., "
"\\Sum (runtime_i / period_i) < global_dl_utilization_cap)."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:591
msgid "4.1 System wide settings"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:593
msgid ""
"The system wide settings are configured under the /proc virtual file system."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:595
msgid ""
"For now the -rt knobs are used for -deadline admission control and with "
"CONFIG_RT_GROUP_SCHED the -deadline runtime is accounted against the (root) -"
"rt runtime. With !CONFIG_RT_GROUP_SCHED the knob only serves for the -dl "
"admission control. We realize that this isn't entirely desirable; however, "
"it is better to have a small interface for now, and be able to change it "
"easily later. The ideal situation (see 5.) is to run -rt tasks from a -"
"deadline server; in which case the -rt bandwidth is a direct subset of dl_bw."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:603
msgid ""
"This means that, for a root_domain comprising M CPUs, -deadline tasks can be "
"created while the sum of their bandwidths stays below:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:606
msgid "M * (sched_rt_runtime_us / sched_rt_period_us)"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:608
msgid ""
"It is also possible to disable this bandwidth management logic, and be thus "
"free of oversubscribing the system up to any arbitrary level. This is done "
"by writing -1 in /proc/sys/kernel/sched_rt_runtime_us."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:614
msgid "4.2 Task interface"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:616
msgid ""
"Specifying a periodic/sporadic task that executes for a given amount of "
"runtime at each instance, and that is scheduled according to the urgency of "
"its own timing constraints needs, in general, a way of declaring:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:620
msgid "a (maximum/typical) instance execution time,"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:621
msgid "a minimum interval between consecutive instances,"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:622
msgid "a time constraint by which each instance must be completed."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:624
msgid "Therefore:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:626
msgid ""
"a new struct sched_attr, containing all the necessary fields is provided;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:628
msgid ""
"the new scheduling related syscalls that manipulate it, i.e., "
"sched_setattr() and sched_getattr() are implemented."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:631
msgid ""
"For debugging purposes, the leftover runtime and absolute deadline of a "
"SCHED_DEADLINE task can be retrieved through /proc/<pid>/sched (entries dl."
"runtime and dl.deadline, both values in ns). A programmatic way to retrieve "
"these values from production code is under discussion."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:638
msgid "4.3 Default behavior"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:640
msgid ""
"The default value for SCHED_DEADLINE bandwidth is to have rt_runtime equal "
"to 950000. With rt_period equal to 1000000, by default, it means that -"
"deadline tasks can use at most 95%, multiplied by the number of CPUs that "
"compose the root_domain, for each root_domain. This means that non -deadline "
"tasks will receive at least 5% of the CPU time, and that -deadline tasks "
"will receive their runtime with a guaranteed worst-case delay respect to the "
"\"deadline\" parameter. If \"deadline\" = \"period\" and the cpuset "
"mechanism is used to implement partitioned scheduling (see Section 5), then "
"this simple setting of the bandwidth management is able to deterministically "
"guarantee that -deadline tasks will receive their runtime in a period."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:652
msgid ""
"Finally, notice that in order not to jeopardize the admission control a -"
"deadline task cannot fork."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:657
msgid "4.4 Behavior of sched_yield()"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:659
msgid ""
"When a SCHED_DEADLINE task calls sched_yield(), it gives up its remaining "
"runtime and is immediately throttled, until the next period, when its "
"runtime will be replenished (a special flag dl_yielded is set and used to "
"handle correctly throttling and runtime replenishment after a call to "
"sched_yield())."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:665
msgid ""
"This behavior of sched_yield() allows the task to wake-up exactly at the "
"beginning of the next period. Also, this may be useful in the future with "
"bandwidth reclaiming mechanisms, where sched_yield() will make the leftoever "
"runtime available for reclamation by other SCHED_DEADLINE tasks."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:673
msgid "5. Tasks CPU affinity"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:675
msgid ""
"Deadline tasks cannot have a cpu affinity mask smaller than the root domain "
"they are created on. So, using ``sched_setaffinity(2)`` won't work. Instead, "
"the the deadline task should be created in a restricted root domain. This "
"can be done using the cpuset controller of either cgroup v1 (deprecated) or "
"cgroup v2. See :ref:`Documentation/admin-guide/cgroup-v1/cpusets.rst "
"<cpusets>` and :ref:`Documentation/admin-guide/cgroup-v2.rst <cgroup-v2>` "
"for more information."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:683
msgid "5.1 Using cgroup v1 cpuset controller"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:685
msgid ""
"An example of a simple configuration (pin a -deadline task to CPU0) follows::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:701
msgid "5.2 Using cgroup v2 cpuset controller"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:703
msgid "Assuming the cgroup v2 root is mounted at ``/sys/fs/cgroup``."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:705
msgid ""
"cd /sys/fs/cgroup echo '+cpuset' > cgroup.subtree_control mkdir "
"deadline_group echo 0 > deadline_group/cpuset.cpus echo 'root' > "
"deadline_group/cpuset.cpus.partition echo $$ > deadline_group/cgroup.procs "
"chrt --sched-runtime 100000 --sched-period 200000 --deadline 0 yes > /dev/"
"null"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:714
msgid "6. Future plans"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:716
msgid "Still missing:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:718
msgid "programmatic way to retrieve current runtime and absolute deadline"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:719
msgid ""
"refinements to deadline inheritance, especially regarding the possibility of "
"retaining bandwidth isolation among non-interacting tasks. This is being "
"studied from both theoretical and practical points of view, and hopefully we "
"should be able to produce some demonstrative code soon;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:723
msgid "(c)group based bandwidth management, and maybe scheduling;"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:724
msgid ""
"access control for non-root users (and related security concerns to "
"address), which is the best way to allow unprivileged use of the mechanisms "
"and how to prevent non-root users \"cheat\" the system?"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:728
msgid ""
"As already discussed, we are planning also to merge this work with the EDF "
"throttling patches [https://lore.kernel.org/r/cover.1266931410.git."
"fabio@helm.retis] but we still are in the preliminary phases of the merge "
"and we really seek feedback that would help us decide on the direction it "
"should take."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:734
msgid "Appendix A. Test suite"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:736
msgid ""
"The SCHED_DEADLINE policy can be easily tested using two applications that "
"are part of a wider Linux Scheduler validation suite. The suite is available "
"as a GitHub repository: https://github.com/scheduler-tools."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:740
msgid ""
"The first testing application is called rt-app and can be used to start "
"multiple threads with specific parameters. rt-app supports SCHED_{OTHER,FIFO,"
"RR,DEADLINE} scheduling policies and their related parameters (e.g., "
"niceness, priority, runtime/deadline/period). rt-app is a valuable tool, as "
"it can be used to synthetically recreate certain workloads (maybe mimicking "
"real use-cases) and evaluate how the scheduler behaves under such workloads. "
"In this way, results are easily reproducible. rt-app is available at: "
"https://github.com/scheduler-tools/rt-app."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:749
msgid ""
"rt-app does not accept command line arguments, and instead reads from a JSON "
"configuration file. Here is an example ``config.json``:"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:775
msgid ""
"On running ``rt-app config.json``, it creates 2 threads. The first one, "
"scheduled by SCHED_DEADLINE, executes for 10ms every 100ms. The second one, "
"scheduled at SCHED_FIFO priority 10, executes for 20ms every 150ms. The test "
"will run for a total of 5 seconds."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:780
msgid ""
"Please refer to the rt-app documentation for the JSON schema and more "
"examples."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:782
msgid ""
"The second testing application is done using chrt which has support for "
"SCHED_DEADLINE."
msgstr ""

#: ../../../scheduler/sched-deadline.rst:785
msgid "The usage is straightforward::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:789
msgid ""
"With this, my_cpuhog_app is put to run inside a SCHED_DEADLINE reservation "
"of 10ms every 100ms (note that parameters are expressed in nanoseconds). You "
"can also use chrt to create a reservation for an already running "
"application, given that you know its pid::"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:797
msgid "Appendix B. Minimal main()"
msgstr ""

#: ../../../scheduler/sched-deadline.rst:799
msgid ""
"We provide in what follows a simple (ugly) self-contained code snippet "
"showing how SCHED_DEADLINE reservations can be created by a real-time "
"application developer::"
msgstr ""
