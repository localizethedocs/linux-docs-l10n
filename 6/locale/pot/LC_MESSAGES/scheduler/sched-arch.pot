# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scheduler/sched-arch.rst:3
msgid "CPU Scheduler implementation hints for architecture specific code"
msgstr ""

#: ../../../scheduler/sched-arch.rst:5
msgid "Nick Piggin, 2005"
msgstr ""

#: ../../../scheduler/sched-arch.rst:8
msgid "Context switch"
msgstr ""

#: ../../../scheduler/sched-arch.rst:9
msgid ""
"1. Runqueue locking By default, the switch_to arch function is called with "
"the runqueue locked. This is usually not a problem unless switch_to may need "
"to take the runqueue lock. This is usually due to a wake up operation in the "
"context switch."
msgstr ""

#: ../../../scheduler/sched-arch.rst:15
msgid ""
"To request the scheduler call switch_to with the runqueue unlocked, you must "
"`#define __ARCH_WANT_UNLOCKED_CTXSW` in a header file (typically the one "
"where switch_to is defined)."
msgstr ""

#: ../../../scheduler/sched-arch.rst:19
msgid ""
"Unlocked context switches introduce only a very minor performance penalty to "
"the core scheduler implementation in the CONFIG_SMP case."
msgstr ""

#: ../../../scheduler/sched-arch.rst:23
msgid "CPU idle"
msgstr ""

#: ../../../scheduler/sched-arch.rst:24
msgid "Your cpu_idle routines need to obey the following rules:"
msgstr ""

#: ../../../scheduler/sched-arch.rst:26
msgid ""
"Preempt should now disabled over idle routines. Should only be enabled to "
"call schedule() then disabled again."
msgstr ""

#: ../../../scheduler/sched-arch.rst:29
msgid ""
"need_resched/TIF_NEED_RESCHED is only ever set, and will never be cleared "
"until the running task has called schedule(). Idle threads need only ever "
"query need_resched, and may never set or clear it."
msgstr ""

#: ../../../scheduler/sched-arch.rst:34
msgid ""
"When cpu_idle finds (need_resched() == 'true'), it should call schedule(). "
"It should not call schedule() otherwise."
msgstr ""

#: ../../../scheduler/sched-arch.rst:37
msgid ""
"The only time interrupts need to be disabled when checking need_resched is "
"if we are about to sleep the processor until the next interrupt (this "
"doesn't provide any protection of need_resched, it prevents losing an "
"interrupt):"
msgstr ""

#: ../../../scheduler/sched-arch.rst:42
msgid "4a. Common problem with this type of sleep appears to be::"
msgstr ""

#: ../../../scheduler/sched-arch.rst:51
msgid ""
"TIF_POLLING_NRFLAG can be set by idle routines that do not need an interrupt "
"to wake them up when need_resched goes high. In other words, they must be "
"periodically polling need_resched, although it may be reasonable to do some "
"background work or enter a low CPU priority."
msgstr ""

#: ../../../scheduler/sched-arch.rst:57
msgid ""
"5a. If TIF_POLLING_NRFLAG is set, and we do decide to enter an interrupt "
"sleep, it needs to be cleared then a memory barrier issued (followed by a "
"test of need_resched with interrupts disabled, as explained in 3)."
msgstr ""

#: ../../../scheduler/sched-arch.rst:62
msgid ""
"arch/x86/kernel/process.c has examples of both polling and sleeping idle "
"functions."
msgstr ""

#: ../../../scheduler/sched-arch.rst:67
msgid "Possible arch/ problems"
msgstr ""

#: ../../../scheduler/sched-arch.rst:69
msgid "Possible arch problems I found (and either tried to fix or didn't):"
msgstr ""

#: ../../../scheduler/sched-arch.rst:71
msgid "sparc - IRQs on at this point(?), change local_irq_save to _disable."
msgstr ""

#: ../../../scheduler/sched-arch.rst:72
msgid "TODO: needs secondary CPUs to disable preempt (See #1)"
msgstr ""
