# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/files.rst:5
msgid "File management in the Linux kernel"
msgstr ""

#: ../../../filesystems/files.rst:7
msgid ""
"This document describes how locking for files (struct file) and file "
"descriptor table (struct files) works."
msgstr ""

#: ../../../filesystems/files.rst:10
msgid ""
"Up until 2.6.12, the file descriptor table has been protected with a lock "
"(files->file_lock) and reference count (files->count). ->file_lock protected "
"accesses to all the file related fields of the table. ->count was used for "
"sharing the file descriptor table between tasks cloned with CLONE_FILES "
"flag. Typically this would be the case for posix threads. As with the common "
"refcounting model in the kernel, the last task doing a put_files_struct() "
"frees the file descriptor (fd) table. The files (struct file) themselves are "
"protected using reference count (->f_count)."
msgstr ""

#: ../../../filesystems/files.rst:21
msgid ""
"In the new lock-free model of file descriptor management, the reference "
"counting is similar, but the locking is based on RCU. The file descriptor "
"table contains multiple elements - the fd sets (open_fds and close_on_exec, "
"the array of file pointers, the sizes of the sets and the array etc.). In "
"order for the updates to appear atomic to a lock-free reader, all the "
"elements of the file descriptor table are in a separate structure - struct "
"fdtable. files_struct contains a pointer to struct fdtable through which the "
"actual fd table is accessed. Initially the fdtable is embedded in "
"files_struct itself. On a subsequent expansion of fdtable, a new fdtable "
"structure is allocated and files->fdtab points to the new structure. The "
"fdtable structure is freed with RCU and lock-free readers either see the old "
"fdtable or the new fdtable making the update appear atomic. Here are the "
"locking rules for the fdtable structure -"
msgstr ""

#: ../../../filesystems/files.rst:39
msgid ""
"All references to the fdtable must be done through the files_fdtable() "
"macro::"
msgstr ""

#: ../../../filesystems/files.rst:53
msgid ""
"files_fdtable() uses rcu_dereference() macro which takes care of the memory "
"barrier requirements for lock-free dereference. The fdtable pointer must be "
"read within the read-side critical section."
msgstr ""

#: ../../../filesystems/files.rst:58
msgid ""
"Reading of the fdtable as described above must be protected by "
"rcu_read_lock()/rcu_read_unlock()."
msgstr ""

#: ../../../filesystems/files.rst:61
msgid "For any update to the fd table, files->file_lock must be held."
msgstr ""

#: ../../../filesystems/files.rst:64
msgid ""
"To look up the file structure given an fd, a reader must use either "
"lookup_fdget_rcu() or files_lookup_fdget_rcu() APIs. These take care of "
"barrier requirements due to lock-free lookup."
msgstr ""

#: ../../../filesystems/files.rst:68
msgid "An example::"
msgstr ""

#: ../../../filesystems/files.rst:81
msgid ""
"Since both fdtable and file structures can be looked up lock-free, they must "
"be installed using rcu_assign_pointer() API. If they are looked up lock-"
"free, rcu_dereference() must be used. However it is advisable to use "
"files_fdtable() and lookup_fdget_rcu()/files_lookup_fdget_rcu() which take "
"care of these issues."
msgstr ""

#: ../../../filesystems/files.rst:88
msgid ""
"While updating, the fdtable pointer must be looked up while holding files-"
">file_lock. If ->file_lock is dropped, then another thread expand the files "
"thereby creating a new fdtable and making the earlier fdtable pointer stale."
msgstr ""

#: ../../../filesystems/files.rst:93
msgid "For example::"
msgstr ""

#: ../../../filesystems/files.rst:105
msgid ""
"Since locate_fd() can drop ->file_lock (and reacquire ->file_lock), the "
"fdtable pointer (fdt) must be loaded after locate_fd()."
msgstr ""

#: ../../../filesystems/files.rst:108
msgid ""
"On newer kernels rcu based file lookup has been switched to rely on "
"SLAB_TYPESAFE_BY_RCU instead of call_rcu(). It isn't sufficient anymore to "
"just acquire a reference to the file in question under rcu using "
"atomic_long_inc_not_zero() since the file might have already been recycled "
"and someone else might have bumped the reference. In other words, callers "
"might see reference count bumps from newer users. For this is reason it is "
"necessary to verify that the pointer is the same before and after the "
"reference count increment. This pattern can be seen in get_file_rcu() and "
"__files_get_rcu()."
msgstr ""

#: ../../../filesystems/files.rst:118
msgid ""
"In addition, it isn't possible to access or check fields in struct file "
"without first acquiring a reference on it under rcu lookup. Not doing that "
"was always very dodgy and it was only usable for non-pointer data in struct "
"file. With SLAB_TYPESAFE_BY_RCU it is necessary that callers either first "
"acquire a reference or they must hold the files_lock of the fdtable."
msgstr ""
