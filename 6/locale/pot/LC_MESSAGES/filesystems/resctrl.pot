# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/resctrl.rst:6
msgid "User Interface for Resource Control feature (resctrl)"
msgstr ""

#: ../../../filesystems/resctrl.rst:0
msgid "Copyright"
msgstr ""

#: ../../../filesystems/resctrl.rst:8
msgid "|copy| 2016 Intel Corporation"
msgstr ""

#: ../../../filesystems/resctrl.rst:0
msgid "Authors"
msgstr ""

#: ../../../filesystems/resctrl.rst:9
msgid "Fenghua Yu <fenghua.yu@intel.com>"
msgstr ""

#: ../../../filesystems/resctrl.rst:10
msgid "Tony Luck <tony.luck@intel.com>"
msgstr ""

#: ../../../filesystems/resctrl.rst:11
msgid "Vikas Shivappa <vikas.shivappa@intel.com>"
msgstr ""

#: ../../../filesystems/resctrl.rst:14
msgid ""
"Intel refers to this feature as Intel Resource Director Technology(Intel(R) "
"RDT). AMD refers to this feature as AMD Platform Quality of Service(AMD QoS)."
msgstr ""

#: ../../../filesystems/resctrl.rst:17
msgid ""
"This feature is enabled by the CONFIG_X86_CPU_RESCTRL and the x86 /proc/"
"cpuinfo flag bits:"
msgstr ""

#: ../../../filesystems/resctrl.rst:21
msgid "RDT (Resource Director Technology) Allocation"
msgstr ""

#: ../../../filesystems/resctrl.rst:21
msgid "\"rdt_a\""
msgstr ""

#: ../../../filesystems/resctrl.rst:22
msgid "CAT (Cache Allocation Technology)"
msgstr ""

#: ../../../filesystems/resctrl.rst:22
msgid "\"cat_l3\", \"cat_l2\""
msgstr ""

#: ../../../filesystems/resctrl.rst:23
msgid "CDP (Code and Data Prioritization)"
msgstr ""

#: ../../../filesystems/resctrl.rst:23
msgid "\"cdp_l3\", \"cdp_l2\""
msgstr ""

#: ../../../filesystems/resctrl.rst:24
msgid "CQM (Cache QoS Monitoring)"
msgstr ""

#: ../../../filesystems/resctrl.rst:24
msgid "\"cqm_llc\", \"cqm_occup_llc\""
msgstr ""

#: ../../../filesystems/resctrl.rst:25
msgid "MBM (Memory Bandwidth Monitoring)"
msgstr ""

#: ../../../filesystems/resctrl.rst:25
msgid "\"cqm_mbm_total\", \"cqm_mbm_local\""
msgstr ""

#: ../../../filesystems/resctrl.rst:26
msgid "MBA (Memory Bandwidth Allocation)"
msgstr ""

#: ../../../filesystems/resctrl.rst:26
msgid "\"mba\""
msgstr ""

#: ../../../filesystems/resctrl.rst:27
msgid "SMBA (Slow Memory Bandwidth Allocation)"
msgstr ""

#: ../../../filesystems/resctrl.rst:27 ../../../filesystems/resctrl.rst:28
#: ../../../filesystems/resctrl.rst:29
msgid "\"\""
msgstr ""

#: ../../../filesystems/resctrl.rst:28
msgid "BMEC (Bandwidth Monitoring Event Configuration)"
msgstr ""

#: ../../../filesystems/resctrl.rst:29
msgid "ABMC (Assignable Bandwidth Monitoring Counters)"
msgstr ""

#: ../../../filesystems/resctrl.rst:32
msgid ""
"Historically, new features were made visible by default in /proc/cpuinfo. "
"This resulted in the feature flags becoming hard to parse by humans. Adding "
"a new flag to /proc/cpuinfo should be avoided if user space can obtain "
"information about the feature from resctrl's info directory."
msgstr ""

#: ../../../filesystems/resctrl.rst:37
msgid "To use the feature mount the file system::"
msgstr ""

#: ../../../filesystems/resctrl.rst:41
msgid "mount options are:"
msgstr ""

#: ../../../filesystems/resctrl.rst:43
msgid "\"cdp\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:44
msgid "Enable code/data prioritization in L3 cache allocations."
msgstr ""

#: ../../../filesystems/resctrl.rst:45
msgid "\"cdpl2\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:46
msgid "Enable code/data prioritization in L2 cache allocations."
msgstr ""

#: ../../../filesystems/resctrl.rst:47
msgid "\"mba_MBps\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:48
msgid ""
"Enable the MBA Software Controller(mba_sc) to specify MBA bandwidth in MiBps"
msgstr ""

#: ../../../filesystems/resctrl.rst:50
msgid "\"debug\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:51
msgid ""
"Make debug files accessible. Available debug files are annotated with "
"\"Available only with debug option\"."
msgstr ""

#: ../../../filesystems/resctrl.rst:54
msgid "L2 and L3 CDP are controlled separately."
msgstr ""

#: ../../../filesystems/resctrl.rst:56
msgid ""
"RDT features are orthogonal. A particular system may support only "
"monitoring, only control, or both monitoring and control.  Cache pseudo-"
"locking is a unique way of using cache control to \"pin\" or \"lock\" data "
"in the cache. Details can be found in \"Cache Pseudo-Locking\"."
msgstr ""

#: ../../../filesystems/resctrl.rst:63
msgid ""
"The mount succeeds if either of allocation or monitoring is present, but "
"only those files and directories supported by the system will be created. "
"For more details on the behavior of the interface during monitoring and "
"allocation, see the \"Resource alloc and monitor groups\" section."
msgstr ""

#: ../../../filesystems/resctrl.rst:69
msgid "Info directory"
msgstr ""

#: ../../../filesystems/resctrl.rst:71
msgid ""
"The 'info' directory contains information about the enabled resources. Each "
"resource has its own subdirectory. The subdirectory names reflect the "
"resource names."
msgstr ""

#: ../../../filesystems/resctrl.rst:75
msgid ""
"Each subdirectory contains the following files with respect to allocation:"
msgstr ""

#: ../../../filesystems/resctrl.rst:78
msgid ""
"Cache resource(L3/L2)  subdirectory contains the following files related to "
"allocation:"
msgstr ""

#: ../../../filesystems/resctrl.rst:81
msgid "\"num_closids\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:82
msgid ""
"The number of CLOSIDs which are valid for this resource. The kernel uses the "
"smallest number of CLOSIDs of all enabled resources as limit."
msgstr ""

#: ../../../filesystems/resctrl.rst:85
msgid "\"cbm_mask\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:86
msgid ""
"The bitmask which is valid for this resource. This mask is equivalent to "
"100%."
msgstr ""

#: ../../../filesystems/resctrl.rst:88
msgid "\"min_cbm_bits\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:89
msgid ""
"The minimum number of consecutive bits which must be set when writing a mask."
msgstr ""

#: ../../../filesystems/resctrl.rst:92
msgid "\"shareable_bits\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:93
msgid ""
"Bitmask of shareable resource with other executing entities (e.g. I/O). User "
"can use this when setting up exclusive cache partitions. Note that some "
"platforms support devices that have their own settings for cache use which "
"can over-ride these bits."
msgstr ""

#: ../../../filesystems/resctrl.rst:99
msgid "\"bit_usage\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:100
msgid ""
"Annotated capacity bitmasks showing how all instances of the resource are "
"used. The legend is:"
msgstr ""

#: ../../../filesystems/resctrl.rst:103 ../../../filesystems/resctrl.rst:134
#: ../../../filesystems/resctrl.rst:387
msgid "\"0\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:104
msgid ""
"Corresponding region is unused. When the system's resources have been "
"allocated and a \"0\" is found in \"bit_usage\" it is a sign that resources "
"are wasted."
msgstr ""

#: ../../../filesystems/resctrl.rst:109
msgid "\"H\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:110
msgid ""
"Corresponding region is used by hardware only but available for software "
"use. If a resource has bits set in \"shareable_bits\" but not all of these "
"bits appear in the resource groups' schematas then the bits appearing in "
"\"shareable_bits\" but no resource group will be marked as \"H\"."
msgstr ""

#: ../../../filesystems/resctrl.rst:117
msgid "\"X\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:118
msgid ""
"Corresponding region is available for sharing and used by hardware and "
"software. These are the bits that appear in \"shareable_bits\" as well as a "
"resource group's allocation."
msgstr ""

#: ../../../filesystems/resctrl.rst:122
msgid "\"S\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:123
msgid "Corresponding region is used by software and available for sharing."
msgstr ""

#: ../../../filesystems/resctrl.rst:125
msgid "\"E\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:126
msgid ""
"Corresponding region is used exclusively by one resource group. No sharing "
"allowed."
msgstr ""

#: ../../../filesystems/resctrl.rst:128
msgid "\"P\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:129
msgid "Corresponding region is pseudo-locked. No sharing allowed."
msgstr ""

#: ../../../filesystems/resctrl.rst:131
msgid "\"sparse_masks\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:132
msgid "Indicates if non-contiguous 1s value in CBM is supported."
msgstr ""

#: ../../../filesystems/resctrl.rst:135
msgid "Only contiguous 1s value in CBM is supported."
msgstr ""

#: ../../../filesystems/resctrl.rst:136 ../../../filesystems/resctrl.rst:389
msgid "\"1\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:137
msgid "Non-contiguous 1s value in CBM is supported."
msgstr ""

#: ../../../filesystems/resctrl.rst:139
msgid ""
"Memory bandwidth(MB) subdirectory contains the following files with respect "
"to allocation:"
msgstr ""

#: ../../../filesystems/resctrl.rst:142
msgid "\"min_bandwidth\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:143
msgid "The minimum memory bandwidth percentage which user can request."
msgstr ""

#: ../../../filesystems/resctrl.rst:146
msgid "\"bandwidth_gran\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:147
msgid ""
"The granularity in which the memory bandwidth percentage is allocated. The "
"allocated b/w percentage is rounded off to the next control step available "
"on the hardware. The available bandwidth control steps are: min_bandwidth + "
"N * bandwidth_gran."
msgstr ""

#: ../../../filesystems/resctrl.rst:154
msgid "\"delay_linear\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:155
msgid ""
"Indicates if the delay scale is linear or non-linear. This field is purely "
"informational only."
msgstr ""

#: ../../../filesystems/resctrl.rst:159
msgid "\"thread_throttle_mode\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:160
msgid ""
"Indicator on Intel systems of how tasks running on threads of a physical "
"core are throttled in cases where they request different memory bandwidth "
"percentages:"
msgstr ""

#: ../../../filesystems/resctrl.rst:164
msgid "\"max\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:165
msgid "the smallest percentage is applied to all threads"
msgstr ""

#: ../../../filesystems/resctrl.rst:167
msgid "\"per-thread\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:168
msgid ""
"bandwidth percentages are directly applied to the threads running on the core"
msgstr ""

#: ../../../filesystems/resctrl.rst:171
msgid ""
"If RDT monitoring is available there will be an \"L3_MON\" directory with "
"the following files:"
msgstr ""

#: ../../../filesystems/resctrl.rst:174
msgid "\"num_rmids\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:175
msgid ""
"The number of RMIDs available. This is the upper bound for how many "
"\"CTRL_MON\" + \"MON\" groups can be created."
msgstr ""

#: ../../../filesystems/resctrl.rst:179
msgid "\"mon_features\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:180
msgid ""
"Lists the monitoring events if monitoring is enabled for the resource. "
"Example::"
msgstr ""

#: ../../../filesystems/resctrl.rst:189
msgid ""
"If the system supports Bandwidth Monitoring Event Configuration (BMEC), then "
"the bandwidth events will be configurable. The output will be::"
msgstr ""

#: ../../../filesystems/resctrl.rst:200
msgid "\"mbm_total_bytes_config\", \"mbm_local_bytes_config\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:201
msgid ""
"Read/write files containing the configuration for the mbm_total_bytes and "
"mbm_local_bytes events, respectively, when the Bandwidth Monitoring Event "
"Configuration (BMEC) feature is supported. The event configuration settings "
"are domain specific and affect all the CPUs in the domain. When either event "
"configuration is changed, the bandwidth counters for all RMIDs of both "
"events (mbm_total_bytes as well as mbm_local_bytes) are cleared for that "
"domain. The next read for every RMID will report \"Unavailable\" and "
"subsequent reads will report the valid value."
msgstr ""

#: ../../../filesystems/resctrl.rst:211
msgid "Following are the types of events supported:"
msgstr ""

#: ../../../filesystems/resctrl.rst:214
msgid "Bits"
msgstr ""

#: ../../../filesystems/resctrl.rst:214 ../../../filesystems/resctrl.rst:346
msgid "Description"
msgstr ""

#: ../../../filesystems/resctrl.rst:216 ../../../filesystems/resctrl.rst:1787
msgid "6"
msgstr ""

#: ../../../filesystems/resctrl.rst:216 ../../../filesystems/resctrl.rst:348
msgid "Dirty Victims from the QOS domain to all types of memory"
msgstr ""

#: ../../../filesystems/resctrl.rst:217
msgid "5"
msgstr ""

#: ../../../filesystems/resctrl.rst:217 ../../../filesystems/resctrl.rst:349
msgid "Reads to slow memory in the non-local NUMA domain"
msgstr ""

#: ../../../filesystems/resctrl.rst:218 ../../../filesystems/resctrl.rst:1785
msgid "4"
msgstr ""

#: ../../../filesystems/resctrl.rst:218 ../../../filesystems/resctrl.rst:350
msgid "Reads to slow memory in the local NUMA domain"
msgstr ""

#: ../../../filesystems/resctrl.rst:219 ../../../filesystems/resctrl.rst:1783
msgid "3"
msgstr ""

#: ../../../filesystems/resctrl.rst:219 ../../../filesystems/resctrl.rst:351
msgid "Non-temporal writes to non-local NUMA domain"
msgstr ""

#: ../../../filesystems/resctrl.rst:220 ../../../filesystems/resctrl.rst:1781
msgid "2"
msgstr ""

#: ../../../filesystems/resctrl.rst:220 ../../../filesystems/resctrl.rst:352
msgid "Non-temporal writes to local NUMA domain"
msgstr ""

#: ../../../filesystems/resctrl.rst:221 ../../../filesystems/resctrl.rst:1779
msgid "1"
msgstr ""

#: ../../../filesystems/resctrl.rst:221 ../../../filesystems/resctrl.rst:353
msgid "Reads to memory in the non-local NUMA domain"
msgstr ""

#: ../../../filesystems/resctrl.rst:222 ../../../filesystems/resctrl.rst:1779
#: ../../../filesystems/resctrl.rst:1781 ../../../filesystems/resctrl.rst:1785
#: ../../../filesystems/resctrl.rst:1791 ../../../filesystems/resctrl.rst:1799
#: ../../../filesystems/resctrl.rst:1807 ../../../filesystems/resctrl.rst:1813
#: ../../../filesystems/resctrl.rst:1817 ../../../filesystems/resctrl.rst:1821
#: ../../../filesystems/resctrl.rst:1829
msgid "0"
msgstr ""

#: ../../../filesystems/resctrl.rst:222 ../../../filesystems/resctrl.rst:354
msgid "Reads to memory in the local NUMA domain"
msgstr ""

#: ../../../filesystems/resctrl.rst:225
msgid ""
"By default, the mbm_total_bytes configuration is set to 0x7f to count all "
"the event types and the mbm_local_bytes configuration is set to 0x15 to "
"count all the local memory events."
msgstr ""

#: ../../../filesystems/resctrl.rst:229 ../../../filesystems/resctrl.rst:566
msgid "Examples:"
msgstr ""

#: ../../../filesystems/resctrl.rst:231
msgid "To view the current configuration:: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:240
msgid ""
"To change the mbm_total_bytes to count only reads on domain 0, the bits 0, "
"1, 4 and 5 needs to be set, which is 110011b in binary (in hexadecimal "
"0x33): ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:250
msgid ""
"To change the mbm_local_bytes to count all the slow memory reads on domain 0 "
"and 1, the bits 4 and 5 needs to be set, which is 110000b in binary (in "
"hexadecimal 0x30): ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:260
msgid "\"mbm_assign_mode\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:261
msgid ""
"The supported counter assignment modes. The enclosed brackets indicate which "
"mode is enabled. The MBM events associated with counters may reset when "
"\"mbm_assign_mode\" is changed. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:270
msgid "\"mbm_event\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:272
msgid ""
"mbm_event mode allows users to assign a hardware counter to an RMID, event "
"pair and monitor the bandwidth usage as long as it is assigned. The hardware "
"continues to track the assigned counter until it is explicitly unassigned by "
"the user. Each event within a resctrl group can be assigned independently."
msgstr ""

#: ../../../filesystems/resctrl.rst:277
msgid ""
"In this mode, a monitoring event can only accumulate data while it is backed "
"by a hardware counter. Use \"mbm_L3_assignments\" found in each CTRL_MON and "
"MON group to specify which of the events should have a counter assigned. The "
"number of counters available is described in the \"num_mbm_cntrs\" file. "
"Changing the mode may cause all counters on the resource to reset."
msgstr ""

#: ../../../filesystems/resctrl.rst:283
msgid ""
"Moving to mbm_event counter assignment mode requires users to assign the "
"counters to the events. Otherwise, the MBM event counters will return "
"'Unassigned' when read."
msgstr ""

#: ../../../filesystems/resctrl.rst:286
msgid ""
"The mode is beneficial for AMD platforms that support more CTRL_MON and MON "
"groups than available hardware counters. By default, this feature is enabled "
"on AMD platforms with the ABMC (Assignable Bandwidth Monitoring Counters) "
"capability, ensuring counters remain assigned even when the corresponding "
"RMID is not actively used by any processor."
msgstr ""

#: ../../../filesystems/resctrl.rst:292
msgid "\"default\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:294
msgid ""
"In default mode, resctrl assumes there is a hardware counter for each event "
"within every CTRL_MON and MON group. On AMD platforms, it is recommended to "
"use the mbm_event mode, if supported, to prevent reset of MBM events between "
"reads resulting from hardware re-allocating counters. This can result in "
"misleading values or display \"Unavailable\" if no counter is assigned to "
"the event."
msgstr ""

#: ../../../filesystems/resctrl.rst:301
msgid "To enable \"mbm_event\" counter assignment mode: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:306
msgid "To enable \"default\" monitoring mode: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:311
msgid "\"num_mbm_cntrs\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:312
msgid ""
"The maximum number of counters (total of available and assigned counters) in "
"each domain when the system supports mbm_event mode."
msgstr ""

#: ../../../filesystems/resctrl.rst:315
msgid ""
"For example, on a system with maximum of 32 memory bandwidth monitoring "
"counters in each of its L3 domains: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:322
msgid "\"available_mbm_cntrs\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:323
msgid ""
"The number of counters available for assignment in each domain when "
"mbm_event mode is enabled on the system."
msgstr ""

#: ../../../filesystems/resctrl.rst:326
msgid ""
"For example, on a system with 30 available [hardware] assignable counters in "
"each of its L3 domains: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:333
msgid "\"event_configs\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:334
msgid ""
"Directory that exists when \"mbm_event\" counter assignment mode is "
"supported. Contains a sub-directory for each MBM event that can be assigned "
"to a counter."
msgstr ""

#: ../../../filesystems/resctrl.rst:337
msgid ""
"Two MBM events are supported by default: mbm_local_bytes and "
"mbm_total_bytes. Each MBM event's sub-directory contains a file named "
"\"event_filter\" that is used to view and modify which memory transactions "
"the MBM event is configured with. The file is accessible only when "
"\"mbm_event\" counter assignment mode is enabled."
msgstr ""

#: ../../../filesystems/resctrl.rst:343
msgid "List of memory transaction types supported:"
msgstr ""

#: ../../../filesystems/resctrl.rst:346
msgid "Name"
msgstr ""

#: ../../../filesystems/resctrl.rst:348
msgid "dirty_victim_writes_all"
msgstr ""

#: ../../../filesystems/resctrl.rst:349
msgid "remote_reads_slow_memory"
msgstr ""

#: ../../../filesystems/resctrl.rst:350
msgid "local_reads_slow_memory"
msgstr ""

#: ../../../filesystems/resctrl.rst:351
msgid "remote_non_temporal_writes"
msgstr ""

#: ../../../filesystems/resctrl.rst:352
msgid "local_non_temporal_writes"
msgstr ""

#: ../../../filesystems/resctrl.rst:353
msgid "remote_reads"
msgstr ""

#: ../../../filesystems/resctrl.rst:354
msgid "local_reads"
msgstr ""

#: ../../../filesystems/resctrl.rst:357 ../../../filesystems/resctrl.rst:370
msgid "For example::"
msgstr ""

#: ../../../filesystems/resctrl.rst:366
msgid ""
"Modify the event configuration by writing to the \"event_filter\" file "
"within the \"event_configs\" directory. The read/write \"event_filter\" file "
"contains the configuration of the event that reflects which memory "
"transactions are counted by it."
msgstr ""

#: ../../../filesystems/resctrl.rst:378
msgid "\"mbm_assign_on_mkdir\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:379
msgid ""
"Exists when \"mbm_event\" counter assignment mode is supported. Accessible "
"only when \"mbm_event\" counter assignment mode is enabled."
msgstr ""

#: ../../../filesystems/resctrl.rst:382
msgid ""
"Determines if a counter will automatically be assigned to an RMID, MBM event "
"pair when its associated monitor group is created via mkdir. Enabled by "
"default on boot, also when switched from \"default\" mode to \"mbm_event\" "
"counter assignment mode. Users can disable this capability by writing to the "
"interface."
msgstr ""

#: ../../../filesystems/resctrl.rst:388
msgid "Auto assignment is disabled."
msgstr ""

#: ../../../filesystems/resctrl.rst:390
msgid "Auto assignment is enabled."
msgstr ""

#: ../../../filesystems/resctrl.rst:392
msgid "Example::"
msgstr ""

#: ../../../filesystems/resctrl.rst:398
msgid "\"max_threshold_occupancy\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:399
msgid ""
"Read/write file provides the largest value (in bytes) at which a previously "
"used LLC_occupancy counter can be considered for re-use."
msgstr ""

#: ../../../filesystems/resctrl.rst:403
msgid ""
"Finally, in the top level of the \"info\" directory there is a file named "
"\"last_cmd_status\". This is reset with every \"command\" issued via the "
"file system (making new directories or writing to any of the control files). "
"If the command was successful, it will read as \"ok\". If the command "
"failed, it will provide more information that can be conveyed in the error "
"returns from file operations. E.g. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:417
msgid "Resource alloc and monitor groups"
msgstr ""

#: ../../../filesystems/resctrl.rst:419
msgid ""
"Resource groups are represented as directories in the resctrl file system.  "
"The default group is the root directory which, immediately after mounting, "
"owns all the tasks and cpus in the system and can make full use of all "
"resources."
msgstr ""

#: ../../../filesystems/resctrl.rst:424
msgid ""
"On a system with RDT control features additional directories can be created "
"in the root directory that specify different amounts of each resource (see "
"\"schemata\" below). The root and these additional top level directories are "
"referred to as \"CTRL_MON\" groups below."
msgstr ""

#: ../../../filesystems/resctrl.rst:429
msgid ""
"On a system with RDT monitoring the root directory and other top level "
"directories contain a directory named \"mon_groups\" in which additional "
"directories can be created to monitor subsets of tasks in the CTRL_MON group "
"that is their ancestor. These are called \"MON\" groups in the rest of this "
"document."
msgstr ""

#: ../../../filesystems/resctrl.rst:435
msgid ""
"Removing a directory will move all tasks and cpus owned by the group it "
"represents to the parent. Removing one of the created CTRL_MON groups will "
"automatically remove all MON groups below it."
msgstr ""

#: ../../../filesystems/resctrl.rst:439
msgid ""
"Moving MON group directories to a new parent CTRL_MON group is supported for "
"the purpose of changing the resource allocations of a MON group without "
"impacting its monitoring data or assigned tasks. This operation is not "
"allowed for MON groups which monitor CPUs. No other move operation is "
"currently allowed other than simply renaming a CTRL_MON or MON group."
msgstr ""

#: ../../../filesystems/resctrl.rst:446
msgid "All groups contain the following files:"
msgstr ""

#: ../../../filesystems/resctrl.rst:448
msgid "\"tasks\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:449
msgid ""
"Reading this file shows the list of all tasks that belong to this group. "
"Writing a task id to the file will add a task to the group. Multiple tasks "
"can be added by separating the task ids with commas. Tasks will be assigned "
"sequentially. Multiple failures are not supported. A single failure "
"encountered while attempting to assign a task will cause the operation to "
"abort and already added tasks before the failure will remain in the group. "
"Failures will be logged to /sys/fs/resctrl/info/last_cmd_status."
msgstr ""

#: ../../../filesystems/resctrl.rst:458
msgid ""
"If the group is a CTRL_MON group the task is removed from whichever previous "
"CTRL_MON group owned the task and also from any MON group that owned the "
"task. If the group is a MON group, then the task must already belong to the "
"CTRL_MON parent of this group. The task is removed from any previous MON "
"group."
msgstr ""

#: ../../../filesystems/resctrl.rst:465
msgid "\"cpus\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:466
msgid ""
"Reading this file shows a bitmask of the logical CPUs owned by this group. "
"Writing a mask to this file will add and remove CPUs to/from this group. As "
"with the tasks file a hierarchy is maintained where MON groups may only "
"include CPUs owned by the parent CTRL_MON group. When the resource group is "
"in pseudo-locked mode this file will only be readable, reflecting the CPUs "
"associated with the pseudo-locked region."
msgstr ""

#: ../../../filesystems/resctrl.rst:476
msgid "\"cpus_list\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:477
msgid "Just like \"cpus\", only using ranges of CPUs instead of bitmasks."
msgstr ""

#: ../../../filesystems/resctrl.rst:480
msgid "When control is enabled all CTRL_MON groups will also contain:"
msgstr ""

#: ../../../filesystems/resctrl.rst:482
msgid "\"schemata\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:483
msgid ""
"A list of all the resources available to this group. Each resource has its "
"own line and format - see below for details."
msgstr ""

#: ../../../filesystems/resctrl.rst:486
msgid "\"size\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:487
msgid ""
"Mirrors the display of the \"schemata\" file to display the size in bytes of "
"each allocation instead of the bits representing the allocation."
msgstr ""

#: ../../../filesystems/resctrl.rst:491
msgid "\"mode\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:492
msgid ""
"The \"mode\" of the resource group dictates the sharing of its allocations. "
"A \"shareable\" resource group allows sharing of its allocations while an "
"\"exclusive\" resource group does not. A cache pseudo-locked region is "
"created by first writing \"pseudo-locksetup\" to the \"mode\" file before "
"writing the cache pseudo-locked region's schemata to the resource group's "
"\"schemata\" file. On successful pseudo-locked region creation the mode will "
"automatically change to \"pseudo-locked\"."
msgstr ""

#: ../../../filesystems/resctrl.rst:501
msgid "\"ctrl_hw_id\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:502
msgid ""
"Available only with debug option. The identifier used by hardware for the "
"control group. On x86 this is the CLOSID."
msgstr ""

#: ../../../filesystems/resctrl.rst:505
msgid "When monitoring is enabled all MON groups will also contain:"
msgstr ""

#: ../../../filesystems/resctrl.rst:507
msgid "\"mon_data\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:508
msgid ""
"This contains a set of files organized by L3 domain and by RDT event. E.g. "
"on a system with two L3 domains there will be subdirectories \"mon_L3_00\" "
"and \"mon_L3_01\".  Each of these directories have one file per event (e.g. "
"\"llc_occupancy\", \"mbm_total_bytes\", and \"mbm_local_bytes\"). In a MON "
"group these files provide a read out of the current value of the event for "
"all tasks in the group. In CTRL_MON groups these files provide the sum for "
"all tasks in the CTRL_MON group and all tasks in MON groups. Please see "
"example section for more details on usage. On systems with Sub-NUMA Cluster "
"(SNC) enabled there are extra directories for each node (located within the "
"\"mon_L3_XX\" directory for the L3 cache they occupy). These are named "
"\"mon_sub_L3_YY\" where \"YY\" is the node number."
msgstr ""

#: ../../../filesystems/resctrl.rst:522
msgid ""
"When the 'mbm_event' counter assignment mode is enabled, reading an MBM "
"event of a MON group returns 'Unassigned' if no hardware counter is assigned "
"to it. For CTRL_MON groups, 'Unassigned' is returned if the MBM event does "
"not have an assigned counter in the CTRL_MON group nor in any of its "
"associated MON groups."
msgstr ""

#: ../../../filesystems/resctrl.rst:528
msgid "\"mon_hw_id\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:529
msgid ""
"Available only with debug option. The identifier used by hardware for the "
"monitor group. On x86 this is the RMID."
msgstr ""

#: ../../../filesystems/resctrl.rst:532
msgid "When monitoring is enabled all MON groups may also contain:"
msgstr ""

#: ../../../filesystems/resctrl.rst:534
msgid "\"mbm_L3_assignments\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:535
msgid ""
"Exists when \"mbm_event\" counter assignment mode is supported and lists the "
"counter assignment states of the group."
msgstr ""

#: ../../../filesystems/resctrl.rst:538
msgid "The assignment list is displayed in the following format:"
msgstr ""

#: ../../../filesystems/resctrl.rst:540
msgid "<Event>:<Domain ID>=<Assignment state>;<Domain ID>=<Assignment state>"
msgstr ""

#: ../../../filesystems/resctrl.rst:542
msgid "Event: A valid MBM event in the"
msgstr ""

#: ../../../filesystems/resctrl.rst:543
msgid "/sys/fs/resctrl/info/L3_MON/event_configs directory."
msgstr ""

#: ../../../filesystems/resctrl.rst:545
msgid "Domain ID: A valid domain ID. When writing, '*' applies the changes"
msgstr ""

#: ../../../filesystems/resctrl.rst:546
msgid "to all the domains."
msgstr ""

#: ../../../filesystems/resctrl.rst:548
msgid "Assignment states:"
msgstr ""

#: ../../../filesystems/resctrl.rst:550
msgid "_ : No counter assigned."
msgstr ""

#: ../../../filesystems/resctrl.rst:552
msgid "e : Counter assigned exclusively."
msgstr ""

#: ../../../filesystems/resctrl.rst:554
msgid "Example:"
msgstr ""

#: ../../../filesystems/resctrl.rst:556
msgid "To display the counter assignment states for the default group. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:564
msgid "Assignments can be modified by writing to the interface."
msgstr ""

#: ../../../filesystems/resctrl.rst:568
msgid ""
"To unassign the counter associated with the mbm_total_bytes event on domain "
"0: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:576
msgid ""
"To unassign the counter associated with the mbm_total_bytes event on all the "
"domains: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:584
msgid ""
"To assign a counter associated with the mbm_total_bytes event on all domains "
"in exclusive mode: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:593
msgid ""
"When the \"mba_MBps\" mount option is used all CTRL_MON groups will also "
"contain:"
msgstr ""

#: ../../../filesystems/resctrl.rst:595
msgid "\"mba_MBps_event\":"
msgstr ""

#: ../../../filesystems/resctrl.rst:596
msgid ""
"Reading this file shows which memory bandwidth event is used as input to the "
"software feedback loop that keeps memory bandwidth below the value specified "
"in the schemata file. Writing the name of one of the supported memory "
"bandwidth events found in /sys/fs/resctrl/info/L3_MON/mon_features changes "
"the input event."
msgstr ""

#: ../../../filesystems/resctrl.rst:604
msgid "Resource allocation rules"
msgstr ""

#: ../../../filesystems/resctrl.rst:606
msgid ""
"When a task is running the following rules define which resources are "
"available to it:"
msgstr ""

#: ../../../filesystems/resctrl.rst:609
msgid ""
"If the task is a member of a non-default group, then the schemata for that "
"group is used."
msgstr ""

#: ../../../filesystems/resctrl.rst:612
msgid ""
"Else if the task belongs to the default group, but is running on a CPU that "
"is assigned to some specific group, then the schemata for the CPU's group is "
"used."
msgstr ""

#: ../../../filesystems/resctrl.rst:616
msgid "Otherwise the schemata for the default group is used."
msgstr ""

#: ../../../filesystems/resctrl.rst:619
msgid "Resource monitoring rules"
msgstr ""

#: ../../../filesystems/resctrl.rst:620
msgid ""
"If a task is a member of a MON group, or non-default CTRL_MON group then RDT "
"events for the task will be reported in that group."
msgstr ""

#: ../../../filesystems/resctrl.rst:623
msgid ""
"If a task is a member of the default CTRL_MON group, but is running on a CPU "
"that is assigned to some specific group, then the RDT events for the task "
"will be reported in that group."
msgstr ""

#: ../../../filesystems/resctrl.rst:627
msgid ""
"Otherwise RDT events for the task will be reported in the root level "
"\"mon_data\" group."
msgstr ""

#: ../../../filesystems/resctrl.rst:632
msgid "Notes on cache occupancy monitoring and control"
msgstr ""

#: ../../../filesystems/resctrl.rst:633
msgid ""
"When moving a task from one group to another you should remember that this "
"only affects *new* cache allocations by the task. E.g. you may have a task "
"in a monitor group showing 3 MB of cache occupancy. If you move to a new "
"group and immediately check the occupancy of the old and new groups you will "
"likely see that the old group is still showing 3 MB and the new group zero. "
"When the task accesses locations still in cache from before the move, the h/"
"w does not update any counters. On a busy system you will likely see the "
"occupancy in the old group go down as cache lines are evicted and re-used "
"while the occupancy in the new group rises as the task accesses memory and "
"loads into the cache are counted based on membership in the new group."
msgstr ""

#: ../../../filesystems/resctrl.rst:645
msgid ""
"The same applies to cache allocation control. Moving a task to a group with "
"a smaller cache partition will not evict any cache lines. The process may "
"continue to use them from the old partition."
msgstr ""

#: ../../../filesystems/resctrl.rst:649
msgid ""
"Hardware uses CLOSid(Class of service ID) and an RMID(Resource monitoring "
"ID) to identify a control group and a monitoring group respectively. Each of "
"the resource groups are mapped to these IDs based on the kind of group. The "
"number of CLOSid and RMID are limited by the hardware and hence the creation "
"of a \"CTRL_MON\" directory may fail if we run out of either CLOSID or RMID "
"and creation of \"MON\" group may fail if we run out of RMIDs."
msgstr ""

#: ../../../filesystems/resctrl.rst:657
msgid "max_threshold_occupancy - generic concepts"
msgstr ""

#: ../../../filesystems/resctrl.rst:659
msgid ""
"Note that an RMID once freed may not be immediately available for use as the "
"RMID is still tagged the cache lines of the previous user of RMID. Hence "
"such RMIDs are placed on limbo list and checked back if the cache occupancy "
"has gone down. If there is a time when system has a lot of limbo RMIDs but "
"which are not ready to be used, user may see an -EBUSY during mkdir."
msgstr ""

#: ../../../filesystems/resctrl.rst:666
msgid ""
"max_threshold_occupancy is a user configurable value to determine the "
"occupancy at which an RMID can be freed."
msgstr ""

#: ../../../filesystems/resctrl.rst:669
msgid ""
"The mon_llc_occupancy_limbo tracepoint gives the precise occupancy in bytes "
"for a subset of RMID that are not immediately available for allocation. This "
"can't be relied on to produce output every second, it may be necessary to "
"attempt to create an empty monitor group to force an update. Output may only "
"be produced if creation of a control or monitor group fails."
msgstr ""

#: ../../../filesystems/resctrl.rst:676
msgid "Schemata files - general concepts"
msgstr ""

#: ../../../filesystems/resctrl.rst:677
msgid ""
"Each line in the file describes one resource. The line starts with the name "
"of the resource, followed by specific values to be applied in each of the "
"instances of that resource on the system."
msgstr ""

#: ../../../filesystems/resctrl.rst:682
msgid "Cache IDs"
msgstr ""

#: ../../../filesystems/resctrl.rst:683
msgid ""
"On current generation systems there is one L3 cache per socket and L2 caches "
"are generally just shared by the hyperthreads on a core, but this isn't an "
"architectural requirement. We could have multiple separate L3 caches on a "
"socket, multiple cores could share an L2 cache. So instead of using "
"\"socket\" or \"core\" to define the set of logical cpus sharing a resource "
"we use a \"Cache ID\". At a given cache level this will be a unique number "
"across the whole system (but it isn't guaranteed to be a contiguous "
"sequence, there may be gaps).  To find the ID for each logical CPU look in /"
"sys/devices/system/cpu/cpu*/cache/index*/id"
msgstr ""

#: ../../../filesystems/resctrl.rst:694
msgid "Cache Bit Masks (CBM)"
msgstr ""

#: ../../../filesystems/resctrl.rst:695
msgid ""
"For cache resources we describe the portion of the cache that is available "
"for allocation using a bitmask. The maximum value of the mask is defined by "
"each cpu model (and may be different for different cache levels). It is "
"found using CPUID, but is also provided in the \"info\" directory of the "
"resctrl file system in \"info/{resource}/cbm_mask\". Some Intel hardware "
"requires that these masks have all the '1' bits in a contiguous block. So "
"0x3, 0x6 and 0xC are legal 4-bit masks with two bits set, but 0x5, 0x9 and "
"0xA are not. Check /sys/fs/resctrl/info/{resource}/sparse_masks if non-"
"contiguous 1s value is supported. On a system with a 20-bit mask each bit "
"represents 5% of the capacity of the cache. You could partition the cache "
"into four equal parts with masks: 0x1f, 0x3e0, 0x7c00, 0xf8000."
msgstr ""

#: ../../../filesystems/resctrl.rst:708
msgid "Notes on Sub-NUMA Cluster mode"
msgstr ""

#: ../../../filesystems/resctrl.rst:709
msgid ""
"When SNC mode is enabled, Linux may load balance tasks between Sub-NUMA "
"nodes much more readily than between regular NUMA nodes since the CPUs on "
"Sub-NUMA nodes share the same L3 cache and the system may report the NUMA "
"distance between Sub-NUMA nodes with a lower value than used for regular "
"NUMA nodes."
msgstr ""

#: ../../../filesystems/resctrl.rst:715
msgid ""
"The top-level monitoring files in each \"mon_L3_XX\" directory provide the "
"sum of data across all SNC nodes sharing an L3 cache instance. Users who "
"bind tasks to the CPUs of a specific Sub-NUMA node can read the "
"\"llc_occupancy\", \"mbm_total_bytes\", and \"mbm_local_bytes\" in the "
"\"mon_sub_L3_YY\" directories to get node local data."
msgstr ""

#: ../../../filesystems/resctrl.rst:721
msgid ""
"Memory bandwidth allocation is still performed at the L3 cache level. I.e. "
"throttling controls are applied to all SNC nodes."
msgstr ""

#: ../../../filesystems/resctrl.rst:724
msgid ""
"L3 cache allocation bitmaps also apply to all SNC nodes. But note that the "
"amount of L3 cache represented by each bit is divided by the number of SNC "
"nodes per L3 cache. E.g. with a 100MB cache on a system with 10-bit "
"allocation masks each bit normally represents 10MB. With SNC mode enabled "
"with two SNC nodes per L3 cache, each bit only represents 5MB."
msgstr ""

#: ../../../filesystems/resctrl.rst:731
msgid "Memory bandwidth Allocation and monitoring"
msgstr ""

#: ../../../filesystems/resctrl.rst:733
msgid ""
"For Memory bandwidth resource, by default the user controls the resource by "
"indicating the percentage of total memory bandwidth."
msgstr ""

#: ../../../filesystems/resctrl.rst:736
msgid ""
"The minimum bandwidth percentage value for each cpu model is predefined and "
"can be looked up through \"info/MB/min_bandwidth\". The bandwidth "
"granularity that is allocated is also dependent on the cpu model and can be "
"looked up at \"info/MB/bandwidth_gran\". The available bandwidth control "
"steps are: min_bw + N * bw_gran. Intermediate values are rounded to the next "
"control step available on the hardware."
msgstr ""

#: ../../../filesystems/resctrl.rst:743
msgid ""
"The bandwidth throttling is a core specific mechanism on some of Intel SKUs. "
"Using a high bandwidth and a low bandwidth setting on two threads sharing a "
"core may result in both threads being throttled to use the low bandwidth "
"(see \"thread_throttle_mode\")."
msgstr ""

#: ../../../filesystems/resctrl.rst:748
msgid ""
"The fact that Memory bandwidth allocation(MBA) may be a core specific "
"mechanism where as memory bandwidth monitoring(MBM) is done at the package "
"level may lead to confusion when users try to apply control via the MBA and "
"then monitor the bandwidth to see if the controls are effective. Below are "
"such scenarios:"
msgstr ""

#: ../../../filesystems/resctrl.rst:754
msgid ""
"User may *not* see increase in actual bandwidth when percentage values are "
"increased:"
msgstr ""

#: ../../../filesystems/resctrl.rst:757
msgid ""
"This can occur when aggregate L2 external bandwidth is more than L3 external "
"bandwidth. Consider an SKL SKU with 24 cores on a package and where L2 "
"external  is 10GBps (hence aggregate L2 external bandwidth is 240GBps) and "
"L3 external bandwidth is 100GBps. Now a workload with '20 threads, having "
"50% bandwidth, each consuming 5GBps' consumes the max L3 bandwidth of "
"100GBps although the percentage value specified is only 50% << 100%. Hence "
"increasing the bandwidth percentage will not yield any more bandwidth. This "
"is because although the L2 external bandwidth still has capacity, the L3 "
"external bandwidth is fully used. Also note that this would be dependent on "
"number of cores the benchmark is run on."
msgstr ""

#: ../../../filesystems/resctrl.rst:768
msgid ""
"Same bandwidth percentage may mean different actual bandwidth depending on # "
"of threads:"
msgstr ""

#: ../../../filesystems/resctrl.rst:771
msgid ""
"For the same SKU in #1, a 'single thread, with 10% bandwidth' and '4 thread, "
"with 10% bandwidth' can consume up to 10GBps and 40GBps although they have "
"same percentage bandwidth of 10%. This is simply because as threads start "
"using more cores in an rdtgroup, the actual bandwidth may increase or vary "
"although user specified bandwidth percentage is same."
msgstr ""

#: ../../../filesystems/resctrl.rst:777
msgid ""
"In order to mitigate this and make the interface more user friendly, resctrl "
"added support for specifying the bandwidth in MiBps as well.  The kernel "
"underneath would use a software feedback mechanism or a \"Software "
"Controller(mba_sc)\" which reads the actual bandwidth using MBM counters and "
"adjust the memory bandwidth percentages to ensure::"
msgstr ""

#: ../../../filesystems/resctrl.rst:785
msgid ""
"By default, the schemata would take the bandwidth percentage values where as "
"user can switch to the \"MBA software controller\" mode using a mount option "
"'mba_MBps'. The schemata format is specified in the below sections."
msgstr ""

#: ../../../filesystems/resctrl.rst:791
msgid "L3 schemata file details (code and data prioritization disabled)"
msgstr ""

#: ../../../filesystems/resctrl.rst:792
msgid "With CDP disabled the L3 schemata format is::"
msgstr ""

#: ../../../filesystems/resctrl.rst:797
msgid "L3 schemata file details (CDP enabled via mount option to resctrl)"
msgstr ""

#: ../../../filesystems/resctrl.rst:798
msgid ""
"When CDP is enabled L3 control is split into two separate resources so you "
"can specify independent masks for code and data like this::"
msgstr ""

#: ../../../filesystems/resctrl.rst:805
msgid "L2 schemata file details"
msgstr ""

#: ../../../filesystems/resctrl.rst:806
msgid ""
"CDP is supported at L2 using the 'cdpl2' mount option. The schemata format "
"is either::"
msgstr ""

#: ../../../filesystems/resctrl.rst:811
msgid "or"
msgstr ""

#: ../../../filesystems/resctrl.rst:813
msgid ""
"L2DATA:<cache_id0>=<cbm>;<cache_id1>=<cbm>;... L2CODE:<cache_id0>=<cbm>;"
"<cache_id1>=<cbm>;..."
msgstr ""

#: ../../../filesystems/resctrl.rst:818
msgid "Memory bandwidth Allocation (default mode)"
msgstr ""

#: ../../../filesystems/resctrl.rst:820
msgid "Memory b/w domain is L3 cache. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:826
msgid "Memory bandwidth Allocation specified in MiBps"
msgstr ""

#: ../../../filesystems/resctrl.rst:828
msgid "Memory bandwidth domain is L3 cache. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:834
msgid "Slow Memory Bandwidth Allocation (SMBA)"
msgstr ""

#: ../../../filesystems/resctrl.rst:835
msgid ""
"AMD hardware supports Slow Memory Bandwidth Allocation (SMBA). CXL.memory is "
"the only supported \"slow\" memory device. With the support of SMBA, the "
"hardware enables bandwidth allocation on the slow memory devices. If there "
"are multiple such devices in the system, the throttling logic groups all the "
"slow sources together and applies the limit on them as a whole."
msgstr ""

#: ../../../filesystems/resctrl.rst:842
msgid ""
"The presence of SMBA (with CXL.memory) is independent of slow memory devices "
"presence. If there are no such devices on the system, then configuring SMBA "
"will have no impact on the performance of the system."
msgstr ""

#: ../../../filesystems/resctrl.rst:846
msgid ""
"The bandwidth domain for slow memory is L3 cache. Its schemata file is "
"formatted as: ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:853
msgid "Reading/writing the schemata file"
msgstr ""

#: ../../../filesystems/resctrl.rst:854
msgid ""
"Reading the schemata file will show the state of all resources on all "
"domains. When writing you only need to specify those values which you wish "
"to change.  E.g. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:868
msgid "Reading/writing the schemata file (on AMD systems)"
msgstr ""

#: ../../../filesystems/resctrl.rst:869
msgid ""
"Reading the schemata file will show the current bandwidth limit on all "
"domains. The allocated resources are in multiples of one eighth GB/s. When "
"writing to the file, you need to specify what cache id you wish to configure "
"the bandwidth limit."
msgstr ""

#: ../../../filesystems/resctrl.rst:874
msgid "For example, to allocate 2GB/s limit on the first cache id:"
msgstr ""

#: ../../../filesystems/resctrl.rst:888
msgid "Reading/writing the schemata file (on AMD systems) with SMBA feature"
msgstr ""

#: ../../../filesystems/resctrl.rst:889
msgid ""
"Reading and writing the schemata file is the same as without SMBA in above "
"section."
msgstr ""

#: ../../../filesystems/resctrl.rst:892
msgid "For example, to allocate 8GB/s limit on the first cache id:"
msgstr ""

#: ../../../filesystems/resctrl.rst:908
msgid "Cache Pseudo-Locking"
msgstr ""

#: ../../../filesystems/resctrl.rst:909
msgid ""
"CAT enables a user to specify the amount of cache space that an application "
"can fill. Cache pseudo-locking builds on the fact that a CPU can still read "
"and write data pre-allocated outside its current allocated area on a cache "
"hit. With cache pseudo-locking, data can be preloaded into a reserved "
"portion of cache that no application can fill, and from that point on will "
"only serve cache hits. The cache pseudo-locked memory is made accessible to "
"user space where an application can map it into its virtual address space "
"and thus have a region of memory with reduced average read latency."
msgstr ""

#: ../../../filesystems/resctrl.rst:919
msgid ""
"The creation of a cache pseudo-locked region is triggered by a request from "
"the user to do so that is accompanied by a schemata of the region to be "
"pseudo-locked. The cache pseudo-locked region is created as follows:"
msgstr ""

#: ../../../filesystems/resctrl.rst:923
msgid ""
"Create a CAT allocation CLOSNEW with a CBM matching the schemata from the "
"user of the cache region that will contain the pseudo-locked memory. This "
"region must not overlap with any current CAT allocation/CLOS on the system "
"and no future overlap with this cache region is allowed while the pseudo-"
"locked region exists."
msgstr ""

#: ../../../filesystems/resctrl.rst:928
msgid ""
"Create a contiguous region of memory of the same size as the cache region."
msgstr ""

#: ../../../filesystems/resctrl.rst:930
msgid "Flush the cache, disable hardware prefetchers, disable preemption."
msgstr ""

#: ../../../filesystems/resctrl.rst:931
msgid ""
"Make CLOSNEW the active CLOS and touch the allocated memory to load it into "
"the cache."
msgstr ""

#: ../../../filesystems/resctrl.rst:933
msgid "Set the previous CLOS as active."
msgstr ""

#: ../../../filesystems/resctrl.rst:934
msgid ""
"At this point the closid CLOSNEW can be released - the cache pseudo-locked "
"region is protected as long as its CBM does not appear in any CAT "
"allocation. Even though the cache pseudo-locked region will from this point "
"on not appear in any CBM of any CLOS an application running with any CLOS "
"will be able to access the memory in the pseudo-locked region since the "
"region continues to serve cache hits."
msgstr ""

#: ../../../filesystems/resctrl.rst:940
msgid ""
"The contiguous region of memory loaded into the cache is exposed to user-"
"space as a character device."
msgstr ""

#: ../../../filesystems/resctrl.rst:943
msgid ""
"Cache pseudo-locking increases the probability that data will remain in the "
"cache via carefully configuring the CAT feature and controlling application "
"behavior. There is no guarantee that data is placed in cache. Instructions "
"like INVD, WBINVD, CLFLUSH, etc. can still evict “locked” data from cache. "
"Power management C-states may shrink or power off cache. Deeper C-states "
"will automatically be restricted on pseudo-locked region creation."
msgstr ""

#: ../../../filesystems/resctrl.rst:951
msgid ""
"It is required that an application using a pseudo-locked region runs with "
"affinity to the cores (or a subset of the cores) associated with the cache "
"on which the pseudo-locked region resides. A sanity check within the code "
"will not allow an application to map pseudo-locked memory unless it runs "
"with affinity to cores associated with the cache on which the pseudo-locked "
"region resides. The sanity check is only done during the initial mmap() "
"handling, there is no enforcement afterwards and the application self needs "
"to ensure it remains affine to the correct cores."
msgstr ""

#: ../../../filesystems/resctrl.rst:960
msgid "Pseudo-locking is accomplished in two stages:"
msgstr ""

#: ../../../filesystems/resctrl.rst:962
msgid ""
"During the first stage the system administrator allocates a portion of cache "
"that should be dedicated to pseudo-locking. At this time an equivalent "
"portion of memory is allocated, loaded into allocated cache portion, and "
"exposed as a character device."
msgstr ""

#: ../../../filesystems/resctrl.rst:966
msgid ""
"During the second stage a user-space application maps (mmap()) the pseudo-"
"locked memory into its address space."
msgstr ""

#: ../../../filesystems/resctrl.rst:970
msgid "Cache Pseudo-Locking Interface"
msgstr ""

#: ../../../filesystems/resctrl.rst:971
msgid ""
"A pseudo-locked region is created using the resctrl interface as follows:"
msgstr ""

#: ../../../filesystems/resctrl.rst:973
msgid ""
"Create a new resource group by creating a new directory in /sys/fs/resctrl."
msgstr ""

#: ../../../filesystems/resctrl.rst:974
msgid ""
"Change the new resource group's mode to \"pseudo-locksetup\" by writing "
"\"pseudo-locksetup\" to the \"mode\" file."
msgstr ""

#: ../../../filesystems/resctrl.rst:976
msgid ""
"Write the schemata of the pseudo-locked region to the \"schemata\" file. All "
"bits within the schemata should be \"unused\" according to the \"bit_usage\" "
"file."
msgstr ""

#: ../../../filesystems/resctrl.rst:980
msgid ""
"On successful pseudo-locked region creation the \"mode\" file will contain "
"\"pseudo-locked\" and a new character device with the same name as the "
"resource group will exist in /dev/pseudo_lock. This character device can be "
"mmap()'ed by user space in order to obtain access to the pseudo-locked "
"memory region."
msgstr ""

#: ../../../filesystems/resctrl.rst:985
msgid ""
"An example of cache pseudo-locked region creation and usage can be found "
"below."
msgstr ""

#: ../../../filesystems/resctrl.rst:988
msgid "Cache Pseudo-Locking Debugging Interface"
msgstr ""

#: ../../../filesystems/resctrl.rst:989
msgid ""
"The pseudo-locking debugging interface is enabled by default (if "
"CONFIG_DEBUG_FS is enabled) and can be found in /sys/kernel/debug/resctrl."
msgstr ""

#: ../../../filesystems/resctrl.rst:992
msgid ""
"There is no explicit way for the kernel to test if a provided memory "
"location is present in the cache. The pseudo-locking debugging interface "
"uses the tracing infrastructure to provide two ways to measure cache "
"residency of the pseudo-locked region:"
msgstr ""

#: ../../../filesystems/resctrl.rst:997
msgid ""
"Memory access latency using the pseudo_lock_mem_latency tracepoint. Data "
"from these measurements are best visualized using a hist trigger (see "
"example below). In this test the pseudo-locked region is traversed at a "
"stride of 32 bytes while hardware prefetchers and preemption are disabled. "
"This also provides a substitute visualization of cache hits and misses."
msgstr ""

#: ../../../filesystems/resctrl.rst:1003
msgid ""
"Cache hit and miss measurements using model specific precision counters if "
"available. Depending on the levels of cache on the system the pseudo_lock_l2 "
"and pseudo_lock_l3 tracepoints are available."
msgstr ""

#: ../../../filesystems/resctrl.rst:1007
msgid ""
"When a pseudo-locked region is created a new debugfs directory is created "
"for it in debugfs as /sys/kernel/debug/resctrl/<newdir>. A single write-only "
"file, pseudo_lock_measure, is present in this directory. The measurement of "
"the pseudo-locked region depends on the number written to this debugfs file:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1013
msgid "1:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1014
msgid ""
"writing \"1\" to the pseudo_lock_measure file will trigger the latency "
"measurement captured in the pseudo_lock_mem_latency tracepoint. See example "
"below."
msgstr ""

#: ../../../filesystems/resctrl.rst:1017
msgid "2:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1018
msgid ""
"writing \"2\" to the pseudo_lock_measure file will trigger the L2 cache "
"residency (cache hits and misses) measurement captured in the pseudo_lock_l2 "
"tracepoint. See example below."
msgstr ""

#: ../../../filesystems/resctrl.rst:1021
msgid "3:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1022
msgid ""
"writing \"3\" to the pseudo_lock_measure file will trigger the L3 cache "
"residency (cache hits and misses) measurement captured in the pseudo_lock_l3 "
"tracepoint."
msgstr ""

#: ../../../filesystems/resctrl.rst:1026
msgid ""
"All measurements are recorded with the tracing infrastructure. This requires "
"the relevant tracepoints to be enabled before the measurement is triggered."
msgstr ""

#: ../../../filesystems/resctrl.rst:1030
msgid "Example of latency debugging interface"
msgstr ""

#: ../../../filesystems/resctrl.rst:1031
msgid ""
"In this example a pseudo-locked region named \"newlock\" was created. Here "
"is how we can measure the latency in cycles of reading from this region and "
"visualize this data with a histogram that is available if "
"CONFIG_HIST_TRIGGERS is set::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1064
msgid "Example of cache hits/misses debugging"
msgstr ""

#: ../../../filesystems/resctrl.rst:1065
msgid ""
"In this example a pseudo-locked region named \"newlock\" was created on the "
"L2 cache of a platform. Here is how we can obtain details of the cache hits "
"and misses using the platform's precision counters. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1089
msgid "Examples for RDT allocation usage"
msgstr ""

#: ../../../filesystems/resctrl.rst:1091
msgid "Example 1"
msgstr ""

#: ../../../filesystems/resctrl.rst:1093
msgid ""
"On a two socket machine (one L3 cache per socket) with just four bits for "
"cache bit masks, minimum b/w of 10% with a memory bandwidth granularity of "
"10%. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1104 ../../../filesystems/resctrl.rst:1531
msgid ""
"The default resource group is unmodified, so we have access to all parts of "
"all caches (its schemata file reads \"L3:0=f;1=f\")."
msgstr ""

#: ../../../filesystems/resctrl.rst:1107 ../../../filesystems/resctrl.rst:1534
msgid ""
"Tasks that are under the control of group \"p0\" may only allocate from the "
"\"lower\" 50% on cache ID 0, and the \"upper\" 50% of cache ID 1. Tasks in "
"group \"p1\" use the \"lower\" 50% of cache on both sockets."
msgstr ""

#: ../../../filesystems/resctrl.rst:1111
msgid ""
"Similarly, tasks that are under the control of group \"p0\" may use a "
"maximum memory b/w of 50% on socket0 and 50% on socket 1. Tasks in group "
"\"p1\" may also use 50% memory b/w on both sockets. Note that unlike cache "
"masks, memory b/w cannot specify whether these allocations can overlap or "
"not. The allocations specifies the maximum b/w that the group may be able to "
"use and the system admin can configure the b/w accordingly."
msgstr ""

#: ../../../filesystems/resctrl.rst:1119
msgid ""
"If resctrl is using the software controller (mba_sc) then user can enter the "
"max b/w in MB rather than the percentage values. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1126
msgid ""
"In the above example the tasks in \"p1\" and \"p0\" on socket 0 would use a "
"max b/w of 1024MB where as on socket 1 they would use 500MB."
msgstr ""

#: ../../../filesystems/resctrl.rst:1129
msgid "Example 2"
msgstr ""

#: ../../../filesystems/resctrl.rst:1131
msgid "Again two sockets, but this time with a more realistic 20-bit mask."
msgstr ""

#: ../../../filesystems/resctrl.rst:1133
msgid ""
"Two real time tasks pid=1234 running on processor 0 and pid=5678 running on "
"processor 1 on socket 0 on a 2-socket and dual core machine. To avoid noisy "
"neighbors, each of the two real-time tasks exclusively occupies one quarter "
"of L3 cache on socket 0. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1142
msgid ""
"First we reset the schemata for the default group so that the \"upper\" 50% "
"of the L3 cache on socket 0 and 50% of memory b/w cannot be used by ordinary "
"tasks::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1148
msgid ""
"Next we make a resource group for our first real time task and give it "
"access to the \"top\" 25% of the cache on socket 0. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1155
msgid ""
"Finally we move our first real time task into this resource group. We also "
"use taskset(1) to ensure the task always runs on a dedicated CPU on socket "
"0. Most uses of resource groups will also constrain which processors tasks "
"run on. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1164
msgid "Ditto for the second real time task (with the remaining 25% of cache)::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1171
msgid ""
"For the same 2 socket system with memory b/w resource and CAT L3 the "
"schemata would look like(Assume min_bandwidth 10 and bandwidth_gran is 10):"
msgstr ""

#: ../../../filesystems/resctrl.rst:1175
msgid ""
"For our first real time task this would request 20% memory b/w on socket "
"0. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1180
msgid ""
"For our second real time task this would request an other 20% memory b/w on "
"socket 0. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1186
msgid "Example 3"
msgstr ""

#: ../../../filesystems/resctrl.rst:1188
msgid ""
"A single socket system which has real-time tasks running on core 4-7 and non "
"real-time workload assigned to core 0-3. The real-time tasks share text and "
"data, so a per task association is not required and due to interaction with "
"the kernel it's desired that the kernel on these cores shares L3 with the "
"tasks. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1198
msgid ""
"First we reset the schemata for the default group so that the \"upper\" 50% "
"of the L3 cache on socket 0, and 50% of memory bandwidth on socket 0 cannot "
"be used by ordinary tasks::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1204
msgid ""
"Next we make a resource group for our real time cores and give it access to "
"the \"top\" 50% of the cache on socket 0 and 50% of memory bandwidth on "
"socket 0. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1212
msgid ""
"Finally we move core 4-7 over to the new group and make sure that the kernel "
"and the tasks running there get 50% of the cache. They should also get 50% "
"of memory bandwidth assuming that the cores 4-7 are SMT siblings and only "
"the real time threads are scheduled on the cores 4-7. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1220
msgid "Example 4"
msgstr ""

#: ../../../filesystems/resctrl.rst:1222
msgid ""
"The resource groups in previous examples were all in the default "
"\"shareable\" mode allowing sharing of their cache allocations. If one "
"resource group configures a cache allocation then nothing prevents another "
"resource group to overlap with that allocation."
msgstr ""

#: ../../../filesystems/resctrl.rst:1227
msgid ""
"In this example a new exclusive resource group will be created on a L2 CAT "
"system with two L2 cache instances that can be configured with an 8-bit "
"capacity bitmask. The new exclusive resource group will be configured to use "
"25% of each cache instance. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1236
msgid ""
"First, we observe that the default group is configured to allocate to all L2 "
"cache::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1242
msgid ""
"We could attempt to create the new resource group at this point, but it will "
"fail because of the overlap with the schemata of the default group::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1254
msgid ""
"To ensure that there is no overlap with another resource group the default "
"resource group's schemata has to change, making it possible for the new "
"resource group to become exclusive. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1267
msgid ""
"A new resource group will on creation not overlap with an exclusive resource "
"group::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1277
msgid "The bit_usage will reflect how the cache is used::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1282
msgid ""
"A resource group cannot be forced to overlap with an exclusive resource "
"group::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1290
msgid "Example of Cache Pseudo-Locking"
msgstr ""

#: ../../../filesystems/resctrl.rst:1291
msgid ""
"Lock portion of L2 cache from cache id 1 using CBM 0x3. Pseudo-locked region "
"is exposed at /dev/pseudo_lock/newlock that can be provided to application "
"for argument to mmap(). ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1299
msgid ""
"Ensure that there are bits available that can be pseudo-locked, since only "
"unused bits can be pseudo-locked the bits to be pseudo-locked needs to be "
"removed from the default resource group's schemata::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1309
msgid ""
"Create a new resource group that will be associated with the pseudo-locked "
"region, indicate that it will be used for a pseudo-locked region, and "
"configure the requested pseudo-locked region capacity bitmask::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1317
msgid ""
"On success the resource group's mode will change to pseudo-locked, the "
"bit_usage will reflect the pseudo-locked region, and the character device "
"exposing the pseudo-locked region will exist::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1395
msgid "Locking between applications"
msgstr ""

#: ../../../filesystems/resctrl.rst:1397
msgid ""
"Certain operations on the resctrl filesystem, composed of read/writes to/"
"from multiple files, must be atomic."
msgstr ""

#: ../../../filesystems/resctrl.rst:1400
msgid ""
"As an example, the allocation of an exclusive reservation of L3 cache "
"involves:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1403
msgid "Read the cbmmasks from each directory or the per-resource \"bit_usage\""
msgstr ""

#: ../../../filesystems/resctrl.rst:1404
msgid ""
"Find a contiguous set of bits in the global CBM bitmask that is clear in any "
"of the directory cbmmasks"
msgstr ""

#: ../../../filesystems/resctrl.rst:1406
msgid "Create a new directory"
msgstr ""

#: ../../../filesystems/resctrl.rst:1407
msgid "Set the bits found in step 2 to the new directory \"schemata\" file"
msgstr ""

#: ../../../filesystems/resctrl.rst:1409
msgid ""
"If two applications attempt to allocate space concurrently then they can end "
"up allocating the same bits so the reservations are shared instead of "
"exclusive."
msgstr ""

#: ../../../filesystems/resctrl.rst:1413
msgid ""
"To coordinate atomic operations on the resctrlfs and to avoid the problem "
"above, the following locking procedure is recommended:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1416
msgid ""
"Locking is based on flock, which is available in libc and also as a shell "
"script command"
msgstr ""

#: ../../../filesystems/resctrl.rst:1419
msgid "Write lock:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1421
msgid "Take flock(LOCK_EX) on /sys/fs/resctrl"
msgstr ""

#: ../../../filesystems/resctrl.rst:1422
msgid "Read/write the directory structure."
msgstr ""

#: ../../../filesystems/resctrl.rst:1423 ../../../filesystems/resctrl.rst:1429
msgid "funlock"
msgstr ""

#: ../../../filesystems/resctrl.rst:1425
msgid "Read lock:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1427
msgid "Take flock(LOCK_SH) on /sys/fs/resctrl"
msgstr ""

#: ../../../filesystems/resctrl.rst:1428
msgid "If success read the directory structure."
msgstr ""

#: ../../../filesystems/resctrl.rst:1431
msgid "Example with bash::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1446
msgid "Example with C::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1510
msgid "Examples for RDT Monitoring along with allocation usage"
msgstr ""

#: ../../../filesystems/resctrl.rst:1512
msgid "Reading monitored data"
msgstr ""

#: ../../../filesystems/resctrl.rst:1513
msgid ""
"Reading an event file (for ex: mon_data/mon_L3_00/llc_occupancy) would show "
"the current snapshot of LLC occupancy of the corresponding MON group or "
"CTRL_MON group."
msgstr ""

#: ../../../filesystems/resctrl.rst:1519
msgid ""
"Example 1 (Monitor CTRL_MON group and subset of tasks in CTRL_MON group)"
msgstr ""

#: ../../../filesystems/resctrl.rst:1520
msgid ""
"On a two socket machine (one L3 cache per socket) with just four bits for "
"cache bit masks::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1538
msgid ""
"Create monitor groups and assign a subset of tasks to each monitor group. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1546
msgid "fetch data (data shown in bytes) ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1556
msgid "The parent ctrl_mon group shows the aggregated data. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1563
msgid "Example 2 (Monitor a task from its creation)"
msgstr ""

#: ../../../filesystems/resctrl.rst:1564
msgid "On a two socket machine (one L3 cache per socket)::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1570
msgid ""
"An RMID is allocated to the group once its created and hence the <cmd> below "
"is monitored from its creation. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1577
msgid "Fetch the data::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1583
msgid "Example 3 (Monitor without CAT support or before creating CAT groups)"
msgstr ""

#: ../../../filesystems/resctrl.rst:1585
msgid ""
"Assume a system like HSW has only CQM and no CAT support. In this case the "
"resctrl will still mount but cannot create CTRL_MON directories. But user "
"can create different MON groups within the root group thereby able to "
"monitor all tasks including kernel threads."
msgstr ""

#: ../../../filesystems/resctrl.rst:1590
msgid ""
"This can also be used to profile jobs cache size footprint before being able "
"to allocate them to different allocation groups. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1602
msgid ""
"Monitor the groups separately and also get per domain data. From the below "
"its apparent that the tasks are mostly doing work on domain(socket) 0. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1618
msgid "Example 4 (Monitor real time tasks)"
msgstr ""

#: ../../../filesystems/resctrl.rst:1620
msgid ""
"A single socket system which has real time tasks running on cores 4-7 and "
"non real time tasks on other cpus. We want to monitor the cache occupancy of "
"the real time threads on these cores. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1629
msgid "Move the cpus 4-7 over to p1::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1633
msgid "View the llc occupancy snapshot::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1640
msgid "Examples on working with mbm_assign_mode"
msgstr ""

#: ../../../filesystems/resctrl.rst:1642
msgid "a. Check if MBM counter assignment mode is supported. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1651
msgid "The \"mbm_event\" mode is detected and enabled."
msgstr ""

#: ../../../filesystems/resctrl.rst:1653
msgid "b. Check how many assignable counters are supported. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1659
msgid ""
"c. Check how many assignable counters are available for assignment in each "
"domain. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1665
msgid "d. To list the default group's assign states. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1672
msgid ""
"e.  To unassign the counter associated with the mbm_total_bytes event on "
"domain 0. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1680
msgid ""
"f. To unassign the counter associated with the mbm_total_bytes event on all "
"domains. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1688
msgid ""
"g. To assign a counter associated with the mbm_total_bytes event on all "
"domains in exclusive mode. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1697
msgid ""
"h. Read the events mbm_total_bytes and mbm_local_bytes of the default group. "
"There is no change in reading the events with the assignment. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1710
msgid "i. Check the event configurations. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1720
msgid "j. Change the event configuration for mbm_local_bytes. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1729
msgid ""
"k. Now read the local events again. The first read may come back with "
"\"Unavailable\" status. The subsequent read of mbm_local_bytes will display "
"the current value. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1742
msgid ""
"l. Users have the option to go back to 'default' mbm_assign_mode if "
"required. This can be done using the following command. Note that switching "
"the mbm_assign_mode may reset all the MBM counters (and thus all MBM events) "
"of all the resctrl groups. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1752
msgid "m. Unmount the resctrl filesystem. ::"
msgstr ""

#: ../../../filesystems/resctrl.rst:1758
msgid "Intel RDT Errata"
msgstr ""

#: ../../../filesystems/resctrl.rst:1761
msgid "Intel MBM Counters May Report System Memory Bandwidth Incorrectly"
msgstr ""

#: ../../../filesystems/resctrl.rst:1763
msgid "Errata SKX99 for Skylake server and BDF102 for Broadwell server."
msgstr ""

#: ../../../filesystems/resctrl.rst:1765
msgid ""
"Problem: Intel Memory Bandwidth Monitoring (MBM) counters track metrics "
"according to the assigned Resource Monitor ID (RMID) for that logical core. "
"The IA32_QM_CTR register (MSR 0xC8E), used to report these metrics, may "
"report incorrect system bandwidth for certain RMID values."
msgstr ""

#: ../../../filesystems/resctrl.rst:1770
msgid ""
"Implication: Due to the errata, system memory bandwidth may not match what "
"is reported."
msgstr ""

#: ../../../filesystems/resctrl.rst:1773
msgid ""
"Workaround: MBM total and local readings are corrected according to the "
"following correction factor table:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1777
msgid "core count"
msgstr ""

#: ../../../filesystems/resctrl.rst:1777
msgid "rmid count"
msgstr ""

#: ../../../filesystems/resctrl.rst:1777
msgid "rmid threshold"
msgstr ""

#: ../../../filesystems/resctrl.rst:1777
msgid "correction factor"
msgstr ""

#: ../../../filesystems/resctrl.rst:1779 ../../../filesystems/resctrl.rst:1791
msgid "8"
msgstr ""

#: ../../../filesystems/resctrl.rst:1779 ../../../filesystems/resctrl.rst:1781
#: ../../../filesystems/resctrl.rst:1785 ../../../filesystems/resctrl.rst:1791
#: ../../../filesystems/resctrl.rst:1799 ../../../filesystems/resctrl.rst:1807
#: ../../../filesystems/resctrl.rst:1813 ../../../filesystems/resctrl.rst:1817
#: ../../../filesystems/resctrl.rst:1821 ../../../filesystems/resctrl.rst:1829
msgid "1.000000"
msgstr ""

#: ../../../filesystems/resctrl.rst:1781 ../../../filesystems/resctrl.rst:1807
msgid "16"
msgstr ""

#: ../../../filesystems/resctrl.rst:1783 ../../../filesystems/resctrl.rst:1823
msgid "24"
msgstr ""

#: ../../../filesystems/resctrl.rst:1783 ../../../filesystems/resctrl.rst:1805
msgid "15"
msgstr ""

#: ../../../filesystems/resctrl.rst:1783 ../../../filesystems/resctrl.rst:1787
msgid "0.969650"
msgstr ""

#: ../../../filesystems/resctrl.rst:1785
msgid "32"
msgstr ""

#: ../../../filesystems/resctrl.rst:1787
msgid "48"
msgstr ""

#: ../../../filesystems/resctrl.rst:1787
msgid "31"
msgstr ""

#: ../../../filesystems/resctrl.rst:1789
msgid "7"
msgstr ""

#: ../../../filesystems/resctrl.rst:1789
msgid "56"
msgstr ""

#: ../../../filesystems/resctrl.rst:1789
msgid "47"
msgstr ""

#: ../../../filesystems/resctrl.rst:1789 ../../../filesystems/resctrl.rst:1803
msgid "1.142857"
msgstr ""

#: ../../../filesystems/resctrl.rst:1791
msgid "64"
msgstr ""

#: ../../../filesystems/resctrl.rst:1793
msgid "9"
msgstr ""

#: ../../../filesystems/resctrl.rst:1793
msgid "72"
msgstr ""

#: ../../../filesystems/resctrl.rst:1793 ../../../filesystems/resctrl.rst:1795
msgid "63"
msgstr ""

#: ../../../filesystems/resctrl.rst:1793
msgid "1.185115"
msgstr ""

#: ../../../filesystems/resctrl.rst:1795
msgid "10"
msgstr ""

#: ../../../filesystems/resctrl.rst:1795
msgid "80"
msgstr ""

#: ../../../filesystems/resctrl.rst:1795
msgid "1.066553"
msgstr ""

#: ../../../filesystems/resctrl.rst:1797
msgid "11"
msgstr ""

#: ../../../filesystems/resctrl.rst:1797
msgid "88"
msgstr ""

#: ../../../filesystems/resctrl.rst:1797
msgid "79"
msgstr ""

#: ../../../filesystems/resctrl.rst:1797
msgid "1.454545"
msgstr ""

#: ../../../filesystems/resctrl.rst:1799
msgid "12"
msgstr ""

#: ../../../filesystems/resctrl.rst:1799
msgid "96"
msgstr ""

#: ../../../filesystems/resctrl.rst:1801
msgid "13"
msgstr ""

#: ../../../filesystems/resctrl.rst:1801
msgid "104"
msgstr ""

#: ../../../filesystems/resctrl.rst:1801 ../../../filesystems/resctrl.rst:1803
#: ../../../filesystems/resctrl.rst:1805
msgid "95"
msgstr ""

#: ../../../filesystems/resctrl.rst:1801
msgid "1.230769"
msgstr ""

#: ../../../filesystems/resctrl.rst:1803
msgid "14"
msgstr ""

#: ../../../filesystems/resctrl.rst:1803
msgid "112"
msgstr ""

#: ../../../filesystems/resctrl.rst:1805
msgid "120"
msgstr ""

#: ../../../filesystems/resctrl.rst:1805 ../../../filesystems/resctrl.rst:1815
msgid "1.066667"
msgstr ""

#: ../../../filesystems/resctrl.rst:1807
msgid "128"
msgstr ""

#: ../../../filesystems/resctrl.rst:1809
msgid "17"
msgstr ""

#: ../../../filesystems/resctrl.rst:1809
msgid "136"
msgstr ""

#: ../../../filesystems/resctrl.rst:1809 ../../../filesystems/resctrl.rst:1811
#: ../../../filesystems/resctrl.rst:1815 ../../../filesystems/resctrl.rst:1823
msgid "127"
msgstr ""

#: ../../../filesystems/resctrl.rst:1809
msgid "1.254863"
msgstr ""

#: ../../../filesystems/resctrl.rst:1811
msgid "18"
msgstr ""

#: ../../../filesystems/resctrl.rst:1811
msgid "144"
msgstr ""

#: ../../../filesystems/resctrl.rst:1811
msgid "1.185255"
msgstr ""

#: ../../../filesystems/resctrl.rst:1813
msgid "19"
msgstr ""

#: ../../../filesystems/resctrl.rst:1813
msgid "152"
msgstr ""

#: ../../../filesystems/resctrl.rst:1815
msgid "20"
msgstr ""

#: ../../../filesystems/resctrl.rst:1815
msgid "160"
msgstr ""

#: ../../../filesystems/resctrl.rst:1817
msgid "21"
msgstr ""

#: ../../../filesystems/resctrl.rst:1817
msgid "168"
msgstr ""

#: ../../../filesystems/resctrl.rst:1819
msgid "22"
msgstr ""

#: ../../../filesystems/resctrl.rst:1819
msgid "176"
msgstr ""

#: ../../../filesystems/resctrl.rst:1819
msgid "159"
msgstr ""

#: ../../../filesystems/resctrl.rst:1819
msgid "1.454334"
msgstr ""

#: ../../../filesystems/resctrl.rst:1821
msgid "23"
msgstr ""

#: ../../../filesystems/resctrl.rst:1821
msgid "184"
msgstr ""

#: ../../../filesystems/resctrl.rst:1823
msgid "192"
msgstr ""

#: ../../../filesystems/resctrl.rst:1823
msgid "0.969744"
msgstr ""

#: ../../../filesystems/resctrl.rst:1825
msgid "25"
msgstr ""

#: ../../../filesystems/resctrl.rst:1825
msgid "200"
msgstr ""

#: ../../../filesystems/resctrl.rst:1825 ../../../filesystems/resctrl.rst:1827
#: ../../../filesystems/resctrl.rst:1831
msgid "191"
msgstr ""

#: ../../../filesystems/resctrl.rst:1825
msgid "1.280246"
msgstr ""

#: ../../../filesystems/resctrl.rst:1827
msgid "26"
msgstr ""

#: ../../../filesystems/resctrl.rst:1827
msgid "208"
msgstr ""

#: ../../../filesystems/resctrl.rst:1827
msgid "1.230921"
msgstr ""

#: ../../../filesystems/resctrl.rst:1829
msgid "27"
msgstr ""

#: ../../../filesystems/resctrl.rst:1829
msgid "216"
msgstr ""

#: ../../../filesystems/resctrl.rst:1831
msgid "28"
msgstr ""

#: ../../../filesystems/resctrl.rst:1831
msgid "224"
msgstr ""

#: ../../../filesystems/resctrl.rst:1831
msgid "1.143118"
msgstr ""

#: ../../../filesystems/resctrl.rst:1834
msgid ""
"If rmid > rmid threshold, MBM total and local values should be multiplied by "
"the correction factor."
msgstr ""

#: ../../../filesystems/resctrl.rst:1837
msgid "See:"
msgstr ""

#: ../../../filesystems/resctrl.rst:1839
msgid ""
"1. Erratum SKX99 in Intel Xeon Processor Scalable Family Specification "
"Update: http://web.archive.org/web/20200716124958/https://www.intel.com/"
"content/www/us/en/processors/xeon/scalable/xeon-scalable-spec-update.html"
msgstr ""

#: ../../../filesystems/resctrl.rst:1842
msgid ""
"2. Erratum BDF102 in Intel Xeon E5-2600 v4 Processor Product Family "
"Specification Update: http://web.archive.org/web/20191125200531/https://www."
"intel.com/content/dam/www/public/us/en/documents/specification-updates/xeon-"
"e5-v4-spec-update.pdf"
msgstr ""

#: ../../../filesystems/resctrl.rst:1845
msgid ""
"3. The errata in Intel Resource Director Technology (Intel RDT) on 2nd "
"Generation Intel Xeon Scalable Processors Reference Manual: https://software."
"intel.com/content/www/us/en/develop/articles/intel-resource-director-"
"technology-rdt-reference-manual.html"
msgstr ""

#: ../../../filesystems/resctrl.rst:1848
msgid "for further information."
msgstr ""
