# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-10 10:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/api-summary.rst:3
msgid "Linux Filesystems API summary"
msgstr ""

#: ../../../filesystems/api-summary.rst:5
msgid ""
"This section contains API-level documentation, mostly taken from the source "
"code itself."
msgstr ""

#: ../../../filesystems/api-summary.rst:9
msgid "The Linux VFS"
msgstr ""

#: ../../../filesystems/api-summary.rst:12
msgid "The Filesystem types"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:302
msgid "aop return codes with specific semantics"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:306
msgid "**Constants**"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:308
msgid "``AOP_WRITEPAGE_ACTIVATE``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:309
msgid ""
"Informs the caller that page writeback has completed, that the page is still "
"locked, and should be considered active.  The VM uses this hint to return "
"the page to the active list -- it won't be a candidate for writeback again "
"in the near future.  Other callers must be careful to unlock the page if "
"they get this return.  Returned by writepage();"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:318
msgid "``AOP_TRUNCATED_PAGE``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:319
msgid ""
"The AOP method that was handed a locked page has unlocked it and the page "
"might have been truncated. The caller should back up to acquiring a new page "
"and trying again.  The aop will be taking reasonable precautions not to "
"livelock.  If the caller held a page reference, it should drop it before "
"retrying.  Returned by read_folio()."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:180
#: ../kernel/sysctl.c:588 ../kernel/sysctl.c:628 ../kernel/sysctl.c:647
#: ../kernel/sysctl.c:667 ../kernel/sysctl.c:691 ../kernel/sysctl.c:718
#: ../kernel/sysctl.c:851 ../kernel/sysctl.c:881
#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3461
#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:51 ../fs/eventfd.c:100
#: ../fs/eventfd.c:191 ../fs/eventfd.c:317 ../fs/eventfd.c:343
#: ../fs/eventfd.c:361 ../../../filesystems/api-summary:131:
#: ../fs/sysfs/file.c:458 ../fs/sysfs/file.c:482 ../fs/sysfs/file.c:505
#: ../fs/sysfs/file.c:521 ../fs/sysfs/file.c:665 ../fs/sysfs/file.c:700
#: ../fs/sysfs/file.c:747 ../fs/sysfs/file.c:775 ../fs/sysfs/file.c:804
#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:102
#: ../fs/sysfs/symlink.c:164 ../../../filesystems/api-summary:143:
#: ../fs/debugfs/inode.c:3 ../fs/debugfs/inode.c:338 ../fs/debugfs/inode.c:490
#: ../fs/debugfs/inode.c:529 ../fs/debugfs/inode.c:554
#: ../fs/debugfs/inode.c:607 ../fs/debugfs/inode.c:651
#: ../fs/debugfs/inode.c:767 ../fs/debugfs/inode.c:791
#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:149
#: ../fs/debugfs/file.c:171 ../fs/debugfs/file.c:190 ../fs/debugfs/file.c:240
#: ../fs/debugfs/file.c:602 ../fs/debugfs/file.c:638 ../fs/debugfs/file.c:674
#: ../fs/debugfs/file.c:711 ../fs/debugfs/file.c:750 ../fs/debugfs/file.c:1004
#: ../fs/debugfs/file.c:1132 ../fs/debugfs/file.c:1194
#: ../fs/debugfs/file.c:1289 ../fs/debugfs/file.c:1318
#: ../fs/debugfs/file.c:1369 ../../../filesystems/api-summary:14:
#: ../include/linux/fs.h:327 ../include/linux/fs.h:1210
#: ../include/linux/fs.h:1457 ../include/linux/fs.h:1477
#: ../include/linux/fs.h:1509 ../include/linux/fs.h:1529
#: ../include/linux/fs.h:1546 ../include/linux/fs.h:1560
#: ../include/linux/fs.h:1574 ../include/linux/fs.h:1707
#: ../include/linux/fs.h:1728 ../include/linux/fs.h:1743
#: ../include/linux/fs.h:2303 ../include/linux/fs.h:2432
#: ../include/linux/fs.h:2676 ../include/linux/fs.h:2697
#: ../include/linux/fs.h:2710 ../include/linux/fs.h:2729
#: ../include/linux/fs.h:3090 ../include/linux/fs.h:3102
#: ../include/linux/fs.h:3292 ../../../filesystems/api-summary:20:
#: ../fs/dcache.c:586 ../fs/dcache.c:1022 ../fs/dcache.c:1059
#: ../fs/dcache.c:1112 ../fs/dcache.c:1285 ../fs/dcache.c:1447
#: ../fs/dcache.c:1813 ../fs/dcache.c:1995 ../fs/dcache.c:2114
#: ../fs/dcache.c:2138 ../fs/dcache.c:2161 ../fs/dcache.c:2382
#: ../fs/dcache.c:2513 ../fs/dcache.c:2552 ../fs/dcache.c:2782
#: ../fs/dcache.c:3119 ../fs/dcache.c:3154 ../../../filesystems/api-summary:23:
#: ../include/linux/dcache.h:318 ../include/linux/dcache.h:335
#: ../include/linux/dcache.h:362 ../include/linux/dcache.h:484
#: ../include/linux/dcache.h:504 ../include/linux/dcache.h:529
#: ../include/linux/dcache.h:541 ../include/linux/dcache.h:553
#: ../include/linux/dcache.h:571 ../include/linux/dcache.h:588
#: ../../../filesystems/api-summary:29: ../fs/inode.c:223 ../fs/inode.c:408
#: ../fs/inode.c:428 ../fs/inode.c:446 ../fs/inode.c:467 ../fs/inode.c:690
#: ../fs/inode.c:708 ../fs/inode.c:888 ../fs/inode.c:1163 ../fs/inode.c:1206
#: ../fs/inode.c:1241 ../fs/inode.c:1282 ../fs/inode.c:1359 ../fs/inode.c:1398
#: ../fs/inode.c:1440 ../fs/inode.c:1537 ../fs/inode.c:1600 ../fs/inode.c:1630
#: ../fs/inode.c:1667 ../fs/inode.c:1702 ../fs/inode.c:1752 ../fs/inode.c:1790
#: ../fs/inode.c:1961 ../fs/inode.c:2029 ../fs/inode.c:2092 ../fs/inode.c:2142
#: ../fs/inode.c:2317 ../fs/inode.c:2332 ../fs/inode.c:2407 ../fs/inode.c:2456
#: ../fs/inode.c:2473 ../fs/inode.c:2628 ../fs/inode.c:2655 ../fs/inode.c:2694
#: ../fs/inode.c:2758 ../fs/inode.c:2788 ../fs/inode.c:2871 ../fs/inode.c:2945
#: ../fs/inode.c:2968 ../../../filesystems/api-summary:32:
#: ../fs/bad_inode.c:201 ../fs/bad_inode.c:228 ../fs/bad_inode.c:242
#: ../../../filesystems/api-summary:38: ../fs/super.c:462 ../fs/super.c:499
#: ../fs/super.c:577 ../fs/super.c:606 ../fs/super.c:705 ../fs/super.c:948
#: ../fs/super.c:1247 ../fs/super.c:1387 ../fs/super.c:1736 ../fs/super.c:2017
#: ../fs/super.c:2220 ../../../filesystems/api-summary:44: ../fs/locks.c:327
#: ../fs/locks.c:823 ../fs/locks.c:1440 ../fs/locks.c:1583 ../fs/locks.c:1707
#: ../fs/locks.c:1950 ../fs/locks.c:2035 ../fs/locks.c:2155 ../fs/locks.c:2244
#: ../fs/locks.c:2383 ../fs/locks.c:2776 ../fs/locks.c:2791
#: ../../../filesystems/api-summary:47: ../fs/locks.c:595 ../fs/locks.c:1460
#: ../fs/locks.c:1737 ../fs/locks.c:2091 ../fs/locks.c:2111 ../fs/locks.c:2131
#: ../fs/locks.c:2179 ../fs/locks.c:2270 ../../../filesystems/api-summary:53:
#: ../fs/mpage.c:325 ../fs/mpage.c:654 ../../../filesystems/api-summary:56:
#: ../fs/namei.c:449 ../fs/namei.c:565 ../fs/namei.c:648 ../fs/namei.c:661
#: ../fs/namei.c:2891 ../fs/namei.c:3090 ../fs/namei.c:3117 ../fs/namei.c:3144
#: ../fs/namei.c:3171 ../fs/namei.c:3199 ../fs/namei.c:3240 ../fs/namei.c:3270
#: ../fs/namei.c:3323 ../fs/namei.c:3350 ../fs/namei.c:3377 ../fs/namei.c:3406
#: ../fs/namei.c:3436 ../fs/namei.c:3459 ../fs/namei.c:3484 ../fs/namei.c:3517
#: ../fs/namei.c:3871 ../fs/namei.c:3965 ../fs/namei.c:3998 ../fs/namei.c:4113
#: ../fs/namei.c:4716 ../fs/namei.c:4923 ../fs/namei.c:4959 ../fs/namei.c:5096
#: ../fs/namei.c:5210 ../fs/namei.c:5334 ../fs/namei.c:5494 ../fs/namei.c:5587
#: ../fs/namei.c:5766 ../fs/namei.c:6121 ../fs/namei.c:6164 ../fs/namei.c:6222
#: ../fs/namei.c:6242 ../../../filesystems/api-summary:59: ../block/bio.c:296
#: ../block/bio.c:338 ../block/bio.c:486 ../block/bio.c:606 ../block/bio.c:815
#: ../block/bio.c:863 ../block/bio.c:894 ../block/bio.c:981 ../block/bio.c:1005
#: ../block/bio.c:1022 ../block/bio.c:1069 ../block/bio.c:1093
#: ../block/bio.c:1120 ../block/bio.c:1376 ../block/bio.c:1406
#: ../block/bio.c:1483 ../block/bio.c:1623 ../block/bio.c:1686
#: ../block/bio.c:1735 ../block/bio.c:1801 ../../../filesystems/api-summary:62:
#: ../fs/seq_file.c:46 ../fs/seq_file.c:149 ../fs/seq_file.c:306
#: ../fs/seq_file.c:349 ../fs/seq_file.c:369 ../fs/seq_file.c:435
#: ../fs/seq_file.c:467 ../fs/seq_file.c:496 ../fs/seq_file.c:821
#: ../fs/seq_file.c:964 ../fs/seq_file.c:982 ../fs/seq_file.c:1000
#: ../fs/seq_file.c:1020 ../fs/seq_file.c:1043 ../fs/seq_file.c:1066
#: ../fs/seq_file.c:1092 ../fs/seq_file.c:1116
#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:63
#: ../fs/filesystems.c:100 ../../../filesystems/api-summary:68:
#: ../fs/fs-writeback.c:821 ../fs/fs-writeback.c:838 ../fs/fs-writeback.c:963
#: ../fs/fs-writeback.c:2544 ../fs/fs-writeback.c:2830
#: ../fs/fs-writeback.c:2847 ../fs/fs-writeback.c:2862
#: ../fs/fs-writeback.c:2878 ../fs/fs-writeback.c:2919
#: ../fs/fs-writeback.c:2946 ../../../filesystems/api-summary:71:
#: ../fs/anon_inodes.c:194 ../fs/anon_inodes.c:219 ../fs/anon_inodes.c:252
#: ../fs/anon_inodes.c:297 ../../../filesystems/api-summary:74: ../fs/attr.c:26
#: ../fs/attr.c:54 ../fs/attr.c:146 ../fs/attr.c:233 ../fs/attr.c:313
#: ../fs/attr.c:397 ../../../filesystems/api-summary:77: ../fs/d_path.c:255
#: ../../../filesystems/api-summary:80: ../fs/dax.c:743 ../fs/dax.c:1702
#: ../fs/dax.c:2066 ../fs/dax.c:2138 ../../../filesystems/api-summary:83:
#: ../fs/libfs.c:830 ../fs/libfs.c:906 ../fs/libfs.c:1136 ../fs/libfs.c:1171
#: ../fs/libfs.c:1206 ../fs/libfs.c:1440 ../fs/libfs.c:1482 ../fs/libfs.c:1514
#: ../fs/libfs.c:1547 ../fs/libfs.c:1611 ../fs/libfs.c:1707 ../fs/libfs.c:1724
#: ../fs/libfs.c:1911 ../fs/libfs.c:1986 ../fs/libfs.c:2014 ../fs/libfs.c:2064
#: ../fs/libfs.c:2144 ../fs/libfs.c:2316 ../../../filesystems/api-summary:86:
#: ../fs/posix_acl.c:597 ../fs/posix_acl.c:690 ../fs/posix_acl.c:755
#: ../fs/posix_acl.c:1083 ../fs/posix_acl.c:1160 ../fs/posix_acl.c:1205
#: ../../../filesystems/api-summary:89: ../fs/stat.c:37 ../fs/stat.c:72
#: ../fs/stat.c:121 ../fs/stat.c:141 ../fs/stat.c:175
#: ../../../filesystems/api-summary:92: ../fs/sync.c:176 ../fs/sync.c:197
#: ../../../filesystems/api-summary:95: ../fs/xattr.c:466 ../fs/xattr.c:1135
#: ../fs/xattr.c:1166 ../../../filesystems/api-summary:98:
#: ../fs/namespace.c:431 ../fs/namespace.c:490 ../fs/namespace.c:534
#: ../fs/namespace.c:555 ../fs/namespace.c:571 ../fs/namespace.c:1172
#: ../fs/namespace.c:1450 ../fs/namespace.c:1584 ../fs/namespace.c:1612
#: ../fs/namespace.c:2359
msgid "**Description**"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:320
msgid ""
"address_space_operation functions return these large constants to indicate "
"special semantics to the caller.  These are much larger than the bytes in a "
"page to allow for functions that return the number of bytes operated on in a "
"given page."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:449
#: ../include/linux/fs.h:1236
msgid "Contents of a cacheable, mappable object."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:453
#: ../include/linux/fs.h:1201 ../include/linux/fs.h:1235
#: ../include/linux/fs.h:1780
msgid "**Definition**::"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:476
#: ../include/linux/fs.h:1213 ../include/linux/fs.h:1274
#: ../include/linux/fs.h:1792
msgid "**Members**"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:450
msgid "``host``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:451
msgid "Owner, either the inode or the block_device."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:451
msgid "``i_pages``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:452
msgid "Cached pages."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:452
msgid "``invalidate_lock``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:453
msgid ""
"Guards coherency between page cache contents and file offset->disk block "
"mappings in the filesystem during invalidates. It is also used to block "
"modification of page cache contents through memory mappings."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:456
msgid "``gfp_mask``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:457
msgid "Memory allocation flags to use for allocating pages."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:457
msgid "``i_mmap_writable``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:458
msgid "Number of VM_SHARED, VM_MAYWRITE mappings."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:458
msgid "``nr_thps``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:459
msgid "Number of THPs in the pagecache (non-shmem only)."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:459
msgid "``i_mmap``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:460
msgid "Tree of private and shared mappings."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:461
msgid "``nrpages``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:462
msgid "Number of page entries, protected by the i_pages lock."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:462
msgid "``writeback_index``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:463
msgid "Writeback starts here."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:463
msgid "``a_ops``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:464
msgid "Methods."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:464
#: ../include/linux/fs.h:1783
msgid "``flags``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:465
msgid "Error bits and flags (AS_*)."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:465
msgid "``wb_err``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:466
msgid "The most recent error which has occurred."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:466
msgid "``i_private_lock``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:467
#: ../include/linux/fs.h:468 ../include/linux/fs.h:469
msgid "For use by the owner of the address_space."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:467
msgid "``i_private_list``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:460
msgid "``i_mmap_rwsem``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:461
msgid "Protects **i_mmap** and **i_mmap_writable**."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:468
msgid "``i_private_data``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1197
msgid "Track a file's readahead state."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1198
msgid "``start``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1199
msgid "Where the most recent readahead started."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1199
msgid "``size``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1200
msgid "Number of pages read in the most recent readahead."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1200
msgid "``async_size``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1201
msgid ""
"Numer of pages that were/are not needed immediately and so were/are "
"genuinely \"ahead\".  Start next readahead when the first of these pages is "
"accessed."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1203
msgid "``ra_pages``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1204
msgid "Maximum size of a readahead request, copied from the bdi."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1204
msgid "``order``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1205
msgid "Preferred folio order used for most recent readahead."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1205
msgid "``mmap_miss``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1206
msgid "How many mmap accesses missed in the page cache."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1206
msgid "``prev_pos``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1207
msgid "The last byte in the most recent read request."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1207
msgid ""
"When this structure is passed to ->readahead(), the \"most recent\" "
"readahead means the current readahead."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1231
msgid "Represents a file"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1232
msgid "``f_lock``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1233
msgid "Protects f_ep, f_flags. Must not be taken from IRQ context."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1233
msgid "``f_mode``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1234
msgid "FMODE_* flags often used in hotpaths"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1234
msgid "``f_op``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1235
msgid "file operations"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1235
msgid "``f_mapping``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1236
msgid "``private_data``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1237
msgid "filesystem or driver specific data"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1237
msgid "``f_inode``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1238
msgid "cached inode"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1238
msgid "``f_flags``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1239
msgid "file flags"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1239
msgid "``f_iocb_flags``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1240
msgid "iocb flags"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1240
msgid "``f_cred``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1241
msgid "stashed credentials of creator/opener"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1241
msgid "``f_owner``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1242
msgid "file owner"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2
msgid "anonymous"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1242
msgid "``f_path``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1243
msgid "path of the file"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1243
msgid "``__f_path``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1244
msgid ""
"writable alias for **f_path**; *ONLY* for core VFS and only before the file "
"gets open"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1245
msgid "``f_pos_lock``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1246
msgid "lock protecting file position"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1246
msgid "``f_pipe``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1247
msgid "specific to pipes"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1247
msgid "``f_pos``"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:178
#: ../kernel/sysctl.c:586 ../kernel/sysctl.c:626 ../kernel/sysctl.c:645
#: ../kernel/sysctl.c:665 ../kernel/sysctl.c:689 ../kernel/sysctl.c:716
#: ../kernel/sysctl.c:849 ../kernel/sysctl.c:879
#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1248
msgid "file position"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1248
msgid "``f_security``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1249
msgid "LSM security context of this file"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1249
msgid "``f_wb_err``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1250
msgid "writeback error"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1250
msgid "``f_sb_err``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1251
msgid "per sb writeback errors"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1251
msgid "``f_ep``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1252
msgid "link of all epoll hooks for this file"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1252
msgid "``f_task_work``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1253
msgid "task work entry point"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1253
msgid "``f_llist``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1254
msgid "work queue entrypoint"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1254
msgid "``f_ra``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1255
msgid "file's readahead state"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1255
msgid "``f_freeptr``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1256
msgid "Pointer used by SLAB_TYPESAFE_BY_RCU file cache (don't touch.)"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1256
msgid "``f_ref``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1257
msgid "reference count"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1438
msgid "map an inode's i_uid down according to an idmapping"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:177
#: ../kernel/sysctl.c:585 ../kernel/sysctl.c:625 ../kernel/sysctl.c:644
#: ../kernel/sysctl.c:664 ../kernel/sysctl.c:688 ../kernel/sysctl.c:715
#: ../kernel/sysctl.c:848 ../kernel/sysctl.c:878
#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3462
#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:51 ../fs/eventfd.c:101
#: ../fs/eventfd.c:190 ../fs/eventfd.c:318 ../fs/eventfd.c:344
#: ../fs/eventfd.c:362 ../../../filesystems/api-summary:125:
#: ../fs/eventpoll.c:387 ../fs/eventpoll.c:402 ../fs/eventpoll.c:1468
#: ../fs/eventpoll.c:1924 ../fs/eventpoll.c:2061 ../fs/eventpoll.c:2126
#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:363
#: ../fs/sysfs/file.c:397 ../fs/sysfs/file.c:430 ../fs/sysfs/file.c:458
#: ../fs/sysfs/file.c:483 ../fs/sysfs/file.c:504 ../fs/sysfs/file.c:521
#: ../fs/sysfs/file.c:554 ../fs/sysfs/file.c:579 ../fs/sysfs/file.c:599
#: ../fs/sysfs/file.c:663 ../fs/sysfs/file.c:699 ../fs/sysfs/file.c:746
#: ../fs/sysfs/file.c:772 ../fs/sysfs/file.c:800
#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:88
#: ../fs/sysfs/symlink.c:101 ../fs/sysfs/symlink.c:143
#: ../fs/sysfs/symlink.c:161 ../../../filesystems/api-summary:143:
#: ../fs/debugfs/inode.c:338 ../fs/debugfs/inode.c:482
#: ../fs/debugfs/inode.c:520 ../fs/debugfs/inode.c:551
#: ../fs/debugfs/inode.c:603 ../fs/debugfs/inode.c:645
#: ../fs/debugfs/inode.c:767 ../fs/debugfs/inode.c:791
#: ../fs/debugfs/inode.c:813 ../fs/debugfs/inode.c:878
#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:150
#: ../fs/debugfs/file.c:171 ../fs/debugfs/file.c:189 ../fs/debugfs/file.c:239
#: ../fs/debugfs/file.c:597 ../fs/debugfs/file.c:633 ../fs/debugfs/file.c:669
#: ../fs/debugfs/file.c:706 ../fs/debugfs/file.c:744 ../fs/debugfs/file.c:794
#: ../fs/debugfs/file.c:812 ../fs/debugfs/file.c:830 ../fs/debugfs/file.c:848
#: ../fs/debugfs/file.c:882 ../fs/debugfs/file.c:917 ../fs/debugfs/file.c:999
#: ../fs/debugfs/file.c:1127 ../fs/debugfs/file.c:1188
#: ../fs/debugfs/file.c:1284 ../fs/debugfs/file.c:1315
#: ../fs/debugfs/file.c:1363 ../fs/debugfs/file.c:1408
#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1442
#: ../include/linux/fs.h:1456 ../include/linux/fs.h:1476
#: ../include/linux/fs.h:1494 ../include/linux/fs.h:1508
#: ../include/linux/fs.h:1528 ../include/linux/fs.h:1546
#: ../include/linux/fs.h:1560 ../include/linux/fs.h:1574
#: ../include/linux/fs.h:1706 ../include/linux/fs.h:1729
#: ../include/linux/fs.h:1744 ../include/linux/fs.h:2304
#: ../include/linux/fs.h:2433 ../include/linux/fs.h:2677
#: ../include/linux/fs.h:2698 ../include/linux/fs.h:2711
#: ../include/linux/fs.h:2730 ../include/linux/fs.h:2853
#: ../include/linux/fs.h:2864 ../include/linux/fs.h:3091
#: ../include/linux/fs.h:3103 ../include/linux/fs.h:3283
#: ../../../filesystems/api-summary:20: ../fs/dcache.c:587 ../fs/dcache.c:1023
#: ../fs/dcache.c:1060 ../fs/dcache.c:1112 ../fs/dcache.c:1286
#: ../fs/dcache.c:1447 ../fs/dcache.c:1694 ../fs/dcache.c:1813
#: ../fs/dcache.c:1995 ../fs/dcache.c:2115 ../fs/dcache.c:2139
#: ../fs/dcache.c:2160 ../fs/dcache.c:2214 ../fs/dcache.c:2381
#: ../fs/dcache.c:2514 ../fs/dcache.c:2553 ../fs/dcache.c:2782
#: ../fs/dcache.c:3119 ../fs/dcache.c:3154 ../../../filesystems/api-summary:23:
#: ../include/linux/dcache.h:319 ../include/linux/dcache.h:336
#: ../include/linux/dcache.h:363 ../include/linux/dcache.h:485
#: ../include/linux/dcache.h:505 ../include/linux/dcache.h:530
#: ../include/linux/dcache.h:542 ../include/linux/dcache.h:554
#: ../include/linux/dcache.h:571 ../include/linux/dcache.h:589
#: ../../../filesystems/api-summary:29: ../fs/inode.c:222 ../fs/inode.c:409
#: ../fs/inode.c:429 ../fs/inode.c:446 ../fs/inode.c:468 ../fs/inode.c:654
#: ../fs/inode.c:689 ../fs/inode.c:709 ../fs/inode.c:889 ../fs/inode.c:1164
#: ../fs/inode.c:1207 ../fs/inode.c:1237 ../fs/inode.c:1261 ../fs/inode.c:1279
#: ../fs/inode.c:1356 ../fs/inode.c:1395 ../fs/inode.c:1440 ../fs/inode.c:1537
#: ../fs/inode.c:1595 ../fs/inode.c:1628 ../fs/inode.c:1667 ../fs/inode.c:1700
#: ../fs/inode.c:1750 ../fs/inode.c:1790 ../fs/inode.c:1962 ../fs/inode.c:2015
#: ../fs/inode.c:2029 ../fs/inode.c:2092 ../fs/inode.c:2142 ../fs/inode.c:2318
#: ../fs/inode.c:2333 ../fs/inode.c:2408 ../fs/inode.c:2457 ../fs/inode.c:2474
#: ../fs/inode.c:2626 ../fs/inode.c:2655 ../fs/inode.c:2695 ../fs/inode.c:2758
#: ../fs/inode.c:2789 ../fs/inode.c:2871 ../fs/inode.c:2944 ../fs/inode.c:2967
#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:202
#: ../fs/bad_inode.c:229 ../fs/bad_inode.c:243
#: ../../../filesystems/api-summary:38: ../fs/super.c:463 ../fs/super.c:500
#: ../fs/super.c:578 ../fs/super.c:607 ../fs/super.c:704 ../fs/super.c:813
#: ../fs/super.c:947 ../fs/super.c:1248 ../fs/super.c:1387 ../fs/super.c:1658
#: ../fs/super.c:1710 ../fs/super.c:1737 ../fs/super.c:2016 ../fs/super.c:2219
#: ../../../filesystems/api-summary:44: ../fs/locks.c:327 ../fs/locks.c:824
#: ../fs/locks.c:1439 ../fs/locks.c:1583 ../fs/locks.c:1707 ../fs/locks.c:1947
#: ../fs/locks.c:2032 ../fs/locks.c:2155 ../fs/locks.c:2244 ../fs/locks.c:2381
#: ../fs/locks.c:2776 ../fs/locks.c:2792 ../../../filesystems/api-summary:47:
#: ../fs/locks.c:593 ../fs/locks.c:1460 ../fs/locks.c:1737 ../fs/locks.c:2090
#: ../fs/locks.c:2110 ../fs/locks.c:2131 ../fs/locks.c:2179 ../fs/locks.c:2270
#: ../../../filesystems/api-summary:53: ../fs/mpage.c:325 ../fs/mpage.c:653
#: ../../../filesystems/api-summary:56: ../fs/namei.c:447 ../fs/namei.c:564
#: ../fs/namei.c:649 ../fs/namei.c:662 ../fs/namei.c:2892 ../fs/namei.c:3009
#: ../fs/namei.c:3027 ../fs/namei.c:3090 ../fs/namei.c:3117 ../fs/namei.c:3143
#: ../fs/namei.c:3170 ../fs/namei.c:3198 ../fs/namei.c:3239 ../fs/namei.c:3270
#: ../fs/namei.c:3322 ../fs/namei.c:3349 ../fs/namei.c:3376 ../fs/namei.c:3405
#: ../fs/namei.c:3436 ../fs/namei.c:3459 ../fs/namei.c:3484 ../fs/namei.c:3517
#: ../fs/namei.c:3867 ../fs/namei.c:3961 ../fs/namei.c:3997 ../fs/namei.c:4111
#: ../fs/namei.c:4713 ../fs/namei.c:4923 ../fs/namei.c:4955 ../fs/namei.c:5093
#: ../fs/namei.c:5208 ../fs/namei.c:5332 ../fs/namei.c:5491 ../fs/namei.c:5584
#: ../fs/namei.c:5767 ../fs/namei.c:6120 ../fs/namei.c:6164 ../fs/namei.c:6221
#: ../fs/namei.c:6243 ../../../filesystems/api-summary:59: ../block/bio.c:295
#: ../block/bio.c:338 ../block/bio.c:483 ../block/bio.c:606 ../block/bio.c:816
#: ../block/bio.c:861 ../block/bio.c:892 ../block/bio.c:979 ../block/bio.c:1004
#: ../block/bio.c:1020 ../block/bio.c:1067 ../block/bio.c:1092
#: ../block/bio.c:1119 ../block/bio.c:1377 ../block/bio.c:1403
#: ../block/bio.c:1484 ../block/bio.c:1624 ../block/bio.c:1684
#: ../block/bio.c:1734 ../block/bio.c:1798 ../../../filesystems/api-summary:62:
#: ../fs/seq_file.c:46 ../fs/seq_file.c:147 ../fs/seq_file.c:305
#: ../fs/seq_file.c:349 ../fs/seq_file.c:366 ../fs/seq_file.c:434
#: ../fs/seq_file.c:466 ../fs/seq_file.c:495 ../fs/seq_file.c:820
#: ../fs/seq_file.c:840 ../fs/seq_file.c:964 ../fs/seq_file.c:982
#: ../fs/seq_file.c:999 ../fs/seq_file.c:1020 ../fs/seq_file.c:1043
#: ../fs/seq_file.c:1065 ../fs/seq_file.c:1091 ../fs/seq_file.c:1114
#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:64
#: ../fs/filesystems.c:101 ../../../filesystems/api-summary:68:
#: ../fs/fs-writeback.c:821 ../fs/fs-writeback.c:839 ../fs/fs-writeback.c:962
#: ../fs/fs-writeback.c:2541 ../fs/fs-writeback.c:2829
#: ../fs/fs-writeback.c:2847 ../fs/fs-writeback.c:2862
#: ../fs/fs-writeback.c:2879 ../fs/fs-writeback.c:2919
#: ../fs/fs-writeback.c:2946 ../../../filesystems/api-summary:71:
#: ../fs/anon_inodes.c:189 ../fs/anon_inodes.c:213 ../fs/anon_inodes.c:245
#: ../fs/anon_inodes.c:292 ../../../filesystems/api-summary:74: ../fs/attr.c:25
#: ../fs/attr.c:53 ../fs/attr.c:145 ../fs/attr.c:233 ../fs/attr.c:312
#: ../fs/attr.c:395 ../../../filesystems/api-summary:77: ../fs/d_path.c:254
#: ../../../filesystems/api-summary:80: ../fs/dax.c:741 ../fs/dax.c:1701
#: ../fs/dax.c:2063 ../fs/dax.c:2137 ../../../filesystems/api-summary:83:
#: ../fs/libfs.c:828 ../fs/libfs.c:905 ../fs/libfs.c:1133 ../fs/libfs.c:1168
#: ../fs/libfs.c:1203 ../fs/libfs.c:1438 ../fs/libfs.c:1479 ../fs/libfs.c:1511
#: ../fs/libfs.c:1544 ../fs/libfs.c:1588 ../fs/libfs.c:1611 ../fs/libfs.c:1705
#: ../fs/libfs.c:1723 ../fs/libfs.c:1817 ../fs/libfs.c:1873 ../fs/libfs.c:1905
#: ../fs/libfs.c:1986 ../fs/libfs.c:2014 ../fs/libfs.c:2065 ../fs/libfs.c:2145
#: ../fs/libfs.c:2316 ../../../filesystems/api-summary:86:
#: ../fs/posix_acl.c:595 ../fs/posix_acl.c:688 ../fs/posix_acl.c:754
#: ../fs/posix_acl.c:1081 ../fs/posix_acl.c:1159 ../fs/posix_acl.c:1204
#: ../../../filesystems/api-summary:89: ../fs/stat.c:36 ../fs/stat.c:70
#: ../fs/stat.c:121 ../fs/stat.c:139 ../fs/stat.c:173
#: ../../../filesystems/api-summary:92: ../fs/sync.c:174 ../fs/sync.c:197
#: ../../../filesystems/api-summary:95: ../fs/xattr.c:266 ../fs/xattr.c:465
#: ../fs/xattr.c:528 ../fs/xattr.c:1134 ../fs/xattr.c:1165
#: ../../../filesystems/api-summary:98: ../fs/namespace.c:432
#: ../fs/namespace.c:491 ../fs/namespace.c:535 ../fs/namespace.c:556
#: ../fs/namespace.c:572 ../fs/namespace.c:1173 ../fs/namespace.c:1451
#: ../fs/namespace.c:1585 ../fs/namespace.c:1613 ../fs/namespace.c:2360
#: ../fs/namespace.c:3777
msgid "**Parameters**"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1444
#: ../include/linux/fs.h:1458 ../include/linux/fs.h:1478
#: ../include/linux/fs.h:1496 ../include/linux/fs.h:1510
#: ../include/linux/fs.h:1530 ../include/linux/fs.h:1545
#: ../include/linux/fs.h:1559 ../include/linux/fs.h:1573
#: ../../../filesystems/api-summary:29: ../fs/inode.c:2628 ../fs/inode.c:2657
#: ../fs/inode.c:2946 ../fs/inode.c:2969 ../../../filesystems/api-summary:56:
#: ../fs/namei.c:449 ../fs/namei.c:566 ../fs/namei.c:3145 ../fs/namei.c:3172
#: ../fs/namei.c:3200 ../fs/namei.c:3241 ../fs/namei.c:3324 ../fs/namei.c:3351
#: ../fs/namei.c:3378 ../fs/namei.c:3407 ../fs/namei.c:4113 ../fs/namei.c:4715
#: ../fs/namei.c:4957 ../fs/namei.c:5095 ../fs/namei.c:5210 ../fs/namei.c:5334
#: ../fs/namei.c:5493 ../fs/namei.c:5583 ../../../filesystems/api-summary:74:
#: ../fs/attr.c:27 ../fs/attr.c:55 ../fs/attr.c:147 ../fs/attr.c:314
#: ../fs/attr.c:397 ../../../filesystems/api-summary:83: ../fs/libfs.c:907
#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:597
#: ../fs/posix_acl.c:690 ../fs/posix_acl.c:1083 ../fs/posix_acl.c:1161
#: ../fs/posix_acl.c:1206 ../../../filesystems/api-summary:89: ../fs/stat.c:72
#: ../../../filesystems/api-summary:95: ../fs/xattr.c:268 ../fs/xattr.c:530
msgid "``struct mnt_idmap *idmap``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1439
#: ../include/linux/fs.h:1453 ../include/linux/fs.h:1473
#: ../include/linux/fs.h:1491 ../include/linux/fs.h:1505
#: ../include/linux/fs.h:1525 ../include/linux/fs.h:1544
#: ../include/linux/fs.h:1558 ../../../filesystems/api-summary:29:
#: ../fs/inode.c:2652 ../../../filesystems/api-summary:56: ../fs/namei.c:444
#: ../fs/namei.c:561 ../fs/namei.c:4108 ../fs/namei.c:4710 ../fs/namei.c:4952
#: ../fs/namei.c:5090 ../fs/namei.c:5205 ../fs/namei.c:5329 ../fs/namei.c:5488
#: ../../../filesystems/api-summary:74: ../fs/attr.c:142 ../fs/attr.c:309
#: ../fs/attr.c:392 ../../../filesystems/api-summary:89: ../fs/stat.c:67
msgid "idmap of the mount the inode was found from"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1441
#: ../include/linux/fs.h:1456 ../include/linux/fs.h:1493
#: ../include/linux/fs.h:1508 ../include/linux/fs.h:2306
#: ../../../filesystems/api-summary:29: ../fs/inode.c:2654 ../fs/inode.c:2943
#: ../../../filesystems/api-summary:74: ../fs/attr.c:25 ../fs/attr.c:235
msgid "``const struct inode *inode``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1440
#: ../include/linux/fs.h:1492
msgid "inode to map"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:3
#: ../fs/eventpoll.c:387 ../fs/eventpoll.c:405 ../fs/eventpoll.c:1933
#: ../fs/eventpoll.c:2064 ../fs/eventpoll.c:2129
#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1442
#: ../include/linux/fs.h:1459 ../include/linux/fs.h:1494
#: ../include/linux/fs.h:1511 ../include/linux/fs.h:1577
#: ../include/linux/fs.h:2433 ../include/linux/fs.h:3287
#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2215 ../fs/dcache.c:2381
#: ../../../filesystems/api-summary:29: ../fs/inode.c:2319 ../fs/inode.c:2414
#: ../fs/inode.c:2461 ../fs/inode.c:2478 ../fs/inode.c:2948 ../fs/inode.c:2973
#: ../../../filesystems/api-summary:38: ../fs/super.c:727 ../fs/super.c:1252
#: ../fs/super.c:1398 ../fs/super.c:2063 ../../../filesystems/api-summary:56:
#: ../fs/namei.c:3330 ../fs/namei.c:3357 ../fs/namei.c:3385 ../fs/namei.c:3416
#: ../fs/namei.c:3440 ../fs/namei.c:3465 ../fs/namei.c:3491 ../fs/namei.c:3524
#: ../fs/namei.c:3880 ../fs/namei.c:3977 ../fs/namei.c:4005 ../fs/namei.c:6224
#: ../../../filesystems/api-summary:59: ../block/bio.c:509 ../block/bio.c:614
#: ../block/bio.c:1073 ../../../filesystems/api-summary:74: ../fs/attr.c:30
#: ../fs/attr.c:59 ../fs/attr.c:241 ../../../filesystems/api-summary:83:
#: ../fs/libfs.c:1729 ../fs/libfs.c:1819 ../fs/libfs.c:1873 ../fs/libfs.c:1914
#: ../fs/libfs.c:2318 ../../../filesystems/api-summary:86:
#: ../fs/posix_acl.c:769 ../fs/posix_acl.c:1085 ../fs/posix_acl.c:1162
#: ../fs/posix_acl.c:1206 ../../../filesystems/api-summary:95:
#: ../fs/xattr.c:478
msgid "**Return**"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1442
msgid ""
"whe inode's i_uid mapped down according to **idmap**. If the inode's i_uid "
"has no mapping INVALID_VFSUID is returned."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1452
msgid "check whether inode's i_uid needs to be updated"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1455
#: ../include/linux/fs.h:1475 ../include/linux/fs.h:1507
#: ../include/linux/fs.h:1527 ../../../filesystems/api-summary:74:
#: ../fs/attr.c:312
msgid "``const struct iattr *attr``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1454
#: ../include/linux/fs.h:1474 ../include/linux/fs.h:1506
#: ../include/linux/fs.h:1526
msgid "the new attributes of **inode**"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1455
#: ../include/linux/fs.h:1475 ../include/linux/fs.h:1507
#: ../include/linux/fs.h:1527
msgid "the inode to update"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1456
msgid ""
"Check whether the $inode's i_uid field needs to be updated taking idmapped "
"mounts into account if the filesystem supports it."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1460
msgid "true if **inode**'s i_uid field needs to be updated, false if not."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1472
msgid "update **inode**'s i_uid field"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1476
#: ../include/linux/fs.h:1528 ../include/linux/fs.h:1548
#: ../include/linux/fs.h:1562 ../include/linux/fs.h:1708
#: ../include/linux/fs.h:3093 ../include/linux/fs.h:3105
#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1025 ../fs/dcache.c:1062
#: ../fs/dcache.c:2117 ../fs/dcache.c:2141 ../fs/dcache.c:2159
#: ../fs/dcache.c:2781 ../fs/dcache.c:3121 ../../../filesystems/api-summary:29:
#: ../fs/inode.c:221 ../fs/inode.c:411 ../fs/inode.c:431 ../fs/inode.c:448
#: ../fs/inode.c:470 ../fs/inode.c:656 ../fs/inode.c:691 ../fs/inode.c:711
#: ../fs/inode.c:1209 ../fs/inode.c:1281 ../fs/inode.c:1964 ../fs/inode.c:2017
#: ../fs/inode.c:2031 ../fs/inode.c:2094 ../fs/inode.c:2144 ../fs/inode.c:2335
#: ../fs/inode.c:2625 ../fs/inode.c:2697 ../fs/inode.c:2757 ../fs/inode.c:2791
#: ../fs/inode.c:2873 ../../../filesystems/api-summary:32:
#: ../fs/bad_inode.c:204 ../fs/bad_inode.c:231 ../fs/bad_inode.c:245
#: ../../../filesystems/api-summary:44: ../fs/locks.c:1585 ../fs/locks.c:1709
#: ../fs/locks.c:2157 ../fs/locks.c:2794 ../../../filesystems/api-summary:47:
#: ../fs/locks.c:1462 ../fs/locks.c:2133 ../../../filesystems/api-summary:56:
#: ../fs/namei.c:446 ../fs/namei.c:563 ../fs/namei.c:6220
#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:351
#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:820
#: ../fs/fs-writeback.c:2543 ../fs/fs-writeback.c:2921
#: ../fs/fs-writeback.c:2948 ../../../filesystems/api-summary:74:
#: ../fs/attr.c:53 ../fs/attr.c:311 ../../../filesystems/api-summary:83:
#: ../fs/libfs.c:1440 ../fs/libfs.c:1722 ../fs/libfs.c:2016 ../fs/libfs.c:2067
#: ../fs/libfs.c:2147 ../../../filesystems/api-summary:86:
#: ../fs/posix_acl.c:687 ../../../filesystems/api-summary:89: ../fs/stat.c:36
#: ../fs/stat.c:70 ../fs/stat.c:123
msgid "``struct inode *inode``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1476
msgid ""
"Safely update **inode**'s i_uid field translating the vfsuid of any idmapped "
"mount into the filesystem kuid."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1490
msgid "map an inode's i_gid down according to an idmapping"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1494
msgid ""
"the inode's i_gid mapped down according to **idmap**. If the inode's i_gid "
"has no mapping INVALID_VFSGID is returned."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1504
msgid "check whether inode's i_gid needs to be updated"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1508
msgid ""
"Check whether the $inode's i_gid field needs to be updated taking idmapped "
"mounts into account if the filesystem supports it."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1512
msgid "true if **inode**'s i_gid field needs to be updated, false if not."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1524
msgid "update **inode**'s i_gid field"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1528
msgid ""
"Safely update **inode**'s i_gid field translating the vfsgid of any idmapped "
"mount into the filesystem kgid."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1542
msgid "initialize inode's i_uid field with callers fsuid"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1543
#: ../include/linux/fs.h:1557
msgid "inode to initialize"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1545
msgid ""
"Initialize the i_uid field of **inode**. If the inode was found/created via "
"an idmapped mount map the caller's fsuid according to **idmap**."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1556
msgid "initialize inode's i_gid field with callers fsgid"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1559
msgid ""
"Initialize the i_gid field of **inode**. If the inode was found/created via "
"an idmapped mount map the caller's fsgid according to **idmap**."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1570
msgid "check whether caller's fsuid/fsgid is mapped"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1576
#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1288
#: ../../../filesystems/api-summary:29: ../fs/inode.c:224 ../fs/inode.c:891
#: ../fs/inode.c:1166 ../fs/inode.c:1358 ../fs/inode.c:1397 ../fs/inode.c:1442
#: ../fs/inode.c:1539 ../fs/inode.c:1597 ../fs/inode.c:1630 ../fs/inode.c:1669
#: ../fs/inode.c:1702 ../fs/inode.c:1752 ../fs/inode.c:1792
#: ../../../filesystems/api-summary:38: ../fs/super.c:580 ../fs/super.c:609
#: ../fs/super.c:2018 ../fs/super.c:2221 ../../../filesystems/api-summary:68:
#: ../fs/fs-writeback.c:2831 ../fs/fs-writeback.c:2849
#: ../fs/fs-writeback.c:2864 ../fs/fs-writeback.c:2881
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1481 ../fs/libfs.c:1513
#: ../fs/libfs.c:1988
msgid "``struct super_block *sb``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1571
msgid "the superblock we want a mapping in"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1572
msgid "idmap of the relevant mount"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1573
msgid ""
"Check whether the caller's fsuid and fsgid have a valid mapping in the "
"s_user_ns of the superblock **sb**. If the caller is on an idmapped mount "
"map the caller's fsuid and fsgid according to the **idmap** first."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1578
msgid "true if fsuid and fsgid is mapped, false if not."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1702
msgid "set the ctime in the inode"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1703
msgid "inode in which to set the ctime"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1705
msgid "``time64_t sec``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1704
msgid "tv_sec value to set"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1706
msgid "``long nsec``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1705
msgid "tv_nsec value to set"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1706
msgid "Set the ctime in **inode** to { **sec**, **nsec** }"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1725
msgid "check if SB_FREEZE_WRITE is held"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1731
#: ../include/linux/fs.h:1746
msgid "``const struct file *file``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1726
#: ../include/linux/fs.h:1741
msgid "the file we write to"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1727
#: ../include/linux/fs.h:1742
msgid ""
"May be false positive with !CONFIG_LOCKDEP/LOCK_STATE_UNKNOWN. May be false "
"positive with !S_ISREG, because file_start_write() has no effect on !S_ISREG."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1740
msgid "check if SB_FREEZE_WRITE is not held"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1776
msgid "contains all information required for renaming"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1777
msgid "``mnt_idmap``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1778
msgid "idmap of the mount in which the rename is happening."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1778
msgid "``old_parent``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1779
msgid "parent of source"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1779
msgid "``old_dentry``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1780
msgid "source"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1780
msgid "``new_parent``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1781
msgid "parent of destination"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1781
msgid "``new_dentry``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1782
msgid "destination"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1782
msgid "``delegated_inode``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1783
msgid "returns an inode needing a delegation break"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:1784
msgid "rename flags"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2300
msgid "is this inode using multigrain timestamps"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2301
msgid "inode to test for multigrain timestamps"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2302
msgid "Return true if the inode uses multigrain timestamps, false otherwise."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2429
msgid "check whether a mount is mapped"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2435
msgid "``const struct vfsmount *mnt``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2430
msgid "the mount to check"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2431
msgid ""
"If **mnt** has an non **nop_mnt_idmap** attached to it then **mnt** is "
"mapped."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2434
msgid "true if mount is mapped, false if not."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2673
msgid "get write access to a superblock for regular file io"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:364
#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:802
#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:191
#: ../fs/debugfs/file.c:241 ../../../filesystems/api-summary:14:
#: ../include/linux/fs.h:2679 ../include/linux/fs.h:2700
#: ../../../filesystems/api-summary:29: ../fs/inode.c:2320 ../fs/inode.c:2410
#: ../fs/inode.c:2459 ../../../filesystems/api-summary:62: ../fs/seq_file.c:48
#: ../fs/seq_file.c:149 ../fs/seq_file.c:307 ../fs/seq_file.c:348
#: ../fs/seq_file.c:494 ../../../filesystems/api-summary:83: ../fs/libfs.c:1546
#: ../fs/libfs.c:1590 ../../../filesystems/api-summary:92: ../fs/sync.c:176
#: ../fs/sync.c:199 ../../../filesystems/api-summary:98: ../fs/namespace.c:537
msgid "``struct file *file``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2674
msgid "the file we want to write to"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2675
msgid ""
"This is a variant of sb_start_write() which is a noop on non-regular file. "
"Should be matched with a call to file_end_write()."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2694
msgid "drop write access to a superblock of a regular file"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2695
msgid "the file we wrote to"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2696
msgid "Should be matched with a call to file_start_write()."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2707
msgid "get write access to a superblock for async file io"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2713
#: ../include/linux/fs.h:2732 ../../../filesystems/api-summary:29:
#: ../fs/inode.c:2476 ../../../filesystems/api-summary:80: ../fs/dax.c:1703
msgid "``struct kiocb *iocb``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2708
msgid "the io context we want to submit the write with"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2709
msgid ""
"This is a variant of sb_start_write() for async io submission. Should be "
"matched with a call to kiocb_end_write()."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2726
msgid "drop write access to a superblock after async file io"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2727
msgid "the io context we sumbitted the write with"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2728
msgid "Should be matched with a call to kiocb_start_write()."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2849
msgid "returns true only if **name** is \".\" or \"..\""
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:662
#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:88
#: ../fs/sysfs/symlink.c:101 ../fs/sysfs/symlink.c:142
#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:340
#: ../fs/debugfs/inode.c:484 ../fs/debugfs/inode.c:522
#: ../fs/debugfs/inode.c:553 ../fs/debugfs/inode.c:605
#: ../fs/debugfs/inode.c:647 ../fs/debugfs/inode.c:793
#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:599
#: ../fs/debugfs/file.c:635 ../fs/debugfs/file.c:671 ../fs/debugfs/file.c:708
#: ../fs/debugfs/file.c:746 ../fs/debugfs/file.c:796 ../fs/debugfs/file.c:814
#: ../fs/debugfs/file.c:832 ../fs/debugfs/file.c:850 ../fs/debugfs/file.c:884
#: ../fs/debugfs/file.c:919 ../fs/debugfs/file.c:1001 ../fs/debugfs/file.c:1129
#: ../fs/debugfs/file.c:1190 ../fs/debugfs/file.c:1286
#: ../fs/debugfs/file.c:1365 ../fs/debugfs/file.c:1408
#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2855
#: ../include/linux/fs.h:2866 ../../../filesystems/api-summary:56:
#: ../fs/namei.c:3027 ../../../filesystems/api-summary:71:
#: ../fs/anon_inodes.c:191 ../fs/anon_inodes.c:215 ../fs/anon_inodes.c:247
#: ../fs/anon_inodes.c:294 ../../../filesystems/api-summary:83:
#: ../fs/libfs.c:2315 ../../../filesystems/api-summary:95: ../fs/xattr.c:268
#: ../fs/xattr.c:530 ../fs/xattr.c:1165
msgid "``const char *name``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2850
msgid "file name to check"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2852
#: ../../../filesystems/api-summary:59: ../block/bio.c:1067 ../block/bio.c:1404
#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:366
#: ../fs/seq_file.c:820
msgid "``size_t len``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2851
msgid "length of file name, in bytes"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2860
msgid "check if a file name contains \"..\" path components"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:2861
msgid ""
"File path string to check Search for \"..\" surrounded by either '/' or "
"start/end of string."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3087
msgid "signal start of a direct I/O requests"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3088
#: ../include/linux/fs.h:3100
msgid "inode the direct I/O happens on"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3089
#: ../include/linux/fs.h:3101
msgid ""
"This is called once we've finished processing a direct I/O request, and is "
"used to wake up callers waiting for direct I/O to be quiesced."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3099
msgid "signal finish of a direct I/O requests"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3279
msgid "Check if a given name is suitable for a directory"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3285
#: ../../../filesystems/api-summary:56: ../fs/namei.c:4954 ../fs/namei.c:5092
#: ../fs/namei.c:5207 ../fs/namei.c:5331 ../fs/namei.c:5490 ../fs/namei.c:5584
msgid "``struct inode *dir``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3289
msgid "inode of the directory where the new file will be created"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3291
#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1812 ../fs/dcache.c:2214
#: ../fs/dcache.c:2380 ../../../filesystems/api-summary:83: ../fs/libfs.c:1818
#: ../fs/libfs.c:1907
msgid "``const struct qstr *name``"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3290
msgid "name of the new file"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3280
msgid ""
"This functions checks if the proposed filename is valid for the parent "
"directory. That means that only valid UTF-8 filenames will be accepted for "
"casefold directories from filesystems created with the strict encoding "
"flag.  That also means that any name will be accepted for directories that "
"doesn't have casefold enabled, or aren't being strict with the encoding."
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3292
msgid ""
"True: if the filename is suitable for this directory. It can be true if a "
"given name is not suitable for a strict encoding directory, but the "
"directory being used isn't strict"
msgstr ""

#: ../../../filesystems/api-summary:14: ../include/linux/fs.h:3295
msgid ""
"False if the filename isn't suitable for this directory. This only happens "
"when a directory is casefolded and the filesystem is strict about its "
"encoding."
msgstr ""

#: ../../../filesystems/api-summary.rst:18
msgid "The Directory Cache"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:583
msgid "drop a dentry"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:769
#: ../fs/debugfs/inode.c:815 ../../../filesystems/api-summary:146:
#: ../fs/debugfs/file.c:152 ../fs/debugfs/file.c:173
#: ../../../filesystems/api-summary:20: ../fs/dcache.c:589 ../fs/dcache.c:1114
#: ../fs/dcache.c:1696 ../fs/dcache.c:2162 ../fs/dcache.c:3118
#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:321
#: ../include/linux/dcache.h:338 ../include/linux/dcache.h:573
#: ../../../filesystems/api-summary:56: ../fs/namei.c:3029 ../fs/namei.c:4110
#: ../fs/namei.c:4922 ../fs/namei.c:4955 ../fs/namei.c:5093 ../fs/namei.c:5208
#: ../fs/namei.c:5332 ../fs/namei.c:5491 ../fs/namei.c:6122 ../fs/namei.c:6166
#: ../fs/namei.c:6223 ../../../filesystems/api-summary:74: ../fs/attr.c:144
#: ../fs/attr.c:394 ../../../filesystems/api-summary:83: ../fs/libfs.c:904
#: ../fs/libfs.c:1725 ../../../filesystems/api-summary:86:
#: ../fs/posix_acl.c:595 ../fs/posix_acl.c:1080 ../fs/posix_acl.c:1158
#: ../fs/posix_acl.c:1203 ../../../filesystems/api-summary:95:
#: ../fs/xattr.c:267 ../fs/xattr.c:467 ../fs/xattr.c:529 ../fs/xattr.c:1136
msgid "``struct dentry *dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:584
msgid "dentry to drop"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:585
msgid ""
"d_drop() unhashes the entry from the parent dentry hashes, so that it won't "
"be found through a VFS lookup any more. Note that this is different from "
"deleting the dentry - d_delete will try to mark the dentry negative if "
"possible, giving a successful _negative_ lookup, while d_drop will just make "
"the cache lookup fail."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:591
msgid ""
"d_drop() is used mainly for stuff that wants to invalidate a dentry for some "
"reason (NFS timeouts or autofs deletes)."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:594
msgid "__d_drop requires dentry->d_lock"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:596
msgid ""
"___d_drop doesn't mark dentry as \"unhashed\" (dentry->d_hash.pprev will be "
"LIST_POISON2, not NULL)."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1019
msgid "find any alias for a given inode"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1020
msgid "inode to find an alias for"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1021
msgid ""
"If any aliases exist for the given inode, take and return a reference for "
"one of them.  If no aliases exist, return ``NULL``."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1056
msgid "grab a hashed alias of inode"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1057
msgid "inode in question"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1058
msgid ""
"If inode has a hashed alias, or is a directory and has any alias, acquire "
"the reference to alias and return it. Otherwise return NULL. Notice that if "
"inode is a directory there can be only one alias and it can be unhashed only "
"if it has no children, or if it is the root of a filesystem, or if the "
"directory was renamed and d_revalidate was the first vfs operation to notice."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1065
msgid ""
"If the inode has an IS_ROOT, DCACHE_DISCONNECTED alias, then prefer any "
"other hashed alias over that one."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1108
msgid "move unreferenced dentries to shrink list"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1109
msgid "dentry in question"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1111
msgid "``struct list_head *dispose``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1110
msgid "head of shrink list"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1111
msgid "If dentry has no external references, move it to shrink list."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1113
msgid ""
"NOTE!!! The caller is responsible for preventing eviction of the dentry by "
"holding dentry->d_inode->i_lock or equivalent."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1282
msgid "shrink dcache for a superblock"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1283
#: ../../../filesystems/api-summary:29: ../fs/inode.c:1161 ../fs/inode.c:1534
msgid "superblock"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1284
msgid ""
"Shrink the dcache for the specified super block. This is used to free the "
"dcache before unmounting a file system."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1443
msgid "check for mounts over a dentry in the current namespace."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1449
msgid "``const struct path *parent``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1445
msgid "path to check."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1446
msgid ""
"Return true if the parent or its subdirectories contain a mount point in the "
"current namespace."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1690
msgid "detach submounts, prune dcache, and drop"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1691
msgid "dentry to invalidate (aka detach, prune and drop)"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1809
msgid "allocate a dcache entry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1815
msgid "``struct dentry * parent``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1810
msgid "parent of entry to allocate"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1811
msgid "qstr of the name"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1812
msgid ""
"Allocates a dentry. It returns ``NULL`` if there is insufficient memory "
"available. On a success the dentry is returned. The name passed in is copied "
"and the copy passed in may be reused after this call."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1991
msgid "fill in inode information for a dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1997 ../fs/dcache.c:2784
msgid "``struct dentry *entry``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1992
msgid "dentry to complete"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1994
msgid "``struct inode * inode``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1993
msgid "inode to attach to this dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1994
msgid "Fill in inode information in the entry."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1996
msgid "This turns negative dentries into productive full members of society."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:1999
msgid ""
"NOTE! This assumes that the inode count has been incremented (or otherwise "
"set) by the caller to indicate that it is now in use by the dcache."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2111
msgid "find or allocate a DISCONNECTED dentry for a given inode"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2112 ../fs/dcache.c:2136
msgid "inode to allocate the dentry for"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2113
msgid ""
"Obtain a dentry for an inode resulting from NFS filehandle conversion or "
"similar open by handle operations.  The returned dentry may be anonymous, or "
"may have a full name (if the inode was already in the cache)."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2117
msgid ""
"When called on a directory inode, we must ensure that the inode only ever "
"has one dentry.  If a dentry is found, that is returned instead of "
"allocating a new one."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2121
msgid ""
"On successful return, the reference to the inode has been transferred to the "
"dentry.  In case of an error the reference on the inode is released. To make "
"it easier to use in export operations a ``NULL`` or IS_ERR inode may be "
"passed in and the error will be propagated to the return value, with a "
"``NULL`` **inode** replaced by ERR_PTR(-ESTALE)."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2135
msgid "find or allocate a dentry for a given inode"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2137
msgid "Obtain an IS_ROOT dentry for the root of a filesystem."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2139
msgid ""
"We must ensure that directory inodes only ever have one dentry.  If a dentry "
"is found, that is returned instead of allocating a new one."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2142
msgid ""
"On successful return, the reference to the inode has been transferred to the "
"dentry.  In case of an error the reference on the inode is released.  A "
"``NULL`` or IS_ERR inode may be passed in and will be the error will be "
"propagate to the return value, with a ``NULL`` **inode** replaced by "
"ERR_PTR(-ESTALE)."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2156
msgid "lookup or allocate new dentry with case-exact name"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2157 ../fs/dcache.c:2211
msgid "the negative dentry that was passed to the parent's lookup func"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2158
msgid "the inode case-insensitive lookup has found"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2160
#: ../../../filesystems/api-summary:56: ../fs/namei.c:3092 ../fs/namei.c:3119
#: ../fs/namei.c:3142 ../fs/namei.c:3169 ../fs/namei.c:3197 ../fs/namei.c:3238
#: ../fs/namei.c:3272 ../fs/namei.c:3322 ../fs/namei.c:3349 ../fs/namei.c:3376
#: ../fs/namei.c:3405 ../fs/namei.c:3435 ../fs/namei.c:3458
msgid "``struct qstr *name``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2159 ../fs/dcache.c:2213
msgid "the case-exact name to be associated with the returned dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2160
msgid ""
"This is to avoid filling the dcache with case-insensitive names to the same "
"inode, only the actual correct case is stored in the dcache for case-"
"insensitive filesystems."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2164
msgid ""
"For a case-insensitive lookup match and if the case-exact dentry already "
"exists in the dcache, use it and return it."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2167
msgid ""
"If no entry exists with the exact case name, allocate new dentry with the "
"exact case, and return the spliced entry."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2210
msgid "compare dentry name with case-exact name"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2216
#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:365
#: ../include/linux/dcache.h:487 ../include/linux/dcache.h:507
#: ../include/linux/dcache.h:532 ../include/linux/dcache.h:544
#: ../include/linux/dcache.h:591 ../../../filesystems/api-summary:83:
#: ../fs/libfs.c:1819 ../fs/libfs.c:1875
msgid "``const struct dentry *dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2213 ../fs/dcache.c:2383
msgid "``const struct dentry *parent``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2212 ../fs/dcache.c:2378
msgid "parent dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2215
msgid "true if names are same, or false"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2377
msgid "search for a dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2379
msgid "qstr of name we wish to find"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2380
msgid "dentry, or NULL"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2381
msgid ""
"d_lookup searches the children of the parent dentry for the name in "
"question. If the dentry is found its reference count is incremented and the "
"dentry is returned. The caller must use dput to free the entry when it has "
"finished using it. ``NULL`` is returned if the dentry does not exist."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2510
msgid "delete a dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2516
msgid "``struct dentry * dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2511
msgid "The dentry to delete"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2512
msgid ""
"Turn the dentry into a negative dentry if possible, otherwise remove it from "
"the hash queues so it can be deleted later"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2549
msgid "add an entry back to the hash"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2555
msgid "``struct dentry * entry``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2550
msgid "dentry to add to the hash"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2551
msgid "Adds a dentry to the hash according to its name."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2778
msgid "add dentry to hash queues"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2779
msgid "dentry to add"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2780
msgid "The inode to attach to this dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:2781
msgid ""
"This adds the entry to the hash queues and initializes **inode**. The entry "
"was actually filled in earlier during d_alloc()."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3115
msgid "splice a disconnected dentry into the tree if one exists"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3116
msgid "the inode which may have a disconnected dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3117
msgid "a negative dentry which we want to point to the inode."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3118
msgid ""
"If inode is a directory and has an IS_ROOT alias, then d_move that in place "
"of the given dentry and return it, else simply d_add the inode to the dentry "
"and return NULL."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3122
msgid ""
"If a non-IS_ROOT directory is found, the filesystem is corrupt, and we "
"should error out: directories can't have multiple aliases."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3125
msgid ""
"This is needed in the lookup routine of any filesystem that is exportable "
"(via knfsd) so that we can build dcache paths to directories effectively."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3128
msgid ""
"If a dentry was found and moved, then it is returned.  Otherwise NULL is "
"returned.  This matches the expected return value of ->lookup."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3131
msgid ""
"Cluster filesystems may call this function with a negative, hashed dentry. "
"In that case, we know that the inode will be a regular file, and also this "
"will only occur during atomic_open. So we need to check for the dentry being "
"already hashed only in the final case."
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3150
msgid "is new dentry a subdirectory of old_dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3156
#: ../../../filesystems/api-summary:56: ../fs/namei.c:3997 ../fs/namei.c:5585
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:829
msgid "``struct dentry *new_dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3151
msgid "new dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3153
#: ../../../filesystems/api-summary:56: ../fs/namei.c:3963 ../fs/namei.c:3996
#: ../fs/namei.c:5586 ../../../filesystems/api-summary:83: ../fs/libfs.c:827
msgid "``struct dentry *old_dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3152
msgid "old dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: ../fs/dcache.c:3153
msgid ""
"Returns true if new_dentry is a subdirectory of the parent (at any depth). "
"Returns false otherwise. Caller must ensure that \"new_dentry\" is pinned "
"before calling is_subdir()"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:315
#: ../include/linux/dcache.h:332
msgid "get a reference to a dentry"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:316
#: ../include/linux/dcache.h:333
msgid "dentry to get a reference to"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:317
msgid ""
"Given a live dentry, increment the reference count and return the dentry. "
"Caller must hold **dentry->d_lock**.  Making sure that dentry is alive is "
"caller's resonsibility.  There are many conditions sufficient to guarantee "
"that; e.g. anything with non-negative refcount is alive, so's anything "
"hashed, anything positive, anyone's parent, etc."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:334
msgid ""
"Given a dentry or ``NULL`` pointer increment the reference count if "
"appropriate and return the dentry.  A dentry will not be destroyed when it "
"has references.  Conversely, a dentry with no references can disappear for "
"any number of reasons, starting with memory pressure.  In other words, that "
"primitive is used to clone an existing reference; using it on something with "
"zero refcount is a bug."
msgstr ""

#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3470
#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:564
#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:342
msgid "**NOTE**"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:343
msgid ""
"it will spin if **dentry->d_lock** is held.  From the deadlock avoidance "
"point of view it is equivalent to spin_lock()/increment refcount/"
"spin_unlock(), so calling it under **dentry->d_lock** is always a bug; so's "
"calling it under ->d_lock on any of its descendents."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:359
msgid "is dentry hashed"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:360
msgid "entry to check"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:361
msgid "Returns true if the dentry passed is not currently hashed."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:481
msgid "Determine if a dentry is really negative (ignoring fallthroughs)"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:482
#: ../include/linux/dcache.h:502
msgid "The dentry in question"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:483
msgid ""
"Returns true if the dentry represents either an absent name or a name that "
"doesn't map to an inode (ie. ->d_inode is NULL).  The dentry could represent "
"a true miss, a whiteout that isn't represented by a 0,0 chardev or a "
"fallthrough marker in an opaque directory."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:488
msgid ""
"Note!  (1) This should be used *only* by a filesystem to examine its own "
"dentries.  It should not be used to look at some other filesystem's "
"dentries.  (2) It should also be used in combination with d_inode() to get "
"the inode.  (3) The dentry may have something attached to ->d_lower and the "
"type field of the flags may be set to something other than miss or whiteout."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:501
msgid "Determine if a dentry is really positive (ignoring fallthroughs)"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:503
msgid ""
"Returns true if the dentry represents a name that maps to an inode (ie. -"
">d_inode is not NULL).  The dentry might still represent a whiteout if that "
"is represented on medium as a 0,0 chardev."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:507
msgid ""
"Note!  (1) This should be used *only* by a filesystem to examine its own "
"dentries.  It should not be used to look at some other filesystem's "
"dentries.  (2) It should also be used in combination with d_inode() to get "
"the inode."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:526
msgid "Get the actual inode of this dentry"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:527
#: ../include/linux/dcache.h:539 ../include/linux/dcache.h:586
msgid "The dentry to query"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:528
#: ../include/linux/dcache.h:540
msgid ""
"This is the helper normal filesystems should use to get at their own inodes "
"in their own dentries and ignore the layering superimposed upon them."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:538
msgid "Get the actual inode of this dentry with READ_ONCE()"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:550
msgid "Get upper or lower inode we should be using"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:556
msgid "``const struct dentry *upper``"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:551
msgid "The upper layer"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:552
msgid ""
"This is the helper that should be used to get at the inode that will be used "
"if this dentry were to be opened as a file.  The inode may be on the upper "
"dentry or it may be on a lower dentry pinned by the upper."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:556
msgid "Normal filesystems should not use this to access their own inodes."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:567
msgid "Return the real dentry"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:568
msgid "the dentry to query"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:570
msgid "``enum d_real_type type``"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:569
msgid "the type of real dentry (data or metadata)"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:570
msgid ""
"If dentry is on a union/overlay, then return the underlying, real dentry. "
"Otherwise return the dentry itself."
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:573
msgid "See also: Documentation/filesystems/vfs.rst"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:585
msgid "Return the real inode hosting the data"
msgstr ""

#: ../../../filesystems/api-summary:23: ../include/linux/dcache.h:587
msgid ""
"If dentry is on a union/overlay, then return the underlying, real inode. "
"Otherwise return d_inode()."
msgstr ""

#: ../../../filesystems/api-summary.rst:27
msgid "Inode Handling"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:218
msgid "perform inode structure initialisation"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:219
msgid "superblock inode belongs to"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:220
msgid "inode to initialise"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:222
#: ../../../filesystems/api-summary:59: ../block/bio.c:861 ../block/bio.c:893
#: ../block/bio.c:1684
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:221
msgid "allocation flags"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:222
msgid ""
"These are initializations that need to be done on every inode allocation as "
"the fields are not initialised by slab allocation. If there are additional "
"allocations required **gfp** is used."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:405
msgid "directly drop an inode's link count"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:406 ../fs/inode.c:426
#: ../fs/inode.c:443 ../fs/inode.c:465 ../fs/inode.c:2786
msgid "inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:407
msgid ""
"This is a low-level filesystem helper to replace any direct filesystem "
"manipulation of i_nlink.  In cases where we are attempting to track writes "
"to the filesystem, a decrement to zero means an imminent write when the file "
"is truncated and actually unlinked on the filesystem."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:425
msgid "directly zero an inode's link count"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:427
msgid ""
"This is a low-level filesystem helper to replace any direct filesystem "
"manipulation of i_nlink.  See drop_nlink() for why we care about i_nlink "
"hitting zero."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:442
msgid "directly set an inode's link count"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:445
msgid "``unsigned int nlink``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:444
msgid "new nlink (should be non-zero)"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:445
msgid ""
"This is a low-level filesystem helper to replace any direct filesystem "
"manipulation of i_nlink."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:464
msgid "directly increment an inode's link count"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:466
msgid ""
"This is a low-level filesystem helper to replace any direct filesystem "
"manipulation of i_nlink.  Currently, it is only here for parity with "
"dec_nlink()."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:650
msgid "add inode to the superblock list of inodes"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:651
msgid "inode to add"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:685
msgid "hash an inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:686
msgid "unhashed inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:688 ../fs/inode.c:1278
#: ../fs/inode.c:1355 ../fs/inode.c:1394 ../fs/inode.c:1594 ../fs/inode.c:1627
#: ../fs/inode.c:1699 ../fs/inode.c:1749
msgid "``unsigned long hashval``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:687
msgid "unsigned long value used to locate this object in the inode_hashtable."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:689
msgid "Add an inode to the inode hash for this superblock."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:705
msgid "remove an inode from the hash"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:706
msgid "inode to unhash"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:707
msgid "Remove an inode from the superblock."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:885
msgid "evict all evictable inodes for a superblock"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:886
msgid "superblock to operate on"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:887
msgid ""
"Make sure that no inodes with zero refcount are retained.  This is called by "
"superblock shutdown after having SB_ACTIVE flag removed, so any inode "
"reaching zero refcount during or after that call will be immediately evicted."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1160
msgid "obtain an inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1162
msgid ""
"Allocates a new inode for given superblock. The default gfp_mask for "
"allocations related to inode->i_mapping is GFP_HIGHUSER_MOVABLE. If HIGHMEM "
"pages are unsuitable or it is known that pages allocated for the page cache "
"are not reclaimable or migratable, mapping_set_gfp_mask() must be called "
"with suitable flags on the newly created inode's mapping"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1203
msgid "clear the I_NEW state and wake up any waiters"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1204
msgid "new inode to unlock"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1205
msgid ""
"Called when the inode is fully initialised to clear the new state of the "
"inode and wake up anyone waiting for the inode to finish initialisation."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1233
msgid "take two i_mutexes on non-directory objects"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1239 ../fs/inode.c:1263
msgid "``struct inode *inode1``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1238
msgid "first inode to lock"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1240 ../fs/inode.c:1260
msgid "``struct inode *inode2``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1239
msgid "second inode to lock"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1234
msgid ""
"Lock any non-NULL argument. Passed objects must not be directories. Zero, "
"one or two objects may be locked by this function."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1257
msgid "release locks from lock_two_nondirectories()"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1258
msgid "first inode to unlock"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1259
msgid "second inode to unlock"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1275 ../fs/inode.c:1352
#: ../fs/inode.c:1391 ../fs/inode.c:1436
msgid "obtain an inode from a mounted file system"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1276
msgid "pre-allocated inode to use for insert to cache"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1277 ../fs/inode.c:1354
#: ../fs/inode.c:1393
msgid "hash value (usually inode number) to get"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1279 ../fs/inode.c:1356
#: ../fs/inode.c:1395 ../fs/inode.c:1595 ../fs/inode.c:1628 ../fs/inode.c:1750
msgid "``int (*test)(struct inode *, void *)``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1278 ../fs/inode.c:1355
#: ../fs/inode.c:1394 ../fs/inode.c:1594 ../fs/inode.c:1627 ../fs/inode.c:1699
msgid "callback used for comparisons between inodes"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1280 ../fs/inode.c:1357
#: ../fs/inode.c:1396
msgid "``int (*set)(struct inode *, void *)``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1279 ../fs/inode.c:1356
#: ../fs/inode.c:1395
msgid "callback used to initialize a new struct inode"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:485
#: ../fs/debugfs/inode.c:523 ../fs/debugfs/inode.c:606
#: ../../../filesystems/api-summary:29: ../fs/inode.c:1281 ../fs/inode.c:1358
#: ../fs/inode.c:1397 ../fs/inode.c:1596 ../fs/inode.c:1629 ../fs/inode.c:1701
#: ../fs/inode.c:1751 ../../../filesystems/api-summary:38: ../fs/super.c:815
#: ../../../filesystems/api-summary:59: ../block/bio.c:1403
msgid "``void *data``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1280 ../fs/inode.c:1357
#: ../fs/inode.c:1396
msgid "opaque data pointer to pass to **test** and **set**"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1282
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, and if present return it with an increased reference count. This is a "
"variant of iget5_locked() that doesn't allocate an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1286
msgid ""
"If the inode is not present in the cache, insert the pre-allocated inode and "
"return it locked, hashed, and with the I_NEW flag set. The file system gets "
"to fill it in before unlocking it via unlock_new_inode()."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1290 ../fs/inode.c:1367
msgid ""
"Note that both **test** and **set** are called with the inode_hash_lock "
"held, so they can't sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1353 ../fs/inode.c:1392
#: ../fs/inode.c:1437
msgid "super block of file system"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1358
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, and if present return it with an increased reference count. This is a "
"generalized version of iget_locked() for file systems where the inode number "
"is not sufficient for unique identification of an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1363
msgid ""
"If the inode is not present in the cache, allocate and insert a new inode "
"and return it locked, hashed, and with the I_NEW flag set. The file system "
"gets to fill it in before unlocking it via unlock_new_inode()."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1397
msgid ""
"This is equivalent to iget5_locked, except the **test** callback must "
"tolerate the inode not being stable, including being mid-teardown."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1439 ../fs/inode.c:1666
#: ../fs/inode.c:1789
msgid "``unsigned long ino``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1438
msgid "inode number to get"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1439
msgid ""
"Search for the inode specified by **ino** in the inode cache and if present "
"return it with an increased reference count. This is for file systems where "
"the inode number is sufficient for unique identification of an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1443
msgid ""
"If the inode is not in cache, allocate a new inode and return it locked, "
"hashed, and with the I_NEW flag set.  The file system gets to fill it in "
"before unlocking it via unlock_new_inode()."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1533
msgid "get a unique inode number"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1536
msgid "``ino_t max_reserved``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1535
msgid "highest reserved inode number"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1536
msgid ""
"Obtain an inode number that is unique on the system for a given superblock. "
"This is used by file systems that have no natural permanent inode numbering "
"system. An inode number is returned that is higher than the reserved limit "
"but unique."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1541
msgid ""
"BUGS: With a large number of inodes live on the file system this function "
"currently becomes quite slow."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1591 ../fs/inode.c:1624
#: ../fs/inode.c:1663
msgid "search for an inode in the inode cache"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1592 ../fs/inode.c:1625
#: ../fs/inode.c:1664 ../fs/inode.c:1697
msgid "super block of file system to search"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1593 ../fs/inode.c:1626
#: ../fs/inode.c:1698
msgid "hash value (usually inode number) to search for"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1595 ../fs/inode.c:1628
msgid "opaque data pointer to pass to **test**"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1597
msgid "``bool *isnew``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1596
msgid ""
"return argument telling whether I_NEW was set when the inode was found in "
"hash (the caller needs to wait for I_NEW to clear)"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1599
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache. If the inode is in the cache, the inode is returned with an "
"incremented reference count."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1603 ../fs/inode.c:1637
#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:54
#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2947
#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1170
msgid "**Note**"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1604
msgid ""
"I_NEW is not waited upon so you have to be very careful what you do with the "
"returned inode.  You probably should be using ilookup5() instead."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1607
msgid ""
"Note2: **test** is called with the inode_hash_lock held, so can't sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1629
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, and if the inode is in the cache, return the inode with an "
"incremented reference count.  Waits on I_NEW before returning the inode. "
"returned with an incremented reference count."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1634
msgid ""
"This is a generalized version of ilookup() for file systems where the inode "
"number is not sufficient for unique identification of an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1638
msgid "**test** is called with the inode_hash_lock held, so can't sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1665
msgid "inode number to search for"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1666
msgid ""
"Search for the inode **ino** in the inode cache, and if the inode is in the "
"cache, the inode is returned with an incremented reference count."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1696 ../fs/inode.c:1746
msgid "find an inode in the inode cache"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1700
msgid "``int (*match)(struct inode *, unsigned long, void *)``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1700
msgid "opaque data pointer to pass to **match**"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1701
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, where the helper function **match** will return 0 if the inode does "
"not match, 1 if the inode does match, and -1 if the search should be "
"stopped.  The **match** function must be responsible for taking the i_lock "
"spin_lock and checking i_state for an inode being freed or being "
"initialized, and incrementing the reference count before returning 1.  It "
"also must not sleep, since it is called with the inode_hash_lock spinlock "
"held."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1710
msgid ""
"This is a even more generalized version of ilookup5() when the function must "
"never block --- find_inode() can block in __wait_on_freeing_inode() --- or "
"when the caller can not increment the reference count because the resulting "
"iput() might cause an inode eviction.  The tradeoff is that the **match** "
"funtion must be very carefully implemented."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1747 ../fs/inode.c:1787
msgid "Super block of file system to search"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1748
msgid "Key to hash"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1749
msgid "Function to test match on an inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1750
msgid "Data for test function"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1751 ../fs/inode.c:1789
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, where the helper function **test** will return 0 if the inode does "
"not match and 1 if it does.  The **test** function must be responsible for "
"taking the i_lock spin_lock and checking i_state for an inode being freed or "
"being initialized."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1757 ../fs/inode.c:1795
msgid ""
"If successful, this will return the inode for which the **test** function "
"returned 1 and NULL otherwise."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1760 ../fs/inode.c:1798
msgid ""
"The **test** function is not permitted to take a ref on any inode presented. "
"It is also not permitted to sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1763 ../fs/inode.c:1801
msgid "The caller must hold the RCU read lock."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1786
msgid "Find an inode in the inode cache"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1788
msgid "The inode number to match"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1958
msgid "put an inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1959 ../fs/inode.c:2012
msgid "inode to put"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1960
msgid ""
"Puts an inode, dropping its usage count. If the inode use count hits zero, "
"the inode is then freed and may also be destroyed."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:1963
msgid "Consequently, iput() can sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2011
msgid "put an inode assuming this is not the last reference"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2025
msgid "find a block number in a file"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2026
msgid "inode owning the block number being requested"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2028
msgid "``sector_t *block``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2027
msgid "pointer containing the block to find"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2028
msgid ""
"Replaces the value in ``*block`` with the block number on the device holding "
"corresponding to the requested block number in the file. That is, asked for "
"block 4 of inode 1 the function will replace the 4 in ``*block``, with disk "
"block relative to the disk start that holds that block of the file."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2034
msgid ""
"Returns -EINVAL in case of error, 0 otherwise. If mapping falls into a hole, "
"returns 0 and ``*block`` is also set to 0."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2088 ../fs/inode.c:2138
msgid "update the timestamps on the inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2089 ../fs/inode.c:2139
msgid "inode to be updated"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2091 ../fs/inode.c:2141
#: ../../../filesystems/api-summary:38: ../fs/super.c:814
#: ../../../filesystems/api-summary:59: ../block/bio.c:1799
#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2541
#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:193
#: ../fs/anon_inodes.c:217 ../fs/anon_inodes.c:250 ../fs/anon_inodes.c:296
#: ../../../filesystems/api-summary:95: ../fs/xattr.c:271
msgid "``int flags``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2090 ../fs/inode.c:2140
msgid "S_* flags that needed to be updated"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2091
msgid ""
"The update_time function is called when an inode's timestamps need to be "
"updated for a read or write operation. This function handles updating the "
"actual timestamps. It's up to the caller to ensure that the inode is marked "
"dirty appropriately."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2096
msgid ""
"In the case where any of S_MTIME, S_CTIME, or S_VERSION need to be updated, "
"attempt to update all three of them. S_ATIME updates can be handled "
"independently of the rest."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2100
msgid "Returns a set of S_* flags indicating which values changed."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2141
msgid ""
"The update_time function is called when an inode's timestamps need to be "
"updated for a read or write operation. In the case where any of S_MTIME, "
"S_CTIME, or S_VERSION need to be updated we attempt to update all three of "
"them. S_ATIME updates can be handled done independently of the rest."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2146
msgid "Returns a S_* mask indicating which fields were updated."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2314
msgid "remove special file privileges (suid, capabilities)"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2315
msgid "file to remove privileges from"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2316
msgid ""
"When file is modified by a write or truncation ensure that special file "
"privileges are removed."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2320 ../fs/inode.c:2415
#: ../fs/inode.c:2461 ../fs/inode.c:2478
msgid "0 on success, negative errno on failure."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2329
msgid "Return FS time (possibly fine-grained)"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2330
msgid "inode."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2331
msgid ""
"Return the current time truncated to the time granularity supported by the "
"fs, as suitable for a ctime/mtime change. If the ctime is flagged as having "
"been QUERIED, get a fine-grained timestamp, but don't update the floor."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2336
msgid ""
"For a multigrain inode, this is effectively an estimate of the timestamp "
"that a file would receive. An actual update must go through "
"inode_set_ctime_current()."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2404
msgid "update mtime and ctime time"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2405
msgid "file accessed"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2406
msgid ""
"Update the mtime and ctime members of an inode and mark the inode for "
"writeback. Note that this function is meant exclusively for usage in the "
"file write path of filesystems, and filesystems may choose to explicitly "
"ignore updates via this function with the _NOCMTIME inode flag, e.g. for "
"network filesystem where these imestamps are handled by the server. This can "
"return an error for file systems who need to allocate space in order to "
"update an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2453 ../fs/inode.c:2470
msgid "handle mandated vfs changes when modifying a file"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2454
msgid "file that was modified"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2455 ../fs/inode.c:2472
msgid ""
"When file has been modified ensure that special file privileges are removed "
"and time settings are updated."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2458 ../fs/inode.c:2475
#: ../../../filesystems/api-summary:38: ../fs/super.c:1249
msgid "**Context**"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2459 ../fs/inode.c:2476
msgid "Caller must hold the file's inode lock."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2471
msgid "iocb that was modified"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2622
msgid "Init uid,gid,mode for new inode according to posix standards"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2623 ../fs/inode.c:2964
msgid "idmap of the mount the inode was created from"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2624
msgid "New inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2626 ../fs/inode.c:2966
msgid "``const struct inode *dir``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2625
msgid "Directory inode"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:430
#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:481
#: ../fs/debugfs/inode.c:519 ../../../filesystems/api-summary:146:
#: ../fs/debugfs/file.c:596 ../fs/debugfs/file.c:632 ../fs/debugfs/file.c:668
#: ../fs/debugfs/file.c:705 ../fs/debugfs/file.c:744 ../fs/debugfs/file.c:793
#: ../fs/debugfs/file.c:811 ../fs/debugfs/file.c:829 ../fs/debugfs/file.c:847
#: ../fs/debugfs/file.c:881 ../fs/debugfs/file.c:917 ../fs/debugfs/file.c:998
#: ../fs/debugfs/file.c:1126 ../fs/debugfs/file.c:1188
#: ../fs/debugfs/file.c:1284 ../fs/debugfs/file.c:1362
#: ../../../filesystems/api-summary:29: ../fs/inode.c:2627 ../fs/inode.c:2967
#: ../../../filesystems/api-summary:56: ../fs/namei.c:4111 ../fs/namei.c:4713
#: ../fs/namei.c:4956 ../fs/namei.c:5094 ../../../filesystems/api-summary:86:
#: ../fs/posix_acl.c:596
msgid "``umode_t mode``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2626
msgid "mode of the new inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2627
msgid ""
"If the inode has been created through an idmapped mount the idmap of the "
"vfsmount must be passed through **idmap**. This function will then take care "
"to map the inode according to **idmap** before checking permissions and "
"initializing i_uid and i_gid. On non-idmapped mounts or if permission "
"checking is to be performed on the raw inode simply pass **nop_mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2651
msgid "check current task permissions to inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2653
msgid "inode being checked"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2654
msgid ""
"Return true if current either has CAP_FOWNER in a namespace with the inode "
"owner uid mapped, or owns the file."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2657
#: ../../../filesystems/api-summary:56: ../fs/namei.c:457 ../fs/namei.c:4114
#: ../fs/namei.c:4960 ../fs/namei.c:5097 ../fs/namei.c:5211 ../fs/namei.c:5345
#: ../fs/namei.c:5495 ../fs/namei.c:5598 ../../../filesystems/api-summary:74:
#: ../fs/attr.c:151 ../fs/attr.c:321 ../fs/attr.c:410
#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:696
msgid ""
"If the inode has been found through an idmapped mount the idmap of the "
"vfsmount must be passed through **idmap**. This function will then take care "
"to map the inode according to **idmap** before checking permissions. On non-"
"idmapped mounts or if permission checking is to be performed on the raw "
"inode simply pass **nop_mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2691
msgid "wait for outstanding DIO requests to finish"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2692
msgid "inode to wait for"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2693
msgid ""
"Waits for all pending direct I/O requests to finish so that we can proceed "
"with a truncate or equivalent operation."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2696
msgid ""
"Must be called under a lock that serializes taking new references to "
"i_dio_count, usually by inode->i_rwsem."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2754
msgid "Truncate timespec to a granularity"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2760
msgid "``struct timespec64 t``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2755
msgid "Timespec"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2756
msgid "inode being updated"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2757
msgid ""
"Truncate a timespec to the granularity supported by the fs containing the "
"inode. Always rounds down. gran must not be 0 nor greater than a second "
"(NSEC_PER_SEC, or 10^9 ns)."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2785
msgid "set the ctime to current_time"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2787
msgid ""
"Set the inode's ctime to the current value for the inode. Returns the "
"current value that was assigned. If this is not a multigrain inode, then we "
"set it to the later of the coarse time and floor value."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2791
msgid ""
"If it is multigrain, then we first see if the coarse-grained timestamp is "
"distinct from what is already there. If so, then use that. Otherwise, get a "
"fine-grained timestamp."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2795
msgid ""
"After that, try to swap the new value into i_ctime_nsec. Accept the "
"resulting ctime, regardless of the outcome of the swap. If it has already "
"been replaced, then that timestamp is later than the earlier unacceptable "
"one, and is thus acceptable."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2867
msgid "try to update the ctime on a delegated inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2868
msgid "inode to update"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2870
msgid "``struct timespec64 update``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2869
msgid "timespec64 to set the ctime"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2870
msgid ""
"Attempt to atomically update the ctime on behalf of a delegation holder."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2872
msgid ""
"The nfs server can call back the holder of a delegation to get updated inode "
"attributes, including the mtime. When updating the mtime, update the ctime "
"to a value at least equal to that."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2876
msgid ""
"This can race with concurrent updates to the inode, in which case the update "
"is skipped."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2879
msgid ""
"Note that this works even when multigrain timestamps are not enabled, so it "
"is used in either case."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2940
msgid "check whether caller is CAP_FSETID privileged"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2941
#: ../../../filesystems/api-summary:74: ../fs/attr.c:23 ../fs/attr.c:51
#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:593
#: ../fs/posix_acl.c:685
msgid "idmap of the mount **inode** was found from"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2942
#: ../../../filesystems/api-summary:74: ../fs/attr.c:24 ../fs/attr.c:52
msgid "inode to check"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2944
msgid "``vfsgid_t vfsgid``"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2943
msgid "the new/current vfsgid of **inode**"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2944
msgid ""
"Check whether **vfsgid** is in the caller's group list or if the caller is "
"privileged with CAP_FSETID over **inode**. This can be used to determine "
"whether the setgid bit can be kept or must be dropped."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2949
msgid "true if the caller is sufficiently privileged, false if not."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2963
msgid "handle the sgid bit for non-directories"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2965
msgid "parent directory inode"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2966
msgid "mode of the file to be created in **dir**"
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2967
msgid ""
"If the **mode** of the new file has both the S_ISGID and S_IXGRP bit raised "
"and **dir** has the S_ISGID bit raised ensure that the caller is either in "
"the group of the parent directory or they have CAP_FSETID in their user "
"namespace and are privileged over the parent directory. In all other cases, "
"strip the S_ISGID bit from **mode**."
msgstr ""

#: ../../../filesystems/api-summary:29: ../fs/inode.c:2974
msgid "the new mode to use for the file"
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:198
msgid "mark an inode bad due to an I/O error"
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:199
msgid "Inode to mark bad"
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:200
msgid ""
"When an inode cannot be read due to a media or remote network failure this "
"function makes the inode \"bad\" and causes I/O operations on it to fail "
"from this point on."
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:225
msgid "is an inode errored"
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:226
msgid "inode to test"
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:227
msgid "Returns true if the inode in question has been marked as bad."
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:239
msgid "Mark an under-construction inode as dead and release it"
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:240
msgid "The inode to discard"
msgstr ""

#: ../../../filesystems/api-summary:32: ../fs/bad_inode.c:241
msgid "Mark an under-construction inode as dead and release it."
msgstr ""

#: ../../../filesystems/api-summary.rst:36
msgid "Registration and Superblocks"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:459 ../fs/super.c:496
msgid "drop an active reference to superblock"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:465 ../fs/super.c:502
msgid "``struct super_block *s``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:460 ../fs/super.c:497
msgid "superblock to deactivate"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:461
msgid ""
"Drops an active reference to superblock, converting it into a temporary one "
"if there is no other active references left.  In that case we tell fs driver "
"to shut it down and drop the temporary reference we had just acquired."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:466
msgid "Caller holds exclusive lock on superblock; that lock is released."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:498
msgid ""
"Variant of deactivate_locked_super(), except that superblock is *not* locked "
"by caller.  If we are going to drop the final active reference, lock will be "
"acquired prior to that."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:574
msgid "prevents superblock from being reused"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:575
msgid "superblock to retire"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:576
msgid ""
"The function marks superblock to be ignored in superblock test, which "
"prevents it from being reused for any new mounts.  If the superblock has a "
"private bdi, it also unregisters it, but doesn't reduce the refcount of the "
"superblock to prevent potential races.  The refcount is reduced by "
"generic_shutdown_super().  The function can not be called concurrently with "
"generic_shutdown_super().  It is safe to call the function multiple times, "
"subsequent calls have no effect."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:584
msgid ""
"The marker will affect the re-use only for block-device-based superblocks.  "
"Other superblocks will still get marked if this function is used, but that "
"will not affect their reusability."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:603
msgid "common helper for ->kill_sb()"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:604
msgid "superblock to kill"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:605
msgid ""
"generic_shutdown_super() does all fs-independent work on superblock "
"shutdown.  Typical ->kill_sb() should pick all fs-specific objects that need "
"destruction out of superblock, call generic_shutdown_super() and release "
"aforementioned objects.  Note: dentries and inodes _are_ taken care of and "
"do not need specific handling."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:611
msgid ""
"Upon calling this function, the filesystem may no longer alter or rearrange "
"the set of dentries belonging to this super_block, nor may it change the "
"attachments of dentries to inodes."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:700
msgid "Find or create a superblock"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:706 ../fs/super.c:1389
#: ../fs/super.c:1660 ../fs/super.c:1712 ../fs/super.c:1739
#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1175
msgid "``struct fs_context *fc``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:701 ../fs/super.c:1384
msgid "Filesystem context."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:703
msgid "``int (*test)(struct super_block *, struct fs_context *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:702
msgid "Comparison callback"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:704
msgid "``int (*set)(struct super_block *, struct fs_context *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:703
msgid "Setup callback"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:704
msgid "Create a new superblock or find an existing one."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:706
msgid ""
"The **test** callback is used to find a matching existing superblock. "
"Whether or not the requested parameters in **fc** are taken into account is "
"specific to the **test** callback that is used. They may even be completely "
"ignored."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:711
msgid "If an extant superblock is matched, it will be returned unless:"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:713
msgid ""
"the namespace the filesystem context **fc** and the extant superblock's "
"namespace differ"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:716
msgid ""
"the filesystem context **fc** has requested that reusing an extant "
"superblock is not allowed"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:719
msgid "In both cases EBUSY will be returned."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:721
msgid ""
"If no match is made, a new superblock will be allocated and basic "
"initialisation will be performed (s_type, s_fs_info and s_id will be set and "
"the **set** callback will be invoked), the superblock will be published and "
"it will be returned in a partially constructed state with SB_BORN and "
"SB_ACTIVE as yet unset."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:728
msgid ""
"On success, an extant or newly created superblock is returned. On failure an "
"error pointer is returned."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:809
msgid "find or create a superblock"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:815 ../fs/super.c:949
msgid "``struct file_system_type *type``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:810
msgid "filesystem type superblock should belong to"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:812
msgid "``int (*test)(struct super_block *,void *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:811
msgid "comparison callback"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:813
msgid "``int (*set)(struct super_block *,void *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:812
msgid "setup callback"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:813
msgid "mount flags"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:814
msgid "argument to each of them"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:943
msgid "call function for superblocks of given type"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:944
msgid "fs type"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:946
msgid "``void (*f)(struct super_block *, void *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:945
msgid "function to call"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:947
#: ../../../filesystems/api-summary:56: ../fs/namei.c:6245
msgid "``void *arg``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:946
msgid "argument to pass to it"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:947
msgid ""
"Scans the superblock list and calls given function, passing it locked "
"superblock and given argument."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1244
msgid "Allocate a block device for filesystems which don't have one."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1250
msgid "``dev_t *p``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1245
msgid "Pointer to a dev_t."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1246
msgid ""
"Filesystems which don't use real block devices can call this function to "
"allocate a virtual block device."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1250
msgid "Any context.  Frequently called while holding sb_lock."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1251
msgid ""
"0 on success, -EMFILE if there are no anonymous bdevs left or -ENOMEM if "
"memory allocation failed."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1383
msgid "Find or create a superblock by device number"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1386
#: ../../../filesystems/api-summary:56: ../fs/namei.c:4957
msgid "``dev_t dev``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1385
msgid "device number"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1386
msgid ""
"Find or create a superblock using the provided device number that will be "
"stored in fc->sget_key."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1389
msgid ""
"If an extant superblock is matched, then that will be returned with an "
"elevated reference count that the caller must transfer or discard."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1392
msgid ""
"If no match is made, a new superblock will be allocated and basic "
"initialisation will be performed (s_type, s_fs_info, s_id, s_dev will be "
"set). The superblock will be published and it will be returned in a "
"partially constructed state with SB_BORN and SB_ACTIVE as yet unset."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1399
msgid ""
"an existing or newly created superblock on success, an error pointer on "
"failure."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1654 ../fs/super.c:1706
msgid "Get a superblock based on a single block device"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1655 ../fs/super.c:1707
msgid "The filesystem context holding the parameters"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1657
msgid "``int (*fill_super)(struct super_block *sb, struct fs_context *fc)``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1656 ../fs/super.c:1708
msgid "Helper to initialise a new superblock"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1658
#: ../../../filesystems/api-summary:44: ../fs/locks.c:1582
#: ../../../filesystems/api-summary:56: ../fs/namei.c:3008 ../fs/namei.c:3028
#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:367
msgid "``unsigned int flags``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1657
msgid "GET_TREE_BDEV_* flags"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1709
msgid "``int (*fill_super)(struct super_block *, struct fs_context *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1733
msgid "Get the mountable root"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1734
msgid "The superblock configuration context."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:1735
msgid ""
"The filesystem is invoked to get or create a superblock which can then later "
"be used for mounting.  The filesystem places a pointer to the root to be "
"used for mounting in **fc->root**."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2012
msgid "lock the filesystem and force it into a consistent state"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2013
msgid "the super to lock"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2015 ../fs/super.c:2218
msgid "``enum freeze_holder who``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2014 ../fs/super.c:2217
msgid "context that wants to freeze"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2016 ../fs/super.c:2219
msgid "``const void *freeze_owner``"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2015 ../fs/super.c:2218
msgid "owner of the freeze"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2016
msgid ""
"Syncs the super to make sure the filesystem is consistent and calls the fs's "
"freeze_fs.  Subsequent calls to this without first thawing the fs may return "
"-EBUSY."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2020
msgid ""
"**who** should be: * ``FREEZE_HOLDER_USERSPACE`` if userspace wants to "
"freeze the fs; * ``FREEZE_HOLDER_KERNEL`` if the kernel wants to freeze the "
"fs. * ``FREEZE_MAY_NEST`` whether nesting freeze and thaw requests is "
"allowed."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2025
msgid ""
"The **who** argument distinguishes between the kernel and userspace trying "
"to freeze the filesystem.  Although there cannot be multiple kernel freezes "
"or multiple userspace freezes in effect at any given time, the kernel and "
"userspace can both hold a filesystem frozen.  The filesystem remains frozen "
"until there are no kernel or userspace freezes in effect."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2031
msgid ""
"A filesystem may hold multiple devices and thus a filesystems may be frozen "
"through the block layer via multiple block devices. In this case the request "
"is marked as being allowed to nest by passing FREEZE_MAY_NEST. The "
"filesystem remains frozen until all block devices are unfrozen. If multiple "
"freezes are attempted without FREEZE_MAY_NEST -EBUSY will be returned."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2038
msgid "During this function, sb->s_writers.frozen goes through these values:"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2040
msgid "SB_UNFROZEN: File system is normal, all writes progress as usual."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2042
msgid ""
"SB_FREEZE_WRITE: The file system is in the process of being frozen.  New "
"writes should be blocked, though page faults are still allowed. We wait for "
"all writes to complete and then proceed to the next stage."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2046
msgid ""
"SB_FREEZE_PAGEFAULT: Freezing continues. Now also page faults are blocked "
"but internal fs threads can still modify the filesystem (although they "
"should not dirty new pages or inodes), writeback can run etc. After waiting "
"for all running page faults we sync the filesystem which will clean all "
"dirty pages and inodes (no new dirty pages or inodes can be created when "
"sync is running)."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2053
msgid ""
"SB_FREEZE_FS: The file system is frozen. Now all internal sources of fs "
"modification are blocked (e.g. XFS preallocation truncation on inode "
"reclaim). This is usually implemented by blocking new transactions for "
"filesystems that have them and need this additional guard. After all "
"internal writers are finished we call ->freeze_fs() to finish filesystem "
"freezing. Then we transition to SB_FREEZE_COMPLETE state. This state is "
"mostly auxiliary for filesystems to verify they do not modify frozen fs."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2061
msgid "sb->s_writers.frozen is protected by sb->s_umount."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2064
msgid ""
"If the freeze was successful zero is returned. If the freeze failed a "
"negative error code is returned."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2215
msgid "unlock filesystem"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2216
msgid "the super to thaw"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2219
msgid ""
"Unlocks the filesystem and marks it writeable again after freeze_super() if "
"there are no remaining freezes on the filesystem."
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2222
msgid ""
"**who** should be: * ``FREEZE_HOLDER_USERSPACE`` if userspace wants to thaw "
"the fs; * ``FREEZE_HOLDER_KERNEL`` if the kernel wants to thaw the fs. * "
"``FREEZE_MAY_NEST`` whether nesting freeze and thaw requests is allowed"
msgstr ""

#: ../../../filesystems/api-summary:38: ../fs/super.c:2227
msgid ""
"A filesystem may hold multiple devices and thus a filesystems may have been "
"frozen through the block layer via multiple block devices. The filesystem "
"remains frozen until all block devices are unfrozen."
msgstr ""

#: ../../../filesystems/api-summary.rst:42
msgid "File Locks"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:323
msgid "Check for blocking lock requests"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:329
msgid "``struct file_lock_context *flctx``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:324
msgid "file lock context"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:326
msgid "``fl_owner_t owner``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:325
msgid "lock owner"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:326
msgid "Return values:"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:327
msgid ""
"``true``: **owner** has at least one blocker ``false``: **owner** has no "
"blockers"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:820
msgid "stop waiting for a file lock"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:826
msgid "``struct file_lock *waiter``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:821
msgid "the lock which was waiting"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:822
msgid "lockd/nfsd need to disconnect the lock while working on it."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1435
#: ../../../filesystems/api-summary:47: ../fs/locks.c:1456
msgid "Apply a POSIX-style lock to a file"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1441 ../fs/locks.c:1949
#: ../fs/locks.c:2034 ../fs/locks.c:2246 ../fs/locks.c:2383 ../fs/locks.c:2778
#: ../../../filesystems/api-summary:47: ../fs/locks.c:595 ../fs/locks.c:1739
#: ../fs/locks.c:2089 ../fs/locks.c:2109 ../../../filesystems/api-summary:83:
#: ../fs/libfs.c:1707
msgid "``struct file *filp``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1436 ../fs/locks.c:2378
msgid "The file to apply the lock to"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1438 ../fs/locks.c:2154
#: ../fs/locks.c:2243 ../fs/locks.c:2381 ../fs/locks.c:2775
#: ../../../filesystems/api-summary:47: ../fs/locks.c:1459 ../fs/locks.c:2130
msgid "``struct file_lock *fl``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1437 ../fs/locks.c:2153
#: ../fs/locks.c:2380 ../../../filesystems/api-summary:47: ../fs/locks.c:1458
#: ../fs/locks.c:2129
msgid "The lock to be applied"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1439
msgid "``struct file_lock *conflock``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1438 ../fs/locks.c:2381
msgid "Place to return a copy of the conflicting lock, if found."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1439
msgid ""
"Add a POSIX style lock to a file. We merge adjacent & overlapping locks "
"whenever possible. POSIX locks are sorted by owner task, then by starting "
"address"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1443
msgid ""
"Note that if called with an FL_EXISTS argument, the caller may determine "
"whether or not a lock was successfully freed by testing the return value for "
"-ENOENT."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1579
msgid "revoke all outstanding leases on file"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1580
msgid "the inode of the file to return"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1581
msgid "LEASE_BREAK_* flags"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1582
msgid ""
"break_lease (inlined for speed) has checked there already is at least some "
"kind of lock (maybe a lease) on this file.  Leases are broken on a call to "
"open() or truncate().  This function can block waiting for the lease break "
"unless you specify LEASE_BREAK_NONBLOCK."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1703
msgid "update modified time of an inode with exclusive lease"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1704
msgid "the inode"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1706
msgid "``struct timespec64 *time``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1705
msgid "pointer to a timespec which contains the last modified time"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1706
msgid ""
"This is to force NFS clients to flush their caches for files with exclusive "
"leases.  The justification is that if someone has an exclusive lease, then "
"they could be modifying it."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1943 ../fs/locks.c:2028
#: ../../../filesystems/api-summary:47: ../fs/locks.c:2086
msgid "sets a lease on an open file"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1944 ../fs/locks.c:2029
#: ../../../filesystems/api-summary:47: ../fs/locks.c:2088 ../fs/locks.c:2108
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1702
msgid "file pointer"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1946 ../fs/locks.c:2031
#: ../../../filesystems/api-summary:47: ../fs/locks.c:2090
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1704
msgid "``int arg``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1945 ../fs/locks.c:2030
#: ../../../filesystems/api-summary:47: ../fs/locks.c:2089
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1703
msgid "type of lease to obtain"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1947
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1705
msgid "``struct file_lease **flp``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1946
msgid "input - file_lock to use, output - file_lock inserted"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1948 ../fs/locks.c:2033
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1706
msgid "``void **priv``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1947
msgid "private data for lm_setup (may be NULL if lm_setup doesn't require it)"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:1949
msgid ""
"The (input) flp->fl_lmops->lm_break function is required by break_lease()."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2032
msgid "``struct file_lease **lease``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2031
msgid "file_lock to use when adding a lease"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2032
msgid ""
"private info for lm_setup when adding a lease (may be NULL if lm_setup "
"doesn't require it)"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2034
msgid ""
"Call this to establish a lease on the file. The \"lease\" argument is not "
"used for F_UNLCK requests and may be NULL. For commands that set or alter an "
"existing lease, the ``(*lease)->fl_lmops->lm_break`` operation must be set; "
"if not, this function will return -ENOLCK (and generate a scary-looking "
"stack trace)."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2040
msgid ""
"The \"priv\" pointer is passed directly to the lm_setup function as-is. It "
"may be NULL if the lm_setup operation doesn't require it."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2151
msgid "Apply a lock to an inode"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2152
#: ../../../filesystems/api-summary:47: ../fs/locks.c:2128
msgid "inode of the file to apply to"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2154
msgid "Apply a POSIX or FLOCK style lock request to an inode."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2240
msgid "test file byte range lock"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2241
msgid "The file to test lock for"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2242
msgid "The byte-range in the file to test; also used to hold result"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2243
msgid ""
"On entry, **fl** does not contain a lock, but identifies a range (fl_start, "
"fl_end) in the file (c.flc_file), and an owner (c.flc_owner) for whom "
"existing locks should be ignored.  c.flc_type and c.flc_flags are ignored. "
"Both fl_lmops and fl_ops in **fl** must be NULL. Returns -ERRNO on failure.  "
"Indicates presence of conflicting lock by setting fl->fl_type to something "
"other than F_UNLCK."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2250
msgid ""
"If vfs_test_lock() does find a lock and return it, the caller must use "
"locks_free_lock() or locks_release_private() on the returned lock."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2377
msgid "file byte range lock"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2380
#: ../../../filesystems/api-summary:47: ../fs/locks.c:2178
msgid "``unsigned int cmd``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2379
msgid "type of locking operation (F_SETLK, F_GETLK, etc.)"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2382
msgid "``struct file_lock *conf``"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2382
msgid ""
"A caller that doesn't care about the conflicting lock may pass NULL as the "
"final argument."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2385
msgid ""
"If the filesystem defines a private ->lock() method, then **conf** will be "
"left unchanged; so a caller that cares should initialize it to some "
"acceptable default."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2389
msgid ""
"To avoid blocking kernel daemons, such as lockd, that need to acquire POSIX "
"locks, the ->lock() interface may return asynchronously, before the lock has "
"been granted or denied by the underlying filesystem, if (and only if) "
"lm_grant is set. Additionally FOP_ASYNC_LOCK in file_operations fop_flags "
"need to be set."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2395
msgid ""
"Callers expecting ->lock() to return asynchronously will only use F_SETLK, "
"not F_SETLKW; they will set FL_SLEEP if (and only if) the request is for a "
"blocking lock. When ->lock() does return asynchronously, it must return "
"FILE_LOCK_DEFERRED, and call ->lm_grant() when the lock request completes. "
"If the request is for non-blocking lock the file system should return "
"FILE_LOCK_DEFERRED then try to get the lock and call the callback routine "
"with the result. If the request timed out the callback routine will return a "
"nonzero return code and the file system should release the lock. The file "
"system is also responsible to keep a corresponding posix lock when it grants "
"a lock so the VFS can find out which locks are locally held and do the "
"correct lock cleanup when required. The underlying filesystem must not drop "
"the kernel lock or call ->lm_grant() before returning to the caller with a "
"FILE_LOCK_DEFERRED return code."
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2772
msgid "file byte range unblock lock"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2773
msgid "The file to apply the unblock to"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2774
msgid "The lock to be unblocked"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2775
msgid "Used by lock managers to cancel blocked requests"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2788
msgid "are any file locks held on **inode**?"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2789
msgid "inode to check for locks"
msgstr ""

#: ../../../filesystems/api-summary:44: ../fs/locks.c:2790
msgid ""
"Return true if there are any FL_POSIX or FL_FLOCK locks currently set on "
"**inode**."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:589
msgid ""
"see if the given file points to an inode that has an existing open that "
"would conflict with the desired lease."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:592
msgid "file to check"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:594
msgid "``const int arg``"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:593
msgid "type of lease that we're trying to acquire"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:594
msgid ""
"Check to see if there's an existing open fd on this file that would conflict "
"with the lease we're trying to set."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1457
msgid "inode of file to which lock request should be applied"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1459
msgid "Apply a POSIX style lock request to an inode."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1733
msgid "Enquire what lease is currently active"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1734
msgid "the file"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1736
msgid "``unsigned int flavor``"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1735
msgid "type of lease flags to check"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1736
msgid ""
"The value returned by this function will be one of (if no lease break is "
"pending):"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1739
msgid "``F_RDLCK`` to indicate a shared lease is held."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1741
msgid "``F_WRLCK`` to indicate an exclusive lease is held."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1743
msgid "``F_UNLCK`` to indicate no lease is held."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1745
msgid "(if a lease break is pending):"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1747
msgid "``F_RDLCK`` to indicate an exclusive lease needs to be"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1748
msgid "changed to a shared lease (or removed)."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1750
msgid "``F_UNLCK`` to indicate the lease needs to be removed."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:1752
msgid ""
"XXX: sfr & willy disagree over whether F_INPROGRESS should be returned to "
"userspace."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2092 ../fs/locks.c:2112
#: ../fs/locks.c:2181
msgid "``unsigned int fd``"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2087 ../fs/locks.c:2107
msgid "open file descriptor"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2090
msgid ""
"Call this fcntl to establish a lease on the file. Note that you also need to "
"call ``F_SETSIG`` to receive a signal when the lease is broken."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2106
msgid "sets a delegation on an open file"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2110
msgid "``struct delegation *deleg``"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2109
msgid "delegation request from userland"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2110
msgid ""
"Call this fcntl to establish a delegation on the file. Note that you also "
"need to call ``F_SETSIG`` to receive a signal when the lease is broken."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2127
msgid "Apply a FLOCK-style lock to a file"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2130
msgid "Apply a FLOCK style lock request to an inode."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2175
msgid "flock() system call."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2176
msgid "the file descriptor to lock."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2177
msgid "the type of lock to apply."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2178
msgid ""
"Apply a ``FL_FLOCK`` style lock to an open file descriptor. The **cmd** can "
"be one of:"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2181
msgid "``LOCK_SH`` -- a shared lock."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2182
msgid "``LOCK_EX`` -- an exclusive lock."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2183
msgid "``LOCK_UN`` -- remove an existing lock."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2184
msgid "``LOCK_MAND`` -- a 'mandatory' flock. (DEPRECATED)"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2186
msgid "``LOCK_MAND`` support has been removed from the kernel."
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2266
msgid "translate a file_lock's fl_pid number into a namespace"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2272
msgid "``struct file_lock_core *fl``"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2267
msgid "The file_lock who's fl_pid should be translated"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2269
msgid "``struct pid_namespace *ns``"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2268
msgid "The namespace into which the pid should be translated"
msgstr ""

#: ../../../filesystems/api-summary:47: ../fs/locks.c:2269
msgid "Used to translate a fl_pid into a namespace virtual pid number"
msgstr ""

#: ../../../filesystems/api-summary.rst:51
msgid "Other Functions"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:321
msgid "start reads against pages"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:327
msgid "``struct readahead_control *rac``"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:322
msgid "Describes which pages to read."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:324 ../fs/mpage.c:653
msgid "``get_block_t get_block``"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:323
msgid "The filesystem's block mapper function."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:324
msgid ""
"This function walks the pages and the blocks within each page, building and "
"emitting large BIOs."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:327
msgid "If anything unusual happens, such as:"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:329
msgid "encountering a page which has buffers"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:330
msgid "encountering a page which has a non-hole after a hole"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:331
msgid "encountering a page with non-contiguous blocks"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:333
msgid ""
"then this code just gives up and calls the buffer_head-based read function. "
"It does handle a page which has holes at the end - that is a common case: "
"the end-of-file on blocksize < PAGE_SIZE setups."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:337
msgid "BH_Boundary explanation:"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:339
msgid ""
"There is a problem.  The mpage read code assembles several pages, gets all "
"their disk mappings, and then submits them all.  That's fine, but obtaining "
"the disk mappings may require I/O.  Reads of indirect blocks, for example."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:343
msgid ""
"So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be "
"submitted in the following order:"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:346
msgid "12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:348
msgid ""
"because the indirect block has to be read to get the mappings of blocks "
"13,14,15,16.  Obviously, this impacts performance."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:351
msgid ""
"So what we do it to allow the filesystem's get_block() function to set "
"BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block "
"after this one will require I/O against a block which is probably close to "
"this one.  So you should push what I/O you have currently accumulated."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:356
msgid "This all causes the disk requests to be issued in the correct order."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:649
msgid ""
"walk the list of dirty pages of the given address space & writepage() all of "
"them"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:655
#: ../../../filesystems/api-summary:80: ../fs/dax.c:743
msgid "``struct address_space *mapping``"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:650
msgid "address space structure to write"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:652
#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:823
#: ../fs/fs-writeback.c:841 ../fs/fs-writeback.c:964
msgid "``struct writeback_control *wbc``"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:651
msgid "subtract the number of written pages from ***wbc->nr_to_write**"
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:652
msgid "the filesystem's block mapper function."
msgstr ""

#: ../../../filesystems/api-summary:53: ../fs/mpage.c:653
msgid ""
"This is a library function, which implements the writepages() "
"address_space_operation."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:443
msgid "check for access rights on a Posix-like filesystem"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:445
msgid "inode to check access rights for"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:447 ../fs/namei.c:564
msgid "``int mask``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:446
msgid ""
"right to check for (``MAY_READ``, ``MAY_WRITE``, ``MAY_EXEC``, "
"``MAY_NOT_BLOCK`` ...)"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:448
msgid ""
"Used to check for read/write/execute permissions on a file. We use \"fsuid\" "
"for this, letting us set arbitrary permissions for filesystem access without "
"changing the \"normal\" uids which are used for other things."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:453
msgid ""
"generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk "
"request cannot be satisfied (eg. requires blocking or too much complexity). "
"It would then be called again in ref-walk mode."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:560
msgid "Check for access rights to a given inode"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:562
msgid "Inode to check permission on"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:563
msgid "Right to check for (``MAY_READ``, ``MAY_WRITE``, ``MAY_EXEC``)"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:564
msgid ""
"Check for read/write/execute permissions on an inode.  We use fs[ug]id for "
"this, letting us set arbitrary permissions for filesystem access without "
"changing the \"normal\" UIDs which are used for other things."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:568
msgid "When checking for MAY_APPEND, MAY_WRITE must also be set in **mask**."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:645
msgid "get a reference to a path"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:651 ../fs/namei.c:664
#: ../fs/namei.c:4925 ../../../filesystems/api-summary:62: ../fs/seq_file.c:465
#: ../../../filesystems/api-summary:77: ../fs/d_path.c:256
#: ../../../filesystems/api-summary:89: ../fs/stat.c:175
#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1453
#: ../fs/namespace.c:2362
msgid "``const struct path *path``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:646
msgid "path to get the reference to"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:647
msgid ""
"Given a path increment the reference count to the dentry and the vfsmount."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:658
msgid "put a reference to a path"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:659
msgid "path to put the reference to"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:660
msgid ""
"Given a path decrement the reference count to the dentry and the vfsmount."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:2888
msgid "signal completion of a dirop"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:2894
msgid "``struct dentry *de``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:2889
msgid "the dentry which was returned by start_dirop or similar."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:2890
msgid ""
"If the de is an error, nothing happens. Otherwise any lock taken to protect "
"the dentry is dropped and the dentry itself is release (dput())."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3005
msgid "lookup a parent path relative to a dentry-vfsmount pair"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3011
msgid "``struct filename *filename``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3006
msgid "filename structure"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3007 ../fs/namei.c:3027
msgid "lookup flags"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3009
msgid "``struct path *parent``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3008 ../fs/namei.c:3028
msgid "pointer to struct path to fill"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3010
msgid "``struct qstr *last``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3009
msgid "last component"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3011
msgid "``int *type``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3010
msgid "type of the last component"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3012
msgid "``const struct path *root``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3011
msgid "pointer to struct path of the base directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3023
msgid "lookup a file path relative to a dentry-vfsmount pair"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3024
msgid "pointer to dentry of the base directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3026
#: ../../../filesystems/api-summary:98: ../fs/namespace.c:558
#: ../fs/namespace.c:574 ../fs/namespace.c:1615 ../fs/namespace.c:3779
msgid "``struct vfsmount *mnt``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3025
msgid "pointer to vfs mount of the base directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3026
msgid "pointer to file name"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3029
msgid "``struct path *path``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3086 ../fs/namei.c:3113
#: ../fs/namei.c:3266
msgid "filesystem helper to lookup single pathname component"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3087 ../fs/namei.c:3114
msgid "qstr storing pathname component to lookup"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3089 ../fs/namei.c:3116
#: ../fs/namei.c:3143 ../fs/namei.c:3170 ../fs/namei.c:3198 ../fs/namei.c:3239
#: ../fs/namei.c:3269
msgid "``struct dentry *base``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3088 ../fs/namei.c:3115
#: ../fs/namei.c:3142 ../fs/namei.c:3169 ../fs/namei.c:3197 ../fs/namei.c:3238
#: ../fs/namei.c:3268
msgid "base directory to lookup from"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3089
msgid ""
"Look up a dentry by name in the dcache, returning NULL if it does not "
"currently exist.  The function does not try to create a dentry and if one is "
"found it doesn't try to revalidate it."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3093 ../fs/namei.c:3116
msgid ""
"Note that this routine is purely a helper for filesystem usage and should "
"not be called by generic code.  It does no permission checking."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3096
msgid "No locks need be held - only a counted reference to **base** is needed."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3119 ../fs/namei.c:3145
msgid "The caller must hold base->i_rwsem."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3139 ../fs/namei.c:3166
#: ../fs/namei.c:3194 ../fs/namei.c:3235
msgid "lookup single pathname component"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3140 ../fs/namei.c:3167
#: ../fs/namei.c:3195 ../fs/namei.c:3236
msgid "idmap of the mount the lookup is performed from"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3141 ../fs/namei.c:3237
msgid "qstr holding pathname component to lookup"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3143 ../fs/namei.c:3170
#: ../fs/namei.c:3205 ../fs/namei.c:3246
msgid "This can be used for in-kernel filesystem clients such as file servers."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3168 ../fs/namei.c:3196
msgid "qstr olding pathname component to lookup"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3172
msgid ""
"Unlike lookup_one, it should be called without the parent i_rwsem held, and "
"will take the i_rwsem itself if necessary."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3198 ../fs/namei.c:3239
msgid ""
"This helper will yield ERR_PTR(-ENOENT) on negatives. The helper returns "
"known positive or ERR_PTR(). This is what most of the users want."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3201 ../fs/namei.c:3242
msgid ""
"Note that pinned negative with unlocked parent _can_ become positive at any "
"time, so callers of lookup_one_unlocked() need to be very careful; pinned "
"positives have >d_inode stable, so this one avoids such problems."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3207
msgid ""
"It should be called without the parent i_rwsem held, and will take the "
"i_rwsem itself if necessary.  If a fatal signal is pending or delivered, it "
"will return ``-EINTR`` if the lock is needed."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3248
msgid "The helper should be called without i_rwsem held."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3267
msgid "pathname component to lookup"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3269
msgid ""
"Note that this routine is purely a helper for filesystem usage and should "
"not be called by generic code. It does no permission checking."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3272
msgid ""
"Unlike lookup_noperm(), it should be called without the parent i_rwsem held, "
"and will take the i_rwsem itself if necessary."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3275
msgid ""
"Unlike try_lookup_noperm() it *does* revalidate the dentry if it already "
"existed."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3318 ../fs/namei.c:3372
msgid "prepare to create a given name with permission checking"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3319 ../fs/namei.c:3346
#: ../fs/namei.c:3373 ../fs/namei.c:3402 ../fs/namei.c:5582
#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1078
#: ../fs/posix_acl.c:1156 ../fs/posix_acl.c:1201
msgid "idmap of the mount"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:337
#: ../fs/debugfs/inode.c:482 ../fs/debugfs/inode.c:520
#: ../fs/debugfs/inode.c:551 ../fs/debugfs/inode.c:602
#: ../fs/debugfs/inode.c:645 ../fs/debugfs/inode.c:790
#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:597
#: ../fs/debugfs/file.c:633 ../fs/debugfs/file.c:669 ../fs/debugfs/file.c:706
#: ../fs/debugfs/file.c:745 ../fs/debugfs/file.c:794 ../fs/debugfs/file.c:812
#: ../fs/debugfs/file.c:830 ../fs/debugfs/file.c:848 ../fs/debugfs/file.c:882
#: ../fs/debugfs/file.c:918 ../fs/debugfs/file.c:999 ../fs/debugfs/file.c:1127
#: ../fs/debugfs/file.c:1189 ../fs/debugfs/file.c:1285
#: ../fs/debugfs/file.c:1363 ../fs/debugfs/file.c:1409
#: ../../../filesystems/api-summary:56: ../fs/namei.c:3321 ../fs/namei.c:3348
#: ../fs/namei.c:3375 ../fs/namei.c:3404 ../fs/namei.c:3438 ../fs/namei.c:3461
#: ../fs/namei.c:3486 ../fs/namei.c:3519 ../../../filesystems/api-summary:83:
#: ../fs/libfs.c:2318
msgid "``struct dentry *parent``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3320 ../fs/namei.c:3374
#: ../fs/namei.c:3433 ../../../filesystems/api-summary:83: ../fs/libfs.c:2313
msgid "directory in which to prepare to create the name"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3321 ../fs/namei.c:3375
#: ../fs/namei.c:3434 ../../../filesystems/api-summary:83: ../fs/libfs.c:2314
msgid "the name to be created"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3322
msgid ""
"Locks are taken and a lookup is performed prior to creating an object in a "
"directory.  Permission checking (MAY_EXEC) is performed against **idmap**."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3326
msgid ""
"If the name already exists, a positive dentry is returned, so behaviour is "
"similar to O_CREAT without O_EXCL, which doesn't fail with -EEXIST."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3331 ../fs/namei.c:3386
#: ../fs/namei.c:3441
msgid "a negative or positive dentry, or an error."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3345 ../fs/namei.c:3401
msgid "prepare to remove a given name with permission checking"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3347 ../fs/namei.c:3403
#: ../fs/namei.c:3456
msgid "directory in which to find the name"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3348 ../fs/namei.c:3404
#: ../fs/namei.c:3457
msgid "the name to be removed"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3349 ../fs/namei.c:3405
msgid ""
"Locks are taken and a lookup in performed prior to removing an object from a "
"directory.  Permission checking (MAY_EXEC) is performed against **idmap**."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3353 ../fs/namei.c:3409
#: ../fs/namei.c:3461
msgid "If the name doesn't exist, an error is returned."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3355 ../fs/namei.c:3411
#: ../fs/namei.c:3463 ../fs/namei.c:3522
msgid "end_removing() should be called when removal is complete, or aborted."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3358 ../fs/namei.c:3417
#: ../fs/namei.c:3466
msgid "a positive dentry, or an error."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3376
msgid ""
"Locks are taken and a lookup in performed prior to creating an object in a "
"directory.  Permission checking (MAY_EXEC) is performed against **idmap**."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3380 ../fs/namei.c:3438
msgid "If the name already exists, a positive dentry is returned."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3382 ../fs/namei.c:3413
msgid ""
"If a signal is received or was already pending, the function aborts with -"
"EINTR;"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3432
msgid "prepare to create a given name without permission checking"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3435
msgid ""
"Locks are taken and a lookup in performed prior to creating an object in a "
"directory."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3455
msgid "prepare to remove a given name without permission checking"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3458
msgid ""
"Locks are taken and a lookup in performed prior to removing an object from a "
"directory."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3480
msgid "prepare to create a given dentry"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3481 ../fs/namei.c:3514
msgid "directory from which dentry should be removed"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3483 ../fs/namei.c:3516
msgid "``struct dentry *child``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3482 ../fs/namei.c:3515
msgid "the dentry to be removed"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3483 ../fs/namei.c:3516
msgid ""
"A lock is taken to protect the dentry again other dirops and the validity of "
"the dentry is checked: correct parent and still hashed."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3486
msgid ""
"If the dentry is valid and negative a reference is taken and returned.  If "
"not an error is returned."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3489
msgid "end_creating() should be called when creation is complete, or aborted."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3492 ../fs/namei.c:3525
msgid "the valid dentry, or an error."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3513
msgid "prepare to remove a given dentry"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3519
msgid ""
"If the dentry is valid and positive, a reference is taken and returned.  If "
"not an error is returned."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3863
msgid "lookup and lock names for rename with permission checking"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3869 ../fs/namei.c:3963
#: ../fs/namei.c:3999 ../fs/namei.c:5769
msgid "``struct renamedata *rd``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3864 ../fs/namei.c:3958
msgid ""
"rename data containing parents and flags, and for receiving found dentries"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3867 ../fs/namei.c:3961
msgid "``int lookup_flags``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3866 ../fs/namei.c:3960
msgid ""
"extra flags to pass to ->lookup (e.g. LOOKUP_REVAL, LOOKUP_NO_SYMLINKS etc)."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3869
msgid "``struct qstr *old_last``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3868
msgid "name of object in **rd.old_parent**"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3870 ../fs/namei.c:3964
msgid "``struct qstr *new_last``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3869
msgid "name of object in **rd.new_parent**"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3870
msgid "Look up two names and ensure locks are in place for rename."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3873
msgid ""
"On success the found dentries are stored in **rd.old_dentry**, **rd."
"new_dentry**.  Also the refcount on **rd->old_parent** is increased. These "
"references and the lock are dropped by end_renaming()."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3877
msgid ""
"The passed in qstrs need not have the hash calculated, and basic eXecute "
"permission checking is performed against **rd.mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3881 ../fs/namei.c:3978
#: ../fs/namei.c:4006
msgid "zero or an error."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3957
msgid "lookup and lock name for rename with permission checking"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3962 ../fs/namei.c:3995
msgid "dentry of name to move"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3963
msgid "name of target in **rd.new_parent**"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3964
msgid "Look up target name and ensure locks are in place for rename."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3967
msgid ""
"On success the found dentry is stored in **rd.new_dentry** and **rd."
"old_parent** is confirmed to be the parent of **old_dentry**.  If it was "
"originally ``NULL``, it is set.  In either case a reference is taken so that "
"end_renaming() can have a stable reference to unlock."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3972 ../fs/namei.c:4003
msgid "References and the lock can be dropped with end_renaming()"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3974
msgid ""
"The passed in qstr need not have the hash calculated, and basic eXecute "
"permission checking is performed against **rd.mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3993
msgid "Lock to dentries in given parents for rename"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3994
msgid "rename data containing parent"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3996
msgid "dentry to move to"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3997
msgid ""
"Ensure locks are in place for rename and check parentage is still correct."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:3999
msgid ""
"On success the two dentries are stored in **rd.old_dentry** and **rd."
"new_dentry** and **rd.old_parent** and **rd.new_parent** are confirmed to be "
"the parents of the dentries."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4107
msgid "create new file"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4109
msgid "dentry of the child file"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4110
msgid "mode of the child file"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4112
msgid "``struct delegated_inode *di``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4111 ../fs/namei.c:4957
#: ../fs/namei.c:5094
msgid "returns parent inode, if the inode is delegated."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4112
msgid "Create a new file."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4709
msgid "open a tmpfile for kernel internal use"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4712
msgid "``const struct path *parentpath``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4711
msgid "path of the base directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4712
msgid "mode of the new tmpfile"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4714
msgid "``int open_flag``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4713
msgid "flags"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4715
msgid "``const struct cred *cred``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4714
msgid "credentials for open"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4715
msgid ""
"Create and open a temporary file.  The file is not accounted in nr_files, "
"hence this is only for kernel internal use, and must not be installed into "
"file tables or such."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4919
msgid "finish a code section started by start_creating_path()"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4920
msgid "the path instantiated by start_creating_path()"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4921
msgid "the dentry returned by start_creating_path()"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4922
msgid ""
"end_creating_path() will unlock and locks taken by start_creating_path() and "
"drop an references that were taken.  It should only be called if "
"start_creating_path() returned a non-error. If vfs_mkdir() was called and it "
"returned an error, that error *should* be passed to end_creating_path() "
"together with the path."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4951
msgid "create device node or file"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4953 ../fs/namei.c:5091
#: ../fs/namei.c:5206 ../fs/namei.c:5489
msgid "inode of the parent directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4954
msgid "dentry of the child device node"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4955
msgid "mode of the child device node"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4956
msgid "device number of device to create"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4958 ../fs/namei.c:5095
#: ../fs/namei.c:5209 ../fs/namei.c:5333 ../fs/namei.c:5493 ../fs/namei.c:5586
#: ../../../filesystems/api-summary:74: ../fs/attr.c:396
#: ../../../filesystems/api-summary:95: ../fs/xattr.c:272 ../fs/xattr.c:531
msgid "``struct delegated_inode *delegated_inode``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:4958
msgid "Create a device node or file."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5089
msgid "create directory returning correct dentry if possible"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5092 ../fs/namei.c:5207
msgid "dentry of the child directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5093
msgid "mode of the child directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5095
msgid "Create a directory."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5103
msgid ""
"In the event that the filesystem does not use the ***dentry** but leaves it "
"negative or unhashes it and possibly splices a different one returning it, "
"the original dentry is dput() and the alternate is returned."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5107
msgid "In case of an error the dentry is dput() and an ERR_PTR() is returned."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5204
msgid "remove directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5208
msgid "returns parent inode, if it's delegated."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5209
msgid "Remove a directory."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5328
msgid "unlink a filesystem object"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5330
msgid "parent directory"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5331
msgid "victim"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5332 ../fs/namei.c:5492
msgid "returns victim inode, if the inode is delegated."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5333 ../fs/namei.c:5586
msgid "The caller must hold dir->i_rwsem exclusively."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5335
msgid ""
"If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and return "
"a reference to the inode in delegated_inode.  The caller should then break "
"the delegation on that inode and retry.  Because breaking a delegation may "
"take a long time, the caller should drop dir->i_rwsem before doing so."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5341 ../fs/namei.c:5594
#: ../fs/namei.c:5774
msgid ""
"Alternatively, a caller may pass NULL for delegated_inode.  This may be "
"appropriate for callers that expect the underlying filesystem not to be NFS "
"exported."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5487
msgid "create symlink"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5490
msgid "dentry of the child symlink file"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5492
msgid "``const char *oldname``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5491
msgid "name of the file to link to"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5493
msgid "Create a symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5580
msgid "create a new link"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5581
msgid "object to be linked"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5583
msgid "new parent"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5584
msgid "where to create the new link"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5585
msgid "returns inode needing a delegation break"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5588
msgid ""
"If vfs_link discovers a delegation on the to-be-linked file in need of "
"breaking, it will return -EWOULDBLOCK and return a reference to the inode in "
"delegated_inode.  The caller should then break the delegation and retry.  "
"Because breaking a delegation may take a long time, the caller should drop "
"the i_rwsem before doing so."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5763
msgid "rename a filesystem object"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5764
msgid "pointer to :c:type:`struct renamedata <renamedata>` info"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5765
msgid "The caller must hold multiple mutexes--see lock_rename())."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5767
msgid ""
"If vfs_rename discovers a delegation in need of breaking at either the "
"source or destination, it will return -EWOULDBLOCK and return a reference to "
"the inode in delegated_inode.  The caller should then break the delegation "
"and retry.  Because breaking a delegation may take a long time, the caller "
"should drop all locks before doing so."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5778
msgid ""
"The worst of all namespace operations - renaming directory. \"Perverted\" "
"doesn't even start to describe it. Somebody in UCB had a heck of a trip... "
"Problems:"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5782
msgid "we can get into loop creation."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5783
msgid ""
"race potential - two innocent renames can create a loop together. That's "
"where 4.4BSD screws up. Current fix: serialization on sb-"
">s_vfs_rename_mutex. We might be more accurate, but that's another story."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5787
msgid ""
"we may have to lock up to _four_ objects - parents and victim (if it "
"exists), and source (if it's a non-directory or a subdirectory that moves to "
"different parent). And that - after we got ->i_rwsem on parents (until then "
"we don't know whether the target exists).  Solution: try to be smart with "
"locking order for inodes.  We rely on the fact that tree topology may change "
"only under ->s_vfs_rename_mutex _and_ that parent of the object we move will "
"be locked.  Thus we can rank directories by the tree (ancestors first) and "
"rank all non-directories after them. That works since everybody except "
"rename does \"lock parent, lookup, lock child\" and rename is under -"
">s_vfs_rename_mutex. HOWEVER, it relies on the assumption that any object "
"with ->lookup() has no more than 1 dentry.  If \"hybrid\" objects will ever "
"appear, we'd better make sure that there's no link(2) for them."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:5801
msgid ""
"conversion from fhandle to dentry may come in the wrong moment - when we are "
"removing the target. Solution: we will have to grab ->i_rwsem in the "
"fhandle_to_dentry code. [FIXME - current nfsfh.c relies on ->i_rwsem on "
"parents, which works but leads to some truly excessive locking]."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6116
msgid "copy symlink body into userspace buffer"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6117 ../fs/namei.c:6161
msgid "dentry on which to get symbolic link"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6119
msgid "``char __user *buffer``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6118
msgid "user memory pointer"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6120
#: ../../../filesystems/api-summary:77: ../fs/d_path.c:254
msgid "``int buflen``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6119
msgid "size of buffer"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6120
msgid "Does not touch atime.  That's up to the caller if necessary"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6122
msgid "Does not call security hook."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6160
msgid "get symlink body"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6163
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1723
msgid "``struct delayed_call *done``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6162
msgid "caller needs to free returned data with this"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6163
msgid "Calls security hook and i_op->get_link() on the supplied inode."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6165
msgid "It does not touch atime.  That's up to the caller if necessary."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6167
msgid "Does not work on \"special\" symlinks like /proc/$$/fd/N"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6217
msgid "An implementation of the get_link inode_operation."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6218
msgid "The directory entry which is the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6219
msgid "The inode for the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6221
msgid "``struct delayed_call *callback``"
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6220
msgid "Used to drop the reference to the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6221
msgid ""
"Filesystems which store their symlinks in the page cache should use this to "
"implement the get_link() member of their inode_operations."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6225
msgid "A pointer to the NUL-terminated symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6239
msgid "Drop the reference to the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6240
msgid "The folio which contains the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6241
msgid ""
"This is used internally by page_get_link().  It is exported for use by "
"filesystems which need to implement a variant of page_get_link() "
"themselves.  Despite the apparent symmetry, filesystems which use "
"page_get_link() do not need to call page_put_link()."
msgstr ""

#: ../../../filesystems/api-summary:56: ../fs/namei.c:6246
msgid ""
"The argument, while it has a void pointer type, must be a pointer to the "
"folio which was retrieved from the page cache.  The delayed_call "
"infrastructure is used to drop the reference count once the caller is done "
"with the symlink."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:291
msgid "reinitialize a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:297 ../block/bio.c:340
#: ../block/bio.c:818 ../block/bio.c:891 ../block/bio.c:981 ../block/bio.c:1006
#: ../block/bio.c:1022 ../block/bio.c:1069 ../block/bio.c:1094
#: ../block/bio.c:1121 ../block/bio.c:1379 ../block/bio.c:1626
#: ../block/bio.c:1686 ../block/bio.c:1736
msgid "``struct bio *bio``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:292
msgid "bio to reset"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:294 ../block/bio.c:485
#: ../block/bio.c:863 ../block/bio.c:894 ../block/bio.c:1405
msgid "``struct block_device *bdev``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:293
msgid "block device to use the bio for"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:295 ../block/bio.c:483
msgid "``blk_opf_t opf``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:294 ../block/bio.c:482
msgid "operation and flags for bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:296
msgid ""
"After calling bio_reset(), **bio** will be in the same state as a freshly "
"allocated bio returned bio bio_alloc_bioset() - the only fields that are "
"preserved are the ones that are initialized by bio_alloc_bioset(). See "
"comment in struct bio."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:334
msgid "chain bio completions"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:335
msgid "the target bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:337
msgid "``struct bio *parent``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:336
msgid "the parent bio of **bio**"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:337
msgid ""
"The caller won't have a bi_end_io called when **bio** completes - instead, "
"**parent**'s bi_end_io won't be called until both **parent** and **bio** "
"have completed; the chained bio will also be freed when it completes."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:341
msgid "The caller must not set bi_private or bi_end_io in **bio**."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:479
msgid "allocate a bio for I/O"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:480
msgid "block device to allocate the bio for (can be ``NULL``)"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:482 ../block/bio.c:608
msgid "``unsigned short nr_vecs``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:481
msgid "number of bvecs to pre-allocate"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:484 ../block/bio.c:605
msgid "``gfp_t gfp_mask``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:483 ../block/bio.c:604
msgid "the GFP_* mask given to the slab allocator"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:485 ../block/bio.c:862
#: ../block/bio.c:1685 ../block/bio.c:1800
msgid "``struct bio_set *bs``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:484
msgid "the bio_set to allocate from."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:485
msgid "Allocate a bio from the mempools in **bs**."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:487
msgid ""
"If ``__GFP_DIRECT_RECLAIM`` is set then bio_alloc will always be able to "
"allocate a bio.  This is due to the mempool guarantees.  To make this work, "
"callers must never allocate more than 1 bio at a time from the general pool. "
"Callers that need to allocate more than 1 bio must always submit the "
"previously allocated bio for IO before attempting to allocate a new one. "
"Failure to do so can cause deadlocks under memory pressure."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:494
msgid ""
"Note that when running under submit_bio_noacct() (i.e. any block driver), "
"bios are not submitted until after you return - see the code in "
"submit_bio_noacct() that converts recursion into iteration, to prevent stack "
"overflows."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:499
msgid ""
"This would normally mean allocating multiple bios under submit_bio_noacct() "
"would be susceptible to deadlocks, but we have deadlock avoidance code that "
"resubmits any blocked bios from a rescuer thread."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:504
msgid ""
"However, we do not guarantee forward progress for allocations from other "
"mempools. Doing multiple allocations from the same mempool under "
"submit_bio_noacct() should be avoided - instead, use bio_set's front_pad for "
"per bio allocations."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:510 ../block/bio.c:615
msgid "Pointer to new bio on success, NULL on failure."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:602
msgid "kmalloc a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:603
msgid "number of bio_vecs to allocate"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:605
msgid ""
"Use kmalloc to allocate a bio (including bvecs).  The bio must be "
"initialized using bio_init() before use.  To free a bio returned from this "
"function use kfree() after calling bio_uninit().  A bio returned from this "
"function can be reused by calling bio_uninit() before calling bio_init() "
"again."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:610
msgid ""
"Note that unlike bio_alloc() or bio_alloc_bioset() allocations from this "
"function are not backed by a mempool can fail.  Do not use this function for "
"allocations in the file system I/O path."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:812
msgid "release a reference to a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:813
msgid "bio to release reference to"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:815
msgid ""
"Put a reference to a :c:type:`struct bio <bio>`, either one you have gotten "
"with bio_alloc, bio_get or bio_clone_*. The last put of a bio will free it."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:857 ../block/bio.c:888
msgid "clone a bio that shares the original bio's biovec"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:858 ../block/bio.c:889
msgid "block_device to clone onto"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:860 ../block/bio.c:892
msgid "``struct bio *bio_src``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:859 ../block/bio.c:891
msgid "bio to clone from"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:860 ../block/bio.c:892
msgid "allocation priority"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:861
msgid "bio_set to allocate from"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:862
msgid ""
"Allocate a new bio that is a clone of **bio_src**. The caller owns the "
"returned bio, but not the actual data it points to."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:865
msgid ""
"The caller must ensure that the return bio is not freed before **bio_src**."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:890
msgid "bio to clone into"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:893
msgid ""
"Initialize a new bio in caller provided memory that is a clone of "
"**bio_src**. The caller owns the returned bio, but not the actual data it "
"points to."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:896
msgid "The caller must ensure that **bio_src** is not freed before **bio**."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:975
msgid "add page(s) to a bio in a new segment"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:976 ../block/bio.c:1001
#: ../block/bio.c:1017 ../block/bio.c:1089 ../block/bio.c:1116
#: ../block/bio.c:1482
msgid "destination bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:978 ../block/bio.c:1019
msgid "``struct page *page``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:977 ../block/bio.c:1018
msgid "start page to add"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:979 ../block/bio.c:1020
#: ../block/bio.c:1119 ../../../filesystems/api-summary:83: ../fs/libfs.c:1816
msgid "``unsigned int len``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:978 ../block/bio.c:1003
msgid "length of the data to add, may cross pages"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:980
msgid "``unsigned int off``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:979
msgid "offset of the data relative to **page**, may cross pages"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:980
msgid ""
"Add the data at **page** + **off** to **bio** as a new bvec.  The caller "
"must ensure that **bio** has space for another bvec."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1000
msgid "add data in the direct kernel mapping to a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1003 ../block/bio.c:1091
#: ../block/bio.c:1118
msgid "``void *vaddr``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1002
msgid "data to add"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1004 ../block/bio.c:1092
msgid "``unsigned len``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1004
msgid ""
"Add the data at **vaddr** to **bio**.  The caller must have ensure a segment "
"is available for the added data.  No merging into an existing segment will "
"be performed."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1016
msgid "attempt to add page(s) to bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1019
msgid "vec entry length, may cross pages"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1021
msgid "``unsigned int offset``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1020
msgid "vec entry offset relative to **page**, may cross pages"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1021
msgid ""
"Attempt to add page(s) to the bio_vec maplist. This will only fail if either "
"bio->bi_vcnt == bio->bi_max_vecs or it's a cloned bio."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1063
msgid "Attempt to add part of a folio to a bio."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1064
msgid "BIO to add to."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1066
#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:961
msgid "``struct folio *folio``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1065
msgid "Folio to add."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1066
msgid "How many bytes from the folio to add."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1068
msgid "``size_t off``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1067
msgid "First byte in this folio to add."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1068
msgid ""
"Filesystems that use folios can call this function instead of calling "
"bio_add_page() for each page in the folio.  If **off** is bigger than "
"PAGE_SIZE, this function can create a bio_vec that starts in a page after "
"the bv_page.  BIOs do not support folios that are 4GiB or larger."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1074
msgid "Whether the addition was successful."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1088
msgid "add a vmalloc chunk to a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1090 ../block/bio.c:1117
msgid "vmalloc address to add"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1091 ../block/bio.c:1118
msgid "total length in bytes of the data to add"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1092
msgid ""
"Add data starting at **vaddr** to **bio** and return how many bytes were "
"added. This may be less than the amount originally asked.  Returns 0 if no "
"data could be added to **bio**."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1096 ../block/bio.c:1122
msgid ""
"This helper calls flush_kernel_vmap_range() for the range added.  For reads "
"the caller still needs to manually call invalidate_kernel_vmap_range() in "
"the completion handler."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1115
msgid "add a vmalloc region to a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1119
msgid ""
"Add data starting at **vaddr** to **bio**.  Return ``true`` on success or "
"``false`` if **bio** does not have enough space for the payload."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1373
msgid "submit a bio, and wait until it completes"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1374
msgid "The :c:type:`struct bio <bio>` which describes the I/O"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1375
msgid ""
"Simple wrapper around submit_bio(). Returns 0 on success, or the error from "
"bio_endio() on failure."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1378
msgid ""
"WARNING: Unlike to how submit_bio() is usually used, this function does not "
"result in bio reference to be consumed. The caller must drop the reference "
"on his own."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1399
msgid "synchronously read into / write from kernel mapping"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1400
msgid "block device to access"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1402
msgid "``sector_t sector``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1401
msgid "sector to access"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1402
msgid "data to read/write"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1403
msgid "length in byte to read/write"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1405
msgid "``enum req_op op``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1404
msgid "operation (e.g. REQ_OP_READ/REQ_OP_WRITE)"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1405
msgid ""
"Performs synchronous I/O to **bdev** for **data**/**len**.  **data** must be "
"in the kernel direct mapping and not a vmalloc address."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1480
msgid "copy contents of data buffers from one bio to another"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1486
msgid "``struct bio *dst``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1484
msgid "``struct bio *src``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1481
msgid "source bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1483
msgid ""
"Stops when it reaches the end of either **src** or **dst** - that is, copies "
"min(src->bi_size, dst->bi_size) bytes (or the equivalent for lists of bios)."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1620
msgid "end I/O on a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1621
msgid "bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1623
msgid ""
"bio_endio() will end I/O on the whole bio. bio_endio() is the preferred way "
"to end I/O on a bio. No one should call bi_end_io() directly on a bio unless "
"they own it and thus know that it has an end_io function."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1627
msgid ""
"bio_endio() can be called several times on a bio that has been chained using "
"bio_chain().  The ->bi_end_io() function will only be called the last time."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1680
msgid "split a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1681
msgid "bio to split"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1683
msgid "``int sectors``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1682
msgid "number of sectors to split from the front of **bio**"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1683
msgid "gfp mask"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1684
msgid "bio set to allocate from"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1685
msgid ""
"Allocates and returns a new bio which represents **sectors** from the start "
"of **bio**, and updates **bio** to represent the remaining sectors."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1688
msgid ""
"Unless this is a discard request the newly allocated bio will point to "
"**bio**'s bi_io_vec. It is the caller's responsibility to ensure that "
"neither **bio** nor **bs** are freed before the split bio."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1730
msgid "trim a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1731
msgid "bio to trim"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1733
msgid "``sector_t offset``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1732
msgid "number of sectors to trim from the front of **bio**"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1734
msgid "``sector_t size``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1733
msgid "size we want to trim **bio** to, in sectors"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1734
msgid ""
"This function is typically used for bios that are cloned and submitted to "
"the underlying device in parts."
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1794
msgid "Initialize a bio_set"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1795
msgid "pool to initialize"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1797
msgid "``unsigned int pool_size``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1796
msgid "Number of bio and bio_vecs to cache in the mempool"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1798
msgid "``unsigned int front_pad``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1797
msgid "Number of bytes to allocate in front of the returned bio"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1798
msgid ""
"Flags to modify behavior, currently ``BIOSET_NEED_BVECS`` and "
"``BIOSET_NEED_RESCUER``"
msgstr ""

#: ../../../filesystems/api-summary:59: ../block/bio.c:1801
msgid ""
"Set up a bio_set to be used with **bio_alloc_bioset**. Allows the caller to "
"ask for a number of bytes to be allocated in front of the bio. Front pad "
"allocation is useful for embedding the bio inside another structure, to "
"avoid allocating extra data to go with the bio. Note that the bio must be "
"embedded at the END of that structure always, or things will break badly. If "
"``BIOSET_NEED_BVECS`` is set in **flags**, a separate pool will be allocated "
"for allocating iovecs.  This pool is not needed e.g. for bio_init_clone(). "
"If ``BIOSET_NEED_RESCUER`` is set, a workqueue is created which can be used "
"to dispatch queued requests when the mempool runs out of space."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:42
msgid "initialize sequential file"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:43
msgid "file we initialize"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:45
msgid "``const struct seq_operations *op``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:44
msgid "method table describing the sequence"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:45
msgid ""
"seq_open() sets **file**, associating it with a sequence described by "
"**op**.  **op->start\\(\\)** sets the iterator up and returns the first "
"element of sequence. **op->stop\\(\\)** shuts it down.  **op->next\\(\\)** "
"returns the next element of sequence.  **op->show\\(\\)** prints element "
"into the buffer.  In case of error ->start() and ->next() return "
"ERR_PTR(error).  In the end of sequence they return ``NULL``. ->show() "
"returns 0 in case of success and negative number in case of error. Returning "
"SEQ_SKIP means \"discard this element and move on\"."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:54
msgid "seq_open() will allocate a struct seq_file and store its"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:55
msgid "pointer in **file->private_data**. This pointer should not be modified."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:143
msgid "->read() method for sequential files."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:144
msgid "the file to read from"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:146
msgid "``char __user *buf``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:145
msgid "the buffer to read to"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:147
#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:754
#: ../../../filesystems/api-summary:95: ../fs/xattr.c:270 ../fs/xattr.c:465
msgid "``size_t size``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:146
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1131 ../fs/libfs.c:1169
#: ../fs/libfs.c:1201
msgid "the maximum number of bytes to read"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:179
#: ../kernel/sysctl.c:587 ../kernel/sysctl.c:627 ../kernel/sysctl.c:646
#: ../kernel/sysctl.c:666 ../kernel/sysctl.c:690 ../kernel/sysctl.c:717
#: ../kernel/sysctl.c:850 ../kernel/sysctl.c:880
#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:148
#: ../fs/seq_file.c:999 ../fs/seq_file.c:1065
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1133 ../fs/libfs.c:1168
#: ../fs/libfs.c:1203
msgid "``loff_t *ppos``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:147
msgid "the current position in the file"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:148
msgid "Ready-made ->f_op->read()"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:301
msgid "->llseek() method for sequential files."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:302
msgid "the file in question"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:304
#: ../../../filesystems/api-summary:74: ../fs/attr.c:232
msgid "``loff_t offset``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:303
msgid "new position"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:305
msgid "``int whence``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:304
msgid "0 for absolute, 1 for relative position"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:305
msgid "Ready-made ->f_op->llseek()"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:345
msgid "free the structures associated with sequential file."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:346
msgid "its inode"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:347
msgid "file in question"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:348
msgid ""
"Frees the structures associated with sequential file; can be used as ->f_op-"
">release() if you don't have private data to destroy."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:362
msgid "print data into buffer, escaping some characters"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:368
#: ../fs/seq_file.c:468 ../fs/seq_file.c:497 ../fs/seq_file.c:842
msgid "``struct seq_file *m``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:363
msgid "target buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:365
msgid "``const char *src``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:364
msgid "source buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:365
msgid "size of source buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:366
msgid "flags to pass to string_escape_mem()"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:368
#: ../fs/seq_file.c:434 ../fs/seq_file.c:466 ../fs/seq_file.c:495
msgid "``const char *esc``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:367
#: ../fs/seq_file.c:433
msgid "set of characters that need escaping"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:368
msgid ""
"Puts data into buffer, replacing each occurrence of character from given "
"class (defined by **flags** and **esc**) with printable escaped sequence."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:371
msgid "Use seq_has_overflowed() to check for errors."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:430
msgid "mangle and copy path to buffer beginning"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:436
msgid "``char *s``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:431
msgid "buffer start"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:433
msgid "``const char *p``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:432
msgid "beginning of path in above buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:434
msgid ""
"Copy the path from **p** to **s**, replacing each occurrence of character "
"from **esc** with usual octal escape. Returns pointer past last written "
"character in **s**, or NULL in case of failure."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:462
msgid "seq_file interface to print a pathname"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:463
#: ../fs/seq_file.c:492
msgid "the seq_file handle"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:464
msgid "the struct path to print"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:465
#: ../fs/seq_file.c:494
msgid "set of characters to escape in the output"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:466
msgid ""
"return the absolute path of 'path', as represented by the dentry / mnt pair "
"in the path parameter."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:491
msgid "seq_file interface to print a pathname of a file"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:493
msgid "the struct file to print"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:495
msgid "return the absolute path to the file."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:816
msgid "write arbitrary data to buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:822
msgid "``struct seq_file *seq``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:817
#: ../fs/seq_file.c:837
msgid "seq_file identifying the buffer to which data should be written"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:819
msgid "``const void *data``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:818
msgid "data address"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:819
msgid "number of bytes"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:820
msgid "Return 0 on success, non-zero otherwise."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:836
msgid "write padding spaces to buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:839
msgid "``char c``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:838
msgid "the byte to append after padding if non-zero"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:960
#: ../fs/seq_file.c:978
msgid "start an iteration of a hlist"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:966
#: ../fs/seq_file.c:984 ../fs/seq_file.c:998 ../fs/seq_file.c:1022
#: ../fs/seq_file.c:1045 ../fs/seq_file.c:1064
msgid "``struct hlist_head *head``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:961
#: ../fs/seq_file.c:979 ../fs/seq_file.c:997 ../fs/seq_file.c:1017
#: ../fs/seq_file.c:1040 ../fs/seq_file.c:1063
msgid "the head of the hlist"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:963
#: ../fs/seq_file.c:981 ../fs/seq_file.c:1019 ../fs/seq_file.c:1042
#: ../fs/seq_file.c:1091
msgid "``loff_t pos``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:962
#: ../fs/seq_file.c:980 ../fs/seq_file.c:1018 ../fs/seq_file.c:1041
msgid "the start position of the sequence"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:963
#: ../fs/seq_file.c:1019 ../fs/seq_file.c:1091
msgid "Called at seq_file->op->start()."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:981
#: ../fs/seq_file.c:1042
msgid ""
"Called at seq_file->op->start(). Call this function if you want to print a "
"header at the top of the output."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:995
msgid "move to the next position of the hlist"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1001
#: ../fs/seq_file.c:1067 ../fs/seq_file.c:1116
msgid "``void *v``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:996
#: ../fs/seq_file.c:1062
msgid "the current iterator"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:998
#: ../fs/seq_file.c:1064
msgid "the current position"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:999
#: ../fs/seq_file.c:1065 ../fs/seq_file.c:1115
msgid "Called at seq_file->op->next()."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1016
#: ../fs/seq_file.c:1039
msgid "start an iteration of a hlist protected by RCU"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1021
#: ../fs/seq_file.c:1045 ../fs/seq_file.c:1067
msgid ""
"This list-traversal primitive may safely run concurrently with the _rcu list-"
"mutation primitives such as hlist_add_head_rcu() as long as the traversal is "
"guarded by rcu_read_lock()."
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1061
msgid "move to the next position of the hlist protected by RCU"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1087
msgid "start an iteration of a percpu hlist array"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1093
#: ../fs/seq_file.c:1113
msgid "``struct hlist_head __percpu *head``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1088
#: ../fs/seq_file.c:1112
msgid "pointer to percpu array of struct hlist_heads"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1090
#: ../fs/seq_file.c:1114
msgid "``int *cpu``"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1089
#: ../fs/seq_file.c:1113
msgid "pointer to cpu \"cursor\""
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1090
#: ../fs/seq_file.c:1114
msgid "start position of sequence"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1110
msgid "move to the next position of the percpu hlist array"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1111
msgid "pointer to current hlist_node"
msgstr ""

#: ../../../filesystems/api-summary:62: ../fs/seq_file.c:1115
msgid "``loff_t *pos``"
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:60
msgid "register a new filesystem"
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:66
#: ../fs/filesystems.c:103
msgid "``struct file_system_type * fs``"
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:61
msgid "the file system structure"
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:62
msgid ""
"Adds the file system passed to the list of file systems the kernel is aware "
"of for mount and other syscalls. Returns 0 on success, or a negative errno "
"code on an error."
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:66
msgid ""
"The :c:type:`struct file_system_type <file_system_type>` that is passed is "
"linked into the kernel structures and must not be freed until the file "
"system has been unregistered."
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:97
msgid "unregister a file system"
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:98
msgid "filesystem to unregister"
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:99
msgid ""
"Remove a file system that was previously successfully registered with the "
"kernel. An error is returned if the file system is not found. Zero is "
"returned on a success."
msgstr ""

#: ../../../filesystems/api-summary:65: ../fs/filesystems.c:103
msgid ""
"Once this function has returned the :c:type:`struct file_system_type "
"<file_system_type>` structure may be freed or reused."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:817
msgid "associate wbc and inode for fdatawrite"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:818
msgid "writeback_control of interest"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:819
#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:686
msgid "target inode"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:820
msgid ""
"This function is to be used by filemap_writeback(), which is an alternative "
"entry point into writeback code, and first ensures **inode** is associated "
"with a bdi_writeback and attaches it to **wbc**."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:835
msgid "disassociate wbc from inode and perform foreign detection"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:836
msgid "writeback_control of the just finished writeback"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:837
msgid ""
"To be called after a writeback attempt of an inode finishes and undoes "
"wbc_attach_and_unlock_inode().  Can be called under any context."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:840
msgid ""
"As concurrent write sharing of an inode is expected to be very rare and "
"memcg only tracks page ownership on first-use basis severely confining the "
"usefulness of such sharing, cgroup writeback tracks ownership per-inode.  "
"While the support for concurrent write sharing of an inode is deemed "
"unnecessary, an inode being written to by different cgroups at different "
"points in time is a lot more common, and, more importantly, charging only by "
"first-use can too readily lead to grossly incorrect behaviors (single "
"foreign page can lead to gigabytes of writeback to be incorrectly "
"attributed)."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:850
msgid ""
"To resolve this issue, cgroup writeback detects the majority dirtier of an "
"inode and transfers the ownership to it.  To avoid unnecessary oscillation, "
"the detection mechanism keeps track of history and gives out the switch "
"verdict only if the foreign usage pattern is stable over a certain amount of "
"time and/or writeback attempts."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:856
msgid ""
"On each writeback attempt, **wbc** tries to detect the majority writer using "
"Boyer-Moore majority vote algorithm.  In addition to the byte count from the "
"majority voting, it also counts the bytes written for the current wb and the "
"last round's winner wb (max of last round's current wb, the winner from two "
"rounds ago, and the last round's majority candidate).  Keeping track of the "
"historical winner helps the algorithm to semi-reliably detect the most "
"active writer even when it's not the absolute majority."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:865
msgid ""
"Once the winner of the round is determined, whether the winner is foreign or "
"not and how much IO time the round consumed is recorded in inode-"
">i_wb_frn_history.  If the amount of recorded foreign IO time is over a "
"certain threshold, the switch verdict is given."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:958
msgid "account writeback to update inode cgroup ownership"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:959
msgid "writeback_control of the writeback in progress"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:960
msgid "folio being written out"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:962
msgid "``size_t bytes``"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:961
msgid "number of bytes being written out"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:962
msgid ""
"**bytes** from **folio** are about to written out during the writeback "
"controlled by **wbc**.  Keep the book for foreign inode detection.  See "
"wbc_detach_inode()."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2537
msgid "internal function to mark an inode dirty"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2539
msgid "inode to mark"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2540
msgid ""
"what kind of dirty, e.g. I_DIRTY_SYNC.  This can be a combination of "
"multiple I_DIRTY_* flags, except that I_DIRTY_TIME can't be combined with "
"I_DIRTY_PAGES."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2543
msgid ""
"Mark an inode as dirty.  We notify the filesystem, then update the inode's "
"dirty flags.  Then, if needed we add the inode to the appropriate dirty list."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2546
msgid ""
"Most callers should use mark_inode_dirty() or mark_inode_dirty_sync() "
"instead of calling this directly."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2549
msgid ""
"CAREFUL!  We only add the inode to the dirty list if it is hashed or if it "
"refers to a blockdev.  Unhashed inodes will never be added to the dirty list "
"even if they are later hashed, as they will have been marked dirty already."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2553
msgid ""
"In short, ensure you hash any inodes _before_ you start marking them dirty."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2555
msgid ""
"Note that for blockdevs, inode->dirtied_when represents the dirtying time of "
"the block-special inode (/dev/hda1) itself.  And the ->dirtied_when field of "
"the kernel-internal blockdev inode represents the dirtying time of the "
"blockdev's pages.  This is why for I_DIRTY_PAGES we always use page->mapping-"
">host, so the page-dirtying time is recorded in the internal blockdev inode."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2825
#: ../fs/fs-writeback.c:2843
msgid "writeback dirty inodes from given super_block"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2826
#: ../fs/fs-writeback.c:2844 ../fs/fs-writeback.c:2859
#: ../fs/fs-writeback.c:2876
msgid "the superblock"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2828
msgid "``unsigned long nr``"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2827
msgid "the number of pages to write"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2829
#: ../fs/fs-writeback.c:2846 ../fs/fs-writeback.c:2861
msgid "``enum wb_reason reason``"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2828
msgid "reason why some writeback work initiated"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2829
#: ../fs/fs-writeback.c:2846
msgid ""
"Start writeback on some inodes on this super_block. No guarantees are made "
"on how many (if any) will be written, and this function does not wait for IO "
"completion of submitted IO."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2845
#: ../fs/fs-writeback.c:2860
msgid "reason why some writeback work was initiated"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2858
msgid "try to start writeback if none underway"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2861
msgid "Invoke __writeback_inodes_sb_nr if no writeback is currently underway."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2875
msgid "sync sb inode pages"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2877
msgid ""
"This function writes and waits on any dirty inode belonging to this "
"super_block."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2915
#: ../fs/fs-writeback.c:2942
msgid "write an inode to disk"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2916
msgid "inode to write to disk"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2918
msgid "``int sync``"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2917
msgid "whether the write should be synchronous or not"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2918
msgid ""
"This function commits an inode to disk immediately if it is dirty. This is "
"primarily needed by knfsd."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2921
msgid ""
"The caller must either have a ref on the inode or must have set I_WILL_FREE."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2943
msgid "the inode to sync"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2945
msgid "``int wait``"
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2944
msgid "wait for I/O to complete."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2945
msgid "Write an inode to disk and adjust its dirty state after completion."
msgstr ""

#: ../../../filesystems/api-summary:68: ../fs/fs-writeback.c:2948
msgid "only writes the actual inode, no associated data or other metadata."
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:185
#: ../fs/anon_inodes.c:209
msgid ""
"creates a new file instance by hooking it up to an anonymous inode, and a "
"dentry that describe the \"class\" of the file"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:189
#: ../fs/anon_inodes.c:213 ../fs/anon_inodes.c:246 ../fs/anon_inodes.c:292
msgid "[in]    name of the \"class\" of the new file"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:488
#: ../fs/debugfs/inode.c:526 ../../../filesystems/api-summary:71:
#: ../fs/anon_inodes.c:191 ../fs/anon_inodes.c:215 ../fs/anon_inodes.c:248
#: ../fs/anon_inodes.c:294
msgid "``const struct file_operations *fops``"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:190
#: ../fs/anon_inodes.c:214 ../fs/anon_inodes.c:247 ../fs/anon_inodes.c:293
msgid "[in]    file operations for the new file"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:192
#: ../fs/anon_inodes.c:216 ../fs/anon_inodes.c:249 ../fs/anon_inodes.c:295
msgid "``void *priv``"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:191
#: ../fs/anon_inodes.c:215 ../fs/anon_inodes.c:248 ../fs/anon_inodes.c:294
msgid "[in]    private data for the new file (will be file's private_data)"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:192
#: ../fs/anon_inodes.c:216 ../fs/anon_inodes.c:249 ../fs/anon_inodes.c:295
msgid "[in]    flags"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:193
msgid ""
"Creates a new file by hooking it on a single inode. This is useful for files "
"that do not need to have a full-fledged inode in order to operate correctly. "
"All the files created with anon_inode_getfile() will share a single inode, "
"hence saving memory and avoiding code duplication for the file/inode/dentry "
"setup.  Returns the newly created file* or an error pointer."
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:218
msgid "``fmode_t f_mode``"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:217
msgid "[in]    fmode"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:218
msgid ""
"Creates a new file by hooking it on a single inode. This is useful for files "
"that do not need to have a full-fledged inode in order to operate correctly. "
"All the files created with anon_inode_getfile() will share a single inode, "
"hence saving memory and avoiding code duplication for the file/inode/dentry "
"setup. Allows setting the fmode. Returns the newly created file* or an error "
"pointer."
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:241
msgid ""
"Like anon_inode_getfile(), but creates a new !S_PRIVATE anon inode rather "
"than reuse the singleton anon inode and calls the inode_init_security_anon() "
"LSM hook."
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:251
msgid "``const struct inode *context_inode``"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:250
msgid "[in]    the logical relationship with the new inode (optional)"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:252
msgid ""
"Create a new anonymous inode and file pair.  This can be done for two "
"reasons:"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:255
msgid ""
"for the inode to have its own security context, so that LSMs can enforce "
"policy on the inode's creation;"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:258
msgid ""
"if the caller needs a unique inode, for example in order to customize the "
"size returned by fstat()"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:261
msgid ""
"The LSM may use **context_inode** in inode_init_security_anon(), but a "
"reference to it is not held."
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:264
msgid "Returns the newly created file* or an error pointer."
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:288
msgid ""
"creates a new file instance by hooking it up to an anonymous inode and a "
"dentry that describe the \"class\" of the file"
msgstr ""

#: ../../../filesystems/api-summary:71: ../fs/anon_inodes.c:296
msgid ""
"Creates a new file by hooking it on a single inode. This is useful for files "
"that do not need to have a full-fledged inode in order to operate "
"correctly.  All the files created with anon_inode_getfd() will use the same "
"singleton inode, reducing memory use and avoiding code duplication for the "
"file/inode/dentry setup.  Returns a newly created file descriptor or an "
"error code."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:21
msgid "determine whether the setgid bit needs to be removed"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:25
msgid ""
"This function determines whether the setgid bit needs to be removed. We "
"retain backwards compatibility and require setgid bit to be removed "
"unconditionally if S_IXGRP is set. Otherwise we have the exact same "
"requirements as setattr_prepare() and setattr_copy()."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:31
msgid "ATTR_KILL_SGID if setgid bit needs to be removed, 0 otherwise."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:49
msgid "determine whether the set{g,u}id bit needs to be dropped"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:53
msgid ""
"This function determines whether the set{g,u}id bits need to be removed. If "
"the setuid bit needs to be removed ATTR_KILL_SUID is returned. If the setgid "
"bit needs to be removed ATTR_KILL_SGID is returned. If both set{g,u}id bits "
"need to be removed the corresponding mask of both flags is returned."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:60
msgid ""
"A mask of ATTR_KILL_S{G,U}ID indicating which - if any - setid bits to "
"remove, 0 otherwise."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:141
msgid "check if attribute changes to a dentry are allowed"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:143
msgid "dentry to check"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:145 ../fs/attr.c:395
msgid "``struct iattr *attr``"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:144
msgid "attributes to change"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:145
msgid ""
"Check if we are allowed to change the attributes contained in **attr** in "
"the given dentry.  This includes the normal unix access permission checks, "
"as well as checks for rlimits and others. The function also clears SGID bit "
"from mode if user is not allowed to set it. Also file capabilities and IMA "
"extended attributes are cleared if ATTR_KILL_PRIV is set."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:157
msgid ""
"Should be called as the first thing in ->setattr implementations, possibly "
"after taking additional locks."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:229
msgid "may this inode be truncated to a given size"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:230
msgid "the inode to be truncated"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:231
msgid "the new size to assign to the inode"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:232
msgid "inode_newsize_ok must be called with i_rwsem held exclusively."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:234
msgid ""
"inode_newsize_ok will check filesystem limits and ulimits to check that the "
"new inode size is within limits. inode_newsize_ok will also send SIGXFSZ "
"when necessary. Caller must not proceed with inode size change if failure is "
"returned. **inode** must be a file (not directory), with appropriate "
"permissions to allow truncate (inode_newsize_ok does NOT check these "
"conditions)."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:242
msgid "0 on success, -ve errno on failure"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:308
msgid "copy simple metadata updates into the generic inode"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:310
msgid "the inode to be updated"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:311
msgid "the new attributes"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:312
msgid "setattr_copy must be called with i_rwsem held exclusively."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:314
msgid ""
"setattr_copy updates the inode's metadata with that specified in attr on "
"idmapped mounts. Necessary permission checks to determine whether or not the "
"S_ISGID property needs to be removed are performed with the correct idmapped "
"mount permission helpers. Noticeably missing is inode size update, which is "
"more complex as it requires pagecache updates."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:327
msgid ""
"The inode is not marked as dirty after this operation. The rationale is that "
"for \"simple\" filesystems, the struct inode is the inode storage. The "
"caller is free to mark the inode dirty afterwards if needed."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:391
msgid "modify attributes of a filesystem object"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:393
msgid "object affected"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:394
msgid "new attributes"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:395
msgid "returns inode, if the inode is delegated"
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:396
msgid "The caller must hold the i_rwsem exclusively on the affected object."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:398
msgid ""
"If notify_change discovers a delegation in need of breaking, it will return -"
"EWOULDBLOCK and return a reference to the inode in delegated_inode.  The "
"caller should then break the delegation and retry.  Because breaking a "
"delegation may take a long time, the caller should drop the i_rwsem before "
"doing so."
msgstr ""

#: ../../../filesystems/api-summary:74: ../fs/attr.c:404
msgid ""
"Alternatively, a caller may pass NULL for delegated_inode.  This may be "
"appropriate for callers that expect the underlying filesystem not to be NFS "
"exported.  Also, passing NULL is fine for callers holding the file open for "
"write, as there can be no conflicting delegation in that case."
msgstr ""

#: ../../../filesystems/api-summary:77: ../fs/d_path.c:250
msgid "return the path of a dentry"
msgstr ""

#: ../../../filesystems/api-summary:77: ../fs/d_path.c:251
msgid "path to report"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:748
#: ../fs/sysfs/file.c:774 ../fs/sysfs/file.c:801
#: ../../../filesystems/api-summary:77: ../fs/d_path.c:253
msgid "``char *buf``"
msgstr ""

#: ../../../filesystems/api-summary:77: ../fs/d_path.c:252
msgid "buffer to return value in"
msgstr ""

#: ../../../filesystems/api-summary:77: ../fs/d_path.c:253
msgid "buffer length"
msgstr ""

#: ../../../filesystems/api-summary:77: ../fs/d_path.c:254
msgid ""
"Convert a dentry into an ASCII path name. If the entry has been deleted the "
"string \" (deleted)\" is appended. Note that this is ambiguous."
msgstr ""

#: ../../../filesystems/api-summary:77: ../fs/d_path.c:257
msgid ""
"Returns a pointer into the buffer or an error code if the path was too long. "
"Note: Callers should use the returned pointer, not the passed in buffer, to "
"use the name! The implementation often starts at an offset into the buffer, "
"and may leave 0 bytes at the start."
msgstr ""

#: ../../../filesystems/api-summary:77: ../fs/d_path.c:262
msgid "\"buflen\" should be positive."
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:737
msgid "find first pinned page in **mapping**"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:738
msgid "address space to scan for a page with ref count > 1"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:740
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1544 ../fs/libfs.c:1588
#: ../../../filesystems/api-summary:92: ../fs/sync.c:173
msgid "``loff_t start``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:739
msgid "Starting offset. Page containing 'start' is included."
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:741
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1545 ../fs/libfs.c:1589
#: ../../../filesystems/api-summary:92: ../fs/sync.c:174
msgid "``loff_t end``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:740
msgid ""
"End offset. Page containing 'end' is included. If 'end' is LLONG_MAX, pages "
"from 'start' till the end of file are included."
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:742
msgid ""
"DAX requires ZONE_DEVICE mapped pages. These pages are never 'onlined' to "
"the page allocator so they are considered idle when page->count == 1. A "
"filesystem uses this interface to determine if any page in the mapping is "
"busy, i.e. for DMA, or other get_user_pages() usages."
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:748
msgid ""
"It is expected that the filesystem is holding locks to block the "
"establishment of new mappings in this address_space. I.e. it expects to be "
"able to run unmap_mapping_range() and subsequently not race mapping_mapped() "
"becoming true."
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:1697
msgid "Perform I/O to a DAX file"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:1698
msgid "The control block for this I/O"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:1700
msgid "``struct iov_iter *iter``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:1699
msgid "The addresses to do I/O from or to"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:1701 ../fs/dax.c:2065
msgid "``const struct iomap_ops *ops``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:1700
msgid "iomap ops passed from the file system"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:1701
msgid ""
"This function performs read and write operations to directly mapped "
"persistent memory.  The callers needs to take care of read/write exclusion "
"and evicting any page cache pages in the region under I/O."
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2059
msgid "handle a page fault on a DAX file"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2065 ../fs/dax.c:2139
msgid "``struct vm_fault *vmf``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2060 ../fs/dax.c:2134
msgid "The description of the fault"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2062 ../fs/dax.c:2136
msgid "``unsigned int order``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2061
msgid "Order of the page to fault in"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2063
msgid "``unsigned long *pfnp``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2062
msgid "PFN to insert for synchronous faults if fsync is required"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2064
msgid "``int *iomap_errp``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2063
msgid "Storage for detailed error code in case of error"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2064
msgid "Iomap ops passed from the file system"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2065
msgid ""
"When a page fault occurs, filesystems may call this helper in their fault "
"handler for DAX files. dax_iomap_fault() assumes the caller has done all the "
"necessary locking for page fault to proceed successfully."
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2133
msgid "finish synchronous page fault"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2135
msgid "Order of entry to be inserted"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2137
msgid "``unsigned long pfn``"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2136
msgid "PFN to insert"
msgstr ""

#: ../../../filesystems/api-summary:80: ../fs/dax.c:2137
msgid ""
"This function ensures that the file range touched by the page fault is "
"stored persistently on the media and handles inserting of appropriate page "
"table entry."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:824
msgid "update the various inode timestamps for rename"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:830
msgid "``struct inode *old_dir``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:825
msgid "old parent directory"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:826
msgid "dentry that is being renamed"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:828
msgid "``struct inode *new_dir``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:827
msgid "new parent directory"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:828
msgid "target for rename"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:829
msgid ""
"POSIX mandates that the old and new parent directories have their ctime and "
"mtime updated, and that inodes of **old_dentry** and **new_dentry** (if "
"any), have their ctime updated."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:901
msgid "setattr for simple filesystem"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:902
msgid "idmap of the target mount"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:903
msgid "dentry"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:905
msgid "``struct iattr *iattr``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:904
msgid "iattr structure"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:905
msgid "Returns 0 on success, -error on failure."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:907
msgid ""
"simple_setattr is a simple ->setattr implementation without a proper "
"implementation of size changes."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:910
msgid ""
"It can either be used for in-memory filesystems or special files on simple "
"regular filesystems.  Anything that needs to change on-disk or wire state on "
"size changes needs its own setattr method."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1129
msgid "copy data from the buffer to user space"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1135
msgid "``void __user *to``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1130
msgid "the user space buffer to read to"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:803
#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1132 ../fs/libfs.c:1170
#: ../fs/libfs.c:1202
msgid "``size_t count``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1132 ../fs/libfs.c:1167
#: ../fs/libfs.c:1202
msgid "the current position in the buffer"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1134 ../fs/libfs.c:1204
msgid "``const void *from``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1133 ../fs/libfs.c:1203
msgid "the buffer to read from"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1135 ../fs/libfs.c:1167
#: ../fs/libfs.c:1205
msgid "``size_t available``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1134 ../fs/libfs.c:1166
#: ../fs/libfs.c:1204
msgid "the size of the buffer"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1135
msgid ""
"The simple_read_from_buffer() function reads up to **count** bytes from the "
"buffer **from** at offset **ppos** into the user space address starting at "
"**to**."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1138 ../fs/libfs.c:1208
msgid ""
"On success, the number of bytes read is returned and the offset **ppos** is "
"advanced by this number, or negative value is returned on error."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1164
msgid "copy data from user space to the buffer"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1170 ../fs/libfs.c:1205
msgid "``void *to``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1165
msgid "the buffer to write to"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1169
msgid "``const void __user *from``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1168
msgid "the user space buffer to read from"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1170
msgid ""
"The simple_write_to_buffer() function reads up to **count** bytes from the "
"user space address starting at **from** into the buffer **to** at offset "
"**ppos**."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1173
msgid ""
"On success, the number of bytes written is returned and the offset **ppos** "
"is advanced by this number, or negative value is returned on error."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1199
msgid "copy data from the buffer"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1200
msgid "the kernel space buffer to read to"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1205
msgid ""
"The memory_read_from_buffer() function reads up to **count** bytes from the "
"buffer **from** at offset **ppos** into the kernel space address starting at "
"**to**."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1434
msgid "generic export_operations->encode_fh function"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1435
msgid "the object to encode"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1437
msgid "``__u32 *fh``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1436
msgid "where to store the file handle fragment"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1438
msgid "``int *max_len``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1437
msgid "maximum length to store there (in 4 byte units)"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1439
msgid "``struct inode *parent``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1438
msgid "parent directory inode, if wanted"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1439
msgid ""
"This generic encode_fh function assumes that the 32 inode number is suitable "
"for locating an inode, and that the generation number can be used to check "
"that it is still valid.  It places them in the filehandle fragment where "
"export_decode_fh expects to find them."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1475
msgid "generic helper for the fh_to_dentry export operation"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1476 ../fs/libfs.c:1508
msgid "filesystem to do the file handle conversion on"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1478 ../fs/libfs.c:1510
msgid "``struct fid *fid``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1477 ../fs/libfs.c:1509
msgid "file handle to convert"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1479 ../fs/libfs.c:1511
msgid "``int fh_len``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1478 ../fs/libfs.c:1510
msgid "length of the file handle in bytes"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1480 ../fs/libfs.c:1512
msgid "``int fh_type``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1479 ../fs/libfs.c:1511
msgid "type of file handle"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1481 ../fs/libfs.c:1513
msgid ""
"``struct inode *(*get_inode) (struct super_block *sb, u64 ino, u32 gen)``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1480 ../fs/libfs.c:1512
msgid "filesystem callback to retrieve inode"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1481
msgid ""
"This function decodes **fid** as long as it has one of the well-known Linux "
"filehandle types and calls **get_inode** on it to retrieve the inode for the "
"object specified in the file handle."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1507
msgid "generic helper for the fh_to_parent export operation"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1513
msgid ""
"This function decodes **fid** as long as it has one of the well-known Linux "
"filehandle types and calls **get_inode** on it to retrieve the inode for the "
"_parent_ object specified in the file handle if it is specified in the file "
"handle, or NULL otherwise."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1540
msgid "generic fsync implementation for simple filesystems"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1542 ../fs/libfs.c:1586
msgid "file to synchronize"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1543 ../fs/libfs.c:1587
msgid "start offset in bytes"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1544 ../fs/libfs.c:1588
msgid "end offset in bytes (inclusive)"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1546 ../fs/libfs.c:1590
#: ../../../filesystems/api-summary:92: ../fs/sync.c:175 ../fs/sync.c:196
msgid "``int datasync``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1545 ../fs/libfs.c:1589
msgid "only synchronize essential metadata if true"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1546
msgid ""
"This is a generic implementation of the fsync method for simple filesystems "
"which track all non-inode metadata in the buffers list hanging off the "
"address_space structure."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1584
msgid "generic fsync implementation for simple filesystems with flush"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1607
msgid "Check addressability of file system"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1613
msgid "``unsigned blocksize_bits``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1608
msgid "log of file system block size"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1610
msgid "``u64 num_blocks``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1609
msgid "number of blocks in file system"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1610
msgid ""
"Determine whether a file system with **num_blocks** blocks (and a block size "
"of 2****blocksize_bits**) is addressable by the sector_t and page cache of "
"the system.  Return 0 if so and -EFBIG otherwise."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1701
msgid "generic helper for prohibiting leases"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1704
msgid "new lease supplied for insertion"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1705
msgid "private data for lm_setup operation"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1706
msgid ""
"Generic helper for filesystems that do not wish to allow leases to be set. "
"All arguments are ignored and it just returns -EINVAL."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1719
msgid "generic helper to get the target of \"fast\" symlinks"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1720 ../fs/libfs.c:1722
msgid "not used here"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1721
msgid "the symlink inode"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1723
msgid ""
"Generic helper for filesystems to use for symlink inodes where a pointer to "
"the symlink target is stored in ->i_link.  NOTE: this isn't normally called, "
"since as an optimization the path lookup code uses any non-NULL ->i_link "
"directly, without calling ->get_link().  But ->get_link() still must be set, "
"to mark the inode_operations as being for a symlink."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1730
msgid "the symlink target"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1813
msgid "generic d_compare implementation for casefolding filesystems"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1814
msgid "dentry whose name we are checking against"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1815
msgid "len of name of dentry"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1817
msgid "``const char *str``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1816
msgid "str pointer to name of dentry"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1817
msgid "Name to compare against"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1819
msgid "0 if names match, 1 if mismatch, or -ERRNO"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1869
msgid "generic d_hash implementation for casefolding filesystems"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1870
msgid "dentry of the parent directory"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1872
msgid "``struct qstr *str``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1871
msgid "qstr of name whose hash we should fill in"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1873
msgid "0 if hash was successful or unchanged, and -EINVAL on error"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1901
msgid ""
"Match a name (case-insensitively) with a dirent. This is a filesystem helper "
"for comparison with directory entries. generic_ci_d_compare should be used "
"in VFS' ->d_compare instead."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1907
msgid "``const struct inode *parent``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1905
msgid "Inode of the parent of the dirent under comparison"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1906
msgid "name under lookup."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1908
msgid "``const struct qstr *folded_name``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1907
msgid "Optional pre-folded name under lookup"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1909
msgid "``const u8 *de_name``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1908
msgid "Dirent name."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1910
msgid "``u32 de_name_len``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1909
msgid "dirent name length."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1910
msgid ""
"Test whether a case-insensitive directory entry matches the filename being "
"searched.  If **folded_name** is provided, it is used instead of "
"recalculating the casefold of **name**."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1915
msgid ""
"> 0 if the directory entry matches, 0 if it doesn't match, or < 0 on error."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1982
msgid ""
"helper for choosing the set of filesystem-wide dentry operations for the "
"enabled features"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1984
msgid "superblock to be configured"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:1985
msgid ""
"Filesystems supporting casefolding and/or fscrypt can call this helper at "
"mount-time to configure default dentry_operations to the best set of dentry "
"operations required for the enabled features. The helper must be called "
"after these have been configured, but before the root dentry is created."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2010
msgid "increments i_version"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2011
msgid "inode with the i_version that should be updated"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2013
msgid "``bool force``"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2012
msgid "increment the counter even if it's not necessary?"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2013
msgid ""
"Every time the inode is modified, the i_version field must be seen to have "
"changed by any observer."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2016
msgid ""
"If \"force\" is set or the QUERIED flag is set, then ensure that we "
"increment the value, and clear the queried flag."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2019
msgid ""
"In the common case where neither is set, then we can return \"false\" "
"without updating i_version."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2022
msgid ""
"If this function returns false, and no other metadata has changed, then we "
"can avoid logging the metadata."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2061
msgid "read i_version for later use"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2062
msgid "inode from which i_version should be read"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2063
msgid ""
"Read the inode i_version counter. This should be used by callers that wish "
"to store the returned i_version for later comparison. This will guarantee "
"that a later query of the i_version will result in a different value if "
"anything has changed."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2068
msgid ""
"In this implementation, we fetch the current value, set the QUERIED flag and "
"then try to swap it into place with a cmpxchg, if it wasn't already set. If "
"that fails, we try again with the newly fetched value from the cmpxchg."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2141
msgid "initialize the timestamps for a new inode"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2142
msgid "inode to be initialized"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2143
msgid ""
"When a new inode is created, most filesystems set the timestamps to the "
"current time. Add a helper to do this."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2312
msgid "prepare to create a given name"
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2315
msgid ""
"Required lock is taken and a lookup in performed prior to creating an object "
"in a directory.  No permission checking is performed."
msgstr ""

#: ../../../filesystems/api-summary:83: ../fs/libfs.c:2319
msgid ""
"a negative dentry on which vfs_create() or similar may be attempted, or an "
"error."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:591
msgid "chmod a posix acl"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:594
msgid "dentry to check permissions on"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:595
msgid "the new mode of **inode**"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:596
msgid ""
"If the dentry has been found through an idmapped mount the idmap of the "
"vfsmount must be passed through **idmap**. This function will then take care "
"to map the inode according to **idmap** before checking permissions. On non-"
"idmapped mounts or if permission checking is to be performed on the raw "
"inode simply pass **nop_mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:684
msgid "update mode in set_acl"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:688
msgid "``umode_t *mode_p``"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:687
msgid "mode (pointer) for update"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:689
msgid "``struct posix_acl **acl``"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:688
msgid "acl pointer"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:689
msgid ""
"Update the file mode when setting an ACL: compute the new file permission "
"bits based on the ACL.  In addition, if the ACL is equivalent to the new "
"file mode, set ***acl** to NULL to indicate that no ACL should be set."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:693
msgid ""
"As with chmod, clear the setgid bit if the caller is not in the owning group "
"or capable of CAP_FSETID (see inode_change_ok)."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:702
msgid "Called from set_acl inode operations."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:750
msgid "convert POSIX ACLs from backing store to VFS format"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:756
msgid "``struct user_namespace *userns``"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:751
msgid "the filesystem's idmapping"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:753
#: ../../../filesystems/api-summary:95: ../fs/xattr.c:269
msgid "``const void *value``"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:752
msgid "the uapi representation of POSIX ACLs"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:753
msgid "the size of **void**"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:754
msgid ""
"Filesystems that store POSIX ACLs in the unaltered uapi format should use "
"posix_acl_from_xattr() when reading them from the backing store and "
"converting them into the struct posix_acl VFS format. The helper is "
"specifically intended to be called from the acl inode operation."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:759
msgid ""
"The posix_acl_from_xattr() function will map the raw {g,u}id values stored "
"in ACL_{GROUP,USER} entries into idmapping in **userns**."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:762
msgid ""
"Note that posix_acl_from_xattr() does not take idmapped mounts into account. "
"If it did it calling it from the get acl inode operation would return POSIX "
"ACLs mapped according to an idmapped mount which would mean that the value "
"couldn't be cached for the filesystem. Idmapped mounts are taken into "
"account on the fly during permission checking or right at the VFS - "
"userspace boundary before reporting them to the user."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:770
msgid ""
"Allocated struct posix_acl on success, NULL for a valid header but without "
"actual POSIX ACL entries, or ERR_PTR() encoded error code."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1077
msgid "set posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1079
msgid "the dentry based on which to set the posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1081
#: ../fs/posix_acl.c:1159 ../fs/posix_acl.c:1204
msgid "``const char *acl_name``"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1080
#: ../fs/posix_acl.c:1158 ../fs/posix_acl.c:1203
msgid "the name of the posix acl"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1082
msgid "``struct posix_acl *kacl``"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1081
msgid "the posix acls in the appropriate VFS format"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1082
msgid ""
"This function sets **kacl**. The caller must all posix_acl_release() on "
"**kacl** afterwards."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1086
#: ../fs/posix_acl.c:1207
msgid "On success 0, on error negative errno."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1155
msgid "get posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1157
#: ../fs/posix_acl.c:1202
msgid "the dentry based on which to retrieve the posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1159
msgid ""
"This function retrieves **kacl** from the filesystem. The caller must all "
"posix_acl_release() on **kacl**."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1163
msgid "On success POSIX ACLs in VFS format, on error negative errno."
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1200
msgid "remove posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: ../fs/posix_acl.c:1204
msgid "This function removes posix acls."
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:32
msgid "Fill in the mtime and ctime and flag ctime as QUERIED"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:38 ../fs/stat.c:71
#: ../fs/stat.c:120 ../fs/stat.c:141 ../fs/stat.c:172
msgid "``struct kstat *stat``"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:33
msgid "where to store the resulting values"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:35 ../fs/stat.c:69
#: ../fs/stat.c:173
msgid "``u32 request_mask``"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:34
msgid "STATX_* values requested"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:35
msgid "inode from which to grab the c/mtime"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:36
msgid ""
"Given **inode**, grab the ctime and mtime out if it and store the result in "
"**stat**. When fetching the value, flag it as QUERIED (if not already) so "
"the next write will record a distinct timestamp."
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:40
msgid ""
"NB: The QUERIED flag is tracked in the ctime, but we set it there even if "
"only the mtime was requested, as that ensures that the next mtime change "
"will be distinct."
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:66
msgid "Fill in the basic attributes from the inode struct"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:68
msgid "statx request_mask"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:69 ../fs/stat.c:118
msgid "Inode to use as the source"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:70
msgid "Where to fill in the attributes"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:71
msgid ""
"Fill in the basic attributes in the kstat structure from data that's to be "
"found on the VFS inode structure.  This is the default if no getattr inode "
"operation is supplied."
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:75
msgid ""
"If the inode has been found through an idmapped mount the idmap of the "
"vfsmount must be passed through **idmap**. This function will then take care "
"to map the inode according to **idmap** before filling in the uid and gid "
"filds. On non-idmapped mounts or if permission checking is to be performed "
"on the raw inode simply pass **nop_mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:117
msgid "Fill in the statx attributes from the inode flags"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:119 ../fs/stat.c:136
msgid "Where to fill in the attribute flags"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:120
msgid ""
"Fill in the STATX_ATTR_* flags in the kstat structure for properties of the "
"inode that are published on i_flags and enforced by the VFS."
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:135
msgid "Fill in atomic writes statx attributes"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:138
msgid "``unsigned int unit_min``"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:137
msgid "Minimum supported atomic write length in bytes"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:139
msgid "``unsigned int unit_max``"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:138
msgid "Maximum supported atomic write length in bytes"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:140
msgid "``unsigned int unit_max_opt``"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:139
msgid "Optimised maximum supported atomic write length in bytes"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:140
msgid ""
"Fill in the STATX{_ATTR}_WRITE_ATOMIC flags in the kstat structure from "
"atomic write unit_min and unit_max values."
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:169
msgid "getattr without security checks"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:170
msgid "file to get attributes from"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:171
msgid "structure to return attributes in"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:172
msgid "STATX_xxx flags indicating what the caller wants"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:174
msgid "``unsigned int query_flags``"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:173
msgid "Query mode (AT_STATX_SYNC_TYPE)"
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:174
msgid "Get attributes without calling security_inode_getattr."
msgstr ""

#: ../../../filesystems/api-summary:89: ../fs/stat.c:176
msgid ""
"Currently the only caller other than vfs_getattr is internal to the "
"filehandle lookup code, which uses only the inode number and returns no "
"attributes to any user.  Any other code probably wants vfs_getattr."
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:170
msgid "helper to sync a range of data & metadata to disk"
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:171 ../fs/sync.c:194
msgid "file to sync"
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:172
msgid "offset in bytes of the beginning of data range to sync"
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:173
msgid "offset in bytes of the end of data range (inclusive)"
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:174
msgid "perform only datasync"
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:175
msgid ""
"Write back data in range **start**..**end** and metadata for **file** to "
"disk.  If **datasync** is set only metadata needed to access modified file "
"data is written."
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:193
msgid "perform a fsync or fdatasync on a file"
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:195
msgid "only perform a fdatasync operation"
msgstr ""

#: ../../../filesystems/api-summary:92: ../fs/sync.c:196
msgid ""
"Write back data and metadata for **file** to disk.  If **datasync** is set "
"only metadata needed to access modified file data is written."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:262 ../fs/xattr.c:524
msgid "set an extended attribute while holding the inode lock"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:265 ../fs/xattr.c:527
msgid "idmap of the mount of the target inode"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:266 ../fs/xattr.c:528
msgid "object to perform setxattr on"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:267
msgid "xattr name to set"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:268
msgid "value to set **name** to"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:269
msgid "size of **value**"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:270
msgid "flags to pass into filesystem operations"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:271 ../fs/xattr.c:530
msgid ""
"on return, will contain an inode pointer that a delegation was broken on, "
"NULL if none."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:461
msgid "retrieve \\0 separated list of xattr names"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:462
msgid "the dentry from whose inode the xattr names are retrieved"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:464
msgid "``char *list``"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:463
msgid "buffer to store xattr names into"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:464
msgid "size of the buffer"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:465
msgid ""
"This function returns the names of all xattrs associated with the inode of "
"**dentry**."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:468
msgid ""
"Note, for legacy reasons the vfs_listxattr() function lists POSIX ACLs as "
"well. Since POSIX ACLs are decoupled from IOP_XATTR the vfs_listxattr() "
"function doesn't check for this flag since a filesystem could implement "
"POSIX ACLs without implementing any other xattrs."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:474
msgid ""
"However, since all codepaths that remove IOP_XATTR also assign of inode "
"operations that either don't implement or implement a stub ->listxattr() "
"operation."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:479
msgid ""
"On success, the size of the buffer that was used. On error a negative error "
"code."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:529
msgid "name of xattr to remove"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1130
msgid "run through a dentry's xattr list() operations"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1131
msgid "dentry to list the xattrs"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1133
msgid "``char *buffer``"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1132
msgid "result buffer"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1134
msgid "``size_t buffer_size``"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1133
msgid "size of **buffer**"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1134
msgid ""
"Combine the results of the list() operation from every xattr_handler in the "
"xattr_handler stack."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1137
msgid "Note that this will not include the entries for POSIX ACLs."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1161
msgid "Compute full attribute name from suffix"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1167
msgid "``const struct xattr_handler *handler``"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1163
msgid "handler of the xattr_handler operation"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1164
msgid "name passed to the xattr_handler operation"
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1165
msgid ""
"The get and set xattr handler operations are called with the remainder of "
"the attribute name after skipping the handler's prefix: for example, \"foo\" "
"is passed to the get operation of a handler with prefix \"user.\" to get "
"attribute \"user.foo\".  The full name is still \"there\" in the name though."
msgstr ""

#: ../../../filesystems/api-summary:95: ../fs/xattr.c:1171
msgid ""
"the list xattr handler operation when called from the vfs is passed a NULL "
"name; some file systems use this operation internally, with varying "
"semantics."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:428
msgid "get write access to a mount without freeze protection"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:434
#: ../fs/namespace.c:493 ../fs/namespace.c:1587
msgid "``struct vfsmount *m``"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:429
#: ../fs/namespace.c:488
msgid "the mount on which to take a write"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:430
msgid ""
"This tells the low-level filesystem that a write is about to be performed to "
"it, and makes sure that writes are allowed (mnt it read-write) before "
"returning success. This operation does not protect against filesystem being "
"frozen. When the write operation is finished, mnt_put_write_access() must be "
"called. This is effectively a refcount."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:487
msgid "get write access to a mount"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:489
msgid ""
"This tells the low-level filesystem that a write is about to be performed to "
"it, and makes sure that writes are allowed (mount is read-write, filesystem "
"is not frozen) before returning success.  When the write operation is "
"finished, mnt_drop_write() must be called.  This is effectively a refcount."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:531
msgid "get write access to a file's mount"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:532
msgid "the file who's mount on which to take a write"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:533
msgid ""
"This is like mnt_want_write, but if the file is already open for writing it "
"skips incrementing mnt_writers (since the open file already has a reference) "
"and instead only does the freeze protection and the check for emergency r/o "
"remounts.  This must be paired with mnt_drop_write_file."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:552
#: ../fs/namespace.c:568
msgid "give up write access to a mount"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:553
#: ../fs/namespace.c:569
msgid "the mount on which to give up write access"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:554
msgid ""
"Tells the low-level filesystem that we are done performing writes to it.  "
"Must be matched with mnt_get_write_access() call above."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:570
msgid ""
"Tells the low-level filesystem that we are done performing writes to it and "
"also allows filesystem to be frozen again.  Must be matched with "
"mnt_want_write() call above."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1169
msgid "Create a mount for a configured superblock"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1170
msgid "The configuration context with the superblock attached"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1171
msgid ""
"Create a mount to an already configured superblock.  If necessary, the "
"caller should invoke vfs_get_tree() before calling this."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1174
msgid "Note that this does not attach the mount to anything."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1447
msgid "Check if path is a mount in the current namespace."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1448
msgid "path to check"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1449
msgid ""
"d_mountpoint() can only be used reliably to establish if a dentry is not "
"mounted in any namespace and that common case is handled inline. "
"d_mountpoint() isn't aware of the possibility there may be multiple mounts "
"using a given dentry in a different namespace. This function checks if the "
"passed in path is a mountpoint rather than the dentry alone."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1581
msgid "check if a mount tree is busy"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1582
msgid "root of mount tree"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1583
msgid ""
"This is called to check if a tree of mounts has any open files, pwds, "
"chroots or sub mounts that are busy."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1609
msgid "check if a mount point is busy"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1610
msgid "root of mount"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1611
msgid ""
"This is called to check if a mount point has any open files, pwds, chroots "
"or sub mounts. If the mount has sub mounts this will return busy regardless "
"of whether the sub mounts are busy."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:1616
msgid ""
"Doesn't take quota and stuff into account. IOW, in some cases it will give "
"false negatives. The main reason why it's here is that we need a non-"
"destructive way to look for easily umountable filesystems."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:2356
msgid "create a private clone of a path"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:2357
msgid "path to clone"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:2358
msgid ""
"This creates a new vfsmount, which will be the clone of **path**.  The new "
"mount will not be attached anywhere in the namespace and will be private (i."
"e. changes to the originating mount won't be propagated into this)."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:2362
msgid "This assumes caller has called or done the equivalent of may_mount()."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:2364
msgid "Release with mntput()."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:3773
msgid "Put a mount on an expiration list"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:3774
msgid "The mount to list."
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:3776
msgid "``struct list_head *expiry_list``"
msgstr ""

#: ../../../filesystems/api-summary:98: ../fs/namespace.c:3775
msgid "The list to add the mount to."
msgstr ""

#: ../../../filesystems/api-summary.rst:102
msgid "The proc filesystem"
msgstr ""

#: ../../../filesystems/api-summary.rst:105
msgid "sysctl interface"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:173
msgid "read a string sysctl"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:179
#: ../kernel/sysctl.c:587 ../kernel/sysctl.c:627 ../kernel/sysctl.c:646
#: ../kernel/sysctl.c:666 ../kernel/sysctl.c:690 ../kernel/sysctl.c:717
#: ../kernel/sysctl.c:850 ../kernel/sysctl.c:880
msgid "``const struct ctl_table *table``"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:174
#: ../kernel/sysctl.c:582 ../kernel/sysctl.c:622 ../kernel/sysctl.c:641
#: ../kernel/sysctl.c:661 ../kernel/sysctl.c:685 ../kernel/sysctl.c:712
#: ../kernel/sysctl.c:845 ../kernel/sysctl.c:875
msgid "the sysctl table"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:176
#: ../kernel/sysctl.c:584 ../kernel/sysctl.c:624 ../kernel/sysctl.c:643
#: ../kernel/sysctl.c:663 ../kernel/sysctl.c:687 ../kernel/sysctl.c:714
#: ../kernel/sysctl.c:847 ../kernel/sysctl.c:877
msgid "``int dir``"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:175
#: ../kernel/sysctl.c:583 ../kernel/sysctl.c:623 ../kernel/sysctl.c:642
#: ../kernel/sysctl.c:662 ../kernel/sysctl.c:686 ../kernel/sysctl.c:713
#: ../kernel/sysctl.c:846 ../kernel/sysctl.c:876
msgid "``TRUE`` if this is a write to the sysctl file"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:177
#: ../kernel/sysctl.c:585 ../kernel/sysctl.c:625 ../kernel/sysctl.c:644
#: ../kernel/sysctl.c:664 ../kernel/sysctl.c:688 ../kernel/sysctl.c:715
#: ../kernel/sysctl.c:848 ../kernel/sysctl.c:878
msgid "``void *buffer``"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:176
#: ../kernel/sysctl.c:584 ../kernel/sysctl.c:624 ../kernel/sysctl.c:643
#: ../kernel/sysctl.c:663 ../kernel/sysctl.c:687 ../kernel/sysctl.c:714
#: ../kernel/sysctl.c:847 ../kernel/sysctl.c:877
msgid "the user buffer"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:178
#: ../kernel/sysctl.c:586 ../kernel/sysctl.c:626 ../kernel/sysctl.c:645
#: ../kernel/sysctl.c:665 ../kernel/sysctl.c:689 ../kernel/sysctl.c:716
#: ../kernel/sysctl.c:849 ../kernel/sysctl.c:879
msgid "``size_t *lenp``"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:177
#: ../kernel/sysctl.c:585 ../kernel/sysctl.c:625 ../kernel/sysctl.c:644
#: ../kernel/sysctl.c:664 ../kernel/sysctl.c:688 ../kernel/sysctl.c:715
#: ../kernel/sysctl.c:848 ../kernel/sysctl.c:878
msgid "the size of the user buffer"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:179
msgid ""
"Reads/writes a string from/to the user buffer. If the kernel buffer provided "
"is not large enough to hold the string, the string is truncated. The copied "
"string is ``NULL-terminated``. If the string is being read by the user "
"process, it is copied and a newline '\\n' is added. It is truncated if the "
"buffer is not large enough."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:186
#: ../kernel/sysctl.c:593 ../kernel/sysctl.c:630 ../kernel/sysctl.c:649
#: ../kernel/sysctl.c:856 ../kernel/sysctl.c:887
msgid "Returns 0 on success."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:581
msgid "read/write a bool"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:587
msgid ""
"Reads/writes one integer value from/to the user buffer, treated as an ASCII "
"string."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:590
msgid ""
"table->data must point to a bool variable and table->maxlen must be "
"sizeof(bool)."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:621
msgid "read a vector of integers"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:627
#: ../kernel/sysctl.c:666
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) integer values from/to "
"the user buffer, treated as an ASCII string."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:640
msgid "read a vector of unsigned integers"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:646
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer "
"values from/to the user buffer, treated as an ASCII string."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:660
msgid "read a vector of integers with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:669
#: ../kernel/sysctl.c:721 ../kernel/sysctl.c:853
msgid ""
"This routine will ensure the values are within the range specified by table-"
">extra1 (min) and table->extra2 (max)."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:672
msgid ""
"Returns 0 on success or -EINVAL when the range check fails and "
"SYSCTL_USER_TO_KERN(dir) == true"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:684
msgid "read a vector of unsigned ints with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:690
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer "
"values from/to the user buffer, treated as an ASCII string. Negative strings "
"are not allowed."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:694
msgid ""
"This routine will ensure the values are within the range specified by table-"
">extra1 (min) and table->extra2 (max). There is a final sanity check for "
"UINT_MAX to avoid having to support wrap around uses from userspace."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:699
msgid ""
"Returns 0 on success or -ERANGE when range check failes and "
"SYSCTL_USER_TO_KERN(dir) == true"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:711
msgid "read a vector of unsigned chars with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:717
msgid ""
"Reads/writes up to table->maxlen/sizeof(u8) unsigned chars values from/to "
"the user buffer, treated as an ASCII string. Negative strings are not "
"allowed."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:724
msgid ""
"Returns 0 on success or an error on SYSCTL_USER_TO_KERN(dir) == true and the "
"range check fails."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:844
msgid "read a vector of long integers with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:850
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long values "
"from/to the user buffer, treated as an ASCII string."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:874
msgid "read/write from/to a large bitmap"
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:880
msgid ""
"The bitmap is stored at table->data and the bitmap length (in bits) in table-"
">maxlen."
msgstr ""

#: ../../../filesystems/api-summary:107: ../kernel/sysctl.c:883
msgid ""
"We use a range comma separated format (e.g. 1,3-4,10-10) so that large "
"bitmaps may be represented in a compact manner. Writing into the file will "
"clear the bitmap then update it with the given input."
msgstr ""

#: ../../../filesystems/api-summary.rst:111
msgid "proc filesystem interface"
msgstr ""

#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3458
msgid "Remove dcache entries for **pid** from the /proc dcache."
msgstr ""

#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3464
msgid "``struct pid *pid``"
msgstr ""

#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3459
msgid "pid that should be flushed."
msgstr ""

#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3460
msgid ""
"This function walks a list of inodes (that belong to any proc filesystem) "
"that are attached to the pid and flushes them from the dentry cache."
msgstr ""

#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3464
msgid ""
"It is safe and reasonable to cache /proc entries for a task until that task "
"exits.  After that they just clog up the dcache with useless entries, "
"possibly causing useful dcache entries to be flushed instead.  This routine "
"is provided to flush those useless dcache entries when a process is reaped."
msgstr ""

#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3471
msgid "This routine is just an optimization so it does not guarantee"
msgstr ""

#: ../../../filesystems/api-summary:113: ../fs/proc/base.c:3472
msgid ""
"that no dcache entries will exist after a process is reaped it just makes it "
"very unlikely that any will persist."
msgstr ""

#: ../../../filesystems/api-summary.rst:117
msgid "Events based on file descriptors"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:47
msgid "Increment the event counter"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:53 ../fs/eventfd.c:103
#: ../fs/eventfd.c:192
msgid "``struct eventfd_ctx *ctx``"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:48
msgid "[in] Pointer to the eventfd context."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:50
msgid "``__poll_t mask``"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:49
msgid "[in] poll mask"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:50
msgid ""
"This function is supposed to be called by the kernel in paths that do not "
"allow sleeping. In this function we allow the counter to reach the "
"ULLONG_MAX value, and we signal this as overflow condition by returning a "
"EPOLLERR to poll(2)."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:97
msgid "Releases a reference to the internal eventfd context."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:98 ../fs/eventfd.c:187
msgid "[in] Pointer to eventfd context."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:99
msgid ""
"The eventfd context reference must have been previously acquired either with "
"eventfd_ctx_fdget() or eventfd_ctx_fileget()."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:186
msgid "Read the current counter and removes wait queue."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:189
msgid "``wait_queue_entry_t *wait``"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:188
msgid "[in] Wait queue to be removed."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:190
msgid "``__u64 *cnt``"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:189
msgid "[out] Pointer to the 64-bit counter value."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:190
msgid "Returns ``0`` if successful, or the following error codes:"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:192
msgid ": The operation would have blocked."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:194
msgid ""
"This is used to atomically remove a wait queue entry from the eventfd wait "
"queue head, and read/reset the counter value."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:314
msgid "Acquire a reference of an eventfd file descriptor."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:320
#: ../fs/eventfd.c:346
msgid "``int fd``"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:315
#: ../fs/eventfd.c:341
msgid "[in] Eventfd file descriptor."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:316
msgid ""
"Returns a pointer to the eventfd file structure in case of success, or the "
"following error pointer:"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:319
msgid ": Invalid **fd** file descriptor."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:320
#: ../fs/eventfd.c:363
msgid ": The **fd** file descriptor is not an eventfd file."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:340
#: ../fs/eventfd.c:358
msgid "Acquires a reference to the internal eventfd context."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:342
msgid ""
"Returns a pointer to the internal eventfd context, otherwise the error "
"pointers returned by the following functions:"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:345
msgid "eventfd_fget"
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:359
msgid "[in] Eventfd file pointer."
msgstr ""

#: ../../../filesystems/api-summary:119: ../fs/eventfd.c:360
msgid ""
"Returns a pointer to the internal eventfd context, otherwise the error "
"pointer:"
msgstr ""

#: ../../../filesystems/api-summary.rst:123
msgid "eventpoll (epoll) interfaces"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:383
msgid "Checks if ready events might be available."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:389
#: ../fs/eventpoll.c:404 ../fs/eventpoll.c:1926 ../fs/eventpoll.c:2063
#: ../fs/eventpoll.c:2128
msgid "``struct eventpoll *ep``"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:385
#: ../fs/eventpoll.c:403 ../fs/eventpoll.c:1923
msgid "Pointer to the eventpoll context."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:387
msgid ""
"a value different than ``zero`` if ready events are available, or ``zero`` "
"otherwise."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:398
msgid ""
"check if busy poll has timed out. The timeout value from the epoll instance "
"ep is preferred, but if it is not set fallback to the system-wide global via "
"busy_loop_timeout."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:404
msgid "``unsigned long start_time``"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:402
msgid "The start time used to compute the remaining time until timeout."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:405
msgid "true if the timeout has expired, false otherwise."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1464
msgid ""
"The tfile_check_list is list of epitem_head, which have links that are "
"proposed to be newly added. We need to make sure that those added links "
"don't add too many paths such that we will spend all our time waking up "
"eventpoll objects."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1470
#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:880
msgid "``void``"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1
#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:1
msgid "no arguments"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1470
msgid ""
"``zero`` if the proposed links don't create too many paths, ``-1`` otherwise."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1920
msgid ""
"Retrieves ready events, and delivers them to the caller-supplied event "
"buffer."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1925
msgid "``struct epoll_event __user *events``"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1924
msgid ""
"Pointer to the userspace buffer where the ready events should be stored."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1927
msgid "``int maxevents``"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1926
msgid "Size (in terms of number of events) of the caller event buffer."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1928
msgid "``struct timespec64 *timeout``"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1927
msgid ""
"Maximum timeout for the ready events fetch operation, in timespec. If the "
"timeout is zero, the function will not block, while if the **timeout** ptr "
"is NULL, the function will block until at least one event has been retrieved "
"(or an error occurred)."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:1933
msgid ""
"the number of ready events which have been fetched, or an error code, in "
"case of error."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2057
msgid ""
"verify that adding an epoll file **ep** inside another epoll file does not "
"create closed loops, and determine the depth of the subtree starting at "
"**ep**"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2061
msgid "the :c:type:`struct eventpoll <eventpoll>` to be currently checked."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2063
msgid "``int depth``"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2062
msgid "Current depth of the path being checked."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2064
msgid "depth of the subtree, or INT_MAX if we found a loop or went too deep."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2122
msgid ""
"Performs a check to verify that adding an epoll file (**to**) into another "
"epoll file (represented by **ep**) does not create closed loops or too deep "
"chains."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2126
msgid "Pointer to the epoll we are inserting into."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2128
msgid "``struct eventpoll *to``"
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2127
msgid "Pointer to the epoll to be inserted."
msgstr ""

#: ../../../filesystems/api-summary:125: ../fs/eventpoll.c:2129
msgid ""
"``zero`` if adding the epoll **to** inside the epoll **from** does not "
"violate the constraints, or ``-1`` otherwise."
msgstr ""

#: ../../../filesystems/api-summary.rst:129
msgid "The Filesystem for Exporting Kernel Objects"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:359
msgid "create an attribute file for an object with custom ns"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:365
#: ../fs/sysfs/file.c:399 ../fs/sysfs/file.c:432 ../fs/sysfs/file.c:460
#: ../fs/sysfs/file.c:506 ../fs/sysfs/file.c:523 ../fs/sysfs/file.c:556
#: ../fs/sysfs/file.c:581 ../fs/sysfs/file.c:601 ../fs/sysfs/file.c:665
#: ../fs/sysfs/file.c:701 ../fs/sysfs/file.c:799
#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:90
#: ../fs/sysfs/symlink.c:103 ../fs/sysfs/symlink.c:145
#: ../fs/sysfs/symlink.c:163
msgid "``struct kobject *kobj``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:360
msgid "object we're creating for"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:362
#: ../fs/sysfs/file.c:396 ../fs/sysfs/file.c:429 ../fs/sysfs/file.c:457
#: ../fs/sysfs/file.c:503 ../fs/sysfs/file.c:520 ../fs/sysfs/file.c:553
msgid "``const struct attribute *attr``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:361
#: ../fs/sysfs/file.c:502 ../fs/sysfs/file.c:519
msgid "attribute descriptor"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:363
#: ../fs/sysfs/file.c:504
msgid "``const void *ns``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:362
msgid "namespace the new file should belong to"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:393
msgid "add an attribute file to a pre-existing group."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:394
#: ../fs/sysfs/file.c:427 ../fs/sysfs/file.c:551
#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:140
#: ../fs/sysfs/symlink.c:158
msgid "object we're acting for."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:395
#: ../fs/sysfs/file.c:428 ../fs/sysfs/file.c:552 ../fs/sysfs/file.c:577
#: ../fs/sysfs/file.c:597 ../fs/sysfs/file.c:799
msgid "attribute descriptor."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:397
#: ../fs/sysfs/file.c:554
msgid "``const char *group``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:396
#: ../fs/sysfs/file.c:553
msgid "group name."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:426
msgid "update the modified mode value on an object attribute."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:429
msgid "file permissions."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:454
msgid "break \"active\" protection"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:455
msgid "The kernel object **attr** is associated with."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:456
msgid "The attribute to break the \"active\" protection for."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:457
msgid ""
"With sysfs, just like kernfs, deletion of an attribute is postponed until "
"all active .show() and .store() callbacks have finished unless this function "
"is called. Hence this function is useful in methods that implement self "
"deletion."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:479
msgid "restore \"active\" protection"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:485
msgid "``struct kernfs_node *kn``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:480
msgid "Pointer returned by sysfs_break_active_protection()."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:481
msgid ""
"Undo the effects of sysfs_break_active_protection(). Since this function "
"calls kernfs_put() on the kernfs node that corresponds to the 'attr' "
"argument passed to sysfs_break_active_protection() that attribute may have "
"been removed between the sysfs_break_active_protection() and "
"sysfs_unbreak_active_protection() calls, it is not safe to access **kn** "
"after this function has returned."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:500
msgid "remove an object attribute with a custom ns tag"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:501
#: ../fs/sysfs/file.c:518
msgid "object we're acting for"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:503
msgid "namespace tag of the file to remove"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:504
msgid "Hash the attribute name and namespace tag and kill the victim."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:517
msgid "remove an object attribute from its own method"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:520
msgid "See kernfs_remove_self() for details."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:550
msgid "remove an attribute file from a group."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:575
msgid "create binary file for object."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:576
#: ../fs/sysfs/file.c:596 ../fs/sysfs/file.c:660 ../fs/sysfs/file.c:696
msgid "object."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:578
#: ../fs/sysfs/file.c:598 ../fs/sysfs/file.c:800
msgid "``const struct bin_attribute *attr``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:595
msgid "remove binary file for object."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:659
msgid "change owner of a sysfs file."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:661
msgid "name of the file to change."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:663
#: ../fs/sysfs/file.c:698
msgid "``kuid_t kuid``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:662
#: ../fs/sysfs/file.c:697
msgid "new owner's kuid"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:664
#: ../fs/sysfs/file.c:699
msgid "``kgid_t kgid``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:663
#: ../fs/sysfs/file.c:698
msgid "new owner's kgid"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:664
msgid ""
"This function looks up the sysfs entry **name** under **kobj** and changes "
"the ownership to **kuid**/**kgid**."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:667
#: ../fs/sysfs/file.c:709
msgid "Returns 0 on success or error code on failure."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:695
msgid "change owner of the given object."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:699
msgid ""
"Change the owner of the default directory, files, groups, and attributes of "
"**kobj** to **kuid**/**kgid**. Note that sysfs_change_owner mirrors how the "
"sysfs entries for a kobject are added by driver core. In summary, "
"sysfs_change_owner() takes care of the default directory entry for **kobj**, "
"the default attributes associated with the ktype of **kobj** and the default "
"attributes associated with the ktype of **kobj**. Additional properties not "
"added by driver core have to be changed by the driver or subsystem which "
"created them. This is similar to how driver/subsystem specific entries are "
"removed."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:742
#: ../fs/sysfs/file.c:768
msgid "scnprintf equivalent, aware of PAGE_SIZE buffer."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:743
#: ../fs/sysfs/file.c:769
msgid "start of PAGE_SIZE buffer."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:745
#: ../fs/sysfs/file.c:773 ../../../filesystems/api-summary:143:
#: ../fs/debugfs/inode.c:812
msgid "``const char *fmt``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:744
#: ../fs/sysfs/file.c:772
msgid "format"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:746
#: ../fs/sysfs/file.c:774 ../../../filesystems/api-summary:143:
#: ../fs/debugfs/inode.c:813
msgid "``...``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:745
msgid "optional arguments to **format**"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:746
msgid "Returns number of characters written to **buf**."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:771
msgid "``int at``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:770
msgid ""
"offset in **buf** to start write in bytes **at** must be >= 0 && < PAGE_SIZE"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:773
msgid "optional arguments to **fmt**"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:774
msgid "Returns number of characters written starting at &**buf**[**at**]."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:796
msgid "read callback to simply copy from memory."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:797
msgid "attribute file which is being read."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:798
msgid "object to which the attribute belongs."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:800
msgid "destination buffer."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:802
msgid "``loff_t off``"
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:801
msgid "offset in bytes from which to read."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:802
msgid "maximum number of bytes to read."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:803
msgid ""
"Simple ->read() callback for bin_attributes backed by a buffer in memory. "
"The **private** and **size** members in struct bin_attribute must be set to "
"the buffer's location and size before the bin_attribute is created in sysfs."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:807
msgid ""
"Bounds check for **off** and **count** is done in sysfs_kf_bin_read(). "
"Negative value check for **off** is done in vfs_setpos() and "
"default_llseek()."
msgstr ""

#: ../../../filesystems/api-summary:131: ../fs/sysfs/file.c:810
msgid "Returns number of bytes written to **buf**."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:84
#: ../fs/sysfs/symlink.c:97
msgid "create symlink between two objects."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:85
#: ../fs/sysfs/symlink.c:98
msgid "object whose directory we're creating the link in."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:87
#: ../fs/sysfs/symlink.c:100
msgid "``struct kobject *target``"
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:86
#: ../fs/sysfs/symlink.c:99 ../fs/sysfs/symlink.c:159
msgid "object we're pointing to."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:87
#: ../fs/sysfs/symlink.c:100
msgid "name of the symlink."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:101
msgid ""
"This function does the same as sysfs_create_link(), but it doesn't warn if "
"the link already exists."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:139
msgid "remove symlink in object's directory."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:141
msgid "name of the symlink to remove."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:157
msgid "rename symlink in object's directory."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:160
msgid "``struct kobject *targ``"
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:161
msgid "``const char *old``"
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:160
msgid "previous name of the symlink."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:162
msgid "``const char *new``"
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:161
msgid "new name of the symlink."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:163
msgid "``const void *new_ns``"
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:162
msgid "new namespace of the symlink."
msgstr ""

#: ../../../filesystems/api-summary:134: ../fs/sysfs/symlink.c:163
msgid "A helper function for the common rename symlink idiom."
msgstr ""

#: ../../../filesystems/api-summary.rst:138
msgid "The debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary.rst:141
msgid "debugfs interface"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:334
msgid "look up an existing debugfs file"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:335
msgid "a pointer to a string containing the name of the file to look up."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:336
msgid "a pointer to the parent dentry of the file."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:337
msgid ""
"This function will return a pointer to a dentry if it succeeds.  If the file "
"doesn't exist or an error occurs, ``NULL`` will be returned.  The returned "
"dentry must be passed to dput() when it is no longer needed."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:341
#: ../fs/debugfs/inode.c:561 ../fs/debugfs/inode.c:659
#: ../fs/debugfs/inode.c:817
msgid ""
"If debugfs is not enabled in the kernel, the value -``ENODEV`` will be "
"returned."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:478
#: ../fs/debugfs/inode.c:516
msgid "create a file in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:479
#: ../fs/debugfs/inode.c:517 ../fs/debugfs/inode.c:600
#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:594
#: ../fs/debugfs/file.c:630 ../fs/debugfs/file.c:666 ../fs/debugfs/file.c:703
#: ../fs/debugfs/file.c:742 ../fs/debugfs/file.c:791 ../fs/debugfs/file.c:809
#: ../fs/debugfs/file.c:827 ../fs/debugfs/file.c:845 ../fs/debugfs/file.c:879
#: ../fs/debugfs/file.c:915 ../fs/debugfs/file.c:996 ../fs/debugfs/file.c:1124
#: ../fs/debugfs/file.c:1186 ../fs/debugfs/file.c:1282
#: ../fs/debugfs/file.c:1360
msgid "a pointer to a string containing the name of the file to create."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:480
#: ../fs/debugfs/inode.c:518 ../../../filesystems/api-summary:146:
#: ../fs/debugfs/file.c:1283
msgid "the permission that the file should have."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:481
#: ../fs/debugfs/inode.c:519 ../fs/debugfs/inode.c:601
msgid ""
"a pointer to the parent dentry for this file.  This should be a directory "
"dentry if set.  If this parameter is NULL, then the file will be created in "
"the root of the debugfs filesystem."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:484
#: ../fs/debugfs/inode.c:522
msgid ""
"a pointer to something that the caller will want to get to later on.  The "
"inode.i_private pointer will point to this value on the open() call."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:487
#: ../fs/debugfs/inode.c:525
msgid ""
"a pointer to a struct file_operations that should be used for this file."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:489
msgid ""
"debugfs_create_file_unsafe() is completely analogous to "
"debugfs_create_file(), the only difference being that the fops handed it "
"will not get protected against file removals by the debugfs core."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:494
msgid ""
"It is your responsibility to protect your struct file_operation methods "
"against file removals by means of debugfs_file_get() and debugfs_file_put(). "
"->open() is still protected by debugfs though."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:499
msgid ""
"Any struct file_operations defined by means of DEFINE_DEBUGFS_ATTRIBUTE() is "
"protected against file removals and thus, may be used here."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:528
msgid "``loff_t file_size``"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:527
msgid "initial file size"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:528
msgid ""
"This is the basic \"create a file\" function for debugfs.  It allows for a "
"wide range of flexibility in creating a file, or a directory (if you want to "
"create a directory, the debugfs_create_dir() function is recommended to be "
"used instead.)"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:547
msgid "create a directory in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:548
msgid "a pointer to a string containing the name of the directory to create."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:550
msgid ""
"a pointer to the parent dentry for this file.  This should be a directory "
"dentry if set.  If this parameter is NULL, then the directory will be "
"created in the root of the debugfs filesystem."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:553
msgid "This function creates a directory in debugfs with the given name."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:555
#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1197
msgid ""
"This function will return a pointer to a dentry if it succeeds.  This "
"pointer must be passed to the debugfs_remove() function when the file is to "
"be removed (no automatic cleanup happens if your module is unloaded, you are "
"responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be returned."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:565
msgid ""
"it's expected that most callers should _ignore_ the errors returned by this "
"function. Other debugfs functions handle the fact that the \"dentry\" passed "
"to them could be an error and they don't crash in that case. Drivers should "
"generally work fine even if debugfs fails to init anyway."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:599
msgid "create automount point in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:605
msgid "``debugfs_automount_t f``"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:604
msgid "function to be called when pathname resolution steps on that one."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:605
msgid "opaque argument to pass to f()."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:606
msgid "**f** should return what ->d_automount() would."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:641
msgid "create a symbolic link in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:642
msgid ""
"a pointer to a string containing the name of the symbolic link to create."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:644
msgid ""
"a pointer to the parent dentry for this symbolic link.  This should be a "
"directory dentry if set.  If this parameter is NULL, then the symbolic link "
"will be created in the root of the debugfs filesystem."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:649
msgid "``const char *target``"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:648
msgid ""
"a pointer to a string containing the path to the target of the symbolic link."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:650
msgid ""
"This function creates a symbolic link with the given name in debugfs that "
"links to the given target path."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:653
msgid ""
"This function will return a pointer to a dentry if it succeeds.  This "
"pointer must be passed to the debugfs_remove() function when the symbolic "
"link is to be removed (no automatic cleanup happens if your module is "
"unloaded, you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) "
"will be returned."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:763
msgid "recursively removes a directory"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:764
msgid ""
"a pointer to a the dentry of the directory to be removed.  If this parameter "
"is NULL or an error value, nothing will be done."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:766
msgid ""
"This function recursively removes a directory tree in debugfs that was "
"previously created with a call to another debugfs function (like "
"debugfs_create_file() or variants thereof.)"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:770
msgid ""
"This function is required to be called in order for the file to be removed, "
"no automatic cleanup of files will happen when a module is removed, you are "
"responsible here."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:787
msgid "lookup a directory or file and recursively remove it"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:788
msgid "a pointer to a string containing the name of the item to look up."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:789
msgid "a pointer to the parent dentry of the item."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:790
msgid ""
"This is the equlivant of doing something like "
"debugfs_remove(debugfs_lookup(..)) but with the proper reference counting "
"handled for the directory being looked up."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:809
msgid "rename a file/directory in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:810
msgid "dentry of an object to be renamed."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:811
msgid "format for new name"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:1
msgid "variable arguments"
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:812
msgid ""
"This function renames a file/directory in debugfs.  The target must not "
"exist for rename to succeed."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:815
msgid "This function will return 0 on success and -E... on failure."
msgstr ""

#: ../../../filesystems/api-summary:143: ../fs/debugfs/inode.c:874
msgid "Tells whether debugfs has been registered"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:146
msgid "mark the beginning of file data access"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:147
msgid "the dentry object whose data is being accessed."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:148
msgid ""
"Up to a matching call to debugfs_file_put(), any successive call into the "
"file removing functions debugfs_remove() and debugfs_remove_recursive() will "
"block. Since associated private file data may only get freed after a "
"successful return of any of the removal functions, you may safely access it "
"after a successful call to debugfs_file_get() without worrying about "
"lifetime issues."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:155
msgid ""
"If -``EIO`` is returned, the file has already been removed and thus, it is "
"not safe to access any of its data. If, on the other hand, it is allowed to "
"access the file data, zero is returned."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:167
msgid "mark the end of file data access"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:168
msgid "the dentry object formerly passed to debugfs_file_get()."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:170
msgid ""
"Allow any ongoing concurrent call into debugfs_remove() or "
"debugfs_remove_recursive() blocked by a former call to debugfs_file_get() to "
"proceed and return to its caller."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:185
msgid "enter a debugfs cancellation"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:186
#: ../fs/debugfs/file.c:236
msgid "the file being accessed"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:188
#: ../fs/debugfs/file.c:238
msgid "``struct debugfs_cancellation *cancellation``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:187
msgid ""
"the cancellation object, the cancel callback inside of it must be initialized"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:189
msgid ""
"When a debugfs file is removed it needs to wait for all active operations to "
"complete. However, the operation itself may need to wait for hardware or "
"completion of some asynchronous process or similar. As such, it may need to "
"be cancelled to avoid long waits or even deadlocks."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:195
msgid ""
"This function can be used inside a debugfs handler that may need to be "
"cancelled. As soon as this function is called, the cancellation's 'cancel' "
"callback may be called, at which point the caller should proceed to call "
"debugfs_leave_cancellation() and leave the debugfs handler function as soon "
"as possible. Note that the 'cancel' callback is only ever called in the "
"context of some kind of debugfs_remove()."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:203
msgid "This function must be paired with debugfs_leave_cancellation()."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:235
msgid "leave cancellation section"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:237
msgid ""
"the cancellation previously registered with debugfs_enter_cancellation()"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:239
msgid "See the documentation of debugfs_enter_cancellation()."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:593
#: ../fs/debugfs/file.c:790
msgid ""
"create a debugfs file that is used to read and write an unsigned 8-bit value"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:595
#: ../fs/debugfs/file.c:631 ../fs/debugfs/file.c:667 ../fs/debugfs/file.c:704
#: ../fs/debugfs/file.c:743 ../fs/debugfs/file.c:792 ../fs/debugfs/file.c:810
#: ../fs/debugfs/file.c:828 ../fs/debugfs/file.c:846 ../fs/debugfs/file.c:880
#: ../fs/debugfs/file.c:916 ../fs/debugfs/file.c:997 ../fs/debugfs/file.c:1125
#: ../fs/debugfs/file.c:1187 ../fs/debugfs/file.c:1361
msgid "the permission that the file should have"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:596
#: ../fs/debugfs/file.c:632 ../fs/debugfs/file.c:668 ../fs/debugfs/file.c:705
#: ../fs/debugfs/file.c:744 ../fs/debugfs/file.c:793 ../fs/debugfs/file.c:811
#: ../fs/debugfs/file.c:829 ../fs/debugfs/file.c:847 ../fs/debugfs/file.c:881
#: ../fs/debugfs/file.c:917 ../fs/debugfs/file.c:998 ../fs/debugfs/file.c:1126
#: ../fs/debugfs/file.c:1188 ../fs/debugfs/file.c:1284
#: ../fs/debugfs/file.c:1362 ../fs/debugfs/file.c:1408
msgid ""
"a pointer to the parent dentry for this file.  This should be a directory "
"dentry if set.  If this parameter is ``NULL``, then the file will be created "
"in the root of the debugfs filesystem."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:600
#: ../fs/debugfs/file.c:797
msgid "``u8 *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:599
#: ../fs/debugfs/file.c:635 ../fs/debugfs/file.c:671 ../fs/debugfs/file.c:708
#: ../fs/debugfs/file.c:747 ../fs/debugfs/file.c:796 ../fs/debugfs/file.c:814
#: ../fs/debugfs/file.c:832 ../fs/debugfs/file.c:850 ../fs/debugfs/file.c:884
#: ../fs/debugfs/file.c:920 ../fs/debugfs/file.c:1001 ../fs/debugfs/file.c:1129
msgid "a pointer to the variable that the file should read to and write from."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:601
#: ../fs/debugfs/file.c:637 ../fs/debugfs/file.c:673 ../fs/debugfs/file.c:710
#: ../fs/debugfs/file.c:749 ../fs/debugfs/file.c:1003 ../fs/debugfs/file.c:1131
msgid ""
"This function creates a file in debugfs with the given name that contains "
"the value of the variable **value**.  If the **mode** variable is so set, it "
"can be read from, and written to."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:629
#: ../fs/debugfs/file.c:808
msgid ""
"create a debugfs file that is used to read and write an unsigned 16-bit value"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:636
#: ../fs/debugfs/file.c:815
msgid "``u16 *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:665
#: ../fs/debugfs/file.c:826
msgid ""
"create a debugfs file that is used to read and write an unsigned 32-bit value"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:672
#: ../fs/debugfs/file.c:833
msgid "``u32 *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:702
#: ../fs/debugfs/file.c:844
msgid ""
"create a debugfs file that is used to read and write an unsigned 64-bit value"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:709
#: ../fs/debugfs/file.c:851
msgid "``u64 *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:740
msgid ""
"create a debugfs file that is used to read and write an unsigned long value."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:748
msgid "``unsigned long *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:878
msgid "create a debugfs file that is used to read and write an size_t value"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:885
msgid "``size_t *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:913
msgid "create a debugfs file that is used to read and write an atomic_t value"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:921
msgid "``atomic_t *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:995
msgid "create a debugfs file that is used to read and write a boolean value"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1002
msgid "``bool *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1123
msgid "create a debugfs file that is used to read and write a string value"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1130
msgid "``char **value``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1184
msgid "create a debugfs file that is used to read and write a binary blob"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1192
msgid "``struct debugfs_blob_wrapper *blob``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1191
msgid ""
"a pointer to a struct debugfs_blob_wrapper which contains a pointer to the "
"blob data and the size of the data."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1193
msgid ""
"This function creates a file in debugfs with the given name that exports "
"**blob->data** as a binary blob. If the **mode** variable is so set it can "
"be read from and written to."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1203
msgid ""
"If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will be "
"returned."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1280
msgid "create a debugfs file that is used to read u32 array."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1288
msgid "``struct debugfs_u32_array *array``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1287
msgid "wrapper struct containing data pointer and size of the array."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1288
msgid ""
"This function creates a file in debugfs with the given name that exports "
"**array** as data. If the **mode** variable is so set it can be read from. "
"Writing is not supported. Seek within the file is also not supported. Once "
"array is created its size can not be changed."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1311
msgid "use seq_print to describe a set of registers"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1317
msgid "``struct seq_file *s``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1312
msgid "the seq_file structure being used to generate output"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1314
msgid "``const struct debugfs_reg32 *regs``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1313
msgid "an array if struct debugfs_reg32 structures"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1315
msgid "``int nregs``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1314
msgid "the length of the above array"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1316
msgid "``void __iomem *base``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1315
msgid "the base address to be used in reading the registers"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1317
msgid "``char *prefix``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1316
msgid "a string to be prefixed to every output line"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1317
msgid ""
"This function outputs a text block describing the current values of some 32-"
"bit hardware registers. It is meant to be used within debugfs files based on "
"seq_file that need to show registers, intermixed with other information. The "
"prefix argument may be used to specify a leading string, because some "
"peripherals have several blocks of identical registers, for example "
"configuration of dma channels"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1359
msgid "create a debugfs file that returns register values"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1366
msgid "``struct debugfs_regset32 *regset``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1365
msgid ""
"a pointer to a struct debugfs_regset32, which contains a pointer to an array "
"of register definitions, the array size and the base address where the "
"register bank is to be found."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1368
msgid ""
"This function creates a file in debugfs with the given name that reports the "
"names and values of a set of 32-bit registers. If the **mode** variable is "
"so set it can be read from. Writing is not supported."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1404
msgid "create a debugfs file that is bound to device."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1410
msgid "``struct device *dev``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1406
msgid "device related to this debugfs file."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1407
msgid "name of the debugfs file."
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1412
msgid "``int (*read_fn)(struct seq_file *s, void *data)``"
msgstr ""

#: ../../../filesystems/api-summary:146: ../fs/debugfs/file.c:1411
msgid "function pointer called to print the seq_file content."
msgstr ""
