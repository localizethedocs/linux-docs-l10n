# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../locking/preempt-locking.rst:3
msgid ""
"Proper Locking Under a Preemptible Kernel: Keeping Kernel Code Preempt-Safe"
msgstr ""

#: ../../../locking/preempt-locking.rst:0
msgid "Author"
msgstr ""

#: ../../../locking/preempt-locking.rst:5
msgid "Robert Love <rml@tech9.net>"
msgstr ""

#: ../../../locking/preempt-locking.rst:9
msgid "Introduction"
msgstr ""

#: ../../../locking/preempt-locking.rst:12
msgid ""
"A preemptible kernel creates new locking issues.  The issues are the same as "
"those under SMP: concurrency and reentrancy.  Thankfully, the Linux "
"preemptible kernel model leverages existing SMP locking mechanisms.  Thus, "
"the kernel requires explicit additional locking for very few additional "
"situations."
msgstr ""

#: ../../../locking/preempt-locking.rst:17
msgid ""
"This document is for all kernel hackers.  Developing code in the kernel "
"requires protecting these situations."
msgstr ""

#: ../../../locking/preempt-locking.rst:22
msgid "RULE #1: Per-CPU data structures need explicit protection"
msgstr ""

#: ../../../locking/preempt-locking.rst:25
msgid "Two similar problems arise. An example code snippet::"
msgstr ""

#: ../../../locking/preempt-locking.rst:32
msgid ""
"First, since the data is per-CPU, it may not have explicit SMP locking, but "
"require it otherwise.  Second, when a preempted task is finally rescheduled, "
"the previous value of smp_processor_id may not equal the current.  You must "
"protect these situations by disabling preemption around them."
msgstr ""

#: ../../../locking/preempt-locking.rst:37
msgid ""
"You can also use put_cpu() and get_cpu(), which will disable preemption."
msgstr ""

#: ../../../locking/preempt-locking.rst:41
msgid "RULE #2: CPU state must be protected."
msgstr ""

#: ../../../locking/preempt-locking.rst:44
msgid ""
"Under preemption, the state of the CPU must be protected.  This is arch- "
"dependent, but includes CPU structures and state not preserved over a "
"context switch.  For example, on x86, entering and exiting FPU mode is now a "
"critical section that must occur while preemption is disabled.  Think what "
"would happen if the kernel is executing a floating-point instruction and is "
"then preempted. Remember, the kernel does not save FPU state except for user "
"tasks.  Therefore, upon preemption, the FPU registers will be sold to the "
"lowest bidder.  Thus, preemption must be disabled around such regions."
msgstr ""

#: ../../../locking/preempt-locking.rst:53
msgid ""
"Note, some FPU functions are already explicitly preempt safe.  For example, "
"kernel_fpu_begin and kernel_fpu_end will disable and enable preemption."
msgstr ""

#: ../../../locking/preempt-locking.rst:58
msgid "RULE #3: Lock acquire and release must be performed by same task"
msgstr ""

#: ../../../locking/preempt-locking.rst:61
msgid ""
"A lock acquired in one task must be released by the same task.  This means "
"you can't do oddball things like acquire a lock and go off to play while "
"another task releases it.  If you want to do something like this, acquire "
"and release the task in the same code path and have the caller wait on an "
"event by the other task."
msgstr ""

#: ../../../locking/preempt-locking.rst:69
msgid "Solution"
msgstr ""

#: ../../../locking/preempt-locking.rst:72
msgid ""
"Data protection under preemption is achieved by disabling preemption for the "
"duration of the critical region."
msgstr ""

#: ../../../locking/preempt-locking.rst:83
msgid ""
"The functions are nestable.  In other words, you can call preempt_disable n-"
"times in a code path, and preemption will not be reenabled until the n-th "
"call to preempt_enable.  The preempt statements define to nothing if "
"preemption is not enabled."
msgstr ""

#: ../../../locking/preempt-locking.rst:88
msgid ""
"Note that you do not need to explicitly prevent preemption if you are "
"holding any locks or interrupts are disabled, since preemption is implicitly "
"disabled in those cases."
msgstr ""

#: ../../../locking/preempt-locking.rst:92
msgid ""
"But keep in mind that 'irqs disabled' is a fundamentally unsafe way of "
"disabling preemption - any cond_resched() or cond_resched_lock() might "
"trigger a reschedule if the preempt count is 0. A simple printk() might "
"trigger a reschedule. So use this implicit preemption-disabling property "
"only if you know that the affected codepath does not do any of this. Best "
"policy is to use this only for small, atomic code that you wrote and which "
"calls no complex functions."
msgstr ""

#: ../../../locking/preempt-locking.rst:100
msgid "Example::"
msgstr ""

#: ../../../locking/preempt-locking.rst:112
msgid ""
"Notice how the preemption statements must encompass every reference of the "
"critical variables.  Another example::"
msgstr ""

#: ../../../locking/preempt-locking.rst:121
msgid ""
"This code is not preempt-safe, but see how easily we can fix it by simply "
"moving the spin_lock up two lines."
msgstr ""

#: ../../../locking/preempt-locking.rst:126
msgid "Preventing preemption using interrupt disabling"
msgstr ""

#: ../../../locking/preempt-locking.rst:129
msgid ""
"It is possible to prevent a preemption event using local_irq_disable and "
"local_irq_save.  Note, when doing so, you must be very careful to not cause "
"an event that would set need_resched and result in a preemption check.  When "
"in doubt, rely on locking or explicit preemption disabling."
msgstr ""

#: ../../../locking/preempt-locking.rst:134
msgid "Note in 2.5 interrupt disabling is now only per-CPU (e.g. local)."
msgstr ""

#: ../../../locking/preempt-locking.rst:136
msgid ""
"An additional concern is proper usage of local_irq_disable and "
"local_irq_save. These may be used to protect from preemption, however, on "
"exit, if preemption may be enabled, a test to see if preemption is required "
"should be done.  If these are called from the spin_lock and read/write lock "
"macros, the right thing is done.  They may also be called within a spin-lock "
"protected region, however, if they are ever called outside of this context, "
"a test for preemption should be made. Do note that calls from interrupt "
"context or bottom half/ tasklets are also protected by preemption locks and "
"so may use the versions which do not check preemption."
msgstr ""
