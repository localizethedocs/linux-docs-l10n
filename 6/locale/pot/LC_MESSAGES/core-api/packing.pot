# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/packing.rst:3
msgid "Generic bitfield packing and unpacking functions"
msgstr ""

#: ../../../core-api/packing.rst:6
msgid "Problem statement"
msgstr ""

#: ../../../core-api/packing.rst:8
msgid ""
"When working with hardware, one has to choose between several approaches of "
"interfacing with it. One can memory-map a pointer to a carefully crafted "
"struct over the hardware device's memory region, and access its fields as "
"struct members (potentially declared as bitfields). But writing code this "
"way would make it less portable, due to potential endianness mismatches "
"between the CPU and the hardware device. Additionally, one has to pay close "
"attention when translating register definitions from the hardware "
"documentation into bit field indices for the structs. Also, some hardware "
"(typically networking equipment) tends to group its register fields in ways "
"that violate any reasonable word boundaries (sometimes even 64 bit ones). "
"This creates the inconvenience of having to define \"high\" and \"low\" "
"portions of register fields within the struct. A more robust alternative to "
"struct field definitions would be to extract the required fields by shifting "
"the appropriate number of bits. But this would still not protect from "
"endianness mismatches, except if all memory accesses were performed byte-by-"
"byte. Also the code can easily get cluttered, and the high-level idea might "
"get lost among the many bit shifts required. Many drivers take the bit-"
"shifting approach and then attempt to reduce the clutter with tailored "
"macros, but more often than not these macros take shortcuts that still "
"prevent the code from being truly portable."
msgstr ""

#: ../../../core-api/packing.rst:30
msgid "The solution"
msgstr ""

#: ../../../core-api/packing.rst:32
msgid "This API deals with 2 basic operations:"
msgstr ""

#: ../../../core-api/packing.rst:34
msgid ""
"Packing a CPU-usable number into a memory buffer (with hardware constraints/"
"quirks)"
msgstr ""

#: ../../../core-api/packing.rst:36
msgid ""
"Unpacking a memory buffer (which has hardware constraints/quirks) into a CPU-"
"usable number."
msgstr ""

#: ../../../core-api/packing.rst:39
msgid ""
"The API offers an abstraction over said hardware constraints and quirks, "
"over CPU endianness and therefore between possible mismatches between the "
"two."
msgstr ""

#: ../../../core-api/packing.rst:43
msgid ""
"The basic unit of these API functions is the u64. From the CPU's "
"perspective, bit 63 always means bit offset 7 of byte 7, albeit only "
"logically. The question is: where do we lay this bit out in memory?"
msgstr ""

#: ../../../core-api/packing.rst:47
msgid ""
"The following examples cover the memory layout of a packed u64 field. The "
"byte offsets in the packed buffer are always implicitly 0, 1, ... 7. What "
"the examples show is where the logical bytes and bits sit."
msgstr ""

#: ../../../core-api/packing.rst:51
msgid "Normally (no quirks), we would do it like this:"
msgstr ""

#: ../../../core-api/packing.rst:60
msgid ""
"That is, the MSByte (7) of the CPU-usable u64 sits at memory offset 0, and "
"the LSByte (0) of the u64 sits at memory offset 7. This corresponds to what "
"most folks would regard to as \"big endian\", where bit i corresponds to the "
"number 2^i. This is also referred to in the code comments as \"logical\" "
"notation."
msgstr ""

#: ../../../core-api/packing.rst:67
msgid "If QUIRK_MSB_ON_THE_RIGHT is set, we do it like this:"
msgstr ""

#: ../../../core-api/packing.rst:76
msgid ""
"That is, QUIRK_MSB_ON_THE_RIGHT does not affect byte positioning, but "
"inverts bit offsets inside a byte."
msgstr ""

#: ../../../core-api/packing.rst:80
msgid "If QUIRK_LITTLE_ENDIAN is set, we do it like this:"
msgstr ""

#: ../../../core-api/packing.rst:89
msgid ""
"Therefore, QUIRK_LITTLE_ENDIAN means that inside the memory region, every "
"byte from each 4-byte word is placed at its mirrored position compared to "
"the boundary of that word."
msgstr ""

#: ../../../core-api/packing.rst:93
msgid ""
"If QUIRK_MSB_ON_THE_RIGHT and QUIRK_LITTLE_ENDIAN are both set, we do it "
"like this:"
msgstr ""

#: ../../../core-api/packing.rst:104
msgid "If just QUIRK_LSW32_IS_FIRST is set, we do it like this:"
msgstr ""

#: ../../../core-api/packing.rst:113
msgid ""
"In this case the 8 byte memory region is interpreted as follows: first 4 "
"bytes correspond to the least significant 4-byte word, next 4 bytes to the "
"more significant 4-byte word."
msgstr ""

#: ../../../core-api/packing.rst:118
msgid ""
"If QUIRK_LSW32_IS_FIRST and QUIRK_MSB_ON_THE_RIGHT are set, we do it like "
"this:"
msgstr ""

#: ../../../core-api/packing.rst:129
msgid ""
"If QUIRK_LSW32_IS_FIRST and QUIRK_LITTLE_ENDIAN are set, it looks like this:"
msgstr ""

#: ../../../core-api/packing.rst:140
msgid ""
"If QUIRK_LSW32_IS_FIRST, QUIRK_LITTLE_ENDIAN and QUIRK_MSB_ON_THE_RIGHT are "
"set, it looks like this:"
msgstr ""

#: ../../../core-api/packing.rst:151
msgid ""
"We always think of our offsets as if there were no quirk, and we translate "
"them afterwards, before accessing the memory region."
msgstr ""

#: ../../../core-api/packing.rst:155
msgid "Note on buffer lengths not multiple of 4"
msgstr ""

#: ../../../core-api/packing.rst:157
msgid ""
"To deal with memory layout quirks where groups of 4 bytes are laid out "
"\"little endian\" relative to each other, but \"big endian\" within the "
"group itself, the concept of groups of 4 bytes is intrinsic to the packing "
"API (not to be confused with the memory access, which is performed byte by "
"byte, though)."
msgstr ""

#: ../../../core-api/packing.rst:162
msgid ""
"With buffer lengths not multiple of 4, this means one group will be "
"incomplete. Depending on the quirks, this may lead to discontinuities in the "
"bit fields accessible through the buffer. The packing API assumes "
"discontinuities were not the intention of the memory layout, so it avoids "
"them by effectively logically shortening the most significant group of 4 "
"octets to the number of octets actually available."
msgstr ""

#: ../../../core-api/packing.rst:169
msgid ""
"Example with a 31 byte sized buffer given below. Physical buffer offsets are "
"implicit, and increase from left to right within a group, and from top to "
"bottom within a column."
msgstr ""

#: ../../../core-api/packing.rst:173
msgid "No quirks:"
msgstr ""

#: ../../../core-api/packing.rst:186
msgid "QUIRK_LSW32_IS_FIRST:"
msgstr ""

#: ../../../core-api/packing.rst:199
msgid "QUIRK_LITTLE_ENDIAN:"
msgstr ""

#: ../../../core-api/packing.rst:212
msgid "QUIRK_LITTLE_ENDIAN | QUIRK_LSW32_IS_FIRST:"
msgstr ""

#: ../../../core-api/packing.rst:226
msgid "Intended use"
msgstr ""

#: ../../../core-api/packing.rst:228
msgid ""
"Drivers that opt to use this API first need to identify which of the above 3 "
"quirk combinations (for a total of 8) match what the hardware documentation "
"describes."
msgstr ""

#: ../../../core-api/packing.rst:232
msgid "There are 3 supported usage patterns, detailed below."
msgstr ""

#: ../../../core-api/packing.rst:235
msgid "packing()"
msgstr ""

#: ../../../core-api/packing.rst:237
msgid "This API function is deprecated."
msgstr ""

#: ../../../core-api/packing.rst:239
msgid ""
"The packing() function returns an int-encoded error code, which protects the "
"programmer against incorrect API use.  The errors are not expected to occur "
"during runtime, therefore it is reasonable to wrap packing() into a custom "
"function which returns void and swallows those errors. Optionally it can "
"dump stack or print the error description."
msgstr ""

#: ../../../core-api/packing.rst:272
msgid "pack() and unpack()"
msgstr ""

#: ../../../core-api/packing.rst:274
msgid ""
"These are const-correct variants of packing(), and eliminate the last \"enum "
"packing_op op\" argument."
msgstr ""

#: ../../../core-api/packing.rst:277
msgid ""
"Calling pack(...) is equivalent, and preferred, to calling packing(..., "
"PACK)."
msgstr ""

#: ../../../core-api/packing.rst:279
msgid ""
"Calling unpack(...) is equivalent, and preferred, to calling packing(..., "
"UNPACK)."
msgstr ""

#: ../../../core-api/packing.rst:282
msgid "pack_fields() and unpack_fields()"
msgstr ""

#: ../../../core-api/packing.rst:284
msgid ""
"The library exposes optimized functions for the scenario where there are "
"many fields represented in a buffer, and it encourages consumer drivers to "
"avoid repetitive calls to pack() and unpack() for each field, but instead "
"use pack_fields() and unpack_fields(), which reduces the code footprint."
msgstr ""

#: ../../../core-api/packing.rst:289
msgid ""
"These APIs use field definitions in arrays of ``struct packed_field_u8`` or "
"``struct packed_field_u16``, allowing consumer drivers to minimize the size "
"of these arrays according to their custom requirements."
msgstr ""

#: ../../../core-api/packing.rst:293
msgid ""
"The pack_fields() and unpack_fields() API functions are actually macros "
"which automatically select the appropriate function at compile time, based "
"on the type of the fields array passed in."
msgstr ""

#: ../../../core-api/packing.rst:297
msgid ""
"An additional benefit over pack() and unpack() is that sanity checks on the "
"field definitions are handled at compile time with ``BUILD_BUG_ON`` rather "
"than only when the offending code is executed. These functions return void "
"and wrapping them to handle unexpected errors is not necessary."
msgstr ""

#: ../../../core-api/packing.rst:302
msgid ""
"It is recommended, but not required, that you wrap your packed buffer into a "
"structured type with a fixed size. This generally makes it easier for the "
"compiler to enforce that the correct size buffer is used."
msgstr ""

#: ../../../core-api/packing.rst:306
msgid "Here is an example of how to use the fields APIs:"
msgstr ""
