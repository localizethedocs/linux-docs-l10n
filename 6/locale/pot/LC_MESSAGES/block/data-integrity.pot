# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../block/data-integrity.rst:3
msgid "Data Integrity"
msgstr ""

#: ../../../block/data-integrity.rst:6
msgid "1. Introduction"
msgstr ""

#: ../../../block/data-integrity.rst:8
msgid ""
"Modern filesystems feature checksumming of data and metadata to protect "
"against data corruption.  However, the detection of the corruption is done "
"at read time which could potentially be months after the data was written.  "
"At that point the original data that the application tried to write is most "
"likely lost."
msgstr ""

#: ../../../block/data-integrity.rst:14
msgid ""
"The solution is to ensure that the disk is actually storing what the "
"application meant it to.  Recent additions to both the SCSI family protocols "
"(SBC Data Integrity Field, SCC protection proposal) as well as SATA/T13 "
"(External Path Protection) try to remedy this by adding support for "
"appending integrity metadata to an I/O.  The integrity metadata (or "
"protection information in SCSI terminology) includes a checksum for each "
"sector as well as an incrementing counter that ensures the individual "
"sectors are written in the right order.  And for some protection schemes "
"also that the I/O is written to the right place on disk."
msgstr ""

#: ../../../block/data-integrity.rst:25
msgid ""
"Current storage controllers and devices implement various protective "
"measures, for instance checksumming and scrubbing.  But these technologies "
"are working in their own isolated domains or at best between adjacent nodes "
"in the I/O path.  The interesting thing about DIF and the other integrity "
"extensions is that the protection format is well defined and every node in "
"the I/O path can verify the integrity of the I/O and reject it if corruption "
"is detected.  This allows not only corruption prevention but also isolation "
"of the point of failure."
msgstr ""

#: ../../../block/data-integrity.rst:36
msgid "2. The Data Integrity Extensions"
msgstr ""

#: ../../../block/data-integrity.rst:38
msgid ""
"As written, the protocol extensions only protect the path between controller "
"and storage device.  However, many controllers actually allow the operating "
"system to interact with the integrity metadata (IMD).  We have been working "
"with several FC/SAS HBA vendors to enable the protection information to be "
"transferred to and from their controllers."
msgstr ""

#: ../../../block/data-integrity.rst:45
msgid ""
"The SCSI Data Integrity Field works by appending 8 bytes of protection "
"information to each sector.  The data + integrity metadata is stored in 520 "
"byte sectors on disk.  Data + IMD are interleaved when transferred between "
"the controller and target.  The T13 proposal is similar."
msgstr ""

#: ../../../block/data-integrity.rst:51
msgid ""
"Because it is highly inconvenient for operating systems to deal with 520 "
"(and 4104) byte sectors, we approached several HBA vendors and encouraged "
"them to allow separation of the data and integrity metadata scatter-gather "
"lists."
msgstr ""

#: ../../../block/data-integrity.rst:56
msgid ""
"The controller will interleave the buffers on write and split them on read.  "
"This means that Linux can DMA the data buffers to and from host memory "
"without changes to the page cache."
msgstr ""

#: ../../../block/data-integrity.rst:60
msgid ""
"Also, the 16-bit CRC checksum mandated by both the SCSI and SATA specs is "
"somewhat heavy to compute in software.  Benchmarks found that calculating "
"this checksum had a significant impact on system performance for a number of "
"workloads.  Some controllers allow a lighter-weight checksum to be used when "
"interfacing with the operating system.  Emulex, for instance, supports the "
"TCP/IP checksum instead. The IP checksum received from the OS is converted "
"to the 16-bit CRC when writing and vice versa.  This allows the integrity "
"metadata to be generated by Linux or the application at very low cost "
"(comparable to software RAID5)."
msgstr ""

#: ../../../block/data-integrity.rst:71
msgid ""
"The IP checksum is weaker than the CRC in terms of detecting bit errors.  "
"However, the strength is really in the separation of the data buffers and "
"the integrity metadata.  These two distinct buffers must match up for an I/O "
"to complete."
msgstr ""

#: ../../../block/data-integrity.rst:76
msgid ""
"The separation of the data and integrity metadata buffers as well as the "
"choice in checksums is referred to as the Data Integrity Extensions.  As "
"these extensions are outside the scope of the protocol bodies (T10, T13), "
"Oracle and its partners are trying to standardize them within the Storage "
"Networking Industry Association."
msgstr ""

#: ../../../block/data-integrity.rst:83
msgid "3. Kernel Changes"
msgstr ""

#: ../../../block/data-integrity.rst:85
msgid ""
"The data integrity framework in Linux enables protection information to be "
"pinned to I/Os and sent to/received from controllers that support it."
msgstr ""

#: ../../../block/data-integrity.rst:89
msgid ""
"The advantage to the integrity extensions in SCSI and SATA is that they "
"enable us to protect the entire path from application to storage device.  "
"However, at the same time this is also the biggest disadvantage. It means "
"that the protection information must be in a format that can be understood "
"by the disk."
msgstr ""

#: ../../../block/data-integrity.rst:95
msgid ""
"Generally Linux/POSIX applications are agnostic to the intricacies of the "
"storage devices they are accessing.  The virtual filesystem switch and the "
"block layer make things like hardware sector size and transport protocols "
"completely transparent to the application."
msgstr ""

#: ../../../block/data-integrity.rst:100
msgid ""
"However, this level of detail is required when preparing the protection "
"information to send to a disk.  Consequently, the very concept of an end-to-"
"end protection scheme is a layering violation. It is completely unreasonable "
"for an application to be aware whether it is accessing a SCSI or SATA disk."
msgstr ""

#: ../../../block/data-integrity.rst:106
msgid ""
"The data integrity support implemented in Linux attempts to hide this from "
"the application.  As far as the application (and to some extent the kernel) "
"is concerned, the integrity metadata is opaque information that's attached "
"to the I/O."
msgstr ""

#: ../../../block/data-integrity.rst:111
msgid ""
"The current implementation allows the block layer to automatically generate "
"the protection information for any I/O.  Eventually the intent is to move "
"the integrity metadata calculation to userspace for user data.  Metadata and "
"other I/O that originates within the kernel will still use the automatic "
"generation interface."
msgstr ""

#: ../../../block/data-integrity.rst:117
msgid ""
"Some storage devices allow each hardware sector to be tagged with a 16-bit "
"value.  The owner of this tag space is the owner of the block device.  I.e. "
"the filesystem in most cases.  The filesystem can use this extra space to "
"tag sectors as they see fit.  Because the tag space is limited, the block "
"interface allows tagging bigger chunks by way of interleaving.  This way, "
"8*16 bits of information can be attached to a typical 4KB filesystem block."
msgstr ""

#: ../../../block/data-integrity.rst:125
msgid ""
"This also means that applications such as fsck and mkfs will need access to "
"manipulate the tags from user space.  A passthrough interface for this is "
"being worked on."
msgstr ""

#: ../../../block/data-integrity.rst:131
msgid "4. Block Layer Implementation Details"
msgstr ""

#: ../../../block/data-integrity.rst:134
msgid "4.1 Bio"
msgstr ""

#: ../../../block/data-integrity.rst:136
msgid ""
"The data integrity patches add a new field to struct bio when "
"CONFIG_BLK_DEV_INTEGRITY is enabled.  bio_integrity(bio) returns a pointer "
"to a struct bip which contains the bio integrity payload. Essentially a bip "
"is a trimmed down struct bio which holds a bio_vec containing the integrity "
"metadata and the required housekeeping information (bvec pool, vector count, "
"etc.)"
msgstr ""

#: ../../../block/data-integrity.rst:143
msgid ""
"A kernel subsystem can enable data integrity protection on a bio by calling "
"bio_integrity_alloc(bio).  This will allocate and attach the bip to the bio."
msgstr ""

#: ../../../block/data-integrity.rst:147
msgid ""
"Individual pages containing integrity metadata can subsequently be attached "
"using bio_integrity_add_page()."
msgstr ""

#: ../../../block/data-integrity.rst:150
msgid "bio_free() will automatically free the bip."
msgstr ""

#: ../../../block/data-integrity.rst:154
msgid "4.2 Block Device"
msgstr ""

#: ../../../block/data-integrity.rst:156
msgid ""
"Block devices can set up the integrity information in the integrity sub-"
"struture of the queue_limits structure."
msgstr ""

#: ../../../block/data-integrity.rst:159
msgid ""
"Layered block devices will need to pick a profile that's appropriate for all "
"subdevices.  queue_limits_stack_integrity() can help with that.  DM and MD "
"linear, RAID0 and RAID1 are currently supported.  RAID4/5/6 will require "
"extra work due to the application tag."
msgstr ""

#: ../../../block/data-integrity.rst:166
msgid "5.0 Block Layer Integrity API"
msgstr ""

#: ../../../block/data-integrity.rst:169
msgid "5.1 Normal Filesystem"
msgstr ""

#: ../../../block/data-integrity.rst:171
msgid ""
"The normal filesystem is unaware that the underlying block device is capable "
"of sending/receiving integrity metadata.  The IMD will be automatically "
"generated by the block layer at submit_bio() time in case of a WRITE.  A "
"READ request will cause the I/O integrity to be verified upon completion."
msgstr ""

#: ../../../block/data-integrity.rst:177
msgid "IMD generation and verification can be toggled using the::"
msgstr ""

#: ../../../block/data-integrity.rst:181
msgid "and::"
msgstr ""

#: ../../../block/data-integrity.rst:185
msgid "flags."
msgstr ""

#: ../../../block/data-integrity.rst:189
msgid "5.2 Integrity-Aware Filesystem"
msgstr ""

#: ../../../block/data-integrity.rst:191
msgid ""
"A filesystem that is integrity-aware can prepare I/Os with IMD attached.  It "
"can also use the application tag space if this is supported by the block "
"device."
msgstr ""

#: ../../../block/data-integrity.rst:196
msgid "`bool bio_integrity_prep(bio);`"
msgstr ""

#: ../../../block/data-integrity.rst:198
msgid ""
"To generate IMD for WRITE and to set up buffers for READ, the filesystem "
"must call bio_integrity_prep(bio)."
msgstr ""

#: ../../../block/data-integrity.rst:201
msgid ""
"Prior to calling this function, the bio data direction and start sector must "
"be set, and the bio should have all data pages added.  It is up to the "
"caller to ensure that the bio does not change while I/O is in progress. "
"Complete bio with error if prepare failed for some reason."
msgstr ""

#: ../../../block/data-integrity.rst:209
msgid "5.3 Passing Existing Integrity Metadata"
msgstr ""

#: ../../../block/data-integrity.rst:211
msgid ""
"Filesystems that either generate their own integrity metadata or are capable "
"of transferring IMD from user space can use the following calls:"
msgstr ""

#: ../../../block/data-integrity.rst:216
msgid "`struct bip * bio_integrity_alloc(bio, gfp_mask, nr_pages);`"
msgstr ""

#: ../../../block/data-integrity.rst:218
msgid ""
"Allocates the bio integrity payload and hangs it off of the bio. nr_pages "
"indicate how many pages of protection data need to be stored in the "
"integrity bio_vec list (similar to bio_alloc())."
msgstr ""

#: ../../../block/data-integrity.rst:222
msgid "The integrity payload will be freed at bio_free() time."
msgstr ""

#: ../../../block/data-integrity.rst:225
msgid "`int bio_integrity_add_page(bio, page, len, offset);`"
msgstr ""

#: ../../../block/data-integrity.rst:227
msgid ""
"Attaches a page containing integrity metadata to an existing bio.  The bio "
"must have an existing bip, i.e. bio_integrity_alloc() must have been "
"called.  For a WRITE, the integrity metadata in the pages must be in a "
"format understood by the target device with the notable exception that the "
"sector numbers will be remapped as the request traverses the I/O stack.  "
"This implies that the pages added using this call will be modified during I/"
"O!  The first reference tag in the integrity metadata must have a value of "
"bip->bip_sector."
msgstr ""

#: ../../../block/data-integrity.rst:237
msgid ""
"Pages can be added using bio_integrity_add_page() as long as there is room "
"in the bip bio_vec array (nr_pages)."
msgstr ""

#: ../../../block/data-integrity.rst:240
msgid ""
"Upon completion of a READ operation, the attached pages will contain the "
"integrity metadata received from the storage device. It is up to the "
"receiver to process them and verify data integrity upon completion."
msgstr ""

#: ../../../block/data-integrity.rst:248
msgid "2007-12-24 Martin K. Petersen <martin.petersen@oracle.com>"
msgstr ""
