# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/kcm.rst:5
msgid "Kernel Connection Multiplexor"
msgstr ""

#: ../../../networking/kcm.rst:7
msgid ""
"Kernel Connection Multiplexor (KCM) is a mechanism that provides a message "
"based interface over TCP for generic application protocols. With KCM an "
"application can efficiently send and receive application protocol messages "
"over TCP using datagram sockets."
msgstr ""

#: ../../../networking/kcm.rst:12
msgid "KCM implements an NxM multiplexor in the kernel as diagrammed below::"
msgstr ""

#: ../../../networking/kcm.rst:35
msgid "KCM sockets"
msgstr ""

#: ../../../networking/kcm.rst:37
msgid ""
"The KCM sockets provide the user interface to the multiplexor. All the KCM "
"sockets bound to a multiplexor are considered to have equivalent function, "
"and I/O operations in different sockets may be done in parallel without the "
"need for synchronization between threads in userspace."
msgstr ""

#: ../../../networking/kcm.rst:43
msgid "Multiplexor"
msgstr ""

#: ../../../networking/kcm.rst:45
msgid ""
"The multiplexor provides the message steering. In the transmit path, "
"messages written on a KCM socket are sent atomically on an appropriate TCP "
"socket. Similarly, in the receive path, messages are constructed on each TCP "
"socket (Psock) and complete messages are steered to a KCM socket."
msgstr ""

#: ../../../networking/kcm.rst:51
msgid "TCP sockets & Psocks"
msgstr ""

#: ../../../networking/kcm.rst:53
msgid ""
"TCP sockets may be bound to a KCM multiplexor. A Psock structure is "
"allocated for each bound TCP socket, this structure holds the state for "
"constructing messages on receive as well as other connection specific "
"information for KCM."
msgstr ""

#: ../../../networking/kcm.rst:58
msgid "Connected mode semantics"
msgstr ""

#: ../../../networking/kcm.rst:60
msgid ""
"Each multiplexor assumes that all attached TCP connections are to the same "
"destination and can use the different connections for load balancing when "
"transmitting. The normal send and recv calls (include sendmmsg and recvmmsg) "
"can be used to send and receive messages from the KCM socket."
msgstr ""

#: ../../../networking/kcm.rst:66
msgid "Socket types"
msgstr ""

#: ../../../networking/kcm.rst:68
msgid "KCM supports SOCK_DGRAM and SOCK_SEQPACKET socket types."
msgstr ""

#: ../../../networking/kcm.rst:71
msgid "Message delineation"
msgstr ""

#: ../../../networking/kcm.rst:73
msgid ""
"Messages are sent over a TCP stream with some application protocol message "
"format that typically includes a header which frames the messages. The "
"length of a received message can be deduced from the application protocol "
"header (often just a simple length field)."
msgstr ""

#: ../../../networking/kcm.rst:78
msgid ""
"A TCP stream must be parsed to determine message boundaries. Berkeley Packet "
"Filter (BPF) is used for this. When attaching a TCP socket to a multiplexor "
"a BPF program must be specified. The program is called at the start of "
"receiving a new message and is given an skbuff that contains the bytes "
"received so far. It parses the message header and returns the length of the "
"message. Given this information, KCM will construct the message of the "
"stated length and deliver it to a KCM socket."
msgstr ""

#: ../../../networking/kcm.rst:87
msgid "TCP socket management"
msgstr ""

#: ../../../networking/kcm.rst:89
msgid ""
"When a TCP socket is attached to a KCM multiplexor data ready (POLLIN) and "
"write space available (POLLOUT) events are handled by the multiplexor. If "
"there is a state change (disconnection) or other error on a TCP socket, an "
"error is posted on the TCP socket so that a POLLERR event happens and KCM "
"discontinues using the socket. When the application gets the error "
"notification for a TCP socket, it should unattach the socket from KCM and "
"then handle the error condition (the typical response is to close the socket "
"and create a new connection if necessary)."
msgstr ""

#: ../../../networking/kcm.rst:98
msgid ""
"KCM limits the maximum receive message size to be the size of the receive "
"socket buffer on the attached TCP socket (the socket buffer size can be set "
"by SO_RCVBUF). If the length of a new message reported by the BPF program is "
"greater than this limit a corresponding error (EMSGSIZE) is posted on the "
"TCP socket. The BPF program may also enforce a maximum messages size and "
"report an error when it is exceeded."
msgstr ""

#: ../../../networking/kcm.rst:105
msgid ""
"A timeout may be set for assembling messages on a receive socket. The "
"timeout value is taken from the receive timeout of the attached TCP socket "
"(this is set by SO_RCVTIMEO). If the timer expires before assembly is "
"complete an error (ETIMEDOUT) is posted on the socket."
msgstr ""

#: ../../../networking/kcm.rst:111
msgid "User interface"
msgstr ""

#: ../../../networking/kcm.rst:114
msgid "Creating a multiplexor"
msgstr ""

#: ../../../networking/kcm.rst:116
msgid "A new multiplexor and initial KCM socket is created by a socket call::"
msgstr ""

#: ../../../networking/kcm.rst:120
msgid "type is either SOCK_DGRAM or SOCK_SEQPACKET"
msgstr ""

#: ../../../networking/kcm.rst:121
msgid "protocol is KCMPROTO_CONNECTED"
msgstr ""

#: ../../../networking/kcm.rst:124
msgid "Cloning KCM sockets"
msgstr ""

#: ../../../networking/kcm.rst:126
msgid ""
"After the first KCM socket is created using the socket call as described "
"above, additional sockets for the multiplexor can be created by cloning a "
"KCM socket. This is accomplished by an ioctl on a KCM socket::"
msgstr ""

#: ../../../networking/kcm.rst:145
msgid "Attach transport sockets"
msgstr ""

#: ../../../networking/kcm.rst:147
msgid ""
"Attaching of transport sockets to a multiplexor is performed by calling an "
"ioctl on a KCM socket for the multiplexor. e.g.::"
msgstr ""

#: ../../../networking/kcm.rst:165
msgid "The kcm_attach structure contains:"
msgstr ""

#: ../../../networking/kcm.rst:167
msgid "fd: file descriptor for TCP socket being attached"
msgstr ""

#: ../../../networking/kcm.rst:168
msgid "bpf_prog_fd: file descriptor for compiled BPF program downloaded"
msgstr ""

#: ../../../networking/kcm.rst:171
msgid "Unattach transport sockets"
msgstr ""

#: ../../../networking/kcm.rst:173
msgid ""
"Unattaching a transport socket from a multiplexor is straightforward. An "
"\"unattach\" ioctl is done with the kcm_unattach structure as the argument::"
msgstr ""

#: ../../../networking/kcm.rst:190
msgid "Disabling receive on KCM socket"
msgstr ""

#: ../../../networking/kcm.rst:192
msgid ""
"A setsockopt is used to disable or enable receiving on a KCM socket. When "
"receive is disabled, any pending messages in the socket's receive buffer are "
"moved to other sockets. This feature is useful if an application thread "
"knows that it will be doing a lot of work on a request and won't be able to "
"service new messages for a while. Example use::"
msgstr ""

#: ../../../networking/kcm.rst:204
msgid "BPF programs for message delineation"
msgstr ""

#: ../../../networking/kcm.rst:206
msgid ""
"BPF programs can be compiled using the BPF LLVM backend. For example, the "
"BPF program for parsing Thrift is::"
msgstr ""

#: ../../../networking/kcm.rst:221
msgid "Use in applications"
msgstr ""

#: ../../../networking/kcm.rst:223
msgid ""
"KCM accelerates application layer protocols. Specifically, it allows "
"applications to use a message based interface for sending and receiving "
"messages. The kernel provides necessary assurances that messages are sent "
"and received atomically. This relieves much of the burden applications have "
"in mapping a message based protocol onto the TCP stream. KCM also make "
"application layer messages a unit of work in the kernel for the purposes of "
"steering and scheduling, which in turn allows a simpler networking model in "
"multithreaded applications."
msgstr ""

#: ../../../networking/kcm.rst:233
msgid "Configurations"
msgstr ""

#: ../../../networking/kcm.rst:235
msgid ""
"In an Nx1 configuration, KCM logically provides multiple socket handles to "
"the same TCP connection. This allows parallelism between in I/O operations "
"on the TCP socket (for instance copyin and copyout of data is parallelized). "
"In an application, a KCM socket can be opened for each processing thread and "
"inserted into the epoll (similar to how SO_REUSEPORT is used to allow "
"multiple listener sockets on the same port)."
msgstr ""

#: ../../../networking/kcm.rst:242
msgid ""
"In a MxN configuration, multiple connections are established to the same "
"destination. These are used for simple load balancing."
msgstr ""

#: ../../../networking/kcm.rst:246
msgid "Message batching"
msgstr ""

#: ../../../networking/kcm.rst:248
msgid ""
"The primary purpose of KCM is load balancing between KCM sockets and hence "
"threads in a nominal use case. Perfect load balancing, that is steering each "
"received message to a different KCM socket or steering each sent message to "
"a different TCP socket, can negatively impact performance since this doesn't "
"allow for affinities to be established. Balancing based on groups, or "
"batches of messages, can be beneficial for performance."
msgstr ""

#: ../../../networking/kcm.rst:255
msgid ""
"On transmit, there are three ways an application can batch (pipeline) "
"messages on a KCM socket."
msgstr ""

#: ../../../networking/kcm.rst:258
msgid "Send multiple messages in a single sendmmsg."
msgstr ""

#: ../../../networking/kcm.rst:259
msgid ""
"Send a group of messages each with a sendmsg call, where all messages except "
"the last have MSG_BATCH in the flags of sendmsg call."
msgstr ""

#: ../../../networking/kcm.rst:261
msgid ""
"Create \"super message\" composed of multiple messages and send this with a "
"single sendmsg."
msgstr ""

#: ../../../networking/kcm.rst:264
msgid ""
"On receive, the KCM module attempts to queue messages received on the same "
"KCM socket during each TCP ready callback. The targeted KCM socket changes "
"at each receive ready callback on the KCM socket. The application does not "
"need to configure this."
msgstr ""

#: ../../../networking/kcm.rst:270
msgid "Error handling"
msgstr ""

#: ../../../networking/kcm.rst:272
msgid ""
"An application should include a thread to monitor errors raised on the TCP "
"connection. Normally, this will be done by placing each TCP socket attached "
"to a KCM multiplexor in epoll set for POLLERR event. If an error occurs on "
"an attached TCP socket, KCM sets an EPIPE on the socket thus waking up the "
"application thread. When the application sees the error (which may just be a "
"disconnect) it should unattach the socket from KCM and then close it. It is "
"assumed that once an error is posted on the TCP socket the data stream is "
"unrecoverable (i.e. an error may have occurred in the middle of receiving a "
"message)."
msgstr ""

#: ../../../networking/kcm.rst:283
msgid "TCP connection monitoring"
msgstr ""

#: ../../../networking/kcm.rst:285
msgid ""
"In KCM there is no means to correlate a message to the TCP socket that was "
"used to send or receive the message (except in the case there is only one "
"attached TCP socket). However, the application does retain an open file "
"descriptor to the socket so it will be able to get statistics from the "
"socket which can be used in detecting issues (such as high retransmissions "
"on the socket)."
msgstr ""
