# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/mctp.rst:5
msgid "Management Component Transport Protocol (MCTP)"
msgstr ""

#: ../../../networking/mctp.rst:7
msgid ""
"net/mctp/ contains protocol support for MCTP, as defined by DMTF standard "
"DSP0236. Physical interface drivers (\"bindings\" in the specification) are "
"provided in drivers/net/mctp/."
msgstr ""

#: ../../../networking/mctp.rst:11
msgid ""
"The core code provides a socket-based interface to send and receive MCTP "
"messages, through an AF_MCTP, SOCK_DGRAM socket."
msgstr ""

#: ../../../networking/mctp.rst:15
msgid "Structure: interfaces & networks"
msgstr ""

#: ../../../networking/mctp.rst:17
msgid ""
"The kernel models the local MCTP topology through two items: interfaces and "
"networks."
msgstr ""

#: ../../../networking/mctp.rst:20
msgid ""
"An interface (or \"link\") is an instance of an MCTP physical transport "
"binding (as defined by DSP0236, section 3.2.47), likely connected to a "
"specific hardware device. This is represented as a ``struct netdevice``."
msgstr ""

#: ../../../networking/mctp.rst:24
msgid ""
"A network defines a unique address space for MCTP endpoints by endpoint-ID "
"(described by DSP0236, section 3.2.31). A network has a user-visible "
"identifier to allow references from userspace. Route definitions are "
"specific to one network."
msgstr ""

#: ../../../networking/mctp.rst:29
msgid ""
"Interfaces are associated with one network. A network may be associated with "
"one or more interfaces."
msgstr ""

#: ../../../networking/mctp.rst:32
msgid ""
"If multiple networks are present, each may contain endpoint IDs (EIDs) that "
"are also present on other networks."
msgstr ""

#: ../../../networking/mctp.rst:36
msgid "Sockets API"
msgstr ""

#: ../../../networking/mctp.rst:39
msgid "Protocol definitions"
msgstr ""

#: ../../../networking/mctp.rst:41
msgid ""
"MCTP uses ``AF_MCTP`` / ``PF_MCTP`` for the address- and protocol- families. "
"Since MCTP is message-based, only ``SOCK_DGRAM`` sockets are supported."
msgstr ""

#: ../../../networking/mctp.rst:48
msgid "The only (current) value for the ``protocol`` argument is 0."
msgstr ""

#: ../../../networking/mctp.rst:50
msgid ""
"As with all socket address families, source and destination addresses are "
"specified with a ``sockaddr`` type, with a single-byte endpoint address:"
msgstr ""

#: ../../../networking/mctp.rst:74
msgid "Syscall behaviour"
msgstr ""

#: ../../../networking/mctp.rst:76
msgid ""
"The following sections describe the MCTP-specific behaviours of the standard "
"socket system calls. These behaviours have been chosen to map closely to the "
"existing sockets APIs."
msgstr ""

#: ../../../networking/mctp.rst:81
msgid "``bind()`` : set local socket address"
msgstr ""

#: ../../../networking/mctp.rst:83
msgid ""
"Sockets that receive incoming request packets will bind to a local address, "
"using the ``bind()`` syscall."
msgstr ""

#: ../../../networking/mctp.rst:98
msgid ""
"This establishes the local address of the socket. Incoming MCTP messages "
"that match the network, address, and message type will be received by this "
"socket. The reference to 'incoming' is important here; a bound socket will "
"only receive messages with the TO bit set, to indicate an incoming request "
"message, rather than a response."
msgstr ""

#: ../../../networking/mctp.rst:104
msgid ""
"The ``smctp_tag`` value will configure the tags accepted from the remote "
"side of this socket. Given the above, the only valid value is "
"``MCTP_TAG_OWNER``, which will result in remotely \"owned\" tags being "
"routed to this socket. Since ``MCTP_TAG_OWNER`` is set, the 3 least-"
"significant bits of ``smctp_tag`` are not used; callers must set them to "
"zero."
msgstr ""

#: ../../../networking/mctp.rst:110
msgid ""
"A ``smctp_network`` value of ``MCTP_NET_ANY`` will configure the socket to "
"receive incoming packets from any locally-connected network. A specific "
"network value will cause the socket to only receive incoming messages from "
"that network."
msgstr ""

#: ../../../networking/mctp.rst:114
msgid ""
"The ``smctp_addr`` field specifies a local address to bind to. A value of "
"``MCTP_ADDR_ANY`` configures the socket to receive messages addressed to any "
"local destination EID."
msgstr ""

#: ../../../networking/mctp.rst:118
msgid ""
"The ``smctp_type`` field specifies which message types to receive. Only the "
"lower 7 bits of the type is matched on incoming messages (ie., the most-"
"significant IC bit is not part of the match). This results in the socket "
"receiving packets with and without a message integrity check footer."
msgstr ""

#: ../../../networking/mctp.rst:124
msgid "``sendto()``, ``sendmsg()``, ``send()`` : transmit an MCTP message"
msgstr ""

#: ../../../networking/mctp.rst:126
msgid ""
"An MCTP message is transmitted using one of the ``sendto()``, ``sendmsg()`` "
"or ``send()`` syscalls. Using ``sendto()`` as the primary example:"
msgstr ""

#: ../../../networking/mctp.rst:149
msgid ""
"The network and address fields of ``addr`` define the remote address to send "
"to. If ``smctp_tag`` has the ``MCTP_TAG_OWNER``, the kernel will ignore any "
"bits set in ``MCTP_TAG_VALUE``, and generate a tag value suitable for the "
"destination EID. If ``MCTP_TAG_OWNER`` is not set, the message will be sent "
"with the tag value as specified. If a tag value cannot be allocated, the "
"system call will report an errno of ``EAGAIN``."
msgstr ""

#: ../../../networking/mctp.rst:156
msgid ""
"The application must provide the message type byte as the first byte of the "
"message buffer passed to ``sendto()``. If a message integrity check is to be "
"included in the transmitted message, it must also be provided in the message "
"buffer, and the most-significant bit of the message type byte must be 1."
msgstr ""

#: ../../../networking/mctp.rst:161
msgid ""
"The ``sendmsg()`` system call allows a more compact argument interface, and "
"the message buffer to be specified as a scatter-gather list. At present no "
"ancillary message types (used for the ``msg_control`` data passed to "
"``sendmsg()``) are defined."
msgstr ""

#: ../../../networking/mctp.rst:166
msgid ""
"Transmitting a message on an unconnected socket with ``MCTP_TAG_OWNER`` "
"specified will cause an allocation of a tag, if no valid tag is already "
"allocated for that destination. The (destination-eid,tag) tuple acts as an "
"implicit local socket address, to allow the socket to receive responses to "
"this outgoing message. If any previous allocation has been performed (to for "
"a different remote EID), that allocation is lost."
msgstr ""

#: ../../../networking/mctp.rst:173
msgid ""
"Sockets will only receive responses to requests they have sent (with TO=1) "
"and may only respond (with TO=0) to requests they have received."
msgstr ""

#: ../../../networking/mctp.rst:177
msgid "``recvfrom()``, ``recvmsg()``, ``recv()`` : receive an MCTP message"
msgstr ""

#: ../../../networking/mctp.rst:179
msgid ""
"An MCTP message can be received by an application using one of the "
"``recvfrom()``, ``recvmsg()``, or ``recv()`` system calls. Using "
"``recvfrom()`` as the primary example:"
msgstr ""

#: ../../../networking/mctp.rst:201
msgid ""
"The address argument to ``recvfrom`` and ``recvmsg`` is populated with the "
"remote address of the incoming message, including tag value (this will be "
"needed in order to reply to the message)."
msgstr ""

#: ../../../networking/mctp.rst:205
msgid ""
"The first byte of the message buffer will contain the message type byte. If "
"an integrity check follows the message, it will be included in the received "
"buffer."
msgstr ""

#: ../../../networking/mctp.rst:208
msgid ""
"The ``recv()`` system call behaves in a similar way, but does not provide a "
"remote address to the application. Therefore, these are only useful if the "
"remote address is already known, or the message does not require a reply."
msgstr ""

#: ../../../networking/mctp.rst:212
msgid ""
"Like the send calls, sockets will only receive responses to requests they "
"have sent (TO=1) and may only respond (TO=0) to requests they have received."
msgstr ""

#: ../../../networking/mctp.rst:216
msgid "``ioctl(SIOCMCTPALLOCTAG)`` and ``ioctl(SIOCMCTPDROPTAG)``"
msgstr ""

#: ../../../networking/mctp.rst:218
msgid ""
"These tags give applications more control over MCTP message tags, by "
"allocating (and dropping) tag values explicitly, rather than the kernel "
"automatically allocating a per-message tag at ``sendmsg()`` time."
msgstr ""

#: ../../../networking/mctp.rst:222
msgid ""
"In general, you will only need to use these ioctls if your MCTP protocol "
"does not fit the usual request/response model. For example, if you need to "
"persist tags across multiple requests, or a request may generate more than "
"one response. In these cases, the ioctls allow you to decouple the tag "
"allocation (and release) from individual message send and receive operations."
msgstr ""

#: ../../../networking/mctp.rst:228
msgid "Both ioctls are passed a pointer to a ``struct mctp_ioc_tag_ctl``:"
msgstr ""

#: ../../../networking/mctp.rst:238
msgid ""
"``SIOCMCTPALLOCTAG`` allocates a tag for a specific peer, which an "
"application can use in future ``sendmsg()`` calls. The application populates "
"the ``peer_addr`` member with the remote EID. Other fields must be zero."
msgstr ""

#: ../../../networking/mctp.rst:242
msgid ""
"On return, the ``tag`` member will be populated with the allocated tag "
"value. The allocated tag will have the following tag bits set:"
msgstr ""

#: ../../../networking/mctp.rst:245
msgid ""
"``MCTP_TAG_OWNER``: it only makes sense to allocate tags if you're the tag "
"owner"
msgstr ""

#: ../../../networking/mctp.rst:248
msgid ""
"``MCTP_TAG_PREALLOC``: to indicate to ``sendmsg()`` that this is a "
"preallocated tag."
msgstr ""

#: ../../../networking/mctp.rst:251
msgid ""
"... and the actual tag value, within the least-significant three bits "
"(``MCTP_TAG_MASK``). Note that zero is a valid tag value."
msgstr ""

#: ../../../networking/mctp.rst:254
msgid ""
"The tag value should be used as-is for the ``smctp_tag`` member of ``struct "
"sockaddr_mctp``."
msgstr ""

#: ../../../networking/mctp.rst:257
msgid ""
"``SIOCMCTPDROPTAG`` releases a tag that has been previously allocated by a "
"``SIOCMCTPALLOCTAG`` ioctl. The ``peer_addr`` must be the same as used for "
"the allocation, and the ``tag`` value must match exactly the tag returned "
"from the allocation (including the ``MCTP_TAG_OWNER`` and "
"``MCTP_TAG_PREALLOC`` bits). The ``flags`` field must be zero."
msgstr ""

#: ../../../networking/mctp.rst:264
msgid "Kernel internals"
msgstr ""

#: ../../../networking/mctp.rst:266
msgid "There are a few possible packet flows in the MCTP stack:"
msgstr ""

#: ../../../networking/mctp.rst:268
msgid "local TX to remote endpoint, message <= MTU::"
msgstr ""

#: ../../../networking/mctp.rst:276
msgid "local TX to remote endpoint, message > MTU::"
msgstr ""

#: ../../../networking/mctp.rst:285
msgid "remote TX to local endpoint, single-packet message::"
msgstr ""

#: ../../../networking/mctp.rst:293
msgid "remote TX to local endpoint, multiple-packet message::"
msgstr ""

#: ../../../networking/mctp.rst:310
msgid "Key refcounts"
msgstr ""

#: ../../../networking/mctp.rst:312
msgid "keys are refed by:"
msgstr ""

#: ../../../networking/mctp.rst:314
msgid "a skb: during route output, stored in ``skb->cb``."
msgstr ""

#: ../../../networking/mctp.rst:316
msgid "netns and sock lists."
msgstr ""

#: ../../../networking/mctp.rst:318
msgid ""
"keys can be associated with a device, in which case they hold a reference to "
"the dev (set through ``key->dev``, counted through ``dev->key_count``). "
"Multiple keys can reference the device."
msgstr ""
