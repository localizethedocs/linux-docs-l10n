# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/tls.rst:5
msgid "Kernel TLS"
msgstr ""

#: ../../../networking/tls.rst:8
msgid "Overview"
msgstr ""

#: ../../../networking/tls.rst:10
msgid ""
"Transport Layer Security (TLS) is a Upper Layer Protocol (ULP) that runs "
"over TCP. TLS provides end-to-end data integrity and confidentiality."
msgstr ""

#: ../../../networking/tls.rst:14
msgid "User interface"
msgstr ""

#: ../../../networking/tls.rst:17
msgid "Creating a TLS connection"
msgstr ""

#: ../../../networking/tls.rst:19
msgid ""
"First create a new TCP socket and once the connection is established set the "
"TLS ULP."
msgstr ""

#: ../../../networking/tls.rst:28
msgid ""
"Setting the TLS ULP allows us to set/get TLS socket options. Currently only "
"the symmetric encryption is handled in the kernel.  After the TLS handshake "
"is complete, we have all the parameters required to move the data-path to "
"the kernel. There is a separate socket option for moving the transmit and "
"the receive into the kernel."
msgstr ""

#: ../../../networking/tls.rst:63
msgid ""
"Transmit and receive are set separately, but the setup is the same, using "
"either TLS_TX or TLS_RX."
msgstr ""

#: ../../../networking/tls.rst:67
msgid "Sending TLS application data"
msgstr ""

#: ../../../networking/tls.rst:69
msgid ""
"After setting the TLS_TX socket option all application data sent over this "
"socket is encrypted using TLS and the parameters provided in the socket "
"option. For example, we can send an encrypted hello world record as follows:"
msgstr ""

#: ../../../networking/tls.rst:78
msgid ""
"send() data is directly encrypted from the userspace buffer provided to the "
"encrypted kernel send buffer if possible."
msgstr ""

#: ../../../networking/tls.rst:81
msgid ""
"The sendfile system call will send the file's data over TLS records of "
"maximum length (2^14)."
msgstr ""

#: ../../../networking/tls.rst:90
msgid ""
"TLS records are created and sent after each send() call, unless MSG_MORE is "
"passed.  MSG_MORE will delay creation of a record until MSG_MORE is not "
"passed, or the maximum record size is reached."
msgstr ""

#: ../../../networking/tls.rst:94
msgid ""
"The kernel will need to allocate a buffer for the encrypted data. This "
"buffer is allocated at the time send() is called, such that either the "
"entire send() call will return -ENOMEM (or block waiting for memory), or the "
"encryption will always succeed.  If send() returns -ENOMEM and some data was "
"left on the socket buffer from a previous call using MSG_MORE, the MSG_MORE "
"data is left on the socket buffer."
msgstr ""

#: ../../../networking/tls.rst:102
msgid "Receiving TLS application data"
msgstr ""

#: ../../../networking/tls.rst:104
msgid ""
"After setting the TLS_RX socket option, all recv family socket calls are "
"decrypted using TLS parameters provided.  A full TLS record must be received "
"before decryption can happen."
msgstr ""

#: ../../../networking/tls.rst:113
msgid ""
"Received data is decrypted directly in to the user buffer if it is large "
"enough, and no additional allocations occur.  If the userspace buffer is too "
"small, data is decrypted in the kernel and copied to userspace."
msgstr ""

#: ../../../networking/tls.rst:118
msgid ""
"``EINVAL`` is returned if the TLS version in the received message does not "
"match the version passed in setsockopt."
msgstr ""

#: ../../../networking/tls.rst:121
msgid "``EMSGSIZE`` is returned if the received message is too big."
msgstr ""

#: ../../../networking/tls.rst:123
msgid "``EBADMSG`` is returned if decryption failed for any other reason."
msgstr ""

#: ../../../networking/tls.rst:126
msgid "Send TLS control messages"
msgstr ""

#: ../../../networking/tls.rst:128
msgid ""
"Other than application data, TLS has control messages such as alert messages "
"(record type 21) and handshake messages (record type 22), etc. These "
"messages can be sent over the socket by providing the TLS record type via a "
"CMSG. For example the following function sends @data of @length bytes using "
"a record of type @record_type."
msgstr ""

#: ../../../networking/tls.rst:163
msgid ""
"Control message data should be provided unencrypted, and will be encrypted "
"by the kernel."
msgstr ""

#: ../../../networking/tls.rst:167
msgid "Receiving TLS control messages"
msgstr ""

#: ../../../networking/tls.rst:169
msgid ""
"TLS control messages are passed in the userspace buffer, with message type "
"passed via cmsg.  If no cmsg buffer is provided, an error is returned if a "
"control message is received.  Data messages may be received without a cmsg "
"buffer set."
msgstr ""

#: ../../../networking/tls.rst:203
msgid "recv will never return data from mixed types of TLS records."
msgstr ""

#: ../../../networking/tls.rst:206
msgid "TLS 1.3 Key Updates"
msgstr ""

#: ../../../networking/tls.rst:208
msgid ""
"In TLS 1.3, KeyUpdate handshake messages signal that the sender is updating "
"its TX key. Any message sent after a KeyUpdate will be encrypted using the "
"new key. The userspace library can pass the new key to the kernel using the "
"TLS_TX and TLS_RX socket options, as for the initial keys. TLS version and "
"cipher cannot be changed."
msgstr ""

#: ../../../networking/tls.rst:214
msgid ""
"To prevent attempting to decrypt incoming records using the wrong key, "
"decryption will be paused when a KeyUpdate message is received by the "
"kernel, until the new key has been provided using the TLS_RX socket option. "
"Any read occurring after the KeyUpdate has been read and before the new key "
"is provided will fail with EKEYEXPIRED. poll() will not report any read "
"events from the socket until the new key is provided. There is no pausing on "
"the transmit side."
msgstr ""

#: ../../../networking/tls.rst:222
msgid ""
"Userspace should make sure that the crypto_info provided has been set "
"properly. In particular, the kernel will not check for key/nonce reuse."
msgstr ""

#: ../../../networking/tls.rst:226
msgid ""
"The number of successful and failed key updates is tracked in the "
"``TlsTxRekeyOk``, ``TlsRxRekeyOk``, ``TlsTxRekeyError``, ``TlsRxRekeyError`` "
"statistics. The ``TlsRxRekeyReceived`` statistic counts KeyUpdate handshake "
"messages that have been received."
msgstr ""

#: ../../../networking/tls.rst:232
msgid "Integrating in to userspace TLS library"
msgstr ""

#: ../../../networking/tls.rst:234
msgid ""
"At a high level, the kernel TLS ULP is a replacement for the record layer of "
"a userspace TLS library."
msgstr ""

#: ../../../networking/tls.rst:237
msgid ""
"A patchset to OpenSSL to use ktls as the record layer is `here <https://"
"github.com/Mellanox/openssl/commits/tls_rx2>`_."
msgstr ""

#: ../../../networking/tls.rst:240
msgid ""
"`An example <https://github.com/ktls/af_ktls-tool/commits/RX>`_ of calling "
"send directly after a handshake using gnutls. Since it doesn't implement a "
"full record layer, control messages are not supported."
msgstr ""

#: ../../../networking/tls.rst:246
msgid "Optional optimizations"
msgstr ""

#: ../../../networking/tls.rst:248
msgid ""
"There are certain condition-specific optimizations the TLS ULP can make, if "
"requested. Those optimizations are either not universally beneficial or may "
"impact correctness, hence they require an opt-in. All options are set per-"
"socket using setsockopt(), and their state can be checked using getsockopt() "
"and via socket diag (``ss``)."
msgstr ""

#: ../../../networking/tls.rst:255
msgid "TLS_TX_ZEROCOPY_RO"
msgstr ""

#: ../../../networking/tls.rst:257
msgid ""
"For device offload only. Allow sendfile() data to be transmitted directly to "
"the NIC without making an in-kernel copy. This allows true zero-copy "
"behavior when device offload is enabled."
msgstr ""

#: ../../../networking/tls.rst:261
msgid ""
"The application must make sure that the data is not modified between being "
"submitted and transmission completing. In other words this is mostly "
"applicable if the data sent on a socket via sendfile() is read-only."
msgstr ""

#: ../../../networking/tls.rst:265
msgid ""
"Modifying the data may result in different versions of the data being used "
"for the original TCP transmission and TCP retransmissions. To the receiver "
"this will look like TLS records had been tampered with and will result in "
"record authentication failures."
msgstr ""

#: ../../../networking/tls.rst:271
msgid "TLS_RX_EXPECT_NO_PAD"
msgstr ""

#: ../../../networking/tls.rst:273
msgid ""
"TLS 1.3 only. Expect the sender to not pad records. This allows the data to "
"be decrypted directly into user space buffers with TLS 1.3."
msgstr ""

#: ../../../networking/tls.rst:276
msgid ""
"This optimization is safe to enable only if the remote end is trusted, "
"otherwise it is an attack vector to doubling the TLS processing cost."
msgstr ""

#: ../../../networking/tls.rst:279
msgid ""
"If the record decrypted turns out to had been padded or is not a data record "
"it will be decrypted again into a kernel buffer without zero copy. Such "
"events are counted in the ``TlsDecryptRetry`` statistic."
msgstr ""

#: ../../../networking/tls.rst:284
msgid "Statistics"
msgstr ""

#: ../../../networking/tls.rst:286
msgid ""
"TLS implementation exposes the following per-namespace statistics (``/proc/"
"net/tls_stat``):"
msgstr ""

#: ../../../networking/tls.rst:289
msgid ""
"``TlsCurrTxSw``, ``TlsCurrRxSw`` - number of TX and RX sessions currently "
"installed where host handles cryptography"
msgstr ""

#: ../../../networking/tls.rst:293
msgid ""
"``TlsCurrTxDevice``, ``TlsCurrRxDevice`` - number of TX and RX sessions "
"currently installed where NIC handles cryptography"
msgstr ""

#: ../../../networking/tls.rst:297
msgid ""
"``TlsTxSw``, ``TlsRxSw`` - number of TX and RX sessions opened with host "
"cryptography"
msgstr ""

#: ../../../networking/tls.rst:300
msgid ""
"``TlsTxDevice``, ``TlsRxDevice`` - number of TX and RX sessions opened with "
"NIC cryptography"
msgstr ""

#: ../../../networking/tls.rst:303
msgid ""
"``TlsDecryptError`` - record decryption failed (e.g. due to incorrect "
"authentication tag)"
msgstr ""

#: ../../../networking/tls.rst:306
msgid ""
"``TlsDeviceRxResync`` - number of RX resyncs sent to NICs handling "
"cryptography"
msgstr ""

#: ../../../networking/tls.rst:309
msgid ""
"``TlsDecryptRetry`` - number of RX records which had to be re-decrypted due "
"to ``TLS_RX_EXPECT_NO_PAD`` mis-prediction. Note that this counter will also "
"increment for non-data records."
msgstr ""

#: ../../../networking/tls.rst:314
msgid ""
"``TlsRxNoPadViolation`` - number of data RX records which had to be re-"
"decrypted due to ``TLS_RX_EXPECT_NO_PAD`` mis-prediction."
msgstr ""

#: ../../../networking/tls.rst:318
msgid ""
"``TlsTxRekeyOk``, ``TlsRxRekeyOk`` - number of successful rekeys on existing "
"sessions for TX and RX"
msgstr ""

#: ../../../networking/tls.rst:321
msgid ""
"``TlsTxRekeyError``, ``TlsRxRekeyError`` - number of failed rekeys on "
"existing sessions for TX and RX"
msgstr ""

#: ../../../networking/tls.rst:324
msgid ""
"``TlsRxRekeyReceived`` - number of received KeyUpdate handshake messages, "
"requiring userspace to provide a new RX key"
msgstr ""
