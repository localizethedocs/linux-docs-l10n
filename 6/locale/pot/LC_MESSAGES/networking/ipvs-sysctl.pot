# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/ipvs-sysctl.rst:5
msgid "IPvs-sysctl"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:8
msgid "/proc/sys/net/ipv4/vs/* Variables:"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:10
msgid "am_droprate - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:11
msgid "default 10"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:13
msgid ""
"It sets the always mode drop rate, which is used in the mode 3 of the "
"drop_rate defense."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:16
msgid "amemthresh - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:17
msgid "default 1024"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:19
msgid ""
"It sets the available memory threshold (in pages), which is used in the "
"automatic modes of defense. When there is no enough available memory, the "
"respective strategy will be enabled and the variable is automatically set to "
"2, otherwise the strategy is disabled and the variable is  set  to 1."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:25
msgid "backup_only - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:26
#: ../../../networking/ipvs-sysctl.rst:53
#: ../../../networking/ipvs-sysctl.rst:70
#: ../../../networking/ipvs-sysctl.rst:153
#: ../../../networking/ipvs-sysctl.rst:171
#: ../../../networking/ipvs-sysctl.rst:187
#: ../../../networking/ipvs-sysctl.rst:197
msgid "0 - disabled (default)"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:27
#: ../../../networking/ipvs-sysctl.rst:54
#: ../../../networking/ipvs-sysctl.rst:71
#: ../../../networking/ipvs-sysctl.rst:154
#: ../../../networking/ipvs-sysctl.rst:172
#: ../../../networking/ipvs-sysctl.rst:188
#: ../../../networking/ipvs-sysctl.rst:198
msgid "not 0 - enabled"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:29
msgid ""
"If set, disable the director function while the server is in backup mode to "
"avoid packet loops for DR/TUN methods."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:32
msgid "conn_reuse_mode - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:33
msgid "1 - default"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:35
msgid ""
"Controls how ipvs will deal with connections that are detected port reuse. "
"It is a bitmap, with the values being:"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:38
msgid ""
"0: disable any special handling on port reuse. The new connection will be "
"delivered to the same real server that was servicing the previous connection."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:42
msgid ""
"bit 1: enable rescheduling of new connections when it is safe. That is, "
"whenever expire_nodest_conn and for TCP sockets, when the connection is in "
"TIME_WAIT state (which is only possible if you use NAT mode)."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:47
msgid ""
"bit 2: it is bit 1 plus, for TCP connections, when connections are in "
"FIN_WAIT state, as this is the last state seen by load balancer in Direct "
"Routing mode. This bit helps on adding new real servers to a very busy "
"cluster."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:52
msgid "conntrack - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:56
msgid ""
"If set, maintain connection tracking entries for connections handled by IPVS."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:59
msgid ""
"This should be enabled if connections handled by IPVS are to be also handled "
"by stateful firewall rules. That is, iptables rules that make use of "
"connection tracking.  It is a performance optimisation to disable this "
"setting otherwise."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:64
msgid ""
"Connections handled by the IPVS FTP application module will have connection "
"tracking entries regardless of this setting."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:67
msgid "Only available when IPVS is compiled with CONFIG_IP_VS_NFCT enabled."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:69
msgid "cache_bypass - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:73
msgid ""
"If it is enabled, forward packets to the original destination directly when "
"no cache server is available and destination address is not local (iph-"
">daddr is RTN_UNICAST). It is mostly used in transparent web cache cluster."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:78
msgid "debug_level - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:79
msgid "0          - transmission error messages (default)"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:80
msgid "1          - non-fatal error messages"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:81
msgid "2          - configuration"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:82
msgid "3          - destination trash"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:83
msgid "4          - drop entry"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:84
msgid "5          - service lookup"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:85
msgid "6          - scheduling"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:86
msgid "7          - connection new/expire, lookup and synchronization"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:87
msgid "8          - state transition"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:88
msgid "9          - binding destination, template checks and applications"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:89
msgid "10         - IPVS packet transmission"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:90
msgid "11         - IPVS packet handling (ip_vs_in/ip_vs_out)"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:91
msgid "12 or more - packet traversal"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:93
msgid "Only available when IPVS is compiled with CONFIG_IP_VS_DEBUG enabled."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:95
msgid ""
"Higher debugging levels include the messages for lower debugging levels, so "
"setting debug level 2, includes level 0, 1 and 2 messages. Thus, logging "
"becomes more and more verbose the higher the level."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:100
msgid "drop_entry - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:101
#: ../../../networking/ipvs-sysctl.rst:119
#: ../../../networking/ipvs-sysctl.rst:213
msgid "0  - disabled (default)"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:103
msgid ""
"The drop_entry defense is to randomly drop entries in the connection hash "
"table, just in order to collect back some memory for new connections. In the "
"current code, the drop_entry procedure can be activated every second, then "
"it randomly scans 1/32 of the whole and drops entries that are in the SYN-"
"RECV/SYNACK state, which should be effective against syn-flooding attack."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:111
msgid ""
"The valid values of drop_entry are from 0 to 3, where 0 means that this "
"strategy is always disabled, 1 and 2 mean automatic modes (when there is no "
"enough available memory, the strategy is enabled and the variable is "
"automatically set to 2, otherwise the strategy is disabled and the variable "
"is set to 1), and 3 means that the strategy is always enabled."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:118
msgid "drop_packet - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:121
msgid ""
"The drop_packet defense is designed to drop 1/rate packets before forwarding "
"them to real servers. If the rate is 1, then drop all the incoming packets."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:125
msgid ""
"The value definition is the same as that of the drop_entry. In the automatic "
"mode, the rate is determined by the follow formula: rate = amemthresh / "
"(amemthresh - available_memory) when available memory is less than the "
"available memory threshold. When the mode 3 is set, the always mode drop "
"rate is controlled by the /proc/sys/net/ipv4/vs/am_droprate."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:132
msgid "est_cpulist - CPULIST"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:133
msgid "Allowed CPUs for estimation kthreads"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:135
msgid ""
"Syntax: standard cpulist format empty list - stop kthread tasks and "
"estimation default - the system's housekeeping CPUs for kthreads"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:139
msgid ""
"Example: \"all\": all possible CPUs \"0-N\": all possible CPUs, N denotes "
"last CPU number \"0,1-N:1/2\": first and all CPUs with odd number \"\": "
"empty list"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:145
msgid "est_nice - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:146
msgid "default 0 Valid range: -20 (more favorable) .. 19 (less favorable)"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:149
msgid "Niceness value to use for the estimation kthreads (scheduling priority)"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:152
msgid "expire_nodest_conn - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:156
msgid ""
"The default value is 0, the load balancer will silently drop packets when "
"its destination server is not available. It may be useful, when user-space "
"monitoring program deletes the destination server (because of server "
"overload or wrong detection) and add back the server later, and the "
"connections to the server can continue."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:163
msgid ""
"If this feature is enabled, the load balancer will expire the connection "
"immediately when a packet arrives and its destination server is not "
"available, then the client program will be notified that the connection is "
"closed. This is equivalent to the feature some people requires to flush "
"connections when its destination is not available."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:170
msgid "expire_quiescent_template - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:174
msgid ""
"When set to a non-zero value, the load balancer will expire persistent "
"templates when the destination server is quiescent. This may be useful, when "
"a user makes a destination server quiescent by setting its weight to 0 and "
"it is desired that subsequent otherwise persistent connections are sent to a "
"different destination server.  By default new persistent connections are "
"allowed to quiescent destination servers."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:182
msgid ""
"If this feature is enabled, the load balancer will expire the persistence "
"template if it is to be used to schedule a new connection and the "
"destination server is quiescent."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:186
msgid "ignore_tunneled - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:190
msgid ""
"If set, ipvs will set the ipvs_property on all packets which are of "
"unrecognized protocols.  This prevents us from routing tunneled protocols "
"like ipip, which is useful to prevent rescheduling packets that have been "
"tunneled to the ipvs host (i.e. to prevent ipvs routing loops when ipvs is "
"also acting as a real server)."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:196
msgid "nat_icmp_send - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:200
msgid ""
"It controls sending icmp error messages (ICMP_DEST_UNREACH) for VS/NAT when "
"the load balancer receives packets from real servers but the connection "
"entries don't exist."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:204
msgid "pmtu_disc - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:205
#: ../../../networking/ipvs-sysctl.rst:277
msgid "0 - disabled"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:206
#: ../../../networking/ipvs-sysctl.rst:278
msgid "not 0 - enabled (default)"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:208
msgid ""
"By default, reject with FRAG_NEEDED all DF packets that exceed the PMTU, "
"irrespective of the forwarding method. For TUN method the flag can be "
"disabled to fragment such packets."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:212
msgid "secure_tcp - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:215
msgid ""
"The secure_tcp defense is to use a more complicated TCP state transition "
"table. For VS/NAT, it also delays entering the TCP ESTABLISHED state until "
"the three way handshake is completed."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:219
msgid "The value definition is the same as that of drop_entry and drop_packet."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:222
msgid "sync_threshold - vector of 2 INTEGERs: sync_threshold, sync_period"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:223
msgid "default 3 50"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:225
msgid ""
"It sets synchronization threshold, which is the minimum number of incoming "
"packets that a connection needs to receive before the connection will be "
"synchronized. A connection will be synchronized, every time the number of "
"its incoming packets modulus sync_period equals the threshold. The range of "
"the threshold is from 0 to sync_period."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:232
msgid ""
"When sync_period and sync_refresh_period are 0, send sync only for state "
"changes or only once when pkts matches sync_threshold"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:235
msgid "sync_refresh_period - UNSIGNED INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:236
#: ../../../networking/ipvs-sysctl.rst:248
#: ../../../networking/ipvs-sysctl.rst:263
#: ../../../networking/ipvs-sysctl.rst:294
msgid "default 0"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:238
msgid ""
"In seconds, difference in reported connection timer that triggers new sync "
"message. It can be used to avoid sync messages for the specified period (or "
"half of the connection timeout if it is lower) if connection state is not "
"changed since last sync."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:243
msgid ""
"This is useful for normal connections with high traffic to reduce sync rate. "
"Additionally, retry sync_retries times with period of sync_refresh_period/8."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:247
msgid "sync_retries - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:250
msgid ""
"Defines sync retries with period of sync_refresh_period/8. Useful to protect "
"against loss of sync messages. The range of the sync_retries is from 0 to 3."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:254
msgid "sync_qlen_max - UNSIGNED LONG"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:256
msgid ""
"Hard limit for queued sync messages that are not sent yet. It defaults to "
"1/32 of the memory pages but actually represents number of messages. It will "
"protect us from allocating large parts of memory when the sending rate is "
"lower than the queuing rate."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:262
msgid "sync_sock_size - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:265
msgid ""
"Configuration of SNDBUF (master) or RCVBUF (slave) socket limit. Default "
"value is 0 (preserve system defaults)."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:268
msgid "sync_ports - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:269
#: ../../../networking/ipvs-sysctl.rst:308
msgid "default 1"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:271
msgid ""
"The number of threads that master and backup servers can use for sync "
"traffic. Every thread will use single UDP port, thread 0 will use the "
"default port 8848 while last thread will use port 8848+sync_ports-1."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:276
msgid "snat_reroute - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:280
msgid ""
"If enabled, recalculate the route of SNATed packets from realservers so that "
"they are routed as if they originate from the director. Otherwise they are "
"routed as if they are forwarded by the director."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:285
msgid ""
"If policy routing is in effect then it is possible that the route of a "
"packet originating from a director is routed differently to a packet being "
"forwarded by the director."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:289
msgid ""
"If policy routing is not in effect then the recalculated route will always "
"be the same as the original route so it is an optimisation to disable "
"snat_reroute and avoid the recalculation."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:293
msgid "sync_persist_mode - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:296
msgid "Controls the synchronisation of connections when using persistence"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:298
msgid "0: All types of connections are synchronised"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:300
msgid ""
"1: Attempt to reduce the synchronisation traffic depending on the connection "
"type. For persistent services avoid synchronisation for normal connections, "
"do it only for persistence templates. In such case, for TCP and SCTP it may "
"need enabling sloppy_tcp and sloppy_sctp flags on backup servers. For non-"
"persistent services such optimization is not applied, mode 0 is assumed."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:307
msgid "sync_version - INTEGER"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:310
msgid ""
"The version of the synchronisation protocol used when sending "
"synchronisation messages."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:313
msgid ""
"0 selects the original synchronisation protocol (version 0). This should be "
"used when sending synchronisation messages to a legacy system that only "
"understands the original synchronisation protocol."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:317
msgid ""
"1 selects the current synchronisation protocol (version 1). This should be "
"used where possible."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:320
msgid ""
"Kernels with this sync_version entry are able to receive messages of both "
"version 1 and version 2 of the synchronisation protocol."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:323
msgid "run_estimation - BOOLEAN"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:324
msgid "0 - disabled not 0 - enabled (default)"
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:327
msgid ""
"If disabled, the estimation will be suspended and kthread tasks stopped."
msgstr ""

#: ../../../networking/ipvs-sysctl.rst:330
msgid ""
"You can always re-enable estimation by setting this value to 1. But be "
"careful, the first estimation after re-enable is not accurate."
msgstr ""
