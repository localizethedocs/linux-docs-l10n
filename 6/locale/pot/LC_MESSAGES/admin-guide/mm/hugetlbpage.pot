# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/mm/hugetlbpage.rst:3
msgid "HugeTLB Pages"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:6
msgid "Overview"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:8
msgid ""
"The intent of this file is to give a brief summary of hugetlbpage support in "
"the Linux kernel.  This support is built on top of multiple page size "
"support that is provided by most modern architectures.  For example, x86 "
"CPUs normally support 4K and 2M (1G if architecturally supported) page "
"sizes, ia64 architecture supports multiple page sizes 4K, 8K, 64K, 256K, 1M, "
"4M, 16M, 256M and ppc64 supports 4K and 16M.  A TLB is a cache of virtual-to-"
"physical translations.  Typically this is a very scarce resource on "
"processor. Operating systems try to make best use of limited number of TLB "
"resources. This optimization is more critical now as bigger and bigger "
"physical memories (several GBs) are more readily available."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:19
msgid ""
"Users can use the huge page support in Linux kernel by either using the mmap "
"system call or standard SYSV shared memory system calls (shmget, shmat)."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:22
msgid ""
"First the Linux kernel needs to be built with the CONFIG_HUGETLBFS (present "
"under \"File systems\") and CONFIG_HUGETLB_PAGE (selected automatically when "
"CONFIG_HUGETLBFS is selected) configuration options."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:27
msgid ""
"The ``/proc/meminfo`` file provides information about the total number of "
"persistent hugetlb pages in the kernel's huge page pool.  It also displays "
"default huge page size and information about the number of free, reserved "
"and surplus huge pages in the pool of huge pages of default size. The huge "
"page size is needed for generating the proper alignment and size of the "
"arguments to system calls that map huge page regions."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:34
msgid "The output of ``cat /proc/meminfo`` will include lines like::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:43
msgid "where:"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:45
msgid "HugePages_Total"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:46
msgid "is the size of the pool of huge pages."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:47
msgid "HugePages_Free"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:48
msgid "is the number of huge pages in the pool that are not yet allocated."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:50
msgid "HugePages_Rsvd"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:51
msgid ""
"is short for \"reserved,\" and is the number of huge pages for which a "
"commitment to allocate from the pool has been made, but no allocation has "
"yet been made.  Reserved huge pages guarantee that an application will be "
"able to allocate a huge page from the pool of huge pages at fault time."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:56
msgid "HugePages_Surp"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:57
msgid ""
"is short for \"surplus,\" and is the number of huge pages in the pool above "
"the value in ``/proc/sys/vm/nr_hugepages``. The maximum number of surplus "
"huge pages is controlled by ``/proc/sys/vm/nr_overcommit_hugepages``. Note: "
"When the feature of freeing unused vmemmap pages associated with each "
"hugetlb page is enabled, the number of surplus huge pages may be temporarily "
"larger than the maximum number of surplus huge pages when the system is "
"under memory pressure."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:65
msgid "Hugepagesize"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:66
msgid "is the default hugepage size (in kB)."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:67
msgid "Hugetlb"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:68
msgid ""
"is the total amount of memory (in kB), consumed by huge pages of all sizes. "
"If huge pages of different sizes are in use, this number will exceed "
"HugePages_Total \\* Hugepagesize. To get more detailed information, please, "
"refer to ``/sys/kernel/mm/hugepages`` (described below)."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:76
msgid ""
"``/proc/filesystems`` should also show a filesystem of type \"hugetlbfs\" "
"configured in the kernel."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:79
msgid ""
"``/proc/sys/vm/nr_hugepages`` indicates the current number of \"persistent\" "
"huge pages in the kernel's huge page pool.  \"Persistent\" huge pages will "
"be returned to the huge page pool when freed by a task.  A user with root "
"privileges can dynamically allocate more or free some persistent huge pages "
"by increasing or decreasing the value of ``nr_hugepages``."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:85
msgid ""
"Note: When the feature of freeing unused vmemmap pages associated with each "
"hugetlb page is enabled, we can fail to free the huge pages triggered by the "
"user when the system is under memory pressure.  Please try again later."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:89
msgid ""
"Pages that are used as huge pages are reserved inside the kernel and cannot "
"be used for other purposes.  Huge pages cannot be swapped out under memory "
"pressure."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:93
msgid ""
"Once a number of huge pages have been pre-allocated to the kernel huge page "
"pool, a user with appropriate privilege can use either the mmap system call "
"or shared memory system calls to use the huge pages.  See the discussion of :"
"ref:`Using Huge Pages <using_huge_pages>`, below."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:98
msgid ""
"The administrator can allocate persistent huge pages on the kernel boot "
"command line by specifying the \"hugepages=N\" parameter, where 'N' = the "
"number of huge pages requested.  This is the most reliable method of "
"allocating huge pages as memory has not yet become fragmented."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:103
msgid ""
"Some platforms support multiple huge page sizes.  To allocate huge pages of "
"a specific size, one must precede the huge pages boot command parameters "
"with a huge page size selection parameter \"hugepagesz=<size>\".  <size> "
"must be specified in bytes with optional scale suffix [kKmMgG].  The default "
"huge page size may be selected with the \"default_hugepagesz=<size>\" boot "
"parameter."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:109
msgid "Hugetlb boot command line parameter semantics"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:111
msgid "hugepagesz"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:112
msgid ""
"Specify a huge page size.  Used in conjunction with hugepages parameter to "
"preallocate a number of huge pages of the specified size.  Hence, hugepagesz "
"and hugepages are typically specified in pairs such as::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:119
msgid ""
"hugepagesz can only be specified once on the command line for a specific "
"huge page size.  Valid huge page sizes are architecture dependent."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:122
msgid "hugepages"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:123
msgid ""
"Specify the number of huge pages to preallocate.  This typically follows a "
"valid hugepagesz or default_hugepagesz parameter.  However, if hugepages is "
"the first or only hugetlb command line parameter it implicitly specifies the "
"number of huge pages of default size to allocate.  If the number of huge "
"pages of default size is implicitly specified, it can not be overwritten by "
"a hugepagesz,hugepages parameter pair for the default size.  This parameter "
"also has a node format.  The node format specifies the number of huge pages "
"to allocate on specific nodes."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:133
msgid "For example, on an architecture with 2M default huge page size::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:137
msgid ""
"will result in 256 2M huge pages being allocated and a warning message "
"indicating that the hugepages=512 parameter is ignored.  If a hugepages "
"parameter is preceded by an invalid hugepagesz parameter, it will be ignored."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:142
msgid "Node format example::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:146
msgid ""
"It will allocate 1 2M hugepage on node0 and 2 2M hugepages on node1. If the "
"node number is invalid,  the parameter will be ignored."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:148
msgid "hugepage_alloc_threads"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:149
msgid ""
"Specify the number of threads that should be used to allocate hugepages "
"during boot. This parameter can be used to improve system bootup time when "
"allocating a large amount of huge pages."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:153
msgid ""
"The default value is 25% of the available hardware threads. Example to use 8 "
"allocation threads::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:158
msgid "Note that this parameter only applies to non-gigantic huge pages."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:159
msgid "default_hugepagesz"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:160
msgid ""
"Specify the default huge page size.  This parameter can only be specified "
"once on the command line.  default_hugepagesz can optionally be followed by "
"the hugepages parameter to preallocate a specific number of huge pages of "
"default size.  The number of default sized huge pages to preallocate can "
"also be implicitly specified as mentioned in the hugepages section above.  "
"Therefore, on an architecture with 2M default huge page size::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:172
msgid ""
"will all result in 256 2M huge pages being allocated.  Valid default huge "
"page size is architecture dependent."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:174
msgid "hugetlb_free_vmemmap"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:175
msgid ""
"When CONFIG_HUGETLB_PAGE_OPTIMIZE_VMEMMAP is set, this enables HugeTLB "
"Vmemmap Optimization (HVO)."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:178
msgid ""
"When multiple huge page sizes are supported, ``/proc/sys/vm/nr_hugepages`` "
"indicates the current number of pre-allocated huge pages of the default "
"size. Thus, one can use the following command to dynamically allocate/"
"deallocate default sized persistent huge pages::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:185
msgid ""
"This command will try to adjust the number of default sized huge pages in "
"the huge page pool to 20, allocating or freeing huge pages, as required."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:188
msgid ""
"On a NUMA platform, the kernel will attempt to distribute the huge page pool "
"over all the set of allowed nodes specified by the NUMA memory policy of the "
"task that modifies ``nr_hugepages``. The default for the allowed nodes--when "
"the task has default memory policy--is all on-line nodes with memory.  "
"Allowed nodes with insufficient available, contiguous memory for a huge page "
"will be silently skipped when allocating persistent huge pages.  See the :"
"ref:`discussion below <mem_policy_and_hp_alloc>` of the interaction of task "
"memory policy, cpusets and per node attributes with the allocation and "
"freeing of persistent huge pages."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:198
msgid ""
"The success or failure of huge page allocation depends on the amount of "
"physically contiguous memory that is present in system at the time of the "
"allocation attempt.  If the kernel is unable to allocate huge pages from "
"some nodes in a NUMA system, it will attempt to make up the difference by "
"allocating extra pages on other nodes with sufficient available contiguous "
"memory, if any."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:205
msgid ""
"System administrators may want to put this command in one of the local rc "
"init files.  This will enable the kernel to allocate huge pages early in the "
"boot process when the possibility of getting physical contiguous pages is "
"still very high.  Administrators can verify the number of huge pages "
"actually allocated by checking the sysctl or meminfo.  To check the per node "
"distribution of huge pages in a NUMA system, use::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:214
msgid ""
"``/proc/sys/vm/nr_overcommit_hugepages`` specifies how large the pool of "
"huge pages can grow, if more huge pages than ``/proc/sys/vm/nr_hugepages`` "
"are requested by applications.  Writing any non-zero value into this file "
"indicates that the hugetlb subsystem is allowed to try to obtain that number "
"of \"surplus\" huge pages from the kernel's normal page pool, when the "
"persistent huge page pool is exhausted. As these surplus huge pages become "
"unused, they are freed back to the kernel's normal page pool."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:222
msgid ""
"When increasing the huge page pool size via ``nr_hugepages``, any existing "
"surplus pages will first be promoted to persistent huge pages.  Then, "
"additional huge pages will be allocated, if necessary and if possible, to "
"fulfill the new persistent huge page pool size."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:227
msgid ""
"The administrator may shrink the pool of persistent huge pages for the "
"default huge page size by setting the ``nr_hugepages`` sysctl to a smaller "
"value.  The kernel will attempt to balance the freeing of huge pages across "
"all nodes in the memory policy of the task modifying ``nr_hugepages``. Any "
"free huge pages on the selected nodes will be freed back to the kernel's "
"normal page pool."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:234
msgid ""
"Caveat: Shrinking the persistent huge page pool via ``nr_hugepages`` such "
"that it becomes less than the number of huge pages in use will convert the "
"balance of the in-use huge pages to surplus huge pages.  This will occur "
"even if the number of surplus pages would exceed the overcommit value.  As "
"long as this condition holds--that is, until "
"``nr_hugepages+nr_overcommit_hugepages`` is increased sufficiently, or the "
"surplus huge pages go out of use and are freed-- no more surplus huge pages "
"will be allowed to be allocated."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:242
msgid ""
"With support for multiple huge page pools at run-time available, much of the "
"huge page userspace interface in ``/proc/sys/vm`` has been duplicated in "
"sysfs. The ``/proc`` interfaces discussed above have been retained for "
"backwards compatibility. The root huge page control directory in sysfs is::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:250
msgid ""
"For each huge page size supported by the running kernel, a subdirectory will "
"exist, of the form::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:255
msgid ""
"Inside each of these directories, the set of files contained in ``/proc`` "
"will exist.  In addition, two additional interfaces for demoting huge pages "
"may exist::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:268
msgid ""
"The demote interfaces provide the ability to split a huge page into smaller "
"huge pages.  For example, the x86 architecture supports both 1GB and 2MB "
"huge pages sizes.  A 1GB huge page can be split into 512 2MB huge pages.  "
"Demote interfaces are not available for the smallest huge page size.  The "
"demote interfaces are:"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:274
msgid "demote_size"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:275
msgid ""
"is the size of demoted pages.  When a page is demoted a corresponding number "
"of huge pages of demote_size will be created.  By default, demote_size is "
"set to the next smaller huge page size.  If there are multiple smaller huge "
"page sizes, demote_size can be set to any of these smaller sizes.  Only huge "
"page sizes less than the current huge pages size are allowed."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:282
msgid "demote"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:283
msgid ""
"is used to demote a number of huge pages.  A user with root privileges can "
"write to this file.  It may not be possible to demote the requested number "
"of huge pages.  To determine how many pages were actually demoted, compare "
"the value of nr_hugepages before and after writing to the demote interface.  "
"demote is a write only interface."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:289
msgid ""
"The interfaces which are the same as in ``/proc`` (all except demote and "
"demote_size) function as described above for the default huge page-sized "
"case."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:295
msgid "Interaction of Task Memory Policy with Huge Page Allocation/Freeing"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:297
msgid ""
"Whether huge pages are allocated and freed via the ``/proc`` interface or "
"the ``/sysfs`` interface using the ``nr_hugepages_mempolicy`` attribute, the "
"NUMA nodes from which huge pages are allocated or freed are controlled by "
"the NUMA memory policy of the task that modifies the "
"``nr_hugepages_mempolicy`` sysctl or attribute.  When the ``nr_hugepages`` "
"attribute is used, mempolicy is ignored."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:304
msgid ""
"The recommended method to allocate or free huge pages to/from the kernel "
"huge page pool, using the ``nr_hugepages`` example above, is::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:310
msgid "or, more succinctly::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:314
msgid ""
"This will allocate or free ``abs(20 - nr_hugepages)`` to or from the nodes "
"specified in <node-list>, depending on whether number of persistent huge "
"pages is initially less than or greater than 20, respectively.  No huge "
"pages will be allocated nor freed on any node not included in the specified "
"<node-list>."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:319
msgid ""
"When adjusting the persistent hugepage count via ``nr_hugepages_mempolicy``, "
"any memory policy mode--bind, preferred, local or interleave--may be used.  "
"The resulting effect on persistent huge page allocation is as follows:"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:323
msgid ""
"Regardless of mempolicy mode [see Documentation/admin-guide/mm/"
"numa_memory_policy.rst], persistent huge pages will be distributed across "
"the node or nodes specified in the mempolicy as if \"interleave\" had been "
"specified. However, if a node in the policy does not contain sufficient "
"contiguous memory for a huge page, the allocation will not \"fallback\" to "
"the nearest neighbor node with sufficient contiguous memory.  To do this "
"would cause undesirable imbalance in the distribution of the huge page pool, "
"or possibly, allocation of persistent huge pages on nodes not allowed by the "
"task's memory policy."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:334
msgid ""
"One or more nodes may be specified with the bind or interleave policy. If "
"more than one node is specified with the preferred policy, only the lowest "
"numeric id will be used.  Local policy will select the node where the task "
"is running at the time the nodes_allowed mask is constructed. For local "
"policy to be deterministic, the task must be bound to a cpu or cpus in a "
"single node.  Otherwise, the task could be migrated to some other node at "
"any time after launch and the resulting node will be indeterminate.  Thus, "
"local policy is not very useful for this purpose. Any of the other mempolicy "
"modes may be used to specify a single node."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:344
msgid ""
"The nodes allowed mask will be derived from any non-default task mempolicy, "
"whether this policy was set explicitly by the task itself or one of its "
"ancestors, such as numactl.  This means that if the task is invoked from a "
"shell with non-default policy, that policy will be used.  One can specify a "
"node list of \"all\" with numactl --interleave or --membind [-m] to achieve "
"interleaving over all nodes in the system or cpuset."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:351
msgid ""
"Any task mempolicy specified--e.g., using numactl--will be constrained by "
"the resource limits of any cpuset in which the task runs.  Thus, there will "
"be no way for a task with non-default policy running in a cpuset with a "
"subset of the system nodes to allocate huge pages outside the cpuset without "
"first moving to a cpuset that contains all of the desired nodes."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:357
msgid ""
"Boot-time huge page allocation attempts to distribute the requested number "
"of huge pages over all on-lines nodes with memory."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:361
msgid "Per Node Hugepages Attributes"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:363
msgid ""
"A subset of the contents of the root huge page control directory in sysfs, "
"described above, will be replicated under each the system device of each "
"NUMA node with memory in::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:369
msgid ""
"Under this directory, the subdirectory for each supported huge page size "
"contains the following attribute files::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:376
msgid ""
"The free\\_' and surplus\\_' attribute files are read-only.  They return the "
"number of free and surplus [overcommitted] huge pages, respectively, on the "
"parent node."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:380
msgid ""
"The ``nr_hugepages`` attribute returns the total number of huge pages on the "
"specified node.  When this attribute is written, the number of persistent "
"huge pages on the parent node will be adjusted to the specified value, if "
"sufficient resources exist, regardless of the task's mempolicy or cpuset "
"constraints."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:385
msgid ""
"Note that the number of overcommit and reserve pages remain global "
"quantities, as we don't know until fault time, when the faulting task's "
"mempolicy is applied, from which node the huge page allocation will be "
"attempted."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:389
msgid ""
"The hugetlb may be migrated between the per-node hugepages pool in the "
"following scenarios: memory offline, memory failure, longterm pinning, "
"syscalls(mbind, migrate_pages and move_pages), alloc_contig_range() and "
"alloc_contig_pages(). Now only memory offline, memory failure and syscalls "
"allow fallbacking to allocate a new hugetlb on a different node if the "
"current node is unable to allocate during hugetlb migration, that means "
"these 3 cases can break the per-node hugepages pool."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:399
msgid "Using Huge Pages"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:401
msgid ""
"If the user applications are going to request huge pages using mmap system "
"call, then it is required that system administrator mount a file system of "
"type hugetlbfs::"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:409
msgid ""
"This command mounts a (pseudo) filesystem of type hugetlbfs on the directory "
"``/mnt/huge``.  Any file created on ``/mnt/huge`` uses huge pages."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:412
msgid ""
"The ``uid`` and ``gid`` options sets the owner and group of the root of the "
"file system.  By default the ``uid`` and ``gid`` of the current process are "
"taken."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:416
msgid ""
"The ``mode`` option sets the mode of root of file system to value & 01777. "
"This value is given in octal. By default the value 0755 is picked."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:419
msgid ""
"If the platform supports multiple huge page sizes, the ``pagesize`` option "
"can be used to specify the huge page size and associated pool. ``pagesize`` "
"is specified in bytes. If ``pagesize`` is not specified the platform's "
"default huge page size and associated pool will be used."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:424
msgid ""
"The ``size`` option sets the maximum value of memory (huge pages) allowed "
"for that filesystem (``/mnt/huge``). The ``size`` option can be specified in "
"bytes, or as a percentage of the specified huge page pool "
"(``nr_hugepages``). The size is rounded down to HPAGE_SIZE boundary."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:429
msgid ""
"The ``min_size`` option sets the minimum value of memory (huge pages) "
"allowed for the filesystem. ``min_size`` can be specified in the same way as "
"``size``, either bytes or a percentage of the huge page pool. At mount time, "
"the number of huge pages specified by ``min_size`` are reserved for use by "
"the filesystem. If there are not enough free huge pages available, the mount "
"will fail. As huge pages are allocated to the filesystem and freed, the "
"reserve count is adjusted so that the sum of allocated and reserved huge "
"pages is always at least ``min_size``."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:439
msgid ""
"The option ``nr_inodes`` sets the maximum number of inodes that ``/mnt/"
"huge`` can use."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:442
msgid ""
"If the ``size``, ``min_size`` or ``nr_inodes`` option is not provided on "
"command line then no limits are set."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:445
msgid ""
"For ``pagesize``, ``size``, ``min_size`` and ``nr_inodes`` options, you can "
"use [G|g]/[M|m]/[K|k] to represent giga/mega/kilo. For example, size=2K has "
"the same meaning as size=2048."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:449
msgid ""
"While read system calls are supported on files that reside on hugetlb file "
"systems, write system calls are not."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:452
msgid ""
"Regular chown, chgrp, and chmod commands (with right permissions) could be "
"used to change the file attributes on hugetlbfs."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:455
msgid ""
"Also, it is important to note that no such mount command is required if "
"applications are going to use only shmat/shmget system calls or mmap with "
"MAP_HUGETLB.  For an example of how to use mmap with MAP_HUGETLB see :ref:"
"`map_hugetlb <map_hugetlb>` below."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:460
msgid ""
"Users who wish to use hugetlb memory via shared memory segment should be "
"members of a supplementary group and system admin needs to configure that "
"gid into ``/proc/sys/vm/hugetlb_shm_group``.  It is possible for same or "
"different applications to use any combination of mmaps and shm* calls, "
"though the mount of filesystem will be required for using mmap calls without "
"MAP_HUGETLB."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:466
msgid ""
"Syscalls that operate on memory backed by hugetlb pages only have their "
"lengths aligned to the native page size of the processor; they will normally "
"fail with errno set to EINVAL or exclude hugetlb pages that extend beyond "
"the length if not hugepage aligned.  For example, munmap(2) will fail if "
"memory is backed by a hugetlb page and the length is smaller than the "
"hugepage size."
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:474
msgid "Examples"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:478
msgid "``map_hugetlb``"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:479
msgid "see tools/testing/selftests/mm/map_hugetlb.c"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:481
msgid "``hugepage-shm``"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:482
msgid "see tools/testing/selftests/mm/hugepage-shm.c"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:484
msgid "``hugepage-mmap``"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:485
msgid "see tools/testing/selftests/mm/hugepage-mmap.c"
msgstr ""

#: ../../../admin-guide/mm/hugetlbpage.rst:487
msgid ""
"The `libhugetlbfs`_  library provides a wide range of userspace tools to "
"help with huge page usability, environment setup, and control."
msgstr ""
