# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:3
msgid "HugeTLB Controller"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:5
msgid ""
"HugeTLB controller can be created by first mounting the cgroup filesystem."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:7
msgid "# mount -t cgroup -o hugetlb none /sys/fs/cgroup"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:9
msgid ""
"With the above step, the initial or the parent HugeTLB group becomes visible "
"at /sys/fs/cgroup. At bootup, this group includes all the tasks in the "
"system. /sys/fs/cgroup/tasks lists the tasks in this cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:13
msgid "New groups can be created under the parent group /sys/fs/cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:19
msgid ""
"The above steps create a new group g1 and move the current shell process "
"(bash) into it."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:22
msgid "Brief summary of control files::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:34
msgid ""
"For a system supporting three hugepage sizes (64k, 32M and 1G), the control "
"files include::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:66
msgid "Page fault accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:75
msgid ""
"The HugeTLB controller allows users to limit the HugeTLB usage (page fault) "
"per control group and enforces the limit during page fault. Since HugeTLB "
"doesn't support page reclaim, enforcing the limit at page fault time implies "
"that, the application will get SIGBUS signal if it tries to fault in HugeTLB "
"pages beyond its limit. Therefore the application needs to know exactly how "
"many HugeTLB pages it uses before hand, and the sysadmin needs to make sure "
"that there are enough available on the machine for all the users to avoid "
"processes getting SIGBUS."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:85
msgid "Reservation accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:94
msgid ""
"The HugeTLB controller allows to limit the HugeTLB reservations per control "
"group and enforces the controller limit at reservation time and at the fault "
"of HugeTLB memory for which no reservation exists. Since reservation limits "
"are enforced at reservation time (on mmap or shget), reservation limits "
"never causes the application to get SIGBUS signal if the memory was reserved "
"before hand. For MAP_NORESERVE allocations, the reservation limit behaves "
"the same as the fault limit, enforcing memory usage at fault time and "
"causing the application to receive a SIGBUS if it's crossing its limit."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:103
msgid ""
"Reservation limits are superior to page fault limits described above, since "
"reservation limits are enforced at reservation time (on mmap or shget), and "
"never causes the application to get SIGBUS signal if the memory was reserved "
"before hand. This allows for easier fallback to alternatives such as non-"
"HugeTLB memory for example. In the case of page fault accounting, it's very "
"hard to avoid processes getting SIGBUS since the sysadmin needs precisely "
"know the HugeTLB usage of all the tasks in the system and make sure there is "
"enough pages to satisfy all requests. Avoiding tasks getting SIGBUS on "
"overcommited systems is practically impossible with page fault accounting."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:114
msgid "Caveats with shared memory"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:116
msgid ""
"For shared HugeTLB memory, both HugeTLB reservation and page faults are "
"charged to the first task that causes the memory to be reserved or faulted, "
"and all subsequent uses of this reserved or faulted memory is done without "
"charging."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:120
msgid ""
"Shared HugeTLB memory is only uncharged when it is unreserved or "
"deallocated. This is usually when the HugeTLB file is deleted, and not when "
"the task that caused the reservation or fault has exited."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:125
msgid "Caveats with HugeTLB cgroup offline."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:127
msgid ""
"When a HugeTLB cgroup goes offline with some reservations or faults still "
"charged to it, the behavior is as follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:130
msgid ""
"The fault charges are charged to the parent HugeTLB cgroup (reparented),"
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:131
msgid "the reservation charges remain on the offline HugeTLB cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/hugetlb.rst:133
msgid ""
"This means that if a HugeTLB cgroup gets offlined while there is still "
"HugeTLB reservations charged to it, that cgroup persists as a zombie until "
"all HugeTLB reservations are uncharged. HugeTLB reservations behave in this "
"manner to match the memory controller whose cgroups also persist as zombie "
"until all charged memory is uncharged. Also, the tracking of HugeTLB "
"reservations is a bit more complex compared to the tracking of HugeTLB "
"faults, so it is significantly harder to reparent reservations at offline "
"time."
msgstr ""
