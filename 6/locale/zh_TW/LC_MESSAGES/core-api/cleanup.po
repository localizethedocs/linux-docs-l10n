# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/cleanup.rst:5
msgid "Scope-based Cleanup Helpers"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:10
msgid ""
"The \"goto error\" pattern is notorious for introducing subtle resource "
"leaks. It is tedious and error prone to add new resource acquisition "
"constraints into code paths that already have several unwind conditions. The "
"\"cleanup\" helpers enable the compiler to help with this tedium and can aid "
"in maintaining LIFO (last in first out) unwind ordering to avoid "
"unintentional leaks."
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:17
msgid ""
"As drivers make up the majority of the kernel code base, here is an example "
"of using these helpers to clean up PCI drivers. The target of the cleanups "
"are occasions where a goto is used to unwind a device reference "
"(pci_dev_put()), or unlock the device (pci_dev_unlock()) before returning."
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:23
msgid ""
"The DEFINE_FREE() macro can arrange for PCI device references to be dropped "
"when the associated variable goes out of scope::"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:31
msgid ""
"The above will automatically call pci_dev_put() if **dev** is non-NULL when "
"**dev** goes out of scope (automatic variable scope). If a function wants to "
"invoke pci_dev_put() on error, but return **dev** (i.e. without freeing it) "
"on success, it can do::"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:38
msgid "...or::"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:42
msgid ""
"The DEFINE_GUARD() macro can arrange for the PCI device lock to be dropped "
"when the scope where guard() is invoked ends::"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:49
msgid ""
"The lifetime of the lock obtained by the guard() helper follows the scope of "
"automatic variable declaration. Take the following example::"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:61
msgid ""
"Observe the lock is held for the remainder of the \"if ()\" block not the "
"remainder of \"func()\"."
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:64
msgid ""
"The ACQUIRE() macro can be used in all places that guard() can be used and "
"additionally support conditional locks::"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:75
msgid ""
"Now, when a function uses both __free() and guard()/ACQUIRE(), or multiple "
"instances of __free(), the LIFO order of variable definition order matters. "
"GCC documentation says:"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:79
msgid ""
"\"When multiple variables in the same scope have cleanup attributes, at exit "
"from the scope their associated cleanup functions are run in reverse order "
"of definition (last defined, first cleanup).\""
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:83
msgid ""
"When the unwind order matters it requires that variables be defined mid-"
"function scope rather than at the top of the file.  Take the following "
"example and notice the bug highlighted by \"!!\"::"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:134
msgid ""
"That bug is fixed by changing init() to call guard() and define + initialize "
"**obj** in this order::"
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:140
msgid ""
"Given that the \"__free(...) = NULL\" pattern for variables defined at the "
"top of the function poses this potential interdependency problem the "
"recommendation is to always define and assign variables in one statement and "
"not group variable definitions at the top of the function when __free() is "
"used."
msgstr ""

#: ../../../core-api/cleanup:7: include/linux/cleanup.h:146
msgid ""
"Lastly, given that the benefit of cleanup helpers is removal of \"goto\", "
"and that the \"goto\" statement can jump between scopes, the expectation is "
"that usage of \"goto\" and cleanup helpers is never mixed in the same "
"function. I.e. for a given routine, convert all resources that need a "
"\"goto\" cleanup to scope-based cleanup, or convert none of them."
msgstr ""
