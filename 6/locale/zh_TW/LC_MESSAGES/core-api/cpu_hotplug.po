# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/cpu_hotplug.rst:3
msgid "CPU hotplug in the Kernel"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:0
msgid "Date"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:5
msgid "September, 2021"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:6
msgid ""
"Sebastian Andrzej Siewior <bigeasy@linutronix.de>, Rusty Russell "
"<rusty@rustcorp.com.au>, Srivatsa Vaddagiri <vatsa@in.ibm.com>, Ashok Raj "
"<ashok.raj@intel.com>, Joel Schopp <jschopp@austin.ibm.com>, Thomas Gleixner "
"<tglx@linutronix.de>"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:14
msgid "Introduction"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:16
msgid ""
"Modern advances in system architectures have introduced advanced error "
"reporting and correction capabilities in processors. There are couple OEMS "
"that support NUMA hardware which are hot pluggable as well, where physical "
"node insertion and removal require support for CPU hotplug."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:21
msgid ""
"Such advances require CPUs available to a kernel to be removed either for "
"provisioning reasons, or for RAS purposes to keep an offending CPU off "
"system execution path. Hence the need for CPU hotplug support in the Linux "
"kernel."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:26
msgid ""
"A more novel use of CPU-hotplug support is its use today in suspend resume "
"support for SMP. Dual-core and HT support makes even a laptop run SMP "
"kernels which didn't support these methods."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:32
msgid "Command Line Switches"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:33
msgid "``maxcpus=n``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:34
msgid ""
"Restrict boot time CPUs to *n*. Say if you have four CPUs, using "
"``maxcpus=2`` will only boot two. You can choose to bring the other CPUs "
"later online."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:38
msgid "``nr_cpus=n``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:39
msgid ""
"Restrict the total amount of CPUs the kernel will support. If the number "
"supplied here is lower than the number of physically available CPUs, then "
"those CPUs can not be brought online later."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:43
msgid "``possible_cpus=n``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:44
msgid "This option sets ``possible_cpus`` bits in ``cpu_possible_mask``."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:46
msgid "This option is limited to the X86 and S390 architecture."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:48
msgid "``cpu0_hotplug``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:49
msgid "Allow to shutdown CPU0."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:51
msgid "This option is limited to the X86 architecture."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:54
msgid "CPU maps"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:56
msgid "``cpu_possible_mask``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:57
msgid ""
"Bitmap of possible CPUs that can ever be available in the system. This is "
"used to allocate some boot time memory for per_cpu variables that aren't "
"designed to grow/shrink as CPUs are made available or removed. Once set "
"during boot time discovery phase, the map is static, i.e no bits are added "
"or removed anytime. Trimming it accurately for your system needs upfront can "
"save some boot time memory."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:64
msgid "``cpu_online_mask``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:65
msgid ""
"Bitmap of all CPUs currently online. Its set in ``__cpu_up()`` after a CPU "
"is available for kernel scheduling and ready to receive interrupts from "
"devices. Its cleared when a CPU is brought down using ``__cpu_disable()``, "
"before which all OS services including interrupts are migrated to another "
"target CPU."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:71
msgid "``cpu_present_mask``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:72
msgid ""
"Bitmap of CPUs currently present in the system. Not all of them may be "
"online. When physical hotplug is processed by the relevant subsystem (e.g "
"ACPI) can change and new bit either be added or removed from the map "
"depending on the event is hot-add/hot-remove. There are currently no locking "
"rules as of now. Typical usage is to init topology during boot, at which "
"time hotplug is disabled."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:79
msgid ""
"You really don't need to manipulate any of the system CPU maps. They should "
"be read-only for most use. When setting up per-cpu resources almost always "
"use ``cpu_possible_mask`` or ``for_each_possible_cpu()`` to iterate. To "
"macro ``for_each_cpu()`` can be used to iterate over a custom CPU mask."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:84
msgid ""
"Never use anything other than ``cpumask_t`` to represent bitmap of CPUs."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:88
msgid "Using CPU hotplug"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:90
msgid ""
"The kernel option *CONFIG_HOTPLUG_CPU* needs to be enabled. It is currently "
"available on multiple architectures including ARM, MIPS, PowerPC and X86. "
"The configuration is done via the sysfs interface::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:110
msgid ""
"The files *offline*, *online*, *possible*, *present* represent the CPU "
"masks. Each CPU folder contains an *online* file which controls the logical "
"on (1) and off (0) state. To logically shutdown CPU4::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:117
msgid ""
"Once the CPU is shutdown, it will be removed from */proc/interrupts*, */proc/"
"cpuinfo* and should also not be shown visible by the *top* command. To bring "
"CPU4 back online::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:124
msgid ""
"The CPU is usable again. This should work on all CPUs, but CPU0 is often "
"special and excluded from CPU hotplug."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:128
msgid "The CPU hotplug coordination"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:131
msgid "The offline case"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:133
msgid ""
"Once a CPU has been logically shutdown the teardown callbacks of registered "
"hotplug states will be invoked, starting with ``CPUHP_ONLINE`` and "
"terminating at state ``CPUHP_OFFLINE``. This includes:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:137
msgid ""
"If tasks are frozen due to a suspend operation then *cpuhp_tasks_frozen* "
"will be set to true."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:139
msgid ""
"All processes are migrated away from this outgoing CPU to new CPUs. The new "
"CPU is chosen from each process' current cpuset, which may be a subset of "
"all online CPUs."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:142
msgid "All interrupts targeted to this CPU are migrated to a new CPU"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:143
msgid "timers are also migrated to a new CPU"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:144
msgid ""
"Once all services are migrated, kernel calls an arch specific routine "
"``__cpu_disable()`` to perform arch specific cleanup."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:149
msgid "The CPU hotplug API"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:152
msgid "CPU hotplug state machine"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:154
msgid ""
"CPU hotplug uses a trivial state machine with a linear state space from "
"CPUHP_OFFLINE to CPUHP_ONLINE. Each state has a startup and a teardown "
"callback."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:158
msgid ""
"When a CPU is onlined, the startup callbacks are invoked sequentially until "
"the state CPUHP_ONLINE is reached. They can also be invoked when the "
"callbacks of a state are set up or an instance is added to a multi-instance "
"state."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:163
msgid ""
"When a CPU is offlined the teardown callbacks are invoked in the reverse "
"order sequentially until the state CPUHP_OFFLINE is reached. They can also "
"be invoked when the callbacks of a state are removed or an instance is "
"removed from a multi-instance state."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:168
msgid ""
"If a usage site requires only a callback in one direction of the hotplug "
"operations (CPU online or CPU offline) then the other not-required callback "
"can be set to NULL when the state is set up."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:172
msgid "The state space is divided into three sections:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:174
msgid "The PREPARE section"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:176
msgid ""
"The PREPARE section covers the state space from CPUHP_OFFLINE to "
"CPUHP_BRINGUP_CPU."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:179
msgid ""
"The startup callbacks in this section are invoked before the CPU is started "
"during a CPU online operation. The teardown callbacks are invoked after the "
"CPU has become dysfunctional during a CPU offline operation."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:183
msgid ""
"The callbacks are invoked on a control CPU as they can't obviously run on "
"the hotplugged CPU which is either not yet started or has become "
"dysfunctional already."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:187
msgid ""
"The startup callbacks are used to setup resources which are required to "
"bring a CPU successfully online. The teardown callbacks are used to free "
"resources or to move pending work to an online CPU after the hotplugged CPU "
"became dysfunctional."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:192
msgid ""
"The startup callbacks are allowed to fail. If a callback fails, the CPU "
"online operation is aborted and the CPU is brought down to the previous "
"state (usually CPUHP_OFFLINE) again."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:196
msgid "The teardown callbacks in this section are not allowed to fail."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:198
msgid "The STARTING section"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:200
msgid ""
"The STARTING section covers the state space between CPUHP_BRINGUP_CPU + 1 "
"and CPUHP_AP_ONLINE."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:203
msgid ""
"The startup callbacks in this section are invoked on the hotplugged CPU with "
"interrupts disabled during a CPU online operation in the early CPU setup "
"code. The teardown callbacks are invoked with interrupts disabled on the "
"hotplugged CPU during a CPU offline operation shortly before the CPU is "
"completely shut down."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:209
msgid "The callbacks in this section are not allowed to fail."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:211
msgid ""
"The callbacks are used for low level hardware initialization/shutdown and "
"for core subsystems."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:214
msgid "The ONLINE section"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:216
msgid ""
"The ONLINE section covers the state space between CPUHP_AP_ONLINE + 1 and "
"CPUHP_ONLINE."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:219
msgid ""
"The startup callbacks in this section are invoked on the hotplugged CPU "
"during a CPU online operation. The teardown callbacks are invoked on the "
"hotplugged CPU during a CPU offline operation."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:223
msgid ""
"The callbacks are invoked in the context of the per CPU hotplug thread, "
"which is pinned on the hotplugged CPU. The callbacks are invoked with "
"interrupts and preemption enabled."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:227
msgid ""
"The callbacks are allowed to fail. When a callback fails the hotplug "
"operation is aborted and the CPU is brought back to the previous state."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:231
msgid "CPU online/offline operations"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:233
msgid "A successful online operation looks like this::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:251
msgid "A successful offline operation looks like this::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:269
msgid "A failed online operation looks like this::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:300
msgid "A failed offline operation looks like this::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:311
msgid ""
"Recursive failures cannot be handled sensibly. Look at the following example "
"of a recursive fail due to a failed offline operation: ::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:321
msgid ""
"The CPU hotplug state machine stops right here and does not try to go back "
"down again because that would likely result in an endless loop::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:331
msgid "Lather, rinse and repeat. In this case the CPU left in state::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:335
msgid ""
"which at least lets the system make progress and gives the user a chance to "
"debug or even resolve the situation."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:339
msgid "Allocating a state"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:341
msgid "There are two ways to allocate a CPU hotplug state:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:343
msgid "Static allocation"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:345
msgid ""
"Static allocation has to be used when the subsystem or driver has ordering "
"requirements versus other CPU hotplug states. E.g. the PERF core startup "
"callback has to be invoked before the PERF driver startup callbacks during a "
"CPU online operation. During a CPU offline operation the driver teardown "
"callbacks have to be invoked before the core teardown callback. The "
"statically allocated states are described by constants in the cpuhp_state "
"enum which can be found in include/linux/cpuhotplug.h."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:353
msgid ""
"Insert the state into the enum at the proper place so the ordering "
"requirements are fulfilled. The state constant has to be used for state "
"setup and removal."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:357
msgid ""
"Static allocation is also required when the state callbacks are not set up "
"at runtime and are part of the initializer of the CPU hotplug state array in "
"kernel/cpu.c."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:361
msgid "Dynamic allocation"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:363
msgid ""
"When there are no ordering requirements for the state callbacks then dynamic "
"allocation is the preferred method. The state number is allocated by the "
"setup function and returned to the caller on success."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:367
msgid ""
"Only the PREPARE and ONLINE sections provide a dynamic allocation range. The "
"STARTING section does not as most of the callbacks in that section have "
"explicit ordering requirements."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:372
msgid "Setup of a CPU hotplug state"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:374
msgid "The core code provides the following functions to setup a state:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:376
msgid "cpuhp_setup_state(state, name, startup, teardown)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:377
msgid "cpuhp_setup_state_nocalls(state, name, startup, teardown)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:378
msgid "cpuhp_setup_state_cpuslocked(state, name, startup, teardown)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:379
msgid "cpuhp_setup_state_nocalls_cpuslocked(state, name, startup, teardown)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:381
msgid ""
"For cases where a driver or a subsystem has multiple instances and the same "
"CPU hotplug state callbacks need to be invoked for each instance, the CPU "
"hotplug core provides multi-instance support. The advantage over driver "
"specific instance lists is that the instance related functions are fully "
"serialized against CPU hotplug operations and provide the automatic "
"invocations of the state callbacks on add and removal. To set up such a "
"multi-instance state the following function is available:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:389
msgid "cpuhp_setup_state_multi(state, name, startup, teardown)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:391
msgid ""
"The @state argument is either a statically allocated state or one of the "
"constants for dynamically allocated states - CPUHP_BP_PREPARE_DYN, "
"CPUHP_AP_ONLINE_DYN - depending on the state section (PREPARE, ONLINE) for "
"which a dynamic state should be allocated."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:396
msgid ""
"The @name argument is used for sysfs output and for instrumentation. The "
"naming convention is \"subsys:mode\" or \"subsys/driver:mode\", e.g. \"perf:"
"mode\" or \"perf/x86:mode\". The common mode names are:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:401
msgid "prepare"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:401
msgid "For states in the PREPARE section"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:403
msgid "dead"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:403
msgid ""
"For states in the PREPARE section which do not provide a startup callback"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:406
msgid "starting"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:406
msgid "For states in the STARTING section"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:408
msgid "dying"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:408
msgid ""
"For states in the STARTING section which do not provide a startup callback"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:411
msgid "online"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:411
msgid "For states in the ONLINE section"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:413
msgid "offline"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:413
msgid ""
"For states in the ONLINE section which do not provide a startup callback"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:417
msgid ""
"As the @name argument is only used for sysfs and instrumentation other mode "
"descriptors can be used as well if they describe the nature of the state "
"better than the common ones."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:421
msgid ""
"Examples for @name arguments: \"perf/online\", \"perf/x86:prepare\", \"RCU/"
"tree:dying\", \"sched/waitempty\""
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:424
msgid ""
"The @startup argument is a function pointer to the callback which should be "
"invoked during a CPU online operation. If the usage site does not require a "
"startup callback set the pointer to NULL."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:428
msgid ""
"The @teardown argument is a function pointer to the callback which should be "
"invoked during a CPU offline operation. If the usage site does not require a "
"teardown callback set the pointer to NULL."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:432 ../../../core-api/cpu_hotplug.rst:486
#: ../../../core-api/cpu_hotplug.rst:525 ../../../core-api/cpu_hotplug.rst:551
msgid ""
"The functions differ in the way how the installed callbacks are treated:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:434
msgid ""
"cpuhp_setup_state_nocalls(), cpuhp_setup_state_nocalls_cpuslocked() and "
"cpuhp_setup_state_multi() only install the callbacks"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:437
msgid ""
"cpuhp_setup_state() and cpuhp_setup_state_cpuslocked() install the callbacks "
"and invoke the @startup callback (if not NULL) for all online CPUs which "
"have currently a state greater than the newly installed state. Depending on "
"the state section the callback is either invoked on the current CPU (PREPARE "
"section) or on each online CPU (ONLINE section) in the context of the CPU's "
"hotplug thread."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:444
msgid ""
"If a callback fails for CPU N then the teardown callback for CPU 0 .. N-1 is "
"invoked to rollback the operation. The state setup fails, the callbacks for "
"the state are not installed and in case of dynamic allocation the allocated "
"state is freed."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:449
msgid ""
"The state setup and the callback invocations are serialized against CPU "
"hotplug operations. If the setup function has to be called from a CPU "
"hotplug read locked region, then the _cpuslocked() variants have to be used. "
"These functions cannot be used from within CPU hotplug callbacks."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:454
msgid "The function return values:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:456
msgid "0"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:456
msgid "Statically allocated state was successfully set up"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:458
msgid ">0"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:458
msgid "Dynamically allocated state was successfully set up."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:460
msgid ""
"The returned number is the state number which was allocated. If the state "
"callbacks have to be removed later, e.g. module removal, then this number "
"has to be saved by the caller and used as @state argument for the state "
"remove function. For multi-instance states the dynamically allocated state "
"number is also required as @state argument for the instance add/remove "
"operations."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:468
msgid "<0"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:468
msgid "Operation failed"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:472
msgid "Removal of a CPU hotplug state"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:474
msgid ""
"To remove a previously set up state, the following functions are provided:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:476
msgid "cpuhp_remove_state(state)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:477
msgid "cpuhp_remove_state_nocalls(state)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:478
msgid "cpuhp_remove_state_nocalls_cpuslocked(state)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:479
msgid "cpuhp_remove_multi_state(state)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:481
msgid ""
"The @state argument is either a statically allocated state or the state "
"number which was allocated in the dynamic range by cpuhp_setup_state*(). If "
"the state is in the dynamic range, then the state number is freed and "
"available for dynamic allocation again."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:488
msgid ""
"cpuhp_remove_state_nocalls(), cpuhp_remove_state_nocalls_cpuslocked() and "
"cpuhp_remove_multi_state() only remove the callbacks."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:491
msgid ""
"cpuhp_remove_state() removes the callbacks and invokes the teardown callback "
"(if not NULL) for all online CPUs which have currently a state greater than "
"the removed state. Depending on the state section the callback is either "
"invoked on the current CPU (PREPARE section) or on each online CPU (ONLINE "
"section) in the context of the CPU's hotplug thread."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:498 ../../../core-api/cpu_hotplug.rst:564
msgid ""
"In order to complete the removal, the teardown callback should not fail."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:500
msgid ""
"The state removal and the callback invocations are serialized against CPU "
"hotplug operations. If the remove function has to be called from a CPU "
"hotplug read locked region, then the _cpuslocked() variants have to be used. "
"These functions cannot be used from within CPU hotplug callbacks."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:505
msgid ""
"If a multi-instance state is removed then the caller has to remove all "
"instances first."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:509
msgid "Multi-Instance state instance management"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:511
msgid ""
"Once the multi-instance state is set up, instances can be added to the state:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:514
msgid "cpuhp_state_add_instance(state, node)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:515
msgid "cpuhp_state_add_instance_nocalls(state, node)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:517
msgid ""
"The @state argument is either a statically allocated state or the state "
"number which was allocated in the dynamic range by cpuhp_setup_state_multi()."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:520
msgid ""
"The @node argument is a pointer to an hlist_node which is embedded in the "
"instance's data structure. The pointer is handed to the multi-instance state "
"callbacks and can be used by the callback to retrieve the instance via "
"container_of()."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:527
msgid ""
"cpuhp_state_add_instance_nocalls() and only adds the instance to the multi-"
"instance state's node list."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:530
msgid ""
"cpuhp_state_add_instance() adds the instance and invokes the startup "
"callback (if not NULL) associated with @state for all online CPUs which have "
"currently a state greater than @state. The callback is only invoked for the "
"to be added instance. Depending on the state section the callback is either "
"invoked on the current CPU (PREPARE section) or on each online CPU (ONLINE "
"section) in the context of the CPU's hotplug thread."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:538
msgid ""
"If a callback fails for CPU N then the teardown callback for CPU 0 .. N-1 is "
"invoked to rollback the operation, the function fails and the instance is "
"not added to the node list of the multi-instance state."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:542
msgid ""
"To remove an instance from the state's node list these functions are "
"available:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:545
msgid "cpuhp_state_remove_instance(state, node)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:546
msgid "cpuhp_state_remove_instance_nocalls(state, node)"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:548
msgid ""
"The arguments are the same as for the cpuhp_state_add_instance*() variants "
"above."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:553
msgid ""
"cpuhp_state_remove_instance_nocalls() only removes the instance from the "
"state's node list."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:556
msgid ""
"cpuhp_state_remove_instance() removes the instance and invokes the teardown "
"callback (if not NULL) associated with @state for all online CPUs which have "
"currently a state greater than @state.  The callback is only invoked for the "
"to be removed instance.  Depending on the state section the callback is "
"either invoked on the current CPU (PREPARE section) or on each online CPU "
"(ONLINE section) in the context of the CPU's hotplug thread."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:566
msgid ""
"The node list add/remove operations and the callback invocations are "
"serialized against CPU hotplug operations. These functions cannot be used "
"from within CPU hotplug callbacks and CPU hotplug read locked regions."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:571
msgid "Examples"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:573
msgid ""
"Setup and teardown a statically allocated state in the STARTING section for "
"notifications on online and offline operations::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:582
msgid ""
"Setup and teardown a dynamically allocated state in the ONLINE section for "
"notifications on offline operations::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:591
msgid ""
"Setup and teardown a dynamically allocated state in the ONLINE section for "
"notifications on online operations without invoking the callbacks::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:600
msgid ""
"Setup, use and teardown a dynamically allocated multi-instance state in the "
"ONLINE section for notifications on online and offline operation::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:623
msgid "Testing of hotplug states"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:625
msgid ""
"One way to verify whether a custom state is working as expected or not is to "
"shutdown a CPU and then put it online again. It is also possible to put the "
"CPU to certain state (for instance *CPUHP_AP_ONLINE*) and then go back to "
"*CPUHP_ONLINE*. This would simulate an error one state after "
"*CPUHP_AP_ONLINE* which would lead to rollback to the online state."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:631
msgid ""
"All registered states are enumerated in ``/sys/devices/system/cpu/hotplug/"
"states`` ::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:645
msgid ""
"To rollback CPU4 to ``lib/percpu_cnt:online`` and back online just issue::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:653
msgid ""
"It is important to note that the teardown callback of state 140 have been "
"invoked. And now get back online::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:660
msgid "With trace events enabled, the individual steps are visible, too::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:689
msgid ""
"As it an be seen, CPU4 went down until timestamp 22.996 and then back up "
"until 95.552. All invoked callbacks including their return codes are visible "
"in the trace."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:694
msgid "Architecture's requirements"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:696
msgid "The following functions and configurations are required:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:698
msgid "``CONFIG_HOTPLUG_CPU``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:699
msgid "This entry needs to be enabled in Kconfig"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:701
msgid "``__cpu_up()``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:702
msgid "Arch interface to bring up a CPU"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:704
msgid "``__cpu_disable()``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:705
msgid ""
"Arch interface to shutdown a CPU, no more interrupts can be handled by the "
"kernel after the routine returns. This includes the shutdown of the timer."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:708
msgid "``__cpu_die()``"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:709
msgid ""
"This actually supposed to ensure death of the CPU. Actually look at some "
"example code in other arch that implement CPU hotplug. The processor is "
"taken down from the ``idle()`` loop for that specific architecture. "
"``__cpu_die()`` typically waits for some per_cpu state to be set, to ensure "
"the processor dead routine is called to be sure positively."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:716
msgid "User Space Notification"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:718
msgid ""
"After CPU successfully onlined or offline udev events are sent. A udev rule "
"like::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:722
msgid "will receive all events. A script like::"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:736
msgid "can process the event further."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:738
msgid ""
"When changes to the CPUs in the system occur, the sysfs file /sys/devices/"
"system/cpu/crash_hotplug contains '1' if the kernel updates the kdump "
"capture kernel list of CPUs itself (via elfcorehdr and other relevant kexec "
"segment), or '0' if userspace must update the kdump capture kernel list of "
"CPUs."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:744
msgid ""
"The availability depends on the CONFIG_HOTPLUG_CPU kernel configuration "
"option."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:747
msgid ""
"To skip userspace processing of CPU hot un/plug events for kdump (i.e. the "
"unload-then-reload to obtain a current list of CPUs), this sysfs file can be "
"used in a udev rule as follows:"
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:751
msgid ""
"SUBSYSTEM==\"cpu\", ATTRS{crash_hotplug}==\"1\", GOTO=\"kdump_reload_end\""
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:753
msgid ""
"For a CPU hot un/plug event, if the architecture supports kernel updates of "
"the elfcorehdr (which contains the list of CPUs) and other relevant kexec "
"segments, then the rule skips the unload-then-reload of the kdump capture "
"kernel."
msgstr ""

#: ../../../core-api/cpu_hotplug.rst:759
msgid "Kernel Inline Documentations Reference"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:261
msgid "Setup hotplug state callbacks with calling the **startup** callback"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:265
#: include/linux/cpuhotplug.h:284 include/linux/cpuhotplug.h:305
#: include/linux/cpuhotplug.h:325 include/linux/cpuhotplug.h:347
#: include/linux/cpuhotplug.h:376 include/linux/cpuhotplug.h:393
#: include/linux/cpuhotplug.h:409 include/linux/cpuhotplug.h:430
#: include/linux/cpuhotplug.h:442 include/linux/cpuhotplug.h:452
#: include/linux/cpuhotplug.h:465 include/linux/cpuhotplug.h:481
#: include/linux/cpuhotplug.h:496
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:267
#: include/linux/cpuhotplug.h:286 include/linux/cpuhotplug.h:307
#: include/linux/cpuhotplug.h:327 include/linux/cpuhotplug.h:349
#: include/linux/cpuhotplug.h:378 include/linux/cpuhotplug.h:395
#: include/linux/cpuhotplug.h:411 include/linux/cpuhotplug.h:432
#: include/linux/cpuhotplug.h:444 include/linux/cpuhotplug.h:454
#: include/linux/cpuhotplug.h:467 include/linux/cpuhotplug.h:483
#: include/linux/cpuhotplug.h:498
msgid "``enum cpuhp_state state``"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:263
#: include/linux/cpuhotplug.h:283 include/linux/cpuhotplug.h:303
#: include/linux/cpuhotplug.h:325 include/linux/cpuhotplug.h:344
msgid "The state for which the calls are installed"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:265
#: include/linux/cpuhotplug.h:285 include/linux/cpuhotplug.h:305
#: include/linux/cpuhotplug.h:327 include/linux/cpuhotplug.h:346
msgid "``const char *name``"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:264
#: include/linux/cpuhotplug.h:284
msgid "Name of the callback (will be used in debug output)"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:266
#: include/linux/cpuhotplug.h:286 include/linux/cpuhotplug.h:306
#: include/linux/cpuhotplug.h:328
msgid "``int (*startup)(unsigned int cpu)``"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:265
#: include/linux/cpuhotplug.h:285 include/linux/cpuhotplug.h:305
#: include/linux/cpuhotplug.h:327 include/linux/cpuhotplug.h:346
msgid "startup callback function or NULL if not required"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:267
#: include/linux/cpuhotplug.h:287 include/linux/cpuhotplug.h:307
#: include/linux/cpuhotplug.h:329
msgid "``int (*teardown)(unsigned int cpu)``"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:266
#: include/linux/cpuhotplug.h:286 include/linux/cpuhotplug.h:306
#: include/linux/cpuhotplug.h:328 include/linux/cpuhotplug.h:347
msgid "teardown callback function or NULL if not required"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:268
#: include/linux/cpuhotplug.h:288 include/linux/cpuhotplug.h:308
#: include/linux/cpuhotplug.h:330 include/linux/cpuhotplug.h:349
#: include/linux/cpuhotplug.h:377 include/linux/cpuhotplug.h:394
#: include/linux/cpuhotplug.h:412 include/linux/cpuhotplug.h:429
#: include/linux/cpuhotplug.h:452 include/linux/cpuhotplug.h:464
#: include/linux/cpuhotplug.h:482 include/linux/cpuhotplug.h:497
msgid "**Description**"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:267
msgid ""
"Installs the callback functions and invokes the **startup** callback on the "
"online cpus which have already reached the **state**."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:280
msgid ""
"Setup hotplug state callbacks with calling **startup** callback from a "
"cpus_read_lock() held region"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:287
msgid ""
"Same as cpuhp_setup_state() except that it must be invoked from within a "
"cpus_read_lock() held region."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:301
msgid "Setup hotplug state callbacks without calling the **startup** callback"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:304
#: include/linux/cpuhotplug.h:326 include/linux/cpuhotplug.h:345
msgid "Name of the callback."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:307
msgid ""
"Same as cpuhp_setup_state() except that the **startup** callback is not "
"invoked during installation. NOP if SMP=n or HOTPLUG_CPU=n."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:321
msgid ""
"Setup hotplug state callbacks without invoking the **startup** callback from "
"a cpus_read_lock() held region callbacks"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:329
msgid ""
"Same as cpuhp_setup_state_nocalls() except that it must be invoked from "
"within a cpus_read_lock() held region."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:343
msgid "Add callbacks for multi state"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:347
msgid "``int (*startup)(unsigned int cpu, struct hlist_node *node)``"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:348
msgid "``int (*teardown)(unsigned int cpu, struct hlist_node *node)``"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:348
msgid ""
"Sets the internal multi_instance flag and prepares a state to work as a "
"multi instance callback. No callbacks are invoked at this point. The "
"callbacks are invoked once an instance for this state are registered via "
"cpuhp_state_add_instance() or cpuhp_state_add_instance_nocalls()"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:372
msgid "Add an instance for a state and invoke startup callback."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:374
#: include/linux/cpuhotplug.h:391 include/linux/cpuhotplug.h:409
msgid "The state for which the instance is installed"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:376
#: include/linux/cpuhotplug.h:393 include/linux/cpuhotplug.h:411
#: include/linux/cpuhotplug.h:481 include/linux/cpuhotplug.h:496
msgid "``struct hlist_node *node``"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:375
#: include/linux/cpuhotplug.h:392 include/linux/cpuhotplug.h:410
#: include/linux/cpuhotplug.h:480 include/linux/cpuhotplug.h:495
msgid "The node for this individual state."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:376
msgid ""
"Installs the instance for the **state** and invokes the registered startup "
"callback on the online cpus which have already reached the **state**. The "
"**state** must have been earlier marked as multi-instance by "
"cpuhp_setup_state_multi()."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:389
msgid "Add an instance for a state without invoking the startup callback."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:393
msgid ""
"Installs the instance for the **state**. The **state** must have been "
"earlier marked as multi-instance by cpuhp_setup_state_multi. NOP if SMP=n or "
"HOTPLUG_CPU=n."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:405
msgid ""
"Add an instance for a state without invoking the startup callback from a "
"cpus_read_lock() held region."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:411
msgid ""
"Same as cpuhp_state_add_instance_nocalls() except that it must be invoked "
"from within a cpus_read_lock() held region."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:426
msgid "Remove hotplug state callbacks and invoke the teardown"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:427
#: include/linux/cpuhotplug.h:440 include/linux/cpuhotplug.h:450
#: include/linux/cpuhotplug.h:462
msgid "The state for which the calls are removed"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:428
msgid ""
"Removes the callback functions and invokes the teardown callback on the "
"online cpus which have already reached the **state**."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:438
msgid "Remove hotplug state callbacks without invoking the teardown callback"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:448
msgid ""
"Remove hotplug state callbacks without invoking teardown from a "
"cpus_read_lock() held region."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:451
msgid ""
"Same as cpuhp_remove_state nocalls() except that it must be invoked from "
"within a cpus_read_lock() held region."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:461
msgid "Remove hotplug multi state callback"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:463
msgid ""
"Removes the callback functions from a multi state. This is the reverse of "
"cpuhp_setup_state_multi(). All instances should have been removed before "
"invoking this function."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:477
msgid "Remove hotplug instance from state and invoke the teardown callback"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:479
#: include/linux/cpuhotplug.h:494
msgid "The state from which the instance is removed"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:481
msgid ""
"Removes the instance and invokes the teardown callback on the online cpus "
"which have already reached **state**."
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:492
msgid ""
"Remove hotplug instance from state without invoking the teardown callback"
msgstr ""

#: ../../../core-api/cpu_hotplug:761: include/linux/cpuhotplug.h:496
msgid "Removes the instance without invoking the teardown callback."
msgstr ""
