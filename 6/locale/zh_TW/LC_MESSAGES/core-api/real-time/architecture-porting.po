# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-21 08:55+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/real-time/architecture-porting.rst:5
msgid "Porting an architecture to support PREEMPT_RT"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:0
msgid "Author"
msgstr "作者"

#: ../../../core-api/real-time/architecture-porting.rst:7
msgid "Sebastian Andrzej Siewior <bigeasy@linutronix.de>"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:9
msgid ""
"This list outlines the architecture specific requirements that must be "
"implemented in order to enable PREEMPT_RT. Once all required features are "
"implemented, ARCH_SUPPORTS_RT can be selected in architecture’s Kconfig to "
"make PREEMPT_RT selectable. Many prerequisites (genirq support for example) "
"are enforced by the common code and are omitted here."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:16
msgid ""
"The optional features are not strictly required but it is worth to consider "
"them."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:20
msgid "Requirements"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:22
msgid "Forced threaded interrupts"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:23
msgid ""
"CONFIG_IRQ_FORCED_THREADING must be selected. Any interrupts that must "
"remain in hard-IRQ context must be marked with IRQF_NO_THREAD. This "
"requirement applies for instance to clocksource event interrupts, perf "
"interrupts and cascading interrupt-controller handlers."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:28
msgid "PREEMPTION support"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:29
msgid ""
"Kernel preemption must be supported and requires that CONFIG_ARCH_NO_PREEMPT "
"remain unselected. Scheduling requests, such as those issued from an "
"interrupt or other exception handler, must be processed immediately."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:34
msgid "POSIX CPU timers and KVM"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:35
msgid ""
"POSIX CPU timers must expire from thread context rather than directly within "
"the timer interrupt. This behavior is enabled by setting the configuration "
"option CONFIG_HAVE_POSIX_CPU_TIMERS_TASK_WORK. When KVM is enabled, "
"CONFIG_KVM_XFER_TO_GUEST_WORK must also be set to ensure that any pending "
"work, such as POSIX timer expiration, is handled before transitioning into "
"guest mode."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:42
msgid "Hard-IRQ and Soft-IRQ stacks"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:43
msgid ""
"Soft interrupts are handled in the thread context in which they are raised. "
"If a soft interrupt is triggered from hard-IRQ context, its execution is "
"deferred to the ksoftirqd thread. Preemption is never disabled during soft "
"interrupt handling, which makes soft interrupts preemptible. If an "
"architecture provides a custom __do_softirq() implementation that uses a "
"separate stack, it must select CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK. The "
"functionality should only be enabled when CONFIG_SOFTIRQ_ON_OWN_STACK is set."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:51
msgid "FPU and SIMD access in kernel mode"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:52
msgid ""
"FPU and SIMD registers are typically not used in kernel mode and are "
"therefore not saved during kernel preemption. As a result, any kernel code "
"that uses these registers must be enclosed within a kernel_fpu_begin() and "
"kernel_fpu_end() section. The kernel_fpu_begin() function usually invokes "
"local_bh_disable() to prevent interruptions from softirqs and to disable "
"regular preemption. This allows the protected code to run safely in both "
"thread and softirq contexts. On PREEMPT_RT kernels, however, "
"kernel_fpu_begin() must not call local_bh_disable(). Instead, it should use "
"preempt_disable(), since softirqs are always handled in thread context under "
"PREEMPT_RT. In this case, disabling preemption alone is sufficient. The "
"crypto subsystem operates on memory pages and requires users to \"walk and "
"map\" these pages while processing a request. This operation must occur "
"outside the kernel_fpu_begin()/ kernel_fpu_end() section because it requires "
"preemption to be enabled. These preemption points are generally sufficient "
"to avoid excessive scheduling latency."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:69
msgid "Exception handlers"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:70
msgid ""
"Exception handlers, such as the page fault handler, typically enable "
"interrupts early, before invoking any generic code to process the exception. "
"This is necessary because handling a page fault may involve operations that "
"can sleep. Enabling interrupts is especially important on PREEMPT_RT, where "
"certain locks, such as spinlock_t, become sleepable. For example, handling "
"an invalid opcode may result in sending a SIGILL signal to the user task. A "
"debug excpetion will send a SIGTRAP signal. In both cases, if the exception "
"occurred in user space, it is safe to enable interrupts early. Sending a "
"signal requires both interrupts and kernel preemption to be enabled."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:82
msgid "Optional features"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:84
msgid "Timer and clocksource"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:85
msgid ""
"A high-resolution clocksource and clockevents device are recommended. The "
"clockevents device should support the CLOCK_EVT_FEAT_ONESHOT feature for "
"optimal timer behavior. In most cases, microsecond-level accuracy is "
"sufficient"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:90
msgid "Lazy preemption"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:91
msgid ""
"This mechanism allows an in-kernel scheduling request for non-real-time "
"tasks to be delayed until the task is about to return to user space. It "
"helps avoid preempting a task that holds a sleeping lock at the time of the "
"scheduling request. With CONFIG_GENERIC_IRQ_ENTRY enabled, supporting this "
"feature requires defining a bit for TIF_NEED_RESCHED_LAZY, preferably near "
"TIF_NEED_RESCHED."
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:98
msgid "Serial console with NBCON"
msgstr ""

#: ../../../core-api/real-time/architecture-porting.rst:99
msgid ""
"With PREEMPT_RT enabled, all console output is handled by a dedicated thread "
"rather than directly from the context in which printk() is invoked. This "
"design allows printk() to be safely used in atomic contexts. However, this "
"also means that if the kernel crashes and cannot switch to the printing "
"thread, no output will be visible preventing the system from printing its "
"final messages. There are exceptions for immediate output, such as during "
"panic() handling. To support this, the console driver must implement new-"
"style lock handling. This involves setting the CON_NBCON flag in console::"
"flags and providing implementations for the write_atomic, write_thread, "
"device_lock, and device_unlock callbacks."
msgstr ""
