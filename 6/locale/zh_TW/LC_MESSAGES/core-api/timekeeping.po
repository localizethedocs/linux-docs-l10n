# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/timekeeping.rst:2
msgid "ktime accessors"
msgstr ""

#: ../../../core-api/timekeeping.rst:4
msgid ""
"Device drivers can read the current time using ktime_get() and the many "
"related functions declared in linux/timekeeping.h. As a rule of thumb, using "
"an accessor with a shorter name is preferred over one with a longer name if "
"both are equally fit for a particular use case."
msgstr ""

#: ../../../core-api/timekeeping.rst:10
msgid "Basic ktime_t based interfaces"
msgstr ""

#: ../../../core-api/timekeeping.rst:12
msgid ""
"The recommended simplest form returns an opaque ktime_t, with variants that "
"return time for different clock references:"
msgstr ""

#: ../../../core-api/timekeeping.rst:18
msgid "CLOCK_MONOTONIC"
msgstr ""

#: ../../../core-api/timekeeping.rst:20
msgid ""
"Useful for reliable timestamps and measuring short time intervals "
"accurately. Starts at system boot time but stops during suspend."
msgstr ""

#: ../../../core-api/timekeeping.rst:25
msgid "CLOCK_BOOTTIME"
msgstr ""

#: ../../../core-api/timekeeping.rst:27
msgid ""
"Like ktime_get(), but does not stop when suspended. This can be used e.g. "
"for key expiration times that need to be synchronized with other machines "
"across a suspend operation."
msgstr ""

#: ../../../core-api/timekeeping.rst:33
msgid "CLOCK_REALTIME"
msgstr ""

#: ../../../core-api/timekeeping.rst:35
msgid ""
"Returns the time in relative to the UNIX epoch starting in 1970 using the "
"Coordinated Universal Time (UTC), same as gettimeofday() user space. This is "
"used for all timestamps that need to persist across a reboot, like inode "
"times, but should be avoided for internal uses, since it can jump backwards "
"due to a leap second update, NTP adjustment settimeofday() operation from "
"user space."
msgstr ""

#: ../../../core-api/timekeeping.rst:45
msgid "CLOCK_TAI"
msgstr ""

#: ../../../core-api/timekeeping.rst:47
msgid ""
"Like ktime_get_real(), but uses the International Atomic Time (TAI) "
"reference instead of UTC to avoid jumping on leap second updates. This is "
"rarely useful in the kernel."
msgstr ""

#: ../../../core-api/timekeeping.rst:53
msgid "CLOCK_MONOTONIC_RAW"
msgstr ""

#: ../../../core-api/timekeeping.rst:55
msgid ""
"Like ktime_get(), but runs at the same rate as the hardware clocksource "
"without (NTP) adjustments for clock drift. This is also rarely needed in the "
"kernel."
msgstr ""

#: ../../../core-api/timekeeping.rst:60
msgid "nanosecond, timespec64, and second output"
msgstr ""

#: ../../../core-api/timekeeping.rst:62
msgid ""
"For all of the above, there are variants that return the time in a different "
"format depending on what is required by the user:"
msgstr ""

#: ../../../core-api/timekeeping.rst:71
msgid ""
"Same as the plain ktime_get functions, but returning a u64 number of "
"nanoseconds in the respective time reference, which may be more convenient "
"for some callers."
msgstr ""

#: ../../../core-api/timekeeping.rst:81
msgid ""
"Same above, but returns the time in a 'struct timespec64', split into "
"seconds and nanoseconds. This can avoid an extra division when printing the "
"time, or when passing it into an external interface that expects a "
"'timespec' or 'timeval' structure."
msgstr ""

#: ../../../core-api/timekeeping.rst:92
msgid ""
"Return a coarse-grained version of the time as a scalar time64_t. This "
"avoids accessing the clock hardware and rounds down the seconds to the full "
"seconds of the last timer tick using the respective reference."
msgstr ""

#: ../../../core-api/timekeeping.rst:98
msgid "Coarse and fast_ns access"
msgstr ""

#: ../../../core-api/timekeeping.rst:100
msgid "Some additional variants exist for more specialized cases:"
msgstr ""

#: ../../../core-api/timekeeping.rst:117
msgid ""
"These are quicker than the non-coarse versions, but less accurate, "
"corresponding to CLOCK_MONOTONIC_COARSE and CLOCK_REALTIME_COARSE in user "
"space, along with the equivalent boottime/tai/raw timebase not available in "
"user space."
msgstr ""

#: ../../../core-api/timekeeping.rst:122
msgid ""
"The time returned here corresponds to the last timer tick, which may be as "
"much as 10ms in the past (for CONFIG_HZ=100), same as reading the 'jiffies' "
"variable.  These are only useful when called in a fast path and one still "
"expects better than second accuracy, but can't easily use 'jiffies', e.g. "
"for inode timestamps. Skipping the hardware clock access saves around 100 "
"CPU cycles on most modern machines with a reliable cycle counter, but up to "
"several microseconds on older hardware with an external clocksource."
msgstr ""

#: ../../../core-api/timekeeping.rst:138
msgid ""
"These variants are safe to call from any context, including from a non-"
"maskable interrupt (NMI) during a timekeeper update, and while we are "
"entering suspend with the clocksource powered down. This is useful in some "
"tracing or debugging code as well as machine check reporting, but most "
"drivers should never call them, since the time is allowed to jump under "
"certain conditions."
msgstr ""

#: ../../../core-api/timekeeping.rst:146
msgid "Deprecated time interfaces"
msgstr ""

#: ../../../core-api/timekeeping.rst:148
msgid ""
"Older kernels used some other interfaces that are now being phased out but "
"may appear in third-party drivers being ported here. In particular, all "
"interfaces returning a 'struct timeval' or 'struct timespec' have been "
"replaced because the tv_sec member overflows in year 2038 on 32-bit "
"architectures. These are the recommended replacements:"
msgstr ""

#: ../../../core-api/timekeeping.rst:156
msgid "Use ktime_get() or ktime_get_ts64() instead."
msgstr ""

#: ../../../core-api/timekeeping.rst:163
msgid ""
"ktime_get_real_ts64() is a direct replacement, but consider using monotonic "
"time (ktime_get_ts64()) and/or a ktime_t based interface (ktime_get()/"
"ktime_get_real())."
msgstr ""

#: ../../../core-api/timekeeping.rst:172
msgid ""
"These are replaced by ktime_get_coarse_real_ts64() and "
"ktime_get_coarse_ts64(). However, A lot of code that wants coarse-grained "
"times can use the simple 'jiffies' instead, while some drivers may actually "
"want the higher resolution accessors these days."
msgstr ""

#: ../../../core-api/timekeeping.rst:185
msgid ""
"These are replaced by ktime_get_raw()/ktime_get_raw_ts64(), "
"ktime_get_clocktai()/ktime_get_clocktai_ts64() as well as "
"ktime_get_boottime()/ktime_get_boottime_ts64(). However, if the particular "
"choice of clock source is not important for the user, consider converting to "
"ktime_get()/ktime_get_ts64() instead for consistency."
msgstr ""
