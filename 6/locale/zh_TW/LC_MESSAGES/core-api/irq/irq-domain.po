# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-25 09:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/irq/irq-domain.rst:3
msgid "The irq_domain Interrupt Number Mapping Library"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:5
msgid ""
"The current design of the Linux kernel uses a single large number space "
"where each separate IRQ source is assigned a unique number. This is simple "
"when there is only one interrupt controller. But in systems with multiple "
"interrupt controllers, the kernel must ensure that each one gets assigned "
"non-overlapping allocations of Linux IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:12
msgid ""
"The number of interrupt controllers registered as unique irqchips shows a "
"rising tendency. For example, subdrivers of different kinds such as GPIO "
"controllers avoid reimplementing identical callback mechanisms as the IRQ "
"core system by modelling their interrupt handlers as irqchips. I.e. in "
"effect cascading interrupt controllers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:18
msgid ""
"So in the past, IRQ numbers could be chosen so that they match the hardware "
"IRQ line into the root interrupt controller (i.e. the component actually "
"firing the interrupt line to the CPU). Nowadays, this number is just a "
"number and the number has no relationship to hardware interrupt numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:24
msgid ""
"For this reason, we need a mechanism to separate controller-local interrupt "
"numbers, called hardware IRQs, from Linux IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:27
msgid ""
"The irq_alloc_desc*() and irq_free_desc*() APIs provide allocation of IRQ "
"numbers, but they don't provide any support for reverse mapping of the "
"controller-local IRQ (hwirq) number into the Linux IRQ number space."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:32
msgid ""
"The irq_domain library adds a mapping between hwirq and IRQ numbers on top "
"of the irq_alloc_desc*() API. An irq_domain to manage the mapping is "
"preferred over interrupt controller drivers open coding their own reverse "
"mapping scheme."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:37
msgid ""
"irq_domain also implements a translation from an abstract struct irq_fwspec "
"to hwirq numbers (Device Tree, non-DT firmware node, ACPI GSI, and software "
"node so far), and can be easily extended to support other IRQ topology data "
"sources. The implementation is performed without any extra platform support "
"code."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:44
msgid "irq_domain Usage"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:45
msgid ""
"struct irq_domain could be defined as an irq domain controller. That is, it "
"handles the mapping between hardware and virtual interrupt numbers for a "
"given interrupt domain. The domain structure is generally created by the PIC "
"code for a given PIC instance (though a domain can cover more than one PIC "
"if they have a flat number model). It is the domain callbacks that are "
"responsible for setting the irq_chip on a given irq_desc after it has been "
"mapped."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:53
msgid ""
"The host code and data structures use a fwnode_handle pointer to identify "
"the domain. In some cases, and in order to preserve source code "
"compatibility, this fwnode pointer is \"upgraded\" to a DT device_node. For "
"those firmware infrastructures that do not provide a unique identifier for "
"an interrupt controller, the irq_domain code offers a fwnode allocator."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:60
msgid ""
"An interrupt controller driver creates and registers a struct irq_domain by "
"calling one of the irq_domain_create_*() functions (each mapping method has "
"a different allocator function, more on that later). The function will "
"return a pointer to the struct irq_domain on success. The caller must "
"provide the allocator function with a struct irq_domain_ops pointer."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:67
msgid ""
"In most cases, the irq_domain will begin empty without any mappings between "
"hwirq and IRQ numbers.  Mappings are added to the irq_domain by calling "
"irq_create_mapping() which accepts the irq_domain and a hwirq number as "
"arguments. If a mapping for the hwirq doesn't already exist, "
"irq_create_mapping() allocates a new Linux irq_desc, associates it with the "
"hwirq, and calls the :c:member:`irq_domain_ops.map()` callback. In there, "
"the driver can perform any required hardware setup."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:76
msgid ""
"Once a mapping has been established, it can be retrieved or used via a "
"variety of methods:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:79
msgid ""
"irq_resolve_mapping() returns a pointer to the irq_desc structure for a "
"given domain and hwirq number, or NULL if there was no mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:82
msgid ""
"irq_find_mapping() returns a Linux IRQ number for a given domain and hwirq "
"number, or 0 if there was no mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:84
msgid ""
"generic_handle_domain_irq() handles an interrupt described by a domain and a "
"hwirq number"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:87
msgid ""
"Note that irq_domain lookups must happen in contexts that are compatible "
"with an RCU read-side critical section."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:90
msgid ""
"The irq_create_mapping() function must be called *at least once* before any "
"call to irq_find_mapping(), lest the descriptor will not be allocated."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:94
msgid ""
"If the driver has the Linux IRQ number or the irq_data pointer, and needs to "
"know the associated hwirq number (such as in the irq_chip callbacks) then it "
"can be directly obtained from :c:member:`irq_data.hwirq`."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:100
msgid "Types of irq_domain Mappings"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:102
msgid ""
"There are several mechanisms available for reverse mapping from hwirq to "
"Linux IRQ, and each mechanism uses a different allocation function. Which "
"reverse map type should be used depends on the use case.  Each of the "
"reverse map types are described below:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:108
msgid "Linear"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:114
msgid ""
"The linear reverse map maintains a fixed-size table indexed by the hwirq "
"number.  When a hwirq is mapped, an irq_desc is allocated for the hwirq, and "
"the IRQ number is stored in the table."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:118
msgid ""
"The Linear map is a good choice when the maximum number of hwirqs is fixed "
"and a relatively small number (~ < 256).  The advantages of this map are "
"fixed-time lookup for IRQ numbers, and irq_descs are only allocated for in-"
"use IRQs.  The disadvantage is that the table must be as large as the "
"largest possible hwirq number."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:124
msgid "The majority of drivers should use the Linear map."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:127
msgid "Tree"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:133
msgid ""
"The irq_domain maintains a radix tree map from hwirq numbers to Linux IRQs.  "
"When an hwirq is mapped, an irq_desc is allocated and the hwirq is used as "
"the lookup key for the radix tree."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:137
msgid ""
"The Tree map is a good choice if the hwirq number can be very large since it "
"doesn't need to allocate a table as large as the largest hwirq number.  The "
"disadvantage is that hwirq to IRQ number lookup is dependent on how many "
"entries are in the table."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:142
msgid "Very few drivers should need this mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:145
msgid "No Map"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:151
msgid ""
"The No Map mapping is to be used when the hwirq number is programmable in "
"the hardware.  In this case it is best to program the Linux IRQ number into "
"the hardware itself so that no mapping is required.  Calling "
"irq_create_direct_mapping() will allocate a Linux IRQ number and call the ."
"map() callback so that driver can program the Linux IRQ number into the "
"hardware."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:158
msgid ""
"Most drivers cannot use this mapping, and it is now gated on the "
"CONFIG_IRQ_DOMAIN_NOMAP option. Please refrain from introducing new users of "
"this API."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:163
msgid "Legacy"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:170
msgid ""
"The Legacy mapping is a special case for drivers that already have a range "
"of irq_descs allocated for the hwirqs.  It is used when the driver cannot be "
"immediately converted to use the Linear mapping.  For example, many embedded "
"system board support files use a set of #defines for IRQ numbers that are "
"passed to struct device registrations.  In that case the Linux IRQ numbers "
"cannot be dynamically assigned and the Legacy mapping should be used."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:178
msgid ""
"As the name implies, the \\*_legacy() functions are deprecated and only "
"exist to ease the support of ancient platforms. No new users should be "
"added. Same goes for the \\*_simple() functions when their use results in "
"the legacy behaviour."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:183
msgid ""
"The Legacy map assumes a contiguous range of IRQ numbers has already been "
"allocated for the controller and that the IRQ number can be calculated by "
"adding a fixed offset to the hwirq number, and visa-versa.  The disadvantage "
"is that it requires the interrupt controller to manage IRQ allocations and "
"it requires an irq_desc to be allocated for every hwirq, even if it is "
"unused."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:190
msgid ""
"The Legacy map should only be used if fixed IRQ mappings must be supported.  "
"For example, ISA controllers would use the Legacy map for mapping Linux IRQs "
"0-15 so that existing ISA drivers get the correct IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:195
msgid ""
"Most users of legacy mappings should use irq_domain_create_simple() which "
"will use a legacy domain only if an IRQ range is supplied by the system and "
"will otherwise use a linear domain mapping. The semantics of this call are "
"such that if an IRQ range is specified then descriptors will be allocated on-"
"the-fly for it, and if no range is specified it will fall through to "
"irq_domain_create_linear() which means *no* IRQ descriptors will be "
"allocated."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:203
msgid ""
"A typical use case for simple domains is where an irqchip provider is "
"supporting both dynamic and static IRQ assignments."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:206
msgid ""
"In order to avoid ending up in a situation where a linear domain is used and "
"no descriptor gets allocated it is very important to make sure that the "
"driver using the simple domain call irq_create_mapping() before any "
"irq_find_mapping() since the latter will actually work for the static IRQ "
"assignment case."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:213
msgid "Hierarchy IRQ Domain"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:215
msgid ""
"On some architectures, there may be multiple interrupt controllers involved "
"in delivering an interrupt from the device to the target CPU. Let's look at "
"a typical interrupt delivery path on x86 platforms::"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:221
msgid "There are three interrupt controllers involved:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:223
msgid "IOAPIC controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:224
msgid "Interrupt remapping controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:225
msgid "Local APIC controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:227
msgid ""
"To support such a hardware topology and make software architecture match "
"hardware architecture, an irq_domain data structure is built for each "
"interrupt controller and those irq_domains are organized into hierarchy. "
"When building irq_domain hierarchy, the irq_domain nearest the device is "
"child and the irq_domain nearest the CPU is parent. So a hierarchy structure "
"as below will be built for the example above::"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:242
msgid "There are four major interfaces to use hierarchy irq_domain:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:244
msgid ""
"irq_domain_alloc_irqs(): allocate IRQ descriptors and interrupt controller "
"related resources to deliver these interrupts."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:246
msgid ""
"irq_domain_free_irqs(): free IRQ descriptors and interrupt controller "
"related resources associated with these interrupts."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:248
msgid ""
"irq_domain_activate_irq(): activate interrupt controller hardware to deliver "
"the interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:250
msgid ""
"irq_domain_deactivate_irq(): deactivate interrupt controller hardware to "
"stop delivering the interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:253
msgid "The following is needed to support hierarchy irq_domain:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:255
msgid ""
"The :c:member:`parent` field in struct irq_domain is used to maintain "
"irq_domain hierarchy information."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:257
msgid ""
"The :c:member:`parent_data` field in struct irq_data is used to build "
"hierarchy irq_data to match hierarchy irq_domains. The irq_data is used to "
"store irq_domain pointer and hardware irq number."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:261
msgid ""
"The :c:member:`alloc()`, :c:member:`free()`, and other callbacks in struct "
"irq_domain_ops to support hierarchy irq_domain operations."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:264
msgid ""
"With the support of hierarchy irq_domain and hierarchy irq_data ready, an "
"irq_domain structure is built for each interrupt controller, and an irq_data "
"structure is allocated for each irq_domain associated with an IRQ."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:269
msgid ""
"For an interrupt controller driver to support hierarchy irq_domain, it needs "
"to:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:272
msgid "Implement irq_domain_ops.alloc() and irq_domain_ops.free()"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:273
msgid ""
"Optionally, implement irq_domain_ops.activate() and irq_domain_ops."
"deactivate()."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:275
msgid ""
"Optionally, implement an irq_chip to manage the interrupt controller "
"hardware."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:277
msgid ""
"There is no need to implement irq_domain_ops.map() and irq_domain_ops."
"unmap(). They are unused with hierarchy irq_domain."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:280
msgid ""
"Note the hierarchy irq_domain is in no way x86-specific, and is heavily used "
"to support other architectures, such as ARM, ARM64 etc."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:284
msgid "Stacked irq_chip"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:286
msgid ""
"Now, we could go one step further to support stacked (hierarchy) irq_chip. "
"That is, an irq_chip is associated with each irq_data along the hierarchy. A "
"child irq_chip may implement a required action by itself or by cooperating "
"with its parent irq_chip."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:291
msgid ""
"With stacked irq_chip, interrupt controller driver only needs to deal with "
"the hardware managed by itself and may ask for services from its parent "
"irq_chip when needed. So we could achieve a much cleaner software "
"architecture."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:297
msgid "Debugging"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:299
msgid ""
"Most of the internals of the IRQ subsystem are exposed in debugfs by turning "
"CONFIG_GENERIC_IRQ_DEBUGFS on."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:303
msgid "Structures and Public Functions Provided"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:305
msgid ""
"This chapter contains the autogenerated documentation of the structures and "
"exported kernel API functions which are used for IRQ domains."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:32
msgid "generic IRQ specifier structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:36
#: include/linux/irqdomain.h:56 include/linux/irqdomain.h:115
#: include/linux/irqdomain.h:274
msgid "**Definition**::"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:44
#: include/linux/irqdomain.h:76 include/linux/irqdomain.h:144
#: include/linux/irqdomain.h:297
msgid "**Members**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:34
#: include/linux/irqdomain.h:123 include/linux/irqdomain.h:271
msgid "``fwnode``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:35
msgid "Pointer to a firmware-specific descriptor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:35
msgid "``param_count``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:36
msgid "Number of device-specific parameters"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:36
msgid "``param``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:37
msgid "Device-specific parameters"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:40
#: include/linux/irqdomain.h:76 include/linux/irqdomain.h:149
#: include/linux/irqdomain.h:448 include/linux/irqdomain.h:538
#: include/linux/irqdomain.h:579 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:69 kernel/irq/irqdomain.c:116
#: kernel/irq/irqdomain.c:382 kernel/irq/irqdomain.c:456
#: kernel/irq/irqdomain.c:553 kernel/irq/irqdomain.c:571
#: kernel/irq/irqdomain.c:731 kernel/irq/irqdomain.c:803
#: kernel/irq/irqdomain.c:1016 kernel/irq/irqdomain.c:1070
#: kernel/irq/irqdomain.c:1094 kernel/irq/irqdomain.c:1118
#: kernel/irq/irqdomain.c:1143 kernel/irq/irqdomain.c:1201
#: kernel/irq/irqdomain.c:1226 kernel/irq/irqdomain.c:1365
#: kernel/irq/irqdomain.c:1649 kernel/irq/irqdomain.c:1709
#: kernel/irq/irqdomain.c:1792 ../../../core-api/irq/irq-domain:319:
#: kernel/irq/irqdomain.c:1964 kernel/irq/irqdomain.c:1983
msgid "**Description**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:37
msgid ""
"This structure, directly modeled after of_phandle_args, is used to pass a "
"device-specific description of an interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:52
msgid "Methods for irq_domain objects"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:53
msgid "``match``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:54
msgid ""
"Match an interrupt controller device node to a domain, returns 1 on a match"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:55
msgid "``select``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:56
msgid ""
"Match an interrupt controller fw specification. It is more generic than "
"**match** as it receives a complete struct irq_fwspec. Therefore, **select** "
"is preferred if provided. Returns 1 on a match."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:58
msgid "``map``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:59
msgid ""
"Create or update a mapping between a virtual irq number and a hw irq number. "
"This is called only once for a given mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:60
msgid "``unmap``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:61
msgid "Dispose of such a mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:61
msgid "``xlate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:62
msgid ""
"Given a device tree node and interrupt specifier, decode the hardware irq "
"number and linux irq type value."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:63
msgid "``alloc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:64
msgid "Allocate **nr_irqs** interrupts starting from **virq**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:64
msgid "``free``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:65
msgid "Free **nr_irqs** interrupts starting from **virq**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:65
msgid "``activate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:66
msgid ""
"Activate one interrupt in HW (**irqd**). If **reserve** is set, only reserve "
"the vector. If unset, assign the vector (called from request_irq())."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:68
msgid "``deactivate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:69
msgid "Disarm one interrupt (**irqd**)."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:69
msgid "``translate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:70
msgid ""
"Given **fwspec**, decode the hardware irq number (**out_hwirq**) and linux "
"irq type value (**out_type**). This is a generalised **xlate** (over struct "
"irq_fwspec) and is preferred if provided."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:72
msgid "``debug_show``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:73
msgid "For domains to show specific data for an interrupt in debugfs."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:73
msgid ""
"Functions below are provided by the driver and called whenever a new mapping "
"is created or an old mapping is disposed. The driver can then proceed to "
"whatever internal data structures management is required. It also needs to "
"setup the irq_desc when returning from map()."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:111
msgid "Hardware interrupt number translation object"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:112
msgid "``link``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:113
msgid "Element in global irq_domain list."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:113
msgid "``name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:114
msgid "Name of interrupt domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:114
#: include/linux/irqdomain.h:283
msgid "``ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:115
msgid "Pointer to irq_domain methods"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:115
#: include/linux/irqdomain.h:284
msgid "``host_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:116
msgid ""
"Private data pointer for use by owner.  Not touched by irq_domain core code."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:117
msgid "``flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:118
msgid "Per irq_domain flags"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:118
msgid "``mapcount``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:119
msgid "The number of mapped interrupts"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:119
msgid "``mutex``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:120
msgid "Domain lock, hierarchical domains use root domain's lock"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:120
msgid "``root``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:121
msgid "Pointer to root domain, or containing structure if non-hierarchical"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:124
msgid ""
"Pointer to firmware node associated with the irq_domain. Pretty easy to swap "
"it for the of_node via the irq_domain_get_of_node accessor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:125
#: include/linux/irqdomain.h:280
msgid "``bus_token``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:126
msgid ""
"**fwnode**'s device_node might be used for several irq domains. But in "
"connection with **bus_token**, the pair shall be unique in a system."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:128
msgid "``gc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:129
msgid ""
"Pointer to a list of generic chips. There is a helper function for setting "
"up one or more generic chips for interrupt controllers drivers using the "
"generic chip library which uses this pointer."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:131
#: include/linux/irqdomain.h:285
msgid "``dev``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:132
msgid ""
"Pointer to the device which instantiated the irqdomain With per device irq "
"domains this is not necessarily the same as **pm_dev**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:134
msgid "``pm_dev``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:135
msgid ""
"Pointer to a device that can be utilized for power management purposes "
"related to the irq domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:136
#: include/linux/irqdomain.h:308
msgid "``parent``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:137
msgid "Pointer to parent irq_domain to support hierarchy irq_domains"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:137
msgid "``msi_parent_ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:138
msgid "Pointer to MSI parent domain methods for per device domain init"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:138
#: include/linux/irqdomain.h:290
msgid "``exit``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:139
msgid "Function called when the domain is destroyed"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:141
#: include/linux/irqdomain.h:274
msgid "``hwirq_max``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:142
msgid ""
"Top limit for the HW irq number. Especially to avoid conflicts/failures with "
"reserved HW irqs. Can be ~0."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:143
msgid "``revmap_size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:144
msgid "Size of the linear map table **revmap**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:144
msgid "``revmap_tree``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:145
msgid "Radix map tree for hwirqs that don't fit in the linear map"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:145
msgid "``revmap``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:146
msgid "Linear table of irq_data pointers"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:121
msgid "Optional elements:"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:123
msgid "Revmap data, used internally by the irq domain code:"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:270
msgid "Domain information structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:272
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:448
msgid "firmware node for the interrupt controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:272
msgid "``domain_flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:273
msgid "Additional flags to add to the domain flags"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:273
msgid "``size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:274
msgid "Size of linear map; 0 for radix mapping only"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:275
msgid "Maximum number of interrupts supported by controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:275
msgid "``direct_max``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:276
msgid ""
"Maximum value of direct maps; Use ~0 for no limit; 0 for no direct mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:277
msgid "``hwirq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:278
msgid "The first hardware interrupt number (legacy domains only)"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:278
msgid "``virq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:279
msgid ""
"The first Linux interrupt number for legacy domains to immediately associate "
"the interrupts after domain creation"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:281
msgid "Domain bus token"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:281
msgid "``name_suffix``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:282
msgid ""
"Optional name suffix to avoid collisions when multiple domains are added "
"using same fwnode"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:284
msgid "Domain operation callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:285
#: include/linux/irqdomain.h:396 include/linux/irqdomain.h:536
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:454
msgid "Controller private data pointer"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:286
msgid "Device which creates the domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:309
msgid "Pointer to the parent irq domain used in a hierarchy domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:286
msgid "``dgc_info``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:287
msgid ""
"Geneneric chip information structure pointer used to create generic chips "
"for the domain if not NULL."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:288
msgid "``init``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:289
msgid ""
"Function called when the domain is created. Allow to do some additional "
"domain initialisation."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:291
msgid ""
"Function called when the domain is destroyed. Allow to do some additional "
"cleanup operation."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:392
msgid "Allocate and register a linear revmap irq_domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:396
#: include/linux/irqdomain.h:448 include/linux/irqdomain.h:469
#: include/linux/irqdomain.h:482 include/linux/irqdomain.h:534
#: include/linux/irqdomain.h:577 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:66 kernel/irq/irqdomain.c:117
#: kernel/irq/irqdomain.c:371 kernel/irq/irqdomain.c:383
#: kernel/irq/irqdomain.c:451 kernel/irq/irqdomain.c:511
#: kernel/irq/irqdomain.c:554 kernel/irq/irqdomain.c:571
#: kernel/irq/irqdomain.c:732 kernel/irq/irqdomain.c:802
#: kernel/irq/irqdomain.c:989 kernel/irq/irqdomain.c:1015
#: kernel/irq/irqdomain.c:1066 kernel/irq/irqdomain.c:1090
#: kernel/irq/irqdomain.c:1114 kernel/irq/irqdomain.c:1139
#: kernel/irq/irqdomain.c:1177 kernel/irq/irqdomain.c:1198
#: kernel/irq/irqdomain.c:1223 kernel/irq/irqdomain.c:1277
#: kernel/irq/irqdomain.c:1365 kernel/irq/irqdomain.c:1465
#: kernel/irq/irqdomain.c:1484 kernel/irq/irqdomain.c:1510
#: kernel/irq/irqdomain.c:1532 kernel/irq/irqdomain.c:1553
#: kernel/irq/irqdomain.c:1644 kernel/irq/irqdomain.c:1708
#: kernel/irq/irqdomain.c:1792 kernel/irq/irqdomain.c:1896
#: kernel/irq/irqdomain.c:1915 ../../../core-api/irq/irq-domain:319:
#: kernel/irq/irqdomain.c:1861 kernel/irq/irqdomain.c:1963
#: kernel/irq/irqdomain.c:1983
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:398
#: include/linux/irqdomain.h:535 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:119 kernel/irq/irqdomain.c:453
msgid "``struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:393
msgid "pointer to interrupt controller's FW node."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:395
#: include/linux/irqdomain.h:534 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:450
msgid "``unsigned int size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:394
msgid "Number of interrupts in the domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:396
#: include/linux/irqdomain.h:536 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:454
msgid "``const struct irq_domain_ops *ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:395
msgid "map/unmap domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:397
#: include/linux/irqdomain.h:537 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:455
msgid "``void *host_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:398
#: include/linux/irqdomain.h:452 include/linux/irqdomain.h:469
#: include/linux/irqdomain.h:482 include/linux/irqdomain.h:542
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:3
#: kernel/irq/irqdomain.c:370
msgid "**Return**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:398
msgid "Newly created irq_domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:444
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:798
msgid "Map a hardware interrupt into linux irq space"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:450
#: include/linux/irqdomain.h:471 include/linux/irqdomain.h:484
#: include/linux/irqdomain.h:579 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:385 kernel/irq/irqdomain.c:556
#: kernel/irq/irqdomain.c:734 kernel/irq/irqdomain.c:804
#: kernel/irq/irqdomain.c:1017 kernel/irq/irqdomain.c:1367
#: kernel/irq/irqdomain.c:1467 kernel/irq/irqdomain.c:1486
#: kernel/irq/irqdomain.c:1512 kernel/irq/irqdomain.c:1534
#: kernel/irq/irqdomain.c:1555 kernel/irq/irqdomain.c:1646
#: kernel/irq/irqdomain.c:1710 kernel/irq/irqdomain.c:1794
#: kernel/irq/irqdomain.c:1898 kernel/irq/irqdomain.c:1917
msgid "``struct irq_domain *domain``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:445
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:799
msgid "domain owning this hardware interrupt or NULL for default domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:447
#: include/linux/irqdomain.h:468 include/linux/irqdomain.h:481
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:801
#: kernel/irq/irqdomain.c:1014 kernel/irq/irqdomain.c:1484
#: kernel/irq/irqdomain.c:1510
msgid "``irq_hw_number_t hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:446
#: include/linux/irqdomain.h:467 include/linux/irqdomain.h:480
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:800
#: kernel/irq/irqdomain.c:1013
msgid "hardware irq number in that domain space"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:447
msgid "Only one mapping per hardware interrupt is permitted."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:449
msgid ""
"If the sense/trigger is to be specified, set_irq_type() should be called on "
"the number returned from that call."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:453
msgid "Linux irq number or 0 on error"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:465
#: include/linux/irqdomain.h:478 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:1011
msgid "Find a linux irq from a hw irq number."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:466
#: include/linux/irqdomain.h:479 ../../../core-api/irq/irq-domain:310:
#: kernel/irq/irqdomain.c:1012
msgid "domain owning this hardware interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:469
msgid "Interrupt descriptor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:482
msgid "Linux irq number or 0 if not found"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:530
msgid "Add a irqdomain into the hierarchy"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:536
msgid "``struct irq_domain *parent``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:531
msgid "Parent irq domain to associate with the new domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:533
msgid "``unsigned int flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:532
msgid "Irq domain flags associated to the domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:533
msgid "Size of the domain. See below"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:534
msgid "Optional fwnode of the interrupt controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:535
msgid "Pointer to the interrupt domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:537
msgid "If **size** is 0 a tree domain is created, otherwise a linear domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:539
msgid ""
"If successful the parent is associated to the new domain and the domain "
"flags are set."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:543
msgid "A pointer to IRQ domain, or ``NULL`` on failure."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:573
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1640
msgid "Allocate IRQs from domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:574
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1641
msgid "domain to allocate from"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:576
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1532
#: kernel/irq/irqdomain.c:1553 kernel/irq/irqdomain.c:1644
#: kernel/irq/irqdomain.c:1896 kernel/irq/irqdomain.c:1915
#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1860
msgid "``unsigned int nr_irqs``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:575
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1643
msgid "number of IRQs to allocate"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:577
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1645
msgid "``int node``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:576
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1644
msgid "NUMA node id for memory allocation"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:578
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1646
#: kernel/irq/irqdomain.c:1708 kernel/irq/irqdomain.c:1897
msgid "``void *arg``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:577
#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1645
msgid "domain specific argument"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: include/linux/irqdomain.h:578
msgid "See __irq_domain_alloc_irqs()' documentation."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:62
msgid "Allocate a fwnode_handle suitable for identifying an irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:68
msgid "``unsigned int type``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:64
msgid "Type of irqchip_fwnode. See linux/irqdomain.h"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:66
msgid "``int id``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:65
msgid "Optional user provided id if name != NULL"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:67
msgid "``const char *name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:66
msgid "Optional user provided domain name"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:68
msgid "``phys_addr_t *pa``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:67
msgid "Optional user-provided physical address"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:68
msgid ""
"Allocate a struct irqchip_fwid, and return a pointer to the embedded "
"fwnode_handle (or NULL on failure)."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:71
#: kernel/irq/irqdomain.c:1146
msgid "**Note**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:72
msgid ""
"The types IRQCHIP_FWNODE_NAMED and IRQCHIP_FWNODE_NAMED_ID are solely to "
"transport name information to irqdomain creation code. The node is not "
"stored. For other types the pointer is kept in the irq domain struct."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:113
msgid "Free a non-OF-backed fwnode_handle"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:114
msgid "fwnode_handle to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:115
msgid "Free a fwnode_handle allocated with irq_domain_alloc_fwnode."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:367
msgid "Instantiate a new irq domain data structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:373
msgid "``const struct irq_domain_info *info``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:368
msgid "Domain information pointer pointing to the information for this domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:370
msgid "A pointer to the instantiated irq domain or an ERR_PTR value."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:379
msgid "Remove an irq domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:380
msgid "domain to remove"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:381
msgid ""
"This routine is used to remove an irq domain. The caller must ensure that "
"all mappings within the domain have been disposed of prior to use, depending "
"on the revmap type."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:447
msgid "Register an irq_domain and optionally map a range of irqs"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:449
msgid "total number of irqs in mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:451
msgid "``unsigned int first_irq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:450
msgid ""
"first number of irq block assigned to the domain, pass zero to assign irqs "
"on-the-fly. If first_irq is non-zero, then pre-map all of the irqs in the "
"domain to virqs starting at first_irq."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:453
msgid "domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:455
msgid ""
"Allocates an irq_domain, and optionally if first_irq is positive then also "
"allocate irq_descs and map all of the hwirqs to virqs starting at first_irq."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:458
msgid ""
"This is intended to implement the expected behaviour for most interrupt "
"controllers. If device tree is used, then first_irq will be 0 and irqs get "
"mapped dynamically on the fly. However, if the controller requires static "
"virq assignments (non-DT boot) then it will set that up correctly."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:507
msgid "Locates a domain for a given fwspec"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:513
#: kernel/irq/irqdomain.c:1177 kernel/irq/irqdomain.c:1198
#: kernel/irq/irqdomain.c:1223
msgid "``struct irq_fwspec *fwspec``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:508
msgid "FW specifier for an interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:510
msgid "``enum irq_domain_bus_token bus_token``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:509
msgid "domain-specific data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:550
msgid "Set a \"default\" irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:551
msgid "default domain pointer"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:552
msgid ""
"For convenience, it's possible to set a \"default\" domain that will be used "
"whenever NULL is passed to irq_create_mapping(). It makes life easier for "
"platforms that want to manipulate a few hard coded interrupt numbers that "
"aren't properly represented in the device-tree."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:567
msgid "Retrieve the \"default\" irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:573
msgid "``void``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1
msgid "no arguments"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:569
msgid "the default domain, if any."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:570
msgid ""
"Modern code should never use this. This should only be used on systems that "
"cannot implement a firmware->fwnode mapping (which both DT and ACPI provide)."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:728
msgid "Allocate an irq for direct mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:729
msgid "domain to allocate the irq for or NULL for default domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:730
msgid ""
"This routine is used for irq controllers which can choose the hardware "
"interrupt numbers they generate. In such a case it's simplest to use the "
"linux irq as the hardware interrupt number. It still uses the linear or "
"radix tree to store the mapping, but the irq controller can optimize the "
"revmap path by using the hwirq directly."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:802
#: kernel/irq/irqdomain.c:1648
msgid "``const struct irq_affinity_desc *affinity``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:801
msgid "irq affinity"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:802
msgid ""
"Only one mapping per hardware interrupt is permitted. Returns a linux irq "
"number. If the sense/trigger is to be specified, set_irq_type() should be "
"called on the number returned from that call."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:985
msgid "Unmap an interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:991
#: kernel/irq/irqdomain.c:1364 kernel/irq/irqdomain.c:1464
#: kernel/irq/irqdomain.c:1483 kernel/irq/irqdomain.c:1509
#: kernel/irq/irqdomain.c:1531 kernel/irq/irqdomain.c:1552
#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1863
msgid "``unsigned int virq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:986
msgid "linux irq number of the interrupt to unmap"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1015
msgid "``unsigned int *irq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1014
msgid "optional pointer to return the Linux irq if required"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1015
msgid "Returns the interrupt descriptor."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1062
msgid "Generic xlate for direct one cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1068
#: kernel/irq/irqdomain.c:1092 kernel/irq/irqdomain.c:1116
#: kernel/irq/irqdomain.c:1141 kernel/irq/irqdomain.c:1179
#: kernel/irq/irqdomain.c:1200 kernel/irq/irqdomain.c:1225
msgid "``struct irq_domain *d``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1063
#: kernel/irq/irqdomain.c:1087 kernel/irq/irqdomain.c:1111
#: kernel/irq/irqdomain.c:1136 kernel/irq/irqdomain.c:1175
#: kernel/irq/irqdomain.c:1196 kernel/irq/irqdomain.c:1221
msgid "Interrupt domain involved in the translation"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1065
#: kernel/irq/irqdomain.c:1089 kernel/irq/irqdomain.c:1113
#: kernel/irq/irqdomain.c:1138
msgid "``struct device_node *ctrlr``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1064
#: kernel/irq/irqdomain.c:1088 kernel/irq/irqdomain.c:1112
#: kernel/irq/irqdomain.c:1137
msgid "The device tree node for the device whose interrupt is translated"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1066
#: kernel/irq/irqdomain.c:1090 kernel/irq/irqdomain.c:1114
#: kernel/irq/irqdomain.c:1139
msgid "``const u32 *intspec``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1065
#: kernel/irq/irqdomain.c:1089 kernel/irq/irqdomain.c:1113
#: kernel/irq/irqdomain.c:1138
msgid "The interrupt specifier data from the device tree"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1067
#: kernel/irq/irqdomain.c:1091 kernel/irq/irqdomain.c:1115
#: kernel/irq/irqdomain.c:1140
msgid "``unsigned int intsize``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1066
#: kernel/irq/irqdomain.c:1090 kernel/irq/irqdomain.c:1114
#: kernel/irq/irqdomain.c:1139
msgid "The number of entries in **intspec**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1068
#: kernel/irq/irqdomain.c:1141 kernel/irq/irqdomain.c:1178
#: kernel/irq/irqdomain.c:1199 kernel/irq/irqdomain.c:1224
msgid "``unsigned long *out_hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1067
#: kernel/irq/irqdomain.c:1091 kernel/irq/irqdomain.c:1115
#: kernel/irq/irqdomain.c:1140 kernel/irq/irqdomain.c:1177
#: kernel/irq/irqdomain.c:1198 kernel/irq/irqdomain.c:1223
msgid "Pointer to storage for the hardware interrupt number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1069
#: kernel/irq/irqdomain.c:1093 kernel/irq/irqdomain.c:1117
#: kernel/irq/irqdomain.c:1142 kernel/irq/irqdomain.c:1179
#: kernel/irq/irqdomain.c:1200 kernel/irq/irqdomain.c:1225
msgid "``unsigned int *out_type``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1068
#: kernel/irq/irqdomain.c:1092 kernel/irq/irqdomain.c:1116
#: kernel/irq/irqdomain.c:1141 kernel/irq/irqdomain.c:1178
#: kernel/irq/irqdomain.c:1199 kernel/irq/irqdomain.c:1224
msgid "Pointer to storage for the interrupt type"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1069
msgid ""
"Device Tree IRQ specifier translation function which works with one cell "
"bindings where the cell value maps directly to the hwirq number."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1086
msgid "Generic xlate for direct two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1092
#: kernel/irq/irqdomain.c:1116
msgid "``irq_hw_number_t *out_hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1093
#: kernel/irq/irqdomain.c:1200
msgid ""
"Device Tree IRQ specifier translation function which works with two cell "
"bindings where the cell values map directly to the hwirq number and linux "
"irq flags."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1110
msgid "Generic xlate for direct two or three cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1117
msgid ""
"Device Tree interrupt specifier translation function for two or three cell "
"bindings, where the cell values map directly to the hardware interrupt "
"number and the type specifier."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1135
msgid "Generic xlate for one or two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1142
msgid ""
"Device Tree IRQ specifier translation function which works with either one "
"or two cell bindings where the cell values map directly to the hwirq number "
"and linux irq flags."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1147
msgid ""
"don't use this function unless your interrupt controller explicitly supports "
"both one and two cell bindings.  For the majority of controllers the "
"_onecell() or _twocell() variants above should be used."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1173
msgid "Generic translate for direct one cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1176
#: kernel/irq/irqdomain.c:1197 kernel/irq/irqdomain.c:1222
msgid "The firmware interrupt specifier to translate"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1194
msgid "Generic translate for direct two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1219
msgid "Generic translate for direct two or three cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1225
msgid ""
"Firmware interrupt specifier translation function for two or three cell "
"specifications, where the parameter values map directly to the hardware "
"interrupt number and the type specifier."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1273
msgid "Clear hwirq, chip and chip_data in **irq_data**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1279
#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1965
#: kernel/irq/irqdomain.c:1985
msgid "``struct irq_data *irq_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1274
msgid "The pointer to irq_data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1361
msgid "Mark the first unused level of a hierarchy"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1362
msgid "IRQ domain from which the hierarchy is to be disconnected"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1363
msgid "IRQ number where the hierarchy is to be trimmed"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1364
msgid ""
"Marks the **virq** level belonging to **domain** as disconnected. Returns -"
"EINVAL if **virq** doesn't have a valid irq_data pointing to **domain**."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1368
msgid ""
"Its only use is to be able to trim levels of hierarchy that do not have any "
"real meaning for this interrupt, and that the driver marks as such from its ."
"alloc() callback."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1461
msgid "Get irq_data associated with **virq** and **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1462
msgid "domain to match"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1463
msgid "IRQ number to get irq_data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1480
msgid "Set hwirq and irqchip of **virq** at **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1481
#: kernel/irq/irqdomain.c:1507 kernel/irq/irqdomain.c:1529
#: kernel/irq/irqdomain.c:1550
msgid "Interrupt domain to match"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1482
#: kernel/irq/irqdomain.c:1508
msgid "IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1483
msgid "The hwirq number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1485
#: kernel/irq/irqdomain.c:1511
msgid "``const struct irq_chip *chip``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1484
#: kernel/irq/irqdomain.c:1510
msgid "The associated interrupt chip"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1486
#: kernel/irq/irqdomain.c:1512
msgid "``void *chip_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1485
msgid "The associated chip data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1506
msgid "Set the complete data for a **virq** in **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1509
msgid "The hardware interrupt number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1511
msgid "The associated interrupt chip data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1513
msgid "``irq_flow_handler_t handler``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1512
msgid "The interrupt flow handler"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1514
msgid "``void *handler_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1513
msgid "The interrupt flow handler data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1515
msgid "``const char *handler_name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1514
msgid "The interrupt handler name"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1528
msgid "Clear irq_data and free the parent"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1530
#: kernel/irq/irqdomain.c:1551
msgid "IRQ number to start with"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1531
#: kernel/irq/irqdomain.c:1552
msgid "The number of irqs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1549
msgid "Clear handler and handler data, clear irqdata and free parent"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1643
msgid "``int irq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1642
msgid "allocate specified IRQ number if irq_base >= 0"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1647
msgid "``bool realloc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1646
msgid "IRQ descriptors have already been allocated if true"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1647
msgid "Optional irq affinity mask for multiqueue devices"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1648
msgid ""
"Allocate IRQ numbers and initialized all data structures to support "
"hierarchy IRQ domains. Parameter **realloc** is mainly to support legacy "
"IRQs. Returns error code or allocated IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1653
msgid ""
"The whole process to setup an IRQ has been split into two steps. The first "
"step, __irq_domain_alloc_irqs(), is to allocate IRQ descriptor and required "
"hardware resources. The second step, irq_domain_activate_irq(), is to "
"program the hardware with preallocated resources. In this way, it's easier "
"to rollback when failing to allocate resources."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1704
msgid "Push a domain in to the top of a hierarchy."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1705
msgid "Domain to push."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1707
#: kernel/irq/irqdomain.c:1791
msgid "``int virq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1706
msgid "Irq to push the domain in to."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1707
msgid "Passed to the irq_domain_ops alloc() function."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1708
msgid ""
"For an already existing irqdomain hierarchy, as might be obtained via a call "
"to pci_enable_msix(), add an additional domain to the head of the processing "
"chain.  Must be called before request_irq() has been called."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1788
msgid "Remove a domain from the top of a hierarchy."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1789
msgid "Domain to remove."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1790
msgid "Irq to remove the domain from."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1791
msgid ""
"Undo the effects of a call to irq_domain_push_irq().  Must be called either "
"before request_irq() or after free_irq()."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1892
msgid "Allocate interrupts from parent domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1893
msgid "Domain below which interrupts must be allocated"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1895
#: kernel/irq/irqdomain.c:1914
msgid "``unsigned int irq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1894
#: kernel/irq/irqdomain.c:1913
msgid "Base IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1895
msgid "Number of IRQs to allocate"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1896
msgid "Allocation data (arch/domain specific)"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1911
msgid "Free interrupts from parent domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1912
msgid "Domain below which interrupts must be freed"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: kernel/irq/irqdomain.c:1914
msgid "Number of IRQs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:314
msgid "Internal Functions Provided"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:316
msgid ""
"This chapter contains the autogenerated documentation of the internal "
"functions."
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1857
msgid "Free IRQ number and associated data structures"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1858
msgid "base IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1859
msgid "number of IRQs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1959
msgid "Call domain_ops->activate recursively to activate interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1961
msgid "Outermost irq_data associated with interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1963
msgid "``bool reserve``"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1962
msgid "If set only reserve an interrupt vector instead of assigning one"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1963
msgid ""
"This is the second step to call domain_ops->activate to program interrupt "
"controllers, so the interrupt could actually get delivered."
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1979
msgid "Call domain_ops->deactivate recursively to deactivate interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1981
msgid "outermost irq_data associated with interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: kernel/irq/irqdomain.c:1982
msgid ""
"It calls domain_ops->deactivate to program interrupt controllers to disable "
"interrupt delivery."
msgstr ""
