# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-10 10:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/liveupdate.rst:5
msgid "Live Update Orchestrator"
msgstr ""

#: ../../../core-api/liveupdate.rst:0
msgid "Author"
msgstr "作者"

#: ../../../core-api/liveupdate.rst:6
msgid "Pasha Tatashin <pasha.tatashin@soleen.com>"
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:9
msgid ""
"Live Update is a specialized, kexec-based reboot process that allows a "
"running kernel to be updated from one version to another while preserving "
"the state of selected resources and keeping designated hardware devices "
"operational. For these devices, DMA activity may continue throughout the "
"kernel transition."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:15
msgid ""
"While the primary use case driving this work is supporting live updates of "
"the Linux kernel when it is used as a hypervisor in cloud environments, the "
"LUO framework itself is designed to be workload-agnostic. Live Update "
"facilitates a full kernel version upgrade for any type of system."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:20
msgid ""
"For example, a non-hypervisor system running an in-memory cache like "
"memcached with many gigabytes of data can use LUO. The userspace service can "
"place its cache into a memfd, have its state preserved by LUO, and restore "
"it immediately after the kernel kexec."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:25
msgid ""
"Whether the system is running virtual machines, containers, a high-"
"performance database, or networking services, LUO's primary goal is to "
"enable a full kernel update by preserving critical userspace state and "
"keeping essential devices operational."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:30
msgid ""
"The core of LUO is a mechanism that tracks the progress of a live update, "
"along with a callback API that allows other kernel subsystems to participate "
"in the process. Example subsystems that can hook into LUO include: kvm, "
"iommu, interrupts, vfio, participating filesystems, and memory management."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:35
msgid ""
"LUO uses Kexec Handover to transfer memory state from the current kernel to "
"the next kernel. For more details see Documentation/core-api/kho/concepts."
"rst."
msgstr ""

#: ../../../core-api/liveupdate.rst:12
msgid "LUO Sessions"
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:9
msgid ""
"LUO Sessions provide the core mechanism for grouping and managing `struct "
"file *` instances that need to be preserved across a kexec-based live "
"update. Each session acts as a named container for a set of file objects, "
"allowing a userspace agent to manage the lifecycle of resources critical to "
"a workload."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:15
msgid "Core Concepts:"
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:17
msgid ""
"Named Containers: Sessions are identified by a unique, user-provided name, "
"which is used for both creation in the current kernel and retrieval in the "
"next kernel."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:21
msgid ""
"Userspace Interface: Session management is driven from userspace via ioctls "
"on /dev/liveupdate."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:24
msgid ""
"Serialization: Session metadata is preserved using the KHO framework. When a "
"live update is triggered via kexec, an array of `struct luo_session_ser` is "
"populated and placed in a preserved memory region. An FDT node is also "
"created, containing the count of sessions and the physical address of this "
"array."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:30
msgid "Session Lifecycle:"
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:32
msgid ""
"Creation: A userspace agent calls `luo_session_create()` to create a new, "
"empty session and receives a file descriptor for it."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:35
msgid ""
"Serialization: When the `reboot(LINUX_REBOOT_CMD_KEXEC)` syscall is made, "
"`luo_session_serialize()` is called. It iterates through all active sessions "
"and writes their metadata into a memory area preserved by KHO."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:40
msgid ""
"Deserialization (in new kernel): After kexec, `luo_session_deserialize()` "
"runs, reading the serialized data and creating a list of `struct "
"luo_session` objects representing the preserved sessions."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:44
msgid ""
"Retrieval: A userspace agent in the new kernel can then call "
"`luo_session_retrieve()` with a session name to get a new file descriptor "
"and access the preserved state."
msgstr ""

#: ../../../core-api/liveupdate.rst:17
msgid "LUO Preserving File Descriptors"
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:9
msgid ""
"LUO provides the infrastructure to preserve specific, stateful file "
"descriptors across a kexec-based live update. The primary goal is to allow "
"workloads, such as virtual machines using vfio, memfd, or iommufd, to retain "
"access to their essential resources without interruption."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:14
msgid ""
"The framework is built around a callback-based handler model and a well- "
"defined lifecycle for each preserved file."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:17
msgid ""
"Handler Registration: Kernel modules responsible for a specific file type (e."
"g., memfd, vfio) register a :c:type:`struct liveupdate_file_handler "
"<liveupdate_file_handler>`. This handler provides a set of callbacks that "
"LUO invokes at different stages of the update process, most notably:"
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:23
msgid ""
"can_preserve(): A lightweight check to determine if the handler is "
"compatible with a given 'struct file'."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:25
msgid ""
"preserve(): The heavyweight operation that saves the file's state and "
"returns an opaque u64 handle. This is typically performed while the workload "
"is still active to minimize the downtime during the actual reboot transition."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:29
msgid ""
"unpreserve(): Cleans up any resources allocated by .preserve(), called if "
"the preservation process is aborted before the reboot (i.e. session is "
"closed)."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:32
msgid ""
"freeze(): A final pre-reboot opportunity to prepare the state for kexec. We "
"are already in reboot syscall, and therefore userspace cannot mutate the "
"file anymore."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:35
msgid ""
"unfreeze(): Undoes the actions of .freeze(), called if the live update is "
"aborted after the freeze phase."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:37
msgid ""
"retrieve(): Reconstructs the file in the new kernel from the preserved "
"handle."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:39
msgid ""
"finish(): Performs final check and cleanup in the new kernel. After succesul "
"finish call, LUO gives up ownership to this file."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:42
msgid "File Preservation Lifecycle happy path:"
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:44
msgid ""
"Preserve (Normal Operation): A userspace agent preserves files one by one "
"via an ioctl. For each file, luo_preserve_file() finds a compatible handler, "
"calls its .preserve() operation, and creates an internal :c:type:`struct "
"luo_file <luo_file>` to track the live state."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:49
msgid ""
"Freeze (Pre-Reboot): Just before the kexec, luo_file_freeze() is called. It "
"iterates through all preserved files, calls their respective .freeze() "
"operation, and serializes their final metadata (compatible string, token, "
"and data handle) into a contiguous memory block for KHO."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:54
msgid ""
"Deserialize: After kexec, luo_file_deserialize() runs when session gets "
"deserialized (which is when /dev/liveupdate is first opened). It reads the "
"serialized data from the KHO memory region and reconstructs the in-memory "
"list of :c:type:`struct luo_file <luo_file>` instances for the new kernel, "
"linking them to their corresponding handlers."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:60
msgid ""
"Retrieve (New Kernel - Userspace Ready): The userspace agent can now restore "
"file descriptors by providing a token. luo_retrieve_file() searches for the "
"matching token, calls the handler's .retrieve() op to re-create the 'struct "
"file', and returns a new FD. Files can be retrieved in ANY order."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:66
msgid ""
"Finish (New Kernel - Cleanup): Once a session retrival is complete, "
"luo_file_finish() is called. It iterates through all files, invokes their ."
"finish() operations for final cleanup, and releases all associated kernel "
"resources."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:71
msgid "File Preservation Lifecycle unhappy paths:"
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:73
msgid ""
"Abort Before Reboot: If the userspace agent aborts the live update process "
"before calling reboot (e.g., by closing the session file descriptor), the "
"session's release handler calls luo_file_unpreserve_files(). This invokes "
"the .unpreserve() callback on all preserved files, ensuring all allocated "
"resources are cleaned up and returning the system to a clean state."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:80
msgid ""
"Freeze Failure: During the reboot() syscall, if any handler's .freeze() op "
"fails, the .unfreeze() op is invoked on all previously *successful* freezes "
"to roll back their state. The reboot() syscall then returns an error to "
"userspace, canceling the live update."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:85
msgid ""
"Finish Failure: In the new kernel, if a handler's .finish() op fails, the "
"luo_file_finish() operation is aborted. LUO retains ownership of all files "
"within that session, including those that were not yet processed. The "
"userspace agent can attempt to call the finish operation again later. If the "
"issue cannot be resolved, these resources will be held by LUO until the next "
"live update cycle, at which point they will be discarded."
msgstr ""

#: ../../../core-api/liveupdate.rst:22
msgid "Live Update Orchestrator ABI"
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:9
msgid ""
"This header defines the stable Application Binary Interface used by the Live "
"Update Orchestrator to pass state from a pre-update kernel to a post-update "
"kernel. The ABI is built upon the Kexec HandOver framework and uses a "
"Flattened Device Tree to describe the preserved data."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:14
msgid ""
"This interface is a contract. Any modification to the FDT structure, node "
"properties, compatible strings, or the layout of the `__packed` "
"serialization structures defined here constitutes a breaking change. Such "
"changes require incrementing the version number in the relevant "
"`_COMPATIBLE` string to prevent a new kernel from misinterpreting data from "
"an old kernel."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:20
msgid ""
"Changes are allowed provided the compatibility version is incremented; "
"however, backward/forward compatibility is only guaranteed for kernels "
"supporting the same ABI version."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:24
msgid "FDT Structure Overview:"
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:25
msgid ""
"The entire LUO state is encapsulated within a single KHO entry named "
"\"LUO\". This entry contains an FDT with the following layout:"
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:40
msgid "Main LUO Node (/):"
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:42
msgid "compatible: \"luo-v1\" Identifies the overall LUO ABI version."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:44
msgid ""
"liveupdate-number: u64 A counter tracking the number of successful live "
"updates performed."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:47
msgid "Session Node (luo-session):"
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:48
msgid "This node describes all preserved user-space sessions."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:50
msgid "compatible: \"luo-session-v1\" Identifies the session ABI version."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:52
msgid ""
"luo-session-header: u64 The physical address of a `struct "
"luo_session_header_ser`. This structure is the header for a contiguous block "
"of memory containing an array of `struct luo_session_ser`, one for each "
"preserved session."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:57
msgid "Serialization Structures:"
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:58
msgid ""
"The FDT properties point to memory regions containing arrays of simple, "
"`__packed` structures. These structures contain the actual preserved state."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:61
msgid ""
"struct luo_session_header_ser: Header for the session array. Contains the "
"total page count of the preserved memory block and the number of `struct "
"luo_session_ser` entries that follow."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:66
msgid ""
"struct luo_session_ser: Metadata for a single session, including its name "
"and a physical pointer to another preserved memory block containing an array "
"of `struct luo_file_ser` for all files in that session."
msgstr ""

#: ../../../core-api/liveupdate:23: ../include/linux/kho/abi/luo.h:71
msgid ""
"struct luo_file_ser: Metadata for a single preserved file. Contains the "
"`compatible` string to find the correct handler in the new kernel, a user-"
"provided `token` for identification, and an opaque `data` handle for the "
"handler to use."
msgstr ""

#: ../../../core-api/liveupdate.rst:26
msgid "The following types of file descriptors can be preserved"
msgstr ""

#: ../../../core-api/liveupdate.rst:34
msgid "Public API"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:21
msgid "Arguments for file operation callbacks."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:25
#: ../include/linux/liveupdate.h:51 ../include/linux/liveupdate.h:83
#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:101
#: ../include/linux/kho/abi/luo.h:115 ../include/linux/kho/abi/luo.h:138
#: ../include/linux/kho/abi/luo.h:153 ../../../core-api/liveupdate:51:
#: ../kernel/liveupdate/luo_session.c:83 ../kernel/liveupdate/luo_session.c:104
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:126
msgid "**Definition**::"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:35
#: ../include/linux/liveupdate.h:65 ../include/linux/liveupdate.h:90
#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:109
#: ../include/linux/kho/abi/luo.h:122 ../include/linux/kho/abi/luo.h:144
#: ../include/linux/kho/abi/luo.h:160 ../../../core-api/liveupdate:51:
#: ../kernel/liveupdate/luo_session.c:94 ../kernel/liveupdate/luo_session.c:111
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:139
msgid "**Members**"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:22
msgid "``handler``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:23
msgid "The file handler being called."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:23
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:136
msgid "``retrieved``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:24
msgid "The retrieve status for the 'can_finish / finish' operation."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:25
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:125
msgid "``file``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:26
msgid ""
"The file object. For retrieve: [OUT] The callback sets this to the new file. "
"For other ops: [IN] The caller sets this to the file being operated on."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:28
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:128
msgid "``serialized_data``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:29
msgid "The opaque u64 handle, preserve/prepare/freeze may update this field."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:30
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:132
msgid "``private_data``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:31
msgid ""
"Private data for the file used to hold runtime state that is not preserved. "
"Set by the handler's .preserve() callback, and must be freed in the "
"handler's .unpreserve() callback."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:37
#: ../include/linux/liveupdate.h:64 ../include/linux/liveupdate.h:88
#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:104
#: ../include/linux/kho/abi/luo.h:140 ../include/linux/kho/abi/luo.h:156
#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:3
#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:3
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:148
#: ../kernel/liveupdate/luo_file.c:220 ../kernel/liveupdate/luo_file.c:326
#: ../kernel/liveupdate/luo_file.c:428 ../kernel/liveupdate/luo_file.c:504
#: ../kernel/liveupdate/luo_file.c:532 ../kernel/liveupdate/luo_file.c:636
#: ../kernel/liveupdate/luo_file.c:706 ../kernel/liveupdate/luo_file.c:866
msgid "**Description**"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:34
msgid ""
"This structure bundles all parameters for the file operation callbacks. The "
"'data' and 'file' fields are used for both input and output."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:47
msgid "Callbacks for live-updatable files."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:48
msgid "``can_preserve``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:49
msgid ""
"Required. Lightweight check to see if this handler is compatible with the "
"given file."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:50
msgid "``preserve``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:51
msgid "Required. Performs state-saving for the file."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:51
msgid "``unpreserve``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:52
msgid "Required. Cleans up any resources allocated by **preserve**."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:52
msgid "``freeze``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:53
msgid "Optional. Final actions just before kernel transition."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:53
msgid "``unfreeze``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:54
msgid "Optional. Undo freeze operations."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:54
msgid "``retrieve``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:55
msgid "Required. Restores the file in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:55
msgid "``can_finish``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:56
msgid ""
"Optional. Check if this FD can finish, i.e. all restoration pre-requirements "
"for this FD are satisfied. Called prior to finish, in order to do successful "
"finish calls for all resources in the session."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:59
msgid "``finish``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:60
msgid "Required. Final cleanup in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:60
msgid "``owner``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:61
msgid "Module reference"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:61
msgid ""
"All operations (except can_preserve) receive a pointer to a 'struct "
"liveupdate_file_op_args' containing the necessary context."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:79
msgid "Represents a handler for a live-updatable file type."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:80
msgid "``ops``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:81
msgid "Callback functions"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:81
#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:98
msgid "``compatible``"
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:82
msgid ""
"The compatibility string (e.g., \"memfd-v1\", \"vfiofd-v1\") that uniquely "
"identifies the file type this handler supports. This is matched against the "
"compatible string associated with individual :c:type:`struct file <file>` "
"instances."
msgstr ""

#: ../../../core-api/liveupdate:35: ../include/linux/liveupdate.h:85
msgid ""
"Modules that want to support live update for specific file types should "
"register an instance of this structure. LUO uses this registration to "
"determine if a given file can be preserved and to find the appropriate "
"operations to manage its state across the update."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:97
msgid "Represents the serialized preserves files."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:99
msgid "File handler compatible string."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:99
msgid "``data``"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:100
msgid "Private data"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:100
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:144
msgid "``token``"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:101
msgid "User provided token for this file"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:101
msgid "If this structure is modified, LUO_SESSION_COMPATIBLE must be updated."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:111
msgid "Represents the serialized metadata for file set"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:112
msgid "``files``"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:113
msgid ""
"The physical address of a contiguous memory block that holds the serialized "
"state of files (array of luo_file_ser) in this file set."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:115
#: ../include/linux/kho/abi/luo.h:135 ../../../core-api/liveupdate:51:
#: ../kernel/liveupdate/luo_session.c:80
msgid "``count``"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:116
msgid ""
"The total number of files that were part of this session during "
"serialization. Used for iteration and validation during restoration."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:134
msgid "Header for the serialized session data block."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:136
msgid ""
"The number of `struct luo_session_ser` entries that immediately follow this "
"header in the memory block."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:137
msgid ""
"This structure is located at the beginning of a contiguous block of physical "
"memory preserved across the kexec. It provides the necessary metadata to "
"interpret the array of session entries that follow."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:141
#: ../include/linux/kho/abi/luo.h:158
msgid ""
"If this structure is modified, `LUO_FDT_SESSION_COMPATIBLE` must be updated."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:149
msgid "Represents the serialized metadata for a LUO session."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:150
msgid "``name``"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:151
msgid ""
"The unique name of the session, provided by the userspace at the time of "
"session creation."
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:152
msgid "``file_set_ser``"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:153
msgid "Serialized files belonging to this session,"
msgstr ""

#: ../../../core-api/liveupdate:37: ../include/linux/kho/abi/luo.h:153
msgid ""
"This structure is used to package session-specific metadata for transfer "
"between kernels via Kexec Handover. An array of these structures (one per "
"session) is created and passed to the new kernel, allowing it to reconstruct "
"the session context."
msgstr ""

#: ../../../core-api/liveupdate.rst:47
msgid "Internal API"
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:209
msgid "Kernel reboot notifier for live update final serialization."
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:213
#: ../kernel/liveupdate/luo_core.c:247 ../../../core-api/liveupdate:51:
#: ../kernel/liveupdate/luo_session.c:609
#: ../kernel/liveupdate/luo_session.c:641 ../../../core-api/liveupdate:54:
#: ../kernel/liveupdate/luo_file.c:219 ../kernel/liveupdate/luo_file.c:327
#: ../kernel/liveupdate/luo_file.c:428 ../kernel/liveupdate/luo_file.c:504
#: ../kernel/liveupdate/luo_file.c:530 ../kernel/liveupdate/luo_file.c:637
#: ../kernel/liveupdate/luo_file.c:706 ../kernel/liveupdate/luo_file.c:806
#: ../kernel/liveupdate/luo_file.c:867
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:215
#: ../kernel/liveupdate/luo_core.c:249 ../../../core-api/liveupdate:51:
#: ../kernel/liveupdate/luo_session.c:611
#: ../kernel/liveupdate/luo_session.c:643
msgid "``void``"
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:1
#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:1
msgid "no arguments"
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:210
msgid ""
"This function is invoked directly from the reboot() syscall pathway if kexec "
"is in progress."
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:213
msgid ""
"If any callback fails, this function aborts KHO, undoes the freeze() "
"callbacks, and returns an error."
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:243
msgid "Check if the live update feature is enabled."
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:244
msgid ""
"This function returns the state of the live update feature flag, which can "
"be controlled via the ``liveupdate`` kernel command-line parameter."
msgstr ""

#: ../../../core-api/liveupdate:48: ../kernel/liveupdate/luo_core.c:247
msgid "**return** true if live update is enabled, false otherwise."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:79
msgid "Header struct for managing LUO sessions."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:81
msgid "The number of sessions currently tracked in the **list**."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:81
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:142
msgid "``list``"
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:82
msgid "The head of the linked list of `struct luo_session` instances."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:82
msgid "``rwsem``"
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:83
msgid ""
"A read-write semaphore providing synchronized access to the session list and "
"other fields in this structure."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:84
msgid "``header_ser``"
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:85
msgid "The header data of serialization array."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:85
msgid "``ser``"
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:86
msgid "The serialized session data (an array of `struct luo_session_ser`)."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:87
msgid "``active``"
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:88
msgid ""
"Set to true when first initialized. If previous kernel did not send session "
"data, active stays false for incoming."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:100
msgid "Global container for managing LUO sessions."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:101
msgid "``incoming``"
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:102
msgid "The sessions passed from the previous kernel."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:102
msgid "``outgoing``"
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:103
msgid "The sessions that are going to be passed to the next kernel."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:605
msgid "Ensure no active sessions exist and lock session lists."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:606
msgid ""
"Acquires exclusive write locks on both incoming and outgoing session lists. "
"It then validates no sessions exist in either list."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:609
msgid ""
"This mechanism is used during file handler un/registration to ensure that no "
"sessions are currently using the handler, and no new sessions can be created "
"while un/registration is in progress."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:613
msgid ""
"This prevents registering new handlers while sessions are active or while "
"deserialization is in progress."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:616
#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:246
#: ../kernel/liveupdate/luo_file.c:455 ../kernel/liveupdate/luo_file.c:547
#: ../kernel/liveupdate/luo_file.c:663 ../kernel/liveupdate/luo_file.c:811
#: ../kernel/liveupdate/luo_file.c:873
msgid "**Return**"
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:617
msgid ""
"true  - System is quiescent (0 sessions) and locked. false - Active sessions "
"exist. The locks are released internally."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:637
msgid "Unlock session lists and resume normal activity."
msgstr ""

#: ../../../core-api/liveupdate:51: ../kernel/liveupdate/luo_session.c:638
msgid ""
"Releases the exclusive locks acquired by a successful call to "
"luo_session_quiesce()."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:122
msgid "Represents a single preserved file instance."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:123
msgid "``fh``"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:124
msgid ""
"Pointer to the :c:type:`struct liveupdate_file_handler "
"<liveupdate_file_handler>` that manages this type of file."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:126
msgid ""
"Pointer to the kernel's :c:type:`struct file <file>` that is being "
"preserved. This is NULL in the new kernel until the file is successfully "
"retrieved."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:129
msgid ""
"The opaque u64 handle to the serialized state of the file. This handle is "
"passed back to the handler's .freeze(), .retrieve(), and .finish() "
"callbacks, allowing it to track and update its serialized state across "
"phases."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:133
msgid ""
"Pointer to the private data for the file used to hold runtime state that is "
"not preserved. Set by the handler's .preserve() callback, and must be freed "
"in the handler's .unpreserve() callback."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:137
msgid ""
"A flag indicating whether a user/kernel in the new kernel has successfully "
"called retrieve() on this file. This prevents multiple retrieval attempts."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:139
msgid "``mutex``"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:140
msgid ""
"A mutex that protects the fields of this specific instance (e.g., "
"**retrieved**, **file**), ensuring that operations like retrieving or "
"finishing a file are atomic."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:143
msgid ""
"The list_head linking this instance into its parent file_set's list of "
"preserved files."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:145
msgid "The user-provided unique token used to identify this file."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:145
msgid ""
"This structure is the core in-kernel representation of a single file being "
"managed through a live update. An instance is created by luo_preserve_file() "
"to link a 'struct file' to its corresponding handler, a user-provided token, "
"and the serialized state handle returned by the handler's .preserve() "
"operation."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:151
msgid ""
"These instances are tracked in a per-file_set list. The **serialized_data** "
"field, which holds a handle to the file's serialized state, may be updated "
"during the .freeze() callback before being serialized for the next kernel. "
"After reboot, these structures are recreated by luo_file_deserialize() and "
"are finally cleaned up by luo_file_finish()."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:215
msgid "Initiate the preservation of a file descriptor."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:221
#: ../kernel/liveupdate/luo_file.c:329 ../kernel/liveupdate/luo_file.c:430
#: ../kernel/liveupdate/luo_file.c:506 ../kernel/liveupdate/luo_file.c:532
#: ../kernel/liveupdate/luo_file.c:639 ../kernel/liveupdate/luo_file.c:708
msgid "``struct luo_file_set *file_set``"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:216
msgid "The file_set to which the preserved file will be added."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:218
#: ../kernel/liveupdate/luo_file.c:529
msgid "``u64 token``"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:217
msgid "A unique, user-provided identifier for the file."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:219
msgid "``int fd``"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:218
msgid "The file descriptor to be preserved."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:219
msgid ""
"This function orchestrates the first phase of preserving a file. Upon entry, "
"it takes a reference to the 'struct file' via fget(), effectively making LUO "
"a co-owner of the file. This reference is held until the file is either "
"unpreserved or successfully finished in the next kernel, preventing the file "
"from being prematurely destroyed."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:225
msgid ""
"This function orchestrates the first phase of preserving a file. It performs "
"the following steps:"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:228
msgid "Validates that the **token** is not already in use within the file_set."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:229
msgid ""
"Ensures the file_set's memory for files serialization is allocated "
"(allocates if needed)."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:231
msgid ""
"Iterates through registered handlers, calling can_preserve() to find one "
"compatible with the given **fd**."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:233
msgid ""
"Calls the handler's .preserve() operation, which saves the file's state and "
"returns an opaque private data handle."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:235
msgid "Adds the new instance to the file_set's internal list."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:237
msgid ""
"On success, LUO takes a reference to the 'struct file' and considers it "
"under its management until it is unpreserved or finished."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:240
msgid ""
"In case of any failure, all intermediate allocations (file reference, memory "
"for the 'luo_file' struct, etc.) are cleaned up before returning an error."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:243
#: ../kernel/liveupdate/luo_file.c:452 ../kernel/liveupdate/luo_file.c:511
#: ../kernel/liveupdate/luo_file.c:543 ../kernel/liveupdate/luo_file.c:660
#: ../kernel/liveupdate/luo_file.c:723 ../kernel/liveupdate/luo_file.c:808
msgid "**Context**"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:244
msgid "Can be called from an ioctl handler during normal system operation."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:245
msgid ""
"0 on success. Returns a negative errno on failure: -EEXIST if the token is "
"already used. -EBADF if the file descriptor is invalid. -ENOSPC if the "
"file_set is full. -ENOENT if no compatible handler is found. -ENOMEM on "
"memory allocation failure. Other erros might be returned by .preserve()."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:323
msgid "Unpreserves all files from a file_set."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:324
msgid "The files to be cleaned up."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:325
msgid ""
"This function serves as the primary cleanup path for a file_set. It is "
"invoked when the userspace agent closes the file_set's file descriptor."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:328
msgid "For each file, it performs the following cleanup actions:"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:329
msgid ""
"Calls the handler's .unpreserve() callback to allow the handler to release "
"any resources it allocated."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:331
msgid "Removes the file from the file_set's internal tracking list."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:332
msgid ""
"Releases the reference to the 'struct file' that was taken by "
"luo_preserve_file() via fput(), returning ownership."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:334
msgid "Frees the memory associated with the internal 'struct luo_file'."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:336
msgid ""
"After all individual files are unpreserved, it frees the contiguous memory "
"block that was allocated to hold their serialization data."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:424
msgid "Freezes all preserved files and serializes their metadata."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:425
msgid "The file_set whose files are to be frozen."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:427
#: ../kernel/liveupdate/luo_file.c:503 ../kernel/liveupdate/luo_file.c:705
msgid "``struct luo_file_set_ser *file_set_ser``"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:426
msgid "Where to put the serialized file_set."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:427
msgid ""
"This function is called from the reboot() syscall path, just before the "
"kernel transitions to the new image via kexec. Its purpose is to perform the "
"final preparation and serialization of all preserved files in the file_set."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:431
msgid ""
"It iterates through each preserved file in FIFO order (the order of "
"preservation) and performs two main actions:"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:434
msgid ""
"Freezes the File: It calls the handler's .freeze() callback for each file. "
"This gives the handler a final opportunity to quiesce the device or prepare "
"its state for the upcoming reboot. The handler may update its private data "
"handle during this step."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:439
msgid ""
"Serializes Metadata: After a successful freeze, it copies the final file "
"metadata—the handler's compatible string, the user token, and the final "
"private data handle—into the pre-allocated contiguous memory buffer "
"(file_set->files) that will be handed over to the next kernel via KHO."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:444
msgid ""
"Error Handling (Rollback): This function is atomic. If any handler's ."
"freeze() operation fails, the entire live update is aborted. The "
"__luo_file_unfreeze() helper is immediately called to invoke the .unfreeze() "
"op on all files that were successfully frozen before the point of failure, "
"rolling them back to a running state. The function then returns an error, "
"causing the reboot() syscall to fail."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:453
msgid "Called only from the liveupdate_reboot() path."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:454
#: ../kernel/liveupdate/luo_file.c:662
msgid "0 on success, or a negative errno on failure."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:500
msgid "Unfreezes all files in a file_set and clear serialization"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:501
msgid "The file_set whose files are to be unfrozen."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:502
msgid "Serialized file_set."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:503
msgid ""
"This function rolls back the state of all files in a file_set after the "
"freeze phase has begun but must be aborted. It is the counterpart to "
"luo_file_freeze()."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:507
msgid ""
"It invokes the __luo_file_unfreeze() helper with a NULL argument, which "
"signals the helper to iterate through all files in the file_set and call "
"their respective .unfreeze() handler callbacks."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:512
msgid ""
"This is called when the live update is aborted during the reboot() syscall, "
"after luo_file_freeze() has been called."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:526
msgid "Restores a preserved file from a file_set by its token."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:527
msgid "The file_set from which to retrieve the file."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:528
msgid "The unique token identifying the file to be restored."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:530
msgid "``struct file **filep``"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:529
msgid ""
"Output parameter; on success, this is populated with a pointer to the newly "
"retrieved 'struct file'."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:531
msgid ""
"This function is the primary mechanism for recreating a file in the new "
"kernel after a live update. It searches the file_set's list of deserialized "
"files for an entry matching the provided **token**."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:535
msgid ""
"The operation is idempotent: if a file has already been successfully "
"retrieved, this function will simply return a pointer to the existing "
"'struct file' and report success without re-executing the retrieve "
"operation. This is handled by checking the 'retrieved' flag under a lock."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:540
msgid ""
"File retrieval can happen in any order; it is not bound by the order of "
"preservation."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:544
msgid "Can be called from an ioctl or other in-kernel code in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:546
msgid ""
"0 on success. Returns a negative errno on failure: -ENOENT if no file with "
"the matching token is found. Any error code returned by the handler's ."
"retrieve() op."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:633
msgid "Completes the lifecycle for all files in a file_set."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:634
msgid "The file_set to be finalized."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:635
msgid ""
"This function orchestrates the final teardown of a live update file_set in "
"the new kernel. It should be called after all necessary files have been "
"retrieved and the userspace agent is ready to release the preserved state."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:639
msgid ""
"The function iterates through all tracked files. For each file, it performs "
"the following sequence of cleanup actions:"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:642
msgid ""
"If file is not yet retrieved, retrieves it, and calls can_finish() on every "
"file in the file_set. If all can_finish return true, continue to finish."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:645
msgid ""
"Calls the handler's .finish() callback (via luo_file_finish_one) to allow "
"for final resource cleanup within the handler."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:647
msgid ""
"Releases LUO's ownership reference on the 'struct file' via fput(). This is "
"the counterpart to the get_file() call in luo_retrieve_file()."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:649
msgid "Removes the 'struct luo_file' from the file_set's internal list."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:650
msgid "Frees the memory for the 'struct luo_file' instance itself."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:652
msgid ""
"After successfully finishing all individual files, it frees the contiguous "
"memory block that was used to transfer the serialized metadata from the "
"previous kernel."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:656
msgid ""
"Error Handling (Atomic Failure): This operation is atomic. If any handler's ."
"can_finish() op fails, the entire function aborts immediately and returns an "
"error."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:661
msgid "Can be called from an ioctl handler in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:702
msgid "Reconstructs the list of preserved files in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:703
msgid "The incoming file_set to fill with deserialized data."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:704
msgid "Serialized KHO file_set data from the previous kernel."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:705
msgid ""
"This function is called during the early boot process of the new kernel. It "
"takes the raw, contiguous memory block of 'struct luo_file_ser' entries, "
"provided by the previous kernel, and transforms it back into a live, in-"
"memory linked list of 'struct luo_file' instances."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:710
msgid "For each serialized entry, it performs the following steps:"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:711
msgid "Reads the 'compatible' string."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:712
msgid ""
"Searches the global list of registered file handlers for one that matches "
"the compatible string."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:714
msgid "Allocates a new 'struct luo_file'."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:715
msgid ""
"Populates the new structure with the deserialized data (token, private data "
"handle) and links it to the found handler. The 'file' pointer is initialized "
"to NULL, as the file has not been retrieved yet."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:718
msgid "Adds the new 'struct luo_file' to the file_set's files_list."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:720
msgid ""
"This prepares the file_set for userspace, which can later call "
"luo_retrieve_file() to restore the actual file descriptors."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:724
msgid "Called from session deserialization."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:802
msgid "Register a file handler with LUO."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:808
#: ../kernel/liveupdate/luo_file.c:869
msgid "``struct liveupdate_file_handler *fh``"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:803
msgid ""
"Pointer to a caller-allocated :c:type:`struct liveupdate_file_handler "
"<liveupdate_file_handler>`. The caller must initialize this structure, "
"including a unique 'compatible' string and a valid 'fh' callbacks. This "
"function adds the handler to the global list of supported file handlers."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:808
msgid ""
"Typically called during module initialization for file types that support "
"live update preservation."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:811
msgid "0 on success. Negative errno on failure."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:863
msgid "Unregister a liveupdate file handler"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:864
msgid "The file handler to unregister"
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:865
msgid ""
"Unregisters the file handler from the liveupdate core. This function "
"reverses the operations of liveupdate_register_file_handler()."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:868
msgid ""
"It ensures safe removal by checking that: No live update session is "
"currently in progress."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:871
msgid "If the unregistration fails, the internal test state is reverted."
msgstr ""

#: ../../../core-api/liveupdate:54: ../kernel/liveupdate/luo_file.c:874
msgid ""
"0 Success. -EOPNOTSUPP when live update is not enabled. -EBUSY A live update "
"is in progress, can't quiesce live update."
msgstr ""

#: ../../../core-api/liveupdate.rst:58
msgid "See Also"
msgstr ""

#: ../../../core-api/liveupdate.rst:60
msgid ":doc:`Live Update uAPI </userspace-api/liveupdate>`"
msgstr ""

#: ../../../core-api/liveupdate.rst:61
msgid ":doc:`/core-api/kho/concepts`"
msgstr ""
