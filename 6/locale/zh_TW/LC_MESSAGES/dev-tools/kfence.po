# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../dev-tools/kfence.rst:5
msgid "Kernel Electric-Fence (KFENCE)"
msgstr ""

#: ../../../dev-tools/kfence.rst:7
msgid ""
"Kernel Electric-Fence (KFENCE) is a low-overhead sampling-based memory "
"safety error detector. KFENCE detects heap out-of-bounds access, use-after-"
"free, and invalid-free errors."
msgstr ""

#: ../../../dev-tools/kfence.rst:11
msgid ""
"KFENCE is designed to be enabled in production kernels, and has near zero "
"performance overhead. Compared to KASAN, KFENCE trades performance for "
"precision. The main motivation behind KFENCE's design, is that with enough "
"total uptime KFENCE will detect bugs in code paths not typically exercised "
"by non-production test workloads. One way to quickly achieve a large enough "
"total uptime is when the tool is deployed across a large fleet of machines."
msgstr ""

#: ../../../dev-tools/kfence.rst:19
msgid "Usage"
msgstr ""

#: ../../../dev-tools/kfence.rst:21
msgid "To enable KFENCE, configure the kernel with::"
msgstr ""

#: ../../../dev-tools/kfence.rst:25
msgid ""
"To build a kernel with KFENCE support, but disabled by default (to enable, "
"set ``kfence.sample_interval`` to non-zero value), configure the kernel "
"with::"
msgstr ""

#: ../../../dev-tools/kfence.rst:31
msgid ""
"KFENCE provides several other configuration options to customize behaviour "
"(see the respective help text in ``lib/Kconfig.kfence`` for more info)."
msgstr ""

#: ../../../dev-tools/kfence.rst:35
msgid "Tuning performance"
msgstr ""

#: ../../../dev-tools/kfence.rst:37
msgid ""
"The most important parameter is KFENCE's sample interval, which can be set "
"via the kernel boot parameter ``kfence.sample_interval`` in milliseconds. "
"The sample interval determines the frequency with which heap allocations "
"will be guarded by KFENCE. The default is configurable via the Kconfig "
"option ``CONFIG_KFENCE_SAMPLE_INTERVAL``. Setting ``kfence."
"sample_interval=0`` disables KFENCE."
msgstr ""

#: ../../../dev-tools/kfence.rst:44
msgid ""
"The sample interval controls a timer that sets up KFENCE allocations. By "
"default, to keep the real sample interval predictable, the normal timer also "
"causes CPU wake-ups when the system is completely idle. This may be "
"undesirable on power-constrained systems. The boot parameter ``kfence."
"deferrable=1`` instead switches to a \"deferrable\" timer which does not "
"force CPU wake-ups on idle systems, at the risk of unpredictable sample "
"intervals. The default is configurable via the Kconfig option "
"``CONFIG_KFENCE_DEFERRABLE``."
msgstr ""

#: ../../../dev-tools/kfence.rst:53
msgid ""
"The KUnit test suite is very likely to fail when using a deferrable timer "
"since it currently causes very unpredictable sample intervals."
msgstr ""

#: ../../../dev-tools/kfence.rst:56
msgid ""
"By default KFENCE will only sample 1 heap allocation within each sample "
"interval. *Burst mode* allows to sample successive heap allocations, where "
"the kernel boot parameter ``kfence.burst`` can be set to a non-zero value "
"which denotes the *additional* successive allocations within a sample "
"interval; setting ``kfence.burst=N`` means that ``1 + N`` successive "
"allocations are attempted through KFENCE for each sample interval."
msgstr ""

#: ../../../dev-tools/kfence.rst:63
msgid ""
"The KFENCE memory pool is of fixed size, and if the pool is exhausted, no "
"further KFENCE allocations occur. With ``CONFIG_KFENCE_NUM_OBJECTS`` "
"(default 255), the number of available guarded objects can be controlled. "
"Each object requires 2 pages, one for the object itself and the other one "
"used as a guard page; object pages are interleaved with guard pages, and "
"every object page is therefore surrounded by two guard pages."
msgstr ""

#: ../../../dev-tools/kfence.rst:70
msgid ""
"The total memory dedicated to the KFENCE memory pool can be computed as::"
msgstr ""

#: ../../../dev-tools/kfence.rst:74
msgid ""
"Using the default config, and assuming a page size of 4 KiB, results in "
"dedicating 2 MiB to the KFENCE memory pool."
msgstr ""

#: ../../../dev-tools/kfence.rst:77
msgid ""
"Note: On architectures that support huge pages, KFENCE will ensure that the "
"pool is using pages of size ``PAGE_SIZE``. This will result in additional "
"page tables being allocated."
msgstr ""

#: ../../../dev-tools/kfence.rst:82
msgid "Error reports"
msgstr ""

#: ../../../dev-tools/kfence.rst:84
msgid "A typical out-of-bounds access looks like this::"
msgstr ""

#: ../../../dev-tools/kfence.rst:110
msgid ""
"The header of the report provides a short summary of the function involved "
"in the access. It is followed by more detailed information about the access "
"and its origin. Note that, real kernel addresses are only shown when using "
"the kernel command line option ``no_hash_pointers``."
msgstr ""

#: ../../../dev-tools/kfence.rst:115
msgid "Use-after-free accesses are reported as::"
msgstr ""

#: ../../../dev-tools/kfence.rst:148
msgid "KFENCE also reports on invalid frees, such as double-frees::"
msgstr ""

#: ../../../dev-tools/kfence.rst:181
msgid ""
"KFENCE also uses pattern-based redzones on the other side of an object's "
"guard page, to detect out-of-bounds writes on the unprotected side of the "
"object. These are reported on frees::"
msgstr ""

#: ../../../dev-tools/kfence.rst:209
msgid ""
"For such errors, the address where the corruption occurred as well as the "
"invalidly written bytes (offset from the address) are shown; in this "
"representation, '.' denote untouched bytes. In the example above ``0xac`` is "
"the value written to the invalid address at offset 0, and the remaining '.' "
"denote that no following bytes have been touched. Note that, real values are "
"only shown if the kernel was booted with ``no_hash_pointers``; to avoid "
"information disclosure otherwise, '!' is used instead to denote invalidly "
"written bytes."
msgstr ""

#: ../../../dev-tools/kfence.rst:218
msgid ""
"And finally, KFENCE may also report on invalid accesses to any protected "
"page where it was not possible to determine an associated object, e.g. if "
"adjacent object pages had not yet been allocated::"
msgstr ""

#: ../../../dev-tools/kfence.rst:237
msgid "DebugFS interface"
msgstr ""

#: ../../../dev-tools/kfence.rst:239
msgid "Some debugging information is exposed via debugfs:"
msgstr ""

#: ../../../dev-tools/kfence.rst:241
msgid ""
"The file ``/sys/kernel/debug/kfence/stats`` provides runtime statistics."
msgstr ""

#: ../../../dev-tools/kfence.rst:243
msgid ""
"The file ``/sys/kernel/debug/kfence/objects`` provides a list of objects "
"allocated via KFENCE, including those already freed but protected."
msgstr ""

#: ../../../dev-tools/kfence.rst:247
msgid "Implementation Details"
msgstr ""

#: ../../../dev-tools/kfence.rst:249
msgid ""
"Guarded allocations are set up based on the sample interval. After "
"expiration of the sample interval, the next allocation through the main "
"allocator (SLAB or SLUB) returns a guarded allocation from the KFENCE object "
"pool (allocation sizes up to PAGE_SIZE are supported). At this point, the "
"timer is reset, and the next allocation is set up after the expiration of "
"the interval."
msgstr ""

#: ../../../dev-tools/kfence.rst:255
msgid ""
"When using ``CONFIG_KFENCE_STATIC_KEYS=y``, KFENCE allocations are \"gated\" "
"through the main allocator's fast-path by relying on static branches via the "
"static keys infrastructure. The static branch is toggled to redirect the "
"allocation to KFENCE. Depending on sample interval, target workloads, and "
"system architecture, this may perform better than the simple dynamic branch. "
"Careful benchmarking is recommended."
msgstr ""

#: ../../../dev-tools/kfence.rst:262
msgid ""
"KFENCE objects each reside on a dedicated page, at either the left or right "
"page boundaries selected at random. The pages to the left and right of the "
"object page are \"guard pages\", whose attributes are changed to a protected "
"state, and cause page faults on any attempted access. Such page faults are "
"then intercepted by KFENCE, which handles the fault gracefully by reporting "
"an out-of-bounds access, and marking the page as accessible so that the "
"faulting code can (wrongly) continue executing (set ``panic_on_warn`` to "
"panic instead)."
msgstr ""

#: ../../../dev-tools/kfence.rst:270
msgid ""
"To detect out-of-bounds writes to memory within the object's page itself, "
"KFENCE also uses pattern-based redzones. For each object page, a redzone is "
"set up for all non-object memory. For typical alignments, the redzone is "
"only required on the unguarded side of an object. Because KFENCE must honor "
"the cache's requested alignment, special alignments may result in "
"unprotected gaps on either side of an object, all of which are redzoned."
msgstr ""

#: ../../../dev-tools/kfence.rst:277
msgid "The following figure illustrates the page layout::"
msgstr ""

#: ../../../dev-tools/kfence.rst:288
msgid ""
"Upon deallocation of a KFENCE object, the object's page is again protected "
"and the object is marked as freed. Any further access to the object causes a "
"fault and KFENCE reports a use-after-free access. Freed objects are inserted "
"at the tail of KFENCE's freelist, so that the least recently freed objects "
"are reused first, and the chances of detecting use-after-frees of recently "
"freed objects is increased."
msgstr ""

#: ../../../dev-tools/kfence.rst:295
msgid ""
"If pool utilization reaches 75% (default) or above, to reduce the risk of "
"the pool eventually being fully occupied by allocated objects yet ensure "
"diverse coverage of allocations, KFENCE limits currently covered allocations "
"of the same source from further filling up the pool. The \"source\" of an "
"allocation is based on its partial allocation stack trace. A side-effect is "
"that this also limits frequent long-lived allocations (e.g. pagecache) of "
"the same source filling up the pool permanently, which is the most common "
"risk for the pool becoming full and the sampled allocation rate dropping to "
"zero. The threshold at which to start limiting currently covered allocations "
"can be configured via the boot parameter ``kfence.skip_covered_thresh`` "
"(pool usage%)."
msgstr ""

#: ../../../dev-tools/kfence.rst:307
msgid "Interface"
msgstr ""

#: ../../../dev-tools/kfence.rst:309
msgid ""
"The following describes the functions which are used by allocators as well "
"as page handling code to set up and deal with KFENCE allocations."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:34
msgid "check if an address belongs to KFENCE pool"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:38
#: include/linux/kfence.h:80 include/linux/kfence.h:107
#: include/linux/kfence.h:137 include/linux/kfence.h:151
#: include/linux/kfence.h:165 include/linux/kfence.h:175
#: include/linux/kfence.h:196
msgid "**Parameters**"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:40
#: include/linux/kfence.h:139 include/linux/kfence.h:153
msgid "``const void *addr``"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:35
msgid "address to check"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:37
#: include/linux/kfence.h:109 include/linux/kfence.h:136
#: include/linux/kfence.h:150 include/linux/kfence.h:174
#: include/linux/kfence.h:197
msgid "**Return**"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:37
msgid ""
"true or false depending on whether the address is within the KFENCE object "
"range."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:40
#: include/linux/kfence.h:79 include/linux/kfence.h:112
#: include/linux/kfence.h:139 include/linux/kfence.h:152
#: include/linux/kfence.h:164 include/linux/kfence.h:177
#: include/linux/kfence.h:200
msgid "**Description**"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:39
msgid ""
"KFENCE objects live in a separate page range and are not to be intermixed "
"with regular heap objects (e.g. KFENCE objects must never be added to the "
"allocator freelists). Failing to do so may and will result in heap "
"corruptions, therefore is_kfence_address() must be used to check whether an "
"object requires specific handling."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:45
msgid "**Note**"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:46
msgid ""
"This function may be used in fast-paths, and is performance critical. Future "
"changes should take this into account; for instance, we want to avoid "
"introducing another load and therefore need to keep KFENCE_POOL_SIZE a "
"constant (until immediate patching support is added to the kernel)."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:76
msgid "handle shutdown_cache() for KFENCE objects"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:82
#: include/linux/kfence.h:109
msgid "``struct kmem_cache *s``"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:77
msgid "cache being shut down"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:78
msgid ""
"Before shutting down a cache, one must ensure there are no remaining objects "
"allocated from it. Because KFENCE objects are not referenced from the cache "
"directly, we need to check them here."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:82
msgid ""
"Note that shutdown_cache() is internal to SL*B, and kmem_cache_destroy() "
"does not return if allocated objects still exist: it prints an error message "
"and simply aborts destruction of a cache, leaking memory."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:86
msgid ""
"If the only such objects are KFENCE objects, we will not leak the entire "
"cache, but instead try to provide more useful debug info by making allocated "
"objects \"zombie allocations\". Objects may then still be used or freed "
"(which is handled gracefully), but usage will result in showing KFENCE error "
"reports which include stack traces to the user of the object, the original "
"allocation site, and caller to shutdown_cache()."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:103
msgid "allocate a KFENCE object with a low probability"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:104
msgid "struct kmem_cache with object requirements"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:106
msgid "``size_t size``"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:105
msgid ""
"exact size of the object to allocate (can be less than **s->size** e.g. for "
"kmalloc caches)"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:108
msgid "``gfp_t flags``"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:107
msgid "GFP flags"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:109
msgid "NULL     - must proceed with allocating as usual,"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:110
msgid "non-NULL - pointer to a KFENCE object."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:112
msgid ""
"kfence_alloc() should be inserted into the heap allocation fast path, "
"allowing it to transparently return KFENCE-allocated objects with a low "
"probability using a static branch (the probability is controlled by the "
"kfence.sample_interval boot parameter)."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:133
msgid "get actual amount of memory allocated for a KFENCE object"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:134
msgid "pointer to a heap object"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:136
msgid "0     - not a KFENCE object, must call __ksize() instead,"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:137
msgid "non-0 - this many bytes can be accessed without causing a memory error."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:139
msgid ""
"kfence_ksize() returns the number of bytes requested for a KFENCE object at "
"allocation time. This number may be less than the object size of the "
"corresponding struct kmem_cache."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:147
msgid "find the beginning of a KFENCE object"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:148
msgid "address within a KFENCE-allocated object"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:150
msgid "address of the beginning of the object."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:151
msgid ""
"SL[AU]B-allocated objects are laid out within a page one by one, so it is "
"easy to calculate the beginning of an object given a pointer inside it and "
"the object size. The same is not true for KFENCE, which places a single "
"object at either end of the page. This helper function is used to find the "
"beginning of a KFENCE-allocated object."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:161
msgid "release a KFENCE heap object to KFENCE pool"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:167
#: include/linux/kfence.h:177
msgid "``void *addr``"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:162
#: include/linux/kfence.h:172
msgid "object to be freed"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:163
msgid "Requires: is_kfence_address(addr)"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:165
msgid "Release a KFENCE object and mark it as freed."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:171
msgid "try to release an arbitrary heap object to KFENCE pool"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:174
msgid "false - object doesn't belong to KFENCE pool and was ignored,"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:175
msgid "true  - object was released to KFENCE pool."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:177
msgid ""
"Release a KFENCE object and mark it as freed. May be called on any object, "
"even non-KFENCE objects, to simplify integration of the hooks into the "
"allocator's free codepath. The allocator must check the return value to "
"determine if it was a KFENCE object or not."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:192
msgid "perform page fault handling for KFENCE pages"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:198
msgid "``unsigned long addr``"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:193
msgid "faulting address"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:195
msgid "``bool is_write``"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:194
msgid "is access a write"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:196
msgid "``struct pt_regs *regs``"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:195
msgid "current struct pt_regs (can be NULL, but shows full stack trace)"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:197
msgid "false - address outside KFENCE pool,"
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:198
msgid "true  - page fault handled by KFENCE, no additional handling required."
msgstr ""

#: ../../../dev-tools/kfence:312: include/linux/kfence.h:200
msgid ""
"A page fault inside KFENCE pool indicates a memory error, such as an out-of-"
"bounds access, a use-after-free or an invalid memory access. In these cases "
"KFENCE prints an error message and marks the offending page as present, so "
"that the kernel can proceed."
msgstr ""

#: ../../../dev-tools/kfence.rst:320
msgid "Related Tools"
msgstr ""

#: ../../../dev-tools/kfence.rst:322
msgid ""
"In userspace, a similar approach is taken by `GWP-ASan <http://llvm.org/docs/"
"GwpAsan.html>`_. GWP-ASan also relies on guard pages and a sampling strategy "
"to detect memory unsafety bugs at scale. KFENCE's design is directly "
"influenced by GWP-ASan, and can be seen as its kernel sibling. Another "
"similar but non-sampling approach, that also inspired the name \"KFENCE\", "
"can be found in the userspace `Electric Fence Malloc Debugger <https://linux."
"die.net/man/3/efence>`_."
msgstr ""

#: ../../../dev-tools/kfence.rst:330
msgid ""
"In the kernel, several tools exist to debug memory access errors, and in "
"particular KASAN can detect all bug classes that KFENCE can detect. While "
"KASAN is more precise, relying on compiler instrumentation, this comes at a "
"performance cost."
msgstr ""

#: ../../../dev-tools/kfence.rst:335
msgid ""
"It is worth highlighting that KASAN and KFENCE are complementary, with "
"different target environments. For instance, KASAN is the better debugging-"
"aid, where test cases or reproducers exists: due to the lower chance to "
"detect the error, it would require more effort using KFENCE to debug. "
"Deployments at scale that cannot afford to enable KASAN, however, would "
"benefit from using KFENCE to discover bugs due to code paths not exercised "
"by test cases or fuzzers."
msgstr ""
