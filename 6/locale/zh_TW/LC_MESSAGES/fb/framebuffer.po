# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../fb/framebuffer.rst:3
msgid "The Frame Buffer Device"
msgstr ""

#: ../../../fb/framebuffer.rst:5
msgid "Last revised: May 10, 2001"
msgstr ""

#: ../../../fb/framebuffer.rst:9
msgid "0. Introduction"
msgstr ""

#: ../../../fb/framebuffer.rst:11
msgid ""
"The frame buffer device provides an abstraction for the graphics hardware. "
"It represents the frame buffer of some video hardware and allows application "
"software to access the graphics hardware through a well-defined interface, "
"so the software doesn't need to know anything about the low-level (hardware "
"register) stuff."
msgstr ""

#: ../../../fb/framebuffer.rst:17
msgid ""
"The device is accessed through special device nodes, usually located in the /"
"dev directory, i.e. /dev/fb*."
msgstr ""

#: ../../../fb/framebuffer.rst:22
msgid "1. User's View of /dev/fb*"
msgstr ""

#: ../../../fb/framebuffer.rst:24
msgid ""
"From the user's point of view, the frame buffer device looks just like any "
"other device in /dev. It's a character device using major 29; the minor "
"specifies the frame buffer number."
msgstr ""

#: ../../../fb/framebuffer.rst:28
msgid ""
"By convention, the following device nodes are used (numbers indicate the "
"device minor numbers)::"
msgstr ""

#: ../../../fb/framebuffer.rst:36
msgid ""
"For backwards compatibility, you may want to create the following symbolic "
"links::"
msgstr ""

#: ../../../fb/framebuffer.rst:42
msgid "and so on..."
msgstr ""

#: ../../../fb/framebuffer.rst:44
msgid ""
"The frame buffer devices are also `normal` memory devices, this means, you "
"can read and write their contents. You can, for example, make a screen "
"snapshot by::"
msgstr ""

#: ../../../fb/framebuffer.rst:49
msgid ""
"There also can be more than one frame buffer at a time, e.g. if you have a "
"graphics card in addition to the built-in hardware. The corresponding frame "
"buffer devices (/dev/fb0 and /dev/fb1 etc.) work independently."
msgstr ""

#: ../../../fb/framebuffer.rst:53
msgid ""
"Application software that uses the frame buffer device (e.g. the X server) "
"will use /dev/fb0 by default (older software uses /dev/fb0current). You can "
"specify an alternative frame buffer device by setting the environment "
"variable $FRAMEBUFFER to the path name of a frame buffer device, e.g. (for "
"sh/bash users)::"
msgstr ""

#: ../../../fb/framebuffer.rst:61
msgid "or (for csh users)::"
msgstr ""

#: ../../../fb/framebuffer.rst:65
msgid "After this the X server will use the second frame buffer."
msgstr ""

#: ../../../fb/framebuffer.rst:69
msgid "2. Programmer's View of /dev/fb*"
msgstr ""

#: ../../../fb/framebuffer.rst:71
msgid ""
"As you already know, a frame buffer device is a memory device like /dev/mem "
"and it has the same features. You can read it, write it, seek to some "
"location in it and mmap() it (the main usage). The difference is just that "
"the memory that appears in the special file is not the whole memory, but the "
"frame buffer of some video hardware."
msgstr ""

#: ../../../fb/framebuffer.rst:77
msgid ""
"/dev/fb* also allows several ioctls on it, by which lots of information "
"about the hardware can be queried and set. The color map handling works via "
"ioctls, too. Look into <linux/fb.h> for more information on what ioctls "
"exist and on which data structures they work. Here's just a brief overview:"
msgstr ""

#: ../../../fb/framebuffer.rst:82
msgid ""
"You can request unchangeable information about the hardware, like name, "
"organization of the screen memory (planes, packed pixels, ...) and address "
"and length of the screen memory."
msgstr ""

#: ../../../fb/framebuffer.rst:86
msgid ""
"You can request and change variable information about the hardware, like "
"visible and virtual geometry, depth, color map format, timing, and so on. If "
"you try to change that information, the driver maybe will round up some "
"values to meet the hardware's capabilities (or return EINVAL if that isn't "
"possible)."
msgstr ""

#: ../../../fb/framebuffer.rst:92
msgid ""
"You can get and set parts of the color map. Communication is done with 16 "
"bits per color part (red, green, blue, transparency) to support all existing "
"hardware. The driver does all the computations needed to apply it to the "
"hardware (round it down to less bits, maybe throw away transparency)."
msgstr ""

#: ../../../fb/framebuffer.rst:98
msgid ""
"All this hardware abstraction makes the implementation of application "
"programs easier and more portable. E.g. the X server works completely on /"
"dev/fb* and thus doesn't need to know, for example, how the color registers "
"of the concrete hardware are organized. XF68_FBDev is a general X server for "
"bitmapped, unaccelerated video hardware. The only thing that has to be built "
"into application programs is the screen organization (bitplanes or chunky "
"pixels etc.), because it works on the frame buffer image data directly."
msgstr ""

#: ../../../fb/framebuffer.rst:106
msgid ""
"For the future it is planned that frame buffer drivers for graphics cards "
"and the like can be implemented as kernel modules that are loaded at "
"runtime. Such a driver just has to call register_framebuffer() and supply "
"some functions. Writing and distributing such drivers independently from the "
"kernel will save much trouble..."
msgstr ""

#: ../../../fb/framebuffer.rst:114
msgid "3. Frame Buffer Resolution Maintenance"
msgstr ""

#: ../../../fb/framebuffer.rst:116
msgid ""
"Frame buffer resolutions are maintained using the utility `fbset`. It can "
"change the video mode properties of a frame buffer device. Its main usage is "
"to change the current video mode, e.g. during boot up in one of your `/etc/"
"rc.*` or `/etc/init.d/*` files."
msgstr ""

#: ../../../fb/framebuffer.rst:121
msgid ""
"Fbset uses a video mode database stored in a configuration file, so you can "
"easily add your own modes and refer to them with a simple identifier."
msgstr ""

#: ../../../fb/framebuffer.rst:126
msgid "4. The X Server"
msgstr ""

#: ../../../fb/framebuffer.rst:128
msgid ""
"The X server (XF68_FBDev) is the most notable application program for the "
"frame buffer device. Starting with XFree86 release 3.2, the X server is part "
"of XFree86 and has 2 modes:"
msgstr ""

#: ../../../fb/framebuffer.rst:132
msgid ""
"If the `Display` subsection for the `fbdev` driver in the /etc/XF86Config "
"file contains a::"
msgstr ""

#: ../../../fb/framebuffer.rst:137
msgid ""
"line, the X server will use the scheme discussed above, i.e. it will start "
"up in the resolution determined by /dev/fb0 (or $FRAMEBUFFER, if set). You "
"still have to specify the color depth (using the Depth keyword) and virtual "
"resolution (using the Virtual keyword) though. This is the default for the "
"configuration file supplied with XFree86. It's the most simple "
"configuration, but it has some limitations."
msgstr ""

#: ../../../fb/framebuffer.rst:144
msgid ""
"Therefore it's also possible to specify resolutions in the /etc/XF86Config "
"file. This allows for on-the-fly resolution switching while retaining the "
"same virtual desktop size. The frame buffer device that's used is still /dev/"
"fb0current (or $FRAMEBUFFER), but the available resolutions are defined by /"
"etc/XF86Config now. The disadvantage is that you have to specify the timings "
"in a different format (but `fbset -x` may help)."
msgstr ""

#: ../../../fb/framebuffer.rst:151
msgid ""
"To tune a video mode, you can use fbset or xvidtune. Note that xvidtune "
"doesn't work 100% with XF68_FBDev: the reported clock values are always "
"incorrect."
msgstr ""

#: ../../../fb/framebuffer.rst:156
msgid "5. Video Mode Timings"
msgstr ""

#: ../../../fb/framebuffer.rst:158
msgid ""
"A monitor draws an image on the screen by using an electron beam (3 electron "
"beams for color models, 1 electron beam for monochrome monitors). The front "
"of the screen is covered by a pattern of colored phosphors (pixels). If a "
"phosphor is hit by an electron, it emits a photon and thus becomes visible."
msgstr ""

#: ../../../fb/framebuffer.rst:163
msgid ""
"The electron beam draws horizontal lines (scanlines) from left to right, and "
"from the top to the bottom of the screen. By modifying the intensity of the "
"electron beam, pixels with various colors and intensities can be shown."
msgstr ""

#: ../../../fb/framebuffer.rst:167
msgid ""
"After each scanline the electron beam has to move back to the left side of "
"the screen and to the next line: this is called the horizontal retrace. "
"After the whole screen (frame) was painted, the beam moves back to the upper "
"left corner: this is called the vertical retrace. During both the horizontal "
"and vertical retrace, the electron beam is turned off (blanked)."
msgstr ""

#: ../../../fb/framebuffer.rst:173
msgid ""
"The speed at which the electron beam paints the pixels is determined by the "
"dotclock in the graphics board. For a dotclock of e.g. 28.37516 MHz "
"(millions of cycles per second), each pixel is 35242 ps (picoseconds) long::"
msgstr ""

#: ../../../fb/framebuffer.rst:179
msgid "If the screen resolution is 640x480, it will take::"
msgstr ""

#: ../../../fb/framebuffer.rst:183
msgid ""
"to paint the 640 (xres) pixels on one scanline. But the horizontal retrace "
"also takes time (e.g. 272 `pixels`), so a full scanline takes::"
msgstr ""

#: ../../../fb/framebuffer.rst:188
msgid "We'll say that the horizontal scanrate is about 31 kHz::"
msgstr ""

#: ../../../fb/framebuffer.rst:192
msgid ""
"A full screen counts 480 (yres) lines, but we have to consider the vertical "
"retrace too (e.g. 49 `lines`). So a full screen will take::"
msgstr ""

#: ../../../fb/framebuffer.rst:197
msgid "The vertical scanrate is about 59 Hz::"
msgstr ""

#: ../../../fb/framebuffer.rst:201
msgid ""
"This means the screen data is refreshed about 59 times per second. To have a "
"stable picture without visible flicker, VESA recommends a vertical scanrate "
"of at least 72 Hz. But the perceived flicker is very human dependent: some "
"people can use 50 Hz without any trouble, while I'll notice if it's less "
"than 80 Hz."
msgstr ""

#: ../../../fb/framebuffer.rst:206
msgid ""
"Since the monitor doesn't know when a new scanline starts, the graphics "
"board will supply a synchronization pulse (horizontal sync or hsync) for "
"each scanline.  Similarly it supplies a synchronization pulse (vertical sync "
"or vsync) for each new frame. The position of the image on the screen is "
"influenced by the moments at which the synchronization pulses occur."
msgstr ""

#: ../../../fb/framebuffer.rst:212
msgid ""
"The following picture summarizes all timings. The horizontal retrace time is "
"the sum of the left margin, the right margin and the hsync length, while the "
"vertical retrace time is the sum of the upper margin, the lower margin and "
"the vsync length::"
msgstr ""

#: ../../../fb/framebuffer.rst:252
msgid ""
"The frame buffer device expects all horizontal timings in number of "
"dotclocks (in picoseconds, 1E-12 s), and vertical timings in number of "
"scanlines."
msgstr ""

#: ../../../fb/framebuffer.rst:257
msgid "6. Converting XFree86 timing values info frame buffer device timings"
msgstr ""

#: ../../../fb/framebuffer.rst:259
msgid "An XFree86 mode line consists of the following fields::"
msgstr ""

#: ../../../fb/framebuffer.rst:264
msgid "The frame buffer device uses the following fields:"
msgstr ""

#: ../../../fb/framebuffer.rst:266
msgid "pixclock: pixel clock in ps (pico seconds)"
msgstr ""

#: ../../../fb/framebuffer.rst:267
msgid "left_margin: time from sync to picture"
msgstr ""

#: ../../../fb/framebuffer.rst:268
msgid "right_margin: time from picture to sync"
msgstr ""

#: ../../../fb/framebuffer.rst:269
msgid "upper_margin: time from sync to picture"
msgstr ""

#: ../../../fb/framebuffer.rst:270
msgid "lower_margin: time from picture to sync"
msgstr ""

#: ../../../fb/framebuffer.rst:271
msgid "hsync_len: length of horizontal sync"
msgstr ""

#: ../../../fb/framebuffer.rst:272
msgid "vsync_len: length of vertical sync"
msgstr ""

#: ../../../fb/framebuffer.rst:274
msgid "Pixelclock:"
msgstr ""

#: ../../../fb/framebuffer.rst:276
msgid "xfree: in MHz"
msgstr ""

#: ../../../fb/framebuffer.rst:278
msgid "fb: in picoseconds (ps)"
msgstr ""

#: ../../../fb/framebuffer.rst:280
msgid "pixclock = 1000000 / DCF"
msgstr ""

#: ../../../fb/framebuffer.rst:282
msgid "horizontal timings:"
msgstr ""

#: ../../../fb/framebuffer.rst:284
msgid "left_margin = HFL - SH2"
msgstr ""

#: ../../../fb/framebuffer.rst:286
msgid "right_margin = SH1 - HR"
msgstr ""

#: ../../../fb/framebuffer.rst:288
msgid "hsync_len = SH2 - SH1"
msgstr ""

#: ../../../fb/framebuffer.rst:290
msgid "vertical timings:"
msgstr ""

#: ../../../fb/framebuffer.rst:292
msgid "upper_margin = VFL - SV2"
msgstr ""

#: ../../../fb/framebuffer.rst:294
msgid "lower_margin = SV1 - VR"
msgstr ""

#: ../../../fb/framebuffer.rst:296
msgid "vsync_len = SV2 - SV1"
msgstr ""

#: ../../../fb/framebuffer.rst:298
msgid ""
"Good examples for VESA timings can be found in the XFree86 source tree, "
"under \"xc/programs/Xserver/hw/xfree86/doc/modeDB.txt\"."
msgstr ""

#: ../../../fb/framebuffer.rst:303
msgid "7. References"
msgstr ""

#: ../../../fb/framebuffer.rst:305
msgid ""
"For more specific information about the frame buffer device and its "
"applications, please refer to the Linux-fbdev website:"
msgstr ""

#: ../../../fb/framebuffer.rst:308
msgid "http://linux-fbdev.sourceforge.net/"
msgstr ""

#: ../../../fb/framebuffer.rst:310
msgid "and to the following documentation:"
msgstr ""

#: ../../../fb/framebuffer.rst:312
msgid "The manual pages for fbset: fbset(8), fb.modes(5)"
msgstr ""

#: ../../../fb/framebuffer.rst:313
msgid "The manual pages for XFree86: XF68_FBDev(1), XF86Config(4/5)"
msgstr ""

#: ../../../fb/framebuffer.rst:314
msgid "The mighty kernel sources:"
msgstr ""

#: ../../../fb/framebuffer.rst:316
msgid "linux/drivers/video/"
msgstr ""

#: ../../../fb/framebuffer.rst:317
msgid "linux/include/linux/fb.h"
msgstr ""

#: ../../../fb/framebuffer.rst:318
msgid "linux/include/video/"
msgstr ""

#: ../../../fb/framebuffer.rst:323
msgid "8. Mailing list"
msgstr ""

#: ../../../fb/framebuffer.rst:325
msgid ""
"There is a frame buffer device related mailing list at kernel.org: linux-"
"fbdev@vger.kernel.org."
msgstr ""

#: ../../../fb/framebuffer.rst:328
msgid ""
"Point your web browser to http://sourceforge.net/projects/linux-fbdev/ for "
"subscription information and archive browsing."
msgstr ""

#: ../../../fb/framebuffer.rst:333
msgid "9. Downloading"
msgstr ""

#: ../../../fb/framebuffer.rst:335
msgid "All necessary files can be found at"
msgstr ""

#: ../../../fb/framebuffer.rst:337
msgid "ftp://ftp.uni-erlangen.de/pub/Linux/LOCAL/680x0/"
msgstr ""

#: ../../../fb/framebuffer.rst:339
msgid "and on its mirrors."
msgstr ""

#: ../../../fb/framebuffer.rst:341
msgid "The latest version of fbset can be found at"
msgstr ""

#: ../../../fb/framebuffer.rst:343
msgid "http://www.linux-fbdev.org/"
msgstr ""

#: ../../../fb/framebuffer.rst:347
msgid "10. Credits"
msgstr ""

#: ../../../fb/framebuffer.rst:349
msgid ""
"This readme was written by Geert Uytterhoeven, partly based on the original "
"`X-framebuffer.README` by Roman Hodek and Martin Schaller. Section 6 was "
"provided by Frank Neumann."
msgstr ""

#: ../../../fb/framebuffer.rst:353
msgid "The frame buffer device abstraction was designed by Martin Schaller."
msgstr ""
