# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-25 09:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../security/keys/trusted-encrypted.rst:3
msgid "Trusted and Encrypted Keys"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:5
msgid ""
"Trusted and Encrypted Keys are two new key types added to the existing "
"kernel key ring service.  Both of these new types are variable length "
"symmetric keys, and in both cases all keys are created in the kernel, and "
"user space sees, stores, and loads only encrypted blobs.  Trusted Keys "
"require the availability of a Trust Source for greater security, while "
"Encrypted Keys can be used on any system. All user level blobs, are "
"displayed and loaded in hex ASCII for convenience, and are integrity "
"verified."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:15
msgid "Trust Source"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:17
msgid ""
"A trust source provides the source of security for Trusted Keys.  This "
"section lists currently supported trust sources, along with their security "
"considerations.  Whether or not a trust source is sufficiently safe depends "
"on the strength and correctness of its implementation, as well as the threat "
"environment for a specific use case.  Since the kernel doesn't know what the "
"environment is, and there is no metric of trust, it is dependent on the "
"consumer of the Trusted Keys to determine if the trust source is "
"sufficiently safe."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:26
msgid "Root of trust for storage"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:28
msgid "TPM (Trusted Platform Module: hardware device)"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:30
msgid ""
"Rooted to Storage Root Key (SRK) which never leaves the TPM that provides "
"crypto operation to establish root of trust for storage."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:33
msgid "TEE (Trusted Execution Environment: OP-TEE based on Arm TrustZone)"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:35
msgid ""
"Rooted to Hardware Unique Key (HUK) which is generally burnt in on-chip "
"fuses and is accessible to TEE only."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:38
msgid "CAAM (Cryptographic Acceleration and Assurance Module: IP on NXP SoCs)"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:40
msgid ""
"When High Assurance Boot (HAB) is enabled and the CAAM is in secure mode, "
"trust is rooted to the OTPMK, a never-disclosed 256-bit key randomly "
"generated and fused into each SoC at manufacturing time. Otherwise, a common "
"fixed test key is used instead."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:45
#: ../../../security/keys/trusted-encrypted.rst:156
msgid "DCP (Data Co-Processor: crypto accelerator of various i.MX SoCs)"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:47
msgid ""
"Rooted to a one-time programmable key (OTP) that is generally burnt in the "
"on-chip fuses and is accessible to the DCP encryption engine only. DCP "
"provides two keys that can be used as root of trust: the OTP key and the "
"UNIQUE key. Default is to use the UNIQUE key, but selecting the OTP key can "
"be done via a module parameter (dcp_use_otp_key)."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:53
msgid "Execution isolation"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:55
#: ../../../security/keys/trusted-encrypted.rst:76
#: ../../../security/keys/trusted-encrypted.rst:103
msgid "TPM"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:57
#: ../../../security/keys/trusted-encrypted.rst:66
msgid "Fixed set of operations running in isolated execution environment."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:59
#: ../../../security/keys/trusted-encrypted.rst:86
#: ../../../security/keys/trusted-encrypted.rst:107
msgid "TEE"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:61
msgid ""
"Customizable set of operations running in isolated execution environment "
"verified via Secure/Trusted boot process."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:64
#: ../../../security/keys/trusted-encrypted.rst:91
#: ../../../security/keys/trusted-encrypted.rst:112
msgid "CAAM"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:68
#: ../../../security/keys/trusted-encrypted.rst:96
#: ../../../security/keys/trusted-encrypted.rst:116
msgid "DCP"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:70
msgid ""
"Fixed set of cryptographic operations running in isolated execution "
"environment. Only basic blob key encryption is executed there. The actual "
"key sealing/unsealing is done on main processor/kernel space."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:74
msgid "Optional binding to platform integrity state"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:78
msgid ""
"Keys can be optionally sealed to specified PCR (integrity measurement) "
"values, and only unsealed by the TPM, if PCRs and blob integrity "
"verifications match. A loaded Trusted Key can be updated with new (future) "
"PCR values, so keys are easily migrated to new PCR values, such as when the "
"kernel and initramfs are updated. The same key can have many saved blobs "
"under different PCR values, so multiple boots are easily supported."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:88
msgid ""
"Relies on Secure/Trusted boot process for platform integrity. It can be "
"extended with TEE based measured boot process."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:93
msgid ""
"Relies on the High Assurance Boot (HAB) mechanism of NXP SoCs for platform "
"integrity."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:98
msgid ""
"Relies on Secure/Trusted boot process (called HAB by vendor) for platform "
"integrity."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:101
msgid "Interfaces and APIs"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:105
msgid "TPMs have well-documented, standardized interfaces and APIs."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:109
msgid ""
"TEEs have well-documented, standardized client interface and APIs. For more "
"details refer to ``Documentation/driver-api/tee.rst``."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:114
msgid "Interface is specific to silicon vendor."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:118
msgid ""
"Vendor-specific API that is implemented as part of the DCP crypto driver in "
"``drivers/crypto/mxs-dcp.c``."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:121
msgid "Threat model"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:123
msgid ""
"The strength and appropriateness of a particular trust source for a given "
"purpose must be assessed when using them to protect security-relevant data."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:128
msgid "Key Generation"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:131
msgid "Trusted Keys"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:133
msgid ""
"New keys are created from random numbers. They are encrypted/decrypted using "
"a child key in the storage key hierarchy. Encryption and decryption of the "
"child key must be protected by a strong access control policy within the "
"trust source. The random number generator in use differs according to the "
"selected trust source:"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:139
msgid "TPM: hardware device based RNG"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:141
msgid ""
"Keys are generated within the TPM. Strength of random numbers may vary from "
"one device manufacturer to another."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:144
msgid "TEE: OP-TEE based on Arm TrustZone based RNG"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:146
msgid ""
"RNG is customizable as per platform needs. It can either be direct output "
"from platform specific hardware RNG or a software based Fortuna CSPRNG which "
"can be seeded via multiple entropy sources."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:150
msgid "CAAM: Kernel RNG"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:152
msgid ""
"The normal kernel random number generator is used. To seed it from the CAAM "
"HWRNG, enable CRYPTO_DEV_FSL_CAAM_RNG_API and ensure the device is probed."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:158
msgid ""
"The DCP hardware device itself does not provide a dedicated RNG interface, "
"so the kernel default RNG is used. SoCs with DCP like the i.MX6ULL do have a "
"dedicated hardware RNG that is independent from DCP which can be enabled to "
"back the kernel RNG."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:163
msgid ""
"Users may override this by specifying ``trusted.rng=kernel`` on the kernel "
"command-line to override the used RNG with the kernel's random number pool."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:167
msgid "Encrypted Keys"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:169
msgid ""
"Encrypted keys do not depend on a trust source, and are faster, as they use "
"AES for encryption/decryption. New keys are created either from kernel-"
"generated random numbers or user-provided decrypted data, and are encrypted/"
"decrypted using a specified ‘master’ key. The ‘master’ key can either be a "
"trusted-key or user-key type. The main disadvantage of encrypted keys is "
"that if they are not rooted in a trusted key, they are only as secure as the "
"user key encrypting them. The master user key should therefore be loaded in "
"as secure a way as possible, preferably early in boot."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:180
msgid "Usage"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:183
msgid "Trusted Keys usage: TPM"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:185
msgid ""
"TPM 1.2: By default, trusted keys are sealed under the SRK, which has the "
"default authorization value (20 bytes of 0s).  This can be set at "
"takeownership time with the TrouSerS utility: \"tpm_takeownership -u -z\"."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:189
msgid ""
"TPM 2.0: The user must first create a storage key and make it persistent, so "
"the key is available after reboot. This can be done using the following "
"commands."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:192
msgid "With the IBM TSS 2 stack::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:198
msgid "Or with the Intel TSS 2 stack::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:205
#: ../../../security/keys/trusted-encrypted.rst:242
#: ../../../security/keys/trusted-encrypted.rst:255
#: ../../../security/keys/trusted-encrypted.rst:268
#: ../../../security/keys/trusted-encrypted.rst:285
msgid "Usage::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:234
msgid ""
"\"keyctl print\" returns an ascii hex copy of the sealed key, which is in "
"standard TPM_STORED_DATA format.  The key length for new keys are always in "
"bytes. Trusted Keys can be 32 - 128 bytes (256 - 1024 bits), the upper limit "
"is to fit within the 2048 bit SRK (RSA) keylength, with all necessary "
"structure/padding."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:240
msgid "Trusted Keys usage: TEE"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:248
msgid ""
"\"keyctl print\" returns an ASCII hex copy of the sealed key, which is in "
"format specific to TEE device implementation.  The key length for new keys "
"is always in bytes. Trusted Keys can be 32 - 128 bytes (256 - 1024 bits)."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:253
msgid "Trusted Keys usage: CAAM"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:261
msgid ""
"\"keyctl print\" returns an ASCII hex copy of the sealed key, which is in a "
"CAAM-specific format.  The key length for new keys is always in bytes. "
"Trusted Keys can be 32 - 128 bytes (256 - 1024 bits)."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:266
msgid "Trusted Keys usage: DCP"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:274
msgid ""
"\"keyctl print\" returns an ASCII hex copy of the sealed key, which is in "
"format specific to this DCP key-blob implementation.  The key length for new "
"keys is always in bytes. Trusted Keys can be 32 - 128 bytes (256 - 1024 "
"bits)."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:279
msgid "Encrypted Keys usage"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:281
msgid ""
"The decrypted portion of encrypted keys can contain either a simple "
"symmetric key or a more complex structure. The format of the more complex "
"structure is application specific, which is identified by 'format'."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:294
msgid "Where::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:300
msgid "Examples of trusted and encrypted key usage"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:302
msgid "Create and save a trusted key named \"kmk\" of length 32 bytes."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:304
msgid ""
"Note: When using a TPM 2.0 with a persistent key with handle 0x81000001, "
"append 'keyhandle=0x81000001' to statements between quotes, such as \"new 32 "
"keyhandle=0x81000001\"."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:331
msgid "Load a trusted key from the saved blob::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:346
msgid "Reseal (TPM specific) a trusted key under new PCR values::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:361
msgid ""
"The initial consumer of trusted keys is EVM, which at boot time needs a high "
"quality symmetric key for HMAC protection of file metadata. The use of a "
"trusted key provides strong guarantees that the EVM key has not been "
"compromised by a user level problem, and when sealed to a platform integrity "
"state, protects against boot and offline attacks. Create and save an "
"encrypted key \"evm\" using the above trusted key \"kmk\":"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:368
msgid "option 1: omitting 'format'::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:373
msgid "option 2: explicitly defining 'format' as 'default'::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:385
msgid "Load an encrypted key \"evm\" from saved blob::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:395
msgid ""
"Instantiate an encrypted key \"evm\" using user-provided decrypted data::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:406
msgid ""
"Other uses for trusted and encrypted keys, such as for disk and file "
"encryption are anticipated.  In particular the new format 'ecryptfs' has "
"been defined in order to use encrypted keys to mount an eCryptfs "
"filesystem.  More details about the usage can be found in the file "
"``Documentation/security/keys/ecryptfs.rst``."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:412
msgid ""
"Another new format 'enc32' has been defined in order to support encrypted "
"keys with payload size of 32 bytes. This will initially be used for nvdimm "
"security but may expand to other usages that require 32 bytes payload."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:418
msgid "TPM 2.0 ASN.1 Key Format"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:420
msgid ""
"The TPM 2.0 ASN.1 key format is designed to be easily recognisable, even in "
"binary form (fixing a problem we had with the TPM 1.2 ASN.1 format) and to "
"be extensible for additions like importable keys and policy::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:433
msgid ""
"type is what distinguishes the key even in binary form since the OID is "
"provided by the TCG to be unique and thus forms a recognizable binary "
"pattern at offset 3 in the key.  The OIDs currently made available are::"
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:451
msgid "The trusted key code only uses the TPM Sealed Data OID."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:453
msgid ""
"emptyAuth is true if the key has well known authorization \"\".  If it is "
"false or not present, the key requires an explicit authorization phrase.  "
"This is used by most user space consumers to decide whether to prompt for a "
"password."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:458
msgid ""
"parent represents the parent key handle, either in the 0x81 MSO space, like "
"0x81000001 for the RSA primary storage key.  Userspace programmes also "
"support specifying the primary handle in the 0x40 MSO space.  If this "
"happens the Elliptic Curve variant of the primary key using the TCG defined "
"template will be generated on the fly into a volatile object and used as the "
"parent.  The current kernel code only supports the 0x81 MSO form."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:466
msgid ""
"pubkey is the binary representation of TPM2B_PRIVATE excluding the initial "
"TPM2B header, which can be reconstructed from the ASN.1 octet string length."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:470
msgid ""
"privkey is the binary representation of TPM2B_PUBLIC excluding the initial "
"TPM2B header which can be reconstructed from the ASN.1 octed string length."
msgstr ""

#: ../../../security/keys/trusted-encrypted.rst:475
msgid "DCP Blob Format"
msgstr ""

#: ../../../security/keys/trusted-encrypted:477:
#: security/keys/trusted-keys/trusted_dcp.c:23
msgid ""
"The Data Co-Processor (DCP) provides hardware-bound AES keys using its AES "
"encryption engine only. It does not provide direct key sealing/unsealing. To "
"make DCP hardware encryption keys usable as trust source, we define our own "
"custom format that uses a hardware-bound key to secure the sealing key "
"stored in the key blob."
msgstr ""

#: ../../../security/keys/trusted-encrypted:477:
#: security/keys/trusted-keys/trusted_dcp.c:29
msgid ""
"Whenever a new trusted key using DCP is generated, we generate a random 128-"
"bit blob encryption key (BEK) and 128-bit nonce. The BEK and nonce are used "
"to encrypt the trusted key payload using AES-128-GCM."
msgstr ""

#: ../../../security/keys/trusted-encrypted:477:
#: security/keys/trusted-keys/trusted_dcp.c:33
msgid ""
"The BEK itself is encrypted using the hardware-bound key using the DCP's AES "
"encryption engine with AES-128-ECB. The encrypted BEK, generated nonce, BEK-"
"encrypted payload and authentication tag make up the blob format together "
"with a version number, payload length and authentication tag."
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:42
msgid "DCP BLOB format."
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:46
msgid "**Definition**::"
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:56
msgid "**Members**"
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:44
msgid "``fmt_version``"
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:45
msgid "Format version, currently being ``1``."
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:45
msgid "``blob_key``"
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:46
msgid ""
"Random AES 128 key which is used to encrypt **payload**, **blob_key** itself "
"is encrypted with OTP or UNIQUE device key in AES-128-ECB mode by DCP."
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:48
msgid "``nonce``"
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:49
msgid "Random nonce used for **payload** encryption."
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:49
msgid "``payload_len``"
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:50
msgid "Length of the plain text **payload**."
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:50
msgid "``payload``"
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:51
msgid ""
"The payload itself, encrypted using AES-128-GCM and **blob_key**, GCM auth "
"tag of size DCP_BLOB_AUTHLEN is attached at the end of it."
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:55
msgid "**Description**"
msgstr ""

#: ../../../security/keys/trusted-encrypted:480:
#: security/keys/trusted-keys/trusted_dcp.c:52
msgid ""
"The total size of a DCP BLOB is sizeof(struct dcp_blob_fmt) + "
"**payload_len** + DCP_BLOB_AUTHLEN."
msgstr ""
