# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm64/sme.rst:3
msgid "Scalable Matrix Extension support for AArch64 Linux"
msgstr ""

#: ../../../arch/arm64/sme.rst:5
msgid ""
"This document outlines briefly the interface provided to userspace by Linux "
"in order to support use of the ARM Scalable Matrix Extension (SME)."
msgstr ""

#: ../../../arch/arm64/sme.rst:8
msgid ""
"This is an outline of the most important features and issues only and not "
"intended to be exhaustive.  It should be read in conjunction with the SVE "
"documentation in sve.rst which provides details on the Streaming SVE mode "
"included in SME."
msgstr ""

#: ../../../arch/arm64/sme.rst:13
msgid ""
"This document does not aim to describe the SME architecture or programmer's "
"model.  To aid understanding, a minimal description of relevant programmer's "
"model features for SME is included in Appendix A."
msgstr ""

#: ../../../arch/arm64/sme.rst:19
msgid "1.  General"
msgstr ""

#: ../../../arch/arm64/sme.rst:21
msgid ""
"PSTATE.SM, PSTATE.ZA, the streaming mode vector length, the ZA and (when "
"present) ZTn register state and TPIDR2_EL0 are tracked per thread."
msgstr ""

#: ../../../arch/arm64/sme.rst:24
msgid ""
"The presence of SME is reported to userspace via HWCAP2_SME in the aux "
"vector AT_HWCAP2 entry.  Presence of this flag implies the presence of the "
"SME instructions and registers, and the Linux-specific system interfaces "
"described in this document.  SME is reported in /proc/cpuinfo as \"sme\"."
msgstr ""

#: ../../../arch/arm64/sme.rst:29
msgid ""
"The presence of SME2 is reported to userspace via HWCAP2_SME2 in the aux "
"vector AT_HWCAP2 entry.  Presence of this flag implies the presence of the "
"SME2 instructions and ZT0, and the Linux-specific system interfaces "
"described in this document.  SME2 is reported in /proc/cpuinfo as \"sme2\"."
msgstr ""

#: ../../../arch/arm64/sme.rst:34
msgid ""
"Support for the execution of SME instructions in userspace can also be "
"detected by reading the CPU ID register ID_AA64PFR1_EL1 using an MRS "
"instruction, and checking that the value of the SME field is nonzero. [3]"
msgstr ""

#: ../../../arch/arm64/sme.rst:38
msgid ""
"It does not guarantee the presence of the system interfaces described in the "
"following sections: software that needs to verify that those interfaces are "
"present must check for HWCAP2_SME instead."
msgstr ""

#: ../../../arch/arm64/sme.rst:42
msgid ""
"There are a number of optional SME features, presence of these is reported "
"through AT_HWCAP2 through:"
msgstr ""

#: ../../../arch/arm64/sme.rst:45
msgid ""
"HWCAP2_SME_I16I64 HWCAP2_SME_F64F64 HWCAP2_SME_I8I32 HWCAP2_SME_F16F32 "
"HWCAP2_SME_B16F32 HWCAP2_SME_F32F32 HWCAP2_SME_FA64 HWCAP2_SME2"
msgstr ""

#: ../../../arch/arm64/sme.rst:54
msgid "This list may be extended over time as the SME architecture evolves."
msgstr ""

#: ../../../arch/arm64/sme.rst:56
msgid ""
"These extensions are also reported via the CPU ID register ID_AA64SMFR0_EL1, "
"which userspace can read using an MRS instruction.  See elf_hwcaps.txt and "
"cpu-feature-registers.txt for details."
msgstr ""

#: ../../../arch/arm64/sme.rst:60
msgid ""
"Debuggers should restrict themselves to interacting with the target via the "
"NT_ARM_SVE, NT_ARM_SSVE, NT_ARM_ZA and NT_ARM_ZT regsets.  The recommended "
"way of detecting support for these regsets is to connect to a target process "
"first and then attempt a"
msgstr ""

#: ../../../arch/arm64/sme.rst:65
msgid "ptrace(PTRACE_GETREGSET, pid, NT_ARM_<regset>, &iov)."
msgstr ""

#: ../../../arch/arm64/sme.rst:67
msgid ""
"Whenever ZA register values are exchanged in memory between userspace and "
"the kernel, the register value is encoded in memory as a series of "
"horizontal vectors from 0 to VL/8-1 stored in the same endianness invariant "
"format as is used for SVE vectors."
msgstr ""

#: ../../../arch/arm64/sme.rst:72
msgid ""
"On thread creation PSTATE.ZA and TPIDR2_EL0 are preserved unless CLONE_VM is "
"specified, in which case PSTATE.ZA is set to 0 and TPIDR2_EL0 is set to 0."
msgstr ""

#: ../../../arch/arm64/sme.rst:76
msgid "2.  Vector lengths"
msgstr ""

#: ../../../arch/arm64/sme.rst:78
msgid ""
"SME defines a second vector length similar to the SVE vector length which "
"controls the size of the streaming mode SVE vectors and the ZA matrix array. "
"The ZA matrix is square with each side having as many bytes as a streaming "
"mode SVE vector."
msgstr ""

#: ../../../arch/arm64/sme.rst:85
msgid "3.  Sharing of streaming and non-streaming mode SVE state"
msgstr ""

#: ../../../arch/arm64/sme.rst:87
msgid ""
"It is implementation defined which if any parts of the SVE state are shared "
"between streaming and non-streaming modes.  When switching between modes via "
"software interfaces such as ptrace if no register content is provided as "
"part of switching no state will be assumed to be shared and everything will "
"be zeroed."
msgstr ""

#: ../../../arch/arm64/sme.rst:95
msgid "4.  System call behaviour"
msgstr ""

#: ../../../arch/arm64/sme.rst:97
msgid ""
"On syscall PSTATE.ZA is preserved, if PSTATE.ZA==1 then the contents of the "
"ZA matrix and ZTn (if present) are preserved."
msgstr ""

#: ../../../arch/arm64/sme.rst:100
msgid ""
"On syscall PSTATE.SM will be cleared and the SVE registers will be handled "
"as per the standard SVE ABI."
msgstr ""

#: ../../../arch/arm64/sme.rst:103
msgid ""
"None of the SVE registers, ZA or ZTn are used to pass arguments to or "
"receive results from any syscall."
msgstr ""

#: ../../../arch/arm64/sme.rst:106
msgid ""
"On process creation (eg, clone()) the newly created process will have PSTATE."
"SM cleared."
msgstr ""

#: ../../../arch/arm64/sme.rst:109
msgid ""
"All other SME state of a thread, including the currently configured vector "
"length, the state of the PR_SME_VL_INHERIT flag, and the deferred vector "
"length (if any), is preserved across all syscalls, subject to the specific "
"exceptions for execve() described in section 6."
msgstr ""

#: ../../../arch/arm64/sme.rst:116
msgid "5.  Signal handling"
msgstr ""

#: ../../../arch/arm64/sme.rst:118
msgid ""
"Signal handlers are invoked with PSTATE.SM=0, PSTATE.ZA=0, and TPIDR2_EL0=0."
msgstr ""

#: ../../../arch/arm64/sme.rst:120
msgid ""
"A new signal frame record TPIDR2_MAGIC is added formatted as a struct "
"tpidr2_context to allow access to TPIDR2_EL0 from signal handlers."
msgstr ""

#: ../../../arch/arm64/sme.rst:123
msgid ""
"A new signal frame record za_context encodes the ZA register contents on "
"signal delivery. [1]"
msgstr ""

#: ../../../arch/arm64/sme.rst:126
msgid ""
"The signal frame record for ZA always contains basic metadata, in particular "
"the thread's vector length (in za_context.vl)."
msgstr ""

#: ../../../arch/arm64/sme.rst:129
msgid ""
"The ZA matrix may or may not be included in the record, depending on the "
"value of PSTATE.ZA.  The registers are present if and only if: za_context."
"head.size >= ZA_SIG_CONTEXT_SIZE(sve_vq_from_vl(za_context.vl)) in which "
"case PSTATE.ZA == 1."
msgstr ""

#: ../../../arch/arm64/sme.rst:134
msgid ""
"If matrix data is present, the remainder of the record has a vl-dependent "
"size and layout.  Macros ZA_SIG_* are defined [1] to facilitate access to "
"them."
msgstr ""

#: ../../../arch/arm64/sme.rst:138
msgid ""
"The matrix is stored as a series of horizontal vectors in the same format as "
"is used for SVE vectors."
msgstr ""

#: ../../../arch/arm64/sme.rst:141
msgid ""
"If the ZA context is too big to fit in sigcontext.__reserved[], then extra "
"space is allocated on the stack, an extra_context record is written in "
"__reserved[] referencing this space.  za_context is then written in the "
"extra space.  Refer to [1] for further details about this mechanism."
msgstr ""

#: ../../../arch/arm64/sme.rst:146
msgid ""
"If ZTn is supported and PSTATE.ZA==1 then a signal frame record for ZTn will "
"be generated."
msgstr ""

#: ../../../arch/arm64/sme.rst:149
msgid ""
"The signal record for ZTn has magic ZT_MAGIC (0x5a544e01) and consists of a "
"standard signal frame header followed by a struct zt_context specifying the "
"number of ZTn registers supported by the system, then zt_context.nregs "
"blocks of 64 bytes of data per register."
msgstr ""

#: ../../../arch/arm64/sme.rst:156
msgid "5.  Signal return"
msgstr ""

#: ../../../arch/arm64/sme.rst:158
msgid "When returning from a signal handler:"
msgstr ""

#: ../../../arch/arm64/sme.rst:160
msgid ""
"If there is no za_context record in the signal frame, or if the record is "
"present but contains no register data as described in the previous section, "
"then ZA is disabled."
msgstr ""

#: ../../../arch/arm64/sme.rst:164
msgid ""
"If za_context is present in the signal frame and contains matrix data then "
"PSTATE.ZA is set to 1 and ZA is populated with the specified data."
msgstr ""

#: ../../../arch/arm64/sme.rst:167
msgid ""
"The vector length cannot be changed via signal return.  If za_context.vl in "
"the signal frame does not match the current vector length, the signal return "
"attempt is treated as illegal, resulting in a forced SIGSEGV."
msgstr ""

#: ../../../arch/arm64/sme.rst:171
msgid ""
"If ZTn is not supported or PSTATE.ZA==0 then it is illegal to have a signal "
"frame record for ZTn, resulting in a forced SIGSEGV."
msgstr ""

#: ../../../arch/arm64/sme.rst:176
msgid "6.  prctl extensions"
msgstr ""

#: ../../../arch/arm64/sme.rst:178
msgid ""
"Some new prctl() calls are added to allow programs to manage the SME vector "
"length:"
msgstr ""

#: ../../../arch/arm64/sme.rst:181
msgid "prctl(PR_SME_SET_VL, unsigned long arg)"
msgstr ""

#: ../../../arch/arm64/sme.rst:183
msgid ""
"Sets the vector length of the calling thread and related flags, where arg == "
"vl | flags.  Other threads of the calling process are unaffected."
msgstr ""

#: ../../../arch/arm64/sme.rst:186
msgid "vl is the desired vector length, where sve_vl_valid(vl) must be true."
msgstr ""

#: ../../../arch/arm64/sme.rst:188
msgid "flags:"
msgstr ""

#: ../../../arch/arm64/sme.rst:190 ../../../arch/arm64/sme.rst:256
msgid "PR_SME_VL_INHERIT"
msgstr ""

#: ../../../arch/arm64/sme.rst:192
msgid ""
"Inherit the current vector length across execve().  Otherwise, the vector "
"length is reset to the system default at execve().  (See Section 9.)"
msgstr ""

#: ../../../arch/arm64/sme.rst:196
msgid "PR_SME_SET_VL_ONEXEC"
msgstr ""

#: ../../../arch/arm64/sme.rst:198
msgid ""
"Defer the requested vector length change until the next execve() performed "
"by this thread."
msgstr ""

#: ../../../arch/arm64/sme.rst:201
msgid ""
"The effect is equivalent to implicit execution of the following call "
"immediately after the next execve() (if any) by the thread:"
msgstr ""

#: ../../../arch/arm64/sme.rst:204
msgid "prctl(PR_SME_SET_VL, arg & ~PR_SME_SET_VL_ONEXEC)"
msgstr ""

#: ../../../arch/arm64/sme.rst:206
msgid ""
"This allows launching of a new program with a different vector length, while "
"avoiding runtime side effects in the caller."
msgstr ""

#: ../../../arch/arm64/sme.rst:209
msgid ""
"Without PR_SME_SET_VL_ONEXEC, the requested change takes effect immediately."
msgstr ""

#: ../../../arch/arm64/sme.rst:213
msgid "Return value: a nonnegative on success, or a negative value on error:"
msgstr ""

#: ../../../arch/arm64/sme.rst:214
msgid "EINVAL: SME not supported, invalid vector length requested, or"
msgstr ""

#: ../../../arch/arm64/sme.rst:215
msgid "invalid flags."
msgstr ""

#: ../../../arch/arm64/sme.rst:218
msgid "On success:"
msgstr ""

#: ../../../arch/arm64/sme.rst:220
msgid ""
"Either the calling thread's vector length or the deferred vector length to "
"be applied at the next execve() by the thread (dependent on whether "
"PR_SME_SET_VL_ONEXEC is present in arg), is set to the largest value "
"supported by the system that is less than or equal to vl.  If vl == "
"SVE_VL_MAX, the value set will be the largest value supported by the system."
msgstr ""

#: ../../../arch/arm64/sme.rst:227
msgid ""
"Any previously outstanding deferred vector length change in the calling "
"thread is cancelled."
msgstr ""

#: ../../../arch/arm64/sme.rst:230
msgid ""
"The returned value describes the resulting configuration, encoded as for "
"PR_SME_GET_VL.  The vector length reported in this value is the new current "
"vector length for this thread if PR_SME_SET_VL_ONEXEC was not present in "
"arg; otherwise, the reported vector length is the deferred vector length "
"that will be applied at the next execve() by the calling thread."
msgstr ""

#: ../../../arch/arm64/sme.rst:237
msgid ""
"Changing the vector length causes all of ZA, ZTn, P0..P15, FFR and all bits "
"of Z0..Z31 except for Z0 bits [127:0] .. Z31 bits [127:0] to become "
"unspecified, including both streaming and non-streaming SVE state. Calling "
"PR_SME_SET_VL with vl equal to the thread's current vector length, or "
"calling PR_SME_SET_VL with the PR_SME_SET_VL_ONEXEC flag, does not "
"constitute a change to the vector length for this purpose."
msgstr ""

#: ../../../arch/arm64/sme.rst:244
msgid ""
"Changing the vector length causes PSTATE.ZA to be cleared. Calling "
"PR_SME_SET_VL with vl equal to the thread's current vector length, or "
"calling PR_SME_SET_VL with the PR_SME_SET_VL_ONEXEC flag, does not "
"constitute a change to the vector length for this purpose."
msgstr ""

#: ../../../arch/arm64/sme.rst:250
msgid "prctl(PR_SME_GET_VL)"
msgstr ""

#: ../../../arch/arm64/sme.rst:252
msgid "Gets the vector length of the calling thread."
msgstr ""

#: ../../../arch/arm64/sme.rst:254
msgid "The following flag may be OR-ed into the result:"
msgstr ""

#: ../../../arch/arm64/sme.rst:258
msgid "Vector length will be inherited across execve()."
msgstr ""

#: ../../../arch/arm64/sme.rst:260
msgid ""
"There is no way to determine whether there is an outstanding deferred vector "
"length change (which would only normally be the case between a fork() or "
"vfork() and the corresponding execve() in typical use)."
msgstr ""

#: ../../../arch/arm64/sme.rst:264
msgid ""
"To extract the vector length from the result, bitwise and it with "
"PR_SME_VL_LEN_MASK."
msgstr ""

#: ../../../arch/arm64/sme.rst:267
msgid ""
"Return value: a nonnegative value on success, or a negative value on error:"
msgstr ""

#: ../../../arch/arm64/sme.rst:268
msgid "EINVAL: SME not supported."
msgstr ""

#: ../../../arch/arm64/sme.rst:272
msgid "7.  ptrace extensions"
msgstr ""

#: ../../../arch/arm64/sme.rst:274
msgid ""
"A new regset NT_ARM_SSVE is defined for access to streaming mode SVE state "
"via PTRACE_GETREGSET and  PTRACE_SETREGSET, this is documented in sve.rst."
msgstr ""

#: ../../../arch/arm64/sme.rst:278
msgid ""
"A new regset NT_ARM_ZA is defined for ZA state for access to ZA state via "
"PTRACE_GETREGSET and PTRACE_SETREGSET."
msgstr ""

#: ../../../arch/arm64/sme.rst:281
msgid "Refer to [2] for definitions."
msgstr ""

#: ../../../arch/arm64/sme.rst:283
msgid "The regset data starts with struct user_za_header, containing:"
msgstr ""

#: ../../../arch/arm64/sme.rst:285
msgid "size"
msgstr ""

#: ../../../arch/arm64/sme.rst:287
msgid ""
"Size of the complete regset, in bytes. This depends on vl and possibly on "
"other things in the future."
msgstr ""

#: ../../../arch/arm64/sme.rst:290
msgid ""
"If a call to PTRACE_GETREGSET requests less data than the value of size, the "
"caller can allocate a larger buffer and retry in order to read the complete "
"regset."
msgstr ""

#: ../../../arch/arm64/sme.rst:294
msgid "max_size"
msgstr ""

#: ../../../arch/arm64/sme.rst:296
msgid ""
"Maximum size in bytes that the regset can grow to for the target thread.  "
"The regset won't grow bigger than this even if the target thread changes its "
"vector length etc."
msgstr ""

#: ../../../arch/arm64/sme.rst:300
msgid "vl"
msgstr ""

#: ../../../arch/arm64/sme.rst:302
msgid "Target thread's current streaming vector length, in bytes."
msgstr ""

#: ../../../arch/arm64/sme.rst:304
msgid "max_vl"
msgstr ""

#: ../../../arch/arm64/sme.rst:306
msgid "Maximum possible streaming vector length for the target thread."
msgstr ""

#: ../../../arch/arm64/sme.rst:308
msgid "flags"
msgstr ""

#: ../../../arch/arm64/sme.rst:310
msgid ""
"Zero or more of the following flags, which have the same meaning and "
"behaviour as the corresponding PR_SET_VL_* flags:"
msgstr ""

#: ../../../arch/arm64/sme.rst:313
msgid "SME_PT_VL_INHERIT"
msgstr ""

#: ../../../arch/arm64/sme.rst:315
msgid "SME_PT_VL_ONEXEC (SETREGSET only)."
msgstr ""

#: ../../../arch/arm64/sme.rst:317
msgid ""
"The effects of changing the vector length and/or flags are equivalent to "
"those documented for PR_SME_SET_VL."
msgstr ""

#: ../../../arch/arm64/sme.rst:320
msgid ""
"The caller must make a further GETREGSET call if it needs to know what VL is "
"actually set by SETREGSET, unless is it known in advance that the requested "
"VL is supported."
msgstr ""

#: ../../../arch/arm64/sme.rst:324
msgid ""
"The size and layout of the payload depends on the header fields.  The "
"ZA_PT_ZA*() macros are provided to facilitate access to the data."
msgstr ""

#: ../../../arch/arm64/sme.rst:327
msgid ""
"In either case, for SETREGSET it is permissible to omit the payload, in "
"which case the vector length and flags are changed and PSTATE.ZA is set to 0 "
"(along with any consequences of those changes).  If a payload is provided "
"then PSTATE.ZA will be set to 1."
msgstr ""

#: ../../../arch/arm64/sme.rst:332
msgid ""
"For SETREGSET, if the requested VL is not supported, the effect will be the "
"same as if the payload were omitted, except that an EIO error is reported. "
"No attempt is made to translate the payload data to the correct layout for "
"the vector length actually set.  It is up to the caller to translate the "
"payload layout for the actual VL and retry."
msgstr ""

#: ../../../arch/arm64/sme.rst:338
msgid "The effect of writing a partial, incomplete payload is unspecified."
msgstr ""

#: ../../../arch/arm64/sme.rst:340
msgid ""
"A new regset NT_ARM_ZT is defined for access to ZTn state via "
"PTRACE_GETREGSET and PTRACE_SETREGSET."
msgstr ""

#: ../../../arch/arm64/sme.rst:343
msgid "The NT_ARM_ZT regset consists of a single 512 bit register."
msgstr ""

#: ../../../arch/arm64/sme.rst:345
msgid "When PSTATE.ZA==0 reads of NT_ARM_ZT will report all bits of ZTn as 0."
msgstr ""

#: ../../../arch/arm64/sme.rst:347
msgid "Writes to NT_ARM_ZT will set PSTATE.ZA to 1."
msgstr ""

#: ../../../arch/arm64/sme.rst:349
msgid ""
"If any register data is provided along with SME_PT_VL_ONEXEC then the "
"registers data will be interpreted with the current vector length, not the "
"vector length configured for use on exec."
msgstr ""

#: ../../../arch/arm64/sme.rst:355
msgid "8.  ELF coredump extensions"
msgstr ""

#: ../../../arch/arm64/sme.rst:357
msgid ""
"NT_ARM_SSVE notes will be added to each coredump for each thread of the "
"dumped process.  The contents will be equivalent to the data that would have "
"been read if a PTRACE_GETREGSET of the corresponding type were executed for "
"each thread when the coredump was generated."
msgstr ""

#: ../../../arch/arm64/sme.rst:362
msgid ""
"A NT_ARM_ZA note will be added to each coredump for each thread of the "
"dumped process.  The contents will be equivalent to the data that would have "
"been read if a PTRACE_GETREGSET of NT_ARM_ZA were executed for each thread "
"when the coredump was generated."
msgstr ""

#: ../../../arch/arm64/sme.rst:367
msgid ""
"A NT_ARM_ZT note will be added to each coredump for each thread of the "
"dumped process.  The contents will be equivalent to the data that would have "
"been read if a PTRACE_GETREGSET of NT_ARM_ZT were executed for each thread "
"when the coredump was generated."
msgstr ""

#: ../../../arch/arm64/sme.rst:372
msgid ""
"The NT_ARM_TLS note will be extended to two registers, the second register "
"will contain TPIDR2_EL0 on systems that support SME and will be read as zero "
"with writes ignored otherwise."
msgstr ""

#: ../../../arch/arm64/sme.rst:377
msgid "9.  System runtime configuration"
msgstr ""

#: ../../../arch/arm64/sme.rst:379
msgid ""
"To mitigate the ABI impact of expansion of the signal frame, a policy "
"mechanism is provided for administrators, distro maintainers and developers "
"to set the default vector length for userspace processes:"
msgstr ""

#: ../../../arch/arm64/sme.rst:383
msgid "/proc/sys/abi/sme_default_vector_length"
msgstr ""

#: ../../../arch/arm64/sme.rst:385
msgid ""
"Writing the text representation of an integer to this file sets the system "
"default vector length to the specified value rounded to a supported value "
"using the same rules as for setting vector length via PR_SME_SET_VL."
msgstr ""

#: ../../../arch/arm64/sme.rst:389
msgid ""
"The result can be determined by reopening the file and reading its contents."
msgstr ""

#: ../../../arch/arm64/sme.rst:392
msgid ""
"At boot, the default vector length is initially set to 32 or the maximum "
"supported vector length, whichever is smaller and supported.  This "
"determines the initial vector length of the init process (PID 1)."
msgstr ""

#: ../../../arch/arm64/sme.rst:396
msgid "Reading this file returns the current system default vector length."
msgstr ""

#: ../../../arch/arm64/sme.rst:398
msgid ""
"At every execve() call, the new vector length of the new process is set to "
"the system default vector length, unless"
msgstr ""

#: ../../../arch/arm64/sme.rst:401
msgid ""
"PR_SME_VL_INHERIT (or equivalently SME_PT_VL_INHERIT) is set for the calling "
"thread, or"
msgstr ""

#: ../../../arch/arm64/sme.rst:404
msgid ""
"a deferred vector length change is pending, established via the "
"PR_SME_SET_VL_ONEXEC flag (or SME_PT_VL_ONEXEC)."
msgstr ""

#: ../../../arch/arm64/sme.rst:407
msgid ""
"Modifying the system default vector length does not affect the vector length "
"of any existing process or thread that does not make an execve() call."
msgstr ""

#: ../../../arch/arm64/sme.rst:412
msgid "Appendix A.  SME programmer's model (informative)"
msgstr ""

#: ../../../arch/arm64/sme.rst:414
msgid ""
"This section provides a minimal description of the additions made by SME to "
"the ARMv8-A programmer's model that are relevant to this document."
msgstr ""

#: ../../../arch/arm64/sme.rst:417
msgid ""
"Note: This section is for information only and not intended to be complete "
"or to replace any architectural specification."
msgstr ""

#: ../../../arch/arm64/sme.rst:421
msgid "A.1.  Registers"
msgstr ""

#: ../../../arch/arm64/sme.rst:423
msgid "In A64 state, SME adds the following:"
msgstr ""

#: ../../../arch/arm64/sme.rst:425
msgid ""
"A new mode, streaming mode, in which a subset of the normal FPSIMD and SVE "
"features are available.  When supported EL0 software may enter and leave "
"streaming mode at any time."
msgstr ""

#: ../../../arch/arm64/sme.rst:429
msgid ""
"For best system performance it is strongly encouraged for software to enable "
"streaming mode only when it is actively being used."
msgstr ""

#: ../../../arch/arm64/sme.rst:432
msgid ""
"A new vector length controlling the size of ZA and the Z registers when in "
"streaming mode, separately to the vector length used for SVE when not in "
"streaming mode.  There is no requirement that either the currently selected "
"vector length or the set of vector lengths supported for the two modes in a "
"given system have any relationship.  The streaming mode vector length is "
"referred to as SVL."
msgstr ""

#: ../../../arch/arm64/sme.rst:439
msgid ""
"A new ZA matrix register.  This is a square matrix of SVLxSVL bits.  Most "
"operations on ZA require that streaming mode be enabled but ZA can be "
"enabled without streaming mode in order to load, save and retain data."
msgstr ""

#: ../../../arch/arm64/sme.rst:443
msgid ""
"For best system performance it is strongly encouraged for software to enable "
"ZA only when it is actively being used."
msgstr ""

#: ../../../arch/arm64/sme.rst:446
msgid ""
"A new ZT0 register is introduced when SME2 is present. This is a 512 bit "
"register which is accessible when PSTATE.ZA is set, as ZA itself is."
msgstr ""

#: ../../../arch/arm64/sme.rst:449
msgid ""
"Two new 1 bit fields in PSTATE which may be controlled via the SMSTART and "
"SMSTOP instructions or by access to the SVCR system register:"
msgstr ""

#: ../../../arch/arm64/sme.rst:452
msgid ""
"PSTATE.ZA, if this is 1 then the ZA matrix is accessible and has valid data "
"while if it is 0 then ZA can not be accessed.  When PSTATE.ZA is changed "
"from 0 to 1 all bits in ZA are cleared."
msgstr ""

#: ../../../arch/arm64/sme.rst:456
msgid ""
"PSTATE.SM, if this is 1 then the PE is in streaming mode.  When the value of "
"PSTATE.SM is changed then it is implementation defined if the subset of the "
"floating point register bits valid in both modes may be retained. Any other "
"bits will be cleared."
msgstr ""

#: ../../../arch/arm64/sme.rst:463
msgid "References"
msgstr ""

#: ../../../arch/arm64/sme.rst:465
msgid "[1] arch/arm64/include/uapi/asm/sigcontext.h"
msgstr ""

#: ../../../arch/arm64/sme.rst:466
msgid "AArch64 Linux signal ABI definitions"
msgstr ""

#: ../../../arch/arm64/sme.rst:468
msgid "[2] arch/arm64/include/uapi/asm/ptrace.h"
msgstr ""

#: ../../../arch/arm64/sme.rst:469
msgid "AArch64 Linux ptrace ABI definitions"
msgstr ""

#: ../../../arch/arm64/sme.rst:471
msgid "[3] Documentation/arch/arm64/cpu-feature-registers.rst"
msgstr ""
