# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm64/memory-tagging-extension.rst:3
msgid "Memory Tagging Extension (MTE) in AArch64 Linux"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:5
msgid "Authors: Vincenzo Frascino <vincenzo.frascino@arm.com>"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:6
msgid "Catalin Marinas <catalin.marinas@arm.com>"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:8
msgid "Date: 2020-02-25"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:10
msgid ""
"This document describes the provision of the Memory Tagging Extension "
"functionality in AArch64 Linux."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:14
msgid "Introduction"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:16
msgid ""
"ARMv8.5 based processors introduce the Memory Tagging Extension (MTE) "
"feature. MTE is built on top of the ARMv8.0 virtual address tagging TBI (Top "
"Byte Ignore) feature and allows software to access a 4-bit allocation tag "
"for each 16-byte granule in the physical address space. Such memory range "
"must be mapped with the Normal-Tagged memory attribute. A logical tag is "
"derived from bits 59-56 of the virtual address used for the memory access. A "
"CPU with MTE enabled will compare the logical tag against the allocation tag "
"and potentially raise an exception on mismatch, subject to system registers "
"configuration."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:27
msgid "Userspace Support"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:29
msgid ""
"When ``CONFIG_ARM64_MTE`` is selected and Memory Tagging Extension is "
"supported by the hardware, the kernel advertises the feature to userspace "
"via ``HWCAP2_MTE``."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:34
msgid "PROT_MTE"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:36
msgid ""
"To access the allocation tags, a user process must enable the Tagged memory "
"attribute on an address range using a new ``prot`` flag for ``mmap()`` and "
"``mprotect()``:"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:40
msgid "``PROT_MTE`` - Pages allow access to the MTE allocation tags."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:42
msgid ""
"The allocation tag is set to 0 when such pages are first mapped in the user "
"address space and preserved on copy-on-write. ``MAP_SHARED`` is supported "
"and the allocation tags can be shared between processes."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:46
msgid ""
"**Note**: ``PROT_MTE`` is only supported on ``MAP_ANONYMOUS`` and RAM-based "
"file mappings (``tmpfs``, ``memfd``). Passing it to other types of mapping "
"will result in ``-EINVAL`` returned by these system calls."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:51
msgid ""
"**Note**: The ``PROT_MTE`` flag (and corresponding memory type) cannot be "
"cleared by ``mprotect()``."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:54
msgid ""
"**Note**: ``madvise()`` memory ranges with ``MADV_DONTNEED`` and "
"``MADV_FREE`` may have the allocation tags cleared (set to 0) at any point "
"after the system call."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:59
msgid "Tag Check Faults"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:61
msgid ""
"When ``PROT_MTE`` is enabled on an address range and a mismatch between the "
"logical and allocation tags occurs on access, there are three configurable "
"behaviours:"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:65
msgid ""
"*Ignore* - This is the default mode. The CPU (and kernel) ignores the tag "
"check fault."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:68
msgid ""
"*Synchronous* - The kernel raises a ``SIGSEGV`` synchronously, with ``."
"si_code = SEGV_MTESERR`` and ``.si_addr = <fault-address>``. The memory "
"access is not performed. If ``SIGSEGV`` is ignored or blocked by the "
"offending thread, the containing process is terminated with a ``coredump``."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:74
msgid ""
"*Asynchronous* - The kernel raises a ``SIGSEGV``, in the offending thread, "
"asynchronously following one or multiple tag check faults, with ``.si_code = "
"SEGV_MTEAERR`` and ``.si_addr = 0`` (the faulting address is unknown)."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:79
msgid ""
"*Asymmetric* - Reads are handled as for synchronous mode while writes are "
"handled as for asynchronous mode."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:82
msgid ""
"The user can select the above modes, per thread, using the "
"``prctl(PR_SET_TAGGED_ADDR_CTRL, flags, 0, 0, 0)`` system call where "
"``flags`` contains any number of the following values in the "
"``PR_MTE_TCF_MASK`` bit-field:"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:87
msgid "``PR_MTE_TCF_NONE`` Â - *Ignore* tag check faults"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:88
msgid "(ignored if combined with other options)"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:89
msgid "``PR_MTE_TCF_SYNC``  - *Synchronous* tag check fault mode"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:90
msgid "``PR_MTE_TCF_ASYNC`` - *Asynchronous* tag check fault mode"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:92
msgid ""
"If no modes are specified, tag check faults are ignored. If a single mode is "
"specified, the program will run in that mode. If multiple modes are "
"specified, the mode is selected as described in the \"Per-CPU preferred tag "
"checking modes\" section below."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:97
msgid ""
"The current tag check fault configuration can be read using the "
"``prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0)`` system call. If multiple "
"modes were requested then all will be reported."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:101
msgid ""
"Tag checking can also be disabled for a user thread by setting the ``PSTATE."
"TCO`` bit with ``MSR TCO, #1``."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:104
msgid ""
"**Note**: Signal handlers are always invoked with ``PSTATE.TCO = 0``, "
"irrespective of the interrupted context. ``PSTATE.TCO`` is restored on "
"``sigreturn()``."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:108
msgid ""
"**Note**: There are no *match-all* logical tags available for user "
"applications."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:111
msgid ""
"**Note**: Kernel accesses to the user address space (e.g. ``read()`` system "
"call) are not checked if the user thread tag checking mode is "
"``PR_MTE_TCF_NONE`` or ``PR_MTE_TCF_ASYNC``. If the tag checking mode is "
"``PR_MTE_TCF_SYNC``, the kernel makes a best effort to check its user "
"address accesses, however it cannot always guarantee it. Kernel accesses to "
"user addresses are always performed with an effective ``PSTATE.TCO`` value "
"of zero, regardless of the user configuration."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:120
msgid "Excluding Tags in the ``IRG``, ``ADDG`` and ``SUBG`` instructions"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:122
msgid ""
"The architecture allows excluding certain tags to be randomly generated via "
"the ``GCR_EL1.Exclude`` register bit-field. By default, Linux excludes all "
"tags other than 0. A user thread can enable specific tags in the randomly "
"generated set using the ``prctl(PR_SET_TAGGED_ADDR_CTRL, flags, 0, 0, 0)`` "
"system call where ``flags`` contains the tags bitmap in the "
"``PR_MTE_TAG_MASK`` bit-field."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:129
msgid ""
"**Note**: The hardware uses an exclude mask but the ``prctl()`` interface "
"provides an include mask. An include mask of ``0`` (exclusion mask "
"``0xffff``) results in the CPU always generating tag ``0``."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:134
msgid "Per-CPU preferred tag checking mode"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:136
msgid ""
"On some CPUs the performance of MTE in stricter tag checking modes is "
"similar to that of less strict tag checking modes. This makes it worthwhile "
"to enable stricter checks on those CPUs when a less strict checking mode is "
"requested, in order to gain the error detection benefits of the stricter "
"checks without the performance downsides. To support this scenario, a "
"privileged user may configure a stricter tag checking mode as the CPU's "
"preferred tag checking mode."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:144
msgid ""
"The preferred tag checking mode for each CPU is controlled by ``/sys/devices/"
"system/cpu/cpu<N>/mte_tcf_preferred``, to which a privileged user may write "
"the value ``async``, ``sync`` or ``asymm``.  The default preferred mode for "
"each CPU is ``async``."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:149
msgid ""
"To allow a program to potentially run in the CPU's preferred tag checking "
"mode, the user program may set multiple tag check fault mode bits in the "
"``flags`` argument to the ``prctl(PR_SET_TAGGED_ADDR_CTRL, flags, 0, 0, 0)`` "
"system call. If both synchronous and asynchronous modes are requested then "
"asymmetric mode may also be selected by the kernel. If the CPU's preferred "
"tag checking mode is in the task's set of provided tag checking modes, that "
"mode will be selected. Otherwise, one of the modes in the task's mode will "
"be selected by the kernel from the task's mode set using the preference "
"order:"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:159
msgid "Asynchronous"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:160
msgid "Asymmetric"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:161
msgid "Synchronous"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:163
msgid ""
"Note that there is no way for userspace to request multiple modes and also "
"disable asymmetric mode."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:167
msgid "Initial process state"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:169
msgid "On ``execve()``, the new process has the following configuration:"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:171
msgid "``PR_TAGGED_ADDR_ENABLE`` set to 0 (disabled)"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:172
msgid "No tag checking modes are selected (tag check faults ignored)"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:173
msgid "``PR_MTE_TAG_MASK`` set to 0 (all tags excluded)"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:174
msgid "``PSTATE.TCO`` set to 0"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:175
msgid "``PROT_MTE`` not set on any of the initial memory maps"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:177
msgid ""
"On ``fork()``, the new process inherits the parent's configuration and "
"memory map attributes with the exception of the ``madvise()`` ranges with "
"``MADV_WIPEONFORK`` which will have the data and tags cleared (set to 0)."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:183
msgid "The ``ptrace()`` interface"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:185
msgid ""
"``PTRACE_PEEKMTETAGS`` and ``PTRACE_POKEMTETAGS`` allow a tracer to read the "
"tags from or set the tags to a tracee's address space. The ``ptrace()`` "
"system call is invoked as ``ptrace(request, pid, addr, data)`` where:"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:190
msgid "``request`` - one of ``PTRACE_PEEKMTETAGS`` or ``PTRACE_POKEMTETAGS``."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:191
msgid "``pid`` - the tracee's PID."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:192
msgid "``addr`` - address in the tracee's address space."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:193
msgid ""
"``data`` - pointer to a ``struct iovec`` where ``iov_base`` points to a "
"buffer of ``iov_len`` length in the tracer's address space."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:196
msgid ""
"The tags in the tracer's ``iov_base`` buffer are represented as one 4-bit "
"tag per byte and correspond to a 16-byte MTE tag granule in the tracee's "
"address space."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:200
msgid ""
"**Note**: If ``addr`` is not aligned to a 16-byte granule, the kernel will "
"use the corresponding aligned address."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:203
msgid "``ptrace()`` return value:"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:205
msgid ""
"0 - tags were copied, the tracer's ``iov_len`` was updated to the number of "
"tags transferred. This may be smaller than the requested ``iov_len`` if the "
"requested address range in the tracee's or the tracer's space cannot be "
"accessed or does not have valid tags."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:209
msgid "``-EPERM`` - the specified process cannot be traced."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:210
msgid ""
"``-EIO`` - the tracee's address range cannot be accessed (e.g. invalid "
"address) and no tags copied. ``iov_len`` not updated."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:212
msgid ""
"``-EFAULT`` - fault on accessing the tracer's memory (``struct iovec`` or "
"``iov_base`` buffer) and no tags copied. ``iov_len`` not updated."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:214
msgid ""
"``-EOPNOTSUPP`` - the tracee's address does not have valid tags (never "
"mapped with the ``PROT_MTE`` flag). ``iov_len`` not updated."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:217
msgid ""
"**Note**: There are no transient errors for the requests above, so user "
"programs should not retry in case of a non-zero system call return."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:220
msgid ""
"``PTRACE_GETREGSET`` and ``PTRACE_SETREGSET`` with ``addr == "
"``NT_ARM_TAGGED_ADDR_CTRL`` allow ``ptrace()`` access to the tagged address "
"ABI control and MTE configuration of a process as per the ``prctl()`` "
"options described in Documentation/arch/arm64/tagged-address-abi.rst and "
"above. The corresponding ``regset`` is 1 element of 8 bytes "
"(``sizeof(long))``)."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:228
msgid "Core dump support"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:230
msgid ""
"The allocation tags for user memory mapped with ``PROT_MTE`` are dumped in "
"the core file as additional ``PT_AARCH64_MEMTAG_MTE`` segments. The program "
"header for such segment is defined as:"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:0
msgid "``p_type``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:234
msgid "``PT_AARCH64_MEMTAG_MTE``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:0
msgid "``p_flags``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:235
#: ../../../arch/arm64/memory-tagging-extension.rst:239
#: ../../../arch/arm64/memory-tagging-extension.rst:244
msgid "0"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:0
msgid "``p_offset``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:236
msgid "segment file offset"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:0
msgid "``p_vaddr``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:237
msgid "segment virtual address, same as the corresponding ``PT_LOAD`` segment"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:0
msgid "``p_paddr``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:0
msgid "``p_filesz``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:240
msgid ""
"segment size in file, calculated as ``p_mem_sz / 32`` (two 4-bit tags cover "
"32 bytes of memory)"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:0
msgid "``p_memsz``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:242
msgid "segment size in memory, same as the corresponding ``PT_LOAD`` segment"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:0
msgid "``p_align``"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:246
msgid ""
"The tags are stored in the core file at ``p_offset`` as two 4-bit tags in a "
"byte. With the tag granule of 16 bytes, a 4K page requires 128 bytes in the "
"core file."
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:251
msgid "Example of correct usage"
msgstr ""

#: ../../../arch/arm64/memory-tagging-extension.rst:253
msgid "*MTE Example code*"
msgstr ""
