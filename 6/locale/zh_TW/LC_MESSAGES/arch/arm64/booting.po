# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm64/booting.rst:3
msgid "Booting AArch64 Linux"
msgstr ""

#: ../../../arch/arm64/booting.rst:5
msgid "Author: Will Deacon <will.deacon@arm.com>"
msgstr ""

#: ../../../arch/arm64/booting.rst:7
msgid "Date  : 07 September 2012"
msgstr ""

#: ../../../arch/arm64/booting.rst:9
msgid ""
"This document is based on the ARM booting document by Russell King and is "
"relevant to all public releases of the AArch64 Linux kernel."
msgstr ""

#: ../../../arch/arm64/booting.rst:12
msgid ""
"The AArch64 exception model is made up of a number of exception levels (EL0 "
"- EL3), with EL0, EL1 and EL2 having a secure and a non-secure counterpart.  "
"EL2 is the hypervisor level, EL3 is the highest priority level and exists "
"only in secure mode. Both are architecturally optional."
msgstr ""

#: ../../../arch/arm64/booting.rst:17
msgid ""
"For the purposes of this document, we will use the term `boot loader` simply "
"to define all software that executes on the CPU(s) before control is passed "
"to the Linux kernel.  This may include secure monitor and hypervisor code, "
"or it may just be a handful of instructions for preparing a minimal boot "
"environment."
msgstr ""

#: ../../../arch/arm64/booting.rst:23
msgid ""
"Essentially, the boot loader should provide (as a minimum) the following:"
msgstr ""

#: ../../../arch/arm64/booting.rst:26
msgid "Setup and initialise the RAM"
msgstr ""

#: ../../../arch/arm64/booting.rst:27
msgid "Setup the device tree"
msgstr ""

#: ../../../arch/arm64/booting.rst:28
msgid "Decompress the kernel image"
msgstr ""

#: ../../../arch/arm64/booting.rst:29
msgid "Call the kernel image"
msgstr ""

#: ../../../arch/arm64/booting.rst:33
msgid "1. Setup and initialise RAM"
msgstr ""

#: ../../../arch/arm64/booting.rst:35 ../../../arch/arm64/booting.rst:51
#: ../../../arch/arm64/booting.rst:76
msgid "Requirement: MANDATORY"
msgstr ""

#: ../../../arch/arm64/booting.rst:37
msgid ""
"The boot loader is expected to find and initialise all RAM that the kernel "
"will use for volatile data storage in the system.  It performs this in a "
"machine dependent manner.  (It may use internal algorithms to automatically "
"locate and size all RAM, or it may use knowledge of the RAM in the machine, "
"or any other method the boot loader designer sees fit.)"
msgstr ""

#: ../../../arch/arm64/booting.rst:44
msgid ""
"For Arm Confidential Compute Realms this includes ensuring that all "
"protected RAM has a Realm IPA state (RIPAS) of \"RAM\"."
msgstr ""

#: ../../../arch/arm64/booting.rst:49
msgid "2. Setup the device tree"
msgstr ""

#: ../../../arch/arm64/booting.rst:53
msgid ""
"The device tree blob (dtb) must be placed on an 8-byte boundary and must not "
"exceed 2 megabytes in size. Since the dtb will be mapped cacheable using "
"blocks of up to 2 megabytes in size, it must not be placed within any 2M "
"region which must be mapped with any specific attributes."
msgstr ""

#: ../../../arch/arm64/booting.rst:58
msgid ""
"NOTE: versions prior to v4.2 also require that the DTB be placed within the "
"512 MB region starting at text_offset bytes below the kernel Image."
msgstr ""

#: ../../../arch/arm64/booting.rst:62
msgid "3. Decompress the kernel image"
msgstr ""

#: ../../../arch/arm64/booting.rst:64
msgid "Requirement: OPTIONAL"
msgstr ""

#: ../../../arch/arm64/booting.rst:66
msgid ""
"The AArch64 kernel does not currently provide a decompressor and therefore "
"requires decompression (gzip etc.) to be performed by the boot loader if a "
"compressed Image target (e.g. Image.gz) is used.  For bootloaders that do "
"not implement this requirement, the uncompressed Image target is available "
"instead."
msgstr ""

#: ../../../arch/arm64/booting.rst:74
msgid "4. Call the kernel image"
msgstr ""

#: ../../../arch/arm64/booting.rst:78
msgid "The decompressed kernel image contains a 64-byte header as follows::"
msgstr ""

#: ../../../arch/arm64/booting.rst:92
msgid "Header notes:"
msgstr ""

#: ../../../arch/arm64/booting.rst:94
msgid "As of v3.17, all fields are little endian unless stated otherwise."
msgstr ""

#: ../../../arch/arm64/booting.rst:96
msgid "code0/code1 are responsible for branching to stext."
msgstr ""

#: ../../../arch/arm64/booting.rst:98
msgid ""
"when booting through EFI, code0/code1 are initially skipped. res5 is an "
"offset to the PE header and the PE header has the EFI entry point "
"(efi_stub_entry).  When the stub has done its work, it jumps to code0 to "
"resume the normal boot process."
msgstr ""

#: ../../../arch/arm64/booting.rst:103
msgid ""
"Prior to v3.17, the endianness of text_offset was not specified.  In these "
"cases image_size is zero and text_offset is 0x80000 in the endianness of the "
"kernel.  Where image_size is non-zero image_size is little-endian and must "
"be respected.  Where image_size is zero, text_offset can be assumed to be "
"0x80000."
msgstr ""

#: ../../../arch/arm64/booting.rst:109
msgid ""
"The flags field (introduced in v3.17) is a little-endian 64-bit field "
"composed as follows:"
msgstr ""

#: ../../../arch/arm64/booting.rst:113
msgid "Bit 0"
msgstr ""

#: ../../../arch/arm64/booting.rst:113
msgid "Kernel endianness.  1 if BE, 0 if LE."
msgstr ""

#: ../../../arch/arm64/booting.rst:114
msgid "Bit 1-2"
msgstr ""

#: ../../../arch/arm64/booting.rst:114
msgid "Kernel Page size."
msgstr ""

#: ../../../arch/arm64/booting.rst:116
msgid "0 - Unspecified."
msgstr ""

#: ../../../arch/arm64/booting.rst:117
msgid "1 - 4K"
msgstr ""

#: ../../../arch/arm64/booting.rst:118
msgid "2 - 16K"
msgstr ""

#: ../../../arch/arm64/booting.rst:119
msgid "3 - 64K"
msgstr ""

#: ../../../arch/arm64/booting.rst:120
msgid "Bit 3"
msgstr ""

#: ../../../arch/arm64/booting.rst:120
msgid "Kernel physical placement"
msgstr ""

#: ../../../arch/arm64/booting.rst:122
msgid "0"
msgstr ""

#: ../../../arch/arm64/booting.rst:123
msgid ""
"2MB aligned base should be as close as possible to the base of DRAM, since "
"memory below it is not accessible via the linear mapping"
msgstr ""

#: ../../../arch/arm64/booting.rst:126
msgid "1"
msgstr ""

#: ../../../arch/arm64/booting.rst:127
msgid ""
"2MB aligned base such that all image_size bytes counted from the start of "
"the image are within the 48-bit addressable range of physical memory"
msgstr ""

#: ../../../arch/arm64/booting.rst:130
msgid "Bits 4-63"
msgstr ""

#: ../../../arch/arm64/booting.rst:130
msgid "Reserved."
msgstr ""

#: ../../../arch/arm64/booting.rst:133
msgid ""
"When image_size is zero, a bootloader should attempt to keep as much memory "
"as possible free for use by the kernel immediately after the end of the "
"kernel image. The amount of space required will vary depending on selected "
"features, and is effectively unbound."
msgstr ""

#: ../../../arch/arm64/booting.rst:138
msgid ""
"The Image must be placed text_offset bytes from a 2MB aligned base address "
"anywhere in usable system RAM and called there. The region between the 2 MB "
"aligned base address and the start of the image has no special significance "
"to the kernel, and may be used for other purposes. At least image_size bytes "
"from the start of the image must be free for use by the kernel. NOTE: "
"versions prior to v4.6 cannot make use of memory below the physical offset "
"of the Image so it is recommended that the Image be placed as close as "
"possible to the start of system RAM."
msgstr ""

#: ../../../arch/arm64/booting.rst:148
msgid ""
"If an initrd/initramfs is passed to the kernel at boot, it must reside "
"entirely within a 1 GB aligned physical memory window of up to 32 GB in size "
"that fully covers the kernel Image as well."
msgstr ""

#: ../../../arch/arm64/booting.rst:152
msgid ""
"Any memory described to the kernel (even that below the start of the image) "
"which is not marked as reserved from the kernel (e.g., with a memreserve "
"region in the device tree) will be considered as available to the kernel."
msgstr ""

#: ../../../arch/arm64/booting.rst:157
msgid "Before jumping into the kernel, the following conditions must be met:"
msgstr ""

#: ../../../arch/arm64/booting.rst:159
msgid ""
"Quiesce all DMA capable devices so that memory does not get corrupted by "
"bogus network packets or disk data.  This will save you many hours of debug."
msgstr ""

#: ../../../arch/arm64/booting.rst:163
msgid "Primary CPU general-purpose register settings:"
msgstr ""

#: ../../../arch/arm64/booting.rst:165
msgid "x0 = physical address of device tree blob (dtb) in system RAM."
msgstr ""

#: ../../../arch/arm64/booting.rst:166 ../../../arch/arm64/booting.rst:595
msgid "x1 = 0 (reserved for future use)"
msgstr ""

#: ../../../arch/arm64/booting.rst:167 ../../../arch/arm64/booting.rst:596
msgid "x2 = 0 (reserved for future use)"
msgstr ""

#: ../../../arch/arm64/booting.rst:168 ../../../arch/arm64/booting.rst:597
msgid "x3 = 0 (reserved for future use)"
msgstr ""

#: ../../../arch/arm64/booting.rst:170
msgid "CPU mode"
msgstr ""

#: ../../../arch/arm64/booting.rst:172
msgid ""
"All forms of interrupts must be masked in PSTATE.DAIF (Debug, SError, IRQ "
"and FIQ). The CPU must be in non-secure state, either in EL2 (RECOMMENDED in "
"order to have access to the virtualisation extensions), or in EL1."
msgstr ""

#: ../../../arch/arm64/booting.rst:177
msgid "Caches, MMUs"
msgstr ""

#: ../../../arch/arm64/booting.rst:179
msgid "The MMU must be off."
msgstr ""

#: ../../../arch/arm64/booting.rst:181
msgid ""
"The instruction cache may be on or off, and must not hold any stale entries "
"corresponding to the loaded kernel image."
msgstr ""

#: ../../../arch/arm64/booting.rst:184
msgid ""
"The address range corresponding to the loaded kernel image must be cleaned "
"to the PoC. In the presence of a system cache or other coherent masters with "
"caches enabled, this will typically require cache maintenance by VA rather "
"than set/way operations. System caches which respect the architected cache "
"maintenance by VA operations must be configured and may be enabled. System "
"caches which do not respect architected cache maintenance by VA operations "
"(not recommended) must be configured and disabled."
msgstr ""

#: ../../../arch/arm64/booting.rst:193
msgid "Architected timers"
msgstr ""

#: ../../../arch/arm64/booting.rst:195
msgid ""
"CNTFRQ must be programmed with the timer frequency and CNTVOFF must be "
"programmed with a consistent value on all CPUs.  If entering the kernel at "
"EL1, CNTHCTL_EL2 must have EL1PCTEN (bit 0) set where available."
msgstr ""

#: ../../../arch/arm64/booting.rst:200
msgid "Coherency"
msgstr ""

#: ../../../arch/arm64/booting.rst:202
msgid ""
"All CPUs to be booted by the kernel must be part of the same coherency "
"domain on entry to the kernel.  This may require IMPLEMENTATION DEFINED "
"initialisation to enable the receiving of maintenance operations on each CPU."
msgstr ""

#: ../../../arch/arm64/booting.rst:207
msgid "System registers"
msgstr ""

#: ../../../arch/arm64/booting.rst:209
msgid ""
"All writable architected system registers at or below the exception level "
"where the kernel image will be entered must be initialised by software at a "
"higher exception level to prevent execution in an UNKNOWN state."
msgstr ""

#: ../../../arch/arm64/booting.rst:214
msgid "For all systems: - If EL3 is present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:217
msgid ""
"SCR_EL3.FIQ must have the same value across all CPUs the kernel is executing "
"on."
msgstr ""

#: ../../../arch/arm64/booting.rst:219
msgid ""
"The value of SCR_EL3.FIQ must be the same as the one present at boot time "
"whenever the kernel is executing."
msgstr ""

#: ../../../arch/arm64/booting.rst:222 ../../../arch/arm64/booting.rst:328
#: ../../../arch/arm64/booting.rst:334 ../../../arch/arm64/booting.rst:340
msgid "If EL3 is present and the kernel is entered at EL2:"
msgstr ""

#: ../../../arch/arm64/booting.rst:224
msgid "SCR_EL3.HCE (bit 8) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:226
msgid "For systems with a GICv5 interrupt controller to be used in v5 mode:"
msgstr ""

#: ../../../arch/arm64/booting.rst:228 ../../../arch/arm64/booting.rst:363
#: ../../../arch/arm64/booting.rst:383 ../../../arch/arm64/booting.rst:408
#: ../../../arch/arm64/booting.rst:418 ../../../arch/arm64/booting.rst:428
#: ../../../arch/arm64/booting.rst:438 ../../../arch/arm64/booting.rst:459
#: ../../../arch/arm64/booting.rst:471 ../../../arch/arm64/booting.rst:484
#: ../../../arch/arm64/booting.rst:494 ../../../arch/arm64/booting.rst:518
msgid "If the kernel is entered at EL1 and EL2 is present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:230
msgid ""
"ICH_HFGRTR_EL2.ICC_PPI_ACTIVERn_EL1 (bit 20) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:231
msgid ""
"ICH_HFGRTR_EL2.ICC_PPI_PRIORITYRn_EL1 (bit 19) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:232
msgid "ICH_HFGRTR_EL2.ICC_PPI_PENDRn_EL1 (bit 18) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:233
msgid ""
"ICH_HFGRTR_EL2.ICC_PPI_ENABLERn_EL1 (bit 17) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:234
msgid "ICH_HFGRTR_EL2.ICC_PPI_HMRn_EL1 (bit 16) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:235
msgid "ICH_HFGRTR_EL2.ICC_IAFFIDR_EL1 (bit 7) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:236
msgid "ICH_HFGRTR_EL2.ICC_ICSR_EL1 (bit 6) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:237
msgid "ICH_HFGRTR_EL2.ICC_PCR_EL1 (bit 5) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:238
msgid "ICH_HFGRTR_EL2.ICC_HPPIR_EL1 (bit 4) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:239
msgid "ICH_HFGRTR_EL2.ICC_HAPR_EL1 (bit 3) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:240
msgid "ICH_HFGRTR_EL2.ICC_CR0_EL1 (bit 2) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:241
msgid "ICH_HFGRTR_EL2.ICC_IDRn_EL1 (bit 1) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:242
msgid "ICH_HFGRTR_EL2.ICC_APR_EL1 (bit 0) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:244
msgid ""
"ICH_HFGWTR_EL2.ICC_PPI_ACTIVERn_EL1 (bit 20) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:245
msgid ""
"ICH_HFGWTR_EL2.ICC_PPI_PRIORITYRn_EL1 (bit 19) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:246
msgid "ICH_HFGWTR_EL2.ICC_PPI_PENDRn_EL1 (bit 18) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:247
msgid ""
"ICH_HFGWTR_EL2.ICC_PPI_ENABLERn_EL1 (bit 17) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:248
msgid "ICH_HFGWTR_EL2.ICC_ICSR_EL1 (bit 6) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:249
msgid "ICH_HFGWTR_EL2.ICC_PCR_EL1 (bit 5) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:250
msgid "ICH_HFGWTR_EL2.ICC_CR0_EL1 (bit 2) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:251
msgid "ICH_HFGWTR_EL2.ICC_APR_EL1 (bit 0) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:253
msgid "ICH_HFGITR_EL2.GICRCDNMIA (bit 10) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:254
msgid "ICH_HFGITR_EL2.GICRCDIA (bit 9) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:255
msgid "ICH_HFGITR_EL2.GICCDDI (bit 8) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:256
msgid "ICH_HFGITR_EL2.GICCDEOI (bit 7) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:257
msgid "ICH_HFGITR_EL2.GICCDHM (bit 6) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:258
msgid "ICH_HFGITR_EL2.GICCDRCFG (bit 5) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:259
msgid "ICH_HFGITR_EL2.GICCDPEND (bit 4) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:260
msgid "ICH_HFGITR_EL2.GICCDAFF (bit 3) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:261
msgid "ICH_HFGITR_EL2.GICCDPRI (bit 2) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:262
msgid "ICH_HFGITR_EL2.GICCDDIS (bit 1) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:263
msgid "ICH_HFGITR_EL2.GICCDEN (bit 0) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:265
msgid "The DT or ACPI tables must describe a GICv5 interrupt controller."
msgstr ""

#: ../../../arch/arm64/booting.rst:267
msgid ""
"For systems with a GICv3 interrupt controller to be used in v3 mode: - If "
"EL3 is present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:270
msgid "ICC_SRE_EL3.Enable (bit 3) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:271
msgid "ICC_SRE_EL3.SRE (bit 0) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:272
msgid ""
"ICC_CTLR_EL3.PMHE (bit 6) must be set to the same value across all CPUs the "
"kernel is executing on, and must stay constant for the lifetime of the "
"kernel."
msgstr ""

#: ../../../arch/arm64/booting.rst:276 ../../../arch/arm64/booting.rst:290
#: ../../../arch/arm64/booting.rst:303 ../../../arch/arm64/booting.rst:319
msgid "If the kernel is entered at EL1:"
msgstr ""

#: ../../../arch/arm64/booting.rst:278
msgid "ICC_SRE_EL2.Enable (bit 3) must be initialised to 0b1"
msgstr ""

#: ../../../arch/arm64/booting.rst:279
msgid "ICC_SRE_EL2.SRE (bit 0) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:281
msgid "The DT or ACPI tables must describe a GICv3 interrupt controller."
msgstr ""

#: ../../../arch/arm64/booting.rst:283
msgid ""
"For systems with a GICv3 interrupt controller to be used in compatibility "
"(v2) mode:"
msgstr ""

#: ../../../arch/arm64/booting.rst:286 ../../../arch/arm64/booting.rst:298
#: ../../../arch/arm64/booting.rst:310 ../../../arch/arm64/booting.rst:346
#: ../../../arch/arm64/booting.rst:374 ../../../arch/arm64/booting.rst:404
#: ../../../arch/arm64/booting.rst:414 ../../../arch/arm64/booting.rst:424
#: ../../../arch/arm64/booting.rst:434 ../../../arch/arm64/booting.rst:455
#: ../../../arch/arm64/booting.rst:480 ../../../arch/arm64/booting.rst:490
#: ../../../arch/arm64/booting.rst:510 ../../../arch/arm64/booting.rst:538
#: ../../../arch/arm64/booting.rst:544
msgid "If EL3 is present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:288
msgid "ICC_SRE_EL3.SRE (bit 0) must be initialised to 0b0."
msgstr ""

#: ../../../arch/arm64/booting.rst:292
msgid "ICC_SRE_EL2.SRE (bit 0) must be initialised to 0b0."
msgstr ""

#: ../../../arch/arm64/booting.rst:294
msgid "The DT or ACPI tables must describe a GICv2 interrupt controller."
msgstr ""

#: ../../../arch/arm64/booting.rst:296
msgid "For CPUs with pointer authentication functionality:"
msgstr ""

#: ../../../arch/arm64/booting.rst:300
msgid "SCR_EL3.APK (bit 16) must be initialised to 0b1"
msgstr ""

#: ../../../arch/arm64/booting.rst:301
msgid "SCR_EL3.API (bit 17) must be initialised to 0b1"
msgstr ""

#: ../../../arch/arm64/booting.rst:305
msgid "HCR_EL2.APK (bit 40) must be initialised to 0b1"
msgstr ""

#: ../../../arch/arm64/booting.rst:306
msgid "HCR_EL2.API (bit 41) must be initialised to 0b1"
msgstr ""

#: ../../../arch/arm64/booting.rst:308
msgid "For CPUs with Activity Monitors Unit v1 (AMUv1) extension present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:312
msgid "CPTR_EL3.TAM (bit 30) must be initialised to 0b0"
msgstr ""

#: ../../../arch/arm64/booting.rst:313
msgid "CPTR_EL2.TAM (bit 30) must be initialised to 0b0"
msgstr ""

#: ../../../arch/arm64/booting.rst:314 ../../../arch/arm64/booting.rst:321
msgid "AMCNTENSET0_EL0 must be initialised to 0b1111"
msgstr ""

#: ../../../arch/arm64/booting.rst:315 ../../../arch/arm64/booting.rst:322
msgid ""
"AMCNTENSET1_EL0 must be initialised to a platform specific value having 0b1 "
"set for the corresponding bit for each of the auxiliary counters present."
msgstr ""

#: ../../../arch/arm64/booting.rst:326
msgid "For CPUs with the Fine Grained Traps (FEAT_FGT) extension present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:330
msgid "SCR_EL3.FGTEn (bit 27) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:332
msgid "For CPUs with the Fine Grained Traps 2 (FEAT_FGT2) extension present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:336
msgid "SCR_EL3.FGTEn2 (bit 59) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:338
msgid "For CPUs with support for HCRX_EL2 (FEAT_HCX) present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:342
msgid "SCR_EL3.HXEn (bit 38) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:344
msgid "For CPUs with Advanced SIMD and floating point support:"
msgstr ""

#: ../../../arch/arm64/booting.rst:348
msgid "CPTR_EL3.TFP (bit 10) must be initialised to 0b0."
msgstr ""

#: ../../../arch/arm64/booting.rst:350
msgid "If EL2 is present and the kernel is entered at EL1:"
msgstr ""

#: ../../../arch/arm64/booting.rst:352
msgid "CPTR_EL2.TFP (bit 10) must be initialised to 0b0."
msgstr ""

#: ../../../arch/arm64/booting.rst:354
msgid "For CPUs with the Scalable Vector Extension (FEAT_SVE) present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:356
msgid "if EL3 is present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:358
msgid "CPTR_EL3.EZ (bit 8) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:360
msgid ""
"ZCR_EL3.LEN must be initialised to the same value for all CPUs the kernel is "
"executed on."
msgstr ""

#: ../../../arch/arm64/booting.rst:365
msgid "CPTR_EL2.TZ (bit 8) must be initialised to 0b0."
msgstr ""

#: ../../../arch/arm64/booting.rst:367
msgid "CPTR_EL2.ZEN (bits 17:16) must be initialised to 0b11."
msgstr ""

#: ../../../arch/arm64/booting.rst:369
msgid ""
"ZCR_EL2.LEN must be initialised to the same value for all CPUs the kernel "
"will execute on."
msgstr ""

#: ../../../arch/arm64/booting.rst:372
msgid "For CPUs with the Scalable Matrix Extension (FEAT_SME):"
msgstr ""

#: ../../../arch/arm64/booting.rst:376
msgid "CPTR_EL3.ESM (bit 12) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:378
msgid "SCR_EL3.EnTP2 (bit 41) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:380
msgid ""
"SMCR_EL3.LEN must be initialised to the same value for all CPUs the kernel "
"will execute on."
msgstr ""

#: ../../../arch/arm64/booting.rst:385
msgid "CPTR_EL2.TSM (bit 12) must be initialised to 0b0."
msgstr ""

#: ../../../arch/arm64/booting.rst:387
msgid "CPTR_EL2.SMEN (bits 25:24) must be initialised to 0b11."
msgstr ""

#: ../../../arch/arm64/booting.rst:389
msgid "SCTLR_EL2.EnTP2 (bit 60) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:391
msgid ""
"SMCR_EL2.LEN must be initialised to the same value for all CPUs the kernel "
"will execute on."
msgstr ""

#: ../../../arch/arm64/booting.rst:394
msgid "HWFGRTR_EL2.nTPIDR2_EL0 (bit 55) must be initialised to 0b01."
msgstr ""

#: ../../../arch/arm64/booting.rst:396
msgid "HWFGWTR_EL2.nTPIDR2_EL0 (bit 55) must be initialised to 0b01."
msgstr ""

#: ../../../arch/arm64/booting.rst:398
msgid "HWFGRTR_EL2.nSMPRI_EL1 (bit 54) must be initialised to 0b01."
msgstr ""

#: ../../../arch/arm64/booting.rst:400
msgid "HWFGWTR_EL2.nSMPRI_EL1 (bit 54) must be initialised to 0b01."
msgstr ""

#: ../../../arch/arm64/booting.rst:402
msgid ""
"For CPUs with the Scalable Matrix Extension FA64 feature (FEAT_SME_FA64):"
msgstr ""

#: ../../../arch/arm64/booting.rst:406
msgid "SMCR_EL3.FA64 (bit 31) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:410
msgid "SMCR_EL2.FA64 (bit 31) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:412
msgid "For CPUs with the Memory Tagging Extension feature (FEAT_MTE2):"
msgstr ""

#: ../../../arch/arm64/booting.rst:416
msgid "SCR_EL3.ATA (bit 26) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:420
msgid "HCR_EL2.ATA (bit 56) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:422
msgid "For CPUs with the Scalable Matrix Extension version 2 (FEAT_SME2):"
msgstr ""

#: ../../../arch/arm64/booting.rst:426
msgid "SMCR_EL3.EZT0 (bit 30) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:430
msgid "SMCR_EL2.EZT0 (bit 30) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:432
msgid "For CPUs with the Branch Record Buffer Extension (FEAT_BRBE):"
msgstr ""

#: ../../../arch/arm64/booting.rst:436
msgid "MDCR_EL3.SBRBE (bits 33:32) must be initialised to 0b01 or 0b11."
msgstr ""

#: ../../../arch/arm64/booting.rst:440
msgid "BRBCR_EL2.CC (bit 3) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:441
msgid "BRBCR_EL2.MPRED (bit 4) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:443
msgid "HDFGRTR_EL2.nBRBDATA (bit 61) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:444
msgid "HDFGRTR_EL2.nBRBCTL  (bit 60) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:445
msgid "HDFGRTR_EL2.nBRBIDR  (bit 59) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:447
msgid "HDFGWTR_EL2.nBRBDATA (bit 61) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:448
msgid "HDFGWTR_EL2.nBRBCTL  (bit 60) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:450
msgid "HFGITR_EL2.nBRBIALL (bit 56) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:451
msgid "HFGITR_EL2.nBRBINJ  (bit 55) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:453
msgid "For CPUs with the Performance Monitors Extension (FEAT_PMUv3p9):"
msgstr ""

#: ../../../arch/arm64/booting.rst:457
msgid "MDCR_EL3.EnPM2 (bit 7) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:461
msgid "HDFGRTR2_EL2.nPMICNTR_EL0 (bit 2) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:462
msgid "HDFGRTR2_EL2.nPMICFILTR_EL0 (bit 3) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:463
msgid "HDFGRTR2_EL2.nPMUACR_EL1 (bit 4) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:465
msgid "HDFGWTR2_EL2.nPMICNTR_EL0 (bit 2) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:466
msgid "HDFGWTR2_EL2.nPMICFILTR_EL0 (bit 3) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:467
msgid "HDFGWTR2_EL2.nPMUACR_EL1 (bit 4) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:469
msgid "For CPUs with Memory Copy and Memory Set instructions (FEAT_MOPS):"
msgstr ""

#: ../../../arch/arm64/booting.rst:473
msgid "HCRX_EL2.MSCEn (bit 11) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:475
msgid ""
"HCRX_EL2.MCE2 (bit 10) must be initialised to 0b1 and the hypervisor must "
"handle MOPS exceptions as described in :ref:`arm64_mops_hyp`."
msgstr ""

#: ../../../arch/arm64/booting.rst:478
msgid ""
"For CPUs with the Extended Translation Control Register feature (FEAT_TCR2):"
msgstr ""

#: ../../../arch/arm64/booting.rst:482
msgid "SCR_EL3.TCR2En (bit 43) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:486
msgid "HCRX_EL2.TCR2En (bit 14) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:488
msgid ""
"For CPUs with the Stage 1 Permission Indirection Extension feature "
"(FEAT_S1PIE):"
msgstr ""

#: ../../../arch/arm64/booting.rst:492
msgid "SCR_EL3.PIEn (bit 45) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:496
msgid "HFGRTR_EL2.nPIR_EL1 (bit 58) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:498
msgid "HFGWTR_EL2.nPIR_EL1 (bit 58) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:500
msgid "HFGRTR_EL2.nPIRE0_EL1 (bit 57) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:502
msgid "HFGRWR_EL2.nPIRE0_EL1 (bit 57) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:504
msgid "For CPUs with Guarded Control Stacks (FEAT_GCS):"
msgstr ""

#: ../../../arch/arm64/booting.rst:506
msgid "GCSCR_EL1 must be initialised to 0."
msgstr ""

#: ../../../arch/arm64/booting.rst:508
msgid "GCSCRE0_EL1 must be initialised to 0."
msgstr ""

#: ../../../arch/arm64/booting.rst:512
msgid "SCR_EL3.GCSEn (bit 39) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:514
msgid "If EL2 is present:"
msgstr ""

#: ../../../arch/arm64/booting.rst:516
msgid "GCSCR_EL2 must be initialised to 0."
msgstr ""

#: ../../../arch/arm64/booting.rst:520
msgid "HCRX_EL2.GCSEn must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:522
msgid "HFGITR_EL2.nGCSEPP (bit 59) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:524
msgid "HFGITR_EL2.nGCSSTR_EL1 (bit 58) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:526
msgid "HFGITR_EL2.nGCSPUSHM_EL1 (bit 57) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:528
msgid "HFGRTR_EL2.nGCS_EL1 (bit 53) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:530
msgid "HFGRTR_EL2.nGCS_EL0 (bit 52) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:532
msgid "HFGWTR_EL2.nGCS_EL1 (bit 53) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:534
msgid "HFGWTR_EL2.nGCS_EL0 (bit 52) must be initialised to 0b1."
msgstr ""

#: ../../../arch/arm64/booting.rst:536
msgid "For CPUs with debug architecture i.e FEAT_Debugv8pN (all versions):"
msgstr ""

#: ../../../arch/arm64/booting.rst:540
msgid "MDCR_EL3.TDA (bit 9) must be initialized to 0b0"
msgstr ""

#: ../../../arch/arm64/booting.rst:542
msgid "For CPUs with FEAT_PMUv3:"
msgstr ""

#: ../../../arch/arm64/booting.rst:546
msgid "MDCR_EL3.TPM (bit 6) must be initialized to 0b0"
msgstr ""

#: ../../../arch/arm64/booting.rst:548
msgid ""
"The requirements described above for CPU mode, caches, MMUs, architected "
"timers, coherency and system registers apply to all CPUs.  All CPUs must "
"enter the kernel in the same exception level.  Where the values documented "
"disable traps it is permissible for these traps to be enabled so long as "
"those traps are handled transparently by higher exception levels as though "
"the values documented were set."
msgstr ""

#: ../../../arch/arm64/booting.rst:555
msgid ""
"The boot loader is expected to enter the kernel on each CPU in the following "
"manner:"
msgstr ""

#: ../../../arch/arm64/booting.rst:558
msgid ""
"The primary CPU must jump directly to the first instruction of the kernel "
"image.  The device tree blob passed by this CPU must contain an 'enable-"
"method' property for each cpu node.  The supported enable-methods are "
"described below."
msgstr ""

#: ../../../arch/arm64/booting.rst:563
msgid ""
"It is expected that the bootloader will generate these device tree "
"properties and insert them into the blob prior to kernel entry."
msgstr ""

#: ../../../arch/arm64/booting.rst:566
msgid ""
"CPUs with a \"spin-table\" enable-method must have a 'cpu-release-addr' "
"property in their cpu node.  This property identifies a naturally-aligned 64-"
"bit zero-initalised memory location."
msgstr ""

#: ../../../arch/arm64/booting.rst:570
msgid ""
"These CPUs should spin outside of the kernel in a reserved area of memory "
"(communicated to the kernel by a /memreserve/ region in the device tree) "
"polling their cpu-release-addr location, which must be contained in the "
"reserved region.  A wfe instruction may be inserted to reduce the overhead "
"of the busy-loop and a sev will be issued by the primary CPU.  When a read "
"of the location pointed to by the cpu-release-addr returns a non-zero value, "
"the CPU must jump to this value.  The value will be written as a single 64-"
"bit little-endian value, so CPUs must convert the read value to their native "
"endianness before jumping to it."
msgstr ""

#: ../../../arch/arm64/booting.rst:581
msgid ""
"CPUs with a \"psci\" enable method should remain outside of the kernel (i.e. "
"outside of the regions of memory described to the kernel in the memory node, "
"or in a reserved area of memory described to the kernel by a /memreserve/ "
"region in the device tree).  The kernel will issue CPU_ON calls as described "
"in ARM document number ARM DEN 0022A (\"Power State Coordination Interface "
"System Software on ARM processors\") to bring CPUs into the kernel."
msgstr ""

#: ../../../arch/arm64/booting.rst:589
msgid ""
"The device tree should contain a 'psci' node, as described in Documentation/"
"devicetree/bindings/arm/psci.yaml."
msgstr ""

#: ../../../arch/arm64/booting.rst:592
msgid "Secondary CPU general-purpose register settings"
msgstr ""

#: ../../../arch/arm64/booting.rst:594
msgid "x0 = 0 (reserved for future use)"
msgstr ""
