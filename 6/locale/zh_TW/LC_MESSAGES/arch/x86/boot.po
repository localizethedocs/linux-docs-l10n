# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/boot.rst:5
msgid "The Linux/x86 Boot Protocol"
msgstr ""

#: ../../../arch/x86/boot.rst:7
msgid ""
"On the x86 platform, the Linux kernel uses a rather complicated boot "
"convention.  This has evolved partially due to historical aspects, as well "
"as the desire in the early days to have the kernel itself be a bootable "
"image, the complicated PC memory model and due to changed expectations in "
"the PC industry caused by the effective demise of real-mode DOS as a "
"mainstream operating system."
msgstr ""

#: ../../../arch/x86/boot.rst:14
msgid "Currently, the following versions of the Linux/x86 boot protocol exist."
msgstr ""

#: ../../../arch/x86/boot.rst:17
msgid "Old kernels"
msgstr ""

#: ../../../arch/x86/boot.rst:17
msgid ""
"zImage/Image support only.  Some very early kernels may not even support a "
"command line."
msgstr ""

#: ../../../arch/x86/boot.rst:20
msgid "Protocol 2.00"
msgstr ""

#: ../../../arch/x86/boot.rst:20
msgid ""
"(Kernel 1.3.73) Added bzImage and initrd support, as well as a formalized "
"way to communicate between the boot loader and the kernel.  setup.S made "
"relocatable, although the traditional setup area still assumed writable."
msgstr ""

#: ../../../arch/x86/boot.rst:26
msgid "Protocol 2.01"
msgstr ""

#: ../../../arch/x86/boot.rst:26
msgid "(Kernel 1.3.76) Added a heap overrun warning."
msgstr ""

#: ../../../arch/x86/boot.rst:28
msgid "Protocol 2.02"
msgstr ""

#: ../../../arch/x86/boot.rst:28
msgid ""
"(Kernel 2.4.0-test3-pre3) New command line protocol. Lower the conventional "
"memory ceiling.  No overwrite of the traditional setup area, thus making "
"booting safe for systems which use the EBDA from SMM or 32-bit BIOS entry "
"points.  zImage deprecated but still supported."
msgstr ""

#: ../../../arch/x86/boot.rst:35
msgid "Protocol 2.03"
msgstr ""

#: ../../../arch/x86/boot.rst:35
msgid ""
"(Kernel 2.4.18-pre1) Explicitly makes the highest possible initrd address "
"available to the bootloader."
msgstr ""

#: ../../../arch/x86/boot.rst:38
msgid "Protocol 2.04"
msgstr ""

#: ../../../arch/x86/boot.rst:38
msgid "(Kernel 2.6.14) Extend the syssize field to four bytes."
msgstr ""

#: ../../../arch/x86/boot.rst:40
msgid "Protocol 2.05"
msgstr ""

#: ../../../arch/x86/boot.rst:40
msgid ""
"(Kernel 2.6.20) Make protected mode kernel relocatable. Introduce "
"relocatable_kernel and kernel_alignment fields."
msgstr ""

#: ../../../arch/x86/boot.rst:43
msgid "Protocol 2.06"
msgstr ""

#: ../../../arch/x86/boot.rst:43
msgid ""
"(Kernel 2.6.22) Added a field that contains the size of the boot command "
"line."
msgstr ""

#: ../../../arch/x86/boot.rst:46
msgid "Protocol 2.07"
msgstr ""

#: ../../../arch/x86/boot.rst:46
msgid ""
"(Kernel 2.6.24) Added paravirtualised boot protocol. Introduced "
"hardware_subarch and hardware_subarch_data and KEEP_SEGMENTS flag in "
"load_flags."
msgstr ""

#: ../../../arch/x86/boot.rst:50
msgid "Protocol 2.08"
msgstr ""

#: ../../../arch/x86/boot.rst:50
msgid ""
"(Kernel 2.6.26) Added crc32 checksum and ELF format payload. Introduced "
"payload_offset and payload_length fields to aid in locating the payload."
msgstr ""

#: ../../../arch/x86/boot.rst:54
msgid "Protocol 2.09"
msgstr ""

#: ../../../arch/x86/boot.rst:54
msgid ""
"(Kernel 2.6.26) Added a field of 64-bit physical pointer to single linked "
"list of struct setup_data."
msgstr ""

#: ../../../arch/x86/boot.rst:57
msgid "Protocol 2.10"
msgstr ""

#: ../../../arch/x86/boot.rst:57
msgid ""
"(Kernel 2.6.31) Added a protocol for relaxed alignment beyond the "
"kernel_alignment added, new init_size and pref_address fields.  Added "
"extended boot loader IDs."
msgstr ""

#: ../../../arch/x86/boot.rst:61
msgid "Protocol 2.11"
msgstr ""

#: ../../../arch/x86/boot.rst:61
msgid ""
"(Kernel 3.6) Added a field for offset of EFI handover protocol entry point."
msgstr ""

#: ../../../arch/x86/boot.rst:64
msgid "Protocol 2.12"
msgstr ""

#: ../../../arch/x86/boot.rst:64
msgid ""
"(Kernel 3.8) Added the xloadflags field and extension fields to struct "
"boot_params for loading bzImage and ramdisk above 4G in 64bit."
msgstr ""

#: ../../../arch/x86/boot.rst:68
msgid "Protocol 2.13"
msgstr ""

#: ../../../arch/x86/boot.rst:68
msgid ""
"(Kernel 3.14) Support 32- and 64-bit flags being set in xloadflags to "
"support booting a 64-bit kernel from 32-bit EFI"
msgstr ""

#: ../../../arch/x86/boot.rst:72
msgid "Protocol 2.14"
msgstr ""

#: ../../../arch/x86/boot.rst:72
msgid ""
"BURNT BY INCORRECT COMMIT ae7e1238e68f2a472a125673ab506d49158c1889 (\"x86/"
"boot: Add ACPI RSDP address to setup_header\") DO NOT USE!!! ASSUME SAME AS "
"2.13."
msgstr ""

#: ../../../arch/x86/boot.rst:77
msgid "Protocol 2.15"
msgstr ""

#: ../../../arch/x86/boot.rst:77
msgid "(Kernel 5.5) Added the kernel_info and kernel_info.setup_type_max."
msgstr ""

#: ../../../arch/x86/boot.rst:81
msgid ""
"The protocol version number should be changed only if the setup header is "
"changed. There is no need to update the version number if boot_params or "
"kernel_info are changed. Additionally, it is recommended to use xloadflags "
"(in this case the protocol version number should not be updated either) or "
"kernel_info to communicate supported Linux kernel features to the boot "
"loader. Due to very limited space available in the original setup header "
"every update to it should be considered with great care. Starting from the "
"protocol 2.15 the primary way to communicate things to the boot loader is "
"the kernel_info."
msgstr ""

#: ../../../arch/x86/boot.rst:93
msgid "Memory Layout"
msgstr ""

#: ../../../arch/x86/boot.rst:95
msgid ""
"The traditional memory map for the kernel loader, used for Image or zImage "
"kernels, typically looks like::"
msgstr ""

#: ../../../arch/x86/boot.rst:120
msgid ""
"When using bzImage, the protected-mode kernel was relocated to 0x100000 "
"(\"high memory\"), and the kernel real-mode block (boot sector, setup, and "
"stack/heap) was made relocatable to any address between 0x10000 and end of "
"low memory. Unfortunately, in protocols 2.00 and 2.01 the 0x90000+ memory "
"range is still used internally by the kernel; the 2.02 protocol resolves "
"that problem."
msgstr ""

#: ../../../arch/x86/boot.rst:127
msgid ""
"It is desirable to keep the \"memory ceiling\" -- the highest point in low "
"memory touched by the boot loader -- as low as possible, since some newer "
"BIOSes have begun to allocate some rather large amounts of memory, called "
"the Extended BIOS Data Area, near the top of low memory.  The boot loader "
"should use the \"INT 12h\" BIOS call to verify how much low memory is "
"available."
msgstr ""

#: ../../../arch/x86/boot.rst:134
msgid ""
"Unfortunately, if INT 12h reports that the amount of memory is too low, "
"there is usually nothing the boot loader can do but to report an error to "
"the user.  The boot loader should therefore be designed to take up as little "
"space in low memory as it reasonably can.  For zImage or old bzImage "
"kernels, which need data written into the 0x90000 segment, the boot loader "
"should make sure not to use memory above the 0x9A000 point; too many BIOSes "
"will break above that point."
msgstr ""

#: ../../../arch/x86/boot.rst:142
msgid ""
"For a modern bzImage kernel with boot protocol version >= 2.02, a memory "
"layout like the following is suggested::"
msgstr ""

#: ../../../arch/x86/boot.rst:172
msgid "The Real-Mode Kernel Header"
msgstr ""

#: ../../../arch/x86/boot.rst:174
msgid ""
"In the following text, and anywhere in the kernel boot sequence, \"a "
"sector\" refers to 512 bytes.  It is independent of the actual sector size "
"of the underlying medium."
msgstr ""

#: ../../../arch/x86/boot.rst:178
msgid ""
"The first step in loading a Linux kernel should be to load the real-mode "
"code (boot sector and setup code) and then examine the following header at "
"offset 0x01f1.  The real-mode code can total up to 32K, although the boot "
"loader may choose to load only the first two sectors (1K) and then examine "
"the bootup sector size."
msgstr ""

#: ../../../arch/x86/boot.rst:184
msgid "The header looks like:"
msgstr ""

#: ../../../arch/x86/boot.rst:187
msgid "Offset/Size"
msgstr ""

#: ../../../arch/x86/boot.rst:187
msgid "Proto"
msgstr ""

#: ../../../arch/x86/boot.rst:187
msgid "Name"
msgstr ""

#: ../../../arch/x86/boot.rst:187
msgid "Meaning"
msgstr ""

#: ../../../arch/x86/boot.rst:189
msgid "01F1/1"
msgstr ""

#: ../../../arch/x86/boot.rst:189
msgid "ALL(1)"
msgstr ""

#: ../../../arch/x86/boot.rst:189 ../../../arch/x86/boot.rst:271
msgid "setup_sects"
msgstr ""

#: ../../../arch/x86/boot.rst:189
msgid "The size of the setup in sectors"
msgstr ""

#: ../../../arch/x86/boot.rst:190
msgid "01F2/2"
msgstr ""

#: ../../../arch/x86/boot.rst:190 ../../../arch/x86/boot.rst:192
#: ../../../arch/x86/boot.rst:193 ../../../arch/x86/boot.rst:194
#: ../../../arch/x86/boot.rst:195 ../../../arch/x86/boot.rst:274
#: ../../../arch/x86/boot.rst:285 ../../../arch/x86/boot.rst:308
#: ../../../arch/x86/boot.rst:325 ../../../arch/x86/boot.rst:335
msgid "ALL"
msgstr ""

#: ../../../arch/x86/boot.rst:190 ../../../arch/x86/boot.rst:282
msgid "root_flags"
msgstr ""

#: ../../../arch/x86/boot.rst:190
msgid "If set, the root is mounted readonly"
msgstr ""

#: ../../../arch/x86/boot.rst:191
msgid "01F4/4"
msgstr ""

#: ../../../arch/x86/boot.rst:191
msgid "2.04+(2)"
msgstr ""

#: ../../../arch/x86/boot.rst:191 ../../../arch/x86/boot.rst:293
msgid "syssize"
msgstr ""

#: ../../../arch/x86/boot.rst:191
msgid "The size of the 32-bit code in 16-byte paras"
msgstr ""

#: ../../../arch/x86/boot.rst:192
msgid "01F8/2"
msgstr ""

#: ../../../arch/x86/boot.rst:192 ../../../arch/x86/boot.rst:305
msgid "ram_size"
msgstr ""

#: ../../../arch/x86/boot.rst:192 ../../../arch/x86/boot.rst:208
msgid "DO NOT USE - for bootsect.S use only"
msgstr ""

#: ../../../arch/x86/boot.rst:193
msgid "01FA/2"
msgstr ""

#: ../../../arch/x86/boot.rst:193 ../../../arch/x86/boot.rst:314
msgid "vid_mode"
msgstr ""

#: ../../../arch/x86/boot.rst:193
msgid "Video mode control"
msgstr ""

#: ../../../arch/x86/boot.rst:194
msgid "01FC/2"
msgstr ""

#: ../../../arch/x86/boot.rst:194 ../../../arch/x86/boot.rst:322
msgid "root_dev"
msgstr ""

#: ../../../arch/x86/boot.rst:194
msgid "Default root device number"
msgstr ""

#: ../../../arch/x86/boot.rst:195
msgid "01FE/2"
msgstr ""

#: ../../../arch/x86/boot.rst:195 ../../../arch/x86/boot.rst:332
msgid "boot_flag"
msgstr ""

#: ../../../arch/x86/boot.rst:195
msgid "0xAA55 magic number"
msgstr ""

#: ../../../arch/x86/boot.rst:196
msgid "0200/2"
msgstr ""

#: ../../../arch/x86/boot.rst:196 ../../../arch/x86/boot.rst:197
#: ../../../arch/x86/boot.rst:198 ../../../arch/x86/boot.rst:199
#: ../../../arch/x86/boot.rst:200 ../../../arch/x86/boot.rst:201
#: ../../../arch/x86/boot.rst:202 ../../../arch/x86/boot.rst:203
#: ../../../arch/x86/boot.rst:204 ../../../arch/x86/boot.rst:205
#: ../../../arch/x86/boot.rst:206 ../../../arch/x86/boot.rst:207
#: ../../../arch/x86/boot.rst:208 ../../../arch/x86/boot.rst:345
#: ../../../arch/x86/boot.rst:356 ../../../arch/x86/boot.rst:365
#: ../../../arch/x86/boot.rst:376 ../../../arch/x86/boot.rst:385
#: ../../../arch/x86/boot.rst:394 ../../../arch/x86/boot.rst:416
#: ../../../arch/x86/boot.rst:467 ../../../arch/x86/boot.rst:529
#: ../../../arch/x86/boot.rst:548 ../../../arch/x86/boot.rst:558
#: ../../../arch/x86/boot.rst:568
msgid "2.00+"
msgstr ""

#: ../../../arch/x86/boot.rst:196 ../../../arch/x86/boot.rst:342
msgid "jump"
msgstr ""

#: ../../../arch/x86/boot.rst:196
msgid "Jump instruction"
msgstr ""

#: ../../../arch/x86/boot.rst:197
msgid "0202/4"
msgstr ""

#: ../../../arch/x86/boot.rst:197 ../../../arch/x86/boot.rst:353
#: ../../../arch/x86/boot.rst:1009
msgid "header"
msgstr ""

#: ../../../arch/x86/boot.rst:197
msgid "Magic signature \"HdrS\""
msgstr ""

#: ../../../arch/x86/boot.rst:198
msgid "0206/2"
msgstr ""

#: ../../../arch/x86/boot.rst:198 ../../../arch/x86/boot.rst:362
msgid "version"
msgstr ""

#: ../../../arch/x86/boot.rst:198
msgid "Boot protocol version supported"
msgstr ""

#: ../../../arch/x86/boot.rst:199
msgid "0208/4"
msgstr ""

#: ../../../arch/x86/boot.rst:199 ../../../arch/x86/boot.rst:373
msgid "realmode_swtch"
msgstr ""

#: ../../../arch/x86/boot.rst:199 ../../../arch/x86/boot.rst:205
msgid "Boot loader hook (see below)"
msgstr ""

#: ../../../arch/x86/boot.rst:200
msgid "020C/2"
msgstr ""

#: ../../../arch/x86/boot.rst:200 ../../../arch/x86/boot.rst:382
msgid "start_sys_seg"
msgstr ""

#: ../../../arch/x86/boot.rst:200
msgid "The load-low segment (0x1000) (obsolete)"
msgstr ""

#: ../../../arch/x86/boot.rst:201
msgid "020E/2"
msgstr ""

#: ../../../arch/x86/boot.rst:201 ../../../arch/x86/boot.rst:391
msgid "kernel_version"
msgstr ""

#: ../../../arch/x86/boot.rst:201
msgid "Pointer to kernel version string"
msgstr ""

#: ../../../arch/x86/boot.rst:202
msgid "0210/1"
msgstr ""

#: ../../../arch/x86/boot.rst:202 ../../../arch/x86/boot.rst:413
msgid "type_of_loader"
msgstr ""

#: ../../../arch/x86/boot.rst:202
msgid "Boot loader identifier"
msgstr ""

#: ../../../arch/x86/boot.rst:203
msgid "0211/1"
msgstr ""

#: ../../../arch/x86/boot.rst:203 ../../../arch/x86/boot.rst:464
msgid "loadflags"
msgstr ""

#: ../../../arch/x86/boot.rst:203 ../../../arch/x86/boot.rst:217
msgid "Boot protocol option flags"
msgstr ""

#: ../../../arch/x86/boot.rst:204
msgid "0212/2"
msgstr ""

#: ../../../arch/x86/boot.rst:204 ../../../arch/x86/boot.rst:508
msgid "setup_move_size"
msgstr ""

#: ../../../arch/x86/boot.rst:204
msgid "Move to high memory size (used with hooks)"
msgstr ""

#: ../../../arch/x86/boot.rst:205
msgid "0214/4"
msgstr ""

#: ../../../arch/x86/boot.rst:205 ../../../arch/x86/boot.rst:526
msgid "code32_start"
msgstr ""

#: ../../../arch/x86/boot.rst:206
msgid "0218/4"
msgstr ""

#: ../../../arch/x86/boot.rst:206 ../../../arch/x86/boot.rst:545
msgid "ramdisk_image"
msgstr ""

#: ../../../arch/x86/boot.rst:206
msgid "initrd load address (set by boot loader)"
msgstr ""

#: ../../../arch/x86/boot.rst:207
msgid "021C/4"
msgstr ""

#: ../../../arch/x86/boot.rst:207 ../../../arch/x86/boot.rst:555
msgid "ramdisk_size"
msgstr ""

#: ../../../arch/x86/boot.rst:207
msgid "initrd size (set by boot loader)"
msgstr ""

#: ../../../arch/x86/boot.rst:208
msgid "0220/4"
msgstr ""

#: ../../../arch/x86/boot.rst:208 ../../../arch/x86/boot.rst:565
msgid "bootsect_kludge"
msgstr ""

#: ../../../arch/x86/boot.rst:209
msgid "0224/2"
msgstr ""

#: ../../../arch/x86/boot.rst:209 ../../../arch/x86/boot.rst:577
msgid "2.01+"
msgstr ""

#: ../../../arch/x86/boot.rst:209 ../../../arch/x86/boot.rst:574
msgid "heap_end_ptr"
msgstr ""

#: ../../../arch/x86/boot.rst:209
msgid "Free memory after setup end"
msgstr ""

#: ../../../arch/x86/boot.rst:210
msgid "0226/1"
msgstr ""

#: ../../../arch/x86/boot.rst:210 ../../../arch/x86/boot.rst:211
msgid "2.02+(3)"
msgstr ""

#: ../../../arch/x86/boot.rst:210 ../../../arch/x86/boot.rst:584
msgid "ext_loader_ver"
msgstr ""

#: ../../../arch/x86/boot.rst:210
msgid "Extended boot loader version"
msgstr ""

#: ../../../arch/x86/boot.rst:211
msgid "0227/1"
msgstr ""

#: ../../../arch/x86/boot.rst:211 ../../../arch/x86/boot.rst:601
msgid "ext_loader_type"
msgstr ""

#: ../../../arch/x86/boot.rst:211
msgid "Extended boot loader ID"
msgstr ""

#: ../../../arch/x86/boot.rst:212
msgid "0228/4"
msgstr ""

#: ../../../arch/x86/boot.rst:212 ../../../arch/x86/boot.rst:587
#: ../../../arch/x86/boot.rst:604 ../../../arch/x86/boot.rst:620
msgid "2.02+"
msgstr ""

#: ../../../arch/x86/boot.rst:212 ../../../arch/x86/boot.rst:617
msgid "cmd_line_ptr"
msgstr ""

#: ../../../arch/x86/boot.rst:212
msgid "32-bit pointer to the kernel command line"
msgstr ""

#: ../../../arch/x86/boot.rst:213
msgid "022C/4"
msgstr ""

#: ../../../arch/x86/boot.rst:213 ../../../arch/x86/boot.rst:638
msgid "2.03+"
msgstr ""

#: ../../../arch/x86/boot.rst:213 ../../../arch/x86/boot.rst:635
msgid "initrd_addr_max"
msgstr ""

#: ../../../arch/x86/boot.rst:213
msgid "Highest legal initrd address"
msgstr ""

#: ../../../arch/x86/boot.rst:214
msgid "0230/4"
msgstr ""

#: ../../../arch/x86/boot.rst:214 ../../../arch/x86/boot.rst:215
#: ../../../arch/x86/boot.rst:669
msgid "2.05+"
msgstr ""

#: ../../../arch/x86/boot.rst:214 ../../../arch/x86/boot.rst:649
msgid "kernel_alignment"
msgstr ""

#: ../../../arch/x86/boot.rst:214
msgid "Physical addr alignment required for kernel"
msgstr ""

#: ../../../arch/x86/boot.rst:215
msgid "0234/1"
msgstr ""

#: ../../../arch/x86/boot.rst:215 ../../../arch/x86/boot.rst:666
msgid "relocatable_kernel"
msgstr ""

#: ../../../arch/x86/boot.rst:215
msgid "Whether kernel is relocatable or not"
msgstr ""

#: ../../../arch/x86/boot.rst:216
msgid "0235/1"
msgstr ""

#: ../../../arch/x86/boot.rst:216 ../../../arch/x86/boot.rst:225
#: ../../../arch/x86/boot.rst:226 ../../../arch/x86/boot.rst:681
#: ../../../arch/x86/boot.rst:873
msgid "2.10+"
msgstr ""

#: ../../../arch/x86/boot.rst:216 ../../../arch/x86/boot.rst:678
msgid "min_alignment"
msgstr ""

#: ../../../arch/x86/boot.rst:216
msgid "Minimum alignment, as a power of two"
msgstr ""

#: ../../../arch/x86/boot.rst:217
msgid "0236/2"
msgstr ""

#: ../../../arch/x86/boot.rst:217 ../../../arch/x86/boot.rst:699
msgid "2.12+"
msgstr ""

#: ../../../arch/x86/boot.rst:217 ../../../arch/x86/boot.rst:696
msgid "xloadflags"
msgstr ""

#: ../../../arch/x86/boot.rst:218
msgid "0238/4"
msgstr ""

#: ../../../arch/x86/boot.rst:218 ../../../arch/x86/boot.rst:731
msgid "2.06+"
msgstr ""

#: ../../../arch/x86/boot.rst:218 ../../../arch/x86/boot.rst:728
msgid "cmdline_size"
msgstr ""

#: ../../../arch/x86/boot.rst:218
msgid "Maximum size of the kernel command line"
msgstr ""

#: ../../../arch/x86/boot.rst:219
msgid "023C/4"
msgstr ""

#: ../../../arch/x86/boot.rst:219 ../../../arch/x86/boot.rst:220
#: ../../../arch/x86/boot.rst:743 ../../../arch/x86/boot.rst:765
msgid "2.07+"
msgstr ""

#: ../../../arch/x86/boot.rst:219 ../../../arch/x86/boot.rst:740
msgid "hardware_subarch"
msgstr ""

#: ../../../arch/x86/boot.rst:219
msgid "Hardware subarchitecture"
msgstr ""

#: ../../../arch/x86/boot.rst:220
msgid "0240/8"
msgstr ""

#: ../../../arch/x86/boot.rst:220 ../../../arch/x86/boot.rst:762
msgid "hardware_subarch_data"
msgstr ""

#: ../../../arch/x86/boot.rst:220
msgid "Subarchitecture-specific data"
msgstr ""

#: ../../../arch/x86/boot.rst:221
msgid "0248/4"
msgstr ""

#: ../../../arch/x86/boot.rst:221 ../../../arch/x86/boot.rst:222
#: ../../../arch/x86/boot.rst:776 ../../../arch/x86/boot.rst:794
msgid "2.08+"
msgstr ""

#: ../../../arch/x86/boot.rst:221 ../../../arch/x86/boot.rst:773
msgid "payload_offset"
msgstr ""

#: ../../../arch/x86/boot.rst:221
msgid "Offset of kernel payload"
msgstr ""

#: ../../../arch/x86/boot.rst:222
msgid "024C/4"
msgstr ""

#: ../../../arch/x86/boot.rst:222 ../../../arch/x86/boot.rst:791
msgid "payload_length"
msgstr ""

#: ../../../arch/x86/boot.rst:222
msgid "Length of kernel payload"
msgstr ""

#: ../../../arch/x86/boot.rst:223
msgid "0250/8"
msgstr ""

#: ../../../arch/x86/boot.rst:223 ../../../arch/x86/boot.rst:803
msgid "2.09+"
msgstr ""

#: ../../../arch/x86/boot.rst:223 ../../../arch/x86/boot.rst:800
msgid "setup_data"
msgstr ""

#: ../../../arch/x86/boot.rst:223
msgid "64-bit physical pointer to linked list of struct setup_data"
msgstr ""

#: ../../../arch/x86/boot.rst:225
msgid "0258/8"
msgstr ""

#: ../../../arch/x86/boot.rst:225 ../../../arch/x86/boot.rst:870
msgid "pref_address"
msgstr ""

#: ../../../arch/x86/boot.rst:225
msgid "Preferred loading address"
msgstr ""

#: ../../../arch/x86/boot.rst:226
msgid "0260/4"
msgstr ""

#: ../../../arch/x86/boot.rst:226 ../../../arch/x86/boot.rst:885
msgid "init_size"
msgstr ""

#: ../../../arch/x86/boot.rst:226
msgid "Linear memory required during initialization"
msgstr ""

#: ../../../arch/x86/boot.rst:227
msgid "0264/4"
msgstr ""

#: ../../../arch/x86/boot.rst:227
msgid "2.11+"
msgstr ""

#: ../../../arch/x86/boot.rst:227 ../../../arch/x86/boot.rst:914
msgid "handover_offset"
msgstr ""

#: ../../../arch/x86/boot.rst:227
msgid "Offset of handover entry point"
msgstr ""

#: ../../../arch/x86/boot.rst:228
msgid "0268/4"
msgstr ""

#: ../../../arch/x86/boot.rst:228 ../../../arch/x86/boot.rst:929
msgid "2.15+"
msgstr ""

#: ../../../arch/x86/boot.rst:228 ../../../arch/x86/boot.rst:926
msgid "kernel_info_offset"
msgstr ""

#: ../../../arch/x86/boot.rst:228
msgid "Offset of the kernel_info"
msgstr ""

#: ../../../arch/x86/boot.rst:232
msgid ""
"For backwards compatibility, if the setup_sects field contains 0, the real "
"value is 4."
msgstr ""

#: ../../../arch/x86/boot.rst:235
msgid ""
"For boot protocol prior to 2.04, the upper two bytes of the syssize field "
"are unusable, which means the size of a bzImage kernel cannot be determined."
msgstr ""

#: ../../../arch/x86/boot.rst:239
msgid "Ignored, but safe to set, for boot protocols 2.02-2.09."
msgstr ""

#: ../../../arch/x86/boot.rst:241
msgid ""
"If the \"HdrS\" (0x53726448) magic number is not found at offset 0x202, the "
"boot protocol version is \"old\".  Loading an old kernel, the following "
"parameters should be assumed::"
msgstr ""

#: ../../../arch/x86/boot.rst:249
msgid ""
"Otherwise, the \"version\" field contains the protocol version, e.g. "
"protocol version 2.01 will contain 0x0201 in this field.  When setting "
"fields in the header, you must make sure only to set fields supported by the "
"protocol version in use."
msgstr ""

#: ../../../arch/x86/boot.rst:256
msgid "Details of Header Fields"
msgstr ""

#: ../../../arch/x86/boot.rst:258
msgid ""
"For each field, some are information from the kernel to the bootloader "
"(\"read\"), some are expected to be filled out by the bootloader "
"(\"write\"), and some are expected to be read and modified by the bootloader "
"(\"modify\")."
msgstr ""

#: ../../../arch/x86/boot.rst:263
msgid ""
"All general purpose boot loaders should write the fields marked "
"(obligatory).  Boot loaders who want to load the kernel at a nonstandard "
"address should fill in the fields marked (reloc); other boot loaders can "
"ignore those fields."
msgstr ""

#: ../../../arch/x86/boot.rst:268
msgid "The byte order of all fields is little endian (this is x86, after all.)"
msgstr ""

#: ../../../arch/x86/boot.rst:271 ../../../arch/x86/boot.rst:282
#: ../../../arch/x86/boot.rst:293 ../../../arch/x86/boot.rst:305
#: ../../../arch/x86/boot.rst:314 ../../../arch/x86/boot.rst:322
#: ../../../arch/x86/boot.rst:332 ../../../arch/x86/boot.rst:342
#: ../../../arch/x86/boot.rst:353 ../../../arch/x86/boot.rst:362
#: ../../../arch/x86/boot.rst:373 ../../../arch/x86/boot.rst:382
#: ../../../arch/x86/boot.rst:391 ../../../arch/x86/boot.rst:413
#: ../../../arch/x86/boot.rst:464 ../../../arch/x86/boot.rst:508
#: ../../../arch/x86/boot.rst:526 ../../../arch/x86/boot.rst:545
#: ../../../arch/x86/boot.rst:555 ../../../arch/x86/boot.rst:565
#: ../../../arch/x86/boot.rst:574 ../../../arch/x86/boot.rst:584
#: ../../../arch/x86/boot.rst:601 ../../../arch/x86/boot.rst:617
#: ../../../arch/x86/boot.rst:635 ../../../arch/x86/boot.rst:649
#: ../../../arch/x86/boot.rst:666 ../../../arch/x86/boot.rst:678
#: ../../../arch/x86/boot.rst:696 ../../../arch/x86/boot.rst:728
#: ../../../arch/x86/boot.rst:740 ../../../arch/x86/boot.rst:762
#: ../../../arch/x86/boot.rst:773 ../../../arch/x86/boot.rst:791
#: ../../../arch/x86/boot.rst:800 ../../../arch/x86/boot.rst:870
#: ../../../arch/x86/boot.rst:885 ../../../arch/x86/boot.rst:914
#: ../../../arch/x86/boot.rst:926 ../../../arch/x86/boot.rst:1009
#: ../../../arch/x86/boot.rst:1016 ../../../arch/x86/boot.rst:1026
#: ../../../arch/x86/boot.rst:1034
msgid "Field name:"
msgstr ""

#: ../../../arch/x86/boot.rst:272 ../../../arch/x86/boot.rst:283
#: ../../../arch/x86/boot.rst:294 ../../../arch/x86/boot.rst:306
#: ../../../arch/x86/boot.rst:315 ../../../arch/x86/boot.rst:323
#: ../../../arch/x86/boot.rst:333 ../../../arch/x86/boot.rst:343
#: ../../../arch/x86/boot.rst:354 ../../../arch/x86/boot.rst:363
#: ../../../arch/x86/boot.rst:374 ../../../arch/x86/boot.rst:383
#: ../../../arch/x86/boot.rst:392 ../../../arch/x86/boot.rst:414
#: ../../../arch/x86/boot.rst:465 ../../../arch/x86/boot.rst:509
#: ../../../arch/x86/boot.rst:527 ../../../arch/x86/boot.rst:546
#: ../../../arch/x86/boot.rst:556 ../../../arch/x86/boot.rst:566
#: ../../../arch/x86/boot.rst:575 ../../../arch/x86/boot.rst:585
#: ../../../arch/x86/boot.rst:602 ../../../arch/x86/boot.rst:618
#: ../../../arch/x86/boot.rst:636 ../../../arch/x86/boot.rst:650
#: ../../../arch/x86/boot.rst:667 ../../../arch/x86/boot.rst:679
#: ../../../arch/x86/boot.rst:697 ../../../arch/x86/boot.rst:729
#: ../../../arch/x86/boot.rst:741 ../../../arch/x86/boot.rst:763
#: ../../../arch/x86/boot.rst:774 ../../../arch/x86/boot.rst:792
#: ../../../arch/x86/boot.rst:801 ../../../arch/x86/boot.rst:871
#: ../../../arch/x86/boot.rst:886 ../../../arch/x86/boot.rst:915
#: ../../../arch/x86/boot.rst:927
msgid "Type:"
msgstr ""

#: ../../../arch/x86/boot.rst:272 ../../../arch/x86/boot.rst:294
#: ../../../arch/x86/boot.rst:333 ../../../arch/x86/boot.rst:343
#: ../../../arch/x86/boot.rst:354 ../../../arch/x86/boot.rst:363
#: ../../../arch/x86/boot.rst:383 ../../../arch/x86/boot.rst:392
#: ../../../arch/x86/boot.rst:636 ../../../arch/x86/boot.rst:697
#: ../../../arch/x86/boot.rst:729 ../../../arch/x86/boot.rst:774
#: ../../../arch/x86/boot.rst:792 ../../../arch/x86/boot.rst:886
#: ../../../arch/x86/boot.rst:915 ../../../arch/x86/boot.rst:927
msgid "read"
msgstr ""

#: ../../../arch/x86/boot.rst:273 ../../../arch/x86/boot.rst:284
#: ../../../arch/x86/boot.rst:295 ../../../arch/x86/boot.rst:307
#: ../../../arch/x86/boot.rst:316 ../../../arch/x86/boot.rst:324
#: ../../../arch/x86/boot.rst:334 ../../../arch/x86/boot.rst:344
#: ../../../arch/x86/boot.rst:355 ../../../arch/x86/boot.rst:364
#: ../../../arch/x86/boot.rst:375 ../../../arch/x86/boot.rst:384
#: ../../../arch/x86/boot.rst:393 ../../../arch/x86/boot.rst:415
#: ../../../arch/x86/boot.rst:466 ../../../arch/x86/boot.rst:510
#: ../../../arch/x86/boot.rst:528 ../../../arch/x86/boot.rst:547
#: ../../../arch/x86/boot.rst:557 ../../../arch/x86/boot.rst:567
#: ../../../arch/x86/boot.rst:576 ../../../arch/x86/boot.rst:586
#: ../../../arch/x86/boot.rst:603 ../../../arch/x86/boot.rst:619
#: ../../../arch/x86/boot.rst:637 ../../../arch/x86/boot.rst:651
#: ../../../arch/x86/boot.rst:668 ../../../arch/x86/boot.rst:680
#: ../../../arch/x86/boot.rst:698 ../../../arch/x86/boot.rst:730
#: ../../../arch/x86/boot.rst:742 ../../../arch/x86/boot.rst:764
#: ../../../arch/x86/boot.rst:775 ../../../arch/x86/boot.rst:793
#: ../../../arch/x86/boot.rst:802 ../../../arch/x86/boot.rst:872
#: ../../../arch/x86/boot.rst:887 ../../../arch/x86/boot.rst:916
#: ../../../arch/x86/boot.rst:928 ../../../arch/x86/boot.rst:1010
#: ../../../arch/x86/boot.rst:1017 ../../../arch/x86/boot.rst:1027
#: ../../../arch/x86/boot.rst:1035
msgid "Offset/size:"
msgstr ""

#: ../../../arch/x86/boot.rst:273
msgid "0x1f1/1"
msgstr ""

#: ../../../arch/x86/boot.rst:274 ../../../arch/x86/boot.rst:285
#: ../../../arch/x86/boot.rst:296 ../../../arch/x86/boot.rst:308
#: ../../../arch/x86/boot.rst:325 ../../../arch/x86/boot.rst:335
#: ../../../arch/x86/boot.rst:345 ../../../arch/x86/boot.rst:356
#: ../../../arch/x86/boot.rst:365 ../../../arch/x86/boot.rst:376
#: ../../../arch/x86/boot.rst:385 ../../../arch/x86/boot.rst:394
#: ../../../arch/x86/boot.rst:416 ../../../arch/x86/boot.rst:467
#: ../../../arch/x86/boot.rst:511 ../../../arch/x86/boot.rst:529
#: ../../../arch/x86/boot.rst:548 ../../../arch/x86/boot.rst:558
#: ../../../arch/x86/boot.rst:568 ../../../arch/x86/boot.rst:577
#: ../../../arch/x86/boot.rst:587 ../../../arch/x86/boot.rst:604
#: ../../../arch/x86/boot.rst:620 ../../../arch/x86/boot.rst:638
#: ../../../arch/x86/boot.rst:652 ../../../arch/x86/boot.rst:669
#: ../../../arch/x86/boot.rst:681 ../../../arch/x86/boot.rst:699
#: ../../../arch/x86/boot.rst:731 ../../../arch/x86/boot.rst:743
#: ../../../arch/x86/boot.rst:765 ../../../arch/x86/boot.rst:776
#: ../../../arch/x86/boot.rst:794 ../../../arch/x86/boot.rst:803
#: ../../../arch/x86/boot.rst:873 ../../../arch/x86/boot.rst:929
msgid "Protocol:"
msgstr ""

#: ../../../arch/x86/boot.rst:277
msgid ""
"The size of the setup code in 512-byte sectors.  If this field is 0, the "
"real value is 4.  The real-mode code consists of the boot sector (always one "
"512-byte sector) plus the setup code."
msgstr ""

#: ../../../arch/x86/boot.rst:283 ../../../arch/x86/boot.rst:323
#: ../../../arch/x86/boot.rst:374
msgid "modify (optional)"
msgstr ""

#: ../../../arch/x86/boot.rst:284
msgid "0x1f2/2"
msgstr ""

#: ../../../arch/x86/boot.rst:288
msgid ""
"If this field is nonzero, the root defaults to readonly.  The use of this "
"field is deprecated; use the \"ro\" or \"rw\" options on the command line "
"instead."
msgstr ""

#: ../../../arch/x86/boot.rst:295
msgid "0x1f4/4 (protocol 2.04+) 0x1f4/2 (protocol ALL)"
msgstr ""

#: ../../../arch/x86/boot.rst:296
msgid "2.04+"
msgstr ""

#: ../../../arch/x86/boot.rst:299
msgid ""
"The size of the protected-mode code in units of 16-byte paragraphs. For "
"protocol versions older than 2.04 this field is only two bytes wide, and "
"therefore cannot be trusted for the size of a kernel if the LOAD_HIGH flag "
"is set."
msgstr ""

#: ../../../arch/x86/boot.rst:306 ../../../arch/x86/boot.rst:566
msgid "kernel internal"
msgstr ""

#: ../../../arch/x86/boot.rst:307
msgid "0x1f8/2"
msgstr ""

#: ../../../arch/x86/boot.rst:311 ../../../arch/x86/boot.rst:571
msgid "This field is obsolete."
msgstr ""

#: ../../../arch/x86/boot.rst:315 ../../../arch/x86/boot.rst:465
#: ../../../arch/x86/boot.rst:509
msgid "modify (obligatory)"
msgstr ""

#: ../../../arch/x86/boot.rst:316
msgid "0x1fa/2"
msgstr ""

#: ../../../arch/x86/boot.rst:319
msgid "Please see the section on SPECIAL COMMAND LINE OPTIONS."
msgstr ""

#: ../../../arch/x86/boot.rst:324
msgid "0x1fc/2"
msgstr ""

#: ../../../arch/x86/boot.rst:328
msgid ""
"The default root device device number.  The use of this field is deprecated, "
"use the \"root=\" option on the command line instead."
msgstr ""

#: ../../../arch/x86/boot.rst:334
msgid "0x1fe/2"
msgstr ""

#: ../../../arch/x86/boot.rst:338
msgid ""
"Contains 0xAA55.  This is the closest thing old Linux kernels have to a "
"magic number."
msgstr ""

#: ../../../arch/x86/boot.rst:344
msgid "0x200/2"
msgstr ""

#: ../../../arch/x86/boot.rst:348
msgid ""
"Contains an x86 jump instruction, 0xEB followed by a signed offset relative "
"to byte 0x202.  This can be used to determine the size of the header."
msgstr ""

#: ../../../arch/x86/boot.rst:355
msgid "0x202/4"
msgstr ""

#: ../../../arch/x86/boot.rst:359
msgid "Contains the magic number \"HdrS\" (0x53726448)."
msgstr ""

#: ../../../arch/x86/boot.rst:364
msgid "0x206/2"
msgstr ""

#: ../../../arch/x86/boot.rst:368
msgid ""
"Contains the boot protocol version, in (major << 8) + minor format, e.g. "
"0x0204 for version 2.04, and 0x0a11 for a hypothetical version 10.17."
msgstr ""

#: ../../../arch/x86/boot.rst:375
msgid "0x208/4"
msgstr ""

#: ../../../arch/x86/boot.rst:379
msgid "Boot loader hook (see ADVANCED BOOT LOADER HOOKS below.)"
msgstr ""

#: ../../../arch/x86/boot.rst:384
msgid "0x20c/2"
msgstr ""

#: ../../../arch/x86/boot.rst:388
msgid "The load low segment (0x1000).  Obsolete."
msgstr ""

#: ../../../arch/x86/boot.rst:393
msgid "0x20e/2"
msgstr ""

#: ../../../arch/x86/boot.rst:397
msgid ""
"If set to a nonzero value, contains a pointer to a NUL-terminated human-"
"readable kernel version number string, less 0x200.  This can be used to "
"display the kernel version to the user.  This value should be less than "
"(0x200 * setup_sects)."
msgstr ""

#: ../../../arch/x86/boot.rst:402
msgid ""
"For example, if this value is set to 0x1c00, the kernel version number "
"string can be found at offset 0x1e00 in the kernel file. This is a valid "
"value if and only if the \"setup_sects\" field contains the value 15 or "
"higher, as::"
msgstr ""

#: ../../../arch/x86/boot.rst:414 ../../../arch/x86/boot.rst:546
#: ../../../arch/x86/boot.rst:556 ../../../arch/x86/boot.rst:575
#: ../../../arch/x86/boot.rst:618
msgid "write (obligatory)"
msgstr ""

#: ../../../arch/x86/boot.rst:415
msgid "0x210/1"
msgstr ""

#: ../../../arch/x86/boot.rst:419
msgid ""
"If your boot loader has an assigned id (see table below), enter 0xTV here, "
"where T is an identifier for the boot loader and V is a version number.  "
"Otherwise, enter 0xFF here."
msgstr ""

#: ../../../arch/x86/boot.rst:423
msgid ""
"For boot loader IDs above T = 0xD, write T = 0xE to this field and write the "
"extended ID minus 0x10 to the ext_loader_type field. Similarly, the "
"ext_loader_ver field can be used to provide more than four bits for the "
"bootloader version."
msgstr ""

#: ../../../arch/x86/boot.rst:428
msgid "For example, for T = 0x15, V = 0x234, write::"
msgstr ""

#: ../../../arch/x86/boot.rst:434
msgid "Assigned boot loader ids (hexadecimal):"
msgstr ""

#: ../../../arch/x86/boot.rst:437
msgid "0"
msgstr ""

#: ../../../arch/x86/boot.rst:437
msgid "LILO (0x00 reserved for pre-2.00 bootloader)"
msgstr ""

#: ../../../arch/x86/boot.rst:439
msgid "1"
msgstr ""

#: ../../../arch/x86/boot.rst:439
msgid "Loadlin"
msgstr ""

#: ../../../arch/x86/boot.rst:440
msgid "2"
msgstr ""

#: ../../../arch/x86/boot.rst:440
msgid "bootsect-loader (0x20, all other values reserved)"
msgstr ""

#: ../../../arch/x86/boot.rst:442
msgid "3"
msgstr ""

#: ../../../arch/x86/boot.rst:442
msgid "Syslinux"
msgstr ""

#: ../../../arch/x86/boot.rst:443
msgid "4"
msgstr ""

#: ../../../arch/x86/boot.rst:443
msgid "Etherboot/gPXE/iPXE"
msgstr ""

#: ../../../arch/x86/boot.rst:444
msgid "5"
msgstr ""

#: ../../../arch/x86/boot.rst:444
msgid "ELILO"
msgstr ""

#: ../../../arch/x86/boot.rst:445
msgid "7"
msgstr ""

#: ../../../arch/x86/boot.rst:445
msgid "GRUB"
msgstr ""

#: ../../../arch/x86/boot.rst:446
msgid "8"
msgstr ""

#: ../../../arch/x86/boot.rst:446
msgid "U-Boot"
msgstr ""

#: ../../../arch/x86/boot.rst:447
msgid "9"
msgstr ""

#: ../../../arch/x86/boot.rst:447 ../../../arch/x86/boot.rst:756
msgid "Xen"
msgstr ""

#: ../../../arch/x86/boot.rst:448
msgid "A"
msgstr ""

#: ../../../arch/x86/boot.rst:448
msgid "Gujin"
msgstr ""

#: ../../../arch/x86/boot.rst:449
msgid "B"
msgstr ""

#: ../../../arch/x86/boot.rst:449
msgid "Qemu"
msgstr ""

#: ../../../arch/x86/boot.rst:450
msgid "C"
msgstr ""

#: ../../../arch/x86/boot.rst:450
msgid "Arcturus Networks uCbootloader"
msgstr ""

#: ../../../arch/x86/boot.rst:451
msgid "D"
msgstr ""

#: ../../../arch/x86/boot.rst:451
msgid "kexec-tools"
msgstr ""

#: ../../../arch/x86/boot.rst:452
msgid "E"
msgstr ""

#: ../../../arch/x86/boot.rst:452
msgid "Extended (see ext_loader_type)"
msgstr ""

#: ../../../arch/x86/boot.rst:453
msgid "F"
msgstr ""

#: ../../../arch/x86/boot.rst:453
msgid "Special (0xFF = undefined)"
msgstr ""

#: ../../../arch/x86/boot.rst:454
msgid "10"
msgstr ""

#: ../../../arch/x86/boot.rst:454
msgid "Reserved"
msgstr ""

#: ../../../arch/x86/boot.rst:455
msgid "11"
msgstr ""

#: ../../../arch/x86/boot.rst:455
msgid "Minimal Linux Bootloader <http://sebastian-plotz.blogspot.de>"
msgstr ""

#: ../../../arch/x86/boot.rst:457
msgid "12"
msgstr ""

#: ../../../arch/x86/boot.rst:457
msgid "OVMF UEFI virtualization stack"
msgstr ""

#: ../../../arch/x86/boot.rst:458
msgid "13"
msgstr ""

#: ../../../arch/x86/boot.rst:458
msgid "barebox"
msgstr ""

#: ../../../arch/x86/boot.rst:461
msgid ""
"Please contact <hpa@zytor.com> if you need a bootloader ID value assigned."
msgstr ""

#: ../../../arch/x86/boot.rst:466
msgid "0x211/1"
msgstr ""

#: ../../../arch/x86/boot.rst:470 ../../../arch/x86/boot.rst:702
msgid "This field is a bitmask."
msgstr ""

#: ../../../arch/x86/boot.rst:472
msgid "Bit 0 (read): LOADED_HIGH"
msgstr ""

#: ../../../arch/x86/boot.rst:474
msgid "If 0, the protected-mode code is loaded at 0x10000."
msgstr ""

#: ../../../arch/x86/boot.rst:475
msgid "If 1, the protected-mode code is loaded at 0x100000."
msgstr ""

#: ../../../arch/x86/boot.rst:477
msgid "Bit 1 (kernel internal): KASLR_FLAG"
msgstr ""

#: ../../../arch/x86/boot.rst:479
msgid ""
"Used internally by the compressed kernel to communicate KASLR status to "
"kernel proper."
msgstr ""

#: ../../../arch/x86/boot.rst:482
msgid "If 1, KASLR enabled."
msgstr ""

#: ../../../arch/x86/boot.rst:483
msgid "If 0, KASLR disabled."
msgstr ""

#: ../../../arch/x86/boot.rst:485
msgid "Bit 5 (write): QUIET_FLAG"
msgstr ""

#: ../../../arch/x86/boot.rst:487
msgid "If 0, print early messages."
msgstr ""

#: ../../../arch/x86/boot.rst:488
msgid "If 1, suppress early messages."
msgstr ""

#: ../../../arch/x86/boot.rst:490
msgid ""
"This requests to the kernel (decompressor and early kernel) to not write "
"early messages that require accessing the display hardware directly."
msgstr ""

#: ../../../arch/x86/boot.rst:494
msgid "Bit 6 (obsolete): KEEP_SEGMENTS"
msgstr ""

#: ../../../arch/x86/boot.rst:496
msgid "Protocol: 2.07+"
msgstr ""

#: ../../../arch/x86/boot.rst:498
msgid "This flag is obsolete."
msgstr ""

#: ../../../arch/x86/boot.rst:500
msgid "Bit 7 (write): CAN_USE_HEAP"
msgstr ""

#: ../../../arch/x86/boot.rst:502
msgid ""
"Set this bit to 1 to indicate that the value entered in the heap_end_ptr is "
"valid.  If this field is clear, some setup code functionality will be "
"disabled."
msgstr ""

#: ../../../arch/x86/boot.rst:510
msgid "0x212/2"
msgstr ""

#: ../../../arch/x86/boot.rst:511
msgid "2.00-2.01"
msgstr ""

#: ../../../arch/x86/boot.rst:514
msgid ""
"When using protocol 2.00 or 2.01, if the real mode kernel is not loaded at "
"0x90000, it gets moved there later in the loading sequence.  Fill in this "
"field if you want additional data (such as the kernel command line) moved in "
"addition to the real-mode kernel itself."
msgstr ""

#: ../../../arch/x86/boot.rst:520
msgid "The unit is bytes starting with the beginning of the boot sector."
msgstr ""

#: ../../../arch/x86/boot.rst:522
msgid ""
"This field is can be ignored when the protocol is 2.02 or higher, or if the "
"real-mode code is loaded at 0x90000."
msgstr ""

#: ../../../arch/x86/boot.rst:527
msgid "modify (optional, reloc)"
msgstr ""

#: ../../../arch/x86/boot.rst:528
msgid "0x214/4"
msgstr ""

#: ../../../arch/x86/boot.rst:532
msgid ""
"The address to jump to in protected mode.  This defaults to the load address "
"of the kernel, and can be used by the boot loader to determine the proper "
"load address."
msgstr ""

#: ../../../arch/x86/boot.rst:536
msgid "This field can be modified for two purposes:"
msgstr ""

#: ../../../arch/x86/boot.rst:538
msgid "as a boot loader hook (see Advanced Boot Loader Hooks below.)"
msgstr ""

#: ../../../arch/x86/boot.rst:540
msgid ""
"if a bootloader which does not install a hook loads a relocatable kernel at "
"a nonstandard address it will have to modify this field to point to the load "
"address."
msgstr ""

#: ../../../arch/x86/boot.rst:547
msgid "0x218/4"
msgstr ""

#: ../../../arch/x86/boot.rst:551
msgid ""
"The 32-bit linear address of the initial ramdisk or ramfs.  Leave at zero if "
"there is no initial ramdisk/ramfs."
msgstr ""

#: ../../../arch/x86/boot.rst:557
msgid "0x21c/4"
msgstr ""

#: ../../../arch/x86/boot.rst:561
msgid ""
"Size of the initial ramdisk or ramfs.  Leave at zero if there is no initial "
"ramdisk/ramfs."
msgstr ""

#: ../../../arch/x86/boot.rst:567
msgid "0x220/4"
msgstr ""

#: ../../../arch/x86/boot.rst:576
msgid "0x224/2"
msgstr ""

#: ../../../arch/x86/boot.rst:580
msgid ""
"Set this field to the offset (from the beginning of the real-mode code) of "
"the end of the setup stack/heap, minus 0x0200."
msgstr ""

#: ../../../arch/x86/boot.rst:585
msgid "write (optional)"
msgstr ""

#: ../../../arch/x86/boot.rst:586
msgid "0x226/1"
msgstr ""

#: ../../../arch/x86/boot.rst:590
msgid ""
"This field is used as an extension of the version number in the "
"type_of_loader field.  The total version number is considered to be "
"(type_of_loader & 0x0f) + (ext_loader_ver << 4)."
msgstr ""

#: ../../../arch/x86/boot.rst:594
msgid ""
"The use of this field is boot loader specific.  If not written, it is zero."
msgstr ""

#: ../../../arch/x86/boot.rst:597 ../../../arch/x86/boot.rst:613
msgid ""
"Kernels prior to 2.6.31 did not recognize this field, but it is safe to "
"write for protocol version 2.02 or higher."
msgstr ""

#: ../../../arch/x86/boot.rst:602
msgid "write (obligatory if (type_of_loader & 0xf0) == 0xe0)"
msgstr ""

#: ../../../arch/x86/boot.rst:603
msgid "0x227/1"
msgstr ""

#: ../../../arch/x86/boot.rst:607
msgid ""
"This field is used as an extension of the type number in type_of_loader "
"field.  If the type in type_of_loader is 0xE, then the actual type is "
"(ext_loader_type + 0x10)."
msgstr ""

#: ../../../arch/x86/boot.rst:611
msgid "This field is ignored if the type in type_of_loader is not 0xE."
msgstr ""

#: ../../../arch/x86/boot.rst:619
msgid "0x228/4"
msgstr ""

#: ../../../arch/x86/boot.rst:623
msgid ""
"Set this field to the linear address of the kernel command line. The kernel "
"command line can be located anywhere between the end of the setup heap and "
"0xA0000; it does not have to be located in the same 64K segment as the real-"
"mode code itself."
msgstr ""

#: ../../../arch/x86/boot.rst:628
msgid ""
"Fill in this field even if your boot loader does not support a command line, "
"in which case you can point this to an empty string (or better yet, to the "
"string \"auto\".)  If this field is left at zero, the kernel will assume "
"that your boot loader does not support the 2.02+ protocol."
msgstr ""

#: ../../../arch/x86/boot.rst:637
msgid "0x22c/4"
msgstr ""

#: ../../../arch/x86/boot.rst:641
msgid ""
"The maximum address that may be occupied by the initial ramdisk/ramfs "
"contents.  For boot protocols 2.02 or earlier, this field is not present, "
"and the maximum address is 0x37FFFFFF.  (This address is defined as the "
"address of the highest safe byte, so if your ramdisk is exactly 131072 bytes "
"long and this field is 0x37FFFFFF, you can start your ramdisk at 0x37FE0000.)"
msgstr ""

#: ../../../arch/x86/boot.rst:650
msgid "read/modify (reloc)"
msgstr ""

#: ../../../arch/x86/boot.rst:651
msgid "0x230/4"
msgstr ""

#: ../../../arch/x86/boot.rst:652
msgid "2.05+ (read), 2.10+ (modify)"
msgstr ""

#: ../../../arch/x86/boot.rst:655
msgid ""
"Alignment unit required by the kernel (if relocatable_kernel is true.)  A "
"relocatable kernel that is loaded at an alignment incompatible with the "
"value in this field will be realigned during kernel initialization."
msgstr ""

#: ../../../arch/x86/boot.rst:660
msgid ""
"Starting with protocol version 2.10, this reflects the kernel alignment "
"preferred for optimal performance; it is possible for the loader to modify "
"this field to permit a lesser alignment.  See the min_alignment and "
"pref_address field below."
msgstr ""

#: ../../../arch/x86/boot.rst:667 ../../../arch/x86/boot.rst:679
#: ../../../arch/x86/boot.rst:871
msgid "read (reloc)"
msgstr ""

#: ../../../arch/x86/boot.rst:668
msgid "0x234/1"
msgstr ""

#: ../../../arch/x86/boot.rst:672
msgid ""
"If this field is nonzero, the protected-mode part of the kernel can be "
"loaded at any address that satisfies the kernel_alignment field. After "
"loading, the boot loader must set the code32_start field to point to the "
"loaded code, or to a boot loader hook."
msgstr ""

#: ../../../arch/x86/boot.rst:680
msgid "0x235/1"
msgstr ""

#: ../../../arch/x86/boot.rst:684
msgid ""
"This field, if nonzero, indicates as a power of two the minimum alignment "
"required, as opposed to preferred, by the kernel to boot. If a boot loader "
"makes use of this field, it should update the kernel_alignment field with "
"the alignment unit desired; typically::"
msgstr ""

#: ../../../arch/x86/boot.rst:691
msgid ""
"There may be a considerable performance cost with an excessively misaligned "
"kernel.  Therefore, a loader should typically try each power-of-two "
"alignment from kernel_alignment down to this alignment."
msgstr ""

#: ../../../arch/x86/boot.rst:698
msgid "0x236/2"
msgstr ""

#: ../../../arch/x86/boot.rst:704
msgid "Bit 0 (read): XLF_KERNEL_64"
msgstr ""

#: ../../../arch/x86/boot.rst:706
msgid "If 1, this kernel has the legacy 64-bit entry point at 0x200."
msgstr ""

#: ../../../arch/x86/boot.rst:708
msgid "Bit 1 (read): XLF_CAN_BE_LOADED_ABOVE_4G"
msgstr ""

#: ../../../arch/x86/boot.rst:710
msgid "If 1, kernel/boot_params/cmdline/ramdisk can be above 4G."
msgstr ""

#: ../../../arch/x86/boot.rst:712
msgid "Bit 2 (read): XLF_EFI_HANDOVER_32"
msgstr ""

#: ../../../arch/x86/boot.rst:714
msgid ""
"If 1, the kernel supports the 32-bit EFI handoff entry point given at "
"handover_offset."
msgstr ""

#: ../../../arch/x86/boot.rst:717
msgid "Bit 3 (read): XLF_EFI_HANDOVER_64"
msgstr ""

#: ../../../arch/x86/boot.rst:719
msgid ""
"If 1, the kernel supports the 64-bit EFI handoff entry point given at "
"handover_offset + 0x200."
msgstr ""

#: ../../../arch/x86/boot.rst:722
msgid "Bit 4 (read): XLF_EFI_KEXEC"
msgstr ""

#: ../../../arch/x86/boot.rst:724
msgid "If 1, the kernel supports kexec EFI boot with EFI runtime support."
msgstr ""

#: ../../../arch/x86/boot.rst:730
msgid "0x238/4"
msgstr ""

#: ../../../arch/x86/boot.rst:734
msgid ""
"The maximum size of the command line without the terminating zero. This "
"means that the command line can contain at most cmdline_size characters. "
"With protocol version 2.05 and earlier, the maximum size was 255."
msgstr ""

#: ../../../arch/x86/boot.rst:741
msgid "write (optional, defaults to x86/PC)"
msgstr ""

#: ../../../arch/x86/boot.rst:742
msgid "0x23c/4"
msgstr ""

#: ../../../arch/x86/boot.rst:746
msgid ""
"In a paravirtualized environment the hardware low level architectural pieces "
"such as interrupt handling, page table handling, and accessing process "
"control registers needs to be done differently."
msgstr ""

#: ../../../arch/x86/boot.rst:750
msgid ""
"This field allows the bootloader to inform the kernel we are in one one of "
"those environments."
msgstr ""

#: ../../../arch/x86/boot.rst:754
msgid "0x00000000"
msgstr ""

#: ../../../arch/x86/boot.rst:754
msgid "The default x86/PC environment"
msgstr ""

#: ../../../arch/x86/boot.rst:755
msgid "0x00000001"
msgstr ""

#: ../../../arch/x86/boot.rst:755
msgid "lguest"
msgstr ""

#: ../../../arch/x86/boot.rst:756
msgid "0x00000002"
msgstr ""

#: ../../../arch/x86/boot.rst:757
msgid "0x00000003"
msgstr ""

#: ../../../arch/x86/boot.rst:757
msgid "Intel MID (Moorestown, CloverTrail, Merrifield, Moorefield)"
msgstr ""

#: ../../../arch/x86/boot.rst:758
msgid "0x00000004"
msgstr ""

#: ../../../arch/x86/boot.rst:758
msgid "CE4100 TV Platform"
msgstr ""

#: ../../../arch/x86/boot.rst:763
msgid "write (subarch-dependent)"
msgstr ""

#: ../../../arch/x86/boot.rst:764
msgid "0x240/8"
msgstr ""

#: ../../../arch/x86/boot.rst:768
msgid ""
"A pointer to data that is specific to hardware subarch This field is "
"currently unused for the default x86/PC environment, do not modify."
msgstr ""

#: ../../../arch/x86/boot.rst:775
msgid "0x248/4"
msgstr ""

#: ../../../arch/x86/boot.rst:779
msgid ""
"If non-zero then this field contains the offset from the beginning of the "
"protected-mode code to the payload."
msgstr ""

#: ../../../arch/x86/boot.rst:782
msgid ""
"The payload may be compressed. The format of both the compressed and "
"uncompressed data should be determined using the standard magic numbers.  "
"The currently supported compression formats are gzip (magic numbers 1F 8B or "
"1F 9E), bzip2 (magic number 42 5A), LZMA (magic number 5D 00), XZ (magic "
"number FD 37), LZ4 (magic number 02 21) and ZSTD (magic number 28 B5). The "
"uncompressed payload is currently always ELF (magic number 7F 45 4C 46)."
msgstr ""

#: ../../../arch/x86/boot.rst:793
msgid "0x24c/4"
msgstr ""

#: ../../../arch/x86/boot.rst:797
msgid "The length of the payload."
msgstr ""

#: ../../../arch/x86/boot.rst:801
msgid "write (special)"
msgstr ""

#: ../../../arch/x86/boot.rst:802
msgid "0x250/8"
msgstr ""

#: ../../../arch/x86/boot.rst:806
msgid ""
"The 64-bit physical pointer to NULL terminated single linked list of struct "
"setup_data. This is used to define a more extensible boot parameters passing "
"mechanism. The definition of struct setup_data is as follow::"
msgstr ""

#: ../../../arch/x86/boot.rst:818
msgid ""
"Where, the next is a 64-bit physical pointer to the next node of linked "
"list, the next field of the last node is 0; the type is used to identify the "
"contents of data; the len is the length of data field; the data holds the "
"real payload."
msgstr ""

#: ../../../arch/x86/boot.rst:823
msgid ""
"This list may be modified at a number of points during the bootup process.  "
"Therefore, when modifying this list one should always make sure to consider "
"the case where the linked list already contains entries."
msgstr ""

#: ../../../arch/x86/boot.rst:828
msgid ""
"The setup_data is a bit awkward to use for extremely large data objects, "
"both because the setup_data header has to be adjacent to the data object and "
"because it has a 32-bit length field. However, it is important that "
"intermediate stages of the boot process have a way to identify which chunks "
"of memory are occupied by kernel data."
msgstr ""

#: ../../../arch/x86/boot.rst:834
msgid ""
"Thus setup_indirect struct and SETUP_INDIRECT type were introduced in "
"protocol 2.15::"
msgstr ""

#: ../../../arch/x86/boot.rst:844
msgid ""
"The type member is a SETUP_INDIRECT | SETUP_* type. However, it cannot be "
"SETUP_INDIRECT itself since making the setup_indirect a tree structure could "
"require a lot of stack space in something that needs to parse it and stack "
"space can be limited in boot contexts."
msgstr ""

#: ../../../arch/x86/boot.rst:849
msgid ""
"Let's give an example how to point to SETUP_E820_EXT data using "
"setup_indirect. In this case setup_data and setup_indirect will look like "
"this::"
msgstr ""

#: ../../../arch/x86/boot.rst:865
msgid ""
"SETUP_INDIRECT | SETUP_NONE objects cannot be properly distinguished from "
"SETUP_INDIRECT itself. So, this kind of objects cannot be provided by the "
"bootloaders."
msgstr ""

#: ../../../arch/x86/boot.rst:872
msgid "0x258/8"
msgstr ""

#: ../../../arch/x86/boot.rst:876
msgid ""
"This field, if nonzero, represents a preferred load address for the kernel.  "
"A relocating bootloader should attempt to load at this address if possible."
msgstr ""

#: ../../../arch/x86/boot.rst:880
msgid ""
"A non-relocatable kernel will unconditionally move itself and to run at this "
"address. A relocatable kernel will move itself to this address if it loaded "
"below this address."
msgstr ""

#: ../../../arch/x86/boot.rst:887
msgid "0x260/4"
msgstr ""

#: ../../../arch/x86/boot.rst:890
msgid ""
"This field indicates the amount of linear contiguous memory starting at the "
"kernel runtime start address that the kernel needs before it is capable of "
"examining its memory map.  This is not the same thing as the total amount of "
"memory the kernel needs to boot, but it can be used by a relocating boot "
"loader to help select a safe load address for the kernel."
msgstr ""

#: ../../../arch/x86/boot.rst:897
msgid ""
"The kernel runtime start address is determined by the following algorithm::"
msgstr ""

#: ../../../arch/x86/boot.rst:907
msgid ""
"Hence the necessary memory window location and size can be estimated by a "
"boot loader as::"
msgstr ""

#: ../../../arch/x86/boot.rst:916
msgid "0x264/4"
msgstr ""

#: ../../../arch/x86/boot.rst:919
msgid ""
"This field is the offset from the beginning of the kernel image to the EFI "
"handover protocol entry point. Boot loaders using the EFI handover protocol "
"to boot the kernel should jump to this offset."
msgstr ""

#: ../../../arch/x86/boot.rst:923
msgid "See EFI HANDOVER PROTOCOL below for more details."
msgstr ""

#: ../../../arch/x86/boot.rst:928
msgid "0x268/4"
msgstr ""

#: ../../../arch/x86/boot.rst:932
msgid ""
"This field is the offset from the beginning of the kernel image to the "
"kernel_info. The kernel_info structure is embedded in the Linux image in the "
"uncompressed protected mode region."
msgstr ""

#: ../../../arch/x86/boot.rst:938
msgid "The kernel_info"
msgstr ""

#: ../../../arch/x86/boot.rst:940
msgid ""
"The relationships between the headers are analogous to the various data "
"sections::"
msgstr ""

#: ../../../arch/x86/boot.rst:946
msgid "What is missing from the above list? That's right::"
msgstr ""

#: ../../../arch/x86/boot.rst:950
msgid ""
"We have been (ab)using .data for things that could go into .rodata or .bss "
"for a long time, for lack of alternatives and -- especially early on -- "
"inertia. Also, the BIOS stub is responsible for creating boot_params, so it "
"isn't available to a BIOS-based loader (setup_data is, though)."
msgstr ""

#: ../../../arch/x86/boot.rst:955
msgid ""
"setup_header is permanently limited to 144 bytes due to the reach of the 2-"
"byte jump field, which doubles as a length field for the structure, combined "
"with the size of the \"hole\" in struct boot_params that a protected-mode "
"loader or the BIOS stub has to copy it into. It is currently 119 bytes long, "
"which leaves us with 25 very precious bytes. This isn't something that can "
"be fixed without revising the boot protocol entirely, breaking backwards "
"compatibility."
msgstr ""

#: ../../../arch/x86/boot.rst:962
msgid ""
"boot_params proper is limited to 4096 bytes, but can be arbitrarily extended "
"by adding setup_data entries. It cannot be used to communicate properties of "
"the kernel image, because it is .bss and has no image-provided content."
msgstr ""

#: ../../../arch/x86/boot.rst:966
msgid ""
"kernel_info solves this by providing an extensible place for information "
"about the kernel image. It is readonly, because the kernel cannot rely on a "
"bootloader copying its contents anywhere, but that is OK; if it becomes "
"necessary it can still contain data items that an enabled bootloader would "
"be expected to copy into a setup_data chunk."
msgstr ""

#: ../../../arch/x86/boot.rst:972
msgid ""
"All kernel_info data should be part of this structure. Fixed size data have "
"to be put before kernel_info_var_len_data label. Variable size data have to "
"be put after kernel_info_var_len_data label. Each chunk of variable size "
"data has to be prefixed with header/magic and its size, e.g.::"
msgstr ""

#: ../../../arch/x86/boot.rst:997
msgid "This way the kernel_info is self-contained blob."
msgstr ""

#: ../../../arch/x86/boot.rst:1000
msgid ""
"Each variable size data header/magic can be any 4-character string, without "
"\\0 at the end of the string, which does not collide with existing variable "
"length data headers/magics."
msgstr ""

#: ../../../arch/x86/boot.rst:1006
msgid "Details of the kernel_info Fields"
msgstr ""

#: ../../../arch/x86/boot.rst:1010
msgid "0x0000/4"
msgstr ""

#: ../../../arch/x86/boot.rst:1013
msgid "Contains the magic number \"LToP\" (0x506f544c)."
msgstr ""

#: ../../../arch/x86/boot.rst:1016
msgid "size"
msgstr ""

#: ../../../arch/x86/boot.rst:1017
msgid "0x0004/4"
msgstr ""

#: ../../../arch/x86/boot.rst:1020
msgid ""
"This field contains the size of the kernel_info including kernel_info."
"header. It does not count kernel_info.kernel_info_var_len_data size. This "
"field should be used by the bootloaders to detect supported fixed size "
"fields in the kernel_info and beginning of kernel_info."
"kernel_info_var_len_data."
msgstr ""

#: ../../../arch/x86/boot.rst:1026
msgid "size_total"
msgstr ""

#: ../../../arch/x86/boot.rst:1027
msgid "0x0008/4"
msgstr ""

#: ../../../arch/x86/boot.rst:1030
msgid ""
"This field contains the size of the kernel_info including kernel_info.header "
"and kernel_info.kernel_info_var_len_data."
msgstr ""

#: ../../../arch/x86/boot.rst:1034
msgid "setup_type_max"
msgstr ""

#: ../../../arch/x86/boot.rst:1035
msgid "0x000c/4"
msgstr ""

#: ../../../arch/x86/boot.rst:1038
msgid ""
"This field contains maximal allowed type for setup_data and setup_indirect "
"structs."
msgstr ""

#: ../../../arch/x86/boot.rst:1042
msgid "The Kernel Command Line"
msgstr ""

#: ../../../arch/x86/boot.rst:1044
msgid ""
"The kernel command line has become an important way for the boot loader to "
"communicate with the kernel.  Some of its options are also relevant to the "
"boot loader itself, see \"special command line options\" below."
msgstr ""

#: ../../../arch/x86/boot.rst:1049
msgid ""
"The kernel command line is a null-terminated string. The maximum length can "
"be retrieved from the field cmdline_size.  Before protocol version 2.06, the "
"maximum was 255 characters.  A string that is too long will be automatically "
"truncated by the kernel."
msgstr ""

#: ../../../arch/x86/boot.rst:1054
msgid ""
"If the boot protocol version is 2.02 or later, the address of the kernel "
"command line is given by the header field cmd_line_ptr (see above.)  This "
"address can be anywhere between the end of the setup heap and 0xA0000."
msgstr ""

#: ../../../arch/x86/boot.rst:1059
msgid ""
"If the protocol version is *not* 2.02 or higher, the kernel command line is "
"entered using the following protocol:"
msgstr ""

#: ../../../arch/x86/boot.rst:1062
msgid ""
"At offset 0x0020 (word), \"cmd_line_magic\", enter the magic number 0xA33F."
msgstr ""

#: ../../../arch/x86/boot.rst:1065
msgid ""
"At offset 0x0022 (word), \"cmd_line_offset\", enter the offset of the kernel "
"command line (relative to the start of the real-mode kernel)."
msgstr ""

#: ../../../arch/x86/boot.rst:1069
msgid ""
"The kernel command line *must* be within the memory region covered by "
"setup_move_size, so you may need to adjust this field."
msgstr ""

#: ../../../arch/x86/boot.rst:1075
msgid "Memory Layout of The Real-Mode Code"
msgstr ""

#: ../../../arch/x86/boot.rst:1077
msgid ""
"The real-mode code requires a stack/heap to be set up, as well as memory "
"allocated for the kernel command line.  This needs to be done in the real-"
"mode accessible memory in bottom megabyte."
msgstr ""

#: ../../../arch/x86/boot.rst:1081
msgid ""
"It should be noted that modern machines often have a sizable Extended BIOS "
"Data Area (EBDA).  As a result, it is advisable to use as little of the low "
"megabyte as possible."
msgstr ""

#: ../../../arch/x86/boot.rst:1085
msgid ""
"Unfortunately, under the following circumstances the 0x90000 memory segment "
"has to be used:"
msgstr ""

#: ../../../arch/x86/boot.rst:1088
msgid "When loading a zImage kernel ((loadflags & 0x01) == 0)."
msgstr ""

#: ../../../arch/x86/boot.rst:1089
msgid "When loading a 2.01 or earlier boot protocol kernel."
msgstr ""

#: ../../../arch/x86/boot.rst:1092
msgid ""
"For the 2.00 and 2.01 boot protocols, the real-mode code can be loaded at "
"another address, but it is internally relocated to 0x90000.  For the \"old\" "
"protocol, the real-mode code must be loaded at 0x90000."
msgstr ""

#: ../../../arch/x86/boot.rst:1097
msgid "When loading at 0x90000, avoid using memory above 0x9a000."
msgstr ""

#: ../../../arch/x86/boot.rst:1099
msgid ""
"For boot protocol 2.02 or higher, the command line does not have to be "
"located in the same 64K segment as the real-mode setup code; it is thus "
"permitted to give the stack/heap the full 64K segment and locate the command "
"line above it."
msgstr ""

#: ../../../arch/x86/boot.rst:1104
msgid ""
"The kernel command line should not be located below the real-mode code, nor "
"should it be located in high memory."
msgstr ""

#: ../../../arch/x86/boot.rst:1109
msgid "Sample Boot Configuration"
msgstr ""

#: ../../../arch/x86/boot.rst:1111
msgid ""
"As a sample configuration, assume the following layout of the real mode "
"segment."
msgstr ""

#: ../../../arch/x86/boot.rst:1114
msgid "When loading below 0x90000, use the entire segment:"
msgstr ""

#: ../../../arch/x86/boot.rst:1117 ../../../arch/x86/boot.rst:1125
msgid "0x0000-0x7fff"
msgstr ""

#: ../../../arch/x86/boot.rst:1117 ../../../arch/x86/boot.rst:1125
msgid "Real mode kernel"
msgstr ""

#: ../../../arch/x86/boot.rst:1118
msgid "0x8000-0xdfff"
msgstr ""

#: ../../../arch/x86/boot.rst:1118 ../../../arch/x86/boot.rst:1126
msgid "Stack and heap"
msgstr ""

#: ../../../arch/x86/boot.rst:1119
msgid "0xe000-0xffff"
msgstr ""

#: ../../../arch/x86/boot.rst:1119 ../../../arch/x86/boot.rst:1127
msgid "Kernel command line"
msgstr ""

#: ../../../arch/x86/boot.rst:1122
msgid "When loading at 0x90000 OR the protocol version is 2.01 or earlier:"
msgstr ""

#: ../../../arch/x86/boot.rst:1126
msgid "0x8000-0x97ff"
msgstr ""

#: ../../../arch/x86/boot.rst:1127
msgid "0x9800-0x9fff"
msgstr ""

#: ../../../arch/x86/boot.rst:1130
msgid "Such a boot loader should enter the following fields in the header::"
msgstr ""

#: ../../../arch/x86/boot.rst:1186
msgid "Loading The Rest of The Kernel"
msgstr ""

#: ../../../arch/x86/boot.rst:1188
msgid ""
"The 32-bit (non-real-mode) kernel starts at offset (setup_sects + 1) * 512 "
"in the kernel file (again, if setup_sects == 0 the real value is 4.) It "
"should be loaded at address 0x10000 for Image/zImage kernels and 0x100000 "
"for bzImage kernels."
msgstr ""

#: ../../../arch/x86/boot.rst:1193
msgid ""
"The kernel is a bzImage kernel if the protocol >= 2.00 and the 0x01 bit "
"(LOAD_HIGH) in the loadflags field is set::"
msgstr ""

#: ../../../arch/x86/boot.rst:1200
msgid ""
"Image/zImage kernels can be up to 512K in size, and thus use the entire "
"0x10000-0x90000 range of memory.  This means it is pretty much a requirement "
"for these kernels to load the real-mode part at 0x90000. bzImage kernels "
"allow much more flexibility."
msgstr ""

#: ../../../arch/x86/boot.rst:1206
msgid "Special Command Line Options"
msgstr ""

#: ../../../arch/x86/boot.rst:1208
msgid ""
"If the command line provided by the boot loader is entered by the user, the "
"user may expect the following command line options to work. They should "
"normally not be deleted from the kernel command line even though not all of "
"them are actually meaningful to the kernel.  Boot loader authors who need "
"additional command line options for the boot loader itself should get them "
"registered in Documentation/admin-guide/kernel-parameters.rst to make sure "
"they will not conflict with actual kernel options now or in the future."
msgstr ""

#: ../../../arch/x86/boot.rst:1217
msgid "vga=<mode>"
msgstr ""

#: ../../../arch/x86/boot.rst:1218
msgid ""
"<mode> here is either an integer (in C notation, either decimal, octal, or "
"hexadecimal) or one of the strings \"normal\" (meaning 0xFFFF), "
"\"ext\" (meaning 0xFFFE) or \"ask\" (meaning 0xFFFD).  This value should be "
"entered into the vid_mode field, as it is used by the kernel before the "
"command line is parsed."
msgstr ""

#: ../../../arch/x86/boot.rst:1225
msgid "mem=<size>"
msgstr ""

#: ../../../arch/x86/boot.rst:1226
msgid ""
"<size> is an integer in C notation optionally followed by (case insensitive) "
"K, M, G, T, P or E (meaning << 10, << 20, << 30, << 40, << 50 or << 60).  "
"This specifies the end of memory to the kernel. This affects the possible "
"placement of an initrd, since an initrd should be placed near end of "
"memory.  Note that this is an option to *both* the kernel and the bootloader!"
msgstr ""

#: ../../../arch/x86/boot.rst:1234
msgid "initrd=<file>"
msgstr ""

#: ../../../arch/x86/boot.rst:1235
msgid ""
"An initrd should be loaded.  The meaning of <file> is obviously bootloader-"
"dependent, and some boot loaders (e.g. LILO) do not have such a command."
msgstr ""

#: ../../../arch/x86/boot.rst:1239
msgid ""
"In addition, some boot loaders add the following options to the user-"
"specified command line:"
msgstr ""

#: ../../../arch/x86/boot.rst:1242
msgid "BOOT_IMAGE=<file>"
msgstr ""

#: ../../../arch/x86/boot.rst:1243
msgid ""
"The boot image which was loaded.  Again, the meaning of <file> is obviously "
"bootloader-dependent."
msgstr ""

#: ../../../arch/x86/boot.rst:1246
msgid "auto"
msgstr ""

#: ../../../arch/x86/boot.rst:1247
msgid "The kernel was booted without explicit user intervention."
msgstr ""

#: ../../../arch/x86/boot.rst:1249
msgid ""
"If these options are added by the boot loader, it is highly recommended that "
"they are located *first*, before the user-specified or configuration-"
"specified command line.  Otherwise, \"init=/bin/sh\" gets confused by the "
"\"auto\" option."
msgstr ""

#: ../../../arch/x86/boot.rst:1256
msgid "Running the Kernel"
msgstr ""

#: ../../../arch/x86/boot.rst:1258
msgid ""
"The kernel is started by jumping to the kernel entry point, which is located "
"at *segment* offset 0x20 from the start of the real mode kernel.  This means "
"that if you loaded your real-mode kernel code at 0x90000, the kernel entry "
"point is 9020:0000."
msgstr ""

#: ../../../arch/x86/boot.rst:1263
msgid ""
"At entry, ds = es = ss should point to the start of the real-mode kernel "
"code (0x9000 if the code is loaded at 0x90000), sp should be set up "
"properly, normally pointing to the top of the heap, and interrupts should be "
"disabled.  Furthermore, to guard against bugs in the kernel, it is "
"recommended that the boot loader sets fs = gs = ds = es = ss."
msgstr ""

#: ../../../arch/x86/boot.rst:1270
msgid "In our example from above, we would do::"
msgstr ""

#: ../../../arch/x86/boot.rst:1287
msgid ""
"If your boot sector accesses a floppy drive, it is recommended to switch off "
"the floppy motor before running the kernel, since the kernel boot leaves "
"interrupts off and thus the motor will not be switched off, especially if "
"the loaded kernel has the floppy driver as a demand-loaded module!"
msgstr ""

#: ../../../arch/x86/boot.rst:1295
msgid "Advanced Boot Loader Hooks"
msgstr ""

#: ../../../arch/x86/boot.rst:1297
msgid ""
"If the boot loader runs in a particularly hostile environment (such as "
"LOADLIN, which runs under DOS) it may be impossible to follow the standard "
"memory location requirements.  Such a boot loader may use the following "
"hooks that, if set, are invoked by the kernel at the appropriate time.  The "
"use of these hooks should probably be considered an absolutely last resort!"
msgstr ""

#: ../../../arch/x86/boot.rst:1304
msgid ""
"IMPORTANT: All the hooks are required to preserve %esp, %ebp, %esi and %edi "
"across invocation."
msgstr ""

#: ../../../arch/x86/boot.rst:1307
msgid "realmode_swtch:"
msgstr ""

#: ../../../arch/x86/boot.rst:1308
msgid ""
"A 16-bit real mode far subroutine invoked immediately before entering "
"protected mode.  The default routine disables NMI, so your routine should "
"probably do so, too."
msgstr ""

#: ../../../arch/x86/boot.rst:1312
msgid "code32_start:"
msgstr ""

#: ../../../arch/x86/boot.rst:1313
msgid ""
"A 32-bit flat-mode routine *jumped* to immediately after the transition to "
"protected mode, but before the kernel is uncompressed.  No segments, except "
"CS, are guaranteed to be set up (current kernels do, but older ones do not); "
"you should set them up to BOOT_DS (0x18) yourself."
msgstr ""

#: ../../../arch/x86/boot.rst:1319
msgid ""
"After completing your hook, you should jump to the address that was in this "
"field before your boot loader overwrote it (relocated, if appropriate.)"
msgstr ""

#: ../../../arch/x86/boot.rst:1325
msgid "32-bit Boot Protocol"
msgstr ""

#: ../../../arch/x86/boot.rst:1327
msgid ""
"For machine with some new BIOS other than legacy BIOS, such as EFI, "
"LinuxBIOS, etc, and kexec, the 16-bit real mode setup code in kernel based "
"on legacy BIOS can not be used, so a 32-bit boot protocol needs to be "
"defined."
msgstr ""

#: ../../../arch/x86/boot.rst:1332
msgid ""
"In 32-bit boot protocol, the first step in loading a Linux kernel should be "
"to setup the boot parameters (struct boot_params, traditionally known as "
"\"zero page\"). The memory for struct boot_params should be allocated and "
"initialized to all zero. Then the setup header from offset 0x01f1 of kernel "
"image on should be loaded into struct boot_params and examined. The end of "
"setup header can be calculated as follow::"
msgstr ""

#: ../../../arch/x86/boot.rst:1342 ../../../arch/x86/boot.rst:1378
msgid ""
"In addition to read/modify/write the setup header of the struct boot_params "
"as that of 16-bit boot protocol, the boot loader should also fill the "
"additional fields of the struct boot_params as described in chapter "
"Documentation/arch/x86/zero-page.rst."
msgstr ""

#: ../../../arch/x86/boot.rst:1347
msgid ""
"After setting up the struct boot_params, the boot loader can load the 32/64-"
"bit kernel in the same way as that of 16-bit boot protocol."
msgstr ""

#: ../../../arch/x86/boot.rst:1350
msgid ""
"In 32-bit boot protocol, the kernel is started by jumping to the 32-bit "
"kernel entry point, which is the start address of loaded 32/64-bit kernel."
msgstr ""

#: ../../../arch/x86/boot.rst:1354
msgid ""
"At entry, the CPU must be in 32-bit protected mode with paging disabled; a "
"GDT must be loaded with the descriptors for selectors __BOOT_CS(0x10) and "
"__BOOT_DS(0x18); both descriptors must be 4G flat segment; __BOOT_CS must "
"have execute/read permission, and __BOOT_DS must have read/write permission; "
"CS must be __BOOT_CS and DS, ES, SS must be __BOOT_DS; interrupt must be "
"disabled; %esi must hold the base address of the struct boot_params; %ebp, "
"%edi and %ebx must be zero."
msgstr ""

#: ../../../arch/x86/boot.rst:1363
msgid "64-bit Boot Protocol"
msgstr ""

#: ../../../arch/x86/boot.rst:1365
msgid ""
"For machine with 64bit cpus and 64bit kernel, we could use 64bit bootloader "
"and we need a 64-bit boot protocol."
msgstr ""

#: ../../../arch/x86/boot.rst:1368
msgid ""
"In 64-bit boot protocol, the first step in loading a Linux kernel should be "
"to setup the boot parameters (struct boot_params, traditionally known as "
"\"zero page\"). The memory for struct boot_params could be allocated "
"anywhere (even above 4G) and initialized to all zero. Then, the setup header "
"at offset 0x01f1 of kernel image on should be loaded into struct boot_params "
"and examined. The end of setup header can be calculated as follows::"
msgstr ""

#: ../../../arch/x86/boot.rst:1383
msgid ""
"After setting up the struct boot_params, the boot loader can load 64-bit "
"kernel in the same way as that of 16-bit boot protocol, but kernel could be "
"loaded above 4G."
msgstr ""

#: ../../../arch/x86/boot.rst:1387
msgid ""
"In 64-bit boot protocol, the kernel is started by jumping to the 64-bit "
"kernel entry point, which is the start address of loaded 64-bit kernel plus "
"0x200."
msgstr ""

#: ../../../arch/x86/boot.rst:1391
msgid ""
"At entry, the CPU must be in 64-bit mode with paging enabled. The range with "
"setup_header.init_size from start address of loaded kernel and zero page and "
"command line buffer get ident mapping; a GDT must be loaded with the "
"descriptors for selectors __BOOT_CS(0x10) and __BOOT_DS(0x18); both "
"descriptors must be 4G flat segment; __BOOT_CS must have execute/read "
"permission, and __BOOT_DS must have read/write permission; CS must be "
"__BOOT_CS and DS, ES, SS must be __BOOT_DS; interrupt must be disabled; %rsi "
"must hold the base address of the struct boot_params."
msgstr ""

#: ../../../arch/x86/boot.rst:1402
msgid "EFI Handover Protocol (deprecated)"
msgstr ""

#: ../../../arch/x86/boot.rst:1404
msgid ""
"This protocol allows boot loaders to defer initialisation to the EFI boot "
"stub. The boot loader is required to load the kernel/initrd(s) from the boot "
"media and jump to the EFI handover protocol entry point which is hdr-"
">handover_offset bytes from the beginning of startup_{32,64}."
msgstr ""

#: ../../../arch/x86/boot.rst:1410
msgid ""
"The boot loader MUST respect the kernel's PE/COFF metadata when it comes to "
"section alignment, the memory footprint of the executable image beyond the "
"size of the file itself, and any other aspect of the PE/COFF header that may "
"affect correct operation of the image as a PE/COFF binary in the execution "
"context provided by the EFI firmware."
msgstr ""

#: ../../../arch/x86/boot.rst:1416
msgid "The function prototype for the handover entry point looks like this::"
msgstr ""

#: ../../../arch/x86/boot.rst:1420
msgid ""
"'handle' is the EFI image handle passed to the boot loader by the EFI "
"firmware, 'table' is the EFI system table - these are the first two "
"arguments of the \"handoff state\" as described in section 2.3 of the UEFI "
"specification. 'bp' is the boot loader-allocated boot params."
msgstr ""

#: ../../../arch/x86/boot.rst:1425
msgid "The boot loader *must* fill out the following fields in bp::"
msgstr ""

#: ../../../arch/x86/boot.rst:1431
msgid "All other fields should be zero."
msgstr ""

#: ../../../arch/x86/boot.rst:1434
msgid ""
"The EFI Handover Protocol is deprecated in favour of the ordinary PE/COFF "
"entry point, combined with the LINUX_EFI_INITRD_MEDIA_GUID based initrd "
"loading protocol (refer to [0] for an example of the bootloader side of "
"this), which removes the need for any knowledge on the part of the EFI "
"bootloader regarding the internal representation of boot_params or any "
"requirements/limitations regarding the placement of the command line and "
"ramdisk in memory, or the placement of the kernel image itself."
msgstr ""

#: ../../../arch/x86/boot.rst:1442
msgid ""
"[0] https://github.com/u-boot/u-boot/commit/"
"ec80b4735a593961fe701cc3a5d717d4739b0fd0"
msgstr ""
