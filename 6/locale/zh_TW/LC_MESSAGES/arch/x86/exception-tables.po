# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/exception-tables.rst:5
msgid "Kernel level exception handling"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:7
msgid "Commentary by Joerg Pommnitz <joerg@raleigh.ibm.com>"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:9
msgid ""
"When a process runs in kernel mode, it often has to access user mode memory "
"whose address has been passed by an untrusted program. To protect itself the "
"kernel has to verify this address."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:13
msgid ""
"In older versions of Linux this was done with the int verify_area(int type, "
"const void * addr, unsigned long size) function (which has since been "
"replaced by access_ok())."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:17
msgid ""
"This function verified that the memory area starting at address 'addr' and "
"of size 'size' was accessible for the operation specified in type (read or "
"write). To do this, verify_read had to look up the virtual memory area (vma) "
"that contained the address addr. In the normal case (correctly working "
"program), this test was successful. It only failed for a few buggy programs. "
"In some kernel profiling tests, this normally unneeded verification used up "
"a considerable amount of time."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:26
msgid ""
"To overcome this situation, Linus decided to let the virtual memory hardware "
"present in every Linux-capable CPU handle this test."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:29
msgid "How does this work?"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:31
msgid ""
"Whenever the kernel tries to access an address that is currently not "
"accessible, the CPU generates a page fault exception and calls the page "
"fault handler::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:37
msgid ""
"in arch/x86/mm/fault.c. The parameters on the stack are set up by the low "
"level assembly glue in arch/x86/entry/entry_32.S. The parameter regs is a "
"pointer to the saved registers on the stack, error_code contains a reason "
"code for the exception."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:42
msgid ""
"exc_page_fault() first obtains the inaccessible address from the CPU control "
"register CR2. If the address is within the virtual address space of the "
"process, the fault probably occurred, because the page was not swapped in, "
"write protected or something similar. However, we are interested in the "
"other case: the address is not valid, there is no vma that contains this "
"address. In this case, the kernel jumps to the bad_area label."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:50
msgid ""
"There it uses the address of the instruction that caused the exception (i.e. "
"regs->eip) to find an address where the execution can continue (fixup). If "
"this search is successful, the fault handler modifies the return address "
"(again regs->eip) and returns. The execution will continue at the address in "
"fixup."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:56
msgid "Where does fixup point to?"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:58
msgid ""
"Since we jump to the contents of fixup, fixup obviously points to executable "
"code. This code is hidden inside the user access macros. I have picked the "
"get_user() macro defined in arch/x86/include/asm/uaccess.h as an example. "
"The definition is somewhat hard to follow, so let's peek at the code "
"generated by the preprocessor and the compiler. I selected the get_user() "
"call in drivers/char/sysrq.c for a detailed examination."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:65
msgid "The original code in sysrq.c line 587::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:69
msgid "The preprocessor output (edited to become somewhat readable)::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:131
msgid ""
"WOW! Black GCC/assembly magic. This is impossible to follow, so let's see "
"what code gcc generates::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:158
msgid ""
"The optimizer does a good job and gives us something we can actually "
"understand. Can we? The actual user access is quite obvious. Thanks to the "
"unified address space we can just access the address in user memory. But "
"what does the .section stuff do?????"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:163
msgid "To understand this we have to look at the final kernel::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:188
msgid ""
"There are obviously 2 non standard ELF sections in the generated object "
"file. But first we want to find out what happened to our code in the final "
"kernel executable::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:205
msgid ""
"The whole user memory access is reduced to 10 x86 machine instructions. The "
"instructions bracketed in the .section directives are no longer in the "
"normal execution path. They are located in a different section of the "
"executable file::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:216
msgid "And finally::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:224
msgid "or in human readable byte order::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:232
msgid "What happened? The assembly directives::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:237
msgid ""
"told the assembler to move the following code to the specified sections in "
"the ELF object file. So the instructions::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:244
msgid "ended up in the .fixup section of the object file and the addresses::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:248
msgid ""
"ended up in the __ex_table section of the object file. 1b and 3b are local "
"labels. The local label 1b (1b stands for next label 1 backward) is the "
"address of the instruction that might fault, i.e. in our case the address of "
"the label 1 is c017e7a5: the original assembly code: > 1:      movb (%ebx),"
"%dl and linked in vmlinux     : > c017e7a5 <do_con_write+e1> movb   (%ebx),"
"%dl"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:255
msgid ""
"The local label 3 (backwards again) is the address of the code to handle the "
"fault, in our case the actual value is c0199ff5: the original assembly code: "
"> 3:      movl $-14,%eax and linked in vmlinux     : > c0199ff5 <."
"fixup+10b5> movl   $0xfffffff2,%eax"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:260
msgid ""
"If the fixup was able to handle the exception, control flow may be returned "
"to the instruction after the one that triggered the fault, ie. local label "
"2b."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:263
msgid "The assembly code::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:269
msgid "becomes the value pair::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:275
msgid "c017e7a5,c0199ff5 in the exception table of the kernel."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:277
msgid ""
"So, what actually happens if a fault from kernel mode with no suitable vma "
"occurs?"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:280
msgid "access to invalid address::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:283
msgid "MMU generates exception"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:284
msgid "CPU calls exc_page_fault()"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:285
msgid "exc_page_fault() calls do_user_addr_fault()"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:286
msgid "do_user_addr_fault() calls kernelmode_fixup_or_oops()"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:287
msgid ""
"kernelmode_fixup_or_oops() calls fixup_exception() (regs->eip == c017e7a5);"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:288
msgid "fixup_exception() calls search_exception_tables()"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:289
msgid ""
"search_exception_tables() looks up the address c017e7a5 in the exception "
"table (i.e. the contents of the ELF section __ex_table) and returns the "
"address of the associated fault handle code c0199ff5."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:292
msgid ""
"fixup_exception() modifies its own return address to point to the fault "
"handle code and returns."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:294
msgid "execution continues in the fault handling code."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:295
msgid "EAX becomes -EFAULT (== -14)"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:296
msgid "DL  becomes zero (the value we \"read\" from user space)"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:297
msgid ""
"execution continues at local label 2 (address of the instruction immediately "
"after the faulting user access)."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:300
msgid ""
"The steps a to c above in a certain way emulate the faulting instruction."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:302
msgid ""
"That's it, mostly. If you look at our example, you might ask why we set EAX "
"to -EFAULT in the exception handler code. Well, the get_user() macro "
"actually returns a value: 0, if the user access was successful, -EFAULT on "
"failure. Our original code did not test this return value, however the "
"inline assembly code in get_user() tries to return -EFAULT. GCC selected EAX "
"to return this value."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:309
msgid ""
"NOTE: Due to the way that the exception table is built and needs to be "
"ordered, only use exceptions for code in the .text section.  Any other "
"section will cause the exception table to not be sorted correctly, and the "
"exceptions will fail."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:315
msgid ""
"Things changed when 64-bit support was added to x86 Linux. Rather than "
"double the size of the exception table by expanding the two entries from 32-"
"bits to 64 bits, a clever trick was used to store addresses as relative "
"offsets from the table itself. The assembly code changed from::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:326
msgid ""
"and the C-code that uses these values converts back to absolute addresses "
"like this::"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:334
msgid ""
"In v4.6 the exception table entry was expanded with a new field \"handler\". "
"This is also 32-bits wide and contains a third relative function pointer "
"which points to one of:"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:338
msgid "``int ex_handler_default(const struct exception_table_entry *fixup)``"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:339
msgid "This is legacy case that just jumps to the fixup code"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:341
msgid "``int ex_handler_fault(const struct exception_table_entry *fixup)``"
msgstr ""

#: ../../../arch/x86/exception-tables.rst:342
msgid ""
"This case provides the fault number of the trap that occurred at entry-"
">insn. It is used to distinguish page faults from machine check."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:346
msgid "More functions can easily be added."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:348
msgid ""
"CONFIG_BUILDTIME_TABLE_SORT allows the __ex_table section to be sorted post "
"link of the kernel image, via a host utility scripts/sorttable. It will set "
"the symbol main_extable_sort_needed to 0, avoiding sorting the __ex_table "
"section at boot time. With the exception table sorted, at runtime when an "
"exception occurs we can quickly lookup the __ex_table entry via binary "
"search."
msgstr ""

#: ../../../arch/x86/exception-tables.rst:354
msgid ""
"This is not just a boot time optimization, some architectures require this "
"table to be sorted in order to handle exceptions relatively early in the "
"boot process. For example, i386 makes use of this form of exception handling "
"before paging support is even enabled!"
msgstr ""
