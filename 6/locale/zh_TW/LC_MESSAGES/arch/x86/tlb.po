# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/tlb.rst:5
msgid "The TLB"
msgstr ""

#: ../../../arch/x86/tlb.rst:7
msgid ""
"When the kernel unmaps or modified the attributes of a range of memory, it "
"has two choices:"
msgstr ""

#: ../../../arch/x86/tlb.rst:10
msgid ""
"Flush the entire TLB with a two-instruction sequence.  This is a quick "
"operation, but it causes collateral damage: TLB entries from areas other "
"than the one we are trying to flush will be destroyed and must be refilled "
"later, at some cost."
msgstr ""

#: ../../../arch/x86/tlb.rst:14
msgid ""
"Use the invlpg instruction to invalidate a single page at a time.  This "
"could potentially cost many more instructions, but it is a much more precise "
"operation, causing no collateral damage to other TLB entries."
msgstr ""

#: ../../../arch/x86/tlb.rst:19
msgid "Which method to do depends on a few things:"
msgstr ""

#: ../../../arch/x86/tlb.rst:21
msgid ""
"The size of the flush being performed.  A flush of the entire address space "
"is obviously better performed by flushing the entire TLB than doing 2^48/"
"PAGE_SIZE individual flushes."
msgstr ""

#: ../../../arch/x86/tlb.rst:24
msgid ""
"The contents of the TLB.  If the TLB is empty, then there will be no "
"collateral damage caused by doing the global flush, and all of the "
"individual flush will have ended up being wasted work."
msgstr ""

#: ../../../arch/x86/tlb.rst:28
msgid ""
"The size of the TLB.  The larger the TLB, the more collateral damage we do "
"with a full flush.  So, the larger the TLB, the more attractive an "
"individual flush looks.  Data and instructions have separate TLBs, as do "
"different page sizes."
msgstr ""

#: ../../../arch/x86/tlb.rst:32
msgid ""
"The microarchitecture.  The TLB has become a multi-level cache on modern "
"CPUs, and the global flushes have become more expensive relative to single-"
"page flushes."
msgstr ""

#: ../../../arch/x86/tlb.rst:36
msgid ""
"There is obviously no way the kernel can know all these things, especially "
"the contents of the TLB during a given flush.  The sizes of the flush will "
"vary greatly depending on the workload as well.  There is essentially no "
"\"right\" point to choose."
msgstr ""

#: ../../../arch/x86/tlb.rst:41
msgid ""
"You may be doing too many individual invalidations if you see the invlpg "
"instruction (or instructions _near_ it) show up high in profiles.  If you "
"believe that individual invalidations being called too often, you can lower "
"the tunable::"
msgstr ""

#: ../../../arch/x86/tlb.rst:48
msgid ""
"This will cause us to do the global flush for more cases. Lowering it to 0 "
"will disable the use of the individual flushes. Setting it to 1 is a very "
"conservative setting and it should never need to be 0 under normal "
"circumstances."
msgstr ""

#: ../../../arch/x86/tlb.rst:53
msgid ""
"Despite the fact that a single individual flush on x86 is guaranteed to "
"flush a full 2MB [1]_, hugetlbfs always uses the full flushes.  THP is "
"treated exactly the same as normal memory."
msgstr ""

#: ../../../arch/x86/tlb.rst:57
msgid ""
"You might see invlpg inside of flush_tlb_mm_range() show up in profiles, or "
"you can use the trace_tlb_flush() tracepoints. to determine how long the "
"flush operations are taking."
msgstr ""

#: ../../../arch/x86/tlb.rst:61
msgid ""
"Essentially, you are balancing the cycles you spend doing invlpg with the "
"cycles that you spend refilling the TLB later."
msgstr ""

#: ../../../arch/x86/tlb.rst:64
msgid ""
"You can measure how expensive TLB refills are by using performance counters "
"and 'perf stat', like this::"
msgstr ""

#: ../../../arch/x86/tlb.rst:75
msgid ""
"That works on an IvyBridge-era CPU (i5-3320M).  Different CPUs may have "
"differently-named counters, but they should at least be there in some form.  "
"You can use pmu-tools 'ocperf list' (https://github.com/andikleen/pmu-tools) "
"to find the right counters for a given CPU."
msgstr ""

#: ../../../arch/x86/tlb.rst:81
msgid ""
"A footnote in Intel's SDM \"4.10.4.2 Recommended Invalidation\" says: \"One "
"execution of INVLPG is sufficient even for a page with size greater than 4 "
"KBytes.\""
msgstr ""
