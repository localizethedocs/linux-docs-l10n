# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/x86_64/fred.rst:5
msgid "Flexible Return and Event Delivery (FRED)"
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:8
msgid "Overview"
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:10
msgid ""
"The FRED architecture defines simple new transitions that change privilege "
"level (ring transitions). The FRED architecture was designed with the "
"following goals:"
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:14
msgid ""
"Improve overall performance and response time by replacing event delivery "
"through the interrupt descriptor table (IDT event delivery) and event return "
"by the IRET instruction with lower latency transitions."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:19
msgid ""
"Improve software robustness by ensuring that event delivery establishes the "
"full supervisor context and that event return establishes the full user "
"context."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:23
msgid ""
"The new transitions defined by the FRED architecture are FRED event delivery "
"and, for returning from events, two FRED return instructions. FRED event "
"delivery can effect a transition from ring 3 to ring 0, but it is used also "
"to deliver events incident to ring 0. One FRED instruction (ERETU) effects a "
"return from ring 0 to ring 3, while the other (ERETS) returns while "
"remaining in ring 0. Collectively, FRED event delivery and the FRED return "
"instructions are FRED transitions."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:31
msgid ""
"In addition to these transitions, the FRED architecture defines a new "
"instruction (LKGS) for managing the state of the GS segment register. The "
"LKGS instruction can be used by 64-bit operating systems that do not use the "
"new FRED transitions."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:36
msgid ""
"Furthermore, the FRED architecture is easy to extend for future CPU "
"architectures."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:40
msgid "Software based event dispatching"
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:42
msgid ""
"FRED operates differently from IDT in terms of event handling. Instead of "
"directly dispatching an event to its handler based on the event vector, FRED "
"requires the software to dispatch an event to its handler based on both the "
"event's type and vector. Therefore, an event dispatch framework must be "
"implemented to facilitate the event-to-handler dispatch process. The FRED "
"event dispatch framework takes control once an event is delivered, and "
"employs a two-level dispatch."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:50
msgid ""
"The first level dispatching is event type based, and the second level "
"dispatching is event vector based."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:54
msgid "Full supervisor/user context"
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:56
msgid ""
"FRED event delivery atomically save and restore full supervisor/user context "
"upon event delivery and return. Thus it avoids the problem of transient "
"states due to %cr2 and/or %dr6, and it is no longer needed to handle all the "
"ugly corner cases caused by half baked entry states."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:61
msgid ""
"FRED allows explicit unblock of NMI with new event return instructions ERETS/"
"ERETU, avoiding the mess caused by IRET which unconditionally unblocks NMI, "
"e.g., when an exception happens during NMI handling."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:65
msgid ""
"FRED always restores the full value of %rsp, thus ESPFIX is no longer needed "
"when FRED is enabled."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:69
msgid "LKGS"
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:71
msgid ""
"LKGS behaves like the MOV to GS instruction except that it loads the base "
"address into the IA32_KERNEL_GS_BASE MSR instead of the GS segmentâ€™s "
"descriptor cache. With LKGS, it ends up with avoiding mucking with kernel "
"GS, i.e., an operating system can always operate with its own GS base "
"address."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:77
msgid ""
"Because FRED event delivery from ring 3 and ERETU both swap the value of the "
"GS base address and that of the IA32_KERNEL_GS_BASE MSR, plus the "
"introduction of LKGS instruction, the SWAPGS instruction is no longer needed "
"when FRED is enabled, thus is disallowed (#UD)."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:83
msgid "Stack levels"
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:85
msgid ""
"4 stack levels 0~3 are introduced to replace the nonreentrant IST for event "
"handling, and each stack level should be configured to use a dedicated stack."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:89
msgid ""
"The current stack level could be unchanged or go higher upon FRED event "
"delivery. If unchanged, the CPU keeps using the current event stack. If "
"higher, the CPU switches to a new event stack specified by the MSR of the "
"new stack level, i.e., MSR_IA32_FRED_RSP[123]."
msgstr ""

#: ../../../arch/x86/x86_64/fred.rst:94
msgid ""
"Only execution of a FRED return instruction ERET[US], could lower the "
"current stack level, causing the CPU to switch back to the stack it was on "
"before a previous event delivery that promoted the stack level."
msgstr ""
