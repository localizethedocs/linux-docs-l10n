# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/amd-debugging.rst:4
msgid "Debugging AMD Zen systems"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:7
msgid "Introduction"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:9
msgid ""
"This document describes techniques that are useful for debugging issues with "
"AMD Zen systems.  It is intended for use by developers and technical users "
"to help identify and resolve issues."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:14
msgid "S3 vs s2idle"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:16
msgid ""
"On AMD systems, it's not possible to simultaneously support suspend-to-RAM "
"(S3) and suspend-to-idle (s2idle).  To confirm which mode your system "
"supports you can look at ``cat /sys/power/mem_sleep``.  If it shows ``s2idle "
"[deep]`` then *S3* is supported.  If it shows ``[s2idle]`` then *s2idle* is "
"supported."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:22
msgid ""
"On systems that support *S3*, the firmware will be utilized to put all "
"hardware into the appropriate low power state."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:25
msgid ""
"On systems that support *s2idle*, the kernel will be responsible for "
"transitioning devices into the appropriate low power state. When all devices "
"are in the appropriate low power state, the hardware will transition into a "
"hardware sleep state."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:29
msgid ""
"After a suspend cycle you can tell how much time was spent in a hardware "
"sleep state by looking at ``cat /sys/power/suspend_stats/last_hw_sleep``."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:32
msgid "This flowchart explains how the AMD s2idle suspend flow works."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:36
msgid "This flowchart explains how the amd s2idle resume flow works."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:41
msgid "s2idle debugging tool"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:43
msgid ""
"As there are a lot of places that problems can occur, a debugging tool has "
"been created at `amd-debug-tools <https://git.kernel.org/pub/scm/linux/"
"kernel/git/superm1/amd-debug-tools.git/about/>`_ that can help test for "
"common problems and offer suggestions."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:48
msgid ""
"If you have an s2idle issue, it's best to start with this and follow "
"instructions from its findings.  If you continue to have an issue, raise a "
"bug with the report generated from this script to `drm/amd gitlab <https://"
"gitlab.freedesktop.org/drm/amd/-/issues/new?"
"issuable_template=s2idle_BUG_TEMPLATE>`_."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:54
msgid "Spurious s2idle wakeups from an IRQ"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:56
msgid ""
"Spurious wakeups will generally have an IRQ set to ``/sys/power/"
"pm_wakeup_irq``. This can be matched to ``/proc/interrupts`` to determine "
"what device woke the system."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:59
msgid ""
"If this isn't enough to debug the problem, then the following sysfs files "
"can be set to add more verbosity to the wakeup process: ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:65
msgid ""
"After making those changes, the kernel will display messages that can be "
"traced back to kernel s2idle loop code as well as display any active GPIO "
"sources while waking up."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:69
msgid ""
"If the wakeup is caused by the ACPI SCI, additional ACPI debugging may be "
"needed.  These commands can enable additional trace data: ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:78
msgid "Spurious s2idle wakeups from a GPIO"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:80
msgid ""
"If a GPIO is active when waking up the system ideally you would look at the "
"schematic to determine what device it is associated with. If the schematic "
"is not available, another tactic is to look at the ACPI _EVT() entry to "
"determine what device is notified when that GPIO is active."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:85
msgid ""
"For a hypothetical example, say that GPIO 59 woke up the system.  You can "
"look at the SSDT to determine what device is notified when GPIO 59 is active."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:88
msgid "First convert the GPIO number into hex. ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:93
msgid "Next determine which ACPI table has the ``_EVT`` entry. For example: ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:98
msgid "Decode this table::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:103
msgid "Then look at the table and find the matching entry for GPIO 0x3b. ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:112
msgid ""
"You can see in this case that the device ``\\_SB.PCI0.GP17.XHC1`` is "
"notified when GPIO 59 is active. It's obvious this is an XHCI controller, "
"but to go a step further you can figure out which XHCI controller it is by "
"matching it to ACPI.::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:126
msgid ""
"Here you can see it matches to ``device:2d``. Look at the ``physical_node`` "
"to determine what PCI device that actually is. ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:132
msgid ""
"So there you have it: the PCI device associated with this GPIO wakeup was "
"``0000:c2:00.4``."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:134
msgid ""
"The ``amd_s2idle.py`` script will capture most of these artifacts for you."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:137
msgid "s2idle PM debug messages"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:139
msgid ""
"During the s2idle flow on AMD systems, the ACPI LPS0 driver is responsible "
"to check all uPEP constraints.  Failing uPEP constraints does not prevent "
"s0i3 entry.  This means that if some constraints are not met, it is possible "
"the kernel may attempt to enter s2idle even if there are some known issues."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:144
msgid ""
"To activate PM debugging, either specify ``pm_debug_messagess`` kernel "
"command-line option at boot or write to ``/sys/power/pm_debug_messages``. "
"Unmet constraints will be displayed in the kernel log and can be viewed by "
"logging tools that process kernel ring buffer like ``dmesg`` or "
"``journalctl``.\""
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:150
msgid ""
"If the system freezes on entry/exit before these messages are flushed, a "
"useful debugging tactic is to unbind the ``amd_pmc`` driver to prevent "
"notification to the platform to start s0i3 entry.  This will stop the system "
"from freezing on entry or exit and let you view all the failed "
"constraints. ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:159
msgid ""
"After doing this, run the suspend cycle and look specifically for errors "
"around: ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:164
msgid "Historical examples of s2idle issues"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:166
msgid ""
"To help understand the types of issues that can occur and how to debug them, "
"here are some historical examples of s2idle issues that have been resolved."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:170
msgid "Core offlining"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:171
msgid ""
"An end user had reported that taking a core offline would prevent the system "
"from properly entering s0i3.  This was debugged using internal AMD tools to "
"capture and display a stream of metrics from the hardware showing what "
"changed when a core was offlined.  It was determined that the hardware "
"didn't get notification the offline cores were in the deepest state, and so "
"it prevented CPU from going into the deepest state. The issue was debugged "
"to a missing command to put cores into C3 upon offline."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:179
msgid ""
"`commit d6b88ce2eb9d2 (\"ACPI: processor idle: Allow playing dead in C3 "
"state\") <https://git.kernel.org/torvalds/c/d6b88ce2eb9d2>`_"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:182
msgid "Corruption after resume"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:183
msgid ""
"A big problem that occurred with Rembrandt was that there was graphical "
"corruption after resume.  This happened because of a misalignment of PSP and "
"driver responsibility.  The PSP will save and restore DMCUB, but the driver "
"assumed it needed to reset DMCUB on resume. This actually was a misalignment "
"for earlier silicon as well, but was not observed."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:190
msgid ""
"`commit 79d6b9351f086 (\"drm/amd/display: Don't reinitialize DMCUB on s0ix "
"resume\") <https://git.kernel.org/torvalds/c/79d6b9351f086>`_"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:193
msgid "Back to Back suspends fail"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:194
msgid ""
"When using a wakeup source that triggers the IRQ to wakeup, a bug in the "
"pinctrl-amd driver may capture the wrong state of the IRQ and prevent the "
"system going back to sleep properly."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:198
msgid ""
"`commit b8c824a869f22 (\"pinctrl: amd: Don't save/restore interrupt status "
"and wake status bits\") <https://git.kernel.org/torvalds/c/b8c824a869f22>`_"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:201
msgid "Spurious timer based wakeup after 5 minutes"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:202
msgid ""
"The HPET was being used to program the wakeup source for the system, however "
"this was causing a spurious wakeup after 5 minutes.  The correct alarm to "
"use was the ACPI alarm."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:206
msgid ""
"`commit 3d762e21d5637 (\"rtc: cmos: Use ACPI alarm for non-Intel x86 systems "
"too\") <https://git.kernel.org/torvalds/c/3d762e21d5637>`_"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:209
msgid "Disk disappears after resume"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:210
msgid ""
"After resuming from s2idle, the NVME disk would disappear.  This was due to "
"the BIOS not specifying the _DSD StorageD3Enable property.  This caused the "
"NVME driver not to put the disk into the expected state at suspend and to "
"fail on resume."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:215
msgid ""
"`commit e79a10652bbd3 (\"ACPI: x86: Force StorageD3Enable on more "
"products\") <https://git.kernel.org/torvalds/c/e79a10652bbd3>`_"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:218
msgid "Spurious IRQ1"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:219
msgid ""
"A number of Renoir, Lucienne, Cezanne, & Barcelo platforms have a platform "
"firmware bug where IRQ1 is triggered during s0i3 resume."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:222
msgid ""
"This was fixed in the platform firmware, but a number of systems didn't "
"receive any more platform firmware updates."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:225
msgid ""
"`commit 8e60615e89321 (\"platform/x86/amd: pmc: Disable IRQ1 wakeup for RN/"
"CZN\") <https://git.kernel.org/torvalds/c/8e60615e89321>`_"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:228
msgid "Hardware timeout"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:229
msgid ""
"The hardware performs many actions besides accepting the values from amd-pmc "
"driver.  As the communication path with the hardware is a mailbox, it's "
"possible that it might not respond quickly enough. This issue manifested as "
"a failure to suspend: ::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:237
msgid ""
"The timing problem was identified by comparing the values of the idle mask."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:239
msgid ""
"`commit 3c3c8e88c8712 (\"platform/x86: amd-pmc: Increase the response "
"register timeout\") <https://git.kernel.org/torvalds/c/3c3c8e88c8712>`_"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:242
msgid "Failed to reach hardware sleep state with panel on"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:243
msgid ""
"On some Strix systems certain panels were observed to block the system from "
"entering a hardware sleep state if the internal panel was on during the "
"sequence."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:246
msgid ""
"Even though the panel got turned off during suspend it exposed a timing "
"problem where an interrupt caused the display hardware to wake up and block "
"low power state entry."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:250
msgid ""
"`commit 40b8c14936bd2 (\"drm/amd/display: Disable unneeded hpd interrupts "
"during dm_init\") <https://git.kernel.org/torvalds/c/40b8c14936bd2>`_"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:253
msgid "Runtime power consumption issues"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:255
msgid ""
"Runtime power consumption is influenced by many factors, including but not "
"limited to the configuration of the PCIe Active State Power Management "
"(ASPM), the display brightness, the EPP policy of the CPU, and the power "
"management of the devices."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:261
msgid "ASPM"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:262
msgid ""
"For the best runtime power consumption, ASPM should be programmed as "
"intended by the BIOS from the hardware vendor.  To accomplish this the Linux "
"kernel should be compiled with ``CONFIG_PCIEASPM_DEFAULT`` set to ``y`` and "
"the sysfs file ``/sys/module/pcie_aspm/parameters/policy`` should not be "
"modified."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:267
msgid ""
"Most notably, if L1.2 is not configured properly for any devices, the SoC "
"will not be able to enter the deepest idle state."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:271
msgid "EPP Policy"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:272
msgid ""
"The ``energy_performance_preference`` sysfs file can be used to set a bias "
"of efficiency or performance for a CPU.  This has a direct relationship on "
"the battery life when more heavily biased towards performance."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:278
msgid "BIOS debug messages"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:280
msgid ""
"Most OEM machines don't have a serial UART for outputting kernel or BIOS "
"debug messages. However BIOS debug messages are useful for understanding "
"both BIOS bugs and bugs with the Linux kernel drivers that call BIOS AML."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:284
msgid ""
"As the BIOS on most OEM AMD systems are based off an AMD reference BIOS, the "
"infrastructure used for exporting debugging messages is often the same as "
"AMD reference BIOS."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:289
msgid "Manually Parsing"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:290
msgid ""
"There is generally an ACPI method ``\\M460`` that different paths of the AML "
"will call to emit a message to the BIOS serial log. This method takes 7 "
"arguments, with the first being a string and the rest being optional "
"integers::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:297
msgid ""
"Here is an example of a string that BIOS AML may call out using ``\\M460``::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:301
msgid ""
"Normally when executed, the ``\\M460`` method would populate the additional "
"arguments into the string.  In order to get these messages from the Linux "
"kernel a hook has been added into ACPICA that can capture the *arguments* "
"sent to ``\\M460`` and print them to the kernel ring buffer. For example the "
"following message could be emitted into kernel ring buffer::"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:309
msgid ""
"In order to get these messages, you need to compile with "
"``CONFIG_ACPI_DEBUG`` and then turn on the following ACPICA tracing "
"parameters. This can be done either on the kernel command line or at runtime:"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:313
msgid "``acpi.trace_method_name=\\M460``"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:314
msgid "``acpi.trace_state=method``"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:316
msgid ""
"NOTE: These can be very noisy at bootup. If you turn these parameters on the "
"kernel command, please also consider turning up ``CONFIG_LOG_BUF_SHIFT`` to "
"a larger size such as 17 to avoid losing early boot messages."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:321
msgid "Tool assisted Parsing"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:322
msgid ""
"As mentioned above, parsing by hand can be tedious, especially with a lot of "
"messages.  To help with this, a tool has been created at `amd-debug-tools "
"<https://git.kernel.org/pub/scm/linux/kernel/git/superm1/amd-debug-tools.git/"
"about/>`_ to help parse the messages."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:328
msgid "Random reboot issues"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:330
msgid ""
"When a random reboot occurs, the high-level reason for the reboot is stored "
"in a register that will persist onto the next boot."
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:333
msgid "There are 6 classes of reasons for the reboot:"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:334
msgid "Software induced"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:335
msgid "Power state transition"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:336
msgid "Pin induced"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:337
msgid "Hardware induced"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:338
msgid "Remote reset"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:339
msgid "Internal CPU event"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "Bit"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "Type"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "Reason"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "0"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "Pin"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "thermal pin BP_THERMTRIP_L was tripped"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "1"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "power button was pressed for 4 seconds"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "2"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "shutdown pin was tripped"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "4"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "Remote"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "remote ASF power off command was received"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "9"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "Internal"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "internal CPU thermal limit was tripped"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "16"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "system reset pin BP_SYS_RST_L was tripped"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "17"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "Software"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "software issued PCI reset"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "18"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "software wrote 0x4 to reset control register 0xCF9"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "19"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "software wrote 0x6 to reset control register 0xCF9"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "20"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "software wrote 0xE to reset control register 0xCF9"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "21"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "ACPI-state"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "ACPI power state transition occurred"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "22"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "keyboard reset pin KB_RST_L was tripped"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "23"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "internal CPU shutdown event occurred"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "24"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "Hardware"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "system failed to boot before failed boot timer expired"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "25"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "hardware watchdog timer expired"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "26"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "remote ASF reset command was received"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "27"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "an uncorrected error caused a data fabric sync flood event"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "29"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "FCH and MP1 failed warm reset handshake"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "30"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "a parity error occurred"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "31"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:1
msgid "a software sync flood event occurred"
msgstr ""

#: ../../../arch/x86/amd-debugging.rst:366
msgid ""
"This information is read by the kernel at bootup and printed into the "
"syslog. When a random reboot occurs this message can be helpful to determine "
"the next component to debug."
msgstr ""
