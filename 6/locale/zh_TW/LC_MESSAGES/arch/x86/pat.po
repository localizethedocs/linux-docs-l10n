# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/pat.rst:5
msgid "PAT (Page Attribute Table)"
msgstr ""

#: ../../../arch/x86/pat.rst:7
msgid ""
"x86 Page Attribute Table (PAT) allows for setting the memory attribute at "
"the page level granularity. PAT is complementary to the MTRR settings which "
"allows for setting of memory types over physical address ranges. However, "
"PAT is more flexible than MTRR due to its capability to set attributes at "
"page level and also due to the fact that there are no hardware limitations "
"on number of such attribute settings allowed. Added flexibility comes with "
"guidelines for not having memory type aliasing for the same physical memory "
"with multiple virtual addresses."
msgstr ""

#: ../../../arch/x86/pat.rst:16
msgid ""
"PAT allows for different types of memory attributes. The most commonly used "
"ones that will be supported at this time are:"
msgstr ""

#: ../../../arch/x86/pat.rst:20 ../../../arch/x86/pat.rst:43
#: ../../../arch/x86/pat.rst:82
msgid "WB"
msgstr ""

#: ../../../arch/x86/pat.rst:20
msgid "Write-back"
msgstr ""

#: ../../../arch/x86/pat.rst:21 ../../../arch/x86/pat.rst:45
msgid "UC"
msgstr ""

#: ../../../arch/x86/pat.rst:21
msgid "Uncached"
msgstr ""

#: ../../../arch/x86/pat.rst:22 ../../../arch/x86/pat.rst:47
#: ../../../arch/x86/pat.rst:54 ../../../arch/x86/pat.rst:62
#: ../../../arch/x86/pat.rst:68
msgid "WC"
msgstr ""

#: ../../../arch/x86/pat.rst:22
msgid "Write-combined"
msgstr ""

#: ../../../arch/x86/pat.rst:23 ../../../arch/x86/pat.rst:49
#: ../../../arch/x86/pat.rst:57
msgid "WT"
msgstr ""

#: ../../../arch/x86/pat.rst:23
msgid "Write-through"
msgstr ""

#: ../../../arch/x86/pat.rst:24 ../../../arch/x86/pat.rst:41
#: ../../../arch/x86/pat.rst:51 ../../../arch/x86/pat.rst:60
#: ../../../arch/x86/pat.rst:65 ../../../arch/x86/pat.rst:74
#: ../../../arch/x86/pat.rst:88
msgid "UC-"
msgstr ""

#: ../../../arch/x86/pat.rst:24
msgid "Uncached Minus"
msgstr ""

#: ../../../arch/x86/pat.rst:29
msgid "PAT APIs"
msgstr ""

#: ../../../arch/x86/pat.rst:31
msgid ""
"There are many different APIs in the kernel that allows setting of memory "
"attributes at the page level. In order to avoid aliasing, these interfaces "
"should be used thoughtfully. Below is a table of interfaces available, their "
"intended usage and their memory attribute relationships. Internally, these "
"APIs use a reserve_memtype()/free_memtype() interface on the physical "
"address range to avoid any aliasing."
msgstr ""

#: ../../../arch/x86/pat.rst:39
msgid "API"
msgstr ""

#: ../../../arch/x86/pat.rst:39
msgid "RAM"
msgstr ""

#: ../../../arch/x86/pat.rst:39
msgid "ACPI,..."
msgstr ""

#: ../../../arch/x86/pat.rst:39
msgid "Reserved/Holes"
msgstr ""

#: ../../../arch/x86/pat.rst:41
msgid "ioremap"
msgstr ""

#: ../../../arch/x86/pat.rst:41 ../../../arch/x86/pat.rst:43
#: ../../../arch/x86/pat.rst:45 ../../../arch/x86/pat.rst:47
#: ../../../arch/x86/pat.rst:49 ../../../arch/x86/pat.rst:51
#: ../../../arch/x86/pat.rst:54 ../../../arch/x86/pat.rst:57
#: ../../../arch/x86/pat.rst:60 ../../../arch/x86/pat.rst:62
#: ../../../arch/x86/pat.rst:65 ../../../arch/x86/pat.rst:68
#: ../../../arch/x86/pat.rst:71 ../../../arch/x86/pat.rst:74
#: ../../../arch/x86/pat.rst:77 ../../../arch/x86/pat.rst:82
#: ../../../arch/x86/pat.rst:88
msgid "--"
msgstr ""

#: ../../../arch/x86/pat.rst:43
msgid "ioremap_cache"
msgstr ""

#: ../../../arch/x86/pat.rst:45
msgid "ioremap_uc"
msgstr ""

#: ../../../arch/x86/pat.rst:47
msgid "ioremap_wc"
msgstr ""

#: ../../../arch/x86/pat.rst:49
msgid "ioremap_wt"
msgstr ""

#: ../../../arch/x86/pat.rst:51
msgid "set_memory_uc, set_memory_wb"
msgstr ""

#: ../../../arch/x86/pat.rst:54
msgid "set_memory_wc, set_memory_wb"
msgstr ""

#: ../../../arch/x86/pat.rst:57
msgid "set_memory_wt, set_memory_wb"
msgstr ""

#: ../../../arch/x86/pat.rst:60
msgid "pci sysfs resource"
msgstr ""

#: ../../../arch/x86/pat.rst:62
msgid "pci sysfs resource_wc is IORESOURCE_PREFETCH"
msgstr ""

#: ../../../arch/x86/pat.rst:65
msgid "pci proc !PCIIOC_WRITE_COMBINE"
msgstr ""

#: ../../../arch/x86/pat.rst:68
msgid "pci proc PCIIOC_WRITE_COMBINE"
msgstr ""

#: ../../../arch/x86/pat.rst:71
msgid "/dev/mem read-write"
msgstr ""

#: ../../../arch/x86/pat.rst:71 ../../../arch/x86/pat.rst:77
msgid "WB/WC/UC-"
msgstr ""

#: ../../../arch/x86/pat.rst:74
msgid "/dev/mem mmap SYNC flag"
msgstr ""

#: ../../../arch/x86/pat.rst:77
msgid "/dev/mem mmap !SYNC flag and any alias to this area"
msgstr ""

#: ../../../arch/x86/pat.rst:79
msgid "(from existing alias)"
msgstr ""

#: ../../../arch/x86/pat.rst:82
msgid "/dev/mem mmap !SYNC flag no alias to this area and MTRR says WB"
msgstr ""

#: ../../../arch/x86/pat.rst:88
msgid "/dev/mem mmap !SYNC flag no alias to this area and MTRR says !WB"
msgstr ""

#: ../../../arch/x86/pat.rst:97
msgid "Advanced APIs for drivers"
msgstr ""

#: ../../../arch/x86/pat.rst:99
msgid ""
"A. Exporting pages to users with remap_pfn_range, io_remap_pfn_range, "
"vmf_insert_pfn."
msgstr ""

#: ../../../arch/x86/pat.rst:102
msgid ""
"Drivers wanting to export some pages to userspace do it by using mmap "
"interface and a combination of:"
msgstr ""

#: ../../../arch/x86/pat.rst:105
msgid "pgprot_noncached()"
msgstr ""

#: ../../../arch/x86/pat.rst:106
msgid "io_remap_pfn_range() or remap_pfn_range() or vmf_insert_pfn()"
msgstr ""

#: ../../../arch/x86/pat.rst:108
msgid ""
"With PAT support, a new API pgprot_writecombine is being added. So, drivers "
"can continue to use the above sequence, with either pgprot_noncached() or "
"pgprot_writecombine() in step 1, followed by step 2."
msgstr ""

#: ../../../arch/x86/pat.rst:112
msgid ""
"In addition, step 2 internally tracks the region as UC or WC in memtype list "
"in order to ensure no conflicting mapping."
msgstr ""

#: ../../../arch/x86/pat.rst:115
msgid ""
"Note that this set of APIs only works with IO (non RAM) regions. If driver "
"wants to export a RAM region, it has to do set_memory_uc() or "
"set_memory_wc() as step 0 above and also track the usage of those pages and "
"use set_memory_wb() before the page is freed to free pool."
msgstr ""

#: ../../../arch/x86/pat.rst:121
msgid "MTRR effects on PAT / non-PAT systems"
msgstr ""

#: ../../../arch/x86/pat.rst:123
msgid ""
"The following table provides the effects of using write-combining MTRRs when "
"using ioremap*() calls on x86 for both non-PAT and PAT systems. Ideally "
"mtrr_add() usage will be phased out in favor of arch_phys_wc_add() which "
"will be a no-op on PAT enabled systems. The region over which a "
"arch_phys_wc_add() is made, should already have been ioremapped with WC "
"attributes or PAT entries, this can be done by using ioremap_wc() / "
"set_memory_wc().  Devices which combine areas of IO memory desired to remain "
"uncacheable with areas where write-combining is desirable should consider "
"use of ioremap_uc() followed by set_memory_wc() to white-list effective "
"write-combined areas.  Such use is nevertheless discouraged as the effective "
"memory type is considered implementation defined, yet this strategy can be "
"used as last resort on devices with size-constrained regions where otherwise "
"MTRR write-combining would otherwise not be effective. ::"
msgstr ""

#: ../../../arch/x86/pat.rst:153
msgid ""
"-- in the above table mean \"Not suggested usage for the API\". Some of the "
"--'s are strictly enforced by the kernel. Some others are not really "
"enforced today, but may be enforced in future."
msgstr ""

#: ../../../arch/x86/pat.rst:157
msgid ""
"For ioremap and pci access through /sys or /proc - The actual type returned "
"can be more restrictive, in case of any existing aliasing for that address. "
"For example: If there is an existing uncached mapping, a new ioremap_wc can "
"return uncached mapping in place of write-combine requested."
msgstr ""

#: ../../../arch/x86/pat.rst:162
msgid ""
"set_memory_[uc|wc|wt] and set_memory_wb should be used in pairs, where "
"driver will first make a region uc, wc or wt and switch it back to wb after "
"use."
msgstr ""

#: ../../../arch/x86/pat.rst:165
msgid ""
"Over time writes to /proc/mtrr will be deprecated in favor of using PAT "
"based interfaces. Users writing to /proc/mtrr are suggested to use above "
"interfaces."
msgstr ""

#: ../../../arch/x86/pat.rst:168
msgid ""
"Drivers should use ioremap_[uc|wc] to access PCI BARs with [uc|wc] access "
"types."
msgstr ""

#: ../../../arch/x86/pat.rst:171
msgid ""
"Drivers should use set_memory_[uc|wc|wt] to set access type for RAM ranges."
msgstr ""

#: ../../../arch/x86/pat.rst:175
msgid "PAT debugging"
msgstr ""

#: ../../../arch/x86/pat.rst:177
msgid "With CONFIG_DEBUG_FS enabled, PAT memtype list can be examined by::"
msgstr ""

#: ../../../arch/x86/pat.rst:198
msgid ""
"This list shows physical address ranges and various PAT settings used to "
"access those physical address ranges."
msgstr ""

#: ../../../arch/x86/pat.rst:201
msgid ""
"Another, more verbose way of getting PAT related debug messages is with "
"\"debugpat\" boot parameter. With this parameter, various debug messages are "
"printed to dmesg log."
msgstr ""

#: ../../../arch/x86/pat.rst:206
msgid "PAT Initialization"
msgstr ""

#: ../../../arch/x86/pat.rst:208
msgid ""
"The following table describes how PAT is initialized under various "
"configurations. The PAT MSR must be updated by Linux in order to support WC "
"and WT attributes. Otherwise, the PAT MSR has the value programmed in it by "
"the firmware. Note, Xen enables WC attribute in the PAT MSR for guests."
msgstr ""

#: ../../../arch/x86/pat.rst:214
msgid "MTRR"
msgstr ""

#: ../../../arch/x86/pat.rst:214
msgid "PAT"
msgstr ""

#: ../../../arch/x86/pat.rst:214
msgid "Call Sequence"
msgstr ""

#: ../../../arch/x86/pat.rst:214
msgid "PAT State"
msgstr ""

#: ../../../arch/x86/pat.rst:214
msgid "PAT MSR"
msgstr ""

#: ../../../arch/x86/pat.rst:216 ../../../arch/x86/pat.rst:217
#: ../../../arch/x86/pat.rst:218 ../../../arch/x86/pat.rst:222
#: ../../../arch/x86/pat.rst:230
msgid "E"
msgstr ""

#: ../../../arch/x86/pat.rst:216 ../../../arch/x86/pat.rst:217
#: ../../../arch/x86/pat.rst:222
msgid "MTRR -> PAT init"
msgstr ""

#: ../../../arch/x86/pat.rst:216 ../../../arch/x86/pat.rst:235
msgid "Enabled"
msgstr ""

#: ../../../arch/x86/pat.rst:216 ../../../arch/x86/pat.rst:237
msgid "OS"
msgstr ""

#: ../../../arch/x86/pat.rst:217 ../../../arch/x86/pat.rst:218
#: ../../../arch/x86/pat.rst:219 ../../../arch/x86/pat.rst:223
#: ../../../arch/x86/pat.rst:231
msgid "D"
msgstr ""

#: ../../../arch/x86/pat.rst:217 ../../../arch/x86/pat.rst:218
#: ../../../arch/x86/pat.rst:219 ../../../arch/x86/pat.rst:220
#: ../../../arch/x86/pat.rst:221 ../../../arch/x86/pat.rst:222
#: ../../../arch/x86/pat.rst:223 ../../../arch/x86/pat.rst:224
#: ../../../arch/x86/pat.rst:236
msgid "Disabled"
msgstr ""

#: ../../../arch/x86/pat.rst:218 ../../../arch/x86/pat.rst:219
#: ../../../arch/x86/pat.rst:223
msgid "MTRR -> PAT disable"
msgstr ""

#: ../../../arch/x86/pat.rst:218 ../../../arch/x86/pat.rst:220
#: ../../../arch/x86/pat.rst:222 ../../../arch/x86/pat.rst:223
#: ../../../arch/x86/pat.rst:224 ../../../arch/x86/pat.rst:238
msgid "BIOS"
msgstr ""

#: ../../../arch/x86/pat.rst:220
msgid "np/E"
msgstr ""

#: ../../../arch/x86/pat.rst:220 ../../../arch/x86/pat.rst:221
msgid "PAT  -> PAT disable"
msgstr ""

#: ../../../arch/x86/pat.rst:221
msgid "np/D"
msgstr ""

#: ../../../arch/x86/pat.rst:222 ../../../arch/x86/pat.rst:223
#: ../../../arch/x86/pat.rst:224
msgid "!P/E"
msgstr ""

#: ../../../arch/x86/pat.rst:224 ../../../arch/x86/pat.rst:234
msgid "!M"
msgstr ""

#: ../../../arch/x86/pat.rst:224
msgid "MTRR stub -> PAT disable"
msgstr ""

#: ../../../arch/x86/pat.rst:227
msgid "Legend"
msgstr ""

#: ../../../arch/x86/pat.rst:230
msgid "Feature enabled in CPU"
msgstr ""

#: ../../../arch/x86/pat.rst:231
msgid "Feature disabled/unsupported in CPU"
msgstr ""

#: ../../../arch/x86/pat.rst:232
msgid "np"
msgstr ""

#: ../../../arch/x86/pat.rst:232
msgid "\"nopat\" boot option specified"
msgstr ""

#: ../../../arch/x86/pat.rst:233
msgid "!P"
msgstr ""

#: ../../../arch/x86/pat.rst:233
msgid "CONFIG_X86_PAT option unset"
msgstr ""

#: ../../../arch/x86/pat.rst:234
msgid "CONFIG_MTRR option unset"
msgstr ""

#: ../../../arch/x86/pat.rst:235
msgid "PAT state set to enabled"
msgstr ""

#: ../../../arch/x86/pat.rst:236
msgid "PAT state set to disabled"
msgstr ""

#: ../../../arch/x86/pat.rst:237
msgid "PAT initializes PAT MSR with OS setting"
msgstr ""

#: ../../../arch/x86/pat.rst:238
msgid "PAT keeps PAT MSR with BIOS setting"
msgstr ""
