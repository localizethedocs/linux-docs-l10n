# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 09:03+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/sgx.rst:5
msgid "Software Guard eXtensions (SGX)"
msgstr ""

#: ../../../arch/x86/sgx.rst:8
msgid "Overview"
msgstr ""

#: ../../../arch/x86/sgx.rst:10
msgid ""
"Software Guard eXtensions (SGX) hardware enables for user space applications "
"to set aside private memory regions of code and data:"
msgstr ""

#: ../../../arch/x86/sgx.rst:13
msgid ""
"Privileged (ring-0) ENCLS functions orchestrate the construction of the "
"regions."
msgstr ""

#: ../../../arch/x86/sgx.rst:15
msgid ""
"Unprivileged (ring-3) ENCLU functions allow an application to enter and "
"execute inside the regions."
msgstr ""

#: ../../../arch/x86/sgx.rst:18
msgid ""
"These memory regions are called enclaves. An enclave can be only entered at "
"a fixed set of entry points. Each entry point can hold a single hardware "
"thread at a time.  While the enclave is loaded from a regular binary file by "
"using ENCLS functions, only the threads inside the enclave can access its "
"memory. The region is denied from outside access by the CPU, and encrypted "
"before it leaves from LLC."
msgstr ""

#: ../../../arch/x86/sgx.rst:25
msgid "The support can be determined by"
msgstr ""

#: ../../../arch/x86/sgx.rst:27
msgid "``grep sgx /proc/cpuinfo``"
msgstr ""

#: ../../../arch/x86/sgx.rst:29
msgid ""
"SGX must both be supported in the processor and enabled by the BIOS.  If SGX "
"appears to be unsupported on a system which has hardware support, ensure "
"support is enabled in the BIOS.  If a BIOS presents a choice between "
"\"Enabled\" and \"Software Enabled\" modes for SGX, choose \"Enabled\"."
msgstr ""

#: ../../../arch/x86/sgx.rst:35
msgid "Enclave Page Cache"
msgstr ""

#: ../../../arch/x86/sgx.rst:37
msgid ""
"SGX utilizes an *Enclave Page Cache (EPC)* to store pages that are "
"associated with an enclave. It is contained in a BIOS-reserved region of "
"physical memory. Unlike pages used for regular memory, pages can only be "
"accessed from outside of the enclave during enclave construction with "
"special, limited SGX instructions."
msgstr ""

#: ../../../arch/x86/sgx.rst:42
msgid ""
"Only a CPU executing inside an enclave can directly access enclave memory. "
"However, a CPU executing inside an enclave may access normal memory outside "
"the enclave."
msgstr ""

#: ../../../arch/x86/sgx.rst:46
msgid ""
"The kernel manages enclave memory similar to how it treats device memory."
msgstr ""

#: ../../../arch/x86/sgx.rst:49
msgid "Enclave Page Types"
msgstr ""

#: ../../../arch/x86/sgx.rst:51
msgid "**SGX Enclave Control Structure (SECS)**"
msgstr ""

#: ../../../arch/x86/sgx.rst:52
msgid ""
"Enclave's address range, attributes and other global data are defined by "
"this structure."
msgstr ""

#: ../../../arch/x86/sgx.rst:55
msgid "**Regular (REG)**"
msgstr ""

#: ../../../arch/x86/sgx.rst:56
msgid "Regular EPC pages contain the code and data of an enclave."
msgstr ""

#: ../../../arch/x86/sgx.rst:58
msgid "**Thread Control Structure (TCS)**"
msgstr ""

#: ../../../arch/x86/sgx.rst:59
msgid ""
"Thread Control Structure pages define the entry points to an enclave and "
"track the execution state of an enclave thread."
msgstr ""

#: ../../../arch/x86/sgx.rst:62
msgid "**Version Array (VA)**"
msgstr ""

#: ../../../arch/x86/sgx.rst:63
msgid ""
"Version Array pages contain 512 slots, each of which can contain a version "
"number for a page evicted from the EPC."
msgstr ""

#: ../../../arch/x86/sgx.rst:67
msgid "Enclave Page Cache Map"
msgstr ""

#: ../../../arch/x86/sgx.rst:69
msgid ""
"The processor tracks EPC pages in a hardware metadata structure called the "
"*Enclave Page Cache Map (EPCM)*.  The EPCM contains an entry for each EPC "
"page which describes the owning enclave, access rights and page type among "
"the other things."
msgstr ""

#: ../../../arch/x86/sgx.rst:74
msgid ""
"EPCM permissions are separate from the normal page tables.  This prevents "
"the kernel from, for instance, allowing writes to data which an enclave "
"wishes to remain read-only.  EPCM permissions may only impose additional "
"restrictions on top of normal x86 page permissions."
msgstr ""

#: ../../../arch/x86/sgx.rst:79
msgid ""
"For all intents and purposes, the SGX architecture allows the processor to "
"invalidate all EPCM entries at will.  This requires that software be "
"prepared to handle an EPCM fault at any time.  In practice, this can happen "
"on events like power transitions when the ephemeral key that encrypts "
"enclave memory is lost."
msgstr ""

#: ../../../arch/x86/sgx.rst:85
msgid "Application interface"
msgstr ""

#: ../../../arch/x86/sgx.rst:88
msgid "Enclave build functions"
msgstr ""

#: ../../../arch/x86/sgx.rst:90
msgid ""
"In addition to the traditional compiler and linker build process, SGX has a "
"separate enclave “build” process.  Enclaves must be built before they can be "
"executed (entered). The first step in building an enclave is opening the **/"
"dev/sgx_enclave** device.  Since enclave memory is protected from direct "
"access, special privileged instructions are then used to copy data into "
"enclave pages and establish enclave page permissions."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:144
msgid "handler for ``SGX_IOC_ENCLAVE_CREATE``"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:808
#: arch/x86/kernel/cpu/sgx/ioctl.c:1014 arch/x86/kernel/cpu/sgx/ioctl.c:1158
#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:199
#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:148
#: arch/x86/kernel/cpu/sgx/ioctl.c:381 arch/x86/kernel/cpu/sgx/ioctl.c:563
#: arch/x86/kernel/cpu/sgx/ioctl.c:630
msgid "**Parameters**"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:810
#: arch/x86/kernel/cpu/sgx/ioctl.c:1016 arch/x86/kernel/cpu/sgx/ioctl.c:1160
#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:150
#: arch/x86/kernel/cpu/sgx/ioctl.c:383 arch/x86/kernel/cpu/sgx/ioctl.c:565
#: arch/x86/kernel/cpu/sgx/ioctl.c:632
msgid "``struct sgx_encl *encl``"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:145
msgid "An enclave pointer."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:808
#: arch/x86/kernel/cpu/sgx/ioctl.c:1013 arch/x86/kernel/cpu/sgx/ioctl.c:1157
#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:147
#: arch/x86/kernel/cpu/sgx/ioctl.c:380 arch/x86/kernel/cpu/sgx/ioctl.c:562
#: arch/x86/kernel/cpu/sgx/ioctl.c:629
msgid "``void __user *arg``"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:146
msgid "The ioctl argument."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:810
#: arch/x86/kernel/cpu/sgx/ioctl.c:1014 arch/x86/kernel/cpu/sgx/ioctl.c:1158
#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:148
#: arch/x86/kernel/cpu/sgx/ioctl.c:381 arch/x86/kernel/cpu/sgx/ioctl.c:563
#: arch/x86/kernel/cpu/sgx/ioctl.c:630
msgid "**Description**"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:147
msgid "Allocate kernel data structures for the enclave and invoke ECREATE."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:818
#: arch/x86/kernel/cpu/sgx/ioctl.c:1027 arch/x86/kernel/cpu/sgx/ioctl.c:1174
#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:223
#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:149
#: arch/x86/kernel/cpu/sgx/ioctl.c:405 arch/x86/kernel/cpu/sgx/ioctl.c:566
#: arch/x86/kernel/cpu/sgx/ioctl.c:632
msgid "**Return**"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:150
#: arch/x86/kernel/cpu/sgx/ioctl.c:406 arch/x86/kernel/cpu/sgx/ioctl.c:567
#: arch/x86/kernel/cpu/sgx/ioctl.c:633
msgid "0:         Success."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:151
msgid "-EIO:      ECREATE failed."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:152
#: arch/x86/kernel/cpu/sgx/ioctl.c:412 arch/x86/kernel/cpu/sgx/ioctl.c:570
msgid "-errno:    POSIX error."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:377
msgid "The handler for ``SGX_IOC_ENCLAVE_ADD_PAGES``"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:806
#: arch/x86/kernel/cpu/sgx/ioctl.c:1011 arch/x86/kernel/cpu/sgx/ioctl.c:1155
#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:378
#: arch/x86/kernel/cpu/sgx/ioctl.c:560 arch/x86/kernel/cpu/sgx/ioctl.c:627
msgid "an enclave pointer"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:379
msgid "a user pointer to a struct sgx_enclave_add_pages instance"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:380
msgid ""
"Add one or more pages to an uninitialized enclave, and optionally extend the "
"measurement with the contents of the page. The SECINFO and measurement mask "
"are applied to all pages."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:384
msgid ""
"A SECINFO for a TCS is required to always contain zero permissions because "
"CPU silently zeros them. Allowing anything else would cause a mismatch in "
"the measurement."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:388
msgid ""
"mmap()'s protection bits are capped by the page permissions. For each page "
"address, the maximum protection bits are computed with the following "
"heuristics:"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:392
msgid ""
"A regular page: PROT_R, PROT_W and PROT_X match the SECINFO permissions."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:393
msgid "A TCS page: PROT_R | PROT_W."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:395
msgid ""
"mmap() is not allowed to surpass the minimum of the maximum protection bits "
"within the given address range."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:398
msgid ""
"The function deinitializes kernel data structures for enclave and returns -"
"EIO in any of the following conditions:"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:401
msgid ""
"Enclave Page Cache (EPC), the physical memory holding enclaves, has been "
"invalidated. This will cause EADD and EEXTEND to fail."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:403
msgid "If the source address is corrupted somehow when executing EADD."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:407
msgid "-EACCES:   The source page is located in a noexec partition."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:408
msgid "-ENOMEM:   Out of EPC pages."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:409
msgid "-EINTR:    The call was interrupted before data was processed."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:410
msgid "-EIO:      Either EADD or EEXTEND failed because invalid source address"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:411
msgid "or power cycle."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:559
msgid "handler for ``SGX_IOC_ENCLAVE_INIT``"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:561
msgid "userspace pointer to a struct sgx_enclave_init instance"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:562
msgid ""
"Flush any outstanding enqueued EADD operations and perform EINIT.  The "
"Launch Enclave Public Key Hash MSRs are rewritten as necessary to match the "
"enclave's MRSIGNER, which is calculated from the provided sigstruct."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:568
msgid "-EPERM:    Invalid SIGSTRUCT."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:569
msgid "-EIO:      EINIT failed because of a power cycle."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:626
msgid "handler for ``SGX_IOC_ENCLAVE_PROVISION``"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:628
msgid "userspace pointer to a struct sgx_enclave_provision instance"
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:629
msgid ""
"Allow ATTRIBUTE.PROVISION_KEY for an enclave by providing a file handle to /"
"dev/sgx_provision."
msgstr ""

#: ../../../arch/x86/sgx:97: arch/x86/kernel/cpu/sgx/ioctl.c:634
msgid "-errno:    Otherwise."
msgstr ""

#: ../../../arch/x86/sgx.rst:104
msgid "Enclave runtime management"
msgstr ""

#: ../../../arch/x86/sgx.rst:106
msgid ""
"Systems supporting SGX2 additionally support changes to initialized "
"enclaves: modifying enclave page permissions and type, and dynamically "
"adding and removing of enclave pages. When an enclave accesses an address "
"within its address range that does not have a backing page then a new "
"regular page will be dynamically added to the enclave. The enclave is still "
"required to run EACCEPT on the new page before it can be used."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:804
msgid "handler for ``SGX_IOC_ENCLAVE_RESTRICT_PERMISSIONS``"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:807
msgid ""
"userspace pointer to a :c:type:`struct sgx_enclave_restrict_permissions "
"<sgx_enclave_restrict_permissions>` instance"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:809
msgid ""
"SGX2 distinguishes between relaxing and restricting the enclave page "
"permissions maintained by the hardware (EPCM permissions) of pages belonging "
"to an initialized enclave (after SGX_IOC_ENCLAVE_INIT)."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:813
msgid ""
"EPCM permissions cannot be restricted from within the enclave, the enclave "
"requires the kernel to run the privileged level 0 instructions ENCLS[EMODPR] "
"and ENCLS[ETRACK]. An attempt to relax EPCM permissions with this call will "
"be ignored by the hardware."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:819
#: arch/x86/kernel/cpu/sgx/ioctl.c:1028 arch/x86/kernel/cpu/sgx/ioctl.c:1175
msgid "0:         Success"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:820
#: arch/x86/kernel/cpu/sgx/ioctl.c:1029 arch/x86/kernel/cpu/sgx/ioctl.c:1176
msgid "-errno:    Otherwise"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1010
msgid "handler for ``SGX_IOC_ENCLAVE_MODIFY_TYPES``"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1012
msgid ""
"userspace pointer to a :c:type:`struct sgx_enclave_modify_types "
"<sgx_enclave_modify_types>` instance"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1013
msgid ""
"Ability to change the enclave page type supports the following use cases:"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1015
msgid ""
"It is possible to add TCS pages to an enclave by changing the type of "
"regular pages (``SGX_PAGE_TYPE_REG``) to TCS (``SGX_PAGE_TYPE_TCS``) pages. "
"With this support the number of threads supported by an initialized enclave "
"can be increased dynamically."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1020
msgid ""
"Regular or TCS pages can dynamically be removed from an initialized enclave "
"by changing the page type to ``SGX_PAGE_TYPE_TRIM``. Changing the page type "
"to ``SGX_PAGE_TYPE_TRIM`` marks the page for removal with actual removal "
"done by handler of ``SGX_IOC_ENCLAVE_REMOVE_PAGES`` ioctl() called after "
"ENCLU[EACCEPT] is run on ``SGX_PAGE_TYPE_TRIM`` page from within the enclave."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1154
msgid "handler for ``SGX_IOC_ENCLAVE_REMOVE_PAGES``"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1156
msgid ""
"userspace pointer to :c:type:`struct sgx_enclave_remove_pages "
"<sgx_enclave_remove_pages>` instance"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1157
msgid ""
"Final step of the flow removing pages from an initialized enclave. The "
"complete flow is:"
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1160
msgid ""
"User changes the type of the pages to be removed to ``SGX_PAGE_TYPE_TRIM`` "
"using the ``SGX_IOC_ENCLAVE_MODIFY_TYPES`` ioctl()."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1162
msgid ""
"User approves the page removal by running ENCLU[EACCEPT] from within the "
"enclave."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1164
msgid ""
"User initiates actual page removal using the "
"``SGX_IOC_ENCLAVE_REMOVE_PAGES`` ioctl() that is handled here."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1167
msgid ""
"First remove any page table entries pointing to the page and then proceed "
"with the actual removal of the enclave page and data in support of it."
msgstr ""

#: ../../../arch/x86/sgx:113: arch/x86/kernel/cpu/sgx/ioctl.c:1170
msgid ""
"VA pages are not affected by this removal. It is thus possible that the "
"enclave may end up with more VA pages than needed to support all its pages."
msgstr ""

#: ../../../arch/x86/sgx.rst:119
msgid "Enclave vDSO"
msgstr ""

#: ../../../arch/x86/sgx.rst:121
msgid ""
"Entering an enclave can only be done through SGX-specific EENTER and ERESUME "
"functions, and is a non-trivial process.  Because of the complexity of "
"transitioning to and from an enclave, enclaves typically utilize a library "
"to handle the actual transitions.  This is roughly analogous to how glibc "
"implementations are used by most applications to wrap system calls."
msgstr ""

#: ../../../arch/x86/sgx.rst:127
msgid ""
"Another crucial characteristic of enclaves is that they can generate "
"exceptions as part of their normal operation that need to be handled in the "
"enclave or are unique to SGX."
msgstr ""

#: ../../../arch/x86/sgx.rst:131
msgid ""
"Instead of the traditional signal mechanism to handle these exceptions, SGX "
"can leverage special exception fixup provided by the vDSO.  The kernel-"
"provided vDSO function wraps low-level transitions to/from the enclave like "
"EENTER and ERESUME.  The vDSO function intercepts exceptions that would "
"otherwise generate a signal and return the fault information directly to its "
"caller.  This avoids the need to juggle signal handlers."
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:190
msgid ""
"**Typedef**: Prototype for __vdso_sgx_enter_enclave(), a vDSO function to "
"enter an SGX enclave."
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:193
msgid "**Syntax**"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:195
msgid ""
"``int vdso_sgx_enter_enclave_t (unsigned long rdi, unsigned long rsi, "
"unsigned long rdx, unsigned int function, unsigned long r8, unsigned long "
"r9, struct sgx_enclave_run *run)``"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:201
msgid "``unsigned long rdi``"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:190
msgid "Pass-through value for RDI"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:192
msgid "``unsigned long rsi``"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:191
msgid "Pass-through value for RSI"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:193
msgid "``unsigned long rdx``"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:192
msgid "Pass-through value for RDX"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:194
msgid "``unsigned int function``"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:193
msgid "ENCLU function, must be EENTER or ERESUME"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:195
msgid "``unsigned long r8``"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:194
msgid "Pass-through value for R8"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:196
msgid "``unsigned long r9``"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:195
msgid "Pass-through value for R9"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:197
msgid "``struct sgx_enclave_run *run``"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:196
msgid "struct sgx_enclave_run, must be non-NULL"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:198
msgid "**NOTE**"
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:198
msgid ""
"__vdso_sgx_enter_enclave() does not ensure full compliance with the x86-64 "
"ABI, e.g. doesn't handle XSAVE state.  Except for non-volatile general "
"purpose registers, EFLAGS.DF, and RSP alignment, preserving/setting state in "
"accordance with the x86-64 ABI is the responsibility of the enclave and its "
"runtime, i.e. __vdso_sgx_enter_enclave() cannot be called from C code "
"without careful consideration by both the enclave and its runtime."
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:205
msgid ""
"All general purpose registers except RAX, RBX and RCX are passed as-is to "
"the enclave.  RAX, RBX and RCX are consumed by EENTER and ERESUME and are "
"loaded with **function**, asynchronous exit pointer, and **run.tcs** "
"respectively."
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:209
msgid ""
"RBP and the stack are used to anchor __vdso_sgx_enter_enclave() to the pre-"
"enclave state, e.g. to retrieve **run.exception** and **run.user_handler** "
"after an enclave exit.  All other registers are available for use by the "
"enclave and its runtime, e.g. an enclave can push additional data onto the "
"stack (and modify RSP) to pass information to the optional user handler (see "
"below)."
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:216
msgid ""
"Most exceptions reported on ENCLU, including those that occur within the "
"enclave, are fixed up and reported synchronously instead of being delivered "
"via a standard signal. Debug Exceptions (#DB) and Breakpoints (#BP) are "
"never fixed up and are always delivered via standard signals. On "
"synchronously reported exceptions, -EFAULT is returned and details about the "
"exception are recorded in **run.exception**, the optional "
"sgx_enclave_exception struct."
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:223
msgid "0:         ENCLU function was successfully executed."
msgstr ""

#: ../../../arch/x86/sgx:138: arch/x86/include/uapi/asm/sgx.h:224
msgid "-EINVAL:   Invalid ENCL number (neither EENTER nor ERESUME)."
msgstr ""

#: ../../../arch/x86/sgx.rst:142
msgid "ksgxd"
msgstr ""

#: ../../../arch/x86/sgx.rst:144
msgid "SGX support includes a kernel thread called *ksgxd*."
msgstr ""

#: ../../../arch/x86/sgx.rst:147
msgid "EPC sanitization"
msgstr ""

#: ../../../arch/x86/sgx.rst:149
msgid ""
"ksgxd is started when SGX initializes.  Enclave memory is typically ready "
"for use when the processor powers on or resets.  However, if SGX has been in "
"use since the reset, enclave pages may be in an inconsistent state.  This "
"might occur after a crash and kexec() cycle, for instance.  At boot, ksgxd "
"reinitializes all enclave pages so that they can be allocated and re-used."
msgstr ""

#: ../../../arch/x86/sgx.rst:155
msgid ""
"The sanitization is done by going through EPC address space and applying the "
"EREMOVE function to each physical page. Some enclave pages like SECS pages "
"have hardware dependencies on other pages which prevents EREMOVE from "
"functioning. Executing two EREMOVE passes removes the dependencies."
msgstr ""

#: ../../../arch/x86/sgx.rst:161
msgid "Page reclaimer"
msgstr ""

#: ../../../arch/x86/sgx.rst:163
msgid ""
"Similar to the core kswapd, ksgxd, is responsible for managing the "
"overcommitment of enclave memory.  If the system runs out of enclave memory, "
"*ksgxd* “swaps” enclave memory to normal memory."
msgstr ""

#: ../../../arch/x86/sgx.rst:168
msgid "Launch Control"
msgstr ""

#: ../../../arch/x86/sgx.rst:170
msgid ""
"SGX provides a launch control mechanism. After all enclave pages have been "
"copied, kernel executes EINIT function, which initializes the enclave. Only "
"after this the CPU can execute inside the enclave."
msgstr ""

#: ../../../arch/x86/sgx.rst:174
msgid ""
"EINIT function takes an RSA-3072 signature of the enclave measurement.  The "
"function checks that the measurement is correct and signature is signed with "
"the key hashed to the four **IA32_SGXLEPUBKEYHASH{0, 1, 2, 3}** MSRs "
"representing the SHA256 of a public key."
msgstr ""

#: ../../../arch/x86/sgx.rst:179
msgid ""
"Those MSRs can be configured by the BIOS to be either readable or writable. "
"Linux supports only writable configuration in order to give full control to "
"the kernel on launch control policy. Before calling EINIT function, the "
"driver sets the MSRs to match the enclave's signing key."
msgstr ""

#: ../../../arch/x86/sgx.rst:185
msgid "Encryption engines"
msgstr ""

#: ../../../arch/x86/sgx.rst:187
msgid ""
"In order to conceal the enclave data while it is out of the CPU package, the "
"memory controller has an encryption engine to transparently encrypt and "
"decrypt enclave memory."
msgstr ""

#: ../../../arch/x86/sgx.rst:191
msgid ""
"In CPUs prior to Ice Lake, the Memory Encryption Engine (MEE) is used to "
"encrypt pages leaving the CPU caches. MEE uses a n-ary Merkle tree with root "
"in SRAM to maintain integrity of the encrypted data. This provides integrity "
"and anti-replay protection but does not scale to large memory sizes because "
"the time required to update the Merkle tree grows logarithmically in "
"relation to the memory size."
msgstr ""

#: ../../../arch/x86/sgx.rst:198
msgid ""
"CPUs starting from Icelake use Total Memory Encryption (TME) in the place of "
"MEE. TME-based SGX implementations do not have an integrity Merkle tree, "
"which means integrity and replay-attacks are not mitigated.  B, it includes "
"additional changes to prevent cipher text from being returned and SW memory "
"aliases from being created."
msgstr ""

#: ../../../arch/x86/sgx.rst:204
msgid ""
"DMA to enclave memory is blocked by range registers on both MEE and TME "
"systems (SDM section 41.10)."
msgstr ""

#: ../../../arch/x86/sgx.rst:208
msgid "Usage Models"
msgstr ""

#: ../../../arch/x86/sgx.rst:211
msgid "Shared Library"
msgstr ""

#: ../../../arch/x86/sgx.rst:213
msgid ""
"Sensitive data and the code that acts on it is partitioned from the "
"application into a separate library. The library is then linked as a DSO "
"which can be loaded into an enclave. The application can then make "
"individual function calls into the enclave through special SGX instructions. "
"A run-time within the enclave is configured to marshal function parameters "
"into and out of the enclave and to call the correct library function."
msgstr ""

#: ../../../arch/x86/sgx.rst:221
msgid "Application Container"
msgstr ""

#: ../../../arch/x86/sgx.rst:223
msgid ""
"An application may be loaded into a container enclave which is specially "
"configured with a library OS and run-time which permits the application to "
"run. The enclave run-time and library OS work together to execute the "
"application when a thread enters the enclave."
msgstr ""

#: ../../../arch/x86/sgx.rst:229
msgid "Impact of Potential Kernel SGX Bugs"
msgstr ""

#: ../../../arch/x86/sgx.rst:232
msgid "EPC leaks"
msgstr ""

#: ../../../arch/x86/sgx.rst:234
msgid "When EPC page leaks happen, a WARNING like this is shown in dmesg:"
msgstr ""

#: ../../../arch/x86/sgx.rst:236
msgid ""
"\"EREMOVE returned ... and an EPC page was leaked.  SGX may become "
"unusable...\""
msgstr ""

#: ../../../arch/x86/sgx.rst:238
msgid ""
"This is effectively a kernel use-after-free of an EPC page, and due to the "
"way SGX works, the bug is detected at freeing. Rather than adding the page "
"back to the pool of available EPC pages, the kernel intentionally leaks the "
"page to avoid additional errors in the future."
msgstr ""

#: ../../../arch/x86/sgx.rst:243
msgid ""
"When this happens, the kernel will likely soon leak more EPC pages, and SGX "
"will likely become unusable because the memory available to SGX is limited. "
"However, while this may be fatal to SGX, the rest of the kernel is unlikely "
"to be impacted and should continue to work."
msgstr ""

#: ../../../arch/x86/sgx.rst:248
msgid ""
"As a result, when this happens, user should stop running any new SGX "
"workloads, (or just any new workloads), and migrate all valuable workloads. "
"Although a machine reboot can recover all EPC memory, the bug should be "
"reported to Linux developers."
msgstr ""

#: ../../../arch/x86/sgx.rst:255
msgid "Virtual EPC"
msgstr ""

#: ../../../arch/x86/sgx.rst:257
msgid ""
"The implementation has also a virtual EPC driver to support SGX enclaves in "
"guests. Unlike the SGX driver, an EPC page allocated by the virtual EPC "
"driver doesn't have a specific enclave associated with it. This is because "
"KVM doesn't track how a guest uses EPC pages."
msgstr ""

#: ../../../arch/x86/sgx.rst:262
msgid ""
"As a result, the SGX core page reclaimer doesn't support reclaiming EPC "
"pages allocated to KVM guests through the virtual EPC driver. If the user "
"wants to deploy SGX applications both on the host and in guests on the same "
"machine, the user should reserve enough EPC (by taking out total virtual EPC "
"size of all SGX VMs from the physical EPC size) for host SGX applications so "
"they can run with acceptable performance."
msgstr ""

#: ../../../arch/x86/sgx.rst:269
msgid ""
"Architectural behavior is to restore all EPC pages to an uninitialized state "
"also after a guest reboot.  Because this state can be reached only through "
"the privileged ``ENCLS[EREMOVE]`` instruction, ``/dev/sgx_vepc`` provides "
"the ``SGX_IOC_VEPC_REMOVE_ALL`` ioctl to execute the instruction on all "
"pages in the virtual EPC."
msgstr ""

#: ../../../arch/x86/sgx.rst:275
msgid ""
"``EREMOVE`` can fail for three reasons.  Userspace must pay attention to "
"expected failures and handle them as follows:"
msgstr ""

#: ../../../arch/x86/sgx.rst:278
msgid ""
"Page removal will always fail when any thread is running in the enclave to "
"which the page belongs.  In this case the ioctl will return ``EBUSY`` "
"independent of whether it has successfully removed some pages; userspace can "
"avoid these failures by preventing execution of any vcpu which maps the "
"virtual EPC."
msgstr ""

#: ../../../arch/x86/sgx.rst:284
msgid ""
"Page removal will cause a general protection fault if two calls to "
"``EREMOVE`` happen concurrently for pages that refer to the same \"SECS\" "
"metadata pages.  This can happen if there are concurrent invocations to "
"``SGX_IOC_VEPC_REMOVE_ALL``, or if a ``/dev/sgx_vepc`` file descriptor in "
"the guest is closed at the same time as ``SGX_IOC_VEPC_REMOVE_ALL``; it will "
"also be reported as ``EBUSY``. This can be avoided in userspace by "
"serializing calls to the ioctl() and to close(), but in general it should "
"not be a problem."
msgstr ""

#: ../../../arch/x86/sgx.rst:293
msgid ""
"Finally, page removal will fail for SECS metadata pages which still have "
"child pages.  Child pages can be removed by executing "
"``SGX_IOC_VEPC_REMOVE_ALL`` on all ``/dev/sgx_vepc`` file descriptors mapped "
"into the guest.  This means that the ioctl() must be called twice: an "
"initial set of calls to remove child pages and a subsequent set of calls to "
"remove SECS pages.  The second set of calls is only required for those "
"mappings that returned a nonzero value from the first call.  It indicates a "
"bug in the kernel or the userspace client if any of the second round of "
"``SGX_IOC_VEPC_REMOVE_ALL`` calls has a return code other than 0."
msgstr ""
