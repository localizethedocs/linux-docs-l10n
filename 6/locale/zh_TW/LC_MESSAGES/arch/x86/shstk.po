# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/shstk.rst:5
msgid "Control-flow Enforcement Technology (CET) Shadow Stack"
msgstr ""

#: ../../../arch/x86/shstk.rst:8
msgid "CET Background"
msgstr ""

#: ../../../arch/x86/shstk.rst:10
msgid ""
"Control-flow Enforcement Technology (CET) covers several related x86 "
"processor features that provide protection against control flow hijacking "
"attacks. CET can protect both applications and the kernel."
msgstr ""

#: ../../../arch/x86/shstk.rst:14
msgid ""
"CET introduces shadow stack and indirect branch tracking (IBT). A shadow "
"stack is a secondary stack allocated from memory which cannot be directly "
"modified by applications. When executing a CALL instruction, the processor "
"pushes the return address to both the normal stack and the shadow stack. "
"Upon function return, the processor pops the shadow stack copy and compares "
"it to the normal stack copy. If the two differ, the processor raises a "
"control-protection fault. IBT verifies indirect CALL/JMP targets are "
"intended as marked by the compiler with 'ENDBR' opcodes. Not all CPU's have "
"both Shadow Stack and Indirect Branch Tracking. Today in the 64-bit kernel, "
"only userspace shadow stack and kernel IBT are supported."
msgstr ""

#: ../../../arch/x86/shstk.rst:26
msgid "Requirements to use Shadow Stack"
msgstr ""

#: ../../../arch/x86/shstk.rst:28
msgid ""
"To use userspace shadow stack you need HW that supports it, a kernel "
"configured with it and userspace libraries compiled with it."
msgstr ""

#: ../../../arch/x86/shstk.rst:31
msgid ""
"The kernel Kconfig option is X86_USER_SHADOW_STACK.  When compiled in, "
"shadow stacks can be disabled at runtime with the kernel parameter: "
"nousershstk."
msgstr ""

#: ../../../arch/x86/shstk.rst:34
msgid ""
"To build a user shadow stack enabled kernel, Binutils v2.29 or LLVM v6 or "
"later are required."
msgstr ""

#: ../../../arch/x86/shstk.rst:37
msgid ""
"At run time, /proc/cpuinfo shows CET features if the processor supports CET. "
"\"user_shstk\" means that userspace shadow stack is supported on the current "
"kernel and HW."
msgstr ""

#: ../../../arch/x86/shstk.rst:42
msgid "Application Enabling"
msgstr ""

#: ../../../arch/x86/shstk.rst:44
msgid ""
"An application's CET capability is marked in its ELF note and can be "
"verified from readelf/llvm-readelf output::"
msgstr ""

#: ../../../arch/x86/shstk.rst:50
msgid ""
"The kernel does not process these applications markers directly. "
"Applications or loaders must enable CET features using the interface "
"described in section 4. Typically this would be done in dynamic loader or "
"static runtime objects, as is the case in GLIBC."
msgstr ""

#: ../../../arch/x86/shstk.rst:56
msgid "Enabling arch_prctl()'s"
msgstr ""

#: ../../../arch/x86/shstk.rst:58
msgid ""
"Elf features should be enabled by the loader using the below arch_prctl's. "
"They are only supported in 64 bit user applications. These operate on the "
"features on a per-thread basis. The enablement status is inherited on clone, "
"so if the feature is enabled on the first thread, it will propagate to all "
"the thread's in an app."
msgstr ""

#: ../../../arch/x86/shstk.rst:64
msgid "arch_prctl(ARCH_SHSTK_ENABLE, unsigned long feature)"
msgstr ""

#: ../../../arch/x86/shstk.rst:65
msgid ""
"Enable a single feature specified in 'feature'. Can only operate on one "
"feature at a time."
msgstr ""

#: ../../../arch/x86/shstk.rst:68
msgid "arch_prctl(ARCH_SHSTK_DISABLE, unsigned long feature)"
msgstr ""

#: ../../../arch/x86/shstk.rst:69
msgid ""
"Disable a single feature specified in 'feature'. Can only operate on one "
"feature at a time."
msgstr ""

#: ../../../arch/x86/shstk.rst:72
msgid "arch_prctl(ARCH_SHSTK_LOCK, unsigned long features)"
msgstr ""

#: ../../../arch/x86/shstk.rst:73
msgid ""
"Lock in features at their current enabled or disabled status. 'features' is "
"a mask of all features to lock. All bits set are processed, unset bits are "
"ignored. The mask is ORed with the existing value. So any feature bits set "
"here cannot be enabled or disabled afterwards."
msgstr ""

#: ../../../arch/x86/shstk.rst:78
msgid "arch_prctl(ARCH_SHSTK_UNLOCK, unsigned long features)"
msgstr ""

#: ../../../arch/x86/shstk.rst:79
msgid ""
"Unlock features. 'features' is a mask of all features to unlock. All bits "
"set are processed, unset bits are ignored. Only works via ptrace."
msgstr ""

#: ../../../arch/x86/shstk.rst:82
msgid "arch_prctl(ARCH_SHSTK_STATUS, unsigned long addr)"
msgstr ""

#: ../../../arch/x86/shstk.rst:83
msgid ""
"Copy the currently enabled features to the address passed in addr. The "
"features are described using the bits passed into the others in 'features'."
msgstr ""

#: ../../../arch/x86/shstk.rst:87
msgid ""
"The return values are as follows. On success, return 0. On error, errno can "
"be::"
msgstr ""

#: ../../../arch/x86/shstk.rst:96
msgid "The feature's bits supported are::"
msgstr ""

#: ../../../arch/x86/shstk.rst:101
msgid ""
"Currently shadow stack and WRSS are supported via this interface. WRSS can "
"only be enabled with shadow stack, and is automatically disabled if shadow "
"stack is disabled."
msgstr ""

#: ../../../arch/x86/shstk.rst:106
msgid "Proc Status"
msgstr ""

#: ../../../arch/x86/shstk.rst:107
msgid ""
"To check if an application is actually running with shadow stack, the user "
"can read the /proc/$PID/status. It will report \"wrss\" or \"shstk\" "
"depending on what is enabled. The lines look like this::"
msgstr ""

#: ../../../arch/x86/shstk.rst:115
msgid "Implementation of the Shadow Stack"
msgstr ""

#: ../../../arch/x86/shstk.rst:118
msgid "Shadow Stack Size"
msgstr ""

#: ../../../arch/x86/shstk.rst:120
msgid ""
"A task's shadow stack is allocated from memory to a fixed size of "
"MIN(RLIMIT_STACK, 4 GB). In other words, the shadow stack is allocated to "
"the maximum size of the normal stack, but capped to 4 GB. In the case of the "
"clone3 syscall, there is a stack size passed in and shadow stack uses this "
"instead of the rlimit."
msgstr ""

#: ../../../arch/x86/shstk.rst:127
msgid "Signal"
msgstr ""

#: ../../../arch/x86/shstk.rst:129
msgid ""
"The main program and its signal handlers use the same shadow stack. Because "
"the shadow stack stores only return addresses, a large shadow stack covers "
"the condition that both the program stack and the signal alternate stack run "
"out."
msgstr ""

#: ../../../arch/x86/shstk.rst:134
msgid ""
"When a signal happens, the old pre-signal state is pushed on the stack. When "
"shadow stack is enabled, the shadow stack specific state is pushed onto the "
"shadow stack. Today this is only the old SSP (shadow stack pointer), pushed "
"in a special format with bit 63 set. On sigreturn this old SSP token is "
"verified and restored by the kernel. The kernel will also push the normal "
"restorer address to the shadow stack to help userspace avoid a shadow stack "
"violation on the sigreturn path that goes through the restorer."
msgstr ""

#: ../../../arch/x86/shstk.rst:142
msgid "So the shadow stack signal frame format is as follows::"
msgstr ""

#: ../../../arch/x86/shstk.rst:149
msgid ""
"32 bit ABI signals are not supported in shadow stack processes. Linux "
"prevents 32 bit execution while shadow stack is enabled by the allocating "
"shadow stacks outside of the 32 bit address space. When execution enters 32 "
"bit mode, either via far call or returning to userspace, a #GP is generated "
"by the hardware which, will be delivered to the process as a segfault. When "
"transitioning to userspace the register's state will be as if the userspace "
"ip being returned to caused the segfault."
msgstr ""

#: ../../../arch/x86/shstk.rst:158
msgid "Fork"
msgstr ""

#: ../../../arch/x86/shstk.rst:160
msgid ""
"The shadow stack's vma has VM_SHADOW_STACK flag set; its PTEs are required "
"to be read-only and dirty. When a shadow stack PTE is not RO and dirty, a "
"shadow access triggers a page fault with the shadow stack access bit set in "
"the page fault error code."
msgstr ""

#: ../../../arch/x86/shstk.rst:165
msgid ""
"When a task forks a child, its shadow stack PTEs are copied and both the "
"parent's and the child's shadow stack PTEs are cleared of the dirty bit. "
"Upon the next shadow stack access, the resulting shadow stack page fault is "
"handled by page copy/re-use."
msgstr ""

#: ../../../arch/x86/shstk.rst:170
msgid ""
"When a pthread child is created, the kernel allocates a new shadow stack for "
"the new thread. New shadow stack creation behaves like mmap() with respect "
"to ASLR behavior. Similarly, on thread exit the thread's shadow stack is "
"disabled."
msgstr ""

#: ../../../arch/x86/shstk.rst:176
msgid "Exec"
msgstr ""

#: ../../../arch/x86/shstk.rst:178
msgid ""
"On exec, shadow stack features are disabled by the kernel. At which point, "
"userspace can choose to re-enable, or lock them."
msgstr ""
