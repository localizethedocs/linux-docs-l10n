# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/cgroup-v2.rst:5
msgid "Control Group v2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:0
msgid "Date"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:7
msgid "October, 2015"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:0
msgid "Author"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:8
msgid "Tejun Heo <tj@kernel.org>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:10
msgid ""
"This is the authoritative documentation on the design, interface and "
"conventions of cgroup v2.  It describes all userland-visible aspects of "
"cgroup including core and specific controller behaviors.  All future changes "
"must be reflected in this document.  Documentation for v1 is available "
"under :ref:`Documentation/admin-guide/cgroup-v1/index.rst <cgroup-v1>`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:101
msgid "Introduction"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:104
msgid "Terminology"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:106
msgid ""
"\"cgroup\" stands for \"control group\" and is never capitalized.  The "
"singular form is used to designate the whole feature and also as a qualifier "
"as in \"cgroup controllers\".  When explicitly referring to multiple "
"individual control groups, the plural form \"cgroups\" is used."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:113
msgid "What is cgroup?"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:115
msgid ""
"cgroup is a mechanism to organize processes hierarchically and distribute "
"system resources along the hierarchy in a controlled and configurable manner."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:119
msgid ""
"cgroup is largely composed of two parts - the core and controllers. cgroup "
"core is primarily responsible for hierarchically organizing processes.  A "
"cgroup controller is usually responsible for distributing a specific type of "
"system resource along the hierarchy although there are utility controllers "
"which serve purposes other than resource distribution."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:126
msgid ""
"cgroups form a tree structure and every process in the system belongs to one "
"and only one cgroup.  All threads of a process belong to the same cgroup.  "
"On creation, all processes are put in the cgroup that the parent process "
"belongs to at the time.  A process can be migrated to another cgroup.  "
"Migration of a process doesn't affect already existing descendant processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:133
msgid ""
"Following certain structural constraints, controllers may be enabled or "
"disabled selectively on a cgroup.  All controller behaviors are hierarchical "
"- if a controller is enabled on a cgroup, it affects all processes which "
"belong to the cgroups consisting the inclusive sub-hierarchy of the cgroup.  "
"When a controller is enabled on a nested cgroup, it always restricts the "
"resource distribution further.  The restrictions set closer to the root in "
"the hierarchy can not be overridden from further away."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:144
msgid "Basic Operations"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:147
msgid "Mounting"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:149
msgid ""
"Unlike v1, cgroup v2 has only single hierarchy.  The cgroup v2 hierarchy can "
"be mounted with the following mount command::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:154
msgid ""
"cgroup2 filesystem has the magic number 0x63677270 (\"cgrp\").  All "
"controllers which support v2 and are not bound to a v1 hierarchy are "
"automatically bound to the v2 hierarchy and show up at the root. Controllers "
"which are not in active use in the v2 hierarchy can be bound to other "
"hierarchies.  This allows mixing v2 hierarchy with the legacy v1 multiple "
"hierarchies in a fully backward compatible way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:161
msgid ""
"A controller can be moved across hierarchies only after the controller is no "
"longer referenced in its current hierarchy.  Because per-cgroup controller "
"states are destroyed asynchronously and controllers may have lingering "
"references, a controller may not show up immediately on the v2 hierarchy "
"after the final umount of the previous hierarchy. Similarly, a controller "
"should be fully disabled to be moved out of the unified hierarchy and it may "
"take some time for the disabled controller to become available for other "
"hierarchies; furthermore, due to inter-controller dependencies, other "
"controllers may need to be disabled too."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:172
msgid ""
"While useful for development and manual configurations, moving controllers "
"dynamically between the v2 and other hierarchies is strongly discouraged for "
"production use.  It is recommended to decide the hierarchies and controller "
"associations before starting using the controllers after system boot."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:178
msgid ""
"During transition to v2, system management software might still automount "
"the v1 cgroup filesystem and so hijack all controllers during boot, before "
"manual intervention is possible. To make testing and experimenting easier, "
"the kernel parameter cgroup_no_v1= allows disabling controllers in v1 and "
"make them always available in v2."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:184
msgid "cgroup v2 currently supports the following mount options."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:186
msgid "nsdelegate"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:187
msgid ""
"Consider cgroup namespaces as delegation boundaries.  This option is system "
"wide and can only be set on mount or modified through remount from the init "
"namespace.  The mount option is ignored on non-init namespace mounts.  "
"Please refer to the Delegation section for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:193
msgid "favordynmods"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:194
msgid ""
"Reduce the latencies of dynamic cgroup modifications such as task migrations "
"and controller on/offs at the cost of making hot path operations such as "
"forks and exits more expensive. The static usage pattern of creating a "
"cgroup, enabling controllers, and then seeding it with CLONE_INTO_CGROUP is "
"not affected by this option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:201
msgid "memory_localevents"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:202
msgid ""
"Only populate memory.events with data for the current cgroup, and not any "
"subtrees. This is legacy behaviour, the default behaviour without this "
"option is to include subtree counts. This option is system wide and can only "
"be set on mount or modified through remount from the init namespace. The "
"mount option is ignored on non-init namespace mounts."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:209
msgid "memory_recursiveprot"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:210
msgid ""
"Recursively apply memory.min and memory.low protection to entire subtrees, "
"without requiring explicit downward propagation into leaf cgroups.  This "
"allows protecting entire subtrees from one another, while retaining free "
"competition within those subtrees.  This should have been the default "
"behavior but is a mount-option to avoid regressing setups relying on the "
"original semantics (e.g. specifying bogusly high 'bypass' protection values "
"at higher tree levels)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:219
msgid "memory_hugetlb_accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:220
msgid ""
"Count HugeTLB memory usage towards the cgroup's overall memory usage for the "
"memory controller (for the purpose of statistics reporting and memory "
"protetion). This is a new behavior that could regress existing setups, so it "
"must be explicitly opted in with this mount option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:226
msgid "A few caveats to keep in mind:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:228
msgid ""
"There is no HugeTLB pool management involved in the memory controller. The "
"pre-allocated pool does not belong to anyone. Specifically, when a new "
"HugeTLB folio is allocated to the pool, it is not accounted for from the "
"perspective of the memory controller. It is only charged to a cgroup when it "
"is actually used (for e.g at page fault time). Host memory overcommit "
"management has to consider this when configuring hard limits. In general, "
"HugeTLB pool management should be done via other mechanisms (such as the "
"HugeTLB controller)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:237
msgid ""
"Failure to charge a HugeTLB folio to the memory controller results in "
"SIGBUS. This could happen even if the HugeTLB pool still has pages available "
"(but the cgroup limit is hit and reclaim attempt fails)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:241
msgid ""
"Charging HugeTLB memory towards the memory controller affects memory "
"protection and reclaim dynamics. Any userspace tuning (of low, min limits "
"for e.g) needs to take this into account."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:244
msgid ""
"HugeTLB pages utilized while this option is not selected will not be tracked "
"by the memory controller (even if cgroup v2 is remounted later on)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:248
msgid "pids_localevents"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:249
msgid ""
"The option restores v1-like behavior of pids.events:max, that is only local "
"(inside cgroup proper) fork failures are counted. Without this option pids."
"events.max represents any pids.max enforcemnt across cgroup's subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:257
msgid "Organizing Processes and Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:260
msgid "Processes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:262
msgid ""
"Initially, only the root cgroup exists to which all processes belong. A "
"child cgroup can be created by creating a sub-directory::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:267
msgid ""
"A given cgroup may have multiple child cgroups forming a tree structure.  "
"Each cgroup has a read-writable interface file \"cgroup.procs\".  When read, "
"it lists the PIDs of all processes which belong to the cgroup one-per-line.  "
"The PIDs are not ordered and the same PID may show up more than once if the "
"process got moved to another cgroup and then back or the PID got recycled "
"while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:274
msgid ""
"A process can be migrated into a cgroup by writing its PID to the target "
"cgroup's \"cgroup.procs\" file.  Only one process can be migrated on a "
"single write(2) call.  If a process is composed of multiple threads, writing "
"the PID of any thread migrates all threads of the process."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:280
msgid ""
"When a process forks a child process, the new process is born into the "
"cgroup that the forking process belongs to at the time of the operation.  "
"After exit, a process stays associated with the cgroup that it belonged to "
"at the time of exit until it's reaped; however, a zombie process does not "
"appear in \"cgroup.procs\" and thus can't be moved to another cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:287
msgid ""
"A cgroup which doesn't have any children or live processes can be destroyed "
"by removing the directory.  Note that a cgroup which doesn't have any "
"children and is associated only with zombie processes is considered empty "
"and can be removed::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:294
msgid ""
"\"/proc/$PID/cgroup\" lists a process's cgroup membership.  If legacy cgroup "
"is in use in the system, this file may contain multiple lines, one for each "
"hierarchy.  The entry for cgroup v2 is always in the format \"0::$PATH\"::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:303
msgid ""
"If the process becomes a zombie and the cgroup it was associated with is "
"removed subsequently, \" (deleted)\" is appended to the path::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:312
msgid "Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:314
msgid ""
"cgroup v2 supports thread granularity for a subset of controllers to support "
"use cases requiring hierarchical resource distribution across the threads of "
"a group of processes.  By default, all threads of a process belong to the "
"same cgroup, which also serves as the resource domain to host resource "
"consumptions which are not specific to a process or thread.  The thread mode "
"allows threads to be spread across a subtree while still maintaining the "
"common resource domain for them."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:322
msgid ""
"Controllers which support thread mode are called threaded controllers. The "
"ones which don't are called domain controllers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:325
msgid ""
"Marking a cgroup threaded makes it join the resource domain of its parent as "
"a threaded cgroup.  The parent may be another threaded cgroup whose resource "
"domain is further up in the hierarchy.  The root of a threaded subtree, that "
"is, the nearest ancestor which is not threaded, is called threaded domain or "
"thread root interchangeably and serves as the resource domain for the entire "
"subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:332
msgid ""
"Inside a threaded subtree, threads of a process can be put in different "
"cgroups and are not subject to the no internal process constraint - threaded "
"controllers can be enabled on non-leaf cgroups whether they have threads in "
"them or not."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:337
msgid ""
"As the threaded domain cgroup hosts all the domain resource consumptions of "
"the subtree, it is considered to have internal resource consumptions whether "
"there are processes in it or not and can't have populated child cgroups "
"which aren't threaded.  Because the root cgroup is not subject to no "
"internal process constraint, it can serve both as a threaded domain and a "
"parent to domain cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:344
msgid ""
"The current operation mode or type of the cgroup is shown in the \"cgroup."
"type\" file which indicates whether the cgroup is a normal domain, a domain "
"which is serving as the domain of a threaded subtree, or a threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:349
msgid ""
"On creation, a cgroup is always a domain cgroup and can be made threaded by "
"writing \"threaded\" to the \"cgroup.type\" file.  The operation is single "
"direction::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:355
msgid ""
"Once threaded, the cgroup can't be made a domain again.  To enable the "
"thread mode, the following conditions must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:358
msgid ""
"As the cgroup will join the parent's resource domain.  The parent must "
"either be a valid (threaded) domain or a threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:361
msgid ""
"When the parent is an unthreaded domain, it must not have any domain "
"controllers enabled or populated domain children.  The root is exempt from "
"this requirement."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:365
msgid ""
"Topology-wise, a cgroup can be in an invalid state.  Please consider the "
"following topology::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:370
msgid ""
"C is created as a domain but isn't connected to a parent which can host "
"child domains.  C can't be used until it is turned into a threaded cgroup.  "
"\"cgroup.type\" file will report \"domain (invalid)\" in these cases.  "
"Operations which fail due to invalid topology use EOPNOTSUPP as the errno."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:376
msgid ""
"A domain cgroup is turned into a threaded domain when one of its child "
"cgroup becomes threaded or threaded controllers are enabled in the \"cgroup."
"subtree_control\" file while there are processes in the cgroup. A threaded "
"domain reverts to a normal domain when the conditions clear."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:382
msgid ""
"When read, \"cgroup.threads\" contains the list of the thread IDs of all "
"threads in the cgroup.  Except that the operations are per-thread instead of "
"per-process, \"cgroup.threads\" has the same format and behaves the same way "
"as \"cgroup.procs\".  While \"cgroup.threads\" can be written to in any "
"cgroup, as it can only move threads inside the same threaded domain, its "
"operations are confined inside each threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:390
msgid ""
"The threaded domain cgroup serves as the resource domain for the whole "
"subtree, and, while the threads can be scattered across the subtree, all the "
"processes are considered to be in the threaded domain cgroup. \"cgroup."
"procs\" in a threaded domain cgroup contains the PIDs of all processes in "
"the subtree and is not readable in the subtree proper. However, \"cgroup."
"procs\" can be written to from anywhere in the subtree to migrate all "
"threads of the matching process to the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:398
msgid ""
"Only threaded controllers can be enabled in a threaded subtree.  When a "
"threaded controller is enabled inside a threaded subtree, it only accounts "
"for and controls resource consumptions associated with the threads in the "
"cgroup and its descendants.  All consumptions which aren't tied to a "
"specific thread belong to the threaded domain cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:404
msgid ""
"Because a threaded subtree is exempt from no internal process constraint, a "
"threaded controller must be able to handle competition between threads in a "
"non-leaf cgroup and its child cgroups.  Each threaded controller defines how "
"such competitions are handled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:409
msgid ""
"Currently, the following controllers are threaded and can be enabled in a "
"threaded cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:418
msgid "[Un]populated Notification"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:420
msgid ""
"Each non-root cgroup has a \"cgroup.events\" file which contains "
"\"populated\" field indicating whether the cgroup's sub-hierarchy has live "
"processes in it.  Its value is 0 if there is no live process in the cgroup "
"and its descendants; otherwise, 1.  poll and [id]notify events are triggered "
"when the value changes.  This can be used, for example, to start a clean-up "
"operation after all processes of a given sub-hierarchy have exited.  The "
"populated state updates and notifications are recursive.  Consider the "
"following sub-hierarchy where the numbers in the parentheses represent the "
"numbers of processes in each cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:434
msgid ""
"A, B and C's \"populated\" fields would be 1 while D's 0.  After the one "
"process in C exits, B and C's \"populated\" fields would flip to \"0\" and "
"file modified events will be generated on the \"cgroup.events\" files of "
"both cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:441
msgid "Controlling Controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:444
msgid "Availability"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:446
msgid ""
"A controller is available in a cgroup when it is supported by the kernel (i."
"e., compiled in, not disabled and not attached to a v1 hierarchy) and listed "
"in the \"cgroup.controllers\" file. Availability means the controller's "
"interface files are exposed in the cgroupâ€™s directory, allowing the "
"distribution of the target resource to be observed or controlled within that "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:453
msgid "Enabling and Disabling"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:455
msgid ""
"Each cgroup has a \"cgroup.controllers\" file which lists all controllers "
"available for the cgroup to enable::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:461
msgid ""
"No controller is enabled by default.  Controllers can be enabled and "
"disabled by writing to the \"cgroup.subtree_control\" file::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:466
msgid ""
"Only controllers which are listed in \"cgroup.controllers\" can be enabled.  "
"When multiple operations are specified as above, either they all succeed or "
"fail.  If multiple operations on the same controller are specified, the last "
"one is effective."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:471
msgid ""
"Enabling a controller in a cgroup indicates that the distribution of the "
"target resource across its immediate children will be controlled. Consider "
"the following sub-hierarchy.  The enabled controllers are listed in "
"parentheses::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:479
msgid ""
"As A has \"cpu\" and \"memory\" enabled, A will control the distribution of "
"CPU cycles and memory to its children, in this case, B.  As B has \"memory\" "
"enabled but not \"CPU\", C and D will compete freely on CPU cycles but their "
"division of memory available to B will be controlled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:484
msgid ""
"As a controller regulates the distribution of the target resource to the "
"cgroup's children, enabling it creates the controller's interface files in "
"the child cgroups.  In the above example, enabling \"cpu\" on B would create "
"the \"cpu.\" prefixed controller interface files in C and D.  Likewise, "
"disabling \"memory\" from B would remove the \"memory.\" prefixed controller "
"interface files from C and D.  This means that the controller interface "
"files - anything which doesn't start with \"cgroup.\" are owned by the "
"parent rather than the cgroup itself."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:495
msgid "Top-down Constraint"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:497
msgid ""
"Resources are distributed top-down and a cgroup can further distribute a "
"resource only if the resource has been distributed to it from the parent.  "
"This means that all non-root \"cgroup.subtree_control\" files can only "
"contain controllers which are enabled in the parent's \"cgroup."
"subtree_control\" file.  A controller can be enabled only if the parent has "
"the controller enabled and a controller can't be disabled if one or more "
"children have it enabled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:507
msgid "No Internal Process Constraint"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:509
msgid ""
"Non-root cgroups can distribute domain resources to their children only when "
"they don't have any processes of their own.  In other words, only domain "
"cgroups which don't contain any processes can have domain controllers "
"enabled in their \"cgroup.subtree_control\" files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:514
msgid ""
"This guarantees that, when a domain controller is looking at the part of the "
"hierarchy which has it enabled, processes are always only on the leaves.  "
"This rules out situations where child cgroups compete against internal "
"processes of the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:519
msgid ""
"The root cgroup is exempt from this restriction.  Root contains processes "
"and anonymous resource consumption which can't be associated with any other "
"cgroups and requires special treatment from most controllers.  How resource "
"consumption in the root cgroup is governed is up to each controller (for "
"more information on this topic please refer to the Non-normative information "
"section in the Controllers chapter)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:527
msgid ""
"Note that the restriction doesn't get in the way if there is no enabled "
"controller in the cgroup's \"cgroup.subtree_control\".  This is important as "
"otherwise it wouldn't be possible to create children of a populated cgroup.  "
"To control resource distribution of a cgroup, the cgroup must create "
"children and transfer all its processes to the children before enabling "
"controllers in its \"cgroup.subtree_control\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:537
msgid "Delegation"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:540
msgid "Model of Delegation"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:542
msgid ""
"A cgroup can be delegated in two ways.  First, to a less privileged user by "
"granting write access of the directory and its \"cgroup.procs\", \"cgroup."
"threads\" and \"cgroup.subtree_control\" files to the user. Second, if the "
"\"nsdelegate\" mount option is set, automatically to a cgroup namespace on "
"namespace creation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:548
msgid ""
"Because the resource control interface files in a given directory control "
"the distribution of the parent's resources, the delegatee shouldn't be "
"allowed to write to them.  For the first method, this is achieved by not "
"granting access to these files.  For the second, files outside the namespace "
"should be hidden from the delegatee by the means of at least mount "
"namespacing, and the kernel rejects writes to all files on a namespace root "
"from inside the cgroup namespace, except for those files listed in \"/sys/"
"kernel/cgroup/delegate\" (including \"cgroup.procs\", \"cgroup.threads\", "
"\"cgroup.subtree_control\", etc.)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:558
msgid ""
"The end results are equivalent for both delegation types.  Once delegated, "
"the user can build sub-hierarchy under the directory, organize processes "
"inside it as it sees fit and further distribute the resources it received "
"from the parent.  The limits and other settings of all resource controllers "
"are hierarchical and regardless of what happens in the delegated sub-"
"hierarchy, nothing can escape the resource restrictions imposed by the "
"parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:566
msgid ""
"Currently, cgroup doesn't impose any restrictions on the number of cgroups "
"in or nesting depth of a delegated sub-hierarchy; however, this may be "
"limited explicitly in the future."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:572
msgid "Delegation Containment"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:574
msgid ""
"A delegated sub-hierarchy is contained in the sense that processes can't be "
"moved into or out of the sub-hierarchy by the delegatee."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:577
msgid ""
"For delegations to a less privileged user, this is achieved by requiring the "
"following conditions for a process with a non-root euid to migrate a target "
"process into a cgroup by writing its PID to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:582
msgid "The writer must have write access to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:584
msgid ""
"The writer must have write access to the \"cgroup.procs\" file of the common "
"ancestor of the source and destination cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:587
msgid ""
"The above two constraints ensure that while a delegatee may migrate "
"processes around freely in the delegated sub-hierarchy it can't pull in from "
"or push out to outside the sub-hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:591
msgid ""
"For an example, let's assume cgroups C0 and C1 have been delegated to user "
"U0 who created C00, C01 under C0 and C10 under C1 as follows and all "
"processes under C0 and C1 belong to U0::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:600
msgid ""
"Let's also say U0 wants to write the PID of a process which is currently in "
"C10 into \"C00/cgroup.procs\".  U0 has write access to the file; however, "
"the common ancestor of the source cgroup C10 and the destination cgroup C00 "
"is above the points of delegation and U0 would not have write access to its "
"\"cgroup.procs\" files and thus the write will be denied with -EACCES."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:607
msgid ""
"For delegations to namespaces, containment is achieved by requiring that "
"both the source and destination cgroups are reachable from the namespace of "
"the process which is attempting the migration.  If either is not reachable, "
"the migration is rejected with -ENOENT."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:614
msgid "Guidelines"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:617
msgid "Organize Once and Control"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:619
msgid ""
"Migrating a process across cgroups is a relatively expensive operation and "
"stateful resources such as memory are not moved together with the process.  "
"This is an explicit design decision as there often exist inherent trade-offs "
"between migration and various hot paths in terms of synchronization cost."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:625
msgid ""
"As such, migrating processes across cgroups frequently as a means to apply "
"different resource restrictions is discouraged.  A workload should be "
"assigned to a cgroup according to the system's logical and resource "
"structure once on start-up.  Dynamic adjustments to resource distribution "
"can be made by changing controller configuration through the interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:634
msgid "Avoid Name Collisions"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:636
msgid ""
"Interface files for a cgroup and its children cgroups occupy the same "
"directory and it is possible to create children cgroups which collide with "
"interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:640
msgid ""
"All cgroup core interface files are prefixed with \"cgroup.\" and each "
"controller's interface files are prefixed with the controller name and a "
"dot.  A controller's name is composed of lower case alphabets and '_'s but "
"never begins with an '_' so it can be used as the prefix character for "
"collision avoidance.  Also, interface file names won't start or end with "
"terms which are often used in categorizing workloads such as job, service, "
"slice, unit or workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:648
msgid ""
"cgroup doesn't do anything to prevent name collisions and it's the user's "
"responsibility to avoid them."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:653
msgid "Resource Distribution Models"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:655
msgid ""
"cgroup controllers implement several resource distribution schemes depending "
"on the resource type and expected use cases.  This section describes major "
"schemes in use along with their expected behaviors."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:661
msgid "Weights"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:663
msgid ""
"A parent's resource is distributed by adding up the weights of all active "
"children and giving each the fraction matching the ratio of its weight "
"against the sum.  As only children which can make use of the resource at the "
"moment participate in the distribution, this is work-conserving.  Due to the "
"dynamic nature, this model is usually used for stateless resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:670
msgid ""
"All weights are in the range [1, 10000] with the default at 100.  This "
"allows symmetric multiplicative biases in both directions at fine enough "
"granularity while staying in the intuitive range."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:674
msgid ""
"As long as the weight is in range, all configuration combinations are valid "
"and there is no reason to reject configuration changes or process migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:678
msgid ""
"\"cpu.weight\" proportionally distributes CPU cycles to active children and "
"is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:685
msgid "Limits"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:687
msgid ""
"A child can only consume up to the configured amount of the resource. Limits "
"can be over-committed - the sum of the limits of children can exceed the "
"amount of resource available to the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:691
msgid ""
"Limits are in the range [0, max] and defaults to \"max\", which is noop."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:693
msgid ""
"As limits can be over-committed, all configuration combinations are valid "
"and there is no reason to reject configuration changes or process migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:697
msgid ""
"\"io.max\" limits the maximum BPS and/or IOPS that a cgroup can consume on "
"an IO device and is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:703
msgid "Protections"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:705
msgid ""
"A cgroup is protected up to the configured amount of the resource as long as "
"the usages of all its ancestors are under their protected levels.  "
"Protections can be hard guarantees or best effort soft boundaries.  "
"Protections can also be over-committed in which case only up to the amount "
"available to the parent is protected among children."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:712
msgid "Protections are in the range [0, max] and defaults to 0, which is noop."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:715
msgid ""
"As protections can be over-committed, all configuration combinations are "
"valid and there is no reason to reject configuration changes or process "
"migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:719
msgid ""
"\"memory.low\" implements best-effort memory protection and is an example of "
"this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:724
msgid "Allocations"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:726
msgid ""
"A cgroup is exclusively allocated a certain amount of a finite resource.  "
"Allocations can't be over-committed - the sum of the allocations of children "
"can not exceed the amount of resource available to the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:731
msgid ""
"Allocations are in the range [0, max] and defaults to 0, which is no "
"resource."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:734
msgid ""
"As allocations can't be over-committed, some configuration combinations are "
"invalid and should be rejected.  Also, if the resource is mandatory for "
"execution of processes, process migrations may be rejected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:739
msgid ""
"\"cpu.rt.max\" hard-allocates realtime slices and is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:744
msgid "Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:747
msgid "Format"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:749
msgid ""
"All interface files should be in one of the following formats whenever "
"possible::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:776
msgid ""
"For a writable file, the format for writing should generally match reading; "
"however, controllers may allow omitting later fields or implement restricted "
"shortcuts for most common use cases."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:780
msgid ""
"For both flat and nested keyed files, only the values for a single key can "
"be written at a time.  For nested keyed files, the sub key pairs may be "
"specified in any order and not all pairs have to be specified."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:786
msgid "Conventions"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:788
msgid "Settings for a single feature should be contained in a single file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:790
msgid ""
"The root cgroup should be exempt from resource control and thus shouldn't "
"have resource control interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:793
msgid ""
"The default time unit is microseconds.  If a different unit is ever used, an "
"explicit unit suffix must be present."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:796
msgid ""
"A parts-per quantity should use a percentage decimal with at least two digit "
"fractional part - e.g. 13.40."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:799
msgid ""
"If a controller implements weight based resource distribution, its interface "
"file should be named \"weight\" and have the range [1, 10000] with 100 as "
"the default.  The values are chosen to allow enough and symmetric bias in "
"both directions while keeping it intuitive (the default is 100%)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:805
msgid ""
"If a controller implements an absolute resource guarantee and/or limit, the "
"interface files should be named \"min\" and \"max\" respectively.  If a "
"controller implements best effort resource guarantee and/or limit, the "
"interface files should be named \"low\" and \"high\" respectively."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:811
msgid ""
"In the above four control files, the special token \"max\" should be used to "
"represent upward infinity for both reading and writing."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:814
msgid ""
"If a setting has a configurable default value and keyed specific overrides, "
"the default entry should be keyed with \"default\" and appear as the first "
"entry in the file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:818
msgid ""
"The default value can be updated by writing either \"default $VAL\" or "
"\"$VAL\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:821
msgid ""
"When writing to update a specific override, \"default\" can be used as the "
"value to indicate removal of the override.  Override entries with "
"\"default\" as the value must not appear when read."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:825
msgid ""
"For example, a setting which is keyed by major:minor device numbers with "
"integer values may look like the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:832
msgid "The default value can be updated by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:836
msgid "or::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:840
msgid "An override can be set by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:844
msgid "and cleared by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:851
msgid ""
"For events which are not very high frequency, an interface file \"events\" "
"should be created which lists event key value pairs. Whenever a notifiable "
"event happens, file modified event should be generated on the file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:858
msgid "Core Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:860
msgid "All cgroup core files are prefixed with \"cgroup.\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:862
msgid "cgroup.type"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:863
#: ../../../admin-guide/cgroup-v2.rst:1446
#: ../../../admin-guide/cgroup-v2.rst:1833
msgid "A read-write single value file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:866
msgid ""
"When read, it indicates the current type of the cgroup, which can be one of "
"the following values."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:869
msgid "\"domain\" : A normal valid domain cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:871
msgid ""
"\"domain threaded\" : A threaded domain cgroup which is serving as the root "
"of a threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:874
msgid ""
"\"domain invalid\" : A cgroup which is in an invalid state. It can't be "
"populated or have controllers enabled.  It may be allowed to become a "
"threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:878
msgid ""
"\"threaded\" : A threaded cgroup which is a member of a threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:881
msgid ""
"A cgroup can be turned into a threaded cgroup by writing \"threaded\" to "
"this file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:884
msgid "cgroup.procs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:885
#: ../../../admin-guide/cgroup-v2.rst:911
msgid ""
"A read-write new-line separated values file which exists on all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:888
msgid ""
"When read, it lists the PIDs of all processes which belong to the cgroup one-"
"per-line.  The PIDs are not ordered and the same PID may show up more than "
"once if the process got moved to another cgroup and then back or the PID got "
"recycled while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:894
msgid ""
"A PID can be written to migrate the process associated with the PID to the "
"cgroup.  The writer should match all of the following conditions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:898
msgid "It must have write access to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:900
#: ../../../admin-guide/cgroup-v2.rst:929
msgid ""
"It must have write access to the \"cgroup.procs\" file of the common "
"ancestor of the source and destination cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:903
#: ../../../admin-guide/cgroup-v2.rst:932
msgid ""
"When delegating a sub-hierarchy, write access to this file should be granted "
"along with the containing directory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:906
msgid ""
"In a threaded cgroup, reading this file fails with EOPNOTSUPP as all the "
"processes belong to the thread root.  Writing is supported and moves every "
"thread of the process to the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:910
msgid "cgroup.threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:914
msgid ""
"When read, it lists the TIDs of all threads which belong to the cgroup one-"
"per-line.  The TIDs are not ordered and the same TID may show up more than "
"once if the thread got moved to another cgroup and then back or the TID got "
"recycled while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:920
msgid ""
"A TID can be written to migrate the thread associated with the TID to the "
"cgroup.  The writer should match all of the following conditions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:924
msgid "It must have write access to the \"cgroup.threads\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:926
msgid ""
"The cgroup that the thread is currently in must be in the same resource "
"domain as the destination cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:935
msgid "cgroup.controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:936
msgid "A read-only space separated values file which exists on all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:939
msgid ""
"It shows space separated list of all controllers available to the cgroup.  "
"The controllers are not ordered."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:942
msgid "cgroup.subtree_control"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:943
msgid ""
"A read-write space separated values file which exists on all cgroups.  "
"Starts out empty."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:946
msgid ""
"When read, it shows space separated list of the controllers which are "
"enabled to control resource distribution from the cgroup to its children."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:950
msgid ""
"Space separated list of controllers prefixed with '+' or '-' can be written "
"to enable or disable controllers.  A controller name prefixed with '+' "
"enables the controller and '-' disables.  If a controller appears more than "
"once on the list, the last one is effective.  When multiple enable and "
"disable operations are specified, either all succeed or all fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:957
msgid "cgroup.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:958
#: ../../../admin-guide/cgroup-v2.rst:1474
#: ../../../admin-guide/cgroup-v2.rst:1850
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. The following "
"entries are defined.  Unless specified otherwise, a value change in this "
"file generates a file modified event."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:963
msgid "populated"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:964
msgid ""
"1 if the cgroup or its descendants contains any live processes; otherwise, 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:966
msgid "frozen"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:967
msgid "1 if the cgroup is frozen; otherwise, 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:969
msgid "cgroup.max.descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:970
#: ../../../admin-guide/cgroup-v2.rst:977
msgid "A read-write single value files.  The default is \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:972
msgid ""
"Maximum allowed number of descent cgroups. If the actual number of "
"descendants is equal or larger, an attempt to create a new cgroup in the "
"hierarchy will fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:976
msgid "cgroup.max.depth"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:979
msgid ""
"Maximum allowed descent depth below the current cgroup. If the actual "
"descent depth is equal or larger, an attempt to create a new child cgroup "
"will fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:983
msgid "cgroup.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:984
msgid "A read-only flat-keyed file with the following entries:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:986
msgid "nr_descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:987
msgid "Total number of visible descendant cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:989
msgid "nr_dying_descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:990
msgid ""
"Total number of dying descendant cgroups. A cgroup becomes dying after being "
"deleted by a user. The cgroup will remain in dying state for some time "
"undefined time (which can depend on system load) before being completely "
"destroyed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:995
msgid ""
"A process can't enter a dying cgroup under any circumstances, a dying cgroup "
"can't revive."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:998
msgid ""
"A dying cgroup can consume system resources not exceeding limits, which were "
"active at the moment of cgroup deletion."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1001
msgid "nr_subsys_<cgroup_subsys>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1002
msgid ""
"Total number of live cgroup subsystems (e.g memory cgroup) at and beneath "
"the current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1005
msgid "nr_dying_subsys_<cgroup_subsys>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1006
msgid ""
"Total number of dying cgroup subsystems (e.g. memory cgroup) at and beneath "
"the current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1009
msgid "cgroup.stat.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1010
msgid ""
"A read-only flat-keyed file which exists in non-root cgroups. The following "
"entry is defined:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1013
msgid "frozen_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1014
msgid ""
"Cumulative time that this cgroup has spent between freezing and thawing, "
"regardless of whether by self or ancestor groups. NB: (not) reaching "
"\"frozen\" state is not accounted here."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1018
msgid ""
"Using the following ASCII representation of a cgroup's freezer state, ::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1025
msgid "the duration being measured is the span between a and c."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1027
msgid "cgroup.freeze"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1028
msgid ""
"A read-write single value file which exists on non-root cgroups. Allowed "
"values are \"0\" and \"1\". The default is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1031
msgid ""
"Writing \"1\" to the file causes freezing of the cgroup and all descendant "
"cgroups. This means that all belonging processes will be stopped and will "
"not run until the cgroup will be explicitly unfrozen. Freezing of the cgroup "
"may take some time; when this action is completed, the \"frozen\" value in "
"the cgroup.events control file will be updated to \"1\" and the "
"corresponding notification will be issued."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1039
msgid ""
"A cgroup can be frozen either by its own settings, or by settings of any "
"ancestor cgroups. If any of ancestor cgroups is frozen, the cgroup will "
"remain frozen."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1043
msgid ""
"Processes in the frozen cgroup can be killed by a fatal signal. They also "
"can enter and leave a frozen cgroup: either by an explicit move by a user, "
"or if freezing of the cgroup races with fork(). If a process is moved to a "
"frozen cgroup, it stops. If a process is moved out of a frozen cgroup, it "
"becomes running."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1049
msgid ""
"Frozen status of a cgroup doesn't affect any cgroup tree operations: it's "
"possible to delete a frozen (and empty) cgroup, as well as create new sub-"
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1053
msgid "cgroup.kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1054
msgid ""
"A write-only single value file which exists in non-root cgroups. The only "
"allowed value is \"1\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1057
msgid ""
"Writing \"1\" to the file causes the cgroup and all descendant cgroups to be "
"killed. This means that all processes located in the affected cgroup tree "
"will be killed via SIGKILL."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1061
msgid ""
"Killing a cgroup tree will deal with concurrent forks appropriately and is "
"protected against migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1064
msgid ""
"In a threaded cgroup, writing this file fails with EOPNOTSUPP as killing "
"cgroups is a process directed operation, i.e. it affects the whole thread-"
"group."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1068
msgid "cgroup.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1069
msgid ""
"A read-write single value file that allowed values are \"0\" and \"1\". The "
"default is \"1\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1072
msgid ""
"Writing \"0\" to the file will disable the cgroup PSI accounting. Writing "
"\"1\" to the file will re-enable the cgroup PSI accounting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1075
msgid ""
"This control attribute is not hierarchical, so disable or enable PSI "
"accounting in a cgroup does not affect PSI accounting in descendants and "
"doesn't need pass enablement via ancestors from root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1079
msgid ""
"The reason this control attribute exists is that PSI accounts stalls for "
"each cgroup separately and aggregates it at each level of the hierarchy. "
"This may cause non-negligible overhead for some workloads when under deep "
"level of the hierarchy, in which case this control attribute can be used to "
"disable PSI accounting in the non-leaf cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1085
msgid "irq.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1086
#: ../../../admin-guide/cgroup-v2.rst:1218
msgid "A read-write nested-keyed file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1088
msgid ""
"Shows pressure stall information for IRQ/SOFTIRQ. See :ref:`Documentation/"
"accounting/psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1092
msgid "Controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1097
msgid "CPU"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1099
msgid ""
"The \"cpu\" controllers regulates distribution of CPU cycles.  This "
"controller implements weight and absolute bandwidth limit models for normal "
"scheduling policy and absolute bandwidth allocation model for realtime "
"scheduling policy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1104
msgid ""
"In all the above models, cycles distribution is defined only on a temporal "
"base and it does not account for the frequency at which tasks are executed. "
"The (optional) utilization clamping support allows to hint the schedutil "
"cpufreq governor about the minimum desired frequency which should always be "
"provided by a CPU, as well as the maximum desired frequency, which should "
"not be exceeded by a CPU."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1111
msgid ""
"WARNING: cgroup2 cpu controller doesn't yet support the (bandwidth) control "
"of realtime processes. For a kernel built with the CONFIG_RT_GROUP_SCHED "
"option enabled for group scheduling of realtime processes, the cpu "
"controller can only be enabled when all RT processes are in the root cgroup. "
"Be aware that system management software may already have placed RT "
"processes into non-root cgroups during the system boot process, and these "
"processes may need to be moved to the root cgroup before the cpu controller "
"can be enabled with a CONFIG_RT_GROUP_SCHED enabled kernel."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1120
msgid ""
"With CONFIG_RT_GROUP_SCHED disabled, this limitation does not apply and some "
"of the interface files either affect realtime processes or account for them. "
"See the following section for details. Only the cpu controller is affected "
"by CONFIG_RT_GROUP_SCHED. Other controllers can be used for the resource "
"control of realtime processes irrespective of CONFIG_RT_GROUP_SCHED."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1128
msgid "CPU Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1130
msgid ""
"The interaction of a process with the cpu controller depends on its "
"scheduling policy and the underlying scheduler. From the point of view of "
"the cpu controller, processes can be categorized as follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1134
msgid "Processes under the fair-class scheduler"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1135
msgid "Processes under a BPF scheduler with the ``cgroup_set_weight`` callback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1136
msgid ""
"Everything else: ``SCHED_{FIFO,RR,DEADLINE}`` and processes under a BPF "
"scheduler without the ``cgroup_set_weight`` callback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1139
msgid ""
"For details on when a process is under the fair-class scheduler or a BPF "
"scheduler, check out :ref:`Documentation/scheduler/sched-ext.rst <sched-"
"ext>`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1142
msgid ""
"For each of the following interface files, the above categories will be "
"referred to. All time durations are in microseconds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1145
msgid "cpu.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1146
msgid ""
"A read-only flat-keyed file. This file exists whether the controller is "
"enabled or not."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1149
msgid ""
"It always reports the following three stats, which account for all the "
"processes in the cgroup:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1152
msgid "usage_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1153
msgid "user_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1154
msgid "system_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1156
msgid ""
"and the following five when the controller is enabled, which account for "
"only the processes under the fair-class scheduler:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1159
msgid "nr_periods"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1160
msgid "nr_throttled"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1161
msgid "throttled_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1162
msgid "nr_bursts"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1163
msgid "burst_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1165
msgid "cpu.weight"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1166
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"100\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1169
msgid ""
"For non idle groups (cpu.idle = 0), the weight is in the range [1, 10000]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1172
msgid ""
"If the cgroup has been configured to be SCHED_IDLE (cpu.idle = 1), then the "
"weight will show as a 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1175
#: ../../../admin-guide/cgroup-v2.rst:1191
msgid ""
"This file affects only processes under the fair-class scheduler and a BPF "
"scheduler with the ``cgroup_set_weight`` callback depending on what the "
"callback actually does."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1179
msgid "cpu.weight.nice"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1180
#: ../../../admin-guide/cgroup-v2.rst:1210
#: ../../../admin-guide/cgroup-v2.rst:1307
#: ../../../admin-guide/cgroup-v2.rst:1333
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1183
msgid "The nice value is in the range [-20, 19]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1185
msgid ""
"This interface file is an alternative interface for \"cpu.weight\" and "
"allows reading and setting weight using the same values used by nice(2).  "
"Because the range is smaller and granularity is coarser for the nice values, "
"the read value is the closest approximation of the current weight."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1195
msgid "cpu.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1196
msgid ""
"A read-write two value file which exists on non-root cgroups. The default is "
"\"max 100000\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1199
msgid "The maximum bandwidth limit.  It's in the following format::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1203
msgid ""
"which indicates that the group may consume up to $MAX in each $PERIOD "
"duration.  \"max\" for $MAX indicates no limit.  If only one number is "
"written, $MAX is updated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1207
#: ../../../admin-guide/cgroup-v2.rst:1215
#: ../../../admin-guide/cgroup-v2.rst:1267
msgid "This file affects only processes under the fair-class scheduler."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1209
msgid "cpu.max.burst"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1213
msgid "The burst in the range [0, $MAX]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1217
msgid "cpu.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1220
msgid ""
"Shows pressure stall information for CPU. See :ref:`Documentation/accounting/"
"psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1223
msgid "This file accounts for all the processes in the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1225
msgid "cpu.uclamp.min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1226
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is \"0\", i.e. no utilization boosting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1229
msgid ""
"The requested minimum utilization (protection) as a percentage rational "
"number, e.g. 12.34 for 12.34%."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1232
msgid ""
"This interface allows reading and setting minimum utilization clamp values "
"similar to the sched_setattr(2). This minimum utilization value is used to "
"clamp the task specific minimum utilization clamp, including those of "
"realtime processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1237
msgid ""
"The requested minimum utilization (protection) is always capped by the "
"current value for the maximum utilization (limit), i.e. `cpu.uclamp.max`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1241
#: ../../../admin-guide/cgroup-v2.rst:1255
msgid "This file affects all the processes in the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1243
msgid "cpu.uclamp.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1244
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is \"max\". i.e. no utilization capping"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1247
msgid ""
"The requested maximum utilization (limit) as a percentage rational number, e."
"g. 98.76 for 98.76%."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1250
msgid ""
"This interface allows reading and setting maximum utilization clamp values "
"similar to the sched_setattr(2). This maximum utilization value is used to "
"clamp the task specific maximum utilization clamp, including those of "
"realtime processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1257
msgid "cpu.idle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1258
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1261
msgid ""
"This is the cgroup analog of the per-task SCHED_IDLE sched policy. Setting "
"this value to a 1 will make the scheduling policy of the cgroup SCHED_IDLE. "
"The threads inside the cgroup will retain their own relative priorities, but "
"the cgroup itself will be treated as very low priority relative to its peers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1270
#: ../../../admin-guide/cgroup-v2.rst:3336
msgid "Memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1272
msgid ""
"The \"memory\" controller regulates distribution of memory.  Memory is "
"stateful and implements both limit and protection models.  Due to the "
"intertwining between memory usage and reclaim pressure and the stateful "
"nature of memory, the distribution model is relatively complex."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1278
msgid ""
"While not completely water-tight, all major memory usages by a given cgroup "
"are tracked so that the total memory consumption can be accounted and "
"controlled to a reasonable extent.  Currently, the following types of memory "
"usages are tracked."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1283
msgid "Userland memory - page cache and anonymous memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1285
msgid "Kernel data structures such as dentries and inodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1287
msgid "TCP socket buffers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1289
msgid "The above list may expand in the future for better coverage."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1293
msgid "Memory Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1295
msgid ""
"All memory amounts are in bytes.  If a value which is not aligned to "
"PAGE_SIZE is written, the value may be rounded up to the closest PAGE_SIZE "
"multiple when read back."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1299
msgid "memory.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1300
#: ../../../admin-guide/cgroup-v2.rst:1810
#: ../../../admin-guide/cgroup-v2.rst:1875
#: ../../../admin-guide/cgroup-v2.rst:2380
#: ../../../admin-guide/cgroup-v2.rst:2386
msgid "A read-only single value file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1303
msgid ""
"The total amount of memory currently being used by the cgroup and its "
"descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1306
msgid "memory.min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1310
msgid ""
"Hard memory protection.  If the memory usage of a cgroup is within its "
"effective min boundary, the cgroup's memory won't be reclaimed under any "
"conditions. If there is no unprotected reclaimable memory available, OOM "
"killer is invoked. Above the effective min boundary (or effective low "
"boundary if it is higher), pages are reclaimed proportionally to the "
"overage, reducing reclaim pressure for smaller overages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1319
msgid ""
"Effective min boundary is limited by memory.min values of all ancestor "
"cgroups. If there is memory.min overcommitment (child cgroup or cgroups are "
"requiring more protected memory than parent will allow), then each child "
"cgroup will get the part of parent's protection proportional to its actual "
"memory usage below memory.min."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1326
msgid ""
"Putting more memory than generally available under this protection is "
"discouraged and may lead to constant OOMs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1329
msgid ""
"If a memory cgroup is not populated with processes, its memory.min is "
"ignored."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1332
msgid "memory.low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1336
msgid ""
"Best-effort memory protection.  If the memory usage of a cgroup is within "
"its effective low boundary, the cgroup's memory won't be reclaimed unless "
"there is no reclaimable memory available in unprotected cgroups. Above the "
"effective low boundary (or effective min boundary if it is higher), pages "
"are reclaimed proportionally to the overage, reducing reclaim pressure for "
"smaller overages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1345
msgid ""
"Effective low boundary is limited by memory.low values of all ancestor "
"cgroups. If there is memory.low overcommitment (child cgroup or cgroups are "
"requiring more protected memory than parent will allow), then each child "
"cgroup will get the part of parent's protection proportional to its actual "
"memory usage below memory.low."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1352
msgid ""
"Putting more memory than generally available under this protection is "
"discouraged."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1355
msgid "memory.high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1356
#: ../../../admin-guide/cgroup-v2.rst:1382
#: ../../../admin-guide/cgroup-v2.rst:1817
#: ../../../admin-guide/cgroup-v2.rst:1843
#: ../../../admin-guide/cgroup-v2.rst:1882
#: ../../../admin-guide/cgroup-v2.rst:2374
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1359
msgid ""
"Memory usage throttle limit.  If a cgroup's usage goes over the high "
"boundary, the processes of the cgroup are throttled and put under heavy "
"reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1363
msgid ""
"Going over the high limit never invokes the OOM killer and under extreme "
"conditions the limit may be breached. The high limit should be used in "
"scenarios where an external process monitors the limited cgroup to alleviate "
"heavy reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1369
msgid ""
"If memory.high is opened with O_NONBLOCK then the synchronous reclaim is "
"bypassed. This is useful for admin processes that need to dynamically adjust "
"the job's memory limits without expending their own CPU resources on memory "
"reclamation. The job will trigger the reclaim and/or get throttled on its "
"next charge request."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1376
#: ../../../admin-guide/cgroup-v2.rst:1405
msgid ""
"Please note that with O_NONBLOCK, there is a chance that the target memory "
"cgroup may take indefinite amount of time to reduce usage below the limit "
"due to delayed charge request or busy-hitting its memory to slow down "
"reclaim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1381
msgid "memory.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1385
msgid ""
"Memory usage hard limit.  This is the main mechanism to limit memory usage "
"of a cgroup.  If a cgroup's memory usage reaches this limit and can't be "
"reduced, the OOM killer is invoked in the cgroup. Under certain "
"circumstances, the usage may go over the limit temporarily."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1391
msgid ""
"In default configuration regular 0-order allocations always succeed unless "
"OOM killer chooses current task as a victim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1394
msgid ""
"Some kinds of allocations don't invoke the OOM killer. Caller could retry "
"them differently, return into userspace as -ENOMEM or silently ignore in "
"cases like disk readahead."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1398
msgid ""
"If memory.max is opened with O_NONBLOCK, then the synchronous reclaim and "
"oom-kill are bypassed. This is useful for admin processes that need to "
"dynamically adjust the job's memory limits without expending their own CPU "
"resources on memory reclamation. The job will trigger the reclaim and/or oom-"
"kill on its next charge request."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1410
msgid "memory.reclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1411
msgid "A write-only nested-keyed file which exists for all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1413
msgid ""
"This is a simple interface to trigger memory reclaim in the target cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1416
msgid "Example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1420
msgid ""
"Please note that the kernel can over or under reclaim from the target "
"cgroup. If less bytes are reclaimed than the specified amount, -EAGAIN is "
"returned."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1424
msgid ""
"Please note that the proactive reclaim (triggered by this interface) is not "
"meant to indicate memory pressure on the memory cgroup. Therefore socket "
"memory balancing triggered by the memory reclaim normally is not exercised "
"in this case. This means that the networking layer will not adapt based on "
"reclaim induced by memory.reclaim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1431
#: ../../../admin-guide/cgroup-v2.rst:2729
msgid "The following nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1434
msgid "swappiness"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1434
msgid "Swappiness value to reclaim with"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1437
msgid ""
"Specifying a swappiness value instructs the kernel to perform the reclaim "
"with that swappiness value. Note that this has the same semantics as vm."
"swappiness applied to memcg reclaim with all the existing limitations and "
"potential future extensions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1442
msgid ""
"The valid range for swappiness is [0-200, max], setting swappiness=max "
"exclusively reclaims anonymous memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1445
msgid "memory.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1448
msgid ""
"The max memory usage recorded for the cgroup and its descendants since "
"either the creation of the cgroup or the most recent reset for that FD."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1451
#: ../../../admin-guide/cgroup-v2.rst:1838
msgid ""
"A write of any non-empty string to this file resets it to the current memory "
"usage for subsequent reads through the same file descriptor."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1455
msgid "memory.oom.group"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1456
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default value is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1459
msgid ""
"Determines whether the cgroup should be treated as an indivisible workload "
"by the OOM killer. If set, all tasks belonging to the cgroup or to its "
"descendants (if the memory cgroup is not a leaf cgroup) are killed together "
"or not at all. This can be used to avoid partial kills to guarantee workload "
"integrity."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1466
msgid ""
"Tasks with the OOM protection (oom_score_adj set to -1000) are treated as an "
"exception and are never killed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1469
msgid ""
"If the OOM killer is invoked in a cgroup, it's not going to kill any tasks "
"outside of this cgroup, regardless memory.oom.group values of ancestor "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1473
msgid "memory.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1479
msgid ""
"Note that all fields in this file are hierarchical and the file modified "
"event can be generated due to an event down the hierarchy. For the local "
"events at the cgroup level see memory.events.local."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1484
msgid "low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1485
msgid ""
"The number of times the cgroup is reclaimed due to high memory pressure even "
"though its usage is under the low boundary.  This usually indicates that the "
"low boundary is over-committed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1490
#: ../../../admin-guide/cgroup-v2.rst:1855
msgid "high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1491
msgid ""
"The number of times processes of the cgroup are throttled and routed to "
"perform direct memory reclaim because the high memory boundary was "
"exceeded.  For a cgroup whose memory usage is capped by the high limit "
"rather than global memory pressure, this event's occurrences are expected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1498
#: ../../../admin-guide/cgroup-v2.rst:1859
#: ../../../admin-guide/cgroup-v2.rst:2010
#: ../../../admin-guide/cgroup-v2.rst:2396
#: ../../../admin-guide/cgroup-v2.rst:2813
#: ../../../admin-guide/cgroup-v2.rst:2899
msgid "max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1499
msgid ""
"The number of times the cgroup's memory usage was about to go over the max "
"boundary.  If direct reclaim fails to bring it down, the cgroup goes to OOM "
"state."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1503
msgid "oom"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1504
msgid ""
"The number of time the cgroup's memory usage was reached the limit and "
"allocation was about to fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1507
msgid ""
"This event is not raised if the OOM killer is not considered as an option, e."
"g. for failed high-order allocations or if caller asked to not retry "
"attempts."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1511
msgid "oom_kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1512
msgid ""
"The number of processes belonging to this cgroup killed by any kind of OOM "
"killer."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1515
msgid "oom_group_kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1516
msgid "The number of times a group OOM has occurred."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1518
msgid "memory.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1519
msgid ""
"Similar to memory.events but the fields in the file are local to the cgroup "
"i.e. not hierarchical. The file modified event generated on this file "
"reflects only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1523
msgid "memory.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1524
#: ../../../admin-guide/cgroup-v2.rst:2811
msgid "A read-only flat-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1526
msgid ""
"This breaks down the cgroup's memory footprint into different types of "
"memory, type-specific details, and other information on the state and past "
"events of the memory management system."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1530
#: ../../../admin-guide/cgroup-v2.rst:1797
msgid "All memory amounts are in bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1532
#: ../../../admin-guide/cgroup-v2.rst:1803
msgid ""
"The entries are ordered to be human readable, and new entries can show up in "
"the middle. Don't rely on items remaining in a fixed position; use the keys "
"to look up specific values!"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1536
msgid ""
"If the entry has no per-node counter (or not show in the memory.numa_stat). "
"We use 'npn' (non-per-node) as the tag to indicate that it will not show in "
"the memory.numa_stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1540
msgid "anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1541
msgid ""
"Amount of memory used in anonymous mappings such as brk(), sbrk(), and "
"mmap(MAP_ANONYMOUS). Note that some kernel configurations might account "
"complete larger allocations (e.g., THP) if only some, but not all the memory "
"of such an allocation is mapped anymore."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1547
msgid "file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1548
msgid ""
"Amount of memory used to cache filesystem data, including tmpfs and shared "
"memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1551
msgid "kernel (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1552
msgid ""
"Amount of total kernel memory, including (kernel_stack, pagetables, percpu, "
"vmalloc, slab) in addition to other kernel memory use cases."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1556
msgid "kernel_stack"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1557
msgid "Amount of memory allocated to kernel stacks."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1559
msgid "pagetables"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1560
msgid "Amount of memory allocated for page tables."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1562
msgid "sec_pagetables"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1563
msgid ""
"Amount of memory allocated for secondary page tables, this currently "
"includes KVM mmu allocations on x86 and arm64 and IOMMU page tables."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1567
msgid "percpu (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1568
msgid "Amount of memory used for storing per-cpu kernel data structures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1571
msgid "sock (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1572
msgid "Amount of memory used in network transmission buffers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1574
msgid "vmalloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1575
msgid "Amount of memory used for vmap backed memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1577
msgid "shmem"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1578
msgid ""
"Amount of cached filesystem data that is swap-backed, such as tmpfs, shm "
"segments, shared anonymous mmap()s"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1581
msgid "zswap"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1582
msgid "Amount of memory consumed by the zswap compression backend."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1584
msgid "zswapped"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1585
msgid "Amount of application memory swapped out to zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1587
msgid "file_mapped"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1588
msgid ""
"Amount of cached filesystem data mapped with mmap(). Note that some kernel "
"configurations might account complete larger allocations (e.g., THP) if only "
"some, but not not all the memory of such an allocation is mapped."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1593
msgid "file_dirty"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1594
msgid ""
"Amount of cached filesystem data that was modified but not yet written back "
"to disk"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1597
msgid "file_writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1598
msgid ""
"Amount of cached filesystem data that was modified and is currently being "
"written back to disk"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1601
msgid "swapcached"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1602
msgid ""
"Amount of swap cached in memory. The swapcache is accounted against both "
"memory and swap usage."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1605
msgid "anon_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1606
msgid ""
"Amount of memory used in anonymous mappings backed by transparent hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1609
msgid "file_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1610
msgid "Amount of cached filesystem data backed by transparent hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1613
msgid "shmem_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1614
msgid ""
"Amount of shm, tmpfs, shared anonymous mmap()s backed by transparent "
"hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1617
msgid "inactive_anon, active_anon, inactive_file, active_file, unevictable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1618
msgid ""
"Amount of memory, swap-backed and filesystem-backed, on the internal memory "
"management lists used by the page reclaim algorithm."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1622
msgid ""
"As these represent internal list state (eg. shmem pages are on anon memory "
"management lists), inactive_foo + active_foo may not be equal to the value "
"for the foo counter, since the foo counter is type-based, not list-based."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1627
msgid "slab_reclaimable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1628
msgid "Part of \"slab\" that might be reclaimed, such as dentries and inodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1631
msgid "slab_unreclaimable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1632
msgid "Part of \"slab\" that cannot be reclaimed on memory pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1635
msgid "slab (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1636
msgid "Amount of memory used for storing in-kernel data structures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1639
msgid "workingset_refault_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1640
msgid "Number of refaults of previously evicted anonymous pages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1642
msgid "workingset_refault_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1643
msgid "Number of refaults of previously evicted file pages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1645
msgid "workingset_activate_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1646
msgid "Number of refaulted anonymous pages that were immediately activated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1649
msgid "workingset_activate_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1650
msgid "Number of refaulted file pages that were immediately activated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1652
msgid "workingset_restore_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1653
msgid ""
"Number of restored anonymous pages which have been detected as an active "
"workingset before they got reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1656
msgid "workingset_restore_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1657
msgid ""
"Number of restored file pages which have been detected as an active "
"workingset before they got reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1660
msgid "workingset_nodereclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1661
msgid "Number of times a shadow node has been reclaimed"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1663
msgid "pswpin (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1664
msgid "Number of pages swapped into memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1666
msgid "pswpout (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1667
msgid "Number of pages swapped out of memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1669
msgid "pgscan (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1670
msgid "Amount of scanned pages (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1672
msgid "pgsteal (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1673
msgid "Amount of reclaimed pages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1675
msgid "pgscan_kswapd (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1676
msgid "Amount of scanned pages by kswapd (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1678
msgid "pgscan_direct (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1679
msgid "Amount of scanned pages directly  (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1681
msgid "pgscan_khugepaged (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1682
msgid "Amount of scanned pages by khugepaged  (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1684
msgid "pgscan_proactive (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1685
msgid "Amount of scanned pages proactively (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1687
msgid "pgsteal_kswapd (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1688
msgid "Amount of reclaimed pages by kswapd"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1690
msgid "pgsteal_direct (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1691
msgid "Amount of reclaimed pages directly"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1693
msgid "pgsteal_khugepaged (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1694
msgid "Amount of reclaimed pages by khugepaged"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1696
msgid "pgsteal_proactive (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1697
msgid "Amount of reclaimed pages proactively"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1699
msgid "pgfault (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1700
msgid "Total number of page faults incurred"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1702
msgid "pgmajfault (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1703
msgid "Number of major page faults incurred"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1705
msgid "pgrefill (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1706
msgid "Amount of scanned pages (in an active LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1708
msgid "pgactivate (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1709
msgid "Amount of pages moved to the active LRU list"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1711
msgid "pgdeactivate (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1712
msgid "Amount of pages moved to the inactive LRU list"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1714
msgid "pglazyfree (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1715
msgid "Amount of pages postponed to be freed under memory pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1717
msgid "pglazyfreed (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1718
msgid "Amount of reclaimed lazyfree pages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1720
msgid "swpin_zero"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1721
msgid ""
"Number of pages swapped into memory and filled with zero, where I/O was "
"optimized out because the page content was detected to be zero during "
"swapout."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1725
msgid "swpout_zero"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1726
msgid ""
"Number of zero-filled pages swapped out with I/O skipped due to the content "
"being detected as zero."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1729
msgid "zswpin"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1730
msgid "Number of pages moved in to memory from zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1732
msgid "zswpout"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1733
msgid "Number of pages moved out of memory to zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1735
msgid "zswpwb"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1736
msgid "Number of pages written from zswap to swap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1738
msgid "thp_fault_alloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1739
msgid ""
"Number of transparent hugepages which were allocated to satisfy a page "
"fault. This counter is not present when CONFIG_TRANSPARENT_HUGEPAGE is not "
"set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1743
msgid "thp_collapse_alloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1744
msgid ""
"Number of transparent hugepages which were allocated to allow collapsing an "
"existing range of pages. This counter is not present when "
"CONFIG_TRANSPARENT_HUGEPAGE is not set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1748
msgid "thp_swpout (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1749
msgid ""
"Number of transparent hugepages which are swapout in one piece without "
"splitting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1752
msgid "thp_swpout_fallback (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1753
msgid ""
"Number of transparent hugepages which were split before swapout. Usually "
"because failed to allocate some continuous swap space for the huge page."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1757
msgid "numa_pages_migrated (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1758
msgid "Number of pages migrated by NUMA balancing."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1760
msgid "numa_pte_updates (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1761
msgid ""
"Number of pages whose page table entries are modified by NUMA balancing to "
"produce NUMA hinting faults on access."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1764
msgid "numa_hint_faults (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1765
msgid "Number of NUMA hinting faults."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1767
msgid "pgdemote_kswapd"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1768
msgid "Number of pages demoted by kswapd."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1770
msgid "pgdemote_direct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1771
msgid "Number of pages demoted directly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1773
msgid "pgdemote_khugepaged"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1774
msgid "Number of pages demoted by khugepaged."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1776
msgid "pgdemote_proactive"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1777
msgid "Number of pages demoted by proactively."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1779
msgid "hugetlb"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1780
msgid ""
"Amount of memory used by hugetlb pages. This metric only shows up if hugetlb "
"usage is accounted for in memory.current (i.e. cgroup is mounted with the "
"memory_hugetlb_accounting option)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1784
msgid "memory.numa_stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1785
msgid "A read-only nested-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1787
msgid ""
"This breaks down the cgroup's memory footprint into different types of "
"memory, type-specific details, and other information per node on the state "
"of the memory management system."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1791
msgid ""
"This is useful for providing visibility into the NUMA locality information "
"within an memcg since the pages are allowed to be allocated from any "
"physical node. One of the use case is evaluating application performance by "
"combining this information with the application's CPU allocation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1799
msgid "The output format of memory.numa_stat is::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1807
msgid "The entries can refer to the memory.stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1809
msgid "memory.swap.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1813
msgid ""
"The total amount of swap currently being used by the cgroup and its "
"descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1816
msgid "memory.swap.high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1820
msgid ""
"Swap usage throttle limit.  If a cgroup's swap usage exceeds this limit, all "
"its further allocations will be throttled to allow userspace to implement "
"custom out-of-memory procedures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1824
msgid ""
"This limit marks a point of no return for the cgroup. It is NOT designed to "
"manage the amount of swapping a workload does during regular operation. "
"Compare to memory.swap.max, which prohibits swapping past a set amount, but "
"lets the cgroup continue unimpeded as long as other memory can be reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1830
msgid "Healthy workloads are not expected to reach this limit."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1832
msgid "memory.swap.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1835
msgid ""
"The max swap usage recorded for the cgroup and its descendants since the "
"creation of the cgroup or the most recent reset for that FD."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1842
msgid "memory.swap.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1846
msgid ""
"Swap usage hard limit.  If a cgroup's swap usage reaches this limit, "
"anonymous memory of the cgroup will not be swapped out."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1849
msgid "memory.swap.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1856
msgid ""
"The number of times the cgroup's swap usage was over the high threshold."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1860
msgid ""
"The number of times the cgroup's swap usage was about to go over the max "
"boundary and swap allocation failed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1864
msgid "fail"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1865
msgid ""
"The number of times swap allocation failed either because of running out of "
"swap system-wide or max limit."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1869
msgid ""
"When reduced under the current usage, the existing swap entries are "
"reclaimed gradually and the swap usage may stay higher than the limit for an "
"extended period of time.  This reduces the impact on the workload and memory "
"management."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1874
msgid "memory.zswap.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1878
msgid "The total amount of memory consumed by the zswap compression backend."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1881
msgid "memory.zswap.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1885
msgid ""
"Zswap usage hard limit. If a cgroup's zswap pool reaches this limit, it will "
"refuse to take any more stores before existing entries fault back in or are "
"written out to disk."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1889
msgid "memory.zswap.writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1890
msgid ""
"A read-write single value file. The default value is \"1\". Note that this "
"setting is hierarchical, i.e. the writeback would be implicitly disabled for "
"child cgroups if the upper hierarchy does so."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1895
msgid ""
"When this is set to 0, all swapping attempts to swapping devices are "
"disabled. This included both zswap writebacks, and swapping due to zswap "
"store failures. If the zswap store failures are recurring (for e.g if the "
"pages are incompressible), users can observe reclaim inefficiency after "
"disabling writeback (because the same pages might be rejected again and "
"again)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1902
msgid ""
"Note that this is subtly different from setting memory.swap.max to 0, as it "
"still allows for pages to be written to the zswap pool. This setting has no "
"effect if zswap is disabled, and swapping is allowed unless memory.swap.max "
"is set to 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1907
msgid "memory.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1908
#: ../../../admin-guide/cgroup-v2.rst:1971
#: ../../../admin-guide/cgroup-v2.rst:2147
msgid "A read-only nested-keyed file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1910
msgid ""
"Shows pressure stall information for memory. See :ref:`Documentation/"
"accounting/psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1915
msgid "Usage Guidelines"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1917
msgid ""
"\"memory.high\" is the main mechanism to control memory usage. Over-"
"committing on high limit (sum of high limits > available memory) and letting "
"global memory pressure to distribute memory according to usage is a viable "
"strategy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1922
msgid ""
"Because breach of the high limit doesn't trigger the OOM killer but "
"throttles the offending cgroup, a management agent has ample opportunities "
"to monitor and take appropriate actions such as granting more memory or "
"terminating the workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1927
msgid ""
"Determining whether a cgroup has enough memory is not trivial as memory "
"usage doesn't indicate whether the workload can benefit from more memory.  "
"For example, a workload which writes data received from network to a file "
"can use all available memory but can also operate as performant with a small "
"amount of memory.  A measure of memory pressure - how much the workload is "
"being impacted due to lack of memory - is necessary to determine whether a "
"workload needs more memory; unfortunately, memory pressure monitoring "
"mechanism isn't implemented yet."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1939
msgid "Memory Ownership"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1941
msgid ""
"A memory area is charged to the cgroup which instantiated it and stays "
"charged to the cgroup until the area is released.  Migrating a process to a "
"different cgroup doesn't move the memory usages that it instantiated while "
"in the previous cgroup to the new cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1946
msgid ""
"A memory area may be used by processes belonging to different cgroups. To "
"which cgroup the area will be charged is in-deterministic; however, over "
"time, the memory area is likely to end up in a cgroup which has enough "
"memory allowance to avoid high reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1951
msgid ""
"If a cgroup sweeps a considerable amount of memory which is expected to be "
"accessed repeatedly by other cgroups, it may make sense to use "
"POSIX_FADV_DONTNEED to relinquish the ownership of memory areas belonging to "
"the affected files to ensure correct memory ownership."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1958
msgid "IO"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1960
msgid ""
"The \"io\" controller regulates the distribution of IO resources.  This "
"controller implements both weight based and absolute bandwidth or IOPS limit "
"distribution; however, weight based distribution is available only if cfq-"
"iosched is in use and neither scheme is available for blk-mq devices."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1968
msgid "IO Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1970
#: ../../../admin-guide/cgroup-v2.rst:2274
msgid "io.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1973
msgid ""
"Lines are keyed by $MAJ:$MIN device numbers and not ordered. The following "
"nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1977
msgid "rbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1977
msgid "Bytes read"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1978
msgid "wbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1978
msgid "Bytes written"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1979
msgid "rios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1979
msgid "Number of read IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1980
msgid "wios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1980
msgid "Number of write IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1981
msgid "dbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1981
msgid "Bytes discarded"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1982
msgid "dios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1982
msgid "Number of discard IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1985
#: ../../../admin-guide/cgroup-v2.rst:2101
msgid "An example read output follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1990
msgid "io.cost.qos"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1991
#: ../../../admin-guide/cgroup-v2.rst:2046
msgid "A read-write nested-keyed file which exists only on the root cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1994
msgid ""
"This file configures the Quality of Service of the IO cost model based "
"controller (CONFIG_BLK_CGROUP_IOCOST) which currently implements \"io."
"weight\" proportional control.  Lines are keyed by $MAJ:$MIN device numbers "
"and not ordered.  The line for a given device is populated on the first "
"write for the device on \"io.cost.qos\" or \"io.cost.model\".  The following "
"nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2003
msgid "enable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2003
msgid "Weight-based control enable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2004
#: ../../../admin-guide/cgroup-v2.rst:2058
msgid "ctrl"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2004
#: ../../../admin-guide/cgroup-v2.rst:2058
msgid "\"auto\" or \"user\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2005
msgid "rpct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2005
msgid "Read latency percentile    [0, 100]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2006
msgid "rlat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2006
msgid "Read latency threshold"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2007
msgid "wpct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2007
msgid "Write latency percentile   [0, 100]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2008
msgid "wlat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2008
msgid "Write latency threshold"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2009
msgid "min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2009
msgid "Minimum scaling percentage [1, 10000]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2010
msgid "Maximum scaling percentage [1, 10000]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2013
msgid ""
"The controller is disabled by default and can be enabled by setting "
"\"enable\" to 1.  \"rpct\" and \"wpct\" parameters default to zero and the "
"controller uses internal device saturation state to adjust the overall IO "
"rate between \"min\" and \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2018
msgid ""
"When a better control quality is needed, latency QoS parameters can be "
"configured.  For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2023
msgid ""
"shows that on sdb, the controller is enabled, will consider the device "
"saturated if the 95th percentile of read completion latencies is above 75ms "
"or write 150ms, and adjust the overall IO issue rate between 50% and 150% "
"accordingly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2028
msgid ""
"The lower the saturation point, the better the latency QoS at the cost of "
"aggregate bandwidth.  The narrower the allowed adjustment range between "
"\"min\" and \"max\", the more conformant to the cost model the IO behavior.  "
"Note that the IO issue base rate may be far off from 100% and setting "
"\"min\" and \"max\" blindly can lead to a significant loss of device "
"capacity or control quality.  \"min\" and \"max\" are useful for regulating "
"devices which show wide temporary behavior changes - e.g. a ssd which "
"accepts writes at the line speed for a while and then completely stalls for "
"multiple seconds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2039
msgid ""
"When \"ctrl\" is \"auto\", the parameters are controlled by the kernel and "
"may change automatically.  Setting \"ctrl\" to \"user\" or setting any of "
"the percentile and latency parameters puts it into \"user\" mode and "
"disables the automatic changes.  The automatic mode can be restored by "
"setting \"ctrl\" to \"auto\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2045
msgid "io.cost.model"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2049
msgid ""
"This file configures the cost model of the IO cost model based controller "
"(CONFIG_BLK_CGROUP_IOCOST) which currently implements \"io.weight\" "
"proportional control.  Lines are keyed by $MAJ:$MIN device numbers and not "
"ordered.  The line for a given device is populated on the first write for "
"the device on \"io.cost.qos\" or \"io.cost.model\".  The following nested "
"keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2059
msgid "model"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2059
msgid "The cost model in use - \"linear\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2062
msgid ""
"When \"ctrl\" is \"auto\", the kernel may change all parameters "
"dynamically.  When \"ctrl\" is set to \"user\" or any other parameters are "
"written to, \"ctrl\" become \"user\" and the automatic changes are disabled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2067
msgid ""
"When \"model\" is \"linear\", the following model parameters are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2071
msgid "[r|w]bps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2071
msgid "The maximum sequential IO throughput"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2072
msgid "[r|w]seqiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2072
msgid "The maximum 4k sequential IOs per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2073
msgid "[r|w]randiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2073
msgid "The maximum 4k random IOs per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2076
msgid ""
"From the above, the builtin linear model determines the base costs of a "
"sequential and random IO and the cost coefficient for the IO size.  While "
"simple, this model can cover most common device classes acceptably."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2081
msgid ""
"The IO cost model isn't expected to be accurate in absolute sense and is "
"scaled to the device behavior dynamically."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2084
msgid ""
"If needed, tools/cgroup/iocost_coef_gen.py can be used to generate device-"
"specific coefficients."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2087
msgid "io.weight"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2088
msgid ""
"A read-write flat-keyed file which exists on non-root cgroups. The default "
"is \"default 100\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2091
msgid ""
"The first line is the default weight applied to devices without specific "
"override.  The rest are overrides keyed by $MAJ:$MIN device numbers and not "
"ordered.  The weights are in the range [1, 10000] and specifies the relative "
"amount IO time the cgroup can use in relation to its siblings."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2097
msgid ""
"The default weight can be updated by writing either \"default $WEIGHT\" or "
"simply \"$WEIGHT\".  Overrides can be set by writing \"$MAJ:$MIN $WEIGHT\" "
"and unset by writing \"$MAJ:$MIN default\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2107
msgid "io.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2108
msgid "A read-write nested-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2111
msgid ""
"BPS and IOPS based IO limit.  Lines are keyed by $MAJ:$MIN device numbers "
"and not ordered.  The following nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2116
msgid "rbps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2116
msgid "Max read bytes per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2117
msgid "wbps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2117
msgid "Max write bytes per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2118
msgid "riops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2118
msgid "Max read IO operations per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2119
msgid "wiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2119
msgid "Max write IO operations per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2122
msgid ""
"When writing, any number of nested key-value pairs can be specified in any "
"order.  \"max\" can be specified as the value to remove a specific limit.  "
"If the same key is specified multiple times, the outcome is undefined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2127
msgid ""
"BPS and IOPS are measured in each IO direction and IOs are delayed if limit "
"is reached.  Temporary bursts are allowed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2130
msgid "Setting read limit at 2M BPS and write at 120 IOPS for 8:16::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2134
msgid "Reading returns the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2138
msgid "Write IOPS limit can be removed by writing the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2142
msgid "Reading now returns the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2146
msgid "io.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2149
msgid ""
"Shows pressure stall information for IO. See :ref:`Documentation/accounting/"
"psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2154
msgid "Writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2156
msgid ""
"Page cache is dirtied through buffered writes and shared mmaps and written "
"asynchronously to the backing filesystem by the writeback mechanism.  "
"Writeback sits between the memory and IO domains and regulates the "
"proportion of dirty memory by balancing dirtying and write IOs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2162
msgid ""
"The io controller, in conjunction with the memory controller, implements "
"control of page cache writeback IOs.  The memory controller defines the "
"memory domain that dirty memory ratio is calculated and maintained for and "
"the io controller defines the io domain which writes out dirty pages for the "
"memory domain.  Both system-wide and per-cgroup dirty memory states are "
"examined and the more restrictive of the two is enforced."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2170
msgid ""
"cgroup writeback requires explicit support from the underlying filesystem.  "
"Currently, cgroup writeback is implemented on ext2, ext4, btrfs, f2fs, and "
"xfs.  On other filesystems, all writeback IOs are attributed to the root "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2175
msgid ""
"There are inherent differences in memory and writeback management which "
"affects how cgroup ownership is tracked.  Memory is tracked per page while "
"writeback per inode.  For the purpose of writeback, an inode is assigned to "
"a cgroup and all IO requests to write dirty pages from the inode are "
"attributed to that cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2181
msgid ""
"As cgroup ownership for memory is tracked per page, there can be pages which "
"are associated with different cgroups than the one the inode is associated "
"with.  These are called foreign pages.  The writeback constantly keeps track "
"of foreign pages and, if a particular foreign cgroup becomes the majority "
"over a certain period of time, switches the ownership of the inode to that "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2188
msgid ""
"While this model is enough for most use cases where a given inode is mostly "
"dirtied by a single cgroup even when the main writing cgroup changes over "
"time, use cases where multiple cgroups write to a single inode "
"simultaneously are not supported well.  In such circumstances, a significant "
"portion of IOs are likely to be attributed incorrectly. As memory controller "
"assigns page ownership on the first use and doesn't update it until the page "
"is released, even if writeback strictly follows page ownership, multiple "
"cgroups dirtying overlapping areas wouldn't work as expected.  It's "
"recommended to avoid such usage patterns."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2199
msgid ""
"The sysctl knobs which affect writeback behavior are applied to cgroup "
"writeback as follows."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2202
msgid "vm.dirty_background_ratio, vm.dirty_ratio"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2203
msgid ""
"These ratios apply the same to cgroup writeback with the amount of available "
"memory capped by limits imposed by the memory controller and system-wide "
"clean memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2207
msgid "vm.dirty_background_bytes, vm.dirty_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2208
msgid ""
"For cgroup writeback, this is calculated into ratio against total available "
"memory and applied the same way as vm.dirty[_background]_ratio."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2214
msgid "IO Latency"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2216
msgid ""
"This is a cgroup v2 controller for IO workload protection.  You provide a "
"group with a latency target, and if the average latency exceeds that target "
"the controller will throttle any peers that have a lower latency target than "
"the protected workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2221
msgid ""
"The limits are only applied at the peer level in the hierarchy.  This means "
"that in the diagram below, only groups A, B, and C will influence each "
"other, and groups D and F will influence each other.  Group G will influence "
"nobody::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2232
msgid ""
"So the ideal way to configure this is to set io.latency in groups A, B, and "
"C. Generally you do not want to set a value lower than the latency your "
"device supports.  Experiment to find the value that works best for your "
"workload. Start at higher than the expected latency for your device and "
"watch the avg_lat value in io.stat for your workload group to get an idea of "
"the latency you see during normal operation.  Use the avg_lat value as a "
"basis for your real setting, setting at 10-15% higher than the value in io."
"stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2241
msgid "How IO Latency Throttling Works"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2243
msgid ""
"io.latency is work conserving; so as long as everybody is meeting their "
"latency target the controller doesn't do anything.  Once a group starts "
"missing its target it begins throttling any peer group that has a higher "
"target than itself. This throttling takes 2 forms:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2248
msgid ""
"Queue depth throttling.  This is the number of outstanding IO's a group is "
"allowed to have.  We will clamp down relatively quickly, starting at no "
"limit and going all the way down to 1 IO at a time."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2252
msgid ""
"Artificial delay induction.  There are certain types of IO that cannot be "
"throttled without possibly adversely affecting higher priority groups.  This "
"includes swapping and metadata IO.  These types of IO are allowed to occur "
"normally, however they are \"charged\" to the originating group.  If the "
"originating group is being throttled you will see the use_delay and delay "
"fields in io.stat increase.  The delay value is how many microseconds that "
"are being added to any process that runs in this group.  Because this number "
"can grow quite large if there is a lot of swapping or metadata IO occurring "
"we limit the individual delay events to 1 second at a time."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2262
msgid ""
"Once the victimized group starts meeting its latency target again it will "
"start unthrottling any peer groups that were throttled previously.  If the "
"victimized group simply stops doing IO the global counter will unthrottle "
"appropriately."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2267
msgid "IO Latency Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2269
msgid "io.latency"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2270
msgid "This takes a similar format as the other controllers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2272
msgid "\"MAJOR:MINOR target=<target time in microseconds>\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2275
msgid ""
"If the controller is enabled you will see extra stats in io.stat in addition "
"to the normal ones."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2278
msgid "depth"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2279
msgid "This is the current queue depth for the group."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2281
msgid "avg_lat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2282
msgid ""
"This is an exponential moving average with a decay rate of 1/exp bound by "
"the sampling interval.  The decay rate interval can be calculated by "
"multiplying the win value in io.stat by the corresponding number of samples "
"based on the win value."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2287
msgid "win"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2288
msgid ""
"The sampling window size in milliseconds.  This is the minimum duration of "
"time between evaluation events.  Windows only elapse with IO activity.  Idle "
"periods extend the most recent window."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2293
msgid "IO Priority"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2295
msgid ""
"A single attribute controls the behavior of the I/O priority cgroup policy, "
"namely the io.prio.class attribute. The following values are accepted for "
"that attribute:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2299
#: ../../../admin-guide/cgroup-v2.rst:2323
msgid "no-change"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2300
msgid "Do not modify the I/O priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2302
#: ../../../admin-guide/cgroup-v2.rst:2325
msgid "promote-to-rt"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2303
msgid ""
"For requests that have a non-RT I/O priority class, change it into RT. Also "
"change the priority level of these requests to 4. Do not modify the I/O "
"priority of requests that have priority class RT."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2307
#: ../../../admin-guide/cgroup-v2.rst:2327
msgid "restrict-to-be"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2308
msgid ""
"For requests that do not have an I/O priority class or that have I/O "
"priority class RT, change it into BE. Also change the priority level of "
"these requests to 0. Do not modify the I/O priority class of requests that "
"have priority class IDLE."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2313
#: ../../../admin-guide/cgroup-v2.rst:2329
msgid "idle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2314
msgid ""
"Change the I/O priority class of all requests into IDLE, the lowest I/O "
"priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2317
msgid "none-to-rt"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2318
msgid "Deprecated. Just an alias for promote-to-rt."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2320
msgid ""
"The following numerical values are associated with the I/O priority policies:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2323
#: ../../../admin-guide/cgroup-v2.rst:2335
msgid "0"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2325
#: ../../../admin-guide/cgroup-v2.rst:2337
msgid "1"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2327
#: ../../../admin-guide/cgroup-v2.rst:2339
msgid "2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2329
#: ../../../admin-guide/cgroup-v2.rst:2341
msgid "3"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2332
msgid ""
"The numerical value that corresponds to each I/O priority class is as "
"follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2335
msgid "IOPRIO_CLASS_NONE"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2337
msgid "IOPRIO_CLASS_RT (real-time)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2339
msgid "IOPRIO_CLASS_BE (best effort)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2341
msgid "IOPRIO_CLASS_IDLE"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2344
msgid ""
"The algorithm to set the I/O priority class for a request is as follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2346
msgid ""
"If I/O priority class policy is promote-to-rt, change the request I/O "
"priority class to IOPRIO_CLASS_RT and change the request I/O priority level "
"to 4."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2349
msgid ""
"If I/O priority class policy is not promote-to-rt, translate the I/O "
"priority class policy into a number, then change the request I/O priority "
"class into the maximum of the I/O priority class policy number and the "
"numerical I/O priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2355
msgid "PID"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2357
msgid ""
"The process number controller is used to allow a cgroup to stop any new "
"tasks from being fork()'d or clone()'d after a specified limit is reached."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2361
msgid ""
"The number of tasks in a cgroup can be exhausted in ways which other "
"controllers cannot prevent, thus warranting its own controller.  For "
"example, a fork bomb is likely to exhaust the number of tasks before hitting "
"memory restrictions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2366
msgid ""
"Note that PIDs used in this controller refer to TIDs, process IDs as used by "
"the kernel."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2371
msgid "PID Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2373
msgid "pids.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2377
msgid "Hard limit of number of processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2379
msgid "pids.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2382
msgid "The number of processes currently in the cgroup and its descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2385
msgid "pids.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2388
msgid ""
"The maximum value that the number of processes in the cgroup and its "
"descendants has ever reached."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2391
msgid "pids.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2392
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. Unless "
"specified otherwise, a value change in this file generates a file modified "
"event. The following entries are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2397
msgid ""
"The number of times the cgroup's total number of processes hit the pids.max "
"limit (see also pids_localevents)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2400
msgid "pids.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2401
msgid ""
"Similar to pids.events but the fields in the file are local to the cgroup i."
"e. not hierarchical. The file modified event generated on this file reflects "
"only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2405
msgid ""
"Organisational operations are not blocked by cgroup policies, so it is "
"possible to have pids.current > pids.max.  This can be done by either "
"setting the limit to be smaller than pids.current, or attaching enough "
"processes to the cgroup such that pids.current is larger than pids.max.  "
"However, it is not possible to violate a cgroup PID policy through fork() or "
"clone(). These will return -EAGAIN if the creation of a new process would "
"cause a cgroup policy to be violated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2415
msgid "Cpuset"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2417
msgid ""
"The \"cpuset\" controller provides a mechanism for constraining the CPU and "
"memory node placement of tasks to only the resources specified in the cpuset "
"interface files in a task's current cgroup. This is especially valuable on "
"large NUMA systems where placing jobs on properly sized subsets of the "
"systems with careful processor and memory placement to reduce cross-node "
"memory access and contention can improve overall system performance."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2425
msgid ""
"The \"cpuset\" controller is hierarchical.  That means the controller cannot "
"use CPUs or memory nodes not allowed in its parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2430
msgid "Cpuset Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2432
msgid "cpuset.cpus"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2433
#: ../../../admin-guide/cgroup-v2.rst:2472
#: ../../../admin-guide/cgroup-v2.rst:2522
msgid ""
"A read-write multiple values file which exists on non-root cpuset-enabled "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2436
msgid ""
"It lists the requested CPUs to be used by tasks within this cgroup.  The "
"actual list of CPUs to be granted, however, is subjected to constraints "
"imposed by its parent and can differ from the requested CPUs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2441
msgid "The CPU numbers are comma-separated numbers or ranges. For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2447
msgid ""
"An empty value indicates that the cgroup is using the same setting as the "
"nearest cgroup ancestor with a non-empty \"cpuset.cpus\" or all the "
"available CPUs if none is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2451
msgid ""
"The value of \"cpuset.cpus\" stays constant until the next update and won't "
"be affected by any CPU hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2454
msgid "cpuset.cpus.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2455
#: ../../../admin-guide/cgroup-v2.rst:2506
msgid ""
"A read-only multiple values file which exists on all cpuset-enabled cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2458
msgid ""
"It lists the onlined CPUs that are actually granted to this cgroup by its "
"parent.  These CPUs are allowed to be used by tasks within the current "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2462
msgid ""
"If \"cpuset.cpus\" is empty, the \"cpuset.cpus.effective\" file shows all "
"the CPUs from the parent cgroup that can be available to be used by this "
"cgroup.  Otherwise, it should be a subset of \"cpuset.cpus\" unless none of "
"the CPUs listed in \"cpuset.cpus\" can be granted.  In this case, it will be "
"treated just like an empty \"cpuset.cpus\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2469
msgid "Its value will be affected by CPU hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2471
msgid "cpuset.mems"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2475
msgid ""
"It lists the requested memory nodes to be used by tasks within this cgroup.  "
"The actual list of memory nodes granted, however, is subjected to "
"constraints imposed by its parent and can differ from the requested memory "
"nodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2480
msgid ""
"The memory node numbers are comma-separated numbers or ranges. For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2486
msgid ""
"An empty value indicates that the cgroup is using the same setting as the "
"nearest cgroup ancestor with a non-empty \"cpuset.mems\" or all the "
"available memory nodes if none is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2491
msgid ""
"The value of \"cpuset.mems\" stays constant until the next update and won't "
"be affected by any memory nodes hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2494
msgid ""
"Setting a non-empty value to \"cpuset.mems\" causes memory of tasks within "
"the cgroup to be migrated to the designated nodes if they are currently "
"using memory outside of the designated nodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2498
msgid ""
"There is a cost for this memory migration.  The migration may not be "
"complete and some memory pages may be left behind. So it is recommended that "
"\"cpuset.mems\" should be set properly before spawning new tasks into the "
"cpuset.  Even if there is a need to change \"cpuset.mems\" with active "
"tasks, it shouldn't be done frequently."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2505
msgid "cpuset.mems.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2509
msgid ""
"It lists the onlined memory nodes that are actually granted to this cgroup "
"by its parent. These memory nodes are allowed to be used by tasks within the "
"current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2513
msgid ""
"If \"cpuset.mems\" is empty, it shows all the memory nodes from the parent "
"cgroup that will be available to be used by this cgroup. Otherwise, it "
"should be a subset of \"cpuset.mems\" unless none of the memory nodes listed "
"in \"cpuset.mems\" can be granted.  In this case, it will be treated just "
"like an empty \"cpuset.mems\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2519
msgid "Its value will be affected by memory nodes hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2521
msgid "cpuset.cpus.exclusive"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2525
msgid ""
"It lists all the exclusive CPUs that are allowed to be used to create a new "
"cpuset partition.  Its value is not used unless the cgroup becomes a valid "
"partition root.  See the \"cpuset.cpus.partition\" section below for a "
"description of what a cpuset partition is."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2531
msgid ""
"When the cgroup becomes a partition root, the actual exclusive CPUs that are "
"allocated to that partition are listed in \"cpuset.cpus.exclusive."
"effective\" which may be different from \"cpuset.cpus.exclusive\".  If "
"\"cpuset.cpus.exclusive\" has previously been set, \"cpuset.cpus.exclusive."
"effective\" is always a subset of it."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2538
msgid ""
"Users can manually set it to a value that is different from \"cpuset."
"cpus\".  One constraint in setting it is that the list of CPUs must be "
"exclusive with respect to \"cpuset.cpus.exclusive\" of its sibling.  If "
"\"cpuset.cpus.exclusive\" of a sibling cgroup isn't set, its \"cpuset.cpus\" "
"value, if set, cannot be a subset of it to leave at least one CPU available "
"when the exclusive CPUs are taken away."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2546
msgid ""
"For a parent cgroup, any one of its exclusive CPUs can only be distributed "
"to at most one of its child cgroups.  Having an exclusive CPU appearing in "
"two or more of its child cgroups is not allowed (the exclusivity rule).  A "
"value that violates the exclusivity rule will be rejected with a write error."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2552
msgid ""
"The root cgroup is a partition root and all its available CPUs are in its "
"exclusive CPU set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2555
msgid "cpuset.cpus.exclusive.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2556
msgid ""
"A read-only multiple values file which exists on all non-root cpuset-enabled "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2559
msgid ""
"This file shows the effective set of exclusive CPUs that can be used to "
"create a partition root.  The content of this file will always be a subset "
"of its parent's \"cpuset.cpus.exclusive.effective\" if its parent is not the "
"root cgroup.  It will also be a subset of \"cpuset.cpus.exclusive\" if it is "
"set.  If \"cpuset.cpus.exclusive\" is not set, it is treated to have an "
"implicit value of \"cpuset.cpus\" in the formation of local partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2568
msgid "cpuset.cpus.isolated"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2569
msgid "A read-only and root cgroup only multiple values file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2571
msgid ""
"This file shows the set of all isolated CPUs used in existing isolated "
"partitions. It will be empty if no isolated partition is created."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2575
msgid "cpuset.cpus.partition"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2576
msgid ""
"A read-write single value file which exists on non-root cpuset-enabled "
"cgroups.  This flag is owned by the parent cgroup and is not delegatable."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2580
msgid "It accepts only the following input values when written to."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2583
#: ../../../admin-guide/cgroup-v2.rst:2635
msgid "\"member\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2583
#: ../../../admin-guide/cgroup-v2.rst:2635
msgid "Non-root member of a partition"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2584
#: ../../../admin-guide/cgroup-v2.rst:2636
msgid "\"root\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2584
#: ../../../admin-guide/cgroup-v2.rst:2636
msgid "Partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2585
#: ../../../admin-guide/cgroup-v2.rst:2637
msgid "\"isolated\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2585
#: ../../../admin-guide/cgroup-v2.rst:2637
msgid "Partition root without load balancing"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2588
msgid ""
"A cpuset partition is a collection of cpuset-enabled cgroups with a "
"partition root at the top of the hierarchy and its descendants except those "
"that are separate partition roots themselves and their descendants.  A "
"partition has exclusive access to the set of exclusive CPUs allocated to "
"it.  Other cgroups outside of that partition cannot use any CPUs in that set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2595
msgid ""
"There are two types of partitions - local and remote.  A local partition is "
"one whose parent cgroup is also a valid partition root.  A remote partition "
"is one whose parent cgroup is not a valid partition root itself.  Writing to "
"\"cpuset.cpus.exclusive\" is optional for the creation of a local partition "
"as its \"cpuset.cpus.exclusive\" file will assume an implicit value that is "
"the same as \"cpuset.cpus\" if it is not set.  Writing the proper \"cpuset."
"cpus.exclusive\" values down the cgroup hierarchy before the target "
"partition root is mandatory for the creation of a remote partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2606
msgid ""
"Currently, a remote partition cannot be created under a local partition.  "
"All the ancestors of a remote partition root except the root cgroup cannot "
"be a partition root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2610
msgid ""
"The root cgroup is always a partition root and its state cannot be changed.  "
"All other non-root cgroups start out as \"member\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2613
msgid ""
"When set to \"root\", the current cgroup is the root of a new partition or "
"scheduling domain.  The set of exclusive CPUs is determined by the value of "
"its \"cpuset.cpus.exclusive.effective\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2617
msgid ""
"When set to \"isolated\", the CPUs in that partition will be in an isolated "
"state without any load balancing from the scheduler and excluded from the "
"unbound workqueues.  Tasks placed in such a partition with multiple CPUs "
"should be carefully distributed and bound to each of the individual CPUs for "
"optimal performance."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2623
msgid ""
"A partition root (\"root\" or \"isolated\") can be in one of the two "
"possible states - valid or invalid.  An invalid partition root is in a "
"degraded state where some state information may be retained, but behaves "
"more like a \"member\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2628
msgid ""
"All possible state transitions among \"member\", \"root\" and \"isolated\" "
"are allowed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2631
msgid ""
"On read, the \"cpuset.cpus.partition\" file can show the following values."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2638
msgid "\"root invalid (<reason>)\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2638
msgid "Invalid partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2639
msgid "\"isolated invalid (<reason>)\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2639
msgid "Invalid isolated partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2642
msgid ""
"In the case of an invalid partition root, a descriptive string on why the "
"partition is invalid is included within parentheses."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2645
msgid ""
"For a local partition root to be valid, the following conditions must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2648
msgid "The parent cgroup is a valid partition root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2649
msgid ""
"The \"cpuset.cpus.exclusive.effective\" file cannot be empty, though it may "
"contain offline CPUs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2651
msgid ""
"The \"cpuset.cpus.effective\" cannot be empty unless there is no task "
"associated with this partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2654
msgid ""
"For a remote partition root to be valid, all the above conditions except the "
"first one must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2657
msgid ""
"External events like hotplug or changes to \"cpuset.cpus\" or \"cpuset.cpus."
"exclusive\" can cause a valid partition root to become invalid and vice "
"versa.  Note that a task cannot be moved to a cgroup with empty \"cpuset."
"cpus.effective\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2662
msgid ""
"A valid non-root parent partition may distribute out all its CPUs to its "
"child local partitions when there is no task associated with it."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2666
msgid ""
"Care must be taken to change a valid partition root to \"member\" as all its "
"child local partitions, if present, will become invalid causing disruption "
"to tasks running in those child partitions. These inactivated partitions "
"could be recovered if their parent is switched back to a partition root with "
"a proper value in \"cpuset.cpus\" or \"cpuset.cpus.exclusive\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2673
msgid ""
"Poll and inotify events are triggered whenever the state of \"cpuset.cpus."
"partition\" changes.  That includes changes caused by write to \"cpuset.cpus."
"partition\", cpu hotplug or other changes that modify the validity status of "
"the partition. This will allow user space agents to monitor unexpected "
"changes to \"cpuset.cpus.partition\" without the need to do continuous "
"polling."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2681
msgid ""
"A user can pre-configure certain CPUs to an isolated state with load "
"balancing disabled at boot time with the \"isolcpus\" kernel boot command "
"line option.  If those CPUs are to be put into a partition, they have to be "
"used in an isolated partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2688
msgid "Device controller"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2690
msgid ""
"Device controller manages access to device files. It includes both creation "
"of new device files (using mknod), and access to the existing device files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2694
msgid ""
"Cgroup v2 device controller has no interface files and is implemented on top "
"of cgroup BPF. To control access to device files, a user may create bpf "
"programs of type BPF_PROG_TYPE_CGROUP_DEVICE and attach them to cgroups with "
"BPF_CGROUP_DEVICE flag. On an attempt to access a device file, corresponding "
"BPF programs will be executed, and depending on the return value the attempt "
"will succeed or fail with -EPERM."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2701
msgid ""
"A BPF_PROG_TYPE_CGROUP_DEVICE program takes a pointer to the "
"bpf_cgroup_dev_ctx structure, which describes the device access attempt: "
"access type (mknod/read/write) and device (type, major and minor numbers). "
"If the program returns 0, the attempt fails with -EPERM, otherwise it "
"succeeds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2707
msgid ""
"An example of BPF_PROG_TYPE_CGROUP_DEVICE program may be found in tools/"
"testing/selftests/bpf/progs/dev_cgroup.c in the kernel source tree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2712
msgid "RDMA"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2714
msgid ""
"The \"rdma\" controller regulates the distribution and accounting of RDMA "
"resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2718
msgid "RDMA Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2720
msgid "rdma.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2721
msgid ""
"A readwrite nested-keyed file that exists for all the cgroups except root "
"that describes current configured resource limit for a RDMA/IB device."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2725
msgid ""
"Lines are keyed by device name and are not ordered. Each line contains space "
"separated resource name and its configured limit that can be distributed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2732
msgid "hca_handle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2732
msgid "Maximum number of HCA Handles"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2733
msgid "hca_object"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2733
msgid "Maximum number of HCA Objects"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2736
#: ../../../admin-guide/cgroup-v2.rst:2745
msgid "An example for mlx4 and ocrdma device follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2741
msgid "rdma.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2742
#: ../../../admin-guide/cgroup-v2.rst:2785
msgid ""
"A read-only file that describes current resource usage. It exists for all "
"the cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2751
msgid "DMEM"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2753
msgid ""
"The \"dmem\" controller regulates the distribution and accounting of device "
"memory regions. Because each memory region may have its own page size, which "
"does not have to be equal to the system page size, the units are always "
"bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2758
msgid "DMEM Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2760
msgid "dmem.max, dmem.min, dmem.low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2761
msgid ""
"A readwrite nested-keyed file that exists for all the cgroups except root "
"that describes current configured resource limit for a region."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2765
#: ../../../admin-guide/cgroup-v2.rst:2779
#: ../../../admin-guide/cgroup-v2.rst:2788
msgid "An example for xe follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2770
msgid ""
"The semantics are the same as for the memory cgroup controller, and are "
"calculated in the same way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2773
msgid "dmem.capacity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2774
msgid ""
"A read-only file that describes maximum region capacity. It only exists on "
"the root cgroup. Not all memory can be allocated by cgroups, as the kernel "
"reserves some for internal use."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2784
msgid "dmem.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2794
msgid "HugeTLB"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2796
msgid ""
"The HugeTLB controller allows to limit the HugeTLB usage per control group "
"and enforces the controller limit during page fault."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2800
msgid "HugeTLB Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2802
msgid "hugetlb.<hugepagesize>.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2803
msgid ""
"Show current usage for \"hugepagesize\" hugetlb.  It exists for all the "
"cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2806
msgid "hugetlb.<hugepagesize>.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2807
msgid ""
"Set/show the hard limit of \"hugepagesize\" hugetlb usage. The default value "
"is \"max\".  It exists for all the cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2810
msgid "hugetlb.<hugepagesize>.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2814
msgid "The number of allocation failure due to HugeTLB limit"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2816
msgid "hugetlb.<hugepagesize>.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2817
msgid ""
"Similar to hugetlb.<hugepagesize>.events but the fields in the file are "
"local to the cgroup i.e. not hierarchical. The file modified event generated "
"on this file reflects only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2821
msgid "hugetlb.<hugepagesize>.numa_stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2822
msgid ""
"Similar to memory.numa_stat, it shows the numa information of the hugetlb "
"pages of <hugepagesize> in this cgroup.  Only active in use hugetlb pages "
"are included.  The per-node values are in bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2827
msgid "Misc"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2829
msgid ""
"The Miscellaneous cgroup provides the resource limiting and tracking "
"mechanism for the scalar resources which cannot be abstracted like the other "
"cgroup resources. Controller is enabled by the CONFIG_CGROUP_MISC config "
"option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2834
msgid ""
"A resource can be added to the controller via enum misc_res_type{} in the "
"include/linux/misc_cgroup.h file and the corresponding name via "
"misc_res_name[] in the kernel/cgroup/misc.c file. Provider of the resource "
"must set its capacity prior to using the resource by calling "
"misc_cg_set_capacity()."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2839
msgid ""
"Once a capacity is set then the resource usage can be updated using charge "
"and uncharge APIs. All of the APIs to interact with misc controller are in "
"include/linux/misc_cgroup.h."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2844
msgid "Misc Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2846
msgid ""
"Miscellaneous controller provides 3 interface files. If two misc resources "
"(res_a and res_b) are registered then:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2848
msgid "misc.capacity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2849
msgid ""
"A read-only flat-keyed file shown only in the root cgroup.  It shows "
"miscellaneous scalar resources available on the platform along with their "
"quantities::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2857
msgid "misc.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2858
msgid ""
"A read-only flat-keyed file shown in the all cgroups.  It shows the current "
"usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2865
msgid "misc.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2866
msgid ""
"A read-only flat-keyed file shown in all cgroups.  It shows the historical "
"maximum usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2874
msgid "misc.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2875
msgid ""
"A read-write flat-keyed file shown in the non root cgroups. Allowed maximum "
"usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2882
msgid "Limit can be set by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2886
msgid "Limit can be set to max by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2890
msgid ""
"Limits can be set higher than the capacity value in the misc.capacity file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2893
msgid "misc.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2894
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. The following "
"entries are defined. Unless specified otherwise, a value change in this file "
"generates a file modified event. All fields in this file are hierarchical."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2900
msgid ""
"The number of times the cgroup's resource usage was about to go over the max "
"boundary."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2903
msgid "misc.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2904
msgid ""
"Similar to misc.events but the fields in the file are local to the cgroup i."
"e. not hierarchical. The file modified event generated on this file reflects "
"only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2909
msgid "Migration and Ownership"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2911
msgid ""
"A miscellaneous scalar resource is charged to the cgroup in which it is used "
"first, and stays charged to that cgroup until that resource is freed. "
"Migrating a process to a different cgroup does not move the charge to the "
"destination cgroup where the process has moved."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2917
msgid "Others"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2920
msgid "perf_event"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2922
msgid ""
"perf_event controller, if not mounted on a legacy hierarchy, is "
"automatically enabled on the v2 hierarchy so that perf events can always be "
"filtered by cgroup v2 path.  The controller can still be moved to a legacy "
"hierarchy after v2 hierarchy is populated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2929
msgid "Non-normative information"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2931
msgid ""
"This section contains information that isn't considered to be a part of the "
"stable kernel API and so is subject to change."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2936
msgid "CPU controller root cgroup process behaviour"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2938
msgid ""
"When distributing CPU cycles in the root cgroup each thread in this cgroup "
"is treated as if it was hosted in a separate child cgroup of the root "
"cgroup. This child cgroup weight is dependent on its thread nice level."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2943
msgid ""
"For details of this mapping see sched_prio_to_weight array in kernel/sched/"
"core.c file (values from this array should be scaled appropriately so the "
"neutral - nice 0 - value is 100 instead of 1024)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2949
msgid "IO controller root cgroup process behaviour"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2951
msgid ""
"Root cgroup processes are hosted in an implicit leaf child node. When "
"distributing IO resources this implicit child node is taken into account as "
"if it was a normal child cgroup of the root cgroup with a weight value of "
"200."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2958
msgid "Namespace"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2961
msgid "Basics"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2963
msgid ""
"cgroup namespace provides a mechanism to virtualize the view of the \"/proc/"
"$PID/cgroup\" file and cgroup mounts.  The CLONE_NEWCGROUP clone flag can be "
"used with clone(2) and unshare(2) to create a new cgroup namespace.  The "
"process running inside the cgroup namespace will have its \"/proc/$PID/"
"cgroup\" output restricted to cgroupns root.  The cgroupns root is the "
"cgroup of the process at the time of creation of the cgroup namespace."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2971
msgid ""
"Without cgroup namespace, the \"/proc/$PID/cgroup\" file shows the complete "
"path of the cgroup of a process.  In a container setup where a set of "
"cgroups and namespaces are intended to isolate processes the \"/proc/$PID/"
"cgroup\" file may leak potential system level information to the isolated "
"processes.  For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2980
msgid ""
"The path '/batchjobs/container_id1' can be considered as system-data and "
"undesirable to expose to the isolated processes.  cgroup namespace can be "
"used to restrict visibility of this path.  For example, before creating a "
"cgroup namespace, one would see::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2990
msgid "After unsharing a new namespace, the view changes::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2997
msgid ""
"When some thread from a multi-threaded process unshares its cgroup "
"namespace, the new cgroupns gets applied to the entire process (all the "
"threads).  This is natural for the v2 hierarchy; however, for the legacy "
"hierarchies, this may be unexpected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3002
msgid ""
"A cgroup namespace is alive as long as there are processes inside or mounts "
"pinning it.  When the last usage goes away, the cgroup namespace is "
"destroyed.  The cgroupns root and the actual cgroups remain."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3009
msgid "The Root and Views"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3011
msgid ""
"The 'cgroupns root' for a cgroup namespace is the cgroup in which the "
"process calling unshare(2) is running.  For example, if a process in /"
"batchjobs/container_id1 cgroup calls unshare, cgroup /batchjobs/"
"container_id1 becomes the cgroupns root.  For the init_cgroup_ns, this is "
"the real root ('/') cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3017
msgid ""
"The cgroupns root cgroup does not change even if the namespace creator "
"process later moves to a different cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3028
msgid "Each process gets its namespace-specific view of \"/proc/$PID/cgroup\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3030
msgid ""
"Processes running inside the cgroup namespace will be able to see cgroup "
"paths (in /proc/self/cgroup) only inside their root cgroup. From within an "
"unshared cgroupns::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3040
msgid ""
"From the initial cgroup namespace, the real cgroup path will be visible::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3046
msgid ""
"From a sibling cgroup namespace (that is, a namespace rooted at a different "
"cgroup), the cgroup path relative to its own cgroup namespace root will be "
"shown.  For instance, if PID 7353's cgroup namespace root is at '/batchjobs/"
"container_id2', then it will see::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3054
msgid ""
"Note that the relative path always starts with '/' to indicate that its "
"relative to the cgroup namespace root of the caller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3059
msgid "Migration and setns(2)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3061
msgid ""
"Processes inside a cgroup namespace can move into and out of the namespace "
"root if they have proper access to external cgroups.  For example, from "
"inside a namespace with cgroupns root at /batchjobs/container_id1, and "
"assuming that the global hierarchy is still accessible inside cgroupns::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3073
msgid ""
"Note that this kind of setup is not encouraged.  A task inside cgroup "
"namespace should only be exposed to its own cgroupns hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3076
msgid "setns(2) to another cgroup namespace is allowed when:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3078
msgid "the process has CAP_SYS_ADMIN against its current user namespace"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3079
msgid ""
"the process has CAP_SYS_ADMIN against the target cgroup namespace's userns"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3082
msgid ""
"No implicit cgroup changes happen with attaching to another cgroup "
"namespace.  It is expected that the someone moves the attaching process "
"under the target cgroup namespace root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3088
msgid "Interaction with Other Namespaces"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3090
msgid ""
"Namespace specific cgroup hierarchy can be mounted by a process running "
"inside a non-init cgroup namespace::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3095
msgid ""
"This will mount the unified cgroup hierarchy with cgroupns root as the "
"filesystem root.  The process needs CAP_SYS_ADMIN against its user and mount "
"namespaces."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3099
msgid ""
"The virtualization of /proc/self/cgroup file combined with restricting the "
"view of cgroup hierarchy by namespace-private cgroupfs mount provides a "
"properly isolated cgroup view inside the container."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3105
msgid "Information on Kernel Programming"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3107
msgid ""
"This section contains kernel programming information in the areas where "
"interacting with cgroup is necessary.  cgroup core and controllers are not "
"covered."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3113
msgid "Filesystem Support for Writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3115
msgid ""
"A filesystem can support cgroup writeback by updating "
"address_space_operations->writepages() to annotate bio's using the following "
"two functions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3119
msgid "wbc_init_bio(@wbc, @bio)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3120
msgid ""
"Should be called for each bio carrying writeback data and associates the bio "
"with the inode's owner cgroup and the corresponding request queue.  This "
"must be called after a queue (device) has been associated with the bio and "
"before submission."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3126
msgid "wbc_account_cgroup_owner(@wbc, @folio, @bytes)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3127
msgid ""
"Should be called for each data segment being written out. While this "
"function doesn't care exactly when it's called during the writeback session, "
"it's the easiest and most natural to call it as data segments are added to a "
"bio."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3132
msgid ""
"With writeback bio's annotated, cgroup support can be enabled per "
"super_block by setting SB_I_CGROUPWB in ->s_iflags.  This allows for "
"selective disabling of cgroup writeback support which is helpful when "
"certain filesystem features, e.g. journaled data mode, are incompatible."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3138
msgid ""
"wbc_init_bio() binds the specified bio to its cgroup.  Depending on the "
"configuration, the bio may be executed at a lower priority and if the "
"writeback session is holding shared resources, e.g. a journal entry, may "
"lead to priority inversion.  There is no one easy solution for the problem.  "
"Filesystems can try to work around specific problem cases by skipping "
"wbc_init_bio() and using bio_associate_blkg() directly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3148
msgid "Deprecated v1 Core Features"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3150
msgid "Multiple hierarchies including named ones are not supported."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3152
msgid "All v1 mount options are not supported."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3154
msgid "The \"tasks\" file is removed and \"cgroup.procs\" is not sorted."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3156
msgid "\"cgroup.clone_children\" is removed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3158
msgid ""
"/proc/cgroups is meaningless for v2.  Use \"cgroup.controllers\" or \"cgroup."
"stat\" files at the root instead."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3163
msgid "Issues with v1 and Rationales for v2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3166
msgid "Multiple Hierarchies"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3168
msgid ""
"cgroup v1 allowed an arbitrary number of hierarchies and each hierarchy "
"could host any number of controllers.  While this seemed to provide a high "
"level of flexibility, it wasn't useful in practice."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3172
msgid ""
"For example, as there is only one instance of each controller, utility type "
"controllers such as freezer which can be useful in all hierarchies could "
"only be used in one.  The issue is exacerbated by the fact that controllers "
"couldn't be moved to another hierarchy once hierarchies were populated.  "
"Another issue was that all controllers bound to a hierarchy were forced to "
"have exactly the same view of the hierarchy.  It wasn't possible to vary the "
"granularity depending on the specific controller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3181
msgid ""
"In practice, these issues heavily limited which controllers could be put on "
"the same hierarchy and most configurations resorted to putting each "
"controller on its own hierarchy.  Only closely related ones, such as the cpu "
"and cpuacct controllers, made sense to be put on the same hierarchy.  This "
"often meant that userland ended up managing multiple similar hierarchies "
"repeating the same steps on each hierarchy whenever a hierarchy management "
"operation was necessary."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3189
msgid ""
"Furthermore, support for multiple hierarchies came at a steep cost. It "
"greatly complicated cgroup core implementation but more importantly the "
"support for multiple hierarchies restricted how cgroup could be used in "
"general and what controllers was able to do."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3194
msgid ""
"There was no limit on how many hierarchies there might be, which meant that "
"a thread's cgroup membership couldn't be described in finite length.  The "
"key might contain any number of entries and was unlimited in length, which "
"made it highly awkward to manipulate and led to addition of controllers "
"which existed only to identify membership, which in turn exacerbated the "
"original problem of proliferating number of hierarchies."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3202
msgid ""
"Also, as a controller couldn't have any expectation regarding the topologies "
"of hierarchies other controllers might be on, each controller had to assume "
"that all other controllers were attached to completely orthogonal "
"hierarchies.  This made it impossible, or at least very cumbersome, for "
"controllers to cooperate with each other."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3208
msgid ""
"In most use cases, putting controllers on hierarchies which are completely "
"orthogonal to each other isn't necessary.  What usually is called for is the "
"ability to have differing levels of granularity depending on the specific "
"controller.  In other words, hierarchy may be collapsed from leaf towards "
"root when viewed from specific controllers.  For example, a given "
"configuration might not care about how memory is distributed beyond a "
"certain level while still wanting to control how CPU cycles are distributed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3219
msgid "Thread Granularity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3221
msgid ""
"cgroup v1 allowed threads of a process to belong to different cgroups. This "
"didn't make sense for some controllers and those controllers ended up "
"implementing different ways to ignore such situations but much more "
"importantly it blurred the line between API exposed to individual "
"applications and system management interface."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3227
msgid ""
"Generally, in-process knowledge is available only to the process itself; "
"thus, unlike service-level organization of processes, categorizing threads "
"of a process requires active participation from the application which owns "
"the target process."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3232
msgid ""
"cgroup v1 had an ambiguously defined delegation model which got abused in "
"combination with thread granularity.  cgroups were delegated to individual "
"applications so that they can create and manage their own sub-hierarchies "
"and control resource distributions along them.  This effectively raised "
"cgroup to the status of a syscall-like API exposed to lay programs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3239
msgid ""
"First of all, cgroup has a fundamentally inadequate interface to be exposed "
"this way.  For a process to access its own knobs, it has to extract the path "
"on the target hierarchy from /proc/self/cgroup, construct the path by "
"appending the name of the knob to the path, open and then read and/or write "
"to it.  This is not only extremely clunky and unusual but also inherently "
"racy.  There is no conventional way to define transaction across the "
"required steps and nothing can guarantee that the process would actually be "
"operating on its own sub-hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3248
msgid ""
"cgroup controllers implemented a number of knobs which would never be "
"accepted as public APIs because they were just adding control knobs to "
"system-management pseudo filesystem.  cgroup ended up with interface knobs "
"which were not properly abstracted or refined and directly revealed kernel "
"internal details.  These knobs got exposed to individual applications "
"through the ill-defined delegation mechanism effectively abusing cgroup as a "
"shortcut to implementing public APIs without going through the required "
"scrutiny."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3257
msgid ""
"This was painful for both userland and kernel.  Userland ended up with "
"misbehaving and poorly abstracted interfaces and kernel exposing and locked "
"into constructs inadvertently."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3263
msgid "Competition Between Inner Nodes and Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3265
msgid ""
"cgroup v1 allowed threads to be in any cgroups which created an interesting "
"problem where threads belonging to a parent cgroup and its children cgroups "
"competed for resources.  This was nasty as two different types of entities "
"competed and there was no obvious way to settle it.  Different controllers "
"did different things."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3271
msgid ""
"The cpu controller considered threads and cgroups as equivalents and mapped "
"nice levels to cgroup weights.  This worked for some cases but fell flat "
"when children wanted to be allocated specific ratios of CPU cycles and the "
"number of internal threads fluctuated - the ratios constantly changed as the "
"number of competing entities fluctuated. There also were other issues.  The "
"mapping from nice level to weight wasn't obvious or universal, and there "
"were various other knobs which simply weren't available for threads."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3280
msgid ""
"The io controller implicitly created a hidden leaf node for each cgroup to "
"host the threads.  The hidden leaf had its own copies of all the knobs with "
"``leaf_`` prefixed.  While this allowed equivalent control over internal "
"threads, it was with serious drawbacks.  It always added an extra layer of "
"nesting which wouldn't be necessary otherwise, made the interface messy and "
"significantly complicated the implementation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3288
msgid ""
"The memory controller didn't have a way to control what happened between "
"internal tasks and child cgroups and the behavior was not clearly defined.  "
"There were attempts to add ad-hoc behaviors and knobs to tailor the behavior "
"to specific workloads which would have led to problems extremely difficult "
"to resolve in the long term."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3294
msgid ""
"Multiple controllers struggled with internal tasks and came up with "
"different ways to deal with it; unfortunately, all the approaches were "
"severely flawed and, furthermore, the widely different behaviors made cgroup "
"as a whole highly inconsistent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3299
msgid ""
"This clearly is a problem which needs to be addressed from cgroup core in a "
"uniform way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3304
msgid "Other Interface Issues"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3306
msgid ""
"cgroup v1 grew without oversight and developed a large number of "
"idiosyncrasies and inconsistencies.  One issue on the cgroup core side was "
"how an empty cgroup was notified - a userland helper binary was forked and "
"executed for each event.  The event delivery wasn't recursive or "
"delegatable.  The limitations of the mechanism also led to in-kernel event "
"delivery filtering mechanism further complicating the interface."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3314
msgid ""
"Controller interfaces were problematic too.  An extreme example is "
"controllers completely ignoring hierarchical organization and treating all "
"cgroups as if they were all located directly under the root cgroup.  Some "
"controllers exposed a large amount of inconsistent implementation details to "
"userland."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3320
msgid ""
"There also was no consistency across controllers.  When a new cgroup was "
"created, some controllers defaulted to not imposing extra restrictions while "
"others disallowed any resource usage until explicitly configured.  "
"Configuration knobs for the same type of control used widely differing "
"naming schemes and formats.  Statistics and information knobs were named "
"arbitrarily and used different formats and units even in the same controller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3328
msgid ""
"cgroup v2 establishes common conventions where appropriate and updates "
"controllers so that they expose minimal and consistent interfaces."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3333
msgid "Controller Issues and Remedies"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3338
msgid ""
"The original lower boundary, the soft limit, is defined as a limit that is "
"per default unset.  As a result, the set of cgroups that global reclaim "
"prefers is opt-in, rather than opt-out.  The costs for optimizing these "
"mostly negative lookups are so high that the implementation, despite its "
"enormous size, does not even provide the basic desirable behavior.  First "
"off, the soft limit has no hierarchical meaning.  All configured groups are "
"organized in a global rbtree and treated like equal peers, regardless where "
"they are located in the hierarchy.  This makes subtree delegation "
"impossible.  Second, the soft limit reclaim pass is so aggressive that it "
"not just introduces high allocation latencies into the system, but also "
"impacts system performance due to overreclaim, to the point where the "
"feature becomes self-defeating."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3352
msgid ""
"The memory.low boundary on the other hand is a top-down allocated reserve.  "
"A cgroup enjoys reclaim protection when it's within its effective low, which "
"makes delegation of subtrees possible. It also enjoys having reclaim "
"pressure proportional to its overage when above its effective low."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3358
msgid ""
"The original high boundary, the hard limit, is defined as a strict limit "
"that can not budge, even if the OOM killer has to be called. But this "
"generally goes against the goal of making the most out of the available "
"memory.  The memory consumption of workloads varies during runtime, and that "
"requires users to overcommit.  But doing that with a strict upper limit "
"requires either a fairly accurate prediction of the working set size or "
"adding slack to the limit.  Since working set size estimation is hard and "
"error prone, and getting it wrong results in OOM kills, most users tend to "
"err on the side of a looser limit and end up wasting precious resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3369
msgid ""
"The memory.high boundary on the other hand can be set much more "
"conservatively.  When hit, it throttles allocations by forcing them into "
"direct reclaim to work off the excess, but it never invokes the OOM killer.  "
"As a result, a high boundary that is chosen too aggressively will not "
"terminate the processes, but instead it will lead to gradual performance "
"degradation.  The user can monitor this and make corrections until the "
"minimal memory footprint that still gives acceptable performance is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3378
msgid ""
"In extreme cases, with many concurrent allocations and a complete breakdown "
"of reclaim progress within the group, the high boundary can be exceeded.  "
"But even then it's mostly better to satisfy the allocation from the slack "
"available in other groups or the rest of the system than killing the group.  "
"Otherwise, memory.max is there to limit this type of spillover and "
"ultimately contain buggy or even malicious applications."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3386
msgid ""
"Setting the original memory.limit_in_bytes below the current usage was "
"subject to a race condition, where concurrent charges could cause the limit "
"setting to fail. memory.max on the other hand will first set the limit to "
"prevent new charges, and then reclaim and OOM kill until the new limit is "
"met - or the task writing to memory.max is killed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3392
msgid ""
"The combined memory+swap accounting and limiting is replaced by real control "
"over swap space."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3395
msgid ""
"The main argument for a combined memory+swap facility in the original cgroup "
"design was that global or parental pressure would always be able to swap all "
"anonymous memory of a child group, regardless of the child's own (possibly "
"untrusted) configuration.  However, untrusted groups can sabotage swapping "
"by other means - such as referencing its anonymous memory in a tight loop - "
"and an admin can not assume full swappability when overcommitting untrusted "
"jobs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3403
msgid ""
"For trusted jobs, on the other hand, a combined counter is not an intuitive "
"userspace interface, and it flies in the face of the idea that cgroup "
"controllers should account and limit specific physical resources.  Swap "
"space is a resource like all others in the system, and that's why unified "
"hierarchy allows distributing it separately."
msgstr ""
