# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/cgroup-v2.rst:5
msgid "Control Group v2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:0
msgid "Date"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:7
msgid "October, 2015"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:0
msgid "Author"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:8
msgid "Tejun Heo <tj@kernel.org>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:10
msgid ""
"This is the authoritative documentation on the design, interface and "
"conventions of cgroup v2.  It describes all userland-visible aspects of "
"cgroup including core and specific controller behaviors.  All future changes "
"must be reflected in this document.  Documentation for v1 is available "
"under :ref:`Documentation/admin-guide/cgroup-v1/index.rst <cgroup-v1>`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:102
msgid "Introduction"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:105
msgid "Terminology"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:107
msgid ""
"\"cgroup\" stands for \"control group\" and is never capitalized.  The "
"singular form is used to designate the whole feature and also as a qualifier "
"as in \"cgroup controllers\".  When explicitly referring to multiple "
"individual control groups, the plural form \"cgroups\" is used."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:114
msgid "What is cgroup?"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:116
msgid ""
"cgroup is a mechanism to organize processes hierarchically and distribute "
"system resources along the hierarchy in a controlled and configurable manner."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:120
msgid ""
"cgroup is largely composed of two parts - the core and controllers. cgroup "
"core is primarily responsible for hierarchically organizing processes.  A "
"cgroup controller is usually responsible for distributing a specific type of "
"system resource along the hierarchy although there are utility controllers "
"which serve purposes other than resource distribution."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:127
msgid ""
"cgroups form a tree structure and every process in the system belongs to one "
"and only one cgroup.  All threads of a process belong to the same cgroup.  "
"On creation, all processes are put in the cgroup that the parent process "
"belongs to at the time.  A process can be migrated to another cgroup.  "
"Migration of a process doesn't affect already existing descendant processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:134
msgid ""
"Following certain structural constraints, controllers may be enabled or "
"disabled selectively on a cgroup.  All controller behaviors are hierarchical "
"- if a controller is enabled on a cgroup, it affects all processes which "
"belong to the cgroups consisting the inclusive sub-hierarchy of the cgroup.  "
"When a controller is enabled on a nested cgroup, it always restricts the "
"resource distribution further.  The restrictions set closer to the root in "
"the hierarchy can not be overridden from further away."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:145
msgid "Basic Operations"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:148
msgid "Mounting"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:150
msgid ""
"Unlike v1, cgroup v2 has only single hierarchy.  The cgroup v2 hierarchy can "
"be mounted with the following mount command::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:155
msgid ""
"cgroup2 filesystem has the magic number 0x63677270 (\"cgrp\").  All "
"controllers which support v2 and are not bound to a v1 hierarchy are "
"automatically bound to the v2 hierarchy and show up at the root. Controllers "
"which are not in active use in the v2 hierarchy can be bound to other "
"hierarchies.  This allows mixing v2 hierarchy with the legacy v1 multiple "
"hierarchies in a fully backward compatible way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:162
msgid ""
"A controller can be moved across hierarchies only after the controller is no "
"longer referenced in its current hierarchy.  Because per-cgroup controller "
"states are destroyed asynchronously and controllers may have lingering "
"references, a controller may not show up immediately on the v2 hierarchy "
"after the final umount of the previous hierarchy. Similarly, a controller "
"should be fully disabled to be moved out of the unified hierarchy and it may "
"take some time for the disabled controller to become available for other "
"hierarchies; furthermore, due to inter-controller dependencies, other "
"controllers may need to be disabled too."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:173
msgid ""
"While useful for development and manual configurations, moving controllers "
"dynamically between the v2 and other hierarchies is strongly discouraged for "
"production use.  It is recommended to decide the hierarchies and controller "
"associations before starting using the controllers after system boot."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:179
msgid ""
"During transition to v2, system management software might still automount "
"the v1 cgroup filesystem and so hijack all controllers during boot, before "
"manual intervention is possible. To make testing and experimenting easier, "
"the kernel parameter cgroup_no_v1= allows disabling controllers in v1 and "
"make them always available in v2."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:185
msgid "cgroup v2 currently supports the following mount options."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:187
msgid "nsdelegate"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:188
msgid ""
"Consider cgroup namespaces as delegation boundaries.  This option is system "
"wide and can only be set on mount or modified through remount from the init "
"namespace.  The mount option is ignored on non-init namespace mounts.  "
"Please refer to the Delegation section for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:194
msgid "favordynmods"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:195
msgid ""
"Reduce the latencies of dynamic cgroup modifications such as task migrations "
"and controller on/offs at the cost of making hot path operations such as "
"forks and exits more expensive. The static usage pattern of creating a "
"cgroup, enabling controllers, and then seeding it with CLONE_INTO_CGROUP is "
"not affected by this option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:202
msgid "memory_localevents"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:203
msgid ""
"Only populate memory.events with data for the current cgroup, and not any "
"subtrees. This is legacy behaviour, the default behaviour without this "
"option is to include subtree counts. This option is system wide and can only "
"be set on mount or modified through remount from the init namespace. The "
"mount option is ignored on non-init namespace mounts."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:210
msgid "memory_recursiveprot"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:211
msgid ""
"Recursively apply memory.min and memory.low protection to entire subtrees, "
"without requiring explicit downward propagation into leaf cgroups.  This "
"allows protecting entire subtrees from one another, while retaining free "
"competition within those subtrees.  This should have been the default "
"behavior but is a mount-option to avoid regressing setups relying on the "
"original semantics (e.g. specifying bogusly high 'bypass' protection values "
"at higher tree levels)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:220
msgid "memory_hugetlb_accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:221
msgid ""
"Count HugeTLB memory usage towards the cgroup's overall memory usage for the "
"memory controller (for the purpose of statistics reporting and memory "
"protetion). This is a new behavior that could regress existing setups, so it "
"must be explicitly opted in with this mount option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:227
msgid "A few caveats to keep in mind:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:229
msgid ""
"There is no HugeTLB pool management involved in the memory controller. The "
"pre-allocated pool does not belong to anyone. Specifically, when a new "
"HugeTLB folio is allocated to the pool, it is not accounted for from the "
"perspective of the memory controller. It is only charged to a cgroup when it "
"is actually used (for e.g at page fault time). Host memory overcommit "
"management has to consider this when configuring hard limits. In general, "
"HugeTLB pool management should be done via other mechanisms (such as the "
"HugeTLB controller)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:238
msgid ""
"Failure to charge a HugeTLB folio to the memory controller results in "
"SIGBUS. This could happen even if the HugeTLB pool still has pages available "
"(but the cgroup limit is hit and reclaim attempt fails)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:242
msgid ""
"Charging HugeTLB memory towards the memory controller affects memory "
"protection and reclaim dynamics. Any userspace tuning (of low, min limits "
"for e.g) needs to take this into account."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:245
msgid ""
"HugeTLB pages utilized while this option is not selected will not be tracked "
"by the memory controller (even if cgroup v2 is remounted later on)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:249
msgid "pids_localevents"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:250
msgid ""
"The option restores v1-like behavior of pids.events:max, that is only local "
"(inside cgroup proper) fork failures are counted. Without this option pids."
"events.max represents any pids.max enforcemnt across cgroup's subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:258
msgid "Organizing Processes and Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:261
msgid "Processes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:263
msgid ""
"Initially, only the root cgroup exists to which all processes belong. A "
"child cgroup can be created by creating a sub-directory::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:268
msgid ""
"A given cgroup may have multiple child cgroups forming a tree structure.  "
"Each cgroup has a read-writable interface file \"cgroup.procs\".  When read, "
"it lists the PIDs of all processes which belong to the cgroup one-per-line.  "
"The PIDs are not ordered and the same PID may show up more than once if the "
"process got moved to another cgroup and then back or the PID got recycled "
"while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:275
msgid ""
"A process can be migrated into a cgroup by writing its PID to the target "
"cgroup's \"cgroup.procs\" file.  Only one process can be migrated on a "
"single write(2) call.  If a process is composed of multiple threads, writing "
"the PID of any thread migrates all threads of the process."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:281
msgid ""
"When a process forks a child process, the new process is born into the "
"cgroup that the forking process belongs to at the time of the operation.  "
"After exit, a process stays associated with the cgroup that it belonged to "
"at the time of exit until it's reaped; however, a zombie process does not "
"appear in \"cgroup.procs\" and thus can't be moved to another cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:288
msgid ""
"A cgroup which doesn't have any children or live processes can be destroyed "
"by removing the directory.  Note that a cgroup which doesn't have any "
"children and is associated only with zombie processes is considered empty "
"and can be removed::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:295
msgid ""
"\"/proc/$PID/cgroup\" lists a process's cgroup membership.  If legacy cgroup "
"is in use in the system, this file may contain multiple lines, one for each "
"hierarchy.  The entry for cgroup v2 is always in the format \"0::$PATH\"::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:304
msgid ""
"If the process becomes a zombie and the cgroup it was associated with is "
"removed subsequently, \" (deleted)\" is appended to the path::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:313
msgid "Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:315
msgid ""
"cgroup v2 supports thread granularity for a subset of controllers to support "
"use cases requiring hierarchical resource distribution across the threads of "
"a group of processes.  By default, all threads of a process belong to the "
"same cgroup, which also serves as the resource domain to host resource "
"consumptions which are not specific to a process or thread.  The thread mode "
"allows threads to be spread across a subtree while still maintaining the "
"common resource domain for them."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:323
msgid ""
"Controllers which support thread mode are called threaded controllers. The "
"ones which don't are called domain controllers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:326
msgid ""
"Marking a cgroup threaded makes it join the resource domain of its parent as "
"a threaded cgroup.  The parent may be another threaded cgroup whose resource "
"domain is further up in the hierarchy.  The root of a threaded subtree, that "
"is, the nearest ancestor which is not threaded, is called threaded domain or "
"thread root interchangeably and serves as the resource domain for the entire "
"subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:333
msgid ""
"Inside a threaded subtree, threads of a process can be put in different "
"cgroups and are not subject to the no internal process constraint - threaded "
"controllers can be enabled on non-leaf cgroups whether they have threads in "
"them or not."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:338
msgid ""
"As the threaded domain cgroup hosts all the domain resource consumptions of "
"the subtree, it is considered to have internal resource consumptions whether "
"there are processes in it or not and can't have populated child cgroups "
"which aren't threaded.  Because the root cgroup is not subject to no "
"internal process constraint, it can serve both as a threaded domain and a "
"parent to domain cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:345
msgid ""
"The current operation mode or type of the cgroup is shown in the \"cgroup."
"type\" file which indicates whether the cgroup is a normal domain, a domain "
"which is serving as the domain of a threaded subtree, or a threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:350
msgid ""
"On creation, a cgroup is always a domain cgroup and can be made threaded by "
"writing \"threaded\" to the \"cgroup.type\" file.  The operation is single "
"direction::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:356
msgid ""
"Once threaded, the cgroup can't be made a domain again.  To enable the "
"thread mode, the following conditions must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:359
msgid ""
"As the cgroup will join the parent's resource domain.  The parent must "
"either be a valid (threaded) domain or a threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:362
msgid ""
"When the parent is an unthreaded domain, it must not have any domain "
"controllers enabled or populated domain children.  The root is exempt from "
"this requirement."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:366
msgid ""
"Topology-wise, a cgroup can be in an invalid state.  Please consider the "
"following topology::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:371
msgid ""
"C is created as a domain but isn't connected to a parent which can host "
"child domains.  C can't be used until it is turned into a threaded cgroup.  "
"\"cgroup.type\" file will report \"domain (invalid)\" in these cases.  "
"Operations which fail due to invalid topology use EOPNOTSUPP as the errno."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:377
msgid ""
"A domain cgroup is turned into a threaded domain when one of its child "
"cgroup becomes threaded or threaded controllers are enabled in the \"cgroup."
"subtree_control\" file while there are processes in the cgroup. A threaded "
"domain reverts to a normal domain when the conditions clear."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:383
msgid ""
"When read, \"cgroup.threads\" contains the list of the thread IDs of all "
"threads in the cgroup.  Except that the operations are per-thread instead of "
"per-process, \"cgroup.threads\" has the same format and behaves the same way "
"as \"cgroup.procs\".  While \"cgroup.threads\" can be written to in any "
"cgroup, as it can only move threads inside the same threaded domain, its "
"operations are confined inside each threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:391
msgid ""
"The threaded domain cgroup serves as the resource domain for the whole "
"subtree, and, while the threads can be scattered across the subtree, all the "
"processes are considered to be in the threaded domain cgroup. \"cgroup."
"procs\" in a threaded domain cgroup contains the PIDs of all processes in "
"the subtree and is not readable in the subtree proper. However, \"cgroup."
"procs\" can be written to from anywhere in the subtree to migrate all "
"threads of the matching process to the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:399
msgid ""
"Only threaded controllers can be enabled in a threaded subtree.  When a "
"threaded controller is enabled inside a threaded subtree, it only accounts "
"for and controls resource consumptions associated with the threads in the "
"cgroup and its descendants.  All consumptions which aren't tied to a "
"specific thread belong to the threaded domain cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:405
msgid ""
"Because a threaded subtree is exempt from no internal process constraint, a "
"threaded controller must be able to handle competition between threads in a "
"non-leaf cgroup and its child cgroups.  Each threaded controller defines how "
"such competitions are handled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:410
msgid ""
"Currently, the following controllers are threaded and can be enabled in a "
"threaded cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:419
msgid "[Un]populated Notification"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:421
msgid ""
"Each non-root cgroup has a \"cgroup.events\" file which contains "
"\"populated\" field indicating whether the cgroup's sub-hierarchy has live "
"processes in it.  Its value is 0 if there is no live process in the cgroup "
"and its descendants; otherwise, 1.  poll and [id]notify events are triggered "
"when the value changes.  This can be used, for example, to start a clean-up "
"operation after all processes of a given sub-hierarchy have exited.  The "
"populated state updates and notifications are recursive.  Consider the "
"following sub-hierarchy where the numbers in the parentheses represent the "
"numbers of processes in each cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:435
msgid ""
"A, B and C's \"populated\" fields would be 1 while D's 0.  After the one "
"process in C exits, B and C's \"populated\" fields would flip to \"0\" and "
"file modified events will be generated on the \"cgroup.events\" files of "
"both cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:442
msgid "Controlling Controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:445
msgid "Availability"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:447
msgid ""
"A controller is available in a cgroup when it is supported by the kernel (i."
"e., compiled in, not disabled and not attached to a v1 hierarchy) and listed "
"in the \"cgroup.controllers\" file. Availability means the controller's "
"interface files are exposed in the cgroupâ€™s directory, allowing the "
"distribution of the target resource to be observed or controlled within that "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:454
msgid "Enabling and Disabling"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:456
msgid ""
"Each cgroup has a \"cgroup.controllers\" file which lists all controllers "
"available for the cgroup to enable::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:462
msgid ""
"No controller is enabled by default.  Controllers can be enabled and "
"disabled by writing to the \"cgroup.subtree_control\" file::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:467
msgid ""
"Only controllers which are listed in \"cgroup.controllers\" can be enabled.  "
"When multiple operations are specified as above, either they all succeed or "
"fail.  If multiple operations on the same controller are specified, the last "
"one is effective."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:472
msgid ""
"Enabling a controller in a cgroup indicates that the distribution of the "
"target resource across its immediate children will be controlled. Consider "
"the following sub-hierarchy.  The enabled controllers are listed in "
"parentheses::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:480
msgid ""
"As A has \"cpu\" and \"memory\" enabled, A will control the distribution of "
"CPU cycles and memory to its children, in this case, B.  As B has \"memory\" "
"enabled but not \"CPU\", C and D will compete freely on CPU cycles but their "
"division of memory available to B will be controlled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:485
msgid ""
"As a controller regulates the distribution of the target resource to the "
"cgroup's children, enabling it creates the controller's interface files in "
"the child cgroups.  In the above example, enabling \"cpu\" on B would create "
"the \"cpu.\" prefixed controller interface files in C and D.  Likewise, "
"disabling \"memory\" from B would remove the \"memory.\" prefixed controller "
"interface files from C and D.  This means that the controller interface "
"files - anything which doesn't start with \"cgroup.\" are owned by the "
"parent rather than the cgroup itself."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:496
msgid "Top-down Constraint"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:498
msgid ""
"Resources are distributed top-down and a cgroup can further distribute a "
"resource only if the resource has been distributed to it from the parent.  "
"This means that all non-root \"cgroup.subtree_control\" files can only "
"contain controllers which are enabled in the parent's \"cgroup."
"subtree_control\" file.  A controller can be enabled only if the parent has "
"the controller enabled and a controller can't be disabled if one or more "
"children have it enabled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:508
msgid "No Internal Process Constraint"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:510
msgid ""
"Non-root cgroups can distribute domain resources to their children only when "
"they don't have any processes of their own.  In other words, only domain "
"cgroups which don't contain any processes can have domain controllers "
"enabled in their \"cgroup.subtree_control\" files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:515
msgid ""
"This guarantees that, when a domain controller is looking at the part of the "
"hierarchy which has it enabled, processes are always only on the leaves.  "
"This rules out situations where child cgroups compete against internal "
"processes of the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:520
msgid ""
"The root cgroup is exempt from this restriction.  Root contains processes "
"and anonymous resource consumption which can't be associated with any other "
"cgroups and requires special treatment from most controllers.  How resource "
"consumption in the root cgroup is governed is up to each controller (for "
"more information on this topic please refer to the Non-normative information "
"section in the Controllers chapter)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:528
msgid ""
"Note that the restriction doesn't get in the way if there is no enabled "
"controller in the cgroup's \"cgroup.subtree_control\".  This is important as "
"otherwise it wouldn't be possible to create children of a populated cgroup.  "
"To control resource distribution of a cgroup, the cgroup must create "
"children and transfer all its processes to the children before enabling "
"controllers in its \"cgroup.subtree_control\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:538
msgid "Delegation"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:541
msgid "Model of Delegation"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:543
msgid ""
"A cgroup can be delegated in two ways.  First, to a less privileged user by "
"granting write access of the directory and its \"cgroup.procs\", \"cgroup."
"threads\" and \"cgroup.subtree_control\" files to the user. Second, if the "
"\"nsdelegate\" mount option is set, automatically to a cgroup namespace on "
"namespace creation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:549
msgid ""
"Because the resource control interface files in a given directory control "
"the distribution of the parent's resources, the delegatee shouldn't be "
"allowed to write to them.  For the first method, this is achieved by not "
"granting access to these files.  For the second, files outside the namespace "
"should be hidden from the delegatee by the means of at least mount "
"namespacing, and the kernel rejects writes to all files on a namespace root "
"from inside the cgroup namespace, except for those files listed in \"/sys/"
"kernel/cgroup/delegate\" (including \"cgroup.procs\", \"cgroup.threads\", "
"\"cgroup.subtree_control\", etc.)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:559
msgid ""
"The end results are equivalent for both delegation types.  Once delegated, "
"the user can build sub-hierarchy under the directory, organize processes "
"inside it as it sees fit and further distribute the resources it received "
"from the parent.  The limits and other settings of all resource controllers "
"are hierarchical and regardless of what happens in the delegated sub-"
"hierarchy, nothing can escape the resource restrictions imposed by the "
"parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:567
msgid ""
"Currently, cgroup doesn't impose any restrictions on the number of cgroups "
"in or nesting depth of a delegated sub-hierarchy; however, this may be "
"limited explicitly in the future."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:573
msgid "Delegation Containment"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:575
msgid ""
"A delegated sub-hierarchy is contained in the sense that processes can't be "
"moved into or out of the sub-hierarchy by the delegatee."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:578
msgid ""
"For delegations to a less privileged user, this is achieved by requiring the "
"following conditions for a process with a non-root euid to migrate a target "
"process into a cgroup by writing its PID to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:583
msgid "The writer must have write access to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:585
msgid ""
"The writer must have write access to the \"cgroup.procs\" file of the common "
"ancestor of the source and destination cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:588
msgid ""
"The above two constraints ensure that while a delegatee may migrate "
"processes around freely in the delegated sub-hierarchy it can't pull in from "
"or push out to outside the sub-hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:592
msgid ""
"For an example, let's assume cgroups C0 and C1 have been delegated to user "
"U0 who created C00, C01 under C0 and C10 under C1 as follows and all "
"processes under C0 and C1 belong to U0::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:601
msgid ""
"Let's also say U0 wants to write the PID of a process which is currently in "
"C10 into \"C00/cgroup.procs\".  U0 has write access to the file; however, "
"the common ancestor of the source cgroup C10 and the destination cgroup C00 "
"is above the points of delegation and U0 would not have write access to its "
"\"cgroup.procs\" files and thus the write will be denied with -EACCES."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:608
msgid ""
"For delegations to namespaces, containment is achieved by requiring that "
"both the source and destination cgroups are reachable from the namespace of "
"the process which is attempting the migration.  If either is not reachable, "
"the migration is rejected with -ENOENT."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:615
msgid "Guidelines"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:618
msgid "Organize Once and Control"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:620
msgid ""
"Migrating a process across cgroups is a relatively expensive operation and "
"stateful resources such as memory are not moved together with the process.  "
"This is an explicit design decision as there often exist inherent trade-offs "
"between migration and various hot paths in terms of synchronization cost."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:626
msgid ""
"As such, migrating processes across cgroups frequently as a means to apply "
"different resource restrictions is discouraged.  A workload should be "
"assigned to a cgroup according to the system's logical and resource "
"structure once on start-up.  Dynamic adjustments to resource distribution "
"can be made by changing controller configuration through the interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:635
msgid "Avoid Name Collisions"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:637
msgid ""
"Interface files for a cgroup and its children cgroups occupy the same "
"directory and it is possible to create children cgroups which collide with "
"interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:641
msgid ""
"All cgroup core interface files are prefixed with \"cgroup.\" and each "
"controller's interface files are prefixed with the controller name and a "
"dot.  A controller's name is composed of lower case alphabets and '_'s but "
"never begins with an '_' so it can be used as the prefix character for "
"collision avoidance.  Also, interface file names won't start or end with "
"terms which are often used in categorizing workloads such as job, service, "
"slice, unit or workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:649
msgid ""
"cgroup doesn't do anything to prevent name collisions and it's the user's "
"responsibility to avoid them."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:654
msgid "Resource Distribution Models"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:656
msgid ""
"cgroup controllers implement several resource distribution schemes depending "
"on the resource type and expected use cases.  This section describes major "
"schemes in use along with their expected behaviors."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:662
msgid "Weights"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:664
msgid ""
"A parent's resource is distributed by adding up the weights of all active "
"children and giving each the fraction matching the ratio of its weight "
"against the sum.  As only children which can make use of the resource at the "
"moment participate in the distribution, this is work-conserving.  Due to the "
"dynamic nature, this model is usually used for stateless resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:671
msgid ""
"All weights are in the range [1, 10000] with the default at 100.  This "
"allows symmetric multiplicative biases in both directions at fine enough "
"granularity while staying in the intuitive range."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:675
msgid ""
"As long as the weight is in range, all configuration combinations are valid "
"and there is no reason to reject configuration changes or process migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:679
msgid ""
"\"cpu.weight\" proportionally distributes CPU cycles to active children and "
"is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:686
msgid "Limits"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:688
msgid ""
"A child can only consume up to the configured amount of the resource. Limits "
"can be over-committed - the sum of the limits of children can exceed the "
"amount of resource available to the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:692
msgid ""
"Limits are in the range [0, max] and defaults to \"max\", which is noop."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:694
msgid ""
"As limits can be over-committed, all configuration combinations are valid "
"and there is no reason to reject configuration changes or process migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:698
msgid ""
"\"io.max\" limits the maximum BPS and/or IOPS that a cgroup can consume on "
"an IO device and is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:704
msgid "Protections"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:706
msgid ""
"A cgroup is protected up to the configured amount of the resource as long as "
"the usages of all its ancestors are under their protected levels.  "
"Protections can be hard guarantees or best effort soft boundaries.  "
"Protections can also be over-committed in which case only up to the amount "
"available to the parent is protected among children."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:713
msgid "Protections are in the range [0, max] and defaults to 0, which is noop."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:716
msgid ""
"As protections can be over-committed, all configuration combinations are "
"valid and there is no reason to reject configuration changes or process "
"migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:720
msgid ""
"\"memory.low\" implements best-effort memory protection and is an example of "
"this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:725
msgid "Allocations"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:727
msgid ""
"A cgroup is exclusively allocated a certain amount of a finite resource.  "
"Allocations can't be over-committed - the sum of the allocations of children "
"can not exceed the amount of resource available to the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:732
msgid ""
"Allocations are in the range [0, max] and defaults to 0, which is no "
"resource."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:735
msgid ""
"As allocations can't be over-committed, some configuration combinations are "
"invalid and should be rejected.  Also, if the resource is mandatory for "
"execution of processes, process migrations may be rejected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:740
msgid ""
"\"cpu.rt.max\" hard-allocates realtime slices and is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:745
msgid "Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:748
msgid "Format"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:750
msgid ""
"All interface files should be in one of the following formats whenever "
"possible::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:777
msgid ""
"For a writable file, the format for writing should generally match reading; "
"however, controllers may allow omitting later fields or implement restricted "
"shortcuts for most common use cases."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:781
msgid ""
"For both flat and nested keyed files, only the values for a single key can "
"be written at a time.  For nested keyed files, the sub key pairs may be "
"specified in any order and not all pairs have to be specified."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:787
msgid "Conventions"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:789
msgid "Settings for a single feature should be contained in a single file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:791
msgid ""
"The root cgroup should be exempt from resource control and thus shouldn't "
"have resource control interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:794
msgid ""
"The default time unit is microseconds.  If a different unit is ever used, an "
"explicit unit suffix must be present."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:797
msgid ""
"A parts-per quantity should use a percentage decimal with at least two digit "
"fractional part - e.g. 13.40."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:800
msgid ""
"If a controller implements weight based resource distribution, its interface "
"file should be named \"weight\" and have the range [1, 10000] with 100 as "
"the default.  The values are chosen to allow enough and symmetric bias in "
"both directions while keeping it intuitive (the default is 100%)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:806
msgid ""
"If a controller implements an absolute resource guarantee and/or limit, the "
"interface files should be named \"min\" and \"max\" respectively.  If a "
"controller implements best effort resource guarantee and/or limit, the "
"interface files should be named \"low\" and \"high\" respectively."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:812
msgid ""
"In the above four control files, the special token \"max\" should be used to "
"represent upward infinity for both reading and writing."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:815
msgid ""
"If a setting has a configurable default value and keyed specific overrides, "
"the default entry should be keyed with \"default\" and appear as the first "
"entry in the file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:819
msgid ""
"The default value can be updated by writing either \"default $VAL\" or "
"\"$VAL\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:822
msgid ""
"When writing to update a specific override, \"default\" can be used as the "
"value to indicate removal of the override.  Override entries with "
"\"default\" as the value must not appear when read."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:826
msgid ""
"For example, a setting which is keyed by major:minor device numbers with "
"integer values may look like the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:833
msgid "The default value can be updated by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:837
msgid "or::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:841
msgid "An override can be set by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:845
msgid "and cleared by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:852
msgid ""
"For events which are not very high frequency, an interface file \"events\" "
"should be created which lists event key value pairs. Whenever a notifiable "
"event happens, file modified event should be generated on the file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:859
msgid "Core Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:861
msgid "All cgroup core files are prefixed with \"cgroup.\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:863
msgid "cgroup.type"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:864
#: ../../../admin-guide/cgroup-v2.rst:1444
#: ../../../admin-guide/cgroup-v2.rst:1835
msgid "A read-write single value file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:867
msgid ""
"When read, it indicates the current type of the cgroup, which can be one of "
"the following values."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:870
msgid "\"domain\" : A normal valid domain cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:872
msgid ""
"\"domain threaded\" : A threaded domain cgroup which is serving as the root "
"of a threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:875
msgid ""
"\"domain invalid\" : A cgroup which is in an invalid state. It can't be "
"populated or have controllers enabled.  It may be allowed to become a "
"threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:879
msgid ""
"\"threaded\" : A threaded cgroup which is a member of a threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:882
msgid ""
"A cgroup can be turned into a threaded cgroup by writing \"threaded\" to "
"this file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:885
msgid "cgroup.procs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:886
#: ../../../admin-guide/cgroup-v2.rst:912
msgid ""
"A read-write new-line separated values file which exists on all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:889
msgid ""
"When read, it lists the PIDs of all processes which belong to the cgroup one-"
"per-line.  The PIDs are not ordered and the same PID may show up more than "
"once if the process got moved to another cgroup and then back or the PID got "
"recycled while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:895
msgid ""
"A PID can be written to migrate the process associated with the PID to the "
"cgroup.  The writer should match all of the following conditions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:899
msgid "It must have write access to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:901
#: ../../../admin-guide/cgroup-v2.rst:930
msgid ""
"It must have write access to the \"cgroup.procs\" file of the common "
"ancestor of the source and destination cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:904
#: ../../../admin-guide/cgroup-v2.rst:933
msgid ""
"When delegating a sub-hierarchy, write access to this file should be granted "
"along with the containing directory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:907
msgid ""
"In a threaded cgroup, reading this file fails with EOPNOTSUPP as all the "
"processes belong to the thread root.  Writing is supported and moves every "
"thread of the process to the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:911
msgid "cgroup.threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:915
msgid ""
"When read, it lists the TIDs of all threads which belong to the cgroup one-"
"per-line.  The TIDs are not ordered and the same TID may show up more than "
"once if the thread got moved to another cgroup and then back or the TID got "
"recycled while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:921
msgid ""
"A TID can be written to migrate the thread associated with the TID to the "
"cgroup.  The writer should match all of the following conditions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:925
msgid "It must have write access to the \"cgroup.threads\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:927
msgid ""
"The cgroup that the thread is currently in must be in the same resource "
"domain as the destination cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:936
msgid "cgroup.controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:937
msgid "A read-only space separated values file which exists on all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:940
msgid ""
"It shows space separated list of all controllers available to the cgroup.  "
"The controllers are not ordered."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:943
msgid "cgroup.subtree_control"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:944
msgid ""
"A read-write space separated values file which exists on all cgroups.  "
"Starts out empty."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:947
msgid ""
"When read, it shows space separated list of the controllers which are "
"enabled to control resource distribution from the cgroup to its children."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:951
msgid ""
"Space separated list of controllers prefixed with '+' or '-' can be written "
"to enable or disable controllers.  A controller name prefixed with '+' "
"enables the controller and '-' disables.  If a controller appears more than "
"once on the list, the last one is effective.  When multiple enable and "
"disable operations are specified, either all succeed or all fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:958
msgid "cgroup.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:959
#: ../../../admin-guide/cgroup-v2.rst:1472
#: ../../../admin-guide/cgroup-v2.rst:1852
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. The following "
"entries are defined.  Unless specified otherwise, a value change in this "
"file generates a file modified event."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:964
msgid "populated"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:965
msgid ""
"1 if the cgroup or its descendants contains any live processes; otherwise, 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:967
msgid "frozen"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:968
msgid "1 if the cgroup is frozen; otherwise, 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:970
msgid "cgroup.max.descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:971
#: ../../../admin-guide/cgroup-v2.rst:978
msgid "A read-write single value files.  The default is \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:973
msgid ""
"Maximum allowed number of descent cgroups. If the actual number of "
"descendants is equal or larger, an attempt to create a new cgroup in the "
"hierarchy will fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:977
msgid "cgroup.max.depth"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:980
msgid ""
"Maximum allowed descent depth below the current cgroup. If the actual "
"descent depth is equal or larger, an attempt to create a new child cgroup "
"will fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:984
msgid "cgroup.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:985
msgid "A read-only flat-keyed file with the following entries:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:987
msgid "nr_descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:988
msgid "Total number of visible descendant cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:990
msgid "nr_dying_descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:991
msgid ""
"Total number of dying descendant cgroups. A cgroup becomes dying after being "
"deleted by a user. The cgroup will remain in dying state for some time "
"undefined time (which can depend on system load) before being completely "
"destroyed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:996
msgid ""
"A process can't enter a dying cgroup under any circumstances, a dying cgroup "
"can't revive."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:999
msgid ""
"A dying cgroup can consume system resources not exceeding limits, which were "
"active at the moment of cgroup deletion."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1002
msgid "nr_subsys_<cgroup_subsys>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1003
msgid ""
"Total number of live cgroup subsystems (e.g memory cgroup) at and beneath "
"the current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1006
msgid "nr_dying_subsys_<cgroup_subsys>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1007
msgid ""
"Total number of dying cgroup subsystems (e.g. memory cgroup) at and beneath "
"the current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1010
msgid "cgroup.stat.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1011
msgid ""
"A read-only flat-keyed file which exists in non-root cgroups. The following "
"entry is defined:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1014
msgid "frozen_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1015
msgid ""
"Cumulative time that this cgroup has spent between freezing and thawing, "
"regardless of whether by self or ancestor groups. NB: (not) reaching "
"\"frozen\" state is not accounted here."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1019
msgid ""
"Using the following ASCII representation of a cgroup's freezer state, ::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1026
msgid "the duration being measured is the span between a and c."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1028
msgid "cgroup.freeze"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1029
msgid ""
"A read-write single value file which exists on non-root cgroups. Allowed "
"values are \"0\" and \"1\". The default is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1032
msgid ""
"Writing \"1\" to the file causes freezing of the cgroup and all descendant "
"cgroups. This means that all belonging processes will be stopped and will "
"not run until the cgroup will be explicitly unfrozen. Freezing of the cgroup "
"may take some time; when this action is completed, the \"frozen\" value in "
"the cgroup.events control file will be updated to \"1\" and the "
"corresponding notification will be issued."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1040
msgid ""
"A cgroup can be frozen either by its own settings, or by settings of any "
"ancestor cgroups. If any of ancestor cgroups is frozen, the cgroup will "
"remain frozen."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1044
msgid ""
"Processes in the frozen cgroup can be killed by a fatal signal. They also "
"can enter and leave a frozen cgroup: either by an explicit move by a user, "
"or if freezing of the cgroup races with fork(). If a process is moved to a "
"frozen cgroup, it stops. If a process is moved out of a frozen cgroup, it "
"becomes running."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1050
msgid ""
"Frozen status of a cgroup doesn't affect any cgroup tree operations: it's "
"possible to delete a frozen (and empty) cgroup, as well as create new sub-"
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1054
msgid "cgroup.kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1055
msgid ""
"A write-only single value file which exists in non-root cgroups. The only "
"allowed value is \"1\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1058
msgid ""
"Writing \"1\" to the file causes the cgroup and all descendant cgroups to be "
"killed. This means that all processes located in the affected cgroup tree "
"will be killed via SIGKILL."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1062
msgid ""
"Killing a cgroup tree will deal with concurrent forks appropriately and is "
"protected against migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1065
msgid ""
"In a threaded cgroup, writing this file fails with EOPNOTSUPP as killing "
"cgroups is a process directed operation, i.e. it affects the whole thread-"
"group."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1069
msgid "cgroup.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1070
msgid ""
"A read-write single value file that allowed values are \"0\" and \"1\". The "
"default is \"1\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1073
msgid ""
"Writing \"0\" to the file will disable the cgroup PSI accounting. Writing "
"\"1\" to the file will re-enable the cgroup PSI accounting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1076
msgid ""
"This control attribute is not hierarchical, so disable or enable PSI "
"accounting in a cgroup does not affect PSI accounting in descendants and "
"doesn't need pass enablement via ancestors from root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1080
msgid ""
"The reason this control attribute exists is that PSI accounts stalls for "
"each cgroup separately and aggregates it at each level of the hierarchy. "
"This may cause non-negligible overhead for some workloads when under deep "
"level of the hierarchy, in which case this control attribute can be used to "
"disable PSI accounting in the non-leaf cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1086
msgid "irq.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1087
#: ../../../admin-guide/cgroup-v2.rst:1219
msgid "A read-write nested-keyed file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1089
msgid ""
"Shows pressure stall information for IRQ/SOFTIRQ. See :ref:`Documentation/"
"accounting/psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1093
msgid "Controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1098
msgid "CPU"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1100
msgid ""
"The \"cpu\" controllers regulates distribution of CPU cycles.  This "
"controller implements weight and absolute bandwidth limit models for normal "
"scheduling policy and absolute bandwidth allocation model for realtime "
"scheduling policy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1105
msgid ""
"In all the above models, cycles distribution is defined only on a temporal "
"base and it does not account for the frequency at which tasks are executed. "
"The (optional) utilization clamping support allows to hint the schedutil "
"cpufreq governor about the minimum desired frequency which should always be "
"provided by a CPU, as well as the maximum desired frequency, which should "
"not be exceeded by a CPU."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1112
msgid ""
"WARNING: cgroup2 cpu controller doesn't yet support the (bandwidth) control "
"of realtime processes. For a kernel built with the CONFIG_RT_GROUP_SCHED "
"option enabled for group scheduling of realtime processes, the cpu "
"controller can only be enabled when all RT processes are in the root cgroup. "
"Be aware that system management software may already have placed RT "
"processes into non-root cgroups during the system boot process, and these "
"processes may need to be moved to the root cgroup before the cpu controller "
"can be enabled with a CONFIG_RT_GROUP_SCHED enabled kernel."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1121
msgid ""
"With CONFIG_RT_GROUP_SCHED disabled, this limitation does not apply and some "
"of the interface files either affect realtime processes or account for them. "
"See the following section for details. Only the cpu controller is affected "
"by CONFIG_RT_GROUP_SCHED. Other controllers can be used for the resource "
"control of realtime processes irrespective of CONFIG_RT_GROUP_SCHED."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1129
msgid "CPU Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1131
msgid ""
"The interaction of a process with the cpu controller depends on its "
"scheduling policy and the underlying scheduler. From the point of view of "
"the cpu controller, processes can be categorized as follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1135
msgid "Processes under the fair-class scheduler"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1136
msgid "Processes under a BPF scheduler with the ``cgroup_set_weight`` callback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1137
msgid ""
"Everything else: ``SCHED_{FIFO,RR,DEADLINE}`` and processes under a BPF "
"scheduler without the ``cgroup_set_weight`` callback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1140
msgid ""
"For details on when a process is under the fair-class scheduler or a BPF "
"scheduler, check out :ref:`Documentation/scheduler/sched-ext.rst <sched-"
"ext>`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1143
msgid ""
"For each of the following interface files, the above categories will be "
"referred to. All time durations are in microseconds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1146
msgid "cpu.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1147
msgid ""
"A read-only flat-keyed file. This file exists whether the controller is "
"enabled or not."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1150
msgid ""
"It always reports the following three stats, which account for all the "
"processes in the cgroup:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1153
msgid "usage_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1154
msgid "user_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1155
msgid "system_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1157
msgid ""
"and the following five when the controller is enabled, which account for "
"only the processes under the fair-class scheduler:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1160
msgid "nr_periods"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1161
msgid "nr_throttled"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1162
msgid "throttled_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1163
msgid "nr_bursts"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1164
msgid "burst_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1166
msgid "cpu.weight"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1167
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"100\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1170
msgid ""
"For non idle groups (cpu.idle = 0), the weight is in the range [1, 10000]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1173
msgid ""
"If the cgroup has been configured to be SCHED_IDLE (cpu.idle = 1), then the "
"weight will show as a 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1176
#: ../../../admin-guide/cgroup-v2.rst:1192
msgid ""
"This file affects only processes under the fair-class scheduler and a BPF "
"scheduler with the ``cgroup_set_weight`` callback depending on what the "
"callback actually does."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1180
msgid "cpu.weight.nice"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1181
#: ../../../admin-guide/cgroup-v2.rst:1211
#: ../../../admin-guide/cgroup-v2.rst:1308
#: ../../../admin-guide/cgroup-v2.rst:1331
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1184
msgid "The nice value is in the range [-20, 19]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1186
msgid ""
"This interface file is an alternative interface for \"cpu.weight\" and "
"allows reading and setting weight using the same values used by nice(2).  "
"Because the range is smaller and granularity is coarser for the nice values, "
"the read value is the closest approximation of the current weight."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1196
msgid "cpu.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1197
msgid ""
"A read-write two value file which exists on non-root cgroups. The default is "
"\"max 100000\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1200
msgid "The maximum bandwidth limit.  It's in the following format::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1204
msgid ""
"which indicates that the group may consume up to $MAX in each $PERIOD "
"duration.  \"max\" for $MAX indicates no limit.  If only one number is "
"written, $MAX is updated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1208
#: ../../../admin-guide/cgroup-v2.rst:1216
#: ../../../admin-guide/cgroup-v2.rst:1268
msgid "This file affects only processes under the fair-class scheduler."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1210
msgid "cpu.max.burst"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1214
msgid "The burst in the range [0, $MAX]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1218
msgid "cpu.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1221
msgid ""
"Shows pressure stall information for CPU. See :ref:`Documentation/accounting/"
"psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1224
msgid "This file accounts for all the processes in the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1226
msgid "cpu.uclamp.min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1227
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is \"0\", i.e. no utilization boosting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1230
msgid ""
"The requested minimum utilization (protection) as a percentage rational "
"number, e.g. 12.34 for 12.34%."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1233
msgid ""
"This interface allows reading and setting minimum utilization clamp values "
"similar to the sched_setattr(2). This minimum utilization value is used to "
"clamp the task specific minimum utilization clamp, including those of "
"realtime processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1238
msgid ""
"The requested minimum utilization (protection) is always capped by the "
"current value for the maximum utilization (limit), i.e. `cpu.uclamp.max`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1242
#: ../../../admin-guide/cgroup-v2.rst:1256
msgid "This file affects all the processes in the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1244
msgid "cpu.uclamp.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1245
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is \"max\". i.e. no utilization capping"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1248
msgid ""
"The requested maximum utilization (limit) as a percentage rational number, e."
"g. 98.76 for 98.76%."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1251
msgid ""
"This interface allows reading and setting maximum utilization clamp values "
"similar to the sched_setattr(2). This maximum utilization value is used to "
"clamp the task specific maximum utilization clamp, including those of "
"realtime processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1258
msgid "cpu.idle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1259
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1262
msgid ""
"This is the cgroup analog of the per-task SCHED_IDLE sched policy. Setting "
"this value to a 1 will make the scheduling policy of the cgroup SCHED_IDLE. "
"The threads inside the cgroup will retain their own relative priorities, but "
"the cgroup itself will be treated as very low priority relative to its peers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1271
#: ../../../admin-guide/cgroup-v2.rst:3359
msgid "Memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1273
msgid ""
"The \"memory\" controller regulates distribution of memory.  Memory is "
"stateful and implements both limit and protection models.  Due to the "
"intertwining between memory usage and reclaim pressure and the stateful "
"nature of memory, the distribution model is relatively complex."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1279
msgid ""
"While not completely water-tight, all major memory usages by a given cgroup "
"are tracked so that the total memory consumption can be accounted and "
"controlled to a reasonable extent.  Currently, the following types of memory "
"usages are tracked."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1284
msgid "Userland memory - page cache and anonymous memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1286
msgid "Kernel data structures such as dentries and inodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1288
msgid "TCP socket buffers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1290
msgid "The above list may expand in the future for better coverage."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1294
msgid "Memory Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1296
msgid ""
"All memory amounts are in bytes.  If a value which is not aligned to "
"PAGE_SIZE is written, the value may be rounded up to the closest PAGE_SIZE "
"multiple when read back."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1300
msgid "memory.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1301
#: ../../../admin-guide/cgroup-v2.rst:1812
#: ../../../admin-guide/cgroup-v2.rst:1877
#: ../../../admin-guide/cgroup-v2.rst:2403
#: ../../../admin-guide/cgroup-v2.rst:2409
msgid "A read-only single value file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1304
msgid ""
"The total amount of memory currently being used by the cgroup and its "
"descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1307
msgid "memory.min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1311
msgid ""
"Hard memory protection.  If the memory usage of a cgroup is within its "
"effective min boundary, the cgroup's memory won't be reclaimed under any "
"conditions. If there is no unprotected reclaimable memory available, OOM "
"killer is invoked. Above the effective min boundary (or effective low "
"boundary if it is higher), pages are reclaimed proportionally to the "
"overage, reducing reclaim pressure for smaller overages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1320
msgid ""
"Effective min boundary is limited by memory.min values of ancestor cgroups. "
"If there is memory.min overcommitment (child cgroup or cgroups are requiring "
"more protected memory than parent will allow), then each child cgroup will "
"get the part of parent's protection proportional to its actual memory usage "
"below memory.min."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1327
msgid ""
"Putting more memory than generally available under this protection is "
"discouraged and may lead to constant OOMs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1330
msgid "memory.low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1334
msgid ""
"Best-effort memory protection.  If the memory usage of a cgroup is within "
"its effective low boundary, the cgroup's memory won't be reclaimed unless "
"there is no reclaimable memory available in unprotected cgroups. Above the "
"effective low boundary (or effective min boundary if it is higher), pages "
"are reclaimed proportionally to the overage, reducing reclaim pressure for "
"smaller overages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1343
msgid ""
"Effective low boundary is limited by memory.low values of ancestor cgroups. "
"If there is memory.low overcommitment (child cgroup or cgroups are requiring "
"more protected memory than parent will allow), then each child cgroup will "
"get the part of parent's protection proportional to its actual memory usage "
"below memory.low."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1350
msgid ""
"Putting more memory than generally available under this protection is "
"discouraged."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1353
msgid "memory.high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1354
#: ../../../admin-guide/cgroup-v2.rst:1380
#: ../../../admin-guide/cgroup-v2.rst:1819
#: ../../../admin-guide/cgroup-v2.rst:1845
#: ../../../admin-guide/cgroup-v2.rst:1884
#: ../../../admin-guide/cgroup-v2.rst:2397
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1357
msgid ""
"Memory usage throttle limit.  If a cgroup's usage goes over the high "
"boundary, the processes of the cgroup are throttled and put under heavy "
"reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1361
msgid ""
"Going over the high limit never invokes the OOM killer and under extreme "
"conditions the limit may be breached. The high limit should be used in "
"scenarios where an external process monitors the limited cgroup to alleviate "
"heavy reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1367
msgid ""
"If memory.high is opened with O_NONBLOCK then the synchronous reclaim is "
"bypassed. This is useful for admin processes that need to dynamically adjust "
"the job's memory limits without expending their own CPU resources on memory "
"reclamation. The job will trigger the reclaim and/or get throttled on its "
"next charge request."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1374
#: ../../../admin-guide/cgroup-v2.rst:1403
msgid ""
"Please note that with O_NONBLOCK, there is a chance that the target memory "
"cgroup may take indefinite amount of time to reduce usage below the limit "
"due to delayed charge request or busy-hitting its memory to slow down "
"reclaim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1379
msgid "memory.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1383
msgid ""
"Memory usage hard limit.  This is the main mechanism to limit memory usage "
"of a cgroup.  If a cgroup's memory usage reaches this limit and can't be "
"reduced, the OOM killer is invoked in the cgroup. Under certain "
"circumstances, the usage may go over the limit temporarily."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1389
msgid ""
"In default configuration regular 0-order allocations always succeed unless "
"OOM killer chooses current task as a victim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1392
msgid ""
"Some kinds of allocations don't invoke the OOM killer. Caller could retry "
"them differently, return into userspace as -ENOMEM or silently ignore in "
"cases like disk readahead."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1396
msgid ""
"If memory.max is opened with O_NONBLOCK, then the synchronous reclaim and "
"oom-kill are bypassed. This is useful for admin processes that need to "
"dynamically adjust the job's memory limits without expending their own CPU "
"resources on memory reclamation. The job will trigger the reclaim and/or oom-"
"kill on its next charge request."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1408
msgid "memory.reclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1409
msgid "A write-only nested-keyed file which exists for all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1411
msgid ""
"This is a simple interface to trigger memory reclaim in the target cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1414
msgid "Example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1418
msgid ""
"Please note that the kernel can over or under reclaim from the target "
"cgroup. If less bytes are reclaimed than the specified amount, -EAGAIN is "
"returned."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1422
msgid ""
"Please note that the proactive reclaim (triggered by this interface) is not "
"meant to indicate memory pressure on the memory cgroup. Therefore socket "
"memory balancing triggered by the memory reclaim normally is not exercised "
"in this case. This means that the networking layer will not adapt based on "
"reclaim induced by memory.reclaim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1429
#: ../../../admin-guide/cgroup-v2.rst:2752
msgid "The following nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1432
msgid "swappiness"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1432
msgid "Swappiness value to reclaim with"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1435
msgid ""
"Specifying a swappiness value instructs the kernel to perform the reclaim "
"with that swappiness value. Note that this has the same semantics as vm."
"swappiness applied to memcg reclaim with all the existing limitations and "
"potential future extensions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1440
msgid ""
"The valid range for swappiness is [0-200, max], setting swappiness=max "
"exclusively reclaims anonymous memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1443
msgid "memory.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1446
msgid ""
"The max memory usage recorded for the cgroup and its descendants since "
"either the creation of the cgroup or the most recent reset for that FD."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1449
#: ../../../admin-guide/cgroup-v2.rst:1840
msgid ""
"A write of any non-empty string to this file resets it to the current memory "
"usage for subsequent reads through the same file descriptor."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1453
msgid "memory.oom.group"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1454
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default value is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1457
msgid ""
"Determines whether the cgroup should be treated as an indivisible workload "
"by the OOM killer. If set, all tasks belonging to the cgroup or to its "
"descendants (if the memory cgroup is not a leaf cgroup) are killed together "
"or not at all. This can be used to avoid partial kills to guarantee workload "
"integrity."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1464
msgid ""
"Tasks with the OOM protection (oom_score_adj set to -1000) are treated as an "
"exception and are never killed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1467
msgid ""
"If the OOM killer is invoked in a cgroup, it's not going to kill any tasks "
"outside of this cgroup, regardless memory.oom.group values of ancestor "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1471
msgid "memory.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1477
msgid ""
"Note that all fields in this file are hierarchical and the file modified "
"event can be generated due to an event down the hierarchy. For the local "
"events at the cgroup level see memory.events.local."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1482
msgid "low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1483
msgid ""
"The number of times the cgroup is reclaimed due to high memory pressure even "
"though its usage is under the low boundary.  This usually indicates that the "
"low boundary is over-committed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1488
#: ../../../admin-guide/cgroup-v2.rst:1857
msgid "high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1489
msgid ""
"The number of times processes of the cgroup are throttled and routed to "
"perform direct memory reclaim because the high memory boundary was "
"exceeded.  For a cgroup whose memory usage is capped by the high limit "
"rather than global memory pressure, this event's occurrences are expected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1496
#: ../../../admin-guide/cgroup-v2.rst:1861
#: ../../../admin-guide/cgroup-v2.rst:2033
#: ../../../admin-guide/cgroup-v2.rst:2419
#: ../../../admin-guide/cgroup-v2.rst:2836
#: ../../../admin-guide/cgroup-v2.rst:2922
msgid "max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1497
msgid ""
"The number of times the cgroup's memory usage was about to go over the max "
"boundary.  If direct reclaim fails to bring it down, the cgroup goes to OOM "
"state."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1501
msgid "oom"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1502
msgid ""
"The number of time the cgroup's memory usage was reached the limit and "
"allocation was about to fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1505
msgid ""
"This event is not raised if the OOM killer is not considered as an option, e."
"g. for failed high-order allocations or if caller asked to not retry "
"attempts."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1509
msgid "oom_kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1510
msgid ""
"The number of processes belonging to this cgroup killed by any kind of OOM "
"killer."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1513
msgid "oom_group_kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1514
msgid "The number of times a group OOM has occurred."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1516
msgid "sock_throttled"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1517
msgid ""
"The number of times network sockets associated with this cgroup are "
"throttled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1520
msgid "memory.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1521
msgid ""
"Similar to memory.events but the fields in the file are local to the cgroup "
"i.e. not hierarchical. The file modified event generated on this file "
"reflects only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1525
msgid "memory.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1526
#: ../../../admin-guide/cgroup-v2.rst:2834
msgid "A read-only flat-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1528
msgid ""
"This breaks down the cgroup's memory footprint into different types of "
"memory, type-specific details, and other information on the state and past "
"events of the memory management system."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1532
#: ../../../admin-guide/cgroup-v2.rst:1799
msgid "All memory amounts are in bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1534
#: ../../../admin-guide/cgroup-v2.rst:1805
msgid ""
"The entries are ordered to be human readable, and new entries can show up in "
"the middle. Don't rely on items remaining in a fixed position; use the keys "
"to look up specific values!"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1538
msgid ""
"If the entry has no per-node counter (or not show in the memory.numa_stat). "
"We use 'npn' (non-per-node) as the tag to indicate that it will not show in "
"the memory.numa_stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1542
msgid "anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1543
msgid ""
"Amount of memory used in anonymous mappings such as brk(), sbrk(), and "
"mmap(MAP_ANONYMOUS). Note that some kernel configurations might account "
"complete larger allocations (e.g., THP) if only some, but not all the memory "
"of such an allocation is mapped anymore."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1549
msgid "file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1550
msgid ""
"Amount of memory used to cache filesystem data, including tmpfs and shared "
"memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1553
msgid "kernel (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1554
msgid ""
"Amount of total kernel memory, including (kernel_stack, pagetables, percpu, "
"vmalloc, slab) in addition to other kernel memory use cases."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1558
msgid "kernel_stack"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1559
msgid "Amount of memory allocated to kernel stacks."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1561
msgid "pagetables"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1562
msgid "Amount of memory allocated for page tables."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1564
msgid "sec_pagetables"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1565
msgid ""
"Amount of memory allocated for secondary page tables, this currently "
"includes KVM mmu allocations on x86 and arm64 and IOMMU page tables."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1569
msgid "percpu (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1570
msgid "Amount of memory used for storing per-cpu kernel data structures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1573
msgid "sock (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1574
msgid "Amount of memory used in network transmission buffers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1576
msgid "vmalloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1577
msgid "Amount of memory used for vmap backed memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1579
msgid "shmem"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1580
msgid ""
"Amount of cached filesystem data that is swap-backed, such as tmpfs, shm "
"segments, shared anonymous mmap()s"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1583
msgid "zswap"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1584
msgid "Amount of memory consumed by the zswap compression backend."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1586
msgid "zswapped"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1587
msgid "Amount of application memory swapped out to zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1589
msgid "file_mapped"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1590
msgid ""
"Amount of cached filesystem data mapped with mmap(). Note that some kernel "
"configurations might account complete larger allocations (e.g., THP) if only "
"some, but not not all the memory of such an allocation is mapped."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1595
msgid "file_dirty"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1596
msgid ""
"Amount of cached filesystem data that was modified but not yet written back "
"to disk"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1599
msgid "file_writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1600
msgid ""
"Amount of cached filesystem data that was modified and is currently being "
"written back to disk"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1603
msgid "swapcached"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1604
msgid ""
"Amount of swap cached in memory. The swapcache is accounted against both "
"memory and swap usage."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1607
msgid "anon_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1608
msgid ""
"Amount of memory used in anonymous mappings backed by transparent hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1611
msgid "file_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1612
msgid "Amount of cached filesystem data backed by transparent hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1615
msgid "shmem_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1616
msgid ""
"Amount of shm, tmpfs, shared anonymous mmap()s backed by transparent "
"hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1619
msgid "inactive_anon, active_anon, inactive_file, active_file, unevictable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1620
msgid ""
"Amount of memory, swap-backed and filesystem-backed, on the internal memory "
"management lists used by the page reclaim algorithm."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1624
msgid ""
"As these represent internal list state (eg. shmem pages are on anon memory "
"management lists), inactive_foo + active_foo may not be equal to the value "
"for the foo counter, since the foo counter is type-based, not list-based."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1629
msgid "slab_reclaimable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1630
msgid "Part of \"slab\" that might be reclaimed, such as dentries and inodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1633
msgid "slab_unreclaimable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1634
msgid "Part of \"slab\" that cannot be reclaimed on memory pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1637
msgid "slab (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1638
msgid "Amount of memory used for storing in-kernel data structures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1641
msgid "workingset_refault_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1642
msgid "Number of refaults of previously evicted anonymous pages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1644
msgid "workingset_refault_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1645
msgid "Number of refaults of previously evicted file pages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1647
msgid "workingset_activate_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1648
msgid "Number of refaulted anonymous pages that were immediately activated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1651
msgid "workingset_activate_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1652
msgid "Number of refaulted file pages that were immediately activated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1654
msgid "workingset_restore_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1655
msgid ""
"Number of restored anonymous pages which have been detected as an active "
"workingset before they got reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1658
msgid "workingset_restore_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1659
msgid ""
"Number of restored file pages which have been detected as an active "
"workingset before they got reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1662
msgid "workingset_nodereclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1663
msgid "Number of times a shadow node has been reclaimed"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1665
msgid "pswpin (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1666
msgid "Number of pages swapped into memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1668
msgid "pswpout (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1669
msgid "Number of pages swapped out of memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1671
msgid "pgscan (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1672
msgid "Amount of scanned pages (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1674
msgid "pgsteal (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1675
msgid "Amount of reclaimed pages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1677
msgid "pgscan_kswapd (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1678
msgid "Amount of scanned pages by kswapd (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1680
msgid "pgscan_direct (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1681
msgid "Amount of scanned pages directly  (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1683
msgid "pgscan_khugepaged (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1684
msgid "Amount of scanned pages by khugepaged  (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1686
msgid "pgscan_proactive (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1687
msgid "Amount of scanned pages proactively (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1689
msgid "pgsteal_kswapd (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1690
msgid "Amount of reclaimed pages by kswapd"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1692
msgid "pgsteal_direct (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1693
msgid "Amount of reclaimed pages directly"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1695
msgid "pgsteal_khugepaged (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1696
msgid "Amount of reclaimed pages by khugepaged"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1698
msgid "pgsteal_proactive (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1699
msgid "Amount of reclaimed pages proactively"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1701
msgid "pgfault (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1702
msgid "Total number of page faults incurred"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1704
msgid "pgmajfault (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1705
msgid "Number of major page faults incurred"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1707
msgid "pgrefill (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1708
msgid "Amount of scanned pages (in an active LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1710
msgid "pgactivate (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1711
msgid "Amount of pages moved to the active LRU list"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1713
msgid "pgdeactivate (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1714
msgid "Amount of pages moved to the inactive LRU list"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1716
msgid "pglazyfree (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1717
msgid "Amount of pages postponed to be freed under memory pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1719
msgid "pglazyfreed (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1720
msgid "Amount of reclaimed lazyfree pages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1722
msgid "swpin_zero"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1723
msgid ""
"Number of pages swapped into memory and filled with zero, where I/O was "
"optimized out because the page content was detected to be zero during "
"swapout."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1727
msgid "swpout_zero"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1728
msgid ""
"Number of zero-filled pages swapped out with I/O skipped due to the content "
"being detected as zero."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1731
msgid "zswpin"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1732
msgid "Number of pages moved in to memory from zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1734
msgid "zswpout"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1735
msgid "Number of pages moved out of memory to zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1737
msgid "zswpwb"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1738
msgid "Number of pages written from zswap to swap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1740
msgid "thp_fault_alloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1741
msgid ""
"Number of transparent hugepages which were allocated to satisfy a page "
"fault. This counter is not present when CONFIG_TRANSPARENT_HUGEPAGE is not "
"set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1745
msgid "thp_collapse_alloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1746
msgid ""
"Number of transparent hugepages which were allocated to allow collapsing an "
"existing range of pages. This counter is not present when "
"CONFIG_TRANSPARENT_HUGEPAGE is not set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1750
msgid "thp_swpout (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1751
msgid ""
"Number of transparent hugepages which are swapout in one piece without "
"splitting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1754
msgid "thp_swpout_fallback (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1755
msgid ""
"Number of transparent hugepages which were split before swapout. Usually "
"because failed to allocate some continuous swap space for the huge page."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1759
msgid "numa_pages_migrated (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1760
msgid "Number of pages migrated by NUMA balancing."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1762
msgid "numa_pte_updates (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1763
msgid ""
"Number of pages whose page table entries are modified by NUMA balancing to "
"produce NUMA hinting faults on access."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1766
msgid "numa_hint_faults (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1767
msgid "Number of NUMA hinting faults."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1769
msgid "pgdemote_kswapd"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1770
msgid "Number of pages demoted by kswapd."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1772
msgid "pgdemote_direct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1773
msgid "Number of pages demoted directly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1775
msgid "pgdemote_khugepaged"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1776
msgid "Number of pages demoted by khugepaged."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1778
msgid "pgdemote_proactive"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1779
msgid "Number of pages demoted by proactively."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1781
msgid "hugetlb"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1782
msgid ""
"Amount of memory used by hugetlb pages. This metric only shows up if hugetlb "
"usage is accounted for in memory.current (i.e. cgroup is mounted with the "
"memory_hugetlb_accounting option)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1786
msgid "memory.numa_stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1787
msgid "A read-only nested-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1789
msgid ""
"This breaks down the cgroup's memory footprint into different types of "
"memory, type-specific details, and other information per node on the state "
"of the memory management system."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1793
msgid ""
"This is useful for providing visibility into the NUMA locality information "
"within an memcg since the pages are allowed to be allocated from any "
"physical node. One of the use case is evaluating application performance by "
"combining this information with the application's CPU allocation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1801
msgid "The output format of memory.numa_stat is::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1809
msgid "The entries can refer to the memory.stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1811
msgid "memory.swap.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1815
msgid ""
"The total amount of swap currently being used by the cgroup and its "
"descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1818
msgid "memory.swap.high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1822
msgid ""
"Swap usage throttle limit.  If a cgroup's swap usage exceeds this limit, all "
"its further allocations will be throttled to allow userspace to implement "
"custom out-of-memory procedures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1826
msgid ""
"This limit marks a point of no return for the cgroup. It is NOT designed to "
"manage the amount of swapping a workload does during regular operation. "
"Compare to memory.swap.max, which prohibits swapping past a set amount, but "
"lets the cgroup continue unimpeded as long as other memory can be reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1832
msgid "Healthy workloads are not expected to reach this limit."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1834
msgid "memory.swap.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1837
msgid ""
"The max swap usage recorded for the cgroup and its descendants since the "
"creation of the cgroup or the most recent reset for that FD."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1844
msgid "memory.swap.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1848
msgid ""
"Swap usage hard limit.  If a cgroup's swap usage reaches this limit, "
"anonymous memory of the cgroup will not be swapped out."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1851
msgid "memory.swap.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1858
msgid ""
"The number of times the cgroup's swap usage was over the high threshold."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1862
msgid ""
"The number of times the cgroup's swap usage was about to go over the max "
"boundary and swap allocation failed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1866
msgid "fail"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1867
msgid ""
"The number of times swap allocation failed either because of running out of "
"swap system-wide or max limit."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1871
msgid ""
"When reduced under the current usage, the existing swap entries are "
"reclaimed gradually and the swap usage may stay higher than the limit for an "
"extended period of time.  This reduces the impact on the workload and memory "
"management."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1876
msgid "memory.zswap.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1880
msgid "The total amount of memory consumed by the zswap compression backend."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1883
msgid "memory.zswap.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1887
msgid ""
"Zswap usage hard limit. If a cgroup's zswap pool reaches this limit, it will "
"refuse to take any more stores before existing entries fault back in or are "
"written out to disk."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1891
msgid "memory.zswap.writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1892
msgid ""
"A read-write single value file. The default value is \"1\". Note that this "
"setting is hierarchical, i.e. the writeback would be implicitly disabled for "
"child cgroups if the upper hierarchy does so."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1897
msgid ""
"When this is set to 0, all swapping attempts to swapping devices are "
"disabled. This included both zswap writebacks, and swapping due to zswap "
"store failures. If the zswap store failures are recurring (for e.g if the "
"pages are incompressible), users can observe reclaim inefficiency after "
"disabling writeback (because the same pages might be rejected again and "
"again)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1904
msgid ""
"Note that this is subtly different from setting memory.swap.max to 0, as it "
"still allows for pages to be written to the zswap pool. This setting has no "
"effect if zswap is disabled, and swapping is allowed unless memory.swap.max "
"is set to 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1909
msgid "memory.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1910
#: ../../../admin-guide/cgroup-v2.rst:1994
#: ../../../admin-guide/cgroup-v2.rst:2170
msgid "A read-only nested-keyed file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1912
msgid ""
"Shows pressure stall information for memory. See :ref:`Documentation/"
"accounting/psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1917
msgid "Usage Guidelines"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1919
msgid ""
"\"memory.high\" is the main mechanism to control memory usage. Over-"
"committing on high limit (sum of high limits > available memory) and letting "
"global memory pressure to distribute memory according to usage is a viable "
"strategy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1924
msgid ""
"Because breach of the high limit doesn't trigger the OOM killer but "
"throttles the offending cgroup, a management agent has ample opportunities "
"to monitor and take appropriate actions such as granting more memory or "
"terminating the workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1929
msgid ""
"Determining whether a cgroup has enough memory is not trivial as memory "
"usage doesn't indicate whether the workload can benefit from more memory.  "
"For example, a workload which writes data received from network to a file "
"can use all available memory but can also operate as performant with a small "
"amount of memory.  A measure of memory pressure - how much the workload is "
"being impacted due to lack of memory - is necessary to determine whether a "
"workload needs more memory; unfortunately, memory pressure monitoring "
"mechanism isn't implemented yet."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1940
msgid "Reclaim Protection"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1942
msgid ""
"The protection configured with \"memory.low\" or \"memory.min\" applies "
"relatively to the target of the reclaim (i.e. any of memory cgroup limits, "
"proactive memory.reclaim or global reclaim apparently located in the root "
"cgroup). The protection value configured for B applies unchanged to the "
"reclaim targeting A (i.e. caused by competition with the sibling E)::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1952
msgid ""
"When the reclaim targets ancestors of A, the effective protection of B is "
"capped by the protection value configured for A (and any other intermediate "
"ancestors between A and the target)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1956
msgid ""
"To express indifference about relative sibling protection, it is suggested "
"to use memory_recursiveprot. Configuring all descendants of a parent with "
"finite protection to \"max\" works but it may unnecessarily skew memory."
"events:low field."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1962
msgid "Memory Ownership"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1964
msgid ""
"A memory area is charged to the cgroup which instantiated it and stays "
"charged to the cgroup until the area is released.  Migrating a process to a "
"different cgroup doesn't move the memory usages that it instantiated while "
"in the previous cgroup to the new cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1969
msgid ""
"A memory area may be used by processes belonging to different cgroups. To "
"which cgroup the area will be charged is in-deterministic; however, over "
"time, the memory area is likely to end up in a cgroup which has enough "
"memory allowance to avoid high reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1974
msgid ""
"If a cgroup sweeps a considerable amount of memory which is expected to be "
"accessed repeatedly by other cgroups, it may make sense to use "
"POSIX_FADV_DONTNEED to relinquish the ownership of memory areas belonging to "
"the affected files to ensure correct memory ownership."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1981
msgid "IO"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1983
msgid ""
"The \"io\" controller regulates the distribution of IO resources.  This "
"controller implements both weight based and absolute bandwidth or IOPS limit "
"distribution; however, weight based distribution is available only if cfq-"
"iosched is in use and neither scheme is available for blk-mq devices."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1991
msgid "IO Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1993
#: ../../../admin-guide/cgroup-v2.rst:2297
msgid "io.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1996
msgid ""
"Lines are keyed by $MAJ:$MIN device numbers and not ordered. The following "
"nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2000
msgid "rbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2000
msgid "Bytes read"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2001
msgid "wbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2001
msgid "Bytes written"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2002
msgid "rios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2002
msgid "Number of read IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2003
msgid "wios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2003
msgid "Number of write IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2004
msgid "dbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2004
msgid "Bytes discarded"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2005
msgid "dios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2005
msgid "Number of discard IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2008
#: ../../../admin-guide/cgroup-v2.rst:2124
msgid "An example read output follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2013
msgid "io.cost.qos"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2014
#: ../../../admin-guide/cgroup-v2.rst:2069
msgid "A read-write nested-keyed file which exists only on the root cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2017
msgid ""
"This file configures the Quality of Service of the IO cost model based "
"controller (CONFIG_BLK_CGROUP_IOCOST) which currently implements \"io."
"weight\" proportional control.  Lines are keyed by $MAJ:$MIN device numbers "
"and not ordered.  The line for a given device is populated on the first "
"write for the device on \"io.cost.qos\" or \"io.cost.model\".  The following "
"nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2026
msgid "enable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2026
msgid "Weight-based control enable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2027
#: ../../../admin-guide/cgroup-v2.rst:2081
msgid "ctrl"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2027
#: ../../../admin-guide/cgroup-v2.rst:2081
msgid "\"auto\" or \"user\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2028
msgid "rpct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2028
msgid "Read latency percentile    [0, 100]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2029
msgid "rlat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2029
msgid "Read latency threshold"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2030
msgid "wpct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2030
msgid "Write latency percentile   [0, 100]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2031
msgid "wlat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2031
msgid "Write latency threshold"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2032
msgid "min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2032
msgid "Minimum scaling percentage [1, 10000]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2033
msgid "Maximum scaling percentage [1, 10000]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2036
msgid ""
"The controller is disabled by default and can be enabled by setting "
"\"enable\" to 1.  \"rpct\" and \"wpct\" parameters default to zero and the "
"controller uses internal device saturation state to adjust the overall IO "
"rate between \"min\" and \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2041
msgid ""
"When a better control quality is needed, latency QoS parameters can be "
"configured.  For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2046
msgid ""
"shows that on sdb, the controller is enabled, will consider the device "
"saturated if the 95th percentile of read completion latencies is above 75ms "
"or write 150ms, and adjust the overall IO issue rate between 50% and 150% "
"accordingly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2051
msgid ""
"The lower the saturation point, the better the latency QoS at the cost of "
"aggregate bandwidth.  The narrower the allowed adjustment range between "
"\"min\" and \"max\", the more conformant to the cost model the IO behavior.  "
"Note that the IO issue base rate may be far off from 100% and setting "
"\"min\" and \"max\" blindly can lead to a significant loss of device "
"capacity or control quality.  \"min\" and \"max\" are useful for regulating "
"devices which show wide temporary behavior changes - e.g. a ssd which "
"accepts writes at the line speed for a while and then completely stalls for "
"multiple seconds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2062
msgid ""
"When \"ctrl\" is \"auto\", the parameters are controlled by the kernel and "
"may change automatically.  Setting \"ctrl\" to \"user\" or setting any of "
"the percentile and latency parameters puts it into \"user\" mode and "
"disables the automatic changes.  The automatic mode can be restored by "
"setting \"ctrl\" to \"auto\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2068
msgid "io.cost.model"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2072
msgid ""
"This file configures the cost model of the IO cost model based controller "
"(CONFIG_BLK_CGROUP_IOCOST) which currently implements \"io.weight\" "
"proportional control.  Lines are keyed by $MAJ:$MIN device numbers and not "
"ordered.  The line for a given device is populated on the first write for "
"the device on \"io.cost.qos\" or \"io.cost.model\".  The following nested "
"keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2082
msgid "model"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2082
msgid "The cost model in use - \"linear\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2085
msgid ""
"When \"ctrl\" is \"auto\", the kernel may change all parameters "
"dynamically.  When \"ctrl\" is set to \"user\" or any other parameters are "
"written to, \"ctrl\" become \"user\" and the automatic changes are disabled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2090
msgid ""
"When \"model\" is \"linear\", the following model parameters are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2094
msgid "[r|w]bps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2094
msgid "The maximum sequential IO throughput"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2095
msgid "[r|w]seqiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2095
msgid "The maximum 4k sequential IOs per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2096
msgid "[r|w]randiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2096
msgid "The maximum 4k random IOs per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2099
msgid ""
"From the above, the builtin linear model determines the base costs of a "
"sequential and random IO and the cost coefficient for the IO size.  While "
"simple, this model can cover most common device classes acceptably."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2104
msgid ""
"The IO cost model isn't expected to be accurate in absolute sense and is "
"scaled to the device behavior dynamically."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2107
msgid ""
"If needed, tools/cgroup/iocost_coef_gen.py can be used to generate device-"
"specific coefficients."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2110
msgid "io.weight"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2111
msgid ""
"A read-write flat-keyed file which exists on non-root cgroups. The default "
"is \"default 100\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2114
msgid ""
"The first line is the default weight applied to devices without specific "
"override.  The rest are overrides keyed by $MAJ:$MIN device numbers and not "
"ordered.  The weights are in the range [1, 10000] and specifies the relative "
"amount IO time the cgroup can use in relation to its siblings."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2120
msgid ""
"The default weight can be updated by writing either \"default $WEIGHT\" or "
"simply \"$WEIGHT\".  Overrides can be set by writing \"$MAJ:$MIN $WEIGHT\" "
"and unset by writing \"$MAJ:$MIN default\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2130
msgid "io.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2131
msgid "A read-write nested-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2134
msgid ""
"BPS and IOPS based IO limit.  Lines are keyed by $MAJ:$MIN device numbers "
"and not ordered.  The following nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2139
msgid "rbps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2139
msgid "Max read bytes per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2140
msgid "wbps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2140
msgid "Max write bytes per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2141
msgid "riops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2141
msgid "Max read IO operations per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2142
msgid "wiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2142
msgid "Max write IO operations per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2145
msgid ""
"When writing, any number of nested key-value pairs can be specified in any "
"order.  \"max\" can be specified as the value to remove a specific limit.  "
"If the same key is specified multiple times, the outcome is undefined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2150
msgid ""
"BPS and IOPS are measured in each IO direction and IOs are delayed if limit "
"is reached.  Temporary bursts are allowed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2153
msgid "Setting read limit at 2M BPS and write at 120 IOPS for 8:16::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2157
msgid "Reading returns the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2161
msgid "Write IOPS limit can be removed by writing the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2165
msgid "Reading now returns the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2169
msgid "io.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2172
msgid ""
"Shows pressure stall information for IO. See :ref:`Documentation/accounting/"
"psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2177
msgid "Writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2179
msgid ""
"Page cache is dirtied through buffered writes and shared mmaps and written "
"asynchronously to the backing filesystem by the writeback mechanism.  "
"Writeback sits between the memory and IO domains and regulates the "
"proportion of dirty memory by balancing dirtying and write IOs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2185
msgid ""
"The io controller, in conjunction with the memory controller, implements "
"control of page cache writeback IOs.  The memory controller defines the "
"memory domain that dirty memory ratio is calculated and maintained for and "
"the io controller defines the io domain which writes out dirty pages for the "
"memory domain.  Both system-wide and per-cgroup dirty memory states are "
"examined and the more restrictive of the two is enforced."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2193
msgid ""
"cgroup writeback requires explicit support from the underlying filesystem.  "
"Currently, cgroup writeback is implemented on ext2, ext4, btrfs, f2fs, and "
"xfs.  On other filesystems, all writeback IOs are attributed to the root "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2198
msgid ""
"There are inherent differences in memory and writeback management which "
"affects how cgroup ownership is tracked.  Memory is tracked per page while "
"writeback per inode.  For the purpose of writeback, an inode is assigned to "
"a cgroup and all IO requests to write dirty pages from the inode are "
"attributed to that cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2204
msgid ""
"As cgroup ownership for memory is tracked per page, there can be pages which "
"are associated with different cgroups than the one the inode is associated "
"with.  These are called foreign pages.  The writeback constantly keeps track "
"of foreign pages and, if a particular foreign cgroup becomes the majority "
"over a certain period of time, switches the ownership of the inode to that "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2211
msgid ""
"While this model is enough for most use cases where a given inode is mostly "
"dirtied by a single cgroup even when the main writing cgroup changes over "
"time, use cases where multiple cgroups write to a single inode "
"simultaneously are not supported well.  In such circumstances, a significant "
"portion of IOs are likely to be attributed incorrectly. As memory controller "
"assigns page ownership on the first use and doesn't update it until the page "
"is released, even if writeback strictly follows page ownership, multiple "
"cgroups dirtying overlapping areas wouldn't work as expected.  It's "
"recommended to avoid such usage patterns."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2222
msgid ""
"The sysctl knobs which affect writeback behavior are applied to cgroup "
"writeback as follows."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2225
msgid "vm.dirty_background_ratio, vm.dirty_ratio"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2226
msgid ""
"These ratios apply the same to cgroup writeback with the amount of available "
"memory capped by limits imposed by the memory controller and system-wide "
"clean memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2230
msgid "vm.dirty_background_bytes, vm.dirty_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2231
msgid ""
"For cgroup writeback, this is calculated into ratio against total available "
"memory and applied the same way as vm.dirty[_background]_ratio."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2237
msgid "IO Latency"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2239
msgid ""
"This is a cgroup v2 controller for IO workload protection.  You provide a "
"group with a latency target, and if the average latency exceeds that target "
"the controller will throttle any peers that have a lower latency target than "
"the protected workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2244
msgid ""
"The limits are only applied at the peer level in the hierarchy.  This means "
"that in the diagram below, only groups A, B, and C will influence each "
"other, and groups D and F will influence each other.  Group G will influence "
"nobody::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2255
msgid ""
"So the ideal way to configure this is to set io.latency in groups A, B, and "
"C. Generally you do not want to set a value lower than the latency your "
"device supports.  Experiment to find the value that works best for your "
"workload. Start at higher than the expected latency for your device and "
"watch the avg_lat value in io.stat for your workload group to get an idea of "
"the latency you see during normal operation.  Use the avg_lat value as a "
"basis for your real setting, setting at 10-15% higher than the value in io."
"stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2264
msgid "How IO Latency Throttling Works"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2266
msgid ""
"io.latency is work conserving; so as long as everybody is meeting their "
"latency target the controller doesn't do anything.  Once a group starts "
"missing its target it begins throttling any peer group that has a higher "
"target than itself. This throttling takes 2 forms:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2271
msgid ""
"Queue depth throttling.  This is the number of outstanding IO's a group is "
"allowed to have.  We will clamp down relatively quickly, starting at no "
"limit and going all the way down to 1 IO at a time."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2275
msgid ""
"Artificial delay induction.  There are certain types of IO that cannot be "
"throttled without possibly adversely affecting higher priority groups.  This "
"includes swapping and metadata IO.  These types of IO are allowed to occur "
"normally, however they are \"charged\" to the originating group.  If the "
"originating group is being throttled you will see the use_delay and delay "
"fields in io.stat increase.  The delay value is how many microseconds that "
"are being added to any process that runs in this group.  Because this number "
"can grow quite large if there is a lot of swapping or metadata IO occurring "
"we limit the individual delay events to 1 second at a time."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2285
msgid ""
"Once the victimized group starts meeting its latency target again it will "
"start unthrottling any peer groups that were throttled previously.  If the "
"victimized group simply stops doing IO the global counter will unthrottle "
"appropriately."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2290
msgid "IO Latency Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2292
msgid "io.latency"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2293
msgid "This takes a similar format as the other controllers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2295
msgid "\"MAJOR:MINOR target=<target time in microseconds>\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2298
msgid ""
"If the controller is enabled you will see extra stats in io.stat in addition "
"to the normal ones."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2301
msgid "depth"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2302
msgid "This is the current queue depth for the group."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2304
msgid "avg_lat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2305
msgid ""
"This is an exponential moving average with a decay rate of 1/exp bound by "
"the sampling interval.  The decay rate interval can be calculated by "
"multiplying the win value in io.stat by the corresponding number of samples "
"based on the win value."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2310
msgid "win"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2311
msgid ""
"The sampling window size in milliseconds.  This is the minimum duration of "
"time between evaluation events.  Windows only elapse with IO activity.  Idle "
"periods extend the most recent window."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2316
msgid "IO Priority"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2318
msgid ""
"A single attribute controls the behavior of the I/O priority cgroup policy, "
"namely the io.prio.class attribute. The following values are accepted for "
"that attribute:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2322
#: ../../../admin-guide/cgroup-v2.rst:2346
msgid "no-change"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2323
msgid "Do not modify the I/O priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2325
#: ../../../admin-guide/cgroup-v2.rst:2348
msgid "promote-to-rt"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2326
msgid ""
"For requests that have a non-RT I/O priority class, change it into RT. Also "
"change the priority level of these requests to 4. Do not modify the I/O "
"priority of requests that have priority class RT."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2330
#: ../../../admin-guide/cgroup-v2.rst:2350
msgid "restrict-to-be"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2331
msgid ""
"For requests that do not have an I/O priority class or that have I/O "
"priority class RT, change it into BE. Also change the priority level of "
"these requests to 0. Do not modify the I/O priority class of requests that "
"have priority class IDLE."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2336
#: ../../../admin-guide/cgroup-v2.rst:2352
msgid "idle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2337
msgid ""
"Change the I/O priority class of all requests into IDLE, the lowest I/O "
"priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2340
msgid "none-to-rt"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2341
msgid "Deprecated. Just an alias for promote-to-rt."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2343
msgid ""
"The following numerical values are associated with the I/O priority policies:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2346
#: ../../../admin-guide/cgroup-v2.rst:2358
msgid "0"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2348
#: ../../../admin-guide/cgroup-v2.rst:2360
msgid "1"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2350
#: ../../../admin-guide/cgroup-v2.rst:2362
msgid "2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2352
#: ../../../admin-guide/cgroup-v2.rst:2364
msgid "3"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2355
msgid ""
"The numerical value that corresponds to each I/O priority class is as "
"follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2358
msgid "IOPRIO_CLASS_NONE"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2360
msgid "IOPRIO_CLASS_RT (real-time)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2362
msgid "IOPRIO_CLASS_BE (best effort)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2364
msgid "IOPRIO_CLASS_IDLE"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2367
msgid ""
"The algorithm to set the I/O priority class for a request is as follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2369
msgid ""
"If I/O priority class policy is promote-to-rt, change the request I/O "
"priority class to IOPRIO_CLASS_RT and change the request I/O priority level "
"to 4."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2372
msgid ""
"If I/O priority class policy is not promote-to-rt, translate the I/O "
"priority class policy into a number, then change the request I/O priority "
"class into the maximum of the I/O priority class policy number and the "
"numerical I/O priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2378
msgid "PID"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2380
msgid ""
"The process number controller is used to allow a cgroup to stop any new "
"tasks from being fork()'d or clone()'d after a specified limit is reached."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2384
msgid ""
"The number of tasks in a cgroup can be exhausted in ways which other "
"controllers cannot prevent, thus warranting its own controller.  For "
"example, a fork bomb is likely to exhaust the number of tasks before hitting "
"memory restrictions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2389
msgid ""
"Note that PIDs used in this controller refer to TIDs, process IDs as used by "
"the kernel."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2394
msgid "PID Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2396
msgid "pids.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2400
msgid "Hard limit of number of processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2402
msgid "pids.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2405
msgid "The number of processes currently in the cgroup and its descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2408
msgid "pids.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2411
msgid ""
"The maximum value that the number of processes in the cgroup and its "
"descendants has ever reached."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2414
msgid "pids.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2415
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. Unless "
"specified otherwise, a value change in this file generates a file modified "
"event. The following entries are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2420
msgid ""
"The number of times the cgroup's total number of processes hit the pids.max "
"limit (see also pids_localevents)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2423
msgid "pids.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2424
msgid ""
"Similar to pids.events but the fields in the file are local to the cgroup i."
"e. not hierarchical. The file modified event generated on this file reflects "
"only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2428
msgid ""
"Organisational operations are not blocked by cgroup policies, so it is "
"possible to have pids.current > pids.max.  This can be done by either "
"setting the limit to be smaller than pids.current, or attaching enough "
"processes to the cgroup such that pids.current is larger than pids.max.  "
"However, it is not possible to violate a cgroup PID policy through fork() or "
"clone(). These will return -EAGAIN if the creation of a new process would "
"cause a cgroup policy to be violated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2438
msgid "Cpuset"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2440
msgid ""
"The \"cpuset\" controller provides a mechanism for constraining the CPU and "
"memory node placement of tasks to only the resources specified in the cpuset "
"interface files in a task's current cgroup. This is especially valuable on "
"large NUMA systems where placing jobs on properly sized subsets of the "
"systems with careful processor and memory placement to reduce cross-node "
"memory access and contention can improve overall system performance."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2448
msgid ""
"The \"cpuset\" controller is hierarchical.  That means the controller cannot "
"use CPUs or memory nodes not allowed in its parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2453
msgid "Cpuset Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2455
msgid "cpuset.cpus"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2456
#: ../../../admin-guide/cgroup-v2.rst:2495
#: ../../../admin-guide/cgroup-v2.rst:2545
msgid ""
"A read-write multiple values file which exists on non-root cpuset-enabled "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2459
msgid ""
"It lists the requested CPUs to be used by tasks within this cgroup.  The "
"actual list of CPUs to be granted, however, is subjected to constraints "
"imposed by its parent and can differ from the requested CPUs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2464
msgid "The CPU numbers are comma-separated numbers or ranges. For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2470
msgid ""
"An empty value indicates that the cgroup is using the same setting as the "
"nearest cgroup ancestor with a non-empty \"cpuset.cpus\" or all the "
"available CPUs if none is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2474
msgid ""
"The value of \"cpuset.cpus\" stays constant until the next update and won't "
"be affected by any CPU hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2477
msgid "cpuset.cpus.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2478
#: ../../../admin-guide/cgroup-v2.rst:2529
msgid ""
"A read-only multiple values file which exists on all cpuset-enabled cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2481
msgid ""
"It lists the onlined CPUs that are actually granted to this cgroup by its "
"parent.  These CPUs are allowed to be used by tasks within the current "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2485
msgid ""
"If \"cpuset.cpus\" is empty, the \"cpuset.cpus.effective\" file shows all "
"the CPUs from the parent cgroup that can be available to be used by this "
"cgroup.  Otherwise, it should be a subset of \"cpuset.cpus\" unless none of "
"the CPUs listed in \"cpuset.cpus\" can be granted.  In this case, it will be "
"treated just like an empty \"cpuset.cpus\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2492
msgid "Its value will be affected by CPU hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2494
msgid "cpuset.mems"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2498
msgid ""
"It lists the requested memory nodes to be used by tasks within this cgroup.  "
"The actual list of memory nodes granted, however, is subjected to "
"constraints imposed by its parent and can differ from the requested memory "
"nodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2503
msgid ""
"The memory node numbers are comma-separated numbers or ranges. For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2509
msgid ""
"An empty value indicates that the cgroup is using the same setting as the "
"nearest cgroup ancestor with a non-empty \"cpuset.mems\" or all the "
"available memory nodes if none is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2514
msgid ""
"The value of \"cpuset.mems\" stays constant until the next update and won't "
"be affected by any memory nodes hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2517
msgid ""
"Setting a non-empty value to \"cpuset.mems\" causes memory of tasks within "
"the cgroup to be migrated to the designated nodes if they are currently "
"using memory outside of the designated nodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2521
msgid ""
"There is a cost for this memory migration.  The migration may not be "
"complete and some memory pages may be left behind. So it is recommended that "
"\"cpuset.mems\" should be set properly before spawning new tasks into the "
"cpuset.  Even if there is a need to change \"cpuset.mems\" with active "
"tasks, it shouldn't be done frequently."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2528
msgid "cpuset.mems.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2532
msgid ""
"It lists the onlined memory nodes that are actually granted to this cgroup "
"by its parent. These memory nodes are allowed to be used by tasks within the "
"current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2536
msgid ""
"If \"cpuset.mems\" is empty, it shows all the memory nodes from the parent "
"cgroup that will be available to be used by this cgroup. Otherwise, it "
"should be a subset of \"cpuset.mems\" unless none of the memory nodes listed "
"in \"cpuset.mems\" can be granted.  In this case, it will be treated just "
"like an empty \"cpuset.mems\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2542
msgid "Its value will be affected by memory nodes hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2544
msgid "cpuset.cpus.exclusive"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2548
msgid ""
"It lists all the exclusive CPUs that are allowed to be used to create a new "
"cpuset partition.  Its value is not used unless the cgroup becomes a valid "
"partition root.  See the \"cpuset.cpus.partition\" section below for a "
"description of what a cpuset partition is."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2554
msgid ""
"When the cgroup becomes a partition root, the actual exclusive CPUs that are "
"allocated to that partition are listed in \"cpuset.cpus.exclusive."
"effective\" which may be different from \"cpuset.cpus.exclusive\".  If "
"\"cpuset.cpus.exclusive\" has previously been set, \"cpuset.cpus.exclusive."
"effective\" is always a subset of it."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2561
msgid ""
"Users can manually set it to a value that is different from \"cpuset."
"cpus\".  One constraint in setting it is that the list of CPUs must be "
"exclusive with respect to \"cpuset.cpus.exclusive\" of its sibling.  If "
"\"cpuset.cpus.exclusive\" of a sibling cgroup isn't set, its \"cpuset.cpus\" "
"value, if set, cannot be a subset of it to leave at least one CPU available "
"when the exclusive CPUs are taken away."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2569
msgid ""
"For a parent cgroup, any one of its exclusive CPUs can only be distributed "
"to at most one of its child cgroups.  Having an exclusive CPU appearing in "
"two or more of its child cgroups is not allowed (the exclusivity rule).  A "
"value that violates the exclusivity rule will be rejected with a write error."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2575
msgid ""
"The root cgroup is a partition root and all its available CPUs are in its "
"exclusive CPU set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2578
msgid "cpuset.cpus.exclusive.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2579
msgid ""
"A read-only multiple values file which exists on all non-root cpuset-enabled "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2582
msgid ""
"This file shows the effective set of exclusive CPUs that can be used to "
"create a partition root.  The content of this file will always be a subset "
"of its parent's \"cpuset.cpus.exclusive.effective\" if its parent is not the "
"root cgroup.  It will also be a subset of \"cpuset.cpus.exclusive\" if it is "
"set.  If \"cpuset.cpus.exclusive\" is not set, it is treated to have an "
"implicit value of \"cpuset.cpus\" in the formation of local partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2591
msgid "cpuset.cpus.isolated"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2592
msgid "A read-only and root cgroup only multiple values file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2594
msgid ""
"This file shows the set of all isolated CPUs used in existing isolated "
"partitions. It will be empty if no isolated partition is created."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2598
msgid "cpuset.cpus.partition"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2599
msgid ""
"A read-write single value file which exists on non-root cpuset-enabled "
"cgroups.  This flag is owned by the parent cgroup and is not delegatable."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2603
msgid "It accepts only the following input values when written to."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2606
#: ../../../admin-guide/cgroup-v2.rst:2658
msgid "\"member\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2606
#: ../../../admin-guide/cgroup-v2.rst:2658
msgid "Non-root member of a partition"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2607
#: ../../../admin-guide/cgroup-v2.rst:2659
msgid "\"root\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2607
#: ../../../admin-guide/cgroup-v2.rst:2659
msgid "Partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2608
#: ../../../admin-guide/cgroup-v2.rst:2660
msgid "\"isolated\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2608
#: ../../../admin-guide/cgroup-v2.rst:2660
msgid "Partition root without load balancing"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2611
msgid ""
"A cpuset partition is a collection of cpuset-enabled cgroups with a "
"partition root at the top of the hierarchy and its descendants except those "
"that are separate partition roots themselves and their descendants.  A "
"partition has exclusive access to the set of exclusive CPUs allocated to "
"it.  Other cgroups outside of that partition cannot use any CPUs in that set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2618
msgid ""
"There are two types of partitions - local and remote.  A local partition is "
"one whose parent cgroup is also a valid partition root.  A remote partition "
"is one whose parent cgroup is not a valid partition root itself.  Writing to "
"\"cpuset.cpus.exclusive\" is optional for the creation of a local partition "
"as its \"cpuset.cpus.exclusive\" file will assume an implicit value that is "
"the same as \"cpuset.cpus\" if it is not set.  Writing the proper \"cpuset."
"cpus.exclusive\" values down the cgroup hierarchy before the target "
"partition root is mandatory for the creation of a remote partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2629
msgid ""
"Currently, a remote partition cannot be created under a local partition.  "
"All the ancestors of a remote partition root except the root cgroup cannot "
"be a partition root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2633
msgid ""
"The root cgroup is always a partition root and its state cannot be changed.  "
"All other non-root cgroups start out as \"member\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2636
msgid ""
"When set to \"root\", the current cgroup is the root of a new partition or "
"scheduling domain.  The set of exclusive CPUs is determined by the value of "
"its \"cpuset.cpus.exclusive.effective\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2640
msgid ""
"When set to \"isolated\", the CPUs in that partition will be in an isolated "
"state without any load balancing from the scheduler and excluded from the "
"unbound workqueues.  Tasks placed in such a partition with multiple CPUs "
"should be carefully distributed and bound to each of the individual CPUs for "
"optimal performance."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2646
msgid ""
"A partition root (\"root\" or \"isolated\") can be in one of the two "
"possible states - valid or invalid.  An invalid partition root is in a "
"degraded state where some state information may be retained, but behaves "
"more like a \"member\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2651
msgid ""
"All possible state transitions among \"member\", \"root\" and \"isolated\" "
"are allowed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2654
msgid ""
"On read, the \"cpuset.cpus.partition\" file can show the following values."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2661
msgid "\"root invalid (<reason>)\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2661
msgid "Invalid partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2662
msgid "\"isolated invalid (<reason>)\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2662
msgid "Invalid isolated partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2665
msgid ""
"In the case of an invalid partition root, a descriptive string on why the "
"partition is invalid is included within parentheses."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2668
msgid ""
"For a local partition root to be valid, the following conditions must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2671
msgid "The parent cgroup is a valid partition root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2672
msgid ""
"The \"cpuset.cpus.exclusive.effective\" file cannot be empty, though it may "
"contain offline CPUs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2674
msgid ""
"The \"cpuset.cpus.effective\" cannot be empty unless there is no task "
"associated with this partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2677
msgid ""
"For a remote partition root to be valid, all the above conditions except the "
"first one must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2680
msgid ""
"External events like hotplug or changes to \"cpuset.cpus\" or \"cpuset.cpus."
"exclusive\" can cause a valid partition root to become invalid and vice "
"versa.  Note that a task cannot be moved to a cgroup with empty \"cpuset."
"cpus.effective\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2685
msgid ""
"A valid non-root parent partition may distribute out all its CPUs to its "
"child local partitions when there is no task associated with it."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2689
msgid ""
"Care must be taken to change a valid partition root to \"member\" as all its "
"child local partitions, if present, will become invalid causing disruption "
"to tasks running in those child partitions. These inactivated partitions "
"could be recovered if their parent is switched back to a partition root with "
"a proper value in \"cpuset.cpus\" or \"cpuset.cpus.exclusive\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2696
msgid ""
"Poll and inotify events are triggered whenever the state of \"cpuset.cpus."
"partition\" changes.  That includes changes caused by write to \"cpuset.cpus."
"partition\", cpu hotplug or other changes that modify the validity status of "
"the partition. This will allow user space agents to monitor unexpected "
"changes to \"cpuset.cpus.partition\" without the need to do continuous "
"polling."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2704
msgid ""
"A user can pre-configure certain CPUs to an isolated state with load "
"balancing disabled at boot time with the \"isolcpus\" kernel boot command "
"line option.  If those CPUs are to be put into a partition, they have to be "
"used in an isolated partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2711
msgid "Device controller"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2713
msgid ""
"Device controller manages access to device files. It includes both creation "
"of new device files (using mknod), and access to the existing device files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2717
msgid ""
"Cgroup v2 device controller has no interface files and is implemented on top "
"of cgroup BPF. To control access to device files, a user may create bpf "
"programs of type BPF_PROG_TYPE_CGROUP_DEVICE and attach them to cgroups with "
"BPF_CGROUP_DEVICE flag. On an attempt to access a device file, corresponding "
"BPF programs will be executed, and depending on the return value the attempt "
"will succeed or fail with -EPERM."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2724
msgid ""
"A BPF_PROG_TYPE_CGROUP_DEVICE program takes a pointer to the "
"bpf_cgroup_dev_ctx structure, which describes the device access attempt: "
"access type (mknod/read/write) and device (type, major and minor numbers). "
"If the program returns 0, the attempt fails with -EPERM, otherwise it "
"succeeds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2730
msgid ""
"An example of BPF_PROG_TYPE_CGROUP_DEVICE program may be found in tools/"
"testing/selftests/bpf/progs/dev_cgroup.c in the kernel source tree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2735
msgid "RDMA"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2737
msgid ""
"The \"rdma\" controller regulates the distribution and accounting of RDMA "
"resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2741
msgid "RDMA Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2743
msgid "rdma.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2744
msgid ""
"A readwrite nested-keyed file that exists for all the cgroups except root "
"that describes current configured resource limit for a RDMA/IB device."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2748
msgid ""
"Lines are keyed by device name and are not ordered. Each line contains space "
"separated resource name and its configured limit that can be distributed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2755
msgid "hca_handle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2755
msgid "Maximum number of HCA Handles"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2756
msgid "hca_object"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2756
msgid "Maximum number of HCA Objects"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2759
#: ../../../admin-guide/cgroup-v2.rst:2768
msgid "An example for mlx4 and ocrdma device follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2764
msgid "rdma.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2765
#: ../../../admin-guide/cgroup-v2.rst:2808
msgid ""
"A read-only file that describes current resource usage. It exists for all "
"the cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2774
msgid "DMEM"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2776
msgid ""
"The \"dmem\" controller regulates the distribution and accounting of device "
"memory regions. Because each memory region may have its own page size, which "
"does not have to be equal to the system page size, the units are always "
"bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2781
msgid "DMEM Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2783
msgid "dmem.max, dmem.min, dmem.low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2784
msgid ""
"A readwrite nested-keyed file that exists for all the cgroups except root "
"that describes current configured resource limit for a region."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2788
#: ../../../admin-guide/cgroup-v2.rst:2802
#: ../../../admin-guide/cgroup-v2.rst:2811
msgid "An example for xe follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2793
msgid ""
"The semantics are the same as for the memory cgroup controller, and are "
"calculated in the same way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2796
msgid "dmem.capacity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2797
msgid ""
"A read-only file that describes maximum region capacity. It only exists on "
"the root cgroup. Not all memory can be allocated by cgroups, as the kernel "
"reserves some for internal use."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2807
msgid "dmem.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2817
msgid "HugeTLB"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2819
msgid ""
"The HugeTLB controller allows to limit the HugeTLB usage per control group "
"and enforces the controller limit during page fault."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2823
msgid "HugeTLB Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2825
msgid "hugetlb.<hugepagesize>.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2826
msgid ""
"Show current usage for \"hugepagesize\" hugetlb.  It exists for all the "
"cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2829
msgid "hugetlb.<hugepagesize>.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2830
msgid ""
"Set/show the hard limit of \"hugepagesize\" hugetlb usage. The default value "
"is \"max\".  It exists for all the cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2833
msgid "hugetlb.<hugepagesize>.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2837
msgid "The number of allocation failure due to HugeTLB limit"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2839
msgid "hugetlb.<hugepagesize>.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2840
msgid ""
"Similar to hugetlb.<hugepagesize>.events but the fields in the file are "
"local to the cgroup i.e. not hierarchical. The file modified event generated "
"on this file reflects only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2844
msgid "hugetlb.<hugepagesize>.numa_stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2845
msgid ""
"Similar to memory.numa_stat, it shows the numa information of the hugetlb "
"pages of <hugepagesize> in this cgroup.  Only active in use hugetlb pages "
"are included.  The per-node values are in bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2850
msgid "Misc"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2852
msgid ""
"The Miscellaneous cgroup provides the resource limiting and tracking "
"mechanism for the scalar resources which cannot be abstracted like the other "
"cgroup resources. Controller is enabled by the CONFIG_CGROUP_MISC config "
"option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2857
msgid ""
"A resource can be added to the controller via enum misc_res_type{} in the "
"include/linux/misc_cgroup.h file and the corresponding name via "
"misc_res_name[] in the kernel/cgroup/misc.c file. Provider of the resource "
"must set its capacity prior to using the resource by calling "
"misc_cg_set_capacity()."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2862
msgid ""
"Once a capacity is set then the resource usage can be updated using charge "
"and uncharge APIs. All of the APIs to interact with misc controller are in "
"include/linux/misc_cgroup.h."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2867
msgid "Misc Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2869
msgid ""
"Miscellaneous controller provides 3 interface files. If two misc resources "
"(res_a and res_b) are registered then:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2871
msgid "misc.capacity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2872
msgid ""
"A read-only flat-keyed file shown only in the root cgroup.  It shows "
"miscellaneous scalar resources available on the platform along with their "
"quantities::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2880
msgid "misc.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2881
msgid ""
"A read-only flat-keyed file shown in the all cgroups.  It shows the current "
"usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2888
msgid "misc.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2889
msgid ""
"A read-only flat-keyed file shown in all cgroups.  It shows the historical "
"maximum usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2897
msgid "misc.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2898
msgid ""
"A read-write flat-keyed file shown in the non root cgroups. Allowed maximum "
"usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2905
msgid "Limit can be set by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2909
msgid "Limit can be set to max by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2913
msgid ""
"Limits can be set higher than the capacity value in the misc.capacity file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2916
msgid "misc.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2917
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. The following "
"entries are defined. Unless specified otherwise, a value change in this file "
"generates a file modified event. All fields in this file are hierarchical."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2923
msgid ""
"The number of times the cgroup's resource usage was about to go over the max "
"boundary."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2926
msgid "misc.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2927
msgid ""
"Similar to misc.events but the fields in the file are local to the cgroup i."
"e. not hierarchical. The file modified event generated on this file reflects "
"only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2932
msgid "Migration and Ownership"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2934
msgid ""
"A miscellaneous scalar resource is charged to the cgroup in which it is used "
"first, and stays charged to that cgroup until that resource is freed. "
"Migrating a process to a different cgroup does not move the charge to the "
"destination cgroup where the process has moved."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2940
msgid "Others"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2943
msgid "perf_event"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2945
msgid ""
"perf_event controller, if not mounted on a legacy hierarchy, is "
"automatically enabled on the v2 hierarchy so that perf events can always be "
"filtered by cgroup v2 path.  The controller can still be moved to a legacy "
"hierarchy after v2 hierarchy is populated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2952
msgid "Non-normative information"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2954
msgid ""
"This section contains information that isn't considered to be a part of the "
"stable kernel API and so is subject to change."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2959
msgid "CPU controller root cgroup process behaviour"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2961
msgid ""
"When distributing CPU cycles in the root cgroup each thread in this cgroup "
"is treated as if it was hosted in a separate child cgroup of the root "
"cgroup. This child cgroup weight is dependent on its thread nice level."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2966
msgid ""
"For details of this mapping see sched_prio_to_weight array in kernel/sched/"
"core.c file (values from this array should be scaled appropriately so the "
"neutral - nice 0 - value is 100 instead of 1024)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2972
msgid "IO controller root cgroup process behaviour"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2974
msgid ""
"Root cgroup processes are hosted in an implicit leaf child node. When "
"distributing IO resources this implicit child node is taken into account as "
"if it was a normal child cgroup of the root cgroup with a weight value of "
"200."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2981
msgid "Namespace"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2984
msgid "Basics"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2986
msgid ""
"cgroup namespace provides a mechanism to virtualize the view of the \"/proc/"
"$PID/cgroup\" file and cgroup mounts.  The CLONE_NEWCGROUP clone flag can be "
"used with clone(2) and unshare(2) to create a new cgroup namespace.  The "
"process running inside the cgroup namespace will have its \"/proc/$PID/"
"cgroup\" output restricted to cgroupns root.  The cgroupns root is the "
"cgroup of the process at the time of creation of the cgroup namespace."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2994
msgid ""
"Without cgroup namespace, the \"/proc/$PID/cgroup\" file shows the complete "
"path of the cgroup of a process.  In a container setup where a set of "
"cgroups and namespaces are intended to isolate processes the \"/proc/$PID/"
"cgroup\" file may leak potential system level information to the isolated "
"processes.  For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3003
msgid ""
"The path '/batchjobs/container_id1' can be considered as system-data and "
"undesirable to expose to the isolated processes.  cgroup namespace can be "
"used to restrict visibility of this path.  For example, before creating a "
"cgroup namespace, one would see::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3013
msgid "After unsharing a new namespace, the view changes::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3020
msgid ""
"When some thread from a multi-threaded process unshares its cgroup "
"namespace, the new cgroupns gets applied to the entire process (all the "
"threads).  This is natural for the v2 hierarchy; however, for the legacy "
"hierarchies, this may be unexpected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3025
msgid ""
"A cgroup namespace is alive as long as there are processes inside or mounts "
"pinning it.  When the last usage goes away, the cgroup namespace is "
"destroyed.  The cgroupns root and the actual cgroups remain."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3032
msgid "The Root and Views"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3034
msgid ""
"The 'cgroupns root' for a cgroup namespace is the cgroup in which the "
"process calling unshare(2) is running.  For example, if a process in /"
"batchjobs/container_id1 cgroup calls unshare, cgroup /batchjobs/"
"container_id1 becomes the cgroupns root.  For the init_cgroup_ns, this is "
"the real root ('/') cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3040
msgid ""
"The cgroupns root cgroup does not change even if the namespace creator "
"process later moves to a different cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3051
msgid "Each process gets its namespace-specific view of \"/proc/$PID/cgroup\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3053
msgid ""
"Processes running inside the cgroup namespace will be able to see cgroup "
"paths (in /proc/self/cgroup) only inside their root cgroup. From within an "
"unshared cgroupns::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3063
msgid ""
"From the initial cgroup namespace, the real cgroup path will be visible::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3069
msgid ""
"From a sibling cgroup namespace (that is, a namespace rooted at a different "
"cgroup), the cgroup path relative to its own cgroup namespace root will be "
"shown.  For instance, if PID 7353's cgroup namespace root is at '/batchjobs/"
"container_id2', then it will see::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3077
msgid ""
"Note that the relative path always starts with '/' to indicate that its "
"relative to the cgroup namespace root of the caller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3082
msgid "Migration and setns(2)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3084
msgid ""
"Processes inside a cgroup namespace can move into and out of the namespace "
"root if they have proper access to external cgroups.  For example, from "
"inside a namespace with cgroupns root at /batchjobs/container_id1, and "
"assuming that the global hierarchy is still accessible inside cgroupns::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3096
msgid ""
"Note that this kind of setup is not encouraged.  A task inside cgroup "
"namespace should only be exposed to its own cgroupns hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3099
msgid "setns(2) to another cgroup namespace is allowed when:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3101
msgid "the process has CAP_SYS_ADMIN against its current user namespace"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3102
msgid ""
"the process has CAP_SYS_ADMIN against the target cgroup namespace's userns"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3105
msgid ""
"No implicit cgroup changes happen with attaching to another cgroup "
"namespace.  It is expected that the someone moves the attaching process "
"under the target cgroup namespace root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3111
msgid "Interaction with Other Namespaces"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3113
msgid ""
"Namespace specific cgroup hierarchy can be mounted by a process running "
"inside a non-init cgroup namespace::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3118
msgid ""
"This will mount the unified cgroup hierarchy with cgroupns root as the "
"filesystem root.  The process needs CAP_SYS_ADMIN against its user and mount "
"namespaces."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3122
msgid ""
"The virtualization of /proc/self/cgroup file combined with restricting the "
"view of cgroup hierarchy by namespace-private cgroupfs mount provides a "
"properly isolated cgroup view inside the container."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3128
msgid "Information on Kernel Programming"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3130
msgid ""
"This section contains kernel programming information in the areas where "
"interacting with cgroup is necessary.  cgroup core and controllers are not "
"covered."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3136
msgid "Filesystem Support for Writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3138
msgid ""
"A filesystem can support cgroup writeback by updating "
"address_space_operations->writepages() to annotate bio's using the following "
"two functions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3142
msgid "wbc_init_bio(@wbc, @bio)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3143
msgid ""
"Should be called for each bio carrying writeback data and associates the bio "
"with the inode's owner cgroup and the corresponding request queue.  This "
"must be called after a queue (device) has been associated with the bio and "
"before submission."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3149
msgid "wbc_account_cgroup_owner(@wbc, @folio, @bytes)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3150
msgid ""
"Should be called for each data segment being written out. While this "
"function doesn't care exactly when it's called during the writeback session, "
"it's the easiest and most natural to call it as data segments are added to a "
"bio."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3155
msgid ""
"With writeback bio's annotated, cgroup support can be enabled per "
"super_block by setting SB_I_CGROUPWB in ->s_iflags.  This allows for "
"selective disabling of cgroup writeback support which is helpful when "
"certain filesystem features, e.g. journaled data mode, are incompatible."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3161
msgid ""
"wbc_init_bio() binds the specified bio to its cgroup.  Depending on the "
"configuration, the bio may be executed at a lower priority and if the "
"writeback session is holding shared resources, e.g. a journal entry, may "
"lead to priority inversion.  There is no one easy solution for the problem.  "
"Filesystems can try to work around specific problem cases by skipping "
"wbc_init_bio() and using bio_associate_blkg() directly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3171
msgid "Deprecated v1 Core Features"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3173
msgid "Multiple hierarchies including named ones are not supported."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3175
msgid "All v1 mount options are not supported."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3177
msgid "The \"tasks\" file is removed and \"cgroup.procs\" is not sorted."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3179
msgid "\"cgroup.clone_children\" is removed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3181
msgid ""
"/proc/cgroups is meaningless for v2.  Use \"cgroup.controllers\" or \"cgroup."
"stat\" files at the root instead."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3186
msgid "Issues with v1 and Rationales for v2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3189
msgid "Multiple Hierarchies"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3191
msgid ""
"cgroup v1 allowed an arbitrary number of hierarchies and each hierarchy "
"could host any number of controllers.  While this seemed to provide a high "
"level of flexibility, it wasn't useful in practice."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3195
msgid ""
"For example, as there is only one instance of each controller, utility type "
"controllers such as freezer which can be useful in all hierarchies could "
"only be used in one.  The issue is exacerbated by the fact that controllers "
"couldn't be moved to another hierarchy once hierarchies were populated.  "
"Another issue was that all controllers bound to a hierarchy were forced to "
"have exactly the same view of the hierarchy.  It wasn't possible to vary the "
"granularity depending on the specific controller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3204
msgid ""
"In practice, these issues heavily limited which controllers could be put on "
"the same hierarchy and most configurations resorted to putting each "
"controller on its own hierarchy.  Only closely related ones, such as the cpu "
"and cpuacct controllers, made sense to be put on the same hierarchy.  This "
"often meant that userland ended up managing multiple similar hierarchies "
"repeating the same steps on each hierarchy whenever a hierarchy management "
"operation was necessary."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3212
msgid ""
"Furthermore, support for multiple hierarchies came at a steep cost. It "
"greatly complicated cgroup core implementation but more importantly the "
"support for multiple hierarchies restricted how cgroup could be used in "
"general and what controllers was able to do."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3217
msgid ""
"There was no limit on how many hierarchies there might be, which meant that "
"a thread's cgroup membership couldn't be described in finite length.  The "
"key might contain any number of entries and was unlimited in length, which "
"made it highly awkward to manipulate and led to addition of controllers "
"which existed only to identify membership, which in turn exacerbated the "
"original problem of proliferating number of hierarchies."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3225
msgid ""
"Also, as a controller couldn't have any expectation regarding the topologies "
"of hierarchies other controllers might be on, each controller had to assume "
"that all other controllers were attached to completely orthogonal "
"hierarchies.  This made it impossible, or at least very cumbersome, for "
"controllers to cooperate with each other."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3231
msgid ""
"In most use cases, putting controllers on hierarchies which are completely "
"orthogonal to each other isn't necessary.  What usually is called for is the "
"ability to have differing levels of granularity depending on the specific "
"controller.  In other words, hierarchy may be collapsed from leaf towards "
"root when viewed from specific controllers.  For example, a given "
"configuration might not care about how memory is distributed beyond a "
"certain level while still wanting to control how CPU cycles are distributed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3242
msgid "Thread Granularity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3244
msgid ""
"cgroup v1 allowed threads of a process to belong to different cgroups. This "
"didn't make sense for some controllers and those controllers ended up "
"implementing different ways to ignore such situations but much more "
"importantly it blurred the line between API exposed to individual "
"applications and system management interface."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3250
msgid ""
"Generally, in-process knowledge is available only to the process itself; "
"thus, unlike service-level organization of processes, categorizing threads "
"of a process requires active participation from the application which owns "
"the target process."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3255
msgid ""
"cgroup v1 had an ambiguously defined delegation model which got abused in "
"combination with thread granularity.  cgroups were delegated to individual "
"applications so that they can create and manage their own sub-hierarchies "
"and control resource distributions along them.  This effectively raised "
"cgroup to the status of a syscall-like API exposed to lay programs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3262
msgid ""
"First of all, cgroup has a fundamentally inadequate interface to be exposed "
"this way.  For a process to access its own knobs, it has to extract the path "
"on the target hierarchy from /proc/self/cgroup, construct the path by "
"appending the name of the knob to the path, open and then read and/or write "
"to it.  This is not only extremely clunky and unusual but also inherently "
"racy.  There is no conventional way to define transaction across the "
"required steps and nothing can guarantee that the process would actually be "
"operating on its own sub-hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3271
msgid ""
"cgroup controllers implemented a number of knobs which would never be "
"accepted as public APIs because they were just adding control knobs to "
"system-management pseudo filesystem.  cgroup ended up with interface knobs "
"which were not properly abstracted or refined and directly revealed kernel "
"internal details.  These knobs got exposed to individual applications "
"through the ill-defined delegation mechanism effectively abusing cgroup as a "
"shortcut to implementing public APIs without going through the required "
"scrutiny."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3280
msgid ""
"This was painful for both userland and kernel.  Userland ended up with "
"misbehaving and poorly abstracted interfaces and kernel exposing and locked "
"into constructs inadvertently."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3286
msgid "Competition Between Inner Nodes and Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3288
msgid ""
"cgroup v1 allowed threads to be in any cgroups which created an interesting "
"problem where threads belonging to a parent cgroup and its children cgroups "
"competed for resources.  This was nasty as two different types of entities "
"competed and there was no obvious way to settle it.  Different controllers "
"did different things."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3294
msgid ""
"The cpu controller considered threads and cgroups as equivalents and mapped "
"nice levels to cgroup weights.  This worked for some cases but fell flat "
"when children wanted to be allocated specific ratios of CPU cycles and the "
"number of internal threads fluctuated - the ratios constantly changed as the "
"number of competing entities fluctuated. There also were other issues.  The "
"mapping from nice level to weight wasn't obvious or universal, and there "
"were various other knobs which simply weren't available for threads."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3303
msgid ""
"The io controller implicitly created a hidden leaf node for each cgroup to "
"host the threads.  The hidden leaf had its own copies of all the knobs with "
"``leaf_`` prefixed.  While this allowed equivalent control over internal "
"threads, it was with serious drawbacks.  It always added an extra layer of "
"nesting which wouldn't be necessary otherwise, made the interface messy and "
"significantly complicated the implementation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3311
msgid ""
"The memory controller didn't have a way to control what happened between "
"internal tasks and child cgroups and the behavior was not clearly defined.  "
"There were attempts to add ad-hoc behaviors and knobs to tailor the behavior "
"to specific workloads which would have led to problems extremely difficult "
"to resolve in the long term."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3317
msgid ""
"Multiple controllers struggled with internal tasks and came up with "
"different ways to deal with it; unfortunately, all the approaches were "
"severely flawed and, furthermore, the widely different behaviors made cgroup "
"as a whole highly inconsistent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3322
msgid ""
"This clearly is a problem which needs to be addressed from cgroup core in a "
"uniform way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3327
msgid "Other Interface Issues"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3329
msgid ""
"cgroup v1 grew without oversight and developed a large number of "
"idiosyncrasies and inconsistencies.  One issue on the cgroup core side was "
"how an empty cgroup was notified - a userland helper binary was forked and "
"executed for each event.  The event delivery wasn't recursive or "
"delegatable.  The limitations of the mechanism also led to in-kernel event "
"delivery filtering mechanism further complicating the interface."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3337
msgid ""
"Controller interfaces were problematic too.  An extreme example is "
"controllers completely ignoring hierarchical organization and treating all "
"cgroups as if they were all located directly under the root cgroup.  Some "
"controllers exposed a large amount of inconsistent implementation details to "
"userland."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3343
msgid ""
"There also was no consistency across controllers.  When a new cgroup was "
"created, some controllers defaulted to not imposing extra restrictions while "
"others disallowed any resource usage until explicitly configured.  "
"Configuration knobs for the same type of control used widely differing "
"naming schemes and formats.  Statistics and information knobs were named "
"arbitrarily and used different formats and units even in the same controller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3351
msgid ""
"cgroup v2 establishes common conventions where appropriate and updates "
"controllers so that they expose minimal and consistent interfaces."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3356
msgid "Controller Issues and Remedies"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3361
msgid ""
"The original lower boundary, the soft limit, is defined as a limit that is "
"per default unset.  As a result, the set of cgroups that global reclaim "
"prefers is opt-in, rather than opt-out.  The costs for optimizing these "
"mostly negative lookups are so high that the implementation, despite its "
"enormous size, does not even provide the basic desirable behavior.  First "
"off, the soft limit has no hierarchical meaning.  All configured groups are "
"organized in a global rbtree and treated like equal peers, regardless where "
"they are located in the hierarchy.  This makes subtree delegation "
"impossible.  Second, the soft limit reclaim pass is so aggressive that it "
"not just introduces high allocation latencies into the system, but also "
"impacts system performance due to overreclaim, to the point where the "
"feature becomes self-defeating."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3375
msgid ""
"The memory.low boundary on the other hand is a top-down allocated reserve.  "
"A cgroup enjoys reclaim protection when it's within its effective low, which "
"makes delegation of subtrees possible. It also enjoys having reclaim "
"pressure proportional to its overage when above its effective low."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3381
msgid ""
"The original high boundary, the hard limit, is defined as a strict limit "
"that can not budge, even if the OOM killer has to be called. But this "
"generally goes against the goal of making the most out of the available "
"memory.  The memory consumption of workloads varies during runtime, and that "
"requires users to overcommit.  But doing that with a strict upper limit "
"requires either a fairly accurate prediction of the working set size or "
"adding slack to the limit.  Since working set size estimation is hard and "
"error prone, and getting it wrong results in OOM kills, most users tend to "
"err on the side of a looser limit and end up wasting precious resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3392
msgid ""
"The memory.high boundary on the other hand can be set much more "
"conservatively.  When hit, it throttles allocations by forcing them into "
"direct reclaim to work off the excess, but it never invokes the OOM killer.  "
"As a result, a high boundary that is chosen too aggressively will not "
"terminate the processes, but instead it will lead to gradual performance "
"degradation.  The user can monitor this and make corrections until the "
"minimal memory footprint that still gives acceptable performance is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3401
msgid ""
"In extreme cases, with many concurrent allocations and a complete breakdown "
"of reclaim progress within the group, the high boundary can be exceeded.  "
"But even then it's mostly better to satisfy the allocation from the slack "
"available in other groups or the rest of the system than killing the group.  "
"Otherwise, memory.max is there to limit this type of spillover and "
"ultimately contain buggy or even malicious applications."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3409
msgid ""
"Setting the original memory.limit_in_bytes below the current usage was "
"subject to a race condition, where concurrent charges could cause the limit "
"setting to fail. memory.max on the other hand will first set the limit to "
"prevent new charges, and then reclaim and OOM kill until the new limit is "
"met - or the task writing to memory.max is killed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3415
msgid ""
"The combined memory+swap accounting and limiting is replaced by real control "
"over swap space."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3418
msgid ""
"The main argument for a combined memory+swap facility in the original cgroup "
"design was that global or parental pressure would always be able to swap all "
"anonymous memory of a child group, regardless of the child's own (possibly "
"untrusted) configuration.  However, untrusted groups can sabotage swapping "
"by other means - such as referencing its anonymous memory in a tight loop - "
"and an admin can not assume full swappability when overcommitting untrusted "
"jobs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3426
msgid ""
"For trusted jobs, on the other hand, a combined counter is not an intuitive "
"userspace interface, and it flies in the face of the idea that cgroup "
"controllers should account and limit specific physical resources.  Swap "
"space is a resource like all others in the system, and that's why unified "
"hierarchy allows distributing it separately."
msgstr ""
