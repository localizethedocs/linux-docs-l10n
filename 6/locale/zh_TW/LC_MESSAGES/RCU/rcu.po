# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../RCU/rcu.rst:4
msgid "RCU Concepts"
msgstr ""

#: ../../../RCU/rcu.rst:6
msgid ""
"The basic idea behind RCU (read-copy update) is to split destructive "
"operations into two parts, one that prevents anyone from seeing the data "
"item being destroyed, and one that actually carries out the destruction. A "
"\"grace period\" must elapse between the two parts, and this grace period "
"must be long enough that any readers accessing the item being deleted have "
"since dropped their references.  For example, an RCU-protected deletion from "
"a linked list would first remove the item from the list, wait for a grace "
"period to elapse, then free the element.  See listRCU.rst for more "
"information on using RCU with linked lists."
msgstr ""

#: ../../../RCU/rcu.rst:17
msgid "Frequently Asked Questions"
msgstr ""

#: ../../../RCU/rcu.rst:19
msgid "Why would anyone want to use RCU?"
msgstr ""

#: ../../../RCU/rcu.rst:21
msgid ""
"The advantage of RCU's two-part approach is that RCU readers need not "
"acquire any locks, perform any atomic instructions, write to shared memory, "
"or (on CPUs other than Alpha) execute any memory barriers.  The fact that "
"these operations are quite expensive on modern CPUs is what gives RCU its "
"performance advantages in read-mostly situations.  The fact that RCU readers "
"need not acquire locks can also greatly simplify deadlock-avoidance code."
msgstr ""

#: ../../../RCU/rcu.rst:29
msgid ""
"How can the updater tell when a grace period has completed if the RCU "
"readers give no indication when they are done?"
msgstr ""

#: ../../../RCU/rcu.rst:32
msgid ""
"Just as with spinlocks, RCU readers are not permitted to block, switch to "
"user-mode execution, or enter the idle loop. Therefore, as soon as a CPU is "
"seen passing through any of these three states, we know that that CPU has "
"exited any previous RCU read-side critical sections.  So, if we remove an "
"item from a linked list, and then wait until all CPUs have switched context, "
"executed in user mode, or executed in the idle loop, we can safely free up "
"that item."
msgstr ""

#: ../../../RCU/rcu.rst:41
msgid ""
"Preemptible variants of RCU (CONFIG_PREEMPT_RCU) get the same effect, but "
"require that the readers manipulate CPU-local counters.  These counters "
"allow limited types of blocking within RCU read-side critical sections.  "
"SRCU also uses CPU-local counters, and permits general blocking within RCU "
"read-side critical sections.  These variants of RCU detect grace periods by "
"sampling these counters."
msgstr ""

#: ../../../RCU/rcu.rst:49
msgid ""
"If I am running on a uniprocessor kernel, which can only do one thing at a "
"time, why should I wait for a grace period?"
msgstr ""

#: ../../../RCU/rcu.rst:52
msgid "See UP.rst for more information."
msgstr ""

#: ../../../RCU/rcu.rst:54
msgid "How can I see where RCU is currently used in the Linux kernel?"
msgstr ""

#: ../../../RCU/rcu.rst:56
msgid ""
"Search for \"rcu_read_lock\", \"rcu_read_unlock\", \"call_rcu\", "
"\"rcu_read_lock_bh\", \"rcu_read_unlock_bh\", \"srcu_read_lock\", "
"\"srcu_read_unlock\", \"synchronize_rcu\", \"synchronize_net\", "
"\"synchronize_srcu\", and the other RCU primitives.  Or grab one of the "
"cscope databases from:"
msgstr ""

#: ../../../RCU/rcu.rst:62
msgid "(http://www.rdrop.com/users/paulmck/RCU/linuxusage/rculocktab.html)."
msgstr ""

#: ../../../RCU/rcu.rst:64
msgid "What guidelines should I follow when writing code that uses RCU?"
msgstr ""

#: ../../../RCU/rcu.rst:66
msgid "See checklist.rst."
msgstr ""

#: ../../../RCU/rcu.rst:68
msgid "Why the name \"RCU\"?"
msgstr ""

#: ../../../RCU/rcu.rst:70
msgid ""
"\"RCU\" stands for \"read-copy update\". listRCU.rst has more information on "
"where this name came from, search for \"read-copy update\" to find it."
msgstr ""

#: ../../../RCU/rcu.rst:74
msgid "I hear that RCU is patented?  What is with that?"
msgstr ""

#: ../../../RCU/rcu.rst:76
msgid ""
"Yes, it is.  There are several known patents related to RCU, search for the "
"string \"Patent\" in Documentation/RCU/RTFP.txt to find them. Of these, one "
"was allowed to lapse by the assignee, and the others have been contributed "
"to the Linux kernel under GPL. Many (but not all) have long since expired. "
"There are now also LGPL implementations of user-level RCU available (https://"
"liburcu.org/)."
msgstr ""

#: ../../../RCU/rcu.rst:84
msgid "I hear that RCU needs work in order to support realtime kernels?"
msgstr ""

#: ../../../RCU/rcu.rst:86
msgid ""
"Realtime-friendly RCU are enabled via the CONFIG_PREEMPTION kernel "
"configuration parameter."
msgstr ""

#: ../../../RCU/rcu.rst:89
msgid "Where can I find more information on RCU?"
msgstr ""

#: ../../../RCU/rcu.rst:91
msgid ""
"See the Documentation/RCU/RTFP.txt file. Or point your browser at (https://"
"docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/"
"edit) or (https://docs.google.com/document/"
"d/1GCdQC8SDbb54W1shjEXqGZ0Rq8a6kIeYutdSIajfpLA/edit?usp=sharing)."
msgstr ""
