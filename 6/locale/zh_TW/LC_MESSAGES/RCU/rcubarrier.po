# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../RCU/rcubarrier.rst:4
msgid "RCU and Unloadable Modules"
msgstr ""

#: ../../../RCU/rcubarrier.rst:6
msgid ""
"[Originally published in LWN Jan. 14, 2007: http://lwn.net/Articles/217484/]"
msgstr ""

#: ../../../RCU/rcubarrier.rst:8
msgid ""
"RCU updaters sometimes use call_rcu() to initiate an asynchronous wait for a "
"grace period to elapse.  This primitive takes a pointer to an rcu_head "
"struct placed within the RCU-protected data structure and another pointer to "
"a function that may be invoked later to free that structure. Code to delete "
"an element p from the linked list from IRQ context might then be as follows::"
msgstr ""

#: ../../../RCU/rcubarrier.rst:18
msgid ""
"Since call_rcu() never blocks, this code can safely be used from within IRQ "
"context. The function p_callback() might be defined as follows::"
msgstr ""

#: ../../../RCU/rcubarrier.rst:30
msgid "Unloading Modules That Use call_rcu()"
msgstr ""

#: ../../../RCU/rcubarrier.rst:32
msgid ""
"But what if the p_callback() function is defined in an unloadable module?"
msgstr ""

#: ../../../RCU/rcubarrier.rst:34
msgid ""
"If we unload the module while some RCU callbacks are pending, the CPUs "
"executing these callbacks are going to be severely disappointed when they "
"are later invoked, as fancifully depicted at http://lwn.net/images/ns/kernel/"
"rcu-drop.jpg."
msgstr ""

#: ../../../RCU/rcubarrier.rst:39
msgid ""
"We could try placing a synchronize_rcu() in the module-exit code path, but "
"this is not sufficient. Although synchronize_rcu() does wait for a grace "
"period to elapse, it does not wait for the callbacks to complete."
msgstr ""

#: ../../../RCU/rcubarrier.rst:43
msgid ""
"One might be tempted to try several back-to-back synchronize_rcu() calls, "
"but this is still not guaranteed to work. If there is a very heavy RCU-"
"callback load, then some of the callbacks might be deferred in order to "
"allow other processing to proceed. For but one example, such deferral is "
"required in realtime kernels in order to avoid excessive scheduling "
"latencies."
msgstr ""

#: ../../../RCU/rcubarrier.rst:52
msgid "rcu_barrier()"
msgstr ""

#: ../../../RCU/rcubarrier.rst:54
msgid ""
"This situation can be handled by the rcu_barrier() primitive.  Rather than "
"waiting for a grace period to elapse, rcu_barrier() waits for all "
"outstanding RCU callbacks to complete.  Please note that rcu_barrier() does "
"**not** imply synchronize_rcu(), in particular, if there are no RCU "
"callbacks queued anywhere, rcu_barrier() is within its rights to return "
"immediately, without waiting for anything, let alone a grace period."
msgstr ""

#: ../../../RCU/rcubarrier.rst:61
msgid "Pseudo-code using rcu_barrier() is as follows:"
msgstr ""

#: ../../../RCU/rcubarrier.rst:63
msgid "Prevent any new RCU callbacks from being posted."
msgstr ""

#: ../../../RCU/rcubarrier.rst:64
msgid "Execute rcu_barrier()."
msgstr ""

#: ../../../RCU/rcubarrier.rst:65
msgid "Allow the module to be unloaded."
msgstr ""

#: ../../../RCU/rcubarrier.rst:67
msgid ""
"There is also an srcu_barrier() function for SRCU, and you of course must "
"match the flavor of srcu_barrier() with that of call_srcu(). If your module "
"uses multiple srcu_struct structures, then it must also use multiple "
"invocations of srcu_barrier() when unloading that module. For example, if it "
"uses call_rcu(), call_srcu() on srcu_struct_1, and call_srcu() on "
"srcu_struct_2, then the following three lines of code will be required when "
"unloading::"
msgstr ""

#: ../../../RCU/rcubarrier.rst:79
msgid ""
"If latency is of the essence, workqueues could be used to run these three "
"functions concurrently."
msgstr ""

#: ../../../RCU/rcubarrier.rst:82
msgid ""
"An ancient version of the rcutorture module makes use of rcu_barrier() in "
"its exit function as follows::"
msgstr ""

#: ../../../RCU/rcubarrier.rst:149
msgid ""
"Line 6 sets a global variable that prevents any RCU callbacks from re-"
"posting themselves. This will not be necessary in most cases, since RCU "
"callbacks rarely include calls to call_rcu(). However, the rcutorture module "
"is an exception to this rule, and therefore needs to set this global "
"variable."
msgstr ""

#: ../../../RCU/rcubarrier.rst:155
msgid ""
"Lines 7-50 stop all the kernel tasks associated with the rcutorture module. "
"Therefore, once execution reaches line 53, no more rcutorture RCU callbacks "
"will be posted. The rcu_barrier() call on line 53 waits for any pre-existing "
"callbacks to complete."
msgstr ""

#: ../../../RCU/rcubarrier.rst:160
msgid ""
"Then lines 55-62 print status and do operation-specific cleanup, and then "
"return, permitting the module-unload operation to be completed."
msgstr ""

#: ../../../RCU/rcubarrier.rst:165 ../../../RCU/rcubarrier.rst:295
msgid "Quick Quiz #1:"
msgstr ""

#: ../../../RCU/rcubarrier.rst:166 ../../../RCU/rcubarrier.rst:296
msgid "Is there any other situation where rcu_barrier() might be required?"
msgstr ""

#: ../../../RCU/rcubarrier.rst:169
msgid ":ref:`Answer to Quick Quiz #1 <answer_rcubarrier_quiz_1>`"
msgstr ""

#: ../../../RCU/rcubarrier.rst:171
msgid ""
"Your module might have additional complications. For example, if your module "
"invokes call_rcu() from timers, you will need to first refrain from posting "
"new timers, cancel (or wait for) all the already-posted timers, and only "
"then invoke rcu_barrier() to wait for any remaining RCU callbacks to "
"complete."
msgstr ""

#: ../../../RCU/rcubarrier.rst:177
msgid ""
"Of course, if your module uses call_rcu(), you will need to invoke "
"rcu_barrier() before unloading.  Similarly, if your module uses call_srcu(), "
"you will need to invoke srcu_barrier() before unloading, and on the same "
"srcu_struct structure.  If your module uses call_rcu() **and** call_srcu(), "
"then (as noted above) you will need to invoke rcu_barrier() **and** "
"srcu_barrier()."
msgstr ""

#: ../../../RCU/rcubarrier.rst:186
msgid "Implementing rcu_barrier()"
msgstr ""

#: ../../../RCU/rcubarrier.rst:188
msgid ""
"Dipankar Sarma's implementation of rcu_barrier() makes use of the fact that "
"RCU callbacks are never reordered once queued on one of the per-CPU queues. "
"His implementation queues an RCU callback on each of the per-CPU callback "
"queues, and then waits until they have all started executing, at which "
"point, all earlier RCU callbacks are guaranteed to have completed."
msgstr ""

#: ../../../RCU/rcubarrier.rst:194
msgid "The original code for rcu_barrier() was roughly as follows::"
msgstr ""

#: ../../../RCU/rcubarrier.rst:210
msgid ""
"Line 3 verifies that the caller is in process context, and lines 5 and 12 "
"use rcu_barrier_mutex to ensure that only one rcu_barrier() is using the "
"global completion and counters at a time, which are initialized on lines 6 "
"and 7. Line 8 causes each CPU to invoke rcu_barrier_func(), which is shown "
"below. Note that the final \"1\" in on_each_cpu()'s argument list ensures "
"that all the calls to rcu_barrier_func() will have completed before "
"on_each_cpu() returns. Line 9 removes the initial count from "
"rcu_barrier_cpu_count, and if this count is now zero, line 10 finalizes the "
"completion, which prevents line 11 from blocking.  Either way, line 11 then "
"waits (if needed) for the completion."
msgstr ""

#: ../../../RCU/rcubarrier.rst:223 ../../../RCU/rcubarrier.rst:315
msgid "Quick Quiz #2:"
msgstr ""

#: ../../../RCU/rcubarrier.rst:224 ../../../RCU/rcubarrier.rst:316
msgid ""
"Why doesn't line 8 initialize rcu_barrier_cpu_count to zero, thereby "
"avoiding the need for lines 9 and 10?"
msgstr ""

#: ../../../RCU/rcubarrier.rst:227
msgid ":ref:`Answer to Quick Quiz #2 <answer_rcubarrier_quiz_2>`"
msgstr ""

#: ../../../RCU/rcubarrier.rst:229
msgid ""
"This code was rewritten in 2008 and several times thereafter, but this still "
"gives the general idea."
msgstr ""

#: ../../../RCU/rcubarrier.rst:232
msgid ""
"The rcu_barrier_func() runs on each CPU, where it invokes call_rcu() to post "
"an RCU callback, as follows::"
msgstr ""

#: ../../../RCU/rcubarrier.rst:246
msgid ""
"Lines 3 and 4 locate RCU's internal per-CPU rcu_data structure, which "
"contains the struct rcu_head that needed for the later call to call_rcu(). "
"Line 7 picks up a pointer to this struct rcu_head, and line 8 increments the "
"global counter. This counter will later be decremented by the callback. Line "
"9 then registers the rcu_barrier_callback() on the current CPU's queue."
msgstr ""

#: ../../../RCU/rcubarrier.rst:253
msgid ""
"The rcu_barrier_callback() function simply atomically decrements the "
"rcu_barrier_cpu_count variable and finalizes the completion when it reaches "
"zero, as follows::"
msgstr ""

#: ../../../RCU/rcubarrier.rst:265 ../../../RCU/rcubarrier.rst:346
msgid "Quick Quiz #3:"
msgstr ""

#: ../../../RCU/rcubarrier.rst:266 ../../../RCU/rcubarrier.rst:347
msgid ""
"What happens if CPU 0's rcu_barrier_func() executes immediately (thus "
"incrementing rcu_barrier_cpu_count to the value one), but the other CPU's "
"rcu_barrier_func() invocations are delayed for a full grace period? Couldn't "
"this result in rcu_barrier() returning prematurely?"
msgstr ""

#: ../../../RCU/rcubarrier.rst:272
msgid ":ref:`Answer to Quick Quiz #3 <answer_rcubarrier_quiz_3>`"
msgstr ""

#: ../../../RCU/rcubarrier.rst:274
msgid ""
"The current rcu_barrier() implementation is more complex, due to the need to "
"avoid disturbing idle CPUs (especially on battery-powered systems) and the "
"need to minimally disturb non-idle CPUs in real-time systems. In addition, a "
"great many optimizations have been applied.  However, the code above "
"illustrates the concepts."
msgstr ""

#: ../../../RCU/rcubarrier.rst:282
msgid "rcu_barrier() Summary"
msgstr ""

#: ../../../RCU/rcubarrier.rst:284
msgid ""
"The rcu_barrier() primitive is used relatively infrequently, since most code "
"using RCU is in the core kernel rather than in modules. However, if you are "
"using RCU from an unloadable module, you need to use rcu_barrier() so that "
"your module may be safely unloaded."
msgstr ""

#: ../../../RCU/rcubarrier.rst:291
msgid "Answers to Quick Quizzes"
msgstr ""

#: ../../../RCU/rcubarrier.rst:299 ../../../RCU/rcubarrier.rst:319
#: ../../../RCU/rcubarrier.rst:353
msgid "Answer:"
msgstr ""

#: ../../../RCU/rcubarrier.rst:300
msgid ""
"Interestingly enough, rcu_barrier() was not originally implemented for "
"module unloading. Nikita Danilov was using RCU in a filesystem, which "
"resulted in a similar situation at filesystem-unmount time. Dipankar Sarma "
"coded up rcu_barrier() in response, so that Nikita could invoke it during "
"the filesystem-unmount process."
msgstr ""

#: ../../../RCU/rcubarrier.rst:307
msgid ""
"Much later, yours truly hit the RCU module-unload problem when implementing "
"rcutorture, and found that rcu_barrier() solves this problem as well."
msgstr ""

#: ../../../RCU/rcubarrier.rst:311
msgid ":ref:`Back to Quick Quiz #1 <rcubarrier_quiz_1>`"
msgstr ""

#: ../../../RCU/rcubarrier.rst:320
msgid ""
"Suppose that the on_each_cpu() function shown on line 8 was delayed, so that "
"CPU 0's rcu_barrier_func() executed and the corresponding grace period "
"elapsed, all before CPU 1's rcu_barrier_func() started executing.  This "
"would result in rcu_barrier_cpu_count being decremented to zero, so that "
"line 11's wait_for_completion() would return immediately, failing to wait "
"for CPU 1's callbacks to be invoked."
msgstr ""

#: ../../../RCU/rcubarrier.rst:328
msgid ""
"Note that this was not a problem when the rcu_barrier() code was first added "
"back in 2005.  This is because on_each_cpu() disables preemption, which "
"acted as an RCU read-side critical section, thus preventing CPU 0's grace "
"period from completing until on_each_cpu() had dealt with all of the CPUs."
msgstr ""

#: ../../../RCU/rcubarrier.rst:334
msgid ""
"However, with the RCU flavor consolidation around v4.20, this possibility "
"was once again ruled out, because the consolidated RCU once again waits on "
"nonpreemptible regions of code."
msgstr ""

#: ../../../RCU/rcubarrier.rst:338
msgid ""
"Nevertheless, that extra count might still be a good idea. Relying on these "
"sort of accidents of implementation can result in later surprise bugs when "
"the implementation changes."
msgstr ""

#: ../../../RCU/rcubarrier.rst:342
msgid ":ref:`Back to Quick Quiz #2 <rcubarrier_quiz_2>`"
msgstr ""

#: ../../../RCU/rcubarrier.rst:354
msgid ""
"This cannot happen. The reason is that on_each_cpu() has its last argument, "
"the wait flag, set to \"1\". This flag is passed through to "
"smp_call_function() and further to smp_call_function_on_cpu(), causing this "
"latter to spin until the cross-CPU invocation of rcu_barrier_func() has "
"completed. This by itself would prevent a grace period from completing on "
"non-CONFIG_PREEMPTION kernels, since each CPU must undergo a context switch "
"(or other quiescent state) before the grace period can complete. However, "
"this is of no use in CONFIG_PREEMPTION kernels."
msgstr ""

#: ../../../RCU/rcubarrier.rst:364
msgid ""
"Therefore, on_each_cpu() disables preemption across its call to "
"smp_call_function() and also across the local call to rcu_barrier_func(). "
"Because recent RCU implementations treat preemption-disabled regions of code "
"as RCU read-side critical sections, this prevents grace periods from "
"completing. This means that all CPUs have executed rcu_barrier_func() before "
"the first rcu_barrier_callback() can possibly execute, in turn preventing "
"rcu_barrier_cpu_count from prematurely reaching zero."
msgstr ""

#: ../../../RCU/rcubarrier.rst:373
msgid ""
"But if on_each_cpu() ever decides to forgo disabling preemption, as might "
"well happen due to real-time latency considerations, initializing "
"rcu_barrier_cpu_count to one will save the day."
msgstr ""

#: ../../../RCU/rcubarrier.rst:377
msgid ":ref:`Back to Quick Quiz #3 <rcubarrier_quiz_3>`"
msgstr ""
