# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../RCU/whatisRCU.rst:4
msgid "What is RCU?  --  \"Read, Copy, Update\""
msgstr ""

#: ../../../RCU/whatisRCU.rst:6
msgid ""
"Please note that the \"What is RCU?\" LWN series is an excellent place to "
"start learning about RCU:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:9
msgid "1.    What is RCU, Fundamentally?  https://lwn.net/Articles/262464/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:10
msgid "2.    What is RCU? Part 2: Usage   https://lwn.net/Articles/263130/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:11
msgid "3.    RCU part 3: the RCU API      https://lwn.net/Articles/264090/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:12
msgid "4.    The RCU API, 2010 Edition    https://lwn.net/Articles/418853/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:13
msgid "2010 Big API Table           https://lwn.net/Articles/419086/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:14
msgid "5.    The RCU API, 2014 Edition    https://lwn.net/Articles/609904/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:15
msgid "2014 Big API Table           https://lwn.net/Articles/609973/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:16
msgid "6.    The RCU API, 2019 Edition    https://lwn.net/Articles/777036/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:17
msgid "2019 Big API Table           https://lwn.net/Articles/777165/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:18
msgid "7.    The RCU API, 2024 Edition    https://lwn.net/Articles/988638/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:19
msgid "2024 Background Information  https://lwn.net/Articles/988641/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:20
msgid "2024 Big API Table           https://lwn.net/Articles/988666/"
msgstr ""

#: ../../../RCU/whatisRCU.rst:22
msgid "For those preferring video:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:24
msgid ""
"1.    Unraveling RCU Mysteries: Fundamentals          https://www."
"linuxfoundation.org/webinars/unraveling-rcu-usage-mysteries"
msgstr ""

#: ../../../RCU/whatisRCU.rst:25
msgid ""
"2.    Unraveling RCU Mysteries: Additional Use Cases  https://www."
"linuxfoundation.org/webinars/unraveling-rcu-usage-mysteries-additional-use-"
"cases"
msgstr ""

#: ../../../RCU/whatisRCU.rst:28
msgid "What is RCU?"
msgstr ""

#: ../../../RCU/whatisRCU.rst:30
msgid ""
"RCU is a synchronization mechanism that was added to the Linux kernel during "
"the 2.5 development effort that is optimized for read-mostly situations.  "
"Although RCU is actually quite simple, making effective use of it requires "
"you to think differently about your code.  Another part of the problem is "
"the mistaken assumption that there is \"one true way\" to describe and to "
"use RCU.  Instead, the experience has been that different people must take "
"different paths to arrive at an understanding of RCU, depending on their "
"experiences and use cases.  This document provides several different paths, "
"as follows:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:40
msgid ":ref:`1.        RCU OVERVIEW <1_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:42
msgid ":ref:`2.        WHAT IS RCU'S CORE API? <2_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:44
msgid ""
":ref:`3.        WHAT ARE SOME EXAMPLE USES OF CORE RCU API? <3_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:46
msgid ":ref:`4.        WHAT IF MY UPDATING THREAD CANNOT BLOCK? <4_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:48
msgid ""
":ref:`5.        WHAT ARE SOME SIMPLE IMPLEMENTATIONS OF RCU? <5_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:50
msgid ":ref:`6.        ANALOGY WITH READER-WRITER LOCKING <6_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:52
msgid ":ref:`7.        ANALOGY WITH REFERENCE COUNTING <7_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:54
msgid ":ref:`8.        FULL LIST OF RCU APIs <8_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:56
msgid ":ref:`9.        ANSWERS TO QUICK QUIZZES <9_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:58
msgid ""
"People who prefer starting with a conceptual overview should focus on "
"Section 1, though most readers will profit by reading this section at some "
"point.  People who prefer to start with an API that they can then experiment "
"with should focus on Section 2.  People who prefer to start with example "
"uses should focus on Sections 3 and 4.  People who need to understand the "
"RCU implementation should focus on Section 5, then dive into the kernel "
"source code.  People who reason best by analogy should focus on Section 6 "
"and 7.  Section 8 serves as an index to the docbook API documentation, and "
"Section 9 is the traditional answer key."
msgstr ""

#: ../../../RCU/whatisRCU.rst:68
msgid ""
"So, start with the section that makes the most sense to you and your "
"preferred method of learning.  If you need to know everything about "
"everything, feel free to read the whole thing -- but if you are really that "
"type of person, you have perused the source code and will therefore never "
"need this document anyway.  ;-)"
msgstr ""

#: ../../../RCU/whatisRCU.rst:77
msgid "1.  RCU OVERVIEW"
msgstr ""

#: ../../../RCU/whatisRCU.rst:79
msgid ""
"The basic idea behind RCU is to split updates into \"removal\" and "
"\"reclamation\" phases.  The removal phase removes references to data items "
"within a data structure (possibly by replacing them with references to new "
"versions of these data items), and can run concurrently with readers. The "
"reason that it is safe to run the removal phase concurrently with readers is "
"the semantics of modern CPUs guarantee that readers will see either the old "
"or the new version of the data structure rather than a partially updated "
"reference.  The reclamation phase does the work of reclaiming (e.g., "
"freeing) the data items removed from the data structure during the removal "
"phase.  Because reclaiming data items can disrupt any readers concurrently "
"referencing those data items, the reclamation phase must not start until "
"readers no longer hold references to those data items."
msgstr ""

#: ../../../RCU/whatisRCU.rst:92
msgid ""
"Splitting the update into removal and reclamation phases permits the updater "
"to perform the removal phase immediately, and to defer the reclamation phase "
"until all readers active during the removal phase have completed, either by "
"blocking until they finish or by registering a callback that is invoked "
"after they finish.  Only readers that are active during the removal phase "
"need be considered, because any reader starting after the removal phase will "
"be unable to gain a reference to the removed data items, and therefore "
"cannot be disrupted by the reclamation phase."
msgstr ""

#: ../../../RCU/whatisRCU.rst:101
msgid "So the typical RCU update sequence goes something like the following:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:103
msgid ""
"Remove pointers to a data structure, so that subsequent readers cannot gain "
"a reference to it."
msgstr ""

#: ../../../RCU/whatisRCU.rst:106
msgid ""
"Wait for all previous readers to complete their RCU read-side critical "
"sections."
msgstr ""

#: ../../../RCU/whatisRCU.rst:109
msgid ""
"At this point, there cannot be any readers who hold references to the data "
"structure, so it now may safely be reclaimed (e.g., kfree()d)."
msgstr ""

#: ../../../RCU/whatisRCU.rst:113
msgid ""
"Step (b) above is the key idea underlying RCU's deferred destruction. The "
"ability to wait until all readers are done allows RCU readers to use much "
"lighter-weight synchronization, in some cases, absolutely no synchronization "
"at all.  In contrast, in more conventional lock-based schemes, readers must "
"use heavy-weight synchronization in order to prevent an updater from "
"deleting the data structure out from under them. This is because lock-based "
"updaters typically update data items in place, and must therefore exclude "
"readers.  In contrast, RCU-based updaters typically take advantage of the "
"fact that writes to single aligned pointers are atomic on modern CPUs, "
"allowing atomic insertion, removal, and replacement of data items in a "
"linked structure without disrupting readers.  Concurrent RCU readers can "
"then continue accessing the old versions, and can dispense with the atomic "
"operations, memory barriers, and communications cache misses that are so "
"expensive on present-day SMP computer systems, even in absence of lock "
"contention."
msgstr ""

#: ../../../RCU/whatisRCU.rst:129
msgid ""
"In the three-step procedure shown above, the updater is performing both the "
"removal and the reclamation step, but it is often helpful for an entirely "
"different thread to do the reclamation, as is in fact the case in the Linux "
"kernel's directory-entry cache (dcache).  Even if the same thread performs "
"both the update step (step (a) above) and the reclamation step (step (c) "
"above), it is often helpful to think of them separately. For example, RCU "
"readers and updaters need not communicate at all, but RCU provides implicit "
"low-overhead communication between readers and reclaimers, namely, in step "
"(b) above."
msgstr ""

#: ../../../RCU/whatisRCU.rst:139
msgid ""
"So how the heck can a reclaimer tell when a reader is done, given that "
"readers are not doing any sort of synchronization operations??? Read on to "
"learn about how RCU's API makes this easy."
msgstr ""

#: ../../../RCU/whatisRCU.rst:146
msgid "2.  WHAT IS RCU'S CORE API?"
msgstr ""

#: ../../../RCU/whatisRCU.rst:148
msgid "The core RCU API is quite small:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:150 ../../../RCU/whatisRCU.rst:165
msgid "rcu_read_lock()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:151 ../../../RCU/whatisRCU.rst:186
msgid "rcu_read_unlock()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:152
msgid "synchronize_rcu() / call_rcu()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:153 ../../../RCU/whatisRCU.rst:253
msgid "rcu_assign_pointer()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:154 ../../../RCU/whatisRCU.rst:279
msgid "rcu_dereference()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:156
msgid ""
"There are many other members of the RCU API, but the rest can be expressed "
"in terms of these five, though most implementations instead express "
"synchronize_rcu() in terms of the call_rcu() callback API."
msgstr ""

#: ../../../RCU/whatisRCU.rst:160
msgid ""
"The five core RCU APIs are described below, the other 18 will be enumerated "
"later.  See the kernel docbook documentation for more info, or look directly "
"at the function header comments."
msgstr ""

#: ../../../RCU/whatisRCU.rst:166
msgid "void rcu_read_lock(void);"
msgstr ""

#: ../../../RCU/whatisRCU.rst:168
msgid ""
"This temporal primitive is used by a reader to inform the reclaimer that the "
"reader is entering an RCU read-side critical section.  It is illegal to "
"block while in an RCU read-side critical section, though kernels built with "
"CONFIG_PREEMPT_RCU can preempt RCU read-side critical sections.  Any RCU-"
"protected data structure accessed during an RCU read-side critical section "
"is guaranteed to remain unreclaimed for the full duration of that critical "
"section.  Reference counts may be used in conjunction with RCU to maintain "
"longer-term references to data structures."
msgstr ""

#: ../../../RCU/whatisRCU.rst:178
msgid ""
"Note that anything that disables bottom halves, preemption, or interrupts "
"also enters an RCU read-side critical section. Acquiring a spinlock also "
"enters an RCU read-side critical sections, even for spinlocks that do not "
"disable preemption, as is the case in kernels built with "
"CONFIG_PREEMPT_RT=y. Sleeplocks do *not* enter RCU read-side critical "
"sections."
msgstr ""

#: ../../../RCU/whatisRCU.rst:187
msgid "void rcu_read_unlock(void);"
msgstr ""

#: ../../../RCU/whatisRCU.rst:189
msgid ""
"This temporal primitives is used by a reader to inform the reclaimer that "
"the reader is exiting an RCU read-side critical section.  Anything that "
"enables bottom halves, preemption, or interrupts also exits an RCU read-side "
"critical section. Releasing a spinlock also exits an RCU read-side critical "
"section."
msgstr ""

#: ../../../RCU/whatisRCU.rst:195
msgid ""
"Note that RCU read-side critical sections may be nested and/or overlapping."
msgstr ""

#: ../../../RCU/whatisRCU.rst:199
msgid "synchronize_rcu()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:200
msgid "void synchronize_rcu(void);"
msgstr ""

#: ../../../RCU/whatisRCU.rst:202
msgid ""
"This temporal primitive marks the end of updater code and the beginning of "
"reclaimer code.  It does this by blocking until all pre-existing RCU read-"
"side critical sections on all CPUs have completed.  Note that "
"synchronize_rcu() will **not** necessarily wait for any subsequent RCU read-"
"side critical sections to complete.  For example, consider the following "
"sequence of events::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:219
msgid ""
"To reiterate, synchronize_rcu() waits only for ongoing RCU read-side "
"critical sections to complete, not necessarily for any that begin after "
"synchronize_rcu() is invoked."
msgstr ""

#: ../../../RCU/whatisRCU.rst:223
msgid ""
"Of course, synchronize_rcu() does not necessarily return **immediately** "
"after the last pre-existing RCU read-side critical section completes.  For "
"one thing, there might well be scheduling delays.  For another thing, many "
"RCU implementations process requests in batches in order to improve "
"efficiencies, which can further delay synchronize_rcu()."
msgstr ""

#: ../../../RCU/whatisRCU.rst:230
msgid ""
"Since synchronize_rcu() is the API that must figure out when readers are "
"done, its implementation is key to RCU.  For RCU to be useful in all but the "
"most read-intensive situations, synchronize_rcu()'s overhead must also be "
"quite small."
msgstr ""

#: ../../../RCU/whatisRCU.rst:235
msgid ""
"The call_rcu() API is an asynchronous callback form of synchronize_rcu(), "
"and is described in more detail in a later section.  Instead of blocking, it "
"registers a function and argument which are invoked after all ongoing RCU "
"read-side critical sections have completed.  This callback variant is "
"particularly useful in situations where it is illegal to block or where "
"update-side performance is critically important."
msgstr ""

#: ../../../RCU/whatisRCU.rst:243
msgid ""
"However, the call_rcu() API should not be used lightly, as use of the "
"synchronize_rcu() API generally results in simpler code. In addition, the "
"synchronize_rcu() API has the nice property of automatically limiting update "
"rate should grace periods be delayed.  This property results in system "
"resilience in face of denial-of-service attacks.  Code using call_rcu() "
"should limit update rate in order to gain this same sort of resilience.  See "
"checklist.rst for some approaches to limiting the update rate."
msgstr ""

#: ../../../RCU/whatisRCU.rst:254
msgid "void rcu_assign_pointer(p, typeof(p) v);"
msgstr ""

#: ../../../RCU/whatisRCU.rst:256
msgid ""
"Yes, rcu_assign_pointer() **is** implemented as a macro, though it would be "
"cool to be able to declare a function in this manner. (And there has been "
"some discussion of adding overloaded functions to the C language, so who "
"knows?)"
msgstr ""

#: ../../../RCU/whatisRCU.rst:261
msgid ""
"The updater uses this spatial macro to assign a new value to an RCU-"
"protected pointer, in order to safely communicate the change in value from "
"the updater to the reader.  This is a spatial (as opposed to temporal) "
"macro.  It does not evaluate to an rvalue, but it does provide any compiler "
"directives and memory-barrier instructions required for a given compile or "
"CPU architecture. Its ordering properties are that of a store-release "
"operation, that is, any prior loads and stores required to initialize the "
"structure are ordered before the store that publishes the pointer to that "
"structure."
msgstr ""

#: ../../../RCU/whatisRCU.rst:272
msgid ""
"Perhaps just as important, rcu_assign_pointer() serves to document (1) which "
"pointers are protected by RCU and (2) the point at which a given structure "
"becomes accessible to other CPUs.  That said, rcu_assign_pointer() is most "
"frequently used indirectly, via the _rcu list-manipulation primitives such "
"as list_add_rcu()."
msgstr ""

#: ../../../RCU/whatisRCU.rst:280
msgid "typeof(p) rcu_dereference(p);"
msgstr ""

#: ../../../RCU/whatisRCU.rst:282
msgid ""
"Like rcu_assign_pointer(), rcu_dereference() must be implemented as a macro."
msgstr ""

#: ../../../RCU/whatisRCU.rst:285
msgid ""
"The reader uses the spatial rcu_dereference() macro to fetch an RCU-"
"protected pointer, which returns a value that may then be safely "
"dereferenced.  Note that rcu_dereference() does not actually dereference the "
"pointer, instead, it protects the pointer for later dereferencing.  It also "
"executes any needed memory-barrier instructions for a given CPU "
"architecture.  Currently, only Alpha needs memory barriers within "
"rcu_dereference() -- on other CPUs, it compiles to a volatile load.  "
"However, no mainstream C compilers respect address dependencies, so "
"rcu_dereference() uses volatile casts, which, in combination with the coding "
"guidelines listed in rcu_dereference.rst, prevent current compilers from "
"breaking these dependencies."
msgstr ""

#: ../../../RCU/whatisRCU.rst:299
msgid ""
"Common coding practice uses rcu_dereference() to copy an RCU-protected "
"pointer to a local variable, then dereferences this local variable, for "
"example as follows::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:306
msgid ""
"However, in this case, one could just as easily combine these into one "
"statement::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:311
msgid ""
"If you are going to be fetching multiple fields from the RCU-protected "
"structure, using the local variable is of course preferred.  Repeated "
"rcu_dereference() calls look ugly, do not guarantee that the same pointer "
"will be returned if an update happened while in the critical section, and "
"incur unnecessary overhead on Alpha CPUs."
msgstr ""

#: ../../../RCU/whatisRCU.rst:318
msgid ""
"Note that the value returned by rcu_dereference() is valid only within the "
"enclosing RCU read-side critical section [1]_. For example, the following is "
"**not** legal::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:330
msgid ""
"Holding a reference from one RCU read-side critical section to another is "
"just as illegal as holding a reference from one lock-based critical section "
"to another!  Similarly, using a reference outside of the critical section in "
"which it was acquired is just as illegal as doing so with normal locking."
msgstr ""

#: ../../../RCU/whatisRCU.rst:337
msgid ""
"As with rcu_assign_pointer(), an important function of rcu_dereference() is "
"to document which pointers are protected by RCU, in particular, flagging a "
"pointer that is subject to changing at any time, including immediately after "
"the rcu_dereference(). And, again like rcu_assign_pointer(), "
"rcu_dereference() is typically used indirectly, via the _rcu list-"
"manipulation primitives, such as list_for_each_entry_rcu() [2]_."
msgstr ""

#: ../../../RCU/whatisRCU.rst:345
msgid ""
"The variant rcu_dereference_protected() can be used outside of an RCU read-"
"side critical section as long as the usage is protected by locks acquired by "
"the update-side code.  This variant avoids the lockdep warning that would "
"happen when using (for example) rcu_dereference() without rcu_read_lock() "
"protection. Using rcu_dereference_protected() also has the advantage of "
"permitting compiler optimizations that rcu_dereference() must prohibit.  The "
"rcu_dereference_protected() variant takes a lockdep expression to indicate "
"which locks must be acquired by the caller. If the indicated protection is "
"not provided, a lockdep splat is emitted.  See Design/Requirements/"
"Requirements.rst and the API's code comments for more details and example "
"usage."
msgstr ""

#: ../../../RCU/whatisRCU.rst:358
msgid ""
"If the list_for_each_entry_rcu() instance might be used by update-side code "
"as well as by RCU readers, then an additional lockdep expression can be "
"added to its list of arguments. For example, given an additional "
"\"lock_is_held(&mylock)\" argument, the RCU lockdep code would complain only "
"if this instance was invoked outside of an RCU read-side critical section "
"and without the protection of mylock."
msgstr ""

#: ../../../RCU/whatisRCU.rst:366
msgid ""
"The following diagram shows how each API communicates among the reader, "
"updater, and reclaimer. ::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:390
msgid ""
"The RCU infrastructure observes the temporal sequence of rcu_read_lock(), "
"rcu_read_unlock(), synchronize_rcu(), and call_rcu() invocations in order to "
"determine when (1) synchronize_rcu() invocations may return to their callers "
"and (2) call_rcu() callbacks may be invoked.  Efficient implementations of "
"the RCU infrastructure make heavy use of batching in order to amortize their "
"overhead over many uses of the corresponding APIs. The rcu_assign_pointer() "
"and rcu_dereference() invocations communicate spatial changes via stores to "
"and loads from the RCU-protected pointer in question."
msgstr ""

#: ../../../RCU/whatisRCU.rst:400
msgid ""
"There are at least three flavors of RCU usage in the Linux kernel. The "
"diagram above shows the most common one. On the updater side, the "
"rcu_assign_pointer(), synchronize_rcu() and call_rcu() primitives used are "
"the same for all three flavors. However for protection (on the reader side), "
"the primitives used vary depending on the flavor:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:406
msgid "rcu_read_lock() / rcu_read_unlock() rcu_dereference()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:409
msgid ""
"rcu_read_lock_bh() / rcu_read_unlock_bh() local_bh_disable() / "
"local_bh_enable() rcu_dereference_bh()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:413
msgid ""
"rcu_read_lock_sched() / rcu_read_unlock_sched() preempt_disable() / "
"preempt_enable() local_irq_save() / local_irq_restore() hardirq enter / "
"hardirq exit NMI enter / NMI exit rcu_dereference_sched()"
msgstr ""

#: ../../../RCU/whatisRCU.rst:420
msgid "These three flavors are used as follows:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:422
msgid "RCU applied to normal data structures."
msgstr ""

#: ../../../RCU/whatisRCU.rst:424
msgid ""
"RCU applied to networking data structures that may be subjected to remote "
"denial-of-service attacks."
msgstr ""

#: ../../../RCU/whatisRCU.rst:427
msgid "RCU applied to scheduler and interrupt/NMI-handler tasks."
msgstr ""

#: ../../../RCU/whatisRCU.rst:429
msgid ""
"Again, most uses will be of (a).  The (b) and (c) cases are important for "
"specialized uses, but are relatively uncommon.  The SRCU, RCU-Tasks, RCU-"
"Tasks-Rude, and RCU-Tasks-Trace have similar relationships among their "
"assorted primitives."
msgstr ""

#: ../../../RCU/whatisRCU.rst:437
msgid "3.  WHAT ARE SOME EXAMPLE USES OF CORE RCU API?"
msgstr ""

#: ../../../RCU/whatisRCU.rst:439
msgid ""
"This section shows a simple use of the core RCU API to protect a global "
"pointer to a dynamically allocated structure.  More-typical uses of RCU may "
"be found in listRCU.rst and NMI-RCU.rst. ::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:500
msgid "So, to sum up:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:502
msgid ""
"Use rcu_read_lock() and rcu_read_unlock() to guard RCU read-side critical "
"sections."
msgstr ""

#: ../../../RCU/whatisRCU.rst:505
msgid ""
"Within an RCU read-side critical section, use rcu_dereference() to "
"dereference RCU-protected pointers."
msgstr ""

#: ../../../RCU/whatisRCU.rst:508
msgid ""
"Use some solid design (such as locks or semaphores) to keep concurrent "
"updates from interfering with each other."
msgstr ""

#: ../../../RCU/whatisRCU.rst:511
msgid ""
"Use rcu_assign_pointer() to update an RCU-protected pointer. This primitive "
"protects concurrent readers from the updater, **not** concurrent updates "
"from each other!  You therefore still need to use locking (or something "
"similar) to keep concurrent rcu_assign_pointer() primitives from interfering "
"with each other."
msgstr ""

#: ../../../RCU/whatisRCU.rst:517
msgid ""
"Use synchronize_rcu() **after** removing a data element from an RCU-"
"protected data structure, but **before** reclaiming/freeing the data "
"element, in order to wait for the completion of all RCU read-side critical "
"sections that might be referencing that data item."
msgstr ""

#: ../../../RCU/whatisRCU.rst:523
msgid ""
"See checklist.rst for additional rules to follow when using RCU. And again, "
"more-typical uses of RCU may be found in listRCU.rst and NMI-RCU.rst."
msgstr ""

#: ../../../RCU/whatisRCU.rst:530
msgid "4.  WHAT IF MY UPDATING THREAD CANNOT BLOCK?"
msgstr ""

#: ../../../RCU/whatisRCU.rst:532
msgid ""
"In the example above, foo_update_a() blocks until a grace period elapses. "
"This is quite simple, but in some cases one cannot afford to wait so long -- "
"there might be other high-priority work to be done."
msgstr ""

#: ../../../RCU/whatisRCU.rst:536
msgid ""
"In such cases, one uses call_rcu() rather than synchronize_rcu(). The "
"call_rcu() API is as follows::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:541
msgid ""
"This function invokes func(head) after a grace period has elapsed. This "
"invocation might happen from either softirq or process context, so the "
"function is not permitted to block.  The foo struct needs to have an "
"rcu_head structure added, perhaps as follows::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:553
msgid "The foo_update_a() function might then be written as follows::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:583
msgid "The foo_reclaim() function might appear as follows::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:594
msgid ""
"The container_of() primitive is a macro that, given a pointer into a struct, "
"the type of the struct, and the pointed-to field within the struct, returns "
"a pointer to the beginning of the struct."
msgstr ""

#: ../../../RCU/whatisRCU.rst:598
msgid ""
"The use of call_rcu() permits the caller of foo_update_a() to immediately "
"regain control, without needing to worry further about the old version of "
"the newly updated element.  It also clearly shows the RCU distinction "
"between updater, namely foo_update_a(), and reclaimer, namely foo_reclaim()."
msgstr ""

#: ../../../RCU/whatisRCU.rst:604
msgid ""
"The summary of advice is the same as for the previous section, except that "
"we are now using call_rcu() rather than synchronize_rcu():"
msgstr ""

#: ../../../RCU/whatisRCU.rst:607
msgid ""
"Use call_rcu() **after** removing a data element from an RCU-protected data "
"structure in order to register a callback function that will be invoked "
"after the completion of all RCU read-side critical sections that might be "
"referencing that data item."
msgstr ""

#: ../../../RCU/whatisRCU.rst:613
msgid ""
"If the callback for call_rcu() is not doing anything more than calling "
"kfree() on the structure, you can use kfree_rcu() instead of call_rcu() to "
"avoid having to write your own callback::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:619
msgid ""
"If the occasional sleep is permitted, the single-argument form may be used, "
"omitting the rcu_head structure from struct foo."
msgstr ""

#: ../../../RCU/whatisRCU.rst:622
msgid "kfree_rcu_mightsleep(old_fp);"
msgstr ""

#: ../../../RCU/whatisRCU.rst:624
msgid ""
"This variant almost never blocks, but might do so by invoking "
"synchronize_rcu() in response to memory-allocation failure."
msgstr ""

#: ../../../RCU/whatisRCU.rst:627
msgid "Again, see checklist.rst for additional rules governing the use of RCU."
msgstr ""

#: ../../../RCU/whatisRCU.rst:632
msgid "5.  WHAT ARE SOME SIMPLE IMPLEMENTATIONS OF RCU?"
msgstr ""

#: ../../../RCU/whatisRCU.rst:634
msgid ""
"One of the nice things about RCU is that it has extremely simple \"toy\" "
"implementations that are a good first step towards understanding the "
"production-quality implementations in the Linux kernel.  This section "
"presents two such \"toy\" implementations of RCU, one that is implemented in "
"terms of familiar locking primitives, and another that more closely "
"resembles \"classic\" RCU.  Both are way too simple for real-world use, "
"lacking both functionality and performance.  However, they are useful in "
"getting a feel for how RCU works.  See kernel/rcu/update.c for a production-"
"quality implementation, and see:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:644
msgid ""
"https://docs.google.com/document/"
"d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit"
msgstr ""

#: ../../../RCU/whatisRCU.rst:646
msgid ""
"for papers describing the Linux kernel RCU implementation.  The OLS'01 and "
"OLS'02 papers are a good introduction, and the dissertation provides more "
"details on the current implementation as of early 2004."
msgstr ""

#: ../../../RCU/whatisRCU.rst:652
msgid "5A.  \"TOY\" IMPLEMENTATION #1: LOCKING"
msgstr ""

#: ../../../RCU/whatisRCU.rst:653
msgid ""
"This section presents a \"toy\" RCU implementation that is based on familiar "
"locking primitives.  Its overhead makes it a non-starter for real-life use, "
"as does its lack of scalability.  It is also unsuitable for realtime use, "
"since it allows scheduling latency to \"bleed\" from one read-side critical "
"section to another.  It also assumes recursive reader-writer locks:  If you "
"try this with non-recursive locks, and you allow nested rcu_read_lock() "
"calls, you can deadlock."
msgstr ""

#: ../../../RCU/whatisRCU.rst:661
msgid ""
"However, it is probably the easiest implementation to relate to, so is a "
"good starting point."
msgstr ""

#: ../../../RCU/whatisRCU.rst:664
msgid "It is extremely simple::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:685
msgid ""
"[You can ignore rcu_assign_pointer() and rcu_dereference() without missing "
"much.  But here are simplified versions anyway.  And whatever you do, don't "
"forget about them when submitting patches making use of RCU!]::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:701
msgid ""
"The rcu_read_lock() and rcu_read_unlock() primitive read-acquire and release "
"a global reader-writer lock.  The synchronize_rcu() primitive write-acquires "
"this same lock, then releases it.  This means that once synchronize_rcu() "
"exits, all RCU read-side critical sections that were in progress before "
"synchronize_rcu() was called are guaranteed to have completed -- there is no "
"way that synchronize_rcu() would have been able to write-acquire the lock "
"otherwise.  The smp_mb__after_spinlock() promotes synchronize_rcu() to a "
"full memory barrier in compliance with the \"Memory-Barrier Guarantees\" "
"listed in:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:711
msgid "Design/Requirements/Requirements.rst"
msgstr ""

#: ../../../RCU/whatisRCU.rst:713
msgid ""
"It is possible to nest rcu_read_lock(), since reader-writer locks may be "
"recursively acquired.  Note also that rcu_read_lock() is immune from "
"deadlock (an important property of RCU).  The reason for this is that the "
"only thing that can block rcu_read_lock() is a synchronize_rcu(). But "
"synchronize_rcu() does not acquire any locks while holding rcu_gp_mutex, so "
"there can be no deadlock cycle."
msgstr ""

#: ../../../RCU/whatisRCU.rst:722 ../../../RCU/whatisRCU.rst:1216
msgid "Quick Quiz #1:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:723
msgid ""
"Why is this argument naive?  How could a deadlock occur when using this "
"algorithm in a real-world Linux kernel?  How could this deadlock be avoided?"
msgstr ""

#: ../../../RCU/whatisRCU.rst:727 ../../../RCU/whatisRCU.rst:782
#: ../../../RCU/whatisRCU.rst:791
msgid ":ref:`Answers to Quick Quiz <9_whatisRCU>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:730
msgid "5B.  \"TOY\" EXAMPLE #2: CLASSIC RCU"
msgstr ""

#: ../../../RCU/whatisRCU.rst:731
msgid ""
"This section presents a \"toy\" RCU implementation that is based on "
"\"classic RCU\".  It is also short on performance (but only for updates) and "
"on features such as hotplug CPU and the ability to run in CONFIG_PREEMPTION "
"kernels.  The definitions of rcu_dereference() and rcu_assign_pointer() are "
"the same as those shown in the preceding section, so they are omitted. ::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:750
msgid ""
"Note that rcu_read_lock() and rcu_read_unlock() do absolutely nothing. This "
"is the great strength of classic RCU in a non-preemptive kernel: read-side "
"overhead is precisely zero, at least on non-Alpha CPUs. And there is "
"absolutely no way that rcu_read_lock() can possibly participate in a "
"deadlock cycle!"
msgstr ""

#: ../../../RCU/whatisRCU.rst:756
msgid ""
"The implementation of synchronize_rcu() simply schedules itself on each CPU "
"in turn.  The run_on() primitive can be implemented straightforwardly in "
"terms of the sched_setaffinity() primitive.  Of course, a somewhat less "
"\"toy\" implementation would restore the affinity upon completion rather "
"than just leaving all tasks running on the last CPU, but when I said "
"\"toy\", I meant **toy**!"
msgstr ""

#: ../../../RCU/whatisRCU.rst:763
msgid "So how the heck is this supposed to work???"
msgstr ""

#: ../../../RCU/whatisRCU.rst:765
msgid ""
"Remember that it is illegal to block while in an RCU read-side critical "
"section.  Therefore, if a given CPU executes a context switch, we know that "
"it must have completed all preceding RCU read-side critical sections. Once "
"**all** CPUs have executed a context switch, then **all** preceding RCU read-"
"side critical sections will have completed."
msgstr ""

#: ../../../RCU/whatisRCU.rst:771
msgid ""
"So, suppose that we remove a data item from its structure and then invoke "
"synchronize_rcu().  Once synchronize_rcu() returns, we are guaranteed that "
"there are no RCU read-side critical sections holding a reference to that "
"data item, so we can safely reclaim it."
msgstr ""

#: ../../../RCU/whatisRCU.rst:778 ../../../RCU/whatisRCU.rst:1264
msgid "Quick Quiz #2:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:779 ../../../RCU/whatisRCU.rst:1265
msgid "Give an example where Classic RCU's read-side overhead is **negative**."
msgstr ""

#: ../../../RCU/whatisRCU.rst:786 ../../../RCU/whatisRCU.rst:1293
msgid "Quick Quiz #3:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:787 ../../../RCU/whatisRCU.rst:1294
msgid ""
"If it is illegal to block in an RCU read-side critical section, what the "
"heck do you do in CONFIG_PREEMPT_RT, where normal spinlocks can block???"
msgstr ""

#: ../../../RCU/whatisRCU.rst:796
msgid "6.  ANALOGY WITH READER-WRITER LOCKING"
msgstr ""

#: ../../../RCU/whatisRCU.rst:798
msgid ""
"Although RCU can be used in many different ways, a very common use of RCU is "
"analogous to reader-writer locking.  The following unified diff shows how "
"closely related RCU and reader-writer locking can be. ::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:853
msgid "Or, for those who prefer a side-by-side listing::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:904
msgid ""
"Either way, the differences are quite small.  Read-side locking moves to "
"rcu_read_lock() and rcu_read_unlock, update-side locking moves from a reader-"
"writer lock to a simple spinlock, and a synchronize_rcu() precedes the "
"kfree()."
msgstr ""

#: ../../../RCU/whatisRCU.rst:909
msgid ""
"However, there is one potential catch: the read-side and update-side "
"critical sections can now run concurrently.  In many cases, this will not be "
"a problem, but it is necessary to check carefully regardless. For example, "
"if multiple independent list updates must be seen as a single atomic update, "
"converting to RCU will require special care."
msgstr ""

#: ../../../RCU/whatisRCU.rst:915
msgid ""
"Also, the presence of synchronize_rcu() means that the RCU version of "
"delete() can now block.  If this is a problem, there is a callback-based "
"mechanism that never blocks, namely call_rcu() or kfree_rcu(), that can be "
"used in place of synchronize_rcu()."
msgstr ""

#: ../../../RCU/whatisRCU.rst:923
msgid "7.  ANALOGY WITH REFERENCE COUNTING"
msgstr ""

#: ../../../RCU/whatisRCU.rst:925
msgid ""
"The reader-writer analogy (illustrated by the previous section) is not "
"always the best way to think about using RCU.  Another helpful analogy "
"considers RCU an effective reference count on everything which is protected "
"by RCU."
msgstr ""

#: ../../../RCU/whatisRCU.rst:930
msgid ""
"A reference count typically does not prevent the referenced object's values "
"from changing, but does prevent changes to type -- particularly the gross "
"change of type that happens when that object's memory is freed and re-"
"allocated for some other purpose.  Once a type-safe reference to the object "
"is obtained, some other mechanism is needed to ensure consistent access to "
"the data in the object.  This could involve taking a spinlock, but with RCU "
"the typical approach is to perform reads with SMP-aware operations such as "
"smp_load_acquire(), to perform updates with atomic read-modify-write "
"operations, and to provide the necessary ordering. RCU provides a number of "
"support functions that embed the required operations and ordering, such as "
"the list_for_each_entry_rcu() macro used in the previous section."
msgstr ""

#: ../../../RCU/whatisRCU.rst:943
msgid ""
"A more focused view of the reference counting behavior is that, between "
"rcu_read_lock() and rcu_read_unlock(), any reference taken with "
"rcu_dereference() on a pointer marked as ``__rcu`` can be treated as though "
"a reference-count on that object has been temporarily increased. This "
"prevents the object from changing type.  Exactly what this means will depend "
"on normal expectations of objects of that type, but it typically includes "
"that spinlocks can still be safely locked, normal reference counters can be "
"safely manipulated, and ``__rcu`` pointers can be safely dereferenced."
msgstr ""

#: ../../../RCU/whatisRCU.rst:953
msgid ""
"Some operations that one might expect to see on an object for which an RCU "
"reference is held include:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:956
msgid "Copying out data that is guaranteed to be stable by the object's type."
msgstr ""

#: ../../../RCU/whatisRCU.rst:957
msgid ""
"Using kref_get_unless_zero() or similar to get a longer-term reference.  "
"This may fail of course."
msgstr ""

#: ../../../RCU/whatisRCU.rst:959
msgid ""
"Acquiring a spinlock in the object, and checking if the object still is the "
"expected object and if so, manipulating it freely."
msgstr ""

#: ../../../RCU/whatisRCU.rst:962
msgid ""
"The understanding that RCU provides a reference that only prevents a change "
"of type is particularly visible with objects allocated from a slab cache "
"marked ``SLAB_TYPESAFE_BY_RCU``.  RCU operations may yield a reference to an "
"object from such a cache that has been concurrently freed and the memory "
"reallocated to a completely different object, though of the same type.  In "
"this case RCU doesn't even protect the identity of the object from changing, "
"only its type.  So the object found may not be the one expected, but it will "
"be one where it is safe to take a reference (and then potentially acquiring "
"a spinlock), allowing subsequent code to check whether the identity matches "
"expectations.  It is tempting to simply acquire the spinlock without first "
"taking the reference, but unfortunately any spinlock in a "
"``SLAB_TYPESAFE_BY_RCU`` object must be initialized after each and every "
"call to kmem_cache_alloc(), which renders reference-free spinlock "
"acquisition completely unsafe.  Therefore, when using "
"``SLAB_TYPESAFE_BY_RCU``, make proper use of a reference counter. If using "
"refcount_t, the specialized refcount_{add|inc}_not_zero_acquire() and "
"refcount_set_release() APIs should be used to ensure correct operation "
"ordering when verifying object identity and when initializing newly "
"allocated objects. Acquire fence in refcount_{add|inc}_not_zero_acquire() "
"ensures that identity checks happen *after* reference count is taken. "
"refcount_set_release() should be called after a newly allocated object is "
"fully initialized and release fence ensures that new values are visible "
"*before* refcount can be successfully taken by other users. Once "
"refcount_set_release() is called, the object should be considered visible by "
"other tasks. (Those willing to initialize their locks in a kmem_cache "
"constructor may also use locking, including cache-friendly sequence locking.)"
msgstr ""

#: ../../../RCU/whatisRCU.rst:990
msgid ""
"With traditional reference counting -- such as that implemented by the kref "
"library in Linux -- there is typically code that runs when the last "
"reference to an object is dropped.  With kref, this is the function passed "
"to kref_put().  When RCU is being used, such finalization code must not be "
"run until all ``__rcu`` pointers referencing the object have been updated, "
"and then a grace period has passed.  Every remaining globally visible "
"pointer to the object must be considered to be a potential counted "
"reference, and the finalization code is typically run using call_rcu() only "
"after all those pointers have been changed."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1000
msgid ""
"To see how to choose between these two analogies -- of RCU as a reader-"
"writer lock and RCU as a reference counting system -- it is useful to "
"reflect on the scale of the thing being protected.  The reader-writer lock "
"analogy looks at larger multi-part objects such as a linked list and shows "
"how RCU can facilitate concurrency while elements are added to, and removed "
"from, the list.  The reference-count analogy looks at the individual objects "
"and looks at how they can be accessed safely within whatever whole they are "
"a part of."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1012
msgid "8.  FULL LIST OF RCU APIs"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1014
msgid ""
"The RCU APIs are documented in docbook-format header comments in the Linux-"
"kernel source code, but it helps to have a full list of the APIs, since "
"there does not appear to be a way to categorize them in docbook.  Here is "
"the list, by category."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1019
msgid "RCU list traversal::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1043
msgid "RCU pointer/list update::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1067
msgid "RCU::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1078
msgid "bh::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1091
msgid "sched::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1107
msgid "RCU-Tasks::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1115
msgid "RCU-Tasks-Rude::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1123
msgid "RCU-Tasks-Trace::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1131
msgid "SRCU::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1141
msgid "SRCU: Initialization/cleanup::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1148
msgid "All: lockdep-checked RCU utility APIs::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1153
msgid "All: Unchecked RCU-protected pointer access::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1157
msgid ""
"All: Unchecked RCU-protected pointer access with dereferencing prohibited::"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1161
msgid ""
"See the comment headers in the source code (or the docbook generated from "
"them) for more information."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1164
msgid ""
"However, given that there are no fewer than four families of RCU APIs in the "
"Linux kernel, how do you choose which one to use?  The following list can be "
"helpful:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1168
msgid "Will readers need to block?  If so, you need SRCU."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1170
msgid ""
"Will readers need to block and are you doing tracing, for example, ftrace or "
"BPF?  If so, you need RCU-tasks, RCU-tasks-rude, and/or RCU-tasks-trace."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1174
msgid ""
"What about the -rt patchset?  If readers would need to block in an non-rt "
"kernel, you need SRCU.  If readers would block when acquiring spinlocks in a "
"-rt kernel, but not in a non-rt kernel, SRCU is not necessary.  (The -rt "
"patchset turns spinlocks into sleeplocks, hence this distinction.)"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1180
msgid ""
"Do you need to treat NMI handlers, hardirq handlers, and code segments with "
"preemption disabled (whether via preempt_disable(), local_irq_save(), "
"local_bh_disable(), or some other mechanism) as if they were explicit RCU "
"readers? If so, RCU-sched readers are the only choice that will work for "
"you, but since about v4.20 you use can use the vanilla RCU update primitives."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1188
msgid ""
"Do you need RCU grace periods to complete even in the face of softirq "
"monopolization of one or more of the CPUs?  For example, is your code "
"subject to network-based denial-of-service attacks? If so, you should "
"disable softirq across your readers, for example, by using "
"rcu_read_lock_bh().  Since about v4.20 you use can use the vanilla RCU "
"update primitives."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1195
msgid ""
"Is your workload too update-intensive for normal use of RCU, but "
"inappropriate for other synchronization mechanisms? If so, consider "
"SLAB_TYPESAFE_BY_RCU (which was originally named SLAB_DESTROY_BY_RCU).  But "
"please be careful!"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1200
msgid ""
"Do you need read-side critical sections that are respected even on CPUs that "
"are deep in the idle loop, during entry to or exit from user-mode execution, "
"or on an offlined CPU?  If so, SRCU and RCU Tasks Trace are the only choices "
"that will work for you, with SRCU being strongly preferred in almost all "
"cases."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1206
msgid "Otherwise, use RCU."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1208
msgid ""
"Of course, this all assumes that you have determined that RCU is in fact the "
"right tool for your job."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1214
msgid "9.  ANSWERS TO QUICK QUIZZES"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1217
msgid ""
"Why is this argument naive?  How could a deadlock occur when using this "
"algorithm in a real-world Linux kernel?  [Referring to the lock-based "
"\"toy\" RCU algorithm.]"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1222 ../../../RCU/whatisRCU.rst:1268
#: ../../../RCU/whatisRCU.rst:1298
msgid "Answer:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1223
msgid "Consider the following sequence of events:"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1225
msgid ""
"CPU 0 acquires some unrelated lock, call it \"problematic_lock\", disabling "
"irq via spin_lock_irqsave()."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1229
msgid "CPU 1 enters synchronize_rcu(), write-acquiring rcu_gp_mutex."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1232
msgid ""
"CPU 0 enters rcu_read_lock(), but must wait because CPU 1 holds rcu_gp_mutex."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1235
msgid ""
"CPU 1 is interrupted, and the irq handler attempts to acquire "
"problematic_lock."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1238
msgid "The system is now deadlocked."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1240
msgid ""
"One way to avoid this deadlock is to use an approach like that of "
"CONFIG_PREEMPT_RT, where all normal spinlocks become blocking locks, and all "
"irq handlers execute in the context of special tasks.  In this case, in step "
"4 above, the irq handler would block, allowing CPU 1 to release "
"rcu_gp_mutex, avoiding the deadlock."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1247
msgid ""
"Even in the absence of deadlock, this RCU implementation allows latency to "
"\"bleed\" from readers to other readers through synchronize_rcu().  To see "
"this, consider task A in an RCU read-side critical section (thus read-"
"holding rcu_gp_mutex), task B blocked attempting to write-acquire "
"rcu_gp_mutex, and task C blocked in rcu_read_lock() attempting to "
"read_acquire rcu_gp_mutex.  Task A's RCU read-side latency is holding up "
"task C, albeit indirectly via task B."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1258
msgid ""
"Realtime RCU implementations therefore use a counter-based approach where "
"tasks in RCU read-side critical sections cannot be blocked by tasks "
"executing synchronize_rcu()."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1262
msgid ":ref:`Back to Quick Quiz #1 <quiz_1>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1269
msgid ""
"Imagine a single-CPU system with a non-CONFIG_PREEMPTION kernel where a "
"routing table is used by process-context code, but can be updated by irq-"
"context code (for example, by an \"ICMP REDIRECT\" packet).  The usual way "
"of handling this would be to have the process-context code disable "
"interrupts while searching the routing table.  Use of RCU allows such "
"interrupt-disabling to be dispensed with. Thus, without RCU, you pay the "
"cost of disabling interrupts, and with RCU you don't."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1279
msgid ""
"One can argue that the overhead of RCU in this case is negative with respect "
"to the single-CPU interrupt-disabling approach.  Others might argue that the "
"overhead of RCU is merely zero, and that replacing the positive overhead of "
"the interrupt-disabling scheme with the zero-overhead RCU scheme does not "
"constitute negative overhead."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1287
msgid ""
"In real life, of course, things are more complex.  But even the theoretical "
"possibility of negative overhead for a synchronization primitive is a bit "
"unexpected.  ;-)"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1291
msgid ":ref:`Back to Quick Quiz #2 <quiz_2>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1299
msgid ""
"Just as CONFIG_PREEMPT_RT permits preemption of spinlock critical sections, "
"it permits preemption of RCU read-side critical sections.  It also permits "
"spinlocks blocking while in RCU read-side critical sections."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1305
msgid ""
"Why the apparent inconsistency?  Because it is possible to use priority "
"boosting to keep the RCU grace periods short if need be (for example, if "
"running short of memory).  In contrast, if blocking waiting for (say) "
"network reception, there is no way to know what should be boosted.  "
"Especially given that the process we need to boost might well be a human "
"being who just went out for a pizza or something.  And although a computer-"
"operated cattle prod might arouse serious interest, it might also provoke "
"serious objections. Besides, how does the computer know what pizza parlor "
"the human being went to???"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1318
msgid ":ref:`Back to Quick Quiz #3 <quiz_3>`"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1320
msgid "ACKNOWLEDGEMENTS"
msgstr ""

#: ../../../RCU/whatisRCU.rst:1322
msgid ""
"My thanks to the people who helped make this human-readable, including Jon "
"Walpole, Josh Triplett, Serge Hallyn, Suzanne Wood, and Alan Stern."
msgstr ""

#: ../../../RCU/whatisRCU.rst:1326
msgid "For more information, see http://www.rdrop.com/users/paulmck/RCU."
msgstr ""
