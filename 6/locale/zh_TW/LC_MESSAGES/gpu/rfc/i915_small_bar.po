# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-02 09:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/rfc/i915_small_bar.rst:3
msgid "I915 Small BAR RFC Section"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:4
msgid ""
"Starting from DG2 we will have resizable BAR support for device local-"
"memory(i.e I915_MEMORY_CLASS_DEVICE), but in some cases the final BAR size "
"might still be smaller than the total probed_size. In such cases, only some "
"subset of I915_MEMORY_CLASS_DEVICE will be CPU accessible(for example the "
"first 256M), while the remainder is only accessible via the GPU."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:11
msgid "I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS flag"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:12
msgid ""
"New gem_create_ext flag to tell the kernel that a BO will require CPU "
"access. This becomes important when placing an object in "
"I915_MEMORY_CLASS_DEVICE, where underneath the device has a small BAR, "
"meaning only some portion of it is CPU accessible. Without this flag the "
"kernel will assume that CPU access is not required, and prioritize using the "
"non-CPU visible portion of I915_MEMORY_CLASS_DEVICE."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:94
msgid ""
"Existing gem_create behaviour, with added extension support using struct "
"i915_user_extension."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:98
#: ../../../gpu/rfc/i915_small_bar:34: Documentation/gpu/rfc/i915_small_bar.h:6
msgid "**Definition**::"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:110
#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:22
msgid "**Members**"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:105
msgid "``size``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:106
msgid "Requested size for the object."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:108
msgid "The (page-aligned) allocated size for the object will be returned."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:110
msgid ""
"Note that for some devices we have might have further minimum page-size "
"restrictions (larger than 4K), like for device local-memory. However in "
"general the final size here should always reflect any rounding up, if for "
"example using the I915_GEM_CREATE_EXT_MEMORY_REGIONS extension to place the "
"object in device local-memory. The kernel will always select the largest "
"minimum page-size for the set of possible placements as the value to use "
"when rounding up the **size**."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:120
msgid "``handle``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:121
msgid "Returned handle for the object."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:123
msgid "Object handles are nonzero."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:127
msgid "``flags``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:128
msgid "Optional flags."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:130
msgid "Supported values:"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:132
msgid ""
"I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS - Signal to the kernel that the "
"object will need to be accessed via the CPU."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:135
msgid ""
"Only valid when placing objects in I915_MEMORY_CLASS_DEVICE, and only "
"strictly required on configurations where some subset of the device memory "
"is directly visible/mappable through the CPU (which we also call small BAR), "
"like on some DG2+ systems. Note that this is quite undesirable, but due to "
"various factors like the client CPU, BIOS etc it's something we can expect "
"to see in the wild. See :c:type:`__drm_i915_memory_region_info."
"probed_cpu_visible_size <__drm_i915_memory_region_info>` for how to "
"determine if this system applies."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:144
msgid ""
"Note that one of the placements MUST be I915_MEMORY_CLASS_SYSTEM, to ensure "
"the kernel can always spill the allocation to system memory, if the object "
"can't be allocated in the mappable part of I915_MEMORY_CLASS_DEVICE."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:149
msgid ""
"Also note that since the kernel only supports flat-CCS on objects that can "
"*only* be placed in I915_MEMORY_CLASS_DEVICE, we therefore don't support "
"I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS together with flat-CCS."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:154
msgid ""
"Without this hint, the kernel will assume that non-mappable "
"I915_MEMORY_CLASS_DEVICE is preferred for this object. Note that the kernel "
"can still migrate the object to the mappable part, as a last resort, if "
"userspace ever CPU faults this object, but this might be expensive, and so "
"ideally should be avoided."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:160
msgid ""
"On older kernels which lack the relevant small-bar uAPI support (see also :c:"
"type:`__drm_i915_memory_region_info.probed_cpu_visible_size "
"<__drm_i915_memory_region_info>`), usage of the flag will result in an "
"error, but it should NEVER be possible to end up with a small BAR "
"configuration, assuming we can also successfully load the i915 kernel "
"module. In such cases the entire I915_MEMORY_CLASS_DEVICE region will be CPU "
"accessible, and as such there are zero restrictions on where the object can "
"be placed."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:171
msgid "``extensions``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:172
msgid "The chain of extensions to apply to this object."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:174
msgid ""
"This will be useful in the future when we need to support several different "
"extensions, and we need to apply more than one when creating the object. See "
"struct i915_user_extension."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:178
msgid ""
"If we don't supply any extensions then we get the same old gem_create "
"behaviour."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:181
msgid ""
"For I915_GEM_CREATE_EXT_MEMORY_REGIONS usage see struct "
"drm_i915_gem_create_ext_memory_regions."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:184
msgid ""
"For I915_GEM_CREATE_EXT_PROTECTED_CONTENT usage see struct "
"drm_i915_gem_create_ext_protected_content."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:188
#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:90
msgid "**Description**"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:19:
#: Documentation/gpu/rfc/i915_small_bar.h:95
msgid ""
"Note that new buffer flags should be added here, at least for the stuff that "
"is immutable. Previously we would have two ioctls, one to create the object "
"with gem_create, and another to apply various parameters, however this "
"creates some ambiguity for the params which are considered immutable. Also "
"in general we're phasing out the various SET/GET ioctls."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:23
msgid "probed_cpu_visible_size attribute"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:24
msgid ""
"New struct__drm_i915_memory_region attribute which returns the total size of "
"the CPU accessible portion, for the particular region. This should only be "
"applicable for I915_MEMORY_CLASS_DEVICE. We also report the "
"unallocated_cpu_visible_size, alongside the unallocated_size."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:29
msgid ""
"Vulkan will need this as part of creating a separate VkMemoryHeap with the "
"VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set, to represent the CPU visible "
"portion, where the total size of the heap needs to be known. It also wants "
"to be able to give a rough estimate of how memory can potentially be "
"allocated."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34: Documentation/gpu/rfc/i915_small_bar.h:2
msgid "Describes one region as known to the driver."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:10
msgid "``region``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:11
msgid "The class:instance pair encoding"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:13
msgid "``rsvd0``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:14
#: Documentation/gpu/rfc/i915_small_bar.h:39
msgid "MBZ"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:17
msgid "``probed_size``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:18
msgid "Memory probed by the driver"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:20
msgid ""
"Note that it should not be possible to ever encounter a zero value here, "
"also note that no current region type will ever return -1 here. Although for "
"future region types, this might be a possibility. The same applies to the "
"other size fields."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:27
msgid "``unallocated_size``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:28
msgid "Estimate of memory remaining"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:30
msgid ""
"Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable accounting. Without "
"this (or if this is an older kernel) the value here will always equal the "
"**probed_size**. Note this is only currently tracked for "
"I915_MEMORY_CLASS_DEVICE regions (for other types the value here will always "
"equal the **probed_size**)."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34: Documentation/gpu/rfc/i915_small_bar.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34: Documentation/gpu/rfc/i915_small_bar.h:2
msgid "anonymous"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:38
msgid "``rsvd1``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34: Documentation/gpu/rfc/i915_small_bar.h:1
msgid "``{unnamed_struct}``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:42
msgid "``probed_cpu_visible_size``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:43
msgid "Memory probed by the driver that is CPU accessible."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:46
msgid ""
"This will be always be <= **probed_size**, and the remainder (if there is "
"any) will not be CPU accessible."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:50
msgid ""
"On systems without small BAR, the **probed_size** will always equal the "
"**probed_cpu_visible_size**, since all of it will be CPU accessible."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:54
msgid ""
"Note this is only tracked for I915_MEMORY_CLASS_DEVICE regions (for other "
"types the value here will always equal the **probed_size**)."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:58
msgid ""
"Note that if the value returned here is zero, then this must be an old "
"kernel which lacks the relevant small-bar uAPI support (including "
"I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS), but on such systems we should "
"never actually end up with a small BAR configuration, assuming we are able "
"to load the kernel module. Hence it should be safe to treat this the same as "
"when **probed_cpu_visible_size** == **probed_size**."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:70
msgid "``unallocated_cpu_visible_size``"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:71
msgid "Estimate of CPU visible memory remaining"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:74
msgid ""
"Note this is only tracked for I915_MEMORY_CLASS_DEVICE regions (for other "
"types the value here will always equal the **probed_cpu_visible_size**)."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:79
msgid ""
"Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable accounting.  Without "
"this the value here will always equal the **probed_cpu_visible_size**. Note "
"this is only currently tracked for I915_MEMORY_CLASS_DEVICE regions (for "
"other types the value here will also always equal the "
"**probed_cpu_visible_size**)."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34:
#: Documentation/gpu/rfc/i915_small_bar.h:86
msgid ""
"If this is an older kernel the value here will be zero, see also "
"**probed_cpu_visible_size**."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar:34: Documentation/gpu/rfc/i915_small_bar.h:3
msgid ""
"Note this is using both struct drm_i915_query_item and struct "
"drm_i915_query. For this new query we are adding the new query id "
"DRM_I915_QUERY_MEMORY_REGIONS at :c:type:`drm_i915_query_item.query_id "
"<drm_i915_query_item>`."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:38
msgid "Error Capture restrictions"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:39
msgid "With error capture we have two new restrictions:"
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:41
msgid ""
"1) Error capture is best effort on small BAR systems; if the pages are not "
"CPU accessible, at the time of capture, then the kernel is free to skip "
"trying to capture them."
msgstr ""

#: ../../../gpu/rfc/i915_small_bar.rst:45
msgid ""
"2) On discrete and newer integrated platforms we now reject error capture on "
"recoverable contexts. In the future the kernel may want to blit during error "
"capture, when for example something is not currently CPU accessible."
msgstr ""
