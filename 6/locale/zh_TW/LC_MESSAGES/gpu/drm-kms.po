# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/drm-kms.rst:3
msgid "Kernel Mode Setting (KMS)"
msgstr ""

#: ../../../gpu/drm-kms.rst:5
msgid ""
"Drivers must initialize the mode setting core by calling "
"drmm_mode_config_init() on the DRM device. The function initializes the :c:"
"type:`struct drm_device <drm_device>` mode_config field and never fails. "
"Once done, mode configuration must be setup by initializing the following "
"fields."
msgstr ""

#: ../../../gpu/drm-kms.rst:11
msgid ""
"int min_width, min_height; int max_width, max_height; Minimum and maximum "
"width and height of the frame buffers in pixel units."
msgstr ""

#: ../../../gpu/drm-kms.rst:15
msgid "struct drm_mode_config_funcs \\*funcs; Mode setting functions."
msgstr ""

#: ../../../gpu/drm-kms.rst:19
msgid "Overview"
msgstr ""

#: ../../../gpu/drm-kms.rst:57
msgid ""
"The basic object structure KMS presents to userspace is fairly simple. "
"Framebuffers (represented by :c:type:`struct drm_framebuffer "
"<drm_framebuffer>`, see `Frame Buffer Abstraction`_) feed into planes. "
"Planes are represented by :c:type:`struct drm_plane <drm_plane>`, see `Plane "
"Abstraction`_ for more details. One or more (or even no) planes feed their "
"pixel data into a CRTC (represented by :c:type:`struct drm_crtc <drm_crtc>`, "
"see `CRTC Abstraction`_) for blending. The precise blending step is "
"explained in more detail in `Plane Composition Properties`_ and related "
"chapters."
msgstr ""

#: ../../../gpu/drm-kms.rst:66
msgid ""
"For the output routing the first step is encoders (represented by :c:type:"
"`struct drm_encoder <drm_encoder>`, see `Encoder Abstraction`_). Those are "
"really just internal artifacts of the helper libraries used to implement KMS "
"drivers. Besides that they make it unnecessarily more complicated for "
"userspace to figure out which connections between a CRTC and a connector are "
"possible, and what kind of cloning is supported, they serve no purpose in "
"the userspace API. Unfortunately encoders have been exposed to userspace, "
"hence can't remove them at this point.  Furthermore the exposed restrictions "
"are often wrongly set by drivers, and in many cases not powerful enough to "
"express the real restrictions. A CRTC can be connected to multiple encoders, "
"and for an active CRTC there must be at least one encoder."
msgstr ""

#: ../../../gpu/drm-kms.rst:78
msgid ""
"The final, and real, endpoint in the display chain is the connector "
"(represented by :c:type:`struct drm_connector <drm_connector>`, see "
"`Connector Abstraction`_). Connectors can have different possible encoders, "
"but the kernel driver selects which encoder to use for each connector. The "
"use case is DVI, which could switch between an analog and a digital encoder. "
"Encoders can also drive multiple different connectors. There is exactly one "
"active connector for every active encoder."
msgstr ""

#: ../../../gpu/drm-kms.rst:86
msgid ""
"Internally the output pipeline is a bit more complex and matches today's "
"hardware more closely:"
msgstr ""

#: ../../../gpu/drm-kms.rst:135
msgid ""
"Internally two additional helper objects come into play. First, to be able "
"to share code for encoders (sometimes on the same SoC, sometimes off-chip) "
"one or more :ref:`drm_bridges` (represented by :c:type:`struct drm_bridge "
"<drm_bridge>`) can be linked to an encoder. This link is static and cannot "
"be changed, which means the cross-bar (if there is any) needs to be mapped "
"between the CRTC and any encoders. Often for drivers with bridges there's no "
"code left at the encoder level. Atomic drivers can leave out all the encoder "
"callbacks to essentially only leave a dummy routing object behind, which is "
"needed for backwards compatibility since encoders are exposed to userspace."
msgstr ""

#: ../../../gpu/drm-kms.rst:145
msgid ""
"The second object is for panels, represented by :c:type:`struct drm_panel "
"<drm_panel>`, see :ref:`drm_panel_helper`. Panels do not have a fixed "
"binding point, but are generally linked to the driver private structure that "
"embeds :c:type:`struct drm_connector <drm_connector>`."
msgstr ""

#: ../../../gpu/drm-kms.rst:150
msgid ""
"Note that currently the bridge chaining and interactions with connectors and "
"panels are still in-flux and not really fully sorted out yet."
msgstr ""

#: ../../../gpu/drm-kms.rst:154
msgid "KMS Core Structures and Functions"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:42
msgid "basic driver provided mode setting functions"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:46
#: include/drm/drm_mode_config.h:331 ../../../gpu/drm-kms:188:
#: include/drm/drm_mode_object.h:38 include/drm/drm_mode_object.h:69
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:39
#: include/drm/drm_atomic.h:204 include/drm/drm_atomic.h:249
#: include/drm/drm_atomic.h:329 include/drm/drm_atomic.h:353
#: include/drm/drm_atomic.h:1183 include/drm/drm_atomic.h:1215
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:71
#: include/drm/drm_crtc.h:395 include/drm/drm_crtc.h:931
#: include/drm/drm_crtc.h:1185 ../../../gpu/drm-kms:342:
#: include/drm/drm_framebuffer.h:45 include/drm/drm_framebuffer.h:111
#: include/drm/drm_framebuffer.h:295 ../../../gpu/drm-kms:357:
#: include/drm/drm_fourcc.h:63 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:50 include/drm/drm_plane.h:294
#: include/drm/drm_plane.h:629 ../../../gpu/drm-kms:398:
#: include/drm/drm_damage_helper.h:54 ../../../gpu/drm-kms:410:
#: include/drm/drm_panic.h:23 ../../../gpu/drm-kms:419:
#: include/drm/drm_modes.h:202 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:227 include/drm/drm_connector.h:262
#: include/drm/drm_connector.h:303 include/drm/drm_connector.h:413
#: include/drm/drm_connector.h:430 include/drm/drm_connector.h:675
#: include/drm/drm_connector.h:875 include/drm/drm_connector.h:903
#: include/drm/drm_connector.h:931 include/drm/drm_connector.h:1007
#: include/drm/drm_connector.h:1209 include/drm/drm_connector.h:1229
#: include/drm/drm_connector.h:1303 include/drm/drm_connector.h:1617
#: include/drm/drm_connector.h:1763 include/drm/drm_connector.h:1870
#: include/drm/drm_connector.h:1890 include/drm/drm_connector.h:2496
#: include/drm/drm_connector.h:2520 ../../../gpu/drm-kms:446:
#: include/drm/drm_writeback.h:23 include/drm/drm_writeback.h:94
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:40
#: include/drm/drm_encoder.h:98 ../../../gpu/drm-kms:473:
#: include/drm/drm_modeset_lock.h:38 include/drm/drm_modeset_lock.h:82
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:37
#: include/drm/drm_property.h:59 include/drm/drm_property.h:205
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:44
#: include/drm/drm_vblank.h:86 include/drm/drm_vblank.h:111
#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:15
msgid "**Definition**::"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:59
#: include/drm/drm_mode_config.h:438 ../../../gpu/drm-kms:188:
#: include/drm/drm_mode_object.h:48 include/drm/drm_mode_object.h:77
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:52
#: include/drm/drm_atomic.h:212 include/drm/drm_atomic.h:258
#: include/drm/drm_atomic.h:336 include/drm/drm_atomic.h:373
#: include/drm/drm_atomic.h:1190 include/drm/drm_atomic.h:1224
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:103
#: include/drm/drm_crtc.h:424 include/drm/drm_crtc.h:968
#: include/drm/drm_crtc.h:1197 ../../../gpu/drm-kms:342:
#: include/drm/drm_framebuffer.h:53 include/drm/drm_framebuffer.h:131
#: include/drm/drm_framebuffer.h:307 ../../../gpu/drm-kms:357:
#: include/drm/drm_fourcc.h:82 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:81 include/drm/drm_plane.h:313
#: include/drm/drm_plane.h:664 ../../../gpu/drm-kms:398:
#: include/drm/drm_damage_helper.h:59 ../../../gpu/drm-kms:410:
#: include/drm/drm_panic.h:36 ../../../gpu/drm-kms:419:
#: include/drm/drm_modes.h:241 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:234 include/drm/drm_connector.h:276
#: include/drm/drm_connector.h:315 include/drm/drm_connector.h:420
#: include/drm/drm_connector.h:437 include/drm/drm_connector.h:714
#: include/drm/drm_connector.h:884 include/drm/drm_connector.h:919
#: include/drm/drm_connector.h:938 include/drm/drm_connector.h:1032
#: include/drm/drm_connector.h:1216 include/drm/drm_connector.h:1238
#: include/drm/drm_connector.h:1324 include/drm/drm_connector.h:1641
#: include/drm/drm_connector.h:1775 include/drm/drm_connector.h:1878
#: include/drm/drm_connector.h:1967 include/drm/drm_connector.h:2505
#: include/drm/drm_connector.h:2525 ../../../gpu/drm-kms:446:
#: include/drm/drm_writeback.h:37 include/drm/drm_writeback.h:106
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:50
#: include/drm/drm_encoder.h:116 ../../../gpu/drm-kms:473:
#: include/drm/drm_modeset_lock.h:49 include/drm/drm_modeset_lock.h:89
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:45
#: include/drm/drm_property.h:72 include/drm/drm_property.h:216
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:57
#: include/drm/drm_vblank.h:93 include/drm/drm_vblank.h:135
#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:25
msgid "**Members**"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:49
msgid "``fb_create``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:50
msgid ""
"Create a new framebuffer object. The core does basic checks on the requested "
"metadata, but most of that is left to the driver. See :c:type:`struct "
"drm_mode_fb_cmd2 <drm_mode_fb_cmd2>` for details."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:54
msgid ""
"To validate the pixel format and modifier drivers can use "
"drm_any_plane_has_format() to make sure at least one plane supports the "
"requested values. Note that the driver must first determine the actual "
"modifier used if the request doesn't have it specified, ie. when (**mode_cmd-"
">flags** & DRM_MODE_FB_MODIFIERS) == 0."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:60
msgid ""
"IMPORTANT: These implied modifiers for legacy userspace must be stored in "
"struct :c:type:`drm_framebuffer`, including all relevant metadata like :c:"
"type:`drm_framebuffer.pitches <drm_framebuffer>` and :c:type:"
"`drm_framebuffer.offsets <drm_framebuffer>` if the modifier enables "
"additional planes beyond the fourcc pixel format code. This is required by "
"the GETFB2 ioctl."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:66
msgid ""
"If the parameters are deemed valid and the backing storage objects in the "
"underlying memory manager all exist, then the driver allocates a new :c:type:"
"`drm_framebuffer` structure, subclassed to contain driver-specific "
"information (like the internal native buffer object references). It also "
"needs to fill out all relevant metadata, which should be done by calling "
"drm_helper_mode_fill_fb_struct()."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:73
msgid ""
"The initialization is finalized by calling drm_framebuffer_init(), which "
"registers the framebuffer and makes it accessible to other threads."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:77
#: include/drm/drm_mode_config.h:93 include/drm/drm_mode_config.h:167
#: include/drm/drm_mode_config.h:235 include/drm/drm_mode_config.h:282
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:215
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:431
#: include/drm/drm_crtc.h:453 include/drm/drm_crtc.h:473
#: include/drm/drm_crtc.h:515 include/drm/drm_crtc.h:566
#: include/drm/drm_crtc.h:610 include/drm/drm_crtc.h:644
#: include/drm/drm_crtc.h:694 include/drm/drm_crtc.h:719
#: include/drm/drm_crtc.h:779 include/drm/drm_crtc.h:795
#: include/drm/drm_crtc.h:814 ../../../gpu/drm-kms:342:
#: include/drm/drm_framebuffer.h:69 include/drm/drm_framebuffer.h:93
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:314
#: include/drm/drm_plane.h:337 include/drm/drm_plane.h:375
#: include/drm/drm_plane.h:409 include/drm/drm_plane.h:459
#: include/drm/drm_plane.h:485 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1317 include/drm/drm_connector.h:1362
#: include/drm/drm_connector.h:1404 include/drm/drm_connector.h:1420
#: include/drm/drm_connector.h:1495 include/drm/drm_connector.h:1545
#: include/drm/drm_connector.h:1571
msgid "RETURNS:"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:79
msgid ""
"A new framebuffer with an initial reference count of 1 or a negative error "
"code encoded with ERR_PTR()."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:89
msgid "``get_format_info``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:90
msgid ""
"Allows a driver to return custom format information for special fb layouts "
"(eg. ones with auxiliary compression control planes)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:95
msgid ""
"The format information specific to the given fb metadata, or NULL if none is "
"found."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:102
msgid "``mode_valid``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:103
msgid ""
"Device specific validation of display modes. Can be used to reject modes "
"that can never be supported. Only device wide constraints can be checked "
"here. crtc/encoder/bridge/connector specific constraints should be checked "
"in the .mode_valid() hook for each specific object."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:113
msgid "``atomic_check``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:114
msgid ""
"This is the only hook to validate an atomic modeset update. This function "
"must reject any modeset and state changes which the hardware or driver "
"doesn't support. This includes but is of course not limited to:"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:119
msgid ""
"Checking that the modes, framebuffers, scaling and placement requirements "
"and so on are within the limits of the hardware."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:122
msgid ""
"Checking that any hidden shared resources are not oversubscribed. This can "
"be shared PLLs, shared lanes, overall memory bandwidth, display fifo space "
"(where shared between planes or maybe even CRTCs)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:127
msgid ""
"Checking that virtualized resources exported to userspace are not "
"oversubscribed. For various reasons it can make sense to expose more planes, "
"crtcs or encoders than which are physically there. One example is dual-pipe "
"operations (which generally should be hidden from userspace if when "
"lockstepped in hardware, exposed otherwise), where a plane might need 1 "
"hardware plane (if it's just on one pipe), 2 hardware planes (when it spans "
"both pipes) or maybe even shared a hardware plane with a 2nd plane (if "
"there's a compatible plane requested on the area handled by the other pipe)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:137
msgid ""
"Check that any transitional state is possible and that if requested, the "
"update can indeed be done in the vblank period without temporarily disabling "
"some functions."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:141
msgid "Check any other constraints the driver or hardware might have."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:143
msgid ""
"This callback also needs to correctly fill out the :c:type:`drm_crtc_state` "
"in this update to make sure that drm_atomic_crtc_needs_modeset() reflects "
"the nature of the possible update and returns true if and only if the update "
"cannot be applied without tearing within one vblank on that CRTC. The core "
"uses that information to reject updates which require a full modeset (i.e. "
"blanking the screen, or at least pausing updates for a substantial amount of "
"time) if userspace has disallowed that in its request."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:152
msgid ""
"The driver also does not need to repeat basic input validation like done for "
"the corresponding legacy entry points. The core does that before calling "
"this hook."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:156
msgid ""
"See the documentation of **atomic_commit** for an exhaustive list of error "
"conditions which don't have to be checked at the in this callback."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:160
#: include/drm/drm_mode_config.h:196
msgid ""
"See the documentation for :c:type:`struct drm_atomic_state "
"<drm_atomic_state>` for how exactly an atomic modeset update is described."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:163
msgid ""
"Drivers using the atomic helpers can implement this hook using "
"drm_atomic_helper_check(), or one of the exported sub-functions of it."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:169
#: include/drm/drm_mode_config.h:237
msgid "0 on success or one of the below negative error codes:"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:171
msgid "-EINVAL, if any of the above constraints are violated."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:173
msgid ""
"-EDEADLK, when returned from an attempt to acquire an additional :c:type:"
"`drm_modeset_lock` through drm_modeset_lock()."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:176
msgid ""
"-ENOMEM, if allocating additional state sub-structures failed due to lack of "
"memory."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:179
msgid ""
"-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted. This can "
"either be due to a pending signal, or because the driver needs to completely "
"bail out to recover from an exceptional situation like a GPU hang. From a "
"userspace point all errors are treated equally."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:190
msgid "``atomic_commit``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:191
msgid ""
"This is the only hook to commit an atomic modeset update. The core "
"guarantees that **atomic_check** has been called successfully before calling "
"this function, and that nothing has been changed in the interim."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:199
msgid ""
"Drivers using the atomic helpers can implement this hook using "
"drm_atomic_helper_commit(), or one of the exported sub-functions of it."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:203
msgid ""
"Nonblocking commits (as indicated with the nonblock parameter) must do any "
"preparatory work which might result in an unsuccessful commit in the context "
"of this callback. The only exceptions are hardware errors resulting in -EIO. "
"But even in that case the driver must ensure that the display pipe is at "
"least running, to avoid compositors crashing when pageflips don't work. "
"Anything else, specifically committing the update to the hardware, should be "
"done without blocking the caller. For updates which do not require a modeset "
"this must be guaranteed."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:213
msgid ""
"The driver must wait for any pending rendering to the new framebuffers to "
"complete before executing the flip. It should also wait for any pending "
"rendering from other drivers if the underlying buffer is a shared dma-buf. "
"Nonblocking commits must not wait for rendering in the context of this "
"callback."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:219
msgid ""
"An application can request to be notified when the atomic commit has "
"completed. These events are per-CRTC and can be distinguished by the CRTC "
"index supplied in :c:type:`drm_event` to userspace."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:223
msgid ""
"The drm core will supply a :c:type:`struct drm_event <drm_event>` in each "
"CRTC's :c:type:`drm_crtc_state.event <drm_crtc_state>`. See the "
"documentation for :c:type:`drm_crtc_state.event <drm_crtc_state>` for more "
"details about the precise semantics of this event."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:228
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:557
#: include/drm/drm_crtc.h:638 include/drm/drm_crtc.h:681
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:403
#: include/drm/drm_plane.h:446 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1489 include/drm/drm_connector.h:1532
msgid "NOTE:"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:230
msgid ""
"Drivers are not allowed to shut down any display pipe successfully enabled "
"through an atomic commit on their own. Doing so can result in compositors "
"crashing if a page flip is suddenly rejected because the pipe is off."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:239
msgid ""
"-EBUSY, if a nonblocking updated is requested and there is an earlier "
"updated pending. Drivers are allowed to support a queue of outstanding "
"updates, but currently no driver supports that. Note that drivers must wait "
"for preceding updates to complete if a synchronous update is requested, they "
"are not allowed to fail the commit in that case."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:246
msgid ""
"-ENOMEM, if the driver failed to allocate memory. Specifically this can "
"happen when trying to pin framebuffers, which must only be done when "
"committing the state."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:250
msgid ""
"-ENOSPC, as a refinement of the more generic -ENOMEM to indicate that the "
"driver has run out of vram, iommu space or similar GPU address space needed "
"for framebuffer."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:254
msgid "-EIO, if the hardware completely died."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:256
msgid ""
"-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted. This can "
"either be due to a pending signal, or because the driver needs to completely "
"bail out to recover from an exceptional situation like a GPU hang. From a "
"userspace point of view all errors are treated equally."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:262
msgid ""
"This list is exhaustive. Specifically this hook is not allowed to return -"
"EINVAL (any invalid requests should be caught in **atomic_check**) or -"
"EDEADLK (this function must not acquire additional modeset locks)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:273
msgid "``atomic_state_alloc``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:274
msgid ""
"This optional hook can be used by drivers that want to subclass struct :c:"
"type:`drm_atomic_state` to be able to track their own driver-private global "
"state easily. If this hook is implemented, drivers must also implement "
"**atomic_state_clear** and **atomic_state_free**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:279
#: include/drm/drm_mode_config.h:304 include/drm/drm_mode_config.h:319
msgid ""
"Subclassing of :c:type:`drm_atomic_state` is deprecated in favour of using :"
"c:type:`drm_private_state` and :c:type:`drm_private_obj`."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:284
msgid "A new :c:type:`drm_atomic_state` on success or NULL on failure."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:290
msgid "``atomic_state_clear``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:291
msgid ""
"This hook must clear any driver private state duplicated into the passed-in :"
"c:type:`drm_atomic_state`. This hook is called when the caller encountered "
"a :c:type:`drm_modeset_lock` deadlock and needs to drop all already acquired "
"locks as part of the deadlock avoidance dance implemented in "
"drm_modeset_backoff()."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:297
msgid ""
"Any duplicated state must be invalidated since a concurrent atomic update "
"might change it, and the drm atomic interfaces always apply updates as "
"relative changes to the current state."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:301
msgid ""
"Drivers that implement this must call drm_atomic_state_default_clear() to "
"clear common state."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:311
msgid "``atomic_state_free``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:312
msgid ""
"This hook needs driver private resources and the :c:type:`drm_atomic_state` "
"itself. Note that the core first calls drm_atomic_state_clear() to avoid "
"code duplicate between the clear and free hooks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:316
msgid ""
"Drivers that implement this must call drm_atomic_state_default_release() to "
"release common resources."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:323
#: include/drm/drm_mode_config.h:345 include/drm/drm_mode_config.h:972
#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:188
#: drivers/gpu/drm/drm_mode_config.c:412 drivers/gpu/drm/drm_mode_config.c:500
#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:43
#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:172
#: drivers/gpu/drm/drm_mode_object.c:191 drivers/gpu/drm/drm_mode_object.c:208
#: drivers/gpu/drm/drm_mode_object.c:227 drivers/gpu/drm/drm_mode_object.c:271
#: drivers/gpu/drm/drm_mode_object.c:341 drivers/gpu/drm/drm_mode_object.c:368
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:157
#: include/drm/drm_atomic.h:240 include/drm/drm_atomic.h:309
#: include/drm/drm_atomic.h:319 include/drm/drm_atomic.h:342
#: include/drm/drm_atomic.h:526 include/drm/drm_atomic.h:535
#: include/drm/drm_atomic.h:550 include/drm/drm_atomic.h:568
#: include/drm/drm_atomic.h:583 include/drm/drm_atomic.h:644
#: include/drm/drm_atomic.h:662 include/drm/drm_atomic.h:676
#: include/drm/drm_atomic.h:691 include/drm/drm_atomic.h:709
#: include/drm/drm_atomic.h:724 include/drm/drm_atomic.h:739
#: include/drm/drm_atomic.h:762 include/drm/drm_atomic.h:782
#: include/drm/drm_atomic.h:802 include/drm/drm_atomic.h:859
#: include/drm/drm_atomic.h:881 include/drm/drm_atomic.h:902
#: include/drm/drm_atomic.h:924 include/drm/drm_atomic.h:947
#: include/drm/drm_atomic.h:967 include/drm/drm_atomic.h:989
#: include/drm/drm_atomic.h:1012 include/drm/drm_atomic.h:1048
#: include/drm/drm_atomic.h:1066 include/drm/drm_atomic.h:1088
#: include/drm/drm_atomic.h:1107 include/drm/drm_atomic.h:1125
#: include/drm/drm_atomic.h:1141 include/drm/drm_atomic.h:1167
#: include/drm/drm_atomic.h:1209 ../../../gpu/drm-kms:297:
#: drivers/gpu/drm/drm_atomic.c:62 drivers/gpu/drm/drm_atomic.c:101
#: drivers/gpu/drm/drm_atomic.c:119 drivers/gpu/drm/drm_atomic.c:163
#: drivers/gpu/drm/drm_atomic.c:191 drivers/gpu/drm/drm_atomic.c:275
#: drivers/gpu/drm/drm_atomic.c:301 drivers/gpu/drm/drm_atomic.c:330
#: drivers/gpu/drm/drm_atomic.c:514 drivers/gpu/drm/drm_atomic.c:782
#: drivers/gpu/drm/drm_atomic.c:807 drivers/gpu/drm/drm_atomic.c:823
#: drivers/gpu/drm/drm_atomic.c:882 drivers/gpu/drm/drm_atomic.c:904
#: drivers/gpu/drm/drm_atomic.c:926 drivers/gpu/drm/drm_atomic.c:964
#: drivers/gpu/drm/drm_atomic.c:1001 drivers/gpu/drm/drm_atomic.c:1054
#: drivers/gpu/drm/drm_atomic.c:1084 drivers/gpu/drm/drm_atomic.c:1114
#: drivers/gpu/drm/drm_atomic.c:1223 drivers/gpu/drm/drm_atomic.c:1251
#: drivers/gpu/drm/drm_atomic.c:1273 drivers/gpu/drm/drm_atomic.c:1295
#: drivers/gpu/drm/drm_atomic.c:1339 drivers/gpu/drm/drm_atomic.c:1400
#: drivers/gpu/drm/drm_atomic.c:1444 drivers/gpu/drm/drm_atomic.c:1552
#: drivers/gpu/drm/drm_atomic.c:1585 drivers/gpu/drm/drm_atomic.c:1792
#: drivers/gpu/drm/drm_atomic.c:1884 ../../../gpu/drm-kms:306:
#: drivers/gpu/drm/drm_atomic_uapi.c:62 drivers/gpu/drm/drm_atomic_uapi.c:114
#: drivers/gpu/drm/drm_atomic_uapi.c:179 drivers/gpu/drm/drm_atomic_uapi.c:235
#: drivers/gpu/drm/drm_atomic_uapi.c:265 ../../../gpu/drm-kms:318:
#: include/drm/drm_crtc.h:3 include/drm/drm_crtc.h:390
#: include/drm/drm_crtc.h:920 include/drm/drm_crtc.h:1179
#: include/drm/drm_crtc.h:1192 include/drm/drm_crtc.h:1262
#: include/drm/drm_crtc.h:1274 include/drm/drm_crtc.h:1291
#: include/drm/drm_crtc.h:1309 include/drm/drm_crtc.h:1319
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:3
#: drivers/gpu/drm/drm_crtc.c:81 drivers/gpu/drm/drm_crtc.c:479
#: drivers/gpu/drm/drm_crtc.c:633 drivers/gpu/drm/drm_crtc.c:920
#: drivers/gpu/drm/drm_crtc.c:948 ../../../gpu/drm-kms:327:
#: drivers/gpu/drm/drm_color_mgmt.c:124 drivers/gpu/drm/drm_color_mgmt.c:158
#: drivers/gpu/drm/drm_color_mgmt.c:201 drivers/gpu/drm/drm_color_mgmt.c:525
#: drivers/gpu/drm/drm_color_mgmt.c:600 drivers/gpu/drm/drm_color_mgmt.c:648
#: drivers/gpu/drm/drm_color_mgmt.c:667 drivers/gpu/drm/drm_color_mgmt.c:697
#: drivers/gpu/drm/drm_color_mgmt.c:731 drivers/gpu/drm/drm_color_mgmt.c:757
#: drivers/gpu/drm/drm_color_mgmt.c:786 drivers/gpu/drm/drm_color_mgmt.c:807
#: drivers/gpu/drm/drm_color_mgmt.c:833 ../../../gpu/drm-kms:330:
#: include/drm/drm_color_mgmt.h:38 include/drm/drm_color_mgmt.h:111
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:210
#: include/drm/drm_framebuffer.h:227 include/drm/drm_framebuffer.h:238
#: include/drm/drm_framebuffer.h:250 include/drm/drm_framebuffer.h:262
#: include/drm/drm_framebuffer.h:325 ../../../gpu/drm-kms:345:
#: drivers/gpu/drm/drm_framebuffer.c:851 drivers/gpu/drm/drm_framebuffer.c:919
#: drivers/gpu/drm/drm_framebuffer.c:941 drivers/gpu/drm/drm_framebuffer.c:969
#: drivers/gpu/drm/drm_framebuffer.c:1138 ../../../gpu/drm-kms:360:
#: drivers/gpu/drm/drm_fourcc.c:38 drivers/gpu/drm/drm_fourcc.c:113
#: drivers/gpu/drm/drm_fourcc.c:147 drivers/gpu/drm/drm_fourcc.c:400
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:3
#: include/drm/drm_plane.h:264 include/drm/drm_plane.h:594
#: include/drm/drm_plane.h:807 include/drm/drm_plane.h:915
#: include/drm/drm_plane.h:945 include/drm/drm_plane.h:963
#: include/drm/drm_plane.h:974 include/drm/drm_plane.h:987
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:3
#: drivers/gpu/drm/drm_plane.c:679 drivers/gpu/drm/drm_plane.c:718
#: drivers/gpu/drm/drm_plane.c:738 drivers/gpu/drm/drm_plane.c:779
#: drivers/gpu/drm/drm_plane.c:1652 drivers/gpu/drm/drm_plane.c:1668
#: drivers/gpu/drm/drm_plane.c:1692 drivers/gpu/drm/drm_plane.c:1764
#: drivers/gpu/drm/drm_plane.c:1794 ../../../gpu/drm-kms:389:
#: drivers/gpu/drm/drm_blend.c:216 drivers/gpu/drm/drm_blend.c:250
#: drivers/gpu/drm/drm_blend.c:318 drivers/gpu/drm/drm_blend.c:352
#: drivers/gpu/drm/drm_blend.c:403 drivers/gpu/drm/drm_blend.c:503
#: drivers/gpu/drm/drm_blend.c:556 ../../../gpu/drm-kms:395:
#: drivers/gpu/drm/drm_damage_helper.c:60
#: drivers/gpu/drm/drm_damage_helper.c:98
#: drivers/gpu/drm/drm_damage_helper.c:212
#: drivers/gpu/drm/drm_damage_helper.c:260
#: drivers/gpu/drm/drm_damage_helper.c:303 ../../../gpu/drm-kms:398:
#: include/drm/drm_damage_helper.h:42 include/drm/drm_damage_helper.h:62
#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:81
#: include/drm/drm_panic.h:90 include/drm/drm_panic.h:141
#: include/drm/drm_panic.h:164 ../../../gpu/drm-kms:413:
#: drivers/gpu/drm/drm_panic.c:913 ../../../gpu/drm-kms:419:
#: include/drm/drm_modes.h:164 include/drm/drm_modes.h:172
#: include/drm/drm_modes.h:177 include/drm/drm_modes.h:418
#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:56
#: drivers/gpu/drm/drm_modes.c:68 drivers/gpu/drm/drm_modes.c:91
#: drivers/gpu/drm/drm_modes.c:107 drivers/gpu/drm/drm_modes.c:533
#: drivers/gpu/drm/drm_modes.c:609 drivers/gpu/drm/drm_modes.c:840
#: drivers/gpu/drm/drm_modes.c:1028 drivers/gpu/drm/drm_modes.c:1069
#: drivers/gpu/drm/drm_modes.c:1110 drivers/gpu/drm/drm_modes.c:1152
#: drivers/gpu/drm/drm_modes.c:1184 drivers/gpu/drm/drm_modes.c:1219
#: drivers/gpu/drm/drm_modes.c:1267 drivers/gpu/drm/drm_modes.c:1317
#: drivers/gpu/drm/drm_modes.c:1338 drivers/gpu/drm/drm_modes.c:1417
#: drivers/gpu/drm/drm_modes.c:1434 drivers/gpu/drm/drm_modes.c:1451
#: drivers/gpu/drm/drm_modes.c:1526 drivers/gpu/drm/drm_modes.c:1570
#: drivers/gpu/drm/drm_modes.c:1592 drivers/gpu/drm/drm_modes.c:1613
#: drivers/gpu/drm/drm_modes.c:1663 drivers/gpu/drm/drm_modes.c:1693
#: drivers/gpu/drm/drm_modes.c:1720 drivers/gpu/drm/drm_modes.c:1801
#: drivers/gpu/drm/drm_modes.c:1868 drivers/gpu/drm/drm_modes.c:1880
#: drivers/gpu/drm/drm_modes.c:2343 drivers/gpu/drm/drm_modes.c:2764
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:89
#: include/drm/drm_connector.h:132 include/drm/drm_connector.h:200
#: include/drm/drm_connector.h:298 include/drm/drm_connector.h:337
#: include/drm/drm_connector.h:352 include/drm/drm_connector.h:384
#: include/drm/drm_connector.h:422 include/drm/drm_connector.h:438
#: include/drm/drm_connector.h:460 include/drm/drm_connector.h:544
#: include/drm/drm_connector.h:605 include/drm/drm_connector.h:865
#: include/drm/drm_connector.h:897 include/drm/drm_connector.h:1609
#: include/drm/drm_connector.h:1755 include/drm/drm_connector.h:1817
#: include/drm/drm_connector.h:2309 include/drm/drm_connector.h:2365
#: include/drm/drm_connector.h:2381 include/drm/drm_connector.h:2392
#: include/drm/drm_connector.h:2405 include/drm/drm_connector.h:2500
#: include/drm/drm_connector.h:2528 include/drm/drm_connector.h:2550
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:388
#: drivers/gpu/drm/drm_connector.c:422 drivers/gpu/drm/drm_connector.c:463
#: drivers/gpu/drm/drm_connector.c:508 drivers/gpu/drm/drm_connector.c:558
#: drivers/gpu/drm/drm_connector.c:634 drivers/gpu/drm/drm_connector.c:653
#: drivers/gpu/drm/drm_connector.c:710 drivers/gpu/drm/drm_connector.c:728
#: drivers/gpu/drm/drm_connector.c:750 drivers/gpu/drm/drm_connector.c:817
#: drivers/gpu/drm/drm_connector.c:890 drivers/gpu/drm/drm_connector.c:916
#: drivers/gpu/drm/drm_connector.c:989 drivers/gpu/drm/drm_connector.c:1038
#: drivers/gpu/drm/drm_connector.c:1113 drivers/gpu/drm/drm_connector.c:1146
#: drivers/gpu/drm/drm_connector.c:1176 drivers/gpu/drm/drm_connector.c:1268
#: drivers/gpu/drm/drm_connector.c:1866 drivers/gpu/drm/drm_connector.c:1899
#: drivers/gpu/drm/drm_connector.c:2049 drivers/gpu/drm/drm_connector.c:2068
#: drivers/gpu/drm/drm_connector.c:2094 drivers/gpu/drm/drm_connector.c:2137
#: drivers/gpu/drm/drm_connector.c:2240 drivers/gpu/drm/drm_connector.c:2280
#: drivers/gpu/drm/drm_connector.c:2374 drivers/gpu/drm/drm_connector.c:2405
#: drivers/gpu/drm/drm_connector.c:2464 drivers/gpu/drm/drm_connector.c:2611
#: drivers/gpu/drm/drm_connector.c:2636 drivers/gpu/drm/drm_connector.c:2660
#: drivers/gpu/drm/drm_connector.c:2687 drivers/gpu/drm/drm_connector.c:2715
#: drivers/gpu/drm/drm_connector.c:2743 drivers/gpu/drm/drm_connector.c:2789
#: drivers/gpu/drm/drm_connector.c:2820 drivers/gpu/drm/drm_connector.c:2852
#: drivers/gpu/drm/drm_connector.c:2873 drivers/gpu/drm/drm_connector.c:2906
#: drivers/gpu/drm/drm_connector.c:2927 drivers/gpu/drm/drm_connector.c:2956
#: drivers/gpu/drm/drm_connector.c:2976 drivers/gpu/drm/drm_connector.c:3036
#: drivers/gpu/drm/drm_connector.c:3064 drivers/gpu/drm/drm_connector.c:3097
#: drivers/gpu/drm/drm_connector.c:3126 drivers/gpu/drm/drm_connector.c:3185
#: drivers/gpu/drm/drm_connector.c:3208 drivers/gpu/drm/drm_connector.c:3492
#: drivers/gpu/drm/drm_connector.c:3545 drivers/gpu/drm/drm_connector.c:3559
#: drivers/gpu/drm/drm_connector.c:3589 ../../../gpu/drm-kms:449:
#: drivers/gpu/drm/drm_writeback.c:159 drivers/gpu/drm/drm_writeback.c:303
#: drivers/gpu/drm/drm_writeback.c:382 drivers/gpu/drm/drm_writeback.c:461
#: drivers/gpu/drm/drm_writeback.c:530 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:3 include/drm/drm_encoder.h:90
#: include/drm/drm_encoder.h:200 include/drm/drm_encoder.h:269
#: include/drm/drm_encoder.h:281 include/drm/drm_encoder.h:294
#: include/drm/drm_encoder.h:308 include/drm/drm_encoder.h:330
#: include/drm/drm_encoder.h:341 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:3 drivers/gpu/drm/drm_encoder.c:185
#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:44
#: include/drm/drm_modeset_lock.h:85 include/drm/drm_modeset_lock.h:158
#: include/drm/drm_modeset_lock.h:190 ../../../gpu/drm-kms:476:
#: drivers/gpu/drm/drm_modeset_lock.c:134
#: drivers/gpu/drm/drm_modeset_lock.c:189
#: drivers/gpu/drm/drm_modeset_lock.c:221
#: drivers/gpu/drm/drm_modeset_lock.c:244
#: drivers/gpu/drm/drm_modeset_lock.c:274
#: drivers/gpu/drm/drm_modeset_lock.c:340
#: drivers/gpu/drm/drm_modeset_lock.c:381
#: drivers/gpu/drm/drm_modeset_lock.c:409
#: drivers/gpu/drm/drm_modeset_lock.c:436 ../../../gpu/drm-kms:527:
#: include/drm/drm_property.h:39 include/drm/drm_property.h:197
#: include/drm/drm_property.h:212 include/drm/drm_property.h:238
#: include/drm/drm_property.h:305 ../../../gpu/drm-kms:530:
#: drivers/gpu/drm/drm_property.c:89 drivers/gpu/drm/drm_property.c:151
#: drivers/gpu/drm/drm_property.c:199 drivers/gpu/drm/drm_property.c:266
#: drivers/gpu/drm/drm_property.c:294 drivers/gpu/drm/drm_property.c:321
#: drivers/gpu/drm/drm_property.c:359 drivers/gpu/drm/drm_property.c:382
#: drivers/gpu/drm/drm_property.c:438 drivers/gpu/drm/drm_property.c:547
#: drivers/gpu/drm/drm_property.c:599 drivers/gpu/drm/drm_property.c:629
#: drivers/gpu/drm/drm_property.c:644 drivers/gpu/drm/drm_property.c:674
#: drivers/gpu/drm/drm_property.c:764 ../../../gpu/drm-kms:632:
#: include/drm/drm_vblank.h:258 ../../../gpu/drm-kms:635:
#: drivers/gpu/drm/drm_vblank.c:404 drivers/gpu/drm/drm_vblank.c:520
#: drivers/gpu/drm/drm_vblank.c:569 drivers/gpu/drm/drm_vblank.c:590
#: drivers/gpu/drm/drm_vblank.c:606 drivers/gpu/drm/drm_vblank.c:676
#: drivers/gpu/drm/drm_vblank.c:818 drivers/gpu/drm/drm_vblank.c:905
#: drivers/gpu/drm/drm_vblank.c:969 drivers/gpu/drm/drm_vblank.c:995
#: drivers/gpu/drm/drm_vblank.c:1066 drivers/gpu/drm/drm_vblank.c:1118
#: drivers/gpu/drm/drm_vblank.c:1228 drivers/gpu/drm/drm_vblank.c:1267
#: drivers/gpu/drm/drm_vblank.c:1282 drivers/gpu/drm/drm_vblank.c:1318
#: drivers/gpu/drm/drm_vblank.c:1332 drivers/gpu/drm/drm_vblank.c:1410
#: drivers/gpu/drm/drm_vblank.c:1444 drivers/gpu/drm/drm_vblank.c:1475
#: drivers/gpu/drm/drm_vblank.c:1520 drivers/gpu/drm/drm_vblank.c:1581
#: drivers/gpu/drm/drm_vblank.c:1913 drivers/gpu/drm/drm_vblank.c:1976
#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:56
#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:95
#: drivers/gpu/drm/drm_vblank_work.c:177 drivers/gpu/drm/drm_vblank_work.c:221
#: drivers/gpu/drm/drm_vblank_work.c:241 drivers/gpu/drm/drm_vblank_work.c:265
msgid "**Description**"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:43
msgid ""
"Some global (i.e. not per-CRTC, connector, etc) mode setting functions that "
"involve drivers."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:327
msgid "Mode configuration control structure"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:362
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:950
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:650
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1870
#: include/drm/drm_connector.h:1934 ../../../gpu/drm-kms:473:
#: include/drm/drm_modeset_lock.h:79
msgid "``mutex``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:363
msgid ""
"This is the big scary modeset BKL which protects everything that isn't "
"protect otherwise. Scope is unclear and fuzzy, try to remove anything from "
"under its protection and move it into more well-scoped locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:368
msgid "The one important thing this protects is the use of **acquire_ctx**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:374
msgid "``connection_mutex``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:375
msgid ""
"This protects connector state and the connector to encoder to CRTC routing "
"chain."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:378
msgid ""
"For atomic drivers specifically this protects :c:type:`drm_connector.state "
"<drm_connector>`."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:384
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:504
msgid "``acquire_ctx``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:385
msgid ""
"Global implicit acquire context used by atomic drivers for legacy IOCTLs. "
"Deprecated, since implicit locking contexts make it impossible to use driver-"
"private :c:type:`struct drm_modeset_lock <drm_modeset_lock>`. Users of this "
"must hold **mutex**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:394
msgid "``idr_mutex``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:395
msgid ""
"Mutex for KMS ID allocation and management. Protects both **object_idr** and "
"**tile_idr**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:402
msgid "``object_idr``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:403
msgid ""
"Main KMS ID tracking object. Use this idr for all IDs, fb, crtc, connector, "
"modes - just makes life easier to have only one."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:410
msgid "``tile_idr``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:411
msgid ""
"Use this idr for allocating new IDs for tiled sinks like use in some high-"
"res DP MST screens."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:417
msgid "``fb_lock``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:418
msgid "Mutex to protect fb the global **fb_list** and **num_fb**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:419
msgid "``num_fb``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:420
msgid "Number of entries on **fb_list**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:421
msgid "``fb_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:422
msgid "List of all :c:type:`struct drm_framebuffer <drm_framebuffer>`."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:425
msgid "``connector_list_lock``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:426
msgid ""
"Protects **num_connector** and **connector_list** and "
"**connector_free_list**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:430
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:478
msgid "``num_connector``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:431
msgid ""
"Number of connectors on this device. Protected by **connector_list_lock**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:435
msgid "``connector_ida``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:436
msgid "ID allocator for connector indices."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:439
msgid "``connector_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:440
msgid ""
"List of connector objects linked with :c:type:`drm_connector.head "
"<drm_connector>`. Protected by **connector_list_lock**. Only use "
"drm_for_each_connector_iter() and :c:type:`struct drm_connector_list_iter "
"<drm_connector_list_iter>` to walk this list."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:447
msgid "``connector_free_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:448
msgid ""
"List of connector objects linked with :c:type:`drm_connector.free_head "
"<drm_connector>`. Protected by **connector_list_lock**. Used by "
"drm_for_each_connector_iter() and :c:type:`struct drm_connector_list_iter "
"<drm_connector_list_iter>` to savely free connectors using "
"**connector_free_work**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:457
msgid "``connector_free_work``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:458
msgid "Work to clean up **connector_free_list**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:462
msgid "``num_encoder``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:463
msgid ""
"Number of encoders on this device. This is invariant over the lifetime of a "
"device and hence doesn't need any locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:469
msgid "``encoder_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:470
msgid ""
"List of encoder objects linked with :c:type:`drm_encoder.head "
"<drm_encoder>`. This is invariant over the lifetime of a device and hence "
"doesn't need any locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:478
msgid "``num_total_plane``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:479
msgid ""
"Number of universal (i.e. with primary/curso) planes on this device. This is "
"invariant over the lifetime of a device and hence doesn't need any locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:486
msgid "``plane_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:487
msgid ""
"List of plane objects linked with :c:type:`drm_plane.head <drm_plane>`. This "
"is invariant over the lifetime of a device and hence doesn't need any locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:494
msgid "``panic_lock``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:495
msgid ""
"Raw spinlock used to protect critical sections of code that access the "
"display hardware or modeset software state, which the panic printing code "
"must be protected against. See drm_panic_trylock(), drm_panic_lock() and "
"drm_panic_unlock()."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:504
msgid "``num_crtc``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:505
msgid ""
"Number of CRTCs on this device linked with :c:type:`drm_crtc.head "
"<drm_crtc>`. This is invariant over the lifetime of a device and hence "
"doesn't need any locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:511
msgid "``crtc_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:512
msgid ""
"List of CRTC objects linked with :c:type:`drm_crtc.head <drm_crtc>`. This is "
"invariant over the lifetime of a device and hence doesn't need any locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:519
msgid "``property_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:520
msgid ""
"List of property type objects linked with :c:type:`drm_property.head "
"<drm_property>`. This is invariant over the lifetime of a device and hence "
"doesn't need any locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:528
msgid "``privobj_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:529
msgid ""
"List of private objects linked with :c:type:`drm_private_obj.head "
"<drm_private_obj>`. This is invariant over the lifetime of a device and "
"hence doesn't need any locks."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:328
msgid "``min_width``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:329
msgid "minimum fb pixel width on this device"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:329
msgid "``min_height``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:330
msgid "minimum fb pixel height on this device"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:330
msgid "``max_width``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:331
msgid "maximum fb pixel width on this device"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:331
msgid "``max_height``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:332
msgid "maximum fb pixel height on this device"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:332
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:304
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1058
#: include/drm/drm_crtc.h:1242 ../../../gpu/drm-kms:342:
#: include/drm/drm_framebuffer.h:146 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:709 include/drm/drm_plane.h:840
#: include/drm/drm_plane.h:885 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1766 include/drm/drm_connector.h:1875
#: include/drm/drm_connector.h:2023 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:99 include/drm/drm_encoder.h:230
#: include/drm/drm_encoder.h:251
msgid "``funcs``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:333
msgid "core driver provided mode setting functions"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:333
msgid "``poll_enabled``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:334
msgid "track polling support for this device"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:334
msgid "``poll_running``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:335
msgid "track polling status for this device"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:335
msgid "``delayed_event``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:336
msgid "track delayed poll uevent deliver for this device"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:336
msgid "``output_poll_work``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:337
msgid "delayed work for polling in process context"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:547
msgid "``blob_lock``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:548
msgid ""
"Mutex for blob property allocation and management, protects "
"**property_blob_list** and :c:type:`drm_file.blobs <drm_file>`."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:555
msgid "``property_blob_list``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:556
msgid ""
"List of all the blob property objects linked with :c:type:`drm_property_blob."
"head <drm_property_blob>`. Protected by **blob_lock**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:565
msgid "``edid_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:566
msgid ""
"Default connector property to hold the EDID of the currently connected sink, "
"if any."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:570
msgid "``dpms_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:571
msgid "Default connector property to control the connector's DPMS state."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:575
msgid "``path_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:576
msgid "Default connector property to hold the DP MST path for the port."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:580
msgid "``tile_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:581
msgid ""
"Default connector property to store the tile position of a tiled screen, for "
"sinks which need to be driven with multiple CRTCs."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:586
msgid "``link_status_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:587
msgid "Default connector property for link status of a connector"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:591
msgid "``plane_type_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:592
msgid ""
"Default plane property to differentiate CURSOR, PRIMARY and OVERLAY legacy "
"uses of planes."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:596
msgid "``prop_src_x``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:597
#: include/drm/drm_mode_config.h:602 include/drm/drm_mode_config.h:607
#: include/drm/drm_mode_config.h:612
msgid ""
"Default atomic plane property for the plane source position in the "
"connected :c:type:`drm_framebuffer`."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:601
msgid "``prop_src_y``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:606
msgid "``prop_src_w``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:611
msgid "``prop_src_h``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:616
msgid "``prop_crtc_x``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:617
#: include/drm/drm_mode_config.h:622 include/drm/drm_mode_config.h:627
#: include/drm/drm_mode_config.h:632
msgid ""
"Default atomic plane property for the plane destination position in the :c:"
"type:`drm_crtc` is being shown on."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:621
msgid "``prop_crtc_y``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:626
msgid "``prop_crtc_w``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:631
msgid "``prop_crtc_h``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:636
msgid "``prop_fb_id``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:637
msgid "Default atomic plane property to specify the :c:type:`drm_framebuffer`."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:641
msgid "``prop_in_fence_fd``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:642
msgid "Sync File fd representing the incoming fences for a Plane."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:646
msgid "``prop_out_fence_ptr``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:647
msgid ""
"Sync File fd pointer representing the outgoing fences for a CRTC. Userspace "
"should provide a pointer to a value of type s32, and then cast that pointer "
"to u64."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:652
msgid "``prop_crtc_id``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:653
msgid "Default atomic plane property to specify the :c:type:`drm_crtc`."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:657
msgid "``prop_fb_damage_clips``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:658
msgid ""
"Optional plane property to mark damaged regions on the plane in framebuffer "
"coordinates of the framebuffer attached to the plane."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:662
msgid ""
"The layout of blob data is simply an array of :c:type:`drm_mode_rect`. "
"Unlike plane src coordinates, damage clips are not in 16.16 fixed point."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:666
msgid "``prop_active``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:667
msgid ""
"Default atomic CRTC property to control the active state, which is the "
"simplified implementation for DPMS in atomic drivers."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:672
msgid "``prop_mode_id``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:673
msgid ""
"Default atomic CRTC property to set the mode for a CRTC. A 0 mode implies "
"that the CRTC is entirely disabled - all connectors must be of and active "
"must be set to disabled, too."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:678
msgid "``prop_vrr_enabled``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:679
msgid ""
"Default atomic CRTC property to indicate whether variable refresh rate "
"should be enabled on the CRTC."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:684
msgid "``dvi_i_subconnector_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:685
msgid ""
"Optional DVI-I property to differentiate between analog or digital mode."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:689
msgid "``dvi_i_select_subconnector_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:690
msgid "Optional DVI-I property to select between analog or digital mode."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:695
msgid "``dp_subconnector_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:696
msgid ""
"Optional DP property to differentiate between different DP downstream port "
"types."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:701
msgid "``tv_subconnector_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:702
msgid ""
"Optional TV property to differentiate between different TV connector types."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:706
msgid "``tv_select_subconnector_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:707
msgid "Optional TV property to select between different TV connector types."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:712
msgid "``legacy_tv_mode_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:713
msgid "Optional TV property to select the output TV mode."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:716
msgid "Superseded by **tv_mode_property**"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:720
msgid "``tv_mode_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:721
msgid "Optional TV property to select the TV standard output on the connector."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:726
msgid "``tv_left_margin_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:727
msgid "Optional TV property to set the left margin (expressed in pixels)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:731
msgid "``tv_right_margin_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:732
#: include/drm/drm_mode_config.h:737 include/drm/drm_mode_config.h:742
msgid "Optional TV property to set the right margin (expressed in pixels)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:736
msgid "``tv_top_margin_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:741
msgid "``tv_bottom_margin_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:746
msgid "``tv_brightness_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:747
msgid "Optional TV property to set the brightness."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:751
msgid "``tv_contrast_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:752
msgid "Optional TV property to set the contrast."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:756
msgid "``tv_flicker_reduction_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:757
msgid "Optional TV property to control the flicker reduction mode."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:761
msgid "``tv_overscan_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:762
msgid "Optional TV property to control the overscan setting."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:766
msgid "``tv_saturation_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:767
msgid "Optional TV property to set the saturation."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:771
msgid "``tv_hue_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:772
msgid "Optional TV property to set the hue."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:776
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2041
msgid "``scaling_mode_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:777
msgid ""
"Optional connector property to control the upscaling, mostly used for built-"
"in panels."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:781
msgid "``aspect_ratio_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:782
msgid ""
"Optional connector property to control the HDMI infoframe aspect ratio "
"setting."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:786
msgid "``content_type_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:787
msgid ""
"Optional connector property to control the HDMI infoframe content type "
"setting."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:791
msgid "``degamma_lut_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:792
msgid ""
"Optional CRTC property to set the LUT used to convert the framebuffer's "
"colors to linear gamma."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:796
msgid "``degamma_lut_size_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:797
msgid ""
"Optional CRTC property for the size of the degamma LUT as supported by the "
"driver (read-only)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:801
msgid "``ctm_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:802
msgid ""
"Optional CRTC property to set the matrix used to convert colors after the "
"lookup in the degamma LUT."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:807
msgid "``gamma_lut_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:808
msgid ""
"Optional CRTC property to set the LUT used to convert the colors, after the "
"CTM matrix, to the gamma space of the connected screen."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:813
msgid "``gamma_lut_size_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:814
msgid ""
"Optional CRTC property for the size of the gamma LUT as supported by the "
"driver (read-only)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:819
msgid "``suggested_x_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:820
#: include/drm/drm_mode_config.h:825
msgid ""
"Optional connector property with a hint for the position of the output on "
"the host's screen."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:824
msgid "``suggested_y_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:830
msgid "``non_desktop_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:831
msgid ""
"Optional connector property with a hint that device isn't a standard "
"display, and the console/desktop, should not be displayed on it."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:837
msgid "``panel_orientation_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:838
msgid ""
"Optional connector property indicating how the lcd-panel is mounted inside "
"the casing (e.g. normal or upside-down)."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:844
msgid "``writeback_fb_id_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:845
msgid ""
"Property for writeback connectors, storing the ID of the output framebuffer. "
"See also: drm_writeback_connector_init()"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:851
msgid "``writeback_pixel_formats_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:852
msgid ""
"Property for writeback connectors, storing an array of the supported pixel "
"formats for the writeback engine (read-only). See also: "
"drm_writeback_connector_init()"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:858
msgid "``writeback_out_fence_ptr_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:859
msgid ""
"Property for writeback connectors, fd pointer representing the outgoing "
"fences for a writeback connector. Userspace should provide a pointer to a "
"value of type s32, and then cast that pointer to u64. See also: "
"drm_writeback_connector_init()"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:867
msgid "``hdr_output_metadata_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:868
msgid ""
"Connector property containing hdr metatada. This will be provided by "
"userspace compositors based on HDR content"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:874
msgid "``content_protection_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:875
msgid ""
"DRM ENUM property for content protection. See "
"drm_connector_attach_content_protection_property()."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:880
msgid "``hdcp_content_type_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:881
msgid "DRM ENUM property for type of Protected Content."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:337
msgid "``preferred_depth``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:338
msgid "preferred RBG pixel depth, used by fb helpers"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:338
msgid "``prefer_shadow``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:339
msgid "hint to userspace to prefer shadow-fb rendering"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:889
msgid "``quirk_addfb_prefer_xbgr_30bpp``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:890
msgid ""
"Special hack for legacy ADDFB to keep nouveau userspace happy. Should only "
"ever be set by the nouveau kernel driver."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:897
msgid "``quirk_addfb_prefer_host_byte_order``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:898
msgid ""
"When set to true drm_mode_addfb() will pick host byte order pixel_format "
"when calling drm_mode_addfb2().  This is how drm_mode_addfb() should have "
"worked from day one.  It didn't though, so we ended up with quirks in both "
"kernel and userspace drivers to deal with the broken behavior. Simply fixing "
"drm_mode_addfb() unconditionally would break these drivers, so add a quirk "
"bit here to allow drivers opt-in."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:911
msgid "``async_page_flip``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:912
msgid "Does this device support async flips on the primary plane?"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:917
msgid "``fb_modifiers_not_supported``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:918
msgid ""
"When this flag is set, the DRM device will not expose modifier support to "
"userspace. This is only used by legacy drivers that infer the buffer layout "
"through heuristics without using modifiers. New drivers shall not set fhis "
"flag."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:927
msgid "``normalize_zpos``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:928
msgid ""
"If true the drm core will call drm_atomic_normalize_zpos() as part of atomic "
"mode checking from drm_atomic_helper_check()"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:935
msgid "``modifiers_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:936
msgid "Plane property to list support modifier/format combination."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:941
msgid "``async_modifiers_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:942
msgid ""
"Plane property to list support modifier/format combination for asynchronous "
"flips."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:947
msgid "``size_hints_property``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:948
msgid "Plane SIZE_HINTS property."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:339
msgid "``cursor_width``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:340
msgid "hint to userspace for max cursor width"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:340
msgid "``cursor_height``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:341
msgid "hint to userspace for max cursor height"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:955
msgid "``suspend_state``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:956
msgid ""
"Atomic state when suspended. Set by drm_mode_config_helper_suspend() and "
"cleared by drm_mode_config_helper_resume()."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:341
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1079
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:724
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2141
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:100
msgid "``helper_private``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:342
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1080
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:725
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2142
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:101
msgid "mid-layer private data"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:342
msgid ""
"Core mode resource tracking structure.  All CRTC, encoders, and connectors "
"enumerated by the driver are added here, as are global properties.  Some "
"global restrictions are also here, e.g. dimension restrictions."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:346
msgid ""
"Framebuffer sizes refer to the virtual screen that can be displayed by the "
"CRTC. This can be different from the physical resolution programmed. The "
"minimum width and height, stored in **min_width** and **min_height**, "
"describe the smallest size of the framebuffer. It correlates to the minimum "
"programmable resolution. The maximum width, stored in **max_width**, is "
"typically limited by the maximum pitch between two adjacent scanlines. The "
"maximum height, stored in **max_height**, is usually only limited by the "
"amount of addressable video memory. For hardware that has no real maximum, "
"drivers should pick a reasonable default."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:357
msgid ""
"See also **DRM_SHADOW_PLANE_MAX_WIDTH** and **DRM_SHADOW_PLANE_MAX_HEIGHT**."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:969
msgid "DRM mode_configuration structure initialization"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:973
#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:189
#: drivers/gpu/drm/drm_mode_config.c:412 drivers/gpu/drm/drm_mode_config.c:501
#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:170
#: drivers/gpu/drm/drm_mode_object.c:192 drivers/gpu/drm/drm_mode_object.c:209
#: drivers/gpu/drm/drm_mode_object.c:226 drivers/gpu/drm/drm_mode_object.c:270
#: drivers/gpu/drm/drm_mode_object.c:340 drivers/gpu/drm/drm_mode_object.c:366
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:317
#: include/drm/drm_atomic.h:536 include/drm/drm_atomic.h:551
#: include/drm/drm_atomic.h:569 include/drm/drm_atomic.h:584
#: include/drm/drm_atomic.h:644 include/drm/drm_atomic.h:662
#: include/drm/drm_atomic.h:676 include/drm/drm_atomic.h:691
#: include/drm/drm_atomic.h:709 include/drm/drm_atomic.h:724
#: include/drm/drm_atomic.h:739 include/drm/drm_atomic.h:762
#: include/drm/drm_atomic.h:782 include/drm/drm_atomic.h:802
#: include/drm/drm_atomic.h:854 include/drm/drm_atomic.h:878
#: include/drm/drm_atomic.h:899 include/drm/drm_atomic.h:921
#: include/drm/drm_atomic.h:945 include/drm/drm_atomic.h:965
#: include/drm/drm_atomic.h:986 include/drm/drm_atomic.h:1008
#: include/drm/drm_atomic.h:1030 include/drm/drm_atomic.h:1046
#: include/drm/drm_atomic.h:1064 include/drm/drm_atomic.h:1085
#: include/drm/drm_atomic.h:1105 include/drm/drm_atomic.h:1123
#: include/drm/drm_atomic.h:1142 include/drm/drm_atomic.h:1168
#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:63
#: drivers/gpu/drm/drm_atomic.c:101 drivers/gpu/drm/drm_atomic.c:119
#: drivers/gpu/drm/drm_atomic.c:164 drivers/gpu/drm/drm_atomic.c:192
#: drivers/gpu/drm/drm_atomic.c:276 drivers/gpu/drm/drm_atomic.c:302
#: drivers/gpu/drm/drm_atomic.c:330 drivers/gpu/drm/drm_atomic.c:514
#: drivers/gpu/drm/drm_atomic.c:779 drivers/gpu/drm/drm_atomic.c:808
#: drivers/gpu/drm/drm_atomic.c:823 drivers/gpu/drm/drm_atomic.c:882
#: drivers/gpu/drm/drm_atomic.c:904 drivers/gpu/drm/drm_atomic.c:926
#: drivers/gpu/drm/drm_atomic.c:964 drivers/gpu/drm/drm_atomic.c:1001
#: drivers/gpu/drm/drm_atomic.c:1054 drivers/gpu/drm/drm_atomic.c:1084
#: drivers/gpu/drm/drm_atomic.c:1114 drivers/gpu/drm/drm_atomic.c:1223
#: drivers/gpu/drm/drm_atomic.c:1251 drivers/gpu/drm/drm_atomic.c:1273
#: drivers/gpu/drm/drm_atomic.c:1295 drivers/gpu/drm/drm_atomic.c:1339
#: drivers/gpu/drm/drm_atomic.c:1400 drivers/gpu/drm/drm_atomic.c:1445
#: drivers/gpu/drm/drm_atomic.c:1553 drivers/gpu/drm/drm_atomic.c:1586
#: drivers/gpu/drm/drm_atomic.c:1792 drivers/gpu/drm/drm_atomic.c:1884
#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:62
#: drivers/gpu/drm/drm_atomic_uapi.c:114 drivers/gpu/drm/drm_atomic_uapi.c:179
#: drivers/gpu/drm/drm_atomic_uapi.c:235 drivers/gpu/drm/drm_atomic_uapi.c:265
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1238
#: include/drm/drm_crtc.h:1263 include/drm/drm_crtc.h:1275
#: include/drm/drm_crtc.h:1290 include/drm/drm_crtc.h:1309
#: include/drm/drm_crtc.h:1319 ../../../gpu/drm-kms:321:
#: drivers/gpu/drm/drm_crtc.c:81 drivers/gpu/drm/drm_crtc.c:316
#: drivers/gpu/drm/drm_crtc.c:400 drivers/gpu/drm/drm_crtc.c:480
#: drivers/gpu/drm/drm_crtc.c:634 drivers/gpu/drm/drm_crtc.c:655
#: drivers/gpu/drm/drm_crtc.c:917 drivers/gpu/drm/drm_crtc.c:948
#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:122
#: drivers/gpu/drm/drm_color_mgmt.c:156 drivers/gpu/drm/drm_color_mgmt.c:201
#: drivers/gpu/drm/drm_color_mgmt.c:522 drivers/gpu/drm/drm_color_mgmt.c:600
#: drivers/gpu/drm/drm_color_mgmt.c:647 drivers/gpu/drm/drm_color_mgmt.c:666
#: drivers/gpu/drm/drm_color_mgmt.c:696 drivers/gpu/drm/drm_color_mgmt.c:731
#: drivers/gpu/drm/drm_color_mgmt.c:757 drivers/gpu/drm/drm_color_mgmt.c:786
#: drivers/gpu/drm/drm_color_mgmt.c:806 drivers/gpu/drm/drm_color_mgmt.c:833
#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:38
#: include/drm/drm_color_mgmt.h:68 ../../../gpu/drm-kms:342:
#: include/drm/drm_framebuffer.h:228 include/drm/drm_framebuffer.h:239
#: include/drm/drm_framebuffer.h:251 include/drm/drm_framebuffer.h:262
#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:850
#: drivers/gpu/drm/drm_framebuffer.c:918 drivers/gpu/drm/drm_framebuffer.c:942
#: drivers/gpu/drm/drm_framebuffer.c:970 drivers/gpu/drm/drm_framebuffer.c:1139
#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:151
#: include/drm/drm_fourcc.h:165 include/drm/drm_fourcc.h:179
#: include/drm/drm_fourcc.h:193 include/drm/drm_fourcc.h:208
#: include/drm/drm_fourcc.h:223 include/drm/drm_fourcc.h:238
#: include/drm/drm_fourcc.h:253 include/drm/drm_fourcc.h:268
#: include/drm/drm_fourcc.h:290 ../../../gpu/drm-kms:360:
#: drivers/gpu/drm/drm_fourcc.c:38 drivers/gpu/drm/drm_fourcc.c:112
#: drivers/gpu/drm/drm_fourcc.c:147 drivers/gpu/drm/drm_fourcc.c:401
#: drivers/gpu/drm/drm_fourcc.c:422 drivers/gpu/drm/drm_fourcc.c:449
#: drivers/gpu/drm/drm_fourcc.c:469 drivers/gpu/drm/drm_fourcc.c:489
#: drivers/gpu/drm/drm_fourcc.c:508 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:838 include/drm/drm_plane.h:883
#: include/drm/drm_plane.h:916 include/drm/drm_plane.h:928
#: include/drm/drm_plane.h:944 include/drm/drm_plane.h:962
#: include/drm/drm_plane.h:974 include/drm/drm_plane.h:987
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:510
#: drivers/gpu/drm/drm_plane.c:680 drivers/gpu/drm/drm_plane.c:718
#: drivers/gpu/drm/drm_plane.c:739 drivers/gpu/drm/drm_plane.c:778
#: drivers/gpu/drm/drm_plane.c:912 drivers/gpu/drm/drm_plane.c:992
#: drivers/gpu/drm/drm_plane.c:1653 drivers/gpu/drm/drm_plane.c:1669
#: drivers/gpu/drm/drm_plane.c:1693 drivers/gpu/drm/drm_plane.c:1761
#: drivers/gpu/drm/drm_plane.c:1792 ../../../gpu/drm-kms:389:
#: drivers/gpu/drm/drm_blend.c:217 drivers/gpu/drm/drm_blend.c:249
#: drivers/gpu/drm/drm_blend.c:318 drivers/gpu/drm/drm_blend.c:350
#: drivers/gpu/drm/drm_blend.c:403 drivers/gpu/drm/drm_blend.c:503
#: drivers/gpu/drm/drm_blend.c:553 ../../../gpu/drm-kms:395:
#: drivers/gpu/drm/drm_damage_helper.c:60
#: drivers/gpu/drm/drm_damage_helper.c:94
#: drivers/gpu/drm/drm_damage_helper.c:211
#: drivers/gpu/drm/drm_damage_helper.c:260
#: drivers/gpu/drm/drm_damage_helper.c:302 ../../../gpu/drm-kms:398:
#: include/drm/drm_damage_helper.h:42 ../../../gpu/drm-kms:410:
#: include/drm/drm_panic.h:90 include/drm/drm_panic.h:141
#: include/drm/drm_panic.h:164 ../../../gpu/drm-kms:413:
#: drivers/gpu/drm/drm_panic.c:914 ../../../gpu/drm-kms:419:
#: include/drm/drm_modes.h:146 include/drm/drm_modes.h:161
#: include/drm/drm_modes.h:175 include/drm/drm_modes.h:432
#: include/drm/drm_modes.h:444 ../../../gpu/drm-kms:422:
#: drivers/gpu/drm/drm_modes.c:57 drivers/gpu/drm/drm_modes.c:69
#: drivers/gpu/drm/drm_modes.c:91 drivers/gpu/drm/drm_modes.c:107
#: drivers/gpu/drm/drm_modes.c:529 drivers/gpu/drm/drm_modes.c:604
#: drivers/gpu/drm/drm_modes.c:832 drivers/gpu/drm/drm_modes.c:1024
#: drivers/gpu/drm/drm_modes.c:1069 drivers/gpu/drm/drm_modes.c:1110
#: drivers/gpu/drm/drm_modes.c:1150 drivers/gpu/drm/drm_modes.c:1182
#: drivers/gpu/drm/drm_modes.c:1218 drivers/gpu/drm/drm_modes.c:1268
#: drivers/gpu/drm/drm_modes.c:1285 drivers/gpu/drm/drm_modes.c:1316
#: drivers/gpu/drm/drm_modes.c:1338 drivers/gpu/drm/drm_modes.c:1417
#: drivers/gpu/drm/drm_modes.c:1434 drivers/gpu/drm/drm_modes.c:1451
#: drivers/gpu/drm/drm_modes.c:1525 drivers/gpu/drm/drm_modes.c:1570
#: drivers/gpu/drm/drm_modes.c:1592 drivers/gpu/drm/drm_modes.c:1613
#: drivers/gpu/drm/drm_modes.c:1663 drivers/gpu/drm/drm_modes.c:1692
#: drivers/gpu/drm/drm_modes.c:1720 drivers/gpu/drm/drm_modes.c:1800
#: drivers/gpu/drm/drm_modes.c:1869 drivers/gpu/drm/drm_modes.c:1881
#: drivers/gpu/drm/drm_modes.c:2342 drivers/gpu/drm/drm_modes.c:2536
#: drivers/gpu/drm/drm_modes.c:2705 drivers/gpu/drm/drm_modes.c:2725
#: drivers/gpu/drm/drm_modes.c:2744 drivers/gpu/drm/drm_modes.c:2763
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2364
#: include/drm/drm_connector.h:2382 include/drm/drm_connector.h:2393
#: include/drm/drm_connector.h:2405 include/drm/drm_connector.h:2550
#: include/drm/drm_connector.h:2562 ../../../gpu/drm-kms:437:
#: drivers/gpu/drm/drm_connector.c:138 drivers/gpu/drm/drm_connector.c:386
#: drivers/gpu/drm/drm_connector.c:419 drivers/gpu/drm/drm_connector.c:460
#: drivers/gpu/drm/drm_connector.c:505 drivers/gpu/drm/drm_connector.c:550
#: drivers/gpu/drm/drm_connector.c:635 drivers/gpu/drm/drm_connector.c:653
#: drivers/gpu/drm/drm_connector.c:688 drivers/gpu/drm/drm_connector.c:711
#: drivers/gpu/drm/drm_connector.c:729 drivers/gpu/drm/drm_connector.c:751
#: drivers/gpu/drm/drm_connector.c:818 drivers/gpu/drm/drm_connector.c:891
#: drivers/gpu/drm/drm_connector.c:917 drivers/gpu/drm/drm_connector.c:990
#: drivers/gpu/drm/drm_connector.c:1038 drivers/gpu/drm/drm_connector.c:1076
#: drivers/gpu/drm/drm_connector.c:1114 drivers/gpu/drm/drm_connector.c:1147
#: drivers/gpu/drm/drm_connector.c:1175 drivers/gpu/drm/drm_connector.c:1268
#: drivers/gpu/drm/drm_connector.c:1867 drivers/gpu/drm/drm_connector.c:1900
#: drivers/gpu/drm/drm_connector.c:2050 drivers/gpu/drm/drm_connector.c:2068
#: drivers/gpu/drm/drm_connector.c:2095 drivers/gpu/drm/drm_connector.c:2136
#: drivers/gpu/drm/drm_connector.c:2240 drivers/gpu/drm/drm_connector.c:2281
#: drivers/gpu/drm/drm_connector.c:2374 drivers/gpu/drm/drm_connector.c:2405
#: drivers/gpu/drm/drm_connector.c:2465 drivers/gpu/drm/drm_connector.c:2611
#: drivers/gpu/drm/drm_connector.c:2636 drivers/gpu/drm/drm_connector.c:2661
#: drivers/gpu/drm/drm_connector.c:2688 drivers/gpu/drm/drm_connector.c:2715
#: drivers/gpu/drm/drm_connector.c:2744 drivers/gpu/drm/drm_connector.c:2789
#: drivers/gpu/drm/drm_connector.c:2819 drivers/gpu/drm/drm_connector.c:2853
#: drivers/gpu/drm/drm_connector.c:2874 drivers/gpu/drm/drm_connector.c:2907
#: drivers/gpu/drm/drm_connector.c:2927 drivers/gpu/drm/drm_connector.c:2955
#: drivers/gpu/drm/drm_connector.c:2976 drivers/gpu/drm/drm_connector.c:3033
#: drivers/gpu/drm/drm_connector.c:3063 drivers/gpu/drm/drm_connector.c:3097
#: drivers/gpu/drm/drm_connector.c:3126 drivers/gpu/drm/drm_connector.c:3184
#: drivers/gpu/drm/drm_connector.c:3209 drivers/gpu/drm/drm_connector.c:3492
#: drivers/gpu/drm/drm_connector.c:3545 drivers/gpu/drm/drm_connector.c:3559
#: drivers/gpu/drm/drm_connector.c:3589 ../../../gpu/drm-kms:449:
#: drivers/gpu/drm/drm_writeback.c:154 drivers/gpu/drm/drm_writeback.c:297
#: drivers/gpu/drm/drm_writeback.c:376 drivers/gpu/drm/drm_writeback.c:461
#: drivers/gpu/drm/drm_writeback.c:530 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:229 include/drm/drm_encoder.h:252
#: include/drm/drm_encoder.h:270 include/drm/drm_encoder.h:282
#: include/drm/drm_encoder.h:294 include/drm/drm_encoder.h:307
#: include/drm/drm_encoder.h:329 include/drm/drm_encoder.h:341
#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:147
#: drivers/gpu/drm/drm_encoder.c:186 drivers/gpu/drm/drm_encoder.c:274
#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:113
#: include/drm/drm_modeset_lock.h:122 include/drm/drm_modeset_lock.h:131
#: include/drm/drm_modeset_lock.h:156 include/drm/drm_modeset_lock.h:189
#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:135
#: drivers/gpu/drm/drm_modeset_lock.c:190
#: drivers/gpu/drm/drm_modeset_lock.c:222
#: drivers/gpu/drm/drm_modeset_lock.c:244
#: drivers/gpu/drm/drm_modeset_lock.c:265
#: drivers/gpu/drm/drm_modeset_lock.c:275
#: drivers/gpu/drm/drm_modeset_lock.c:341
#: drivers/gpu/drm/drm_modeset_lock.c:369
#: drivers/gpu/drm/drm_modeset_lock.c:381
#: drivers/gpu/drm/drm_modeset_lock.c:410
#: drivers/gpu/drm/drm_modeset_lock.c:425
#: drivers/gpu/drm/drm_modeset_lock.c:436 ../../../gpu/drm-kms:527:
#: include/drm/drm_property.h:238 include/drm/drm_property.h:304
#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:87
#: drivers/gpu/drm/drm_property.c:148 drivers/gpu/drm/drm_property.c:195
#: drivers/gpu/drm/drm_property.c:263 drivers/gpu/drm/drm_property.c:291
#: drivers/gpu/drm/drm_property.c:319 drivers/gpu/drm/drm_property.c:358
#: drivers/gpu/drm/drm_property.c:381 drivers/gpu/drm/drm_property.c:438
#: drivers/gpu/drm/drm_property.c:546 drivers/gpu/drm/drm_property.c:600
#: drivers/gpu/drm/drm_property.c:630 drivers/gpu/drm/drm_property.c:644
#: drivers/gpu/drm/drm_property.c:669 drivers/gpu/drm/drm_property.c:737
#: drivers/gpu/drm/drm_property.c:760 ../../../gpu/drm-kms:635:
#: drivers/gpu/drm/drm_vblank.c:405 drivers/gpu/drm/drm_vblank.c:520
#: drivers/gpu/drm/drm_vblank.c:569 drivers/gpu/drm/drm_vblank.c:591
#: drivers/gpu/drm/drm_vblank.c:606 drivers/gpu/drm/drm_vblank.c:667
#: drivers/gpu/drm/drm_vblank.c:812 drivers/gpu/drm/drm_vblank.c:906
#: drivers/gpu/drm/drm_vblank.c:968 drivers/gpu/drm/drm_vblank.c:995
#: drivers/gpu/drm/drm_vblank.c:1066 drivers/gpu/drm/drm_vblank.c:1118
#: drivers/gpu/drm/drm_vblank.c:1229 drivers/gpu/drm/drm_vblank.c:1268
#: drivers/gpu/drm/drm_vblank.c:1282 drivers/gpu/drm/drm_vblank.c:1319
#: drivers/gpu/drm/drm_vblank.c:1333 drivers/gpu/drm/drm_vblank.c:1411
#: drivers/gpu/drm/drm_vblank.c:1444 drivers/gpu/drm/drm_vblank.c:1474
#: drivers/gpu/drm/drm_vblank.c:1521 drivers/gpu/drm/drm_vblank.c:1582
#: drivers/gpu/drm/drm_vblank.c:1913 drivers/gpu/drm/drm_vblank.c:1977
#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:62
#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:94
#: drivers/gpu/drm/drm_vblank_work.c:177 drivers/gpu/drm/drm_vblank_work.c:221
#: drivers/gpu/drm/drm_vblank_work.c:242 drivers/gpu/drm/drm_vblank_work.c:264
msgid "**Parameters**"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:975
#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:191
#: drivers/gpu/drm/drm_mode_config.c:414 drivers/gpu/drm/drm_mode_config.c:503
#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:172
#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:121
#: drivers/gpu/drm/drm_atomic.c:166 drivers/gpu/drm/drm_atomic.c:781
#: drivers/gpu/drm/drm_atomic.c:1886 ../../../gpu/drm-kms:318:
#: include/drm/drm_crtc.h:1292 ../../../gpu/drm-kms:321:
#: drivers/gpu/drm/drm_crtc.c:83 drivers/gpu/drm/drm_crtc.c:318
#: drivers/gpu/drm/drm_crtc.c:402 ../../../gpu/drm-kms:345:
#: drivers/gpu/drm/drm_framebuffer.c:852 drivers/gpu/drm/drm_framebuffer.c:920
#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:114
#: drivers/gpu/drm/drm_fourcc.c:149 drivers/gpu/drm/drm_fourcc.c:424
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:946
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:512
#: drivers/gpu/drm/drm_plane.c:720 drivers/gpu/drm/drm_plane.c:994
#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:505
#: ../../../gpu/drm-kms:413: drivers/gpu/drm/drm_panic.c:916
#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:71
#: drivers/gpu/drm/drm_modes.c:93 drivers/gpu/drm/drm_modes.c:531
#: drivers/gpu/drm/drm_modes.c:606 drivers/gpu/drm/drm_modes.c:834
#: drivers/gpu/drm/drm_modes.c:1026 drivers/gpu/drm/drm_modes.c:1453
#: drivers/gpu/drm/drm_modes.c:1665 drivers/gpu/drm/drm_modes.c:1802
#: drivers/gpu/drm/drm_modes.c:2538 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:2366 ../../../gpu/drm-kms:437:
#: drivers/gpu/drm/drm_connector.c:388 drivers/gpu/drm/drm_connector.c:421
#: drivers/gpu/drm/drm_connector.c:462 drivers/gpu/drm/drm_connector.c:507
#: drivers/gpu/drm/drm_connector.c:552 drivers/gpu/drm/drm_connector.c:1040
#: drivers/gpu/drm/drm_connector.c:1869 drivers/gpu/drm/drm_connector.c:2097
#: drivers/gpu/drm/drm_connector.c:2138 drivers/gpu/drm/drm_connector.c:2242
#: drivers/gpu/drm/drm_connector.c:2283 drivers/gpu/drm/drm_connector.c:2467
#: drivers/gpu/drm/drm_connector.c:2663 drivers/gpu/drm/drm_connector.c:2690
#: drivers/gpu/drm/drm_connector.c:3547 drivers/gpu/drm/drm_connector.c:3561
#: drivers/gpu/drm/drm_connector.c:3591 ../../../gpu/drm-kms:449:
#: drivers/gpu/drm/drm_writeback.c:156 drivers/gpu/drm/drm_writeback.c:299
#: drivers/gpu/drm/drm_writeback.c:378 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:309 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:149 drivers/gpu/drm/drm_encoder.c:276
#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:137
#: drivers/gpu/drm/drm_modeset_lock.c:192
#: drivers/gpu/drm/drm_modeset_lock.c:224
#: drivers/gpu/drm/drm_modeset_lock.c:438 ../../../gpu/drm-kms:527:
#: include/drm/drm_property.h:306 ../../../gpu/drm-kms:530:
#: drivers/gpu/drm/drm_property.c:89 drivers/gpu/drm/drm_property.c:150
#: drivers/gpu/drm/drm_property.c:197 drivers/gpu/drm/drm_property.c:265
#: drivers/gpu/drm/drm_property.c:293 drivers/gpu/drm/drm_property.c:321
#: drivers/gpu/drm/drm_property.c:360 drivers/gpu/drm/drm_property.c:440
#: drivers/gpu/drm/drm_property.c:548 drivers/gpu/drm/drm_property.c:646
#: drivers/gpu/drm/drm_property.c:671 drivers/gpu/drm/drm_property.c:762
#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:522
#: drivers/gpu/drm/drm_vblank.c:1284 drivers/gpu/drm/drm_vblank.c:1915
msgid "``struct drm_device *dev``"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:970
#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:410
#: drivers/gpu/drm/drm_mode_config.c:498 ../../../gpu/drm-kms:297:
#: drivers/gpu/drm/drm_atomic.c:116 drivers/gpu/drm/drm_atomic.c:161
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1236
#: include/drm/drm_crtc.h:1287 ../../../gpu/drm-kms:321:
#: drivers/gpu/drm/drm_crtc.c:78 drivers/gpu/drm/drm_crtc.c:314
#: drivers/gpu/drm/drm_crtc.c:398 ../../../gpu/drm-kms:345:
#: drivers/gpu/drm/drm_framebuffer.c:847 ../../../gpu/drm-kms:360:
#: drivers/gpu/drm/drm_fourcc.c:109 drivers/gpu/drm/drm_fourcc.c:144
#: drivers/gpu/drm/drm_fourcc.c:419 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:835 include/drm/drm_plane.h:880
#: include/drm/drm_plane.h:941 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:507 drivers/gpu/drm/drm_plane.c:715
#: drivers/gpu/drm/drm_plane.c:989 ../../../gpu/drm-kms:389:
#: drivers/gpu/drm/drm_blend.c:500 ../../../gpu/drm-kms:422:
#: drivers/gpu/drm/drm_modes.c:66 drivers/gpu/drm/drm_modes.c:88
#: drivers/gpu/drm/drm_modes.c:1797 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:2361 include/drm/drm_connector.h:2495
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:383
#: drivers/gpu/drm/drm_connector.c:416 drivers/gpu/drm/drm_connector.c:457
#: drivers/gpu/drm/drm_connector.c:502 drivers/gpu/drm/drm_connector.c:547
#: drivers/gpu/drm/drm_connector.c:1035 drivers/gpu/drm/drm_connector.c:1864
#: drivers/gpu/drm/drm_connector.c:2092 drivers/gpu/drm/drm_connector.c:2133
#: drivers/gpu/drm/drm_connector.c:2237 drivers/gpu/drm/drm_connector.c:2278
#: drivers/gpu/drm/drm_connector.c:2462 drivers/gpu/drm/drm_connector.c:2658
#: drivers/gpu/drm/drm_connector.c:2685 drivers/gpu/drm/drm_connector.c:3542
#: drivers/gpu/drm/drm_connector.c:3556 drivers/gpu/drm/drm_connector.c:3586
#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:151
#: drivers/gpu/drm/drm_writeback.c:296 drivers/gpu/drm/drm_writeback.c:375
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:304
#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:132
#: drivers/gpu/drm/drm_modeset_lock.c:187
#: drivers/gpu/drm/drm_modeset_lock.c:433 ../../../gpu/drm-kms:527:
#: include/drm/drm_property.h:188 include/drm/drm_property.h:204
#: include/drm/drm_property.h:301 ../../../gpu/drm-kms:530:
#: drivers/gpu/drm/drm_property.c:757 ../../../gpu/drm-kms:635:
#: drivers/gpu/drm/drm_vblank.c:517 drivers/gpu/drm/drm_vblank.c:1279
#: drivers/gpu/drm/drm_vblank.c:1910
msgid "DRM device"
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:971
msgid ""
"This is the unmanaged version of drmm_mode_config_init() for drivers which "
"still explicitly call drm_mode_config_cleanup()."
msgstr ""

#: ../../../gpu/drm-kms:156: include/drm/drm_mode_config.h:974
msgid ""
"FIXME: This function is deprecated and drivers should be converted over to "
"drmm_mode_config_init()."
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:185
msgid "call ->reset callbacks"
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:186
#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:167
#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:915
#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:526
#: drivers/gpu/drm/drm_modes.c:601 drivers/gpu/drm/drm_modes.c:829
#: drivers/gpu/drm/drm_modes.c:1021 drivers/gpu/drm/drm_modes.c:1660
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:226
#: include/drm/drm_encoder.h:249 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:144 drivers/gpu/drm/drm_encoder.c:271
#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:153
#: include/drm/drm_modeset_lock.h:186 ../../../gpu/drm-kms:530:
#: drivers/gpu/drm/drm_property.c:84 drivers/gpu/drm/drm_property.c:145
#: drivers/gpu/drm/drm_property.c:192 drivers/gpu/drm/drm_property.c:260
#: drivers/gpu/drm/drm_property.c:288 drivers/gpu/drm/drm_property.c:316
#: drivers/gpu/drm/drm_property.c:355 drivers/gpu/drm/drm_property.c:435
#: drivers/gpu/drm/drm_property.c:641 drivers/gpu/drm/drm_property.c:666
msgid "drm device"
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:187
msgid ""
"This functions calls all the crtc's, encoder's and connector's ->reset "
"callback. Drivers can use this in e.g. their driver load or resume code to "
"reset hardware and software state."
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:408
msgid "managed DRM mode_configuration structure initialization"
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:411
msgid ""
"Initialize **dev**'s mode_config structure, used for tracking the graphics "
"configuration of **dev**."
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:414
msgid ""
"Since this initializes the modeset locks, no locking is possible. Which is "
"no problem, since this should happen single threaded at init time. It is the "
"driver's problem to ensure this guarantee."
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:418
msgid ""
"Cleanup is automatically handled through registering drm_mode_config_cleanup "
"with drmm_add_action()."
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:421
#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:280
#: drivers/gpu/drm/drm_mode_object.c:348 drivers/gpu/drm/drm_mode_object.c:373
#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:536
#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:64
#: drivers/gpu/drm/drm_atomic.c:337 drivers/gpu/drm/drm_atomic.c:517
#: drivers/gpu/drm/drm_atomic.c:826 drivers/gpu/drm/drm_atomic.c:938
#: drivers/gpu/drm/drm_atomic.c:975 drivers/gpu/drm/drm_atomic.c:1011
#: drivers/gpu/drm/drm_atomic.c:1056 drivers/gpu/drm/drm_atomic.c:1086
#: drivers/gpu/drm/drm_atomic.c:1117 drivers/gpu/drm/drm_atomic.c:1226
#: drivers/gpu/drm/drm_atomic.c:1300 drivers/gpu/drm/drm_atomic.c:1345
#: drivers/gpu/drm/drm_atomic.c:1409 drivers/gpu/drm/drm_atomic.c:1447
#: drivers/gpu/drm/drm_atomic.c:1558 drivers/gpu/drm/drm_atomic.c:1591
#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:64
#: drivers/gpu/drm/drm_atomic_uapi.c:118 drivers/gpu/drm/drm_atomic_uapi.c:182
#: drivers/gpu/drm/drm_atomic_uapi.c:268 ../../../gpu/drm-kms:318:
#: include/drm/drm_crtc.h:1248 ../../../gpu/drm-kms:321:
#: drivers/gpu/drm/drm_crtc.c:338 drivers/gpu/drm/drm_crtc.c:419
#: drivers/gpu/drm/drm_crtc.c:638 drivers/gpu/drm/drm_crtc.c:922
#: drivers/gpu/drm/drm_crtc.c:950 ../../../gpu/drm-kms:327:
#: drivers/gpu/drm/drm_color_mgmt.c:204 ../../../gpu/drm-kms:330:
#: include/drm/drm_color_mgmt.h:67 ../../../gpu/drm-kms:345:
#: drivers/gpu/drm/drm_framebuffer.c:859 ../../../gpu/drm-kms:357:
#: include/drm/drm_fourcc.h:151 include/drm/drm_fourcc.h:165
#: include/drm/drm_fourcc.h:179 include/drm/drm_fourcc.h:193
#: include/drm/drm_fourcc.h:208 include/drm/drm_fourcc.h:223
#: include/drm/drm_fourcc.h:238 include/drm/drm_fourcc.h:253
#: include/drm/drm_fourcc.h:269 include/drm/drm_fourcc.h:291
#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:402
#: drivers/gpu/drm/drm_fourcc.c:423 drivers/gpu/drm/drm_fourcc.c:449
#: drivers/gpu/drm/drm_fourcc.c:469 drivers/gpu/drm/drm_fourcc.c:489
#: drivers/gpu/drm/drm_fourcc.c:509 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:855 include/drm/drm_plane.h:899
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:529
#: drivers/gpu/drm/drm_plane.c:782 drivers/gpu/drm/drm_plane.c:913
#: drivers/gpu/drm/drm_plane.c:993 drivers/gpu/drm/drm_plane.c:1670
#: drivers/gpu/drm/drm_plane.c:1696 drivers/gpu/drm/drm_plane.c:1766
#: drivers/gpu/drm/drm_plane.c:1795 ../../../gpu/drm-kms:389:
#: drivers/gpu/drm/drm_blend.c:221 drivers/gpu/drm/drm_blend.c:371
#: drivers/gpu/drm/drm_blend.c:410 drivers/gpu/drm/drm_blend.c:573
#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:106
#: drivers/gpu/drm/drm_damage_helper.c:269
#: drivers/gpu/drm/drm_damage_helper.c:308 ../../../gpu/drm-kms:410:
#: include/drm/drm_panic.h:129 ../../../gpu/drm-kms:419:
#: include/drm/drm_modes.h:443 ../../../gpu/drm-kms:422:
#: drivers/gpu/drm/drm_modes.c:70 drivers/gpu/drm/drm_modes.c:540
#: drivers/gpu/drm/drm_modes.c:617 drivers/gpu/drm/drm_modes.c:842
#: drivers/gpu/drm/drm_modes.c:1047 drivers/gpu/drm/drm_modes.c:1187
#: drivers/gpu/drm/drm_modes.c:1221 drivers/gpu/drm/drm_modes.c:1284
#: drivers/gpu/drm/drm_modes.c:1453 drivers/gpu/drm/drm_modes.c:1527
#: drivers/gpu/drm/drm_modes.c:1571 drivers/gpu/drm/drm_modes.c:1594
#: drivers/gpu/drm/drm_modes.c:1615 drivers/gpu/drm/drm_modes.c:1666
#: drivers/gpu/drm/drm_modes.c:1697 drivers/gpu/drm/drm_modes.c:1722
#: drivers/gpu/drm/drm_modes.c:2357 drivers/gpu/drm/drm_modes.c:2536
#: drivers/gpu/drm/drm_modes.c:2707 drivers/gpu/drm/drm_modes.c:2727
#: drivers/gpu/drm/drm_modes.c:2746 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:2406 ../../../gpu/drm-kms:437:
#: drivers/gpu/drm/drm_connector.c:137 drivers/gpu/drm/drm_connector.c:399
#: drivers/gpu/drm/drm_connector.c:438 drivers/gpu/drm/drm_connector.c:476
#: drivers/gpu/drm/drm_connector.c:517 drivers/gpu/drm/drm_connector.c:567
#: drivers/gpu/drm/drm_connector.c:656 drivers/gpu/drm/drm_connector.c:689
#: drivers/gpu/drm/drm_connector.c:828 drivers/gpu/drm/drm_connector.c:896
#: drivers/gpu/drm/drm_connector.c:991 drivers/gpu/drm/drm_connector.c:1075
#: drivers/gpu/drm/drm_connector.c:1148 drivers/gpu/drm/drm_connector.c:1179
#: drivers/gpu/drm/drm_connector.c:1269 drivers/gpu/drm/drm_connector.c:1867
#: drivers/gpu/drm/drm_connector.c:2050 drivers/gpu/drm/drm_connector.c:2098
#: drivers/gpu/drm/drm_connector.c:2146 drivers/gpu/drm/drm_connector.c:2242
#: drivers/gpu/drm/drm_connector.c:2286 drivers/gpu/drm/drm_connector.c:2376
#: drivers/gpu/drm/drm_connector.c:2410 drivers/gpu/drm/drm_connector.c:2466
#: drivers/gpu/drm/drm_connector.c:2613 drivers/gpu/drm/drm_connector.c:2638
#: drivers/gpu/drm/drm_connector.c:2662 drivers/gpu/drm/drm_connector.c:2688
#: drivers/gpu/drm/drm_connector.c:2719 drivers/gpu/drm/drm_connector.c:2748
#: drivers/gpu/drm/drm_connector.c:2821 drivers/gpu/drm/drm_connector.c:2854
#: drivers/gpu/drm/drm_connector.c:2874 drivers/gpu/drm/drm_connector.c:2908
#: drivers/gpu/drm/drm_connector.c:2930 drivers/gpu/drm/drm_connector.c:2988
#: drivers/gpu/drm/drm_connector.c:3038 drivers/gpu/drm/drm_connector.c:3066
#: drivers/gpu/drm/drm_connector.c:3560 drivers/gpu/drm/drm_connector.c:3591
#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:168
#: drivers/gpu/drm/drm_writeback.c:318 drivers/gpu/drm/drm_writeback.c:388
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:238
#: include/drm/drm_encoder.h:256 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:160 drivers/gpu/drm/drm_encoder.c:283
#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:170
#: include/drm/drm_modeset_lock.h:195 ../../../gpu/drm-kms:476:
#: drivers/gpu/drm/drm_modeset_lock.c:448 ../../../gpu/drm-kms:530:
#: drivers/gpu/drm/drm_property.c:93 drivers/gpu/drm/drm_property.c:158
#: drivers/gpu/drm/drm_property.c:206 drivers/gpu/drm/drm_property.c:273
#: drivers/gpu/drm/drm_property.c:301 drivers/gpu/drm/drm_property.c:328
#: drivers/gpu/drm/drm_property.c:365 drivers/gpu/drm/drm_property.c:386
#: drivers/gpu/drm/drm_property.c:550 drivers/gpu/drm/drm_property.c:647
#: drivers/gpu/drm/drm_property.c:737 drivers/gpu/drm/drm_property.c:767
#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:523
#: drivers/gpu/drm/drm_vblank.c:575 drivers/gpu/drm/drm_vblank.c:688
#: drivers/gpu/drm/drm_vblank.c:832 drivers/gpu/drm/drm_vblank.c:918
#: drivers/gpu/drm/drm_vblank.c:1230 drivers/gpu/drm/drm_vblank.c:1988
#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:106
#: drivers/gpu/drm/drm_vblank_work.c:182
msgid "**Return**"
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:422
msgid "0 on success, negative error value on failure."
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:497
msgid "free up DRM mode_config info"
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:499
msgid ""
"Free up all the connectors and CRTCs associated with this DRM device, then "
"free up the framebuffers and associated buffer objects."
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:502
msgid ""
"Note that since this /should/ happen single-threaded at driver/device "
"teardown time, no locking is required. It's the driver's job to ensure that "
"this guarantee actually holds true."
msgstr ""

#: ../../../gpu/drm-kms:159: drivers/gpu/drm/drm_mode_config.c:506
msgid ""
"FIXME: With the managed drmm_mode_config_init() it is no longer necessary "
"for drivers to explicitly call this function."
msgstr ""

#: ../../../gpu/drm-kms.rst:165
msgid "Modeset Base Object Abstraction"
msgstr ""

#: ../../../gpu/drm-kms.rst:179
msgid ""
"The base structure for all KMS objects is :c:type:`struct drm_mode_object "
"<drm_mode_object>`. One of the base services it provides is tracking "
"properties, which are especially important for the atomic IOCTL (see `Atomic "
"Mode Setting`_). The somewhat surprising part here is that properties are "
"not directly instantiated on each object, but free-standing mode objects "
"themselves, represented by :c:type:`struct drm_property <drm_property>`, "
"which only specify the type and value range of a property. Any given "
"property can be attached multiple times to different objects using "
"drm_object_attach_property()."
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:34
msgid "base structure for modeset objects"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:35
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2495
msgid "``id``"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:36
msgid "userspace visible identifier"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:36
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1238
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:715
#: include/drm/drm_plane.h:837 include/drm/drm_plane.h:882
#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:352
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:228
msgid "``type``"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:37
msgid "type of the object, one of DRM_MODE_OBJECT\\_\\*"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:37
#: include/drm/drm_mode_object.h:75 ../../../gpu/drm-kms:318:
#: include/drm/drm_crtc.h:1082 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:712 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:2037
msgid "``properties``"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:38
msgid "properties attached to this object, including values"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:38
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2493
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:159
msgid "``refcount``"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:39
msgid "reference count for objects with dynamic lifetime"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:39
msgid "``free_cb``"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:40
msgid "free function callback, only set for objects with dynamic lifetime"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:40
msgid ""
"Base structure for modeset objects visible to userspace. Objects can be "
"looked up using drm_mode_object_find(). Besides basic uapi interface "
"properties like **id** and **type** it provides two services:"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:44
msgid ""
"It tracks attached properties and their values. This is used by :c:type:"
"`drm_crtc`, :c:type:`drm_plane` and :c:type:`drm_connector`. Properties are "
"attached by calling drm_object_attach_property() before the object is "
"visible to userspace."
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:48
msgid ""
"For objects with dynamic lifetimes (as indicated by a non-NULL **free_cb**) "
"it provides reference counting through drm_mode_object_get() and "
"drm_mode_object_put(). This is used by :c:type:`drm_framebuffer`, :c:type:"
"`drm_connector` and :c:type:`drm_property_blob`. These objects provide "
"specialized reference counting wrappers."
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:65
msgid "property tracking for :c:type:`drm_mode_object`"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:69
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:139
#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:37
msgid "``count``"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:70
msgid ""
"number of valid properties, must be less than or equal to "
"DRM_OBJECT_MAX_PROPERTY."
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:76
msgid "Array of pointers to :c:type:`drm_property`."
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:78
msgid ""
"NOTE: if we ever start dynamically destroying properties (ie. not at "
"drm_mode_config_cleanup() time), then we'd have to do a better job of "
"detaching property from mode objects to avoid dangling property pointers:"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:85
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:179
msgid "``values``"
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:86
msgid ""
"Array to store the property values, matching **properties**. Do not read/"
"write values directly, but use drm_object_property_get_value() and "
"drm_object_property_set_value()."
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:90
msgid ""
"Note that atomic drivers do not store mutable properties in this array, but "
"only the decoded values in the corresponding state structure. The decoding "
"is done using the :c:type:`drm_crtc.atomic_get_property <drm_crtc>` and :c:"
"type:`drm_crtc.atomic_set_property <drm_crtc>` hooks for :c:type:`struct "
"drm_crtc <drm_crtc>`. For :c:type:`struct drm_plane <drm_plane>` the hooks "
"are :c:type:`drm_plane_funcs.atomic_get_property <drm_plane_funcs>` and :c:"
"type:`drm_plane_funcs.atomic_set_property <drm_plane_funcs>`. And for :c:"
"type:`struct drm_connector <drm_connector>` the hooks are :c:type:"
"`drm_connector_funcs.atomic_get_property <drm_connector_funcs>` and :c:type:"
"`drm_connector_funcs.atomic_set_property <drm_connector_funcs>` ."
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:99
msgid ""
"Hence atomic drivers should not use drm_object_property_set_value() and "
"drm_object_property_get_value() on mutable objects, i.e. those without the "
"DRM_MODE_PROP_IMMUTABLE flag set."
msgstr ""

#: ../../../gpu/drm-kms:188: include/drm/drm_mode_object.h:103
msgid ""
"For atomic drivers the default value of properties is stored in this array, "
"so drm_object_property_get_default_value can be used to retrieve it."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:166
msgid "look up a drm object with static lifetime"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:169
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1289
#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:917
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:943
#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:93
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2363
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:306
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:303
msgid "``struct drm_file *file_priv``"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:168
msgid "drm file"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:170
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1290
#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:918
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:944
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2364
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:307
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:304
#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:643
msgid "``uint32_t id``"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:169
msgid "id of the mode object"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:171
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:237
#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:320
msgid "``uint32_t type``"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:170
msgid "type of the mode object"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:171
msgid ""
"This function is used to look up a modeset object. It will acquire a "
"reference for reference counted objects. This reference must be dropped "
"again by callind drm_mode_object_put()."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:188
msgid "release a mode object reference"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:194
#: drivers/gpu/drm/drm_mode_object.c:211 drivers/gpu/drm/drm_mode_object.c:228
#: drivers/gpu/drm/drm_mode_object.c:272 drivers/gpu/drm/drm_mode_object.c:342
#: drivers/gpu/drm/drm_mode_object.c:368
msgid "``struct drm_mode_object *obj``"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:189
#: drivers/gpu/drm/drm_mode_object.c:206
msgid "DRM mode object"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:190
msgid ""
"This function decrements the object's refcount if it is a refcounted modeset "
"object. It is a no-op on any other object. This is used to drop references "
"acquired with drm_mode_object_get()."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:205
msgid "acquire a mode object reference"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:207
msgid ""
"This function increments the object's refcount if it is a refcounted modeset "
"object. It is a no-op on any other object. References should be dropped "
"again by calling drm_mode_object_put()."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:222
msgid "attach a property to a modeset object"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:223
msgid "drm modeset object"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:225
#: drivers/gpu/drm/drm_mode_object.c:269 drivers/gpu/drm/drm_mode_object.c:339
#: drivers/gpu/drm/drm_mode_object.c:366 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:777 ../../../gpu/drm-kms:527:
#: include/drm/drm_property.h:240 ../../../gpu/drm-kms:530:
#: drivers/gpu/drm/drm_property.c:383 drivers/gpu/drm/drm_property.c:437
msgid "``struct drm_property *property``"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:224
msgid "property to attach"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:226
msgid "``uint64_t init_val``"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:225
msgid "initial value of the property"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:226
msgid ""
"This attaches the given property to the modeset object with the given "
"initial value. Currently this function cannot fail since the properties are "
"stored in a statically sized array."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:230
msgid ""
"Note that all properties must be attached before the object itself is "
"registered and accessible from userspace."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:266
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:774
msgid "set the value of a property"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:267
msgid "drm mode object to set property value for"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:268
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:776
msgid "property to set"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:270
msgid "``uint64_t val``"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:269
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:777
msgid "value the property should be set to"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:270
msgid ""
"This function sets a given property on a given object. This function only "
"changes the software state of the property, it does not call into the "
"driver's ->set_property callback."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:274
msgid ""
"Note that atomic drivers should not have any need to call this, the core "
"will ensure consistency of values reported back to userspace through the "
"appropriate ->atomic_get_property callback. Only legacy drivers should call "
"this function to update the tracked value (after clamping and other "
"restrictions have been applied)."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:281
#: drivers/gpu/drm/drm_mode_object.c:349 drivers/gpu/drm/drm_mode_object.c:374
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:338
#: drivers/gpu/drm/drm_crtc.c:420 ../../../gpu/drm-kms:345:
#: drivers/gpu/drm/drm_framebuffer.c:860 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:529 drivers/gpu/drm/drm_plane.c:783
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:399
#: drivers/gpu/drm/drm_connector.c:439 drivers/gpu/drm/drm_connector.c:476
#: drivers/gpu/drm/drm_connector.c:518 drivers/gpu/drm/drm_connector.c:568
#: drivers/gpu/drm/drm_connector.c:828 drivers/gpu/drm/drm_connector.c:897
#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:160
#: drivers/gpu/drm/drm_encoder.c:284 ../../../gpu/drm-kms:530:
#: drivers/gpu/drm/drm_property.c:387
msgid "Zero on success, error code on failure."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:336
msgid "retrieve the value of a property"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:337
#: drivers/gpu/drm/drm_mode_object.c:364
msgid "drm mode object to get property value from"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:338
#: drivers/gpu/drm/drm_mode_object.c:365
msgid "property to retrieve"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:340
#: drivers/gpu/drm/drm_mode_object.c:367
msgid "``uint64_t *val``"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:339
#: drivers/gpu/drm/drm_mode_object.c:366
msgid "storage for the property value"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:340
msgid ""
"This function retrieves the softare state of the given property for the "
"given property. Since there is no driver callback to retrieve the current "
"property value this might be out of sync with the hardware, depending upon "
"the driver and property."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:345
msgid ""
"Atomic drivers should never call this function directly, the core will read "
"out property values through the various ->atomic_get_property callbacks."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:362
msgid "retrieve the default value of a property when in atomic mode."
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:367
msgid ""
"This function retrieves the default state of the given property as passed in "
"to drm_object_attach_property"
msgstr ""

#: ../../../gpu/drm-kms:191: drivers/gpu/drm/drm_mode_object.c:370
msgid ""
"Only atomic drivers should call this function directly, as for non-atomic "
"drivers it will return the current value."
msgstr ""

#: ../../../gpu/drm-kms.rst:195
msgid "Atomic Mode Setting"
msgstr ""

#: ../../../gpu/drm-kms.rst:237
msgid ""
"Atomic provides transactional modeset (including planes) updates, but a bit "
"differently from the usual transactional approach of try-commit and rollback:"
msgstr ""

#: ../../../gpu/drm-kms.rst:241
msgid ""
"Firstly, no hardware changes are allowed when the commit would fail. This "
"allows us to implement the DRM_MODE_ATOMIC_TEST_ONLY mode, which allows "
"userspace to explore whether certain configurations would work or not."
msgstr ""

#: ../../../gpu/drm-kms.rst:245
msgid ""
"This would still allow setting and rollback of just the software state, "
"simplifying conversion of existing drivers. But auditing drivers for "
"correctness of the atomic_check code becomes really hard with that: Rolling "
"back changes in data structures all over the place is hard to get right."
msgstr ""

#: ../../../gpu/drm-kms.rst:250
msgid ""
"Lastly, for backwards compatibility and to support all use-cases, atomic "
"updates need to be incremental and be able to execute in parallel. Hardware "
"doesn't always allow it, but where possible plane updates on different CRTCs "
"should not interfere, and not get stalled due to output routing changing on "
"different CRTCs."
msgstr ""

#: ../../../gpu/drm-kms.rst:256
msgid "Taken all together there's two consequences for the atomic design:"
msgstr ""

#: ../../../gpu/drm-kms.rst:258
msgid ""
"The overall state is split up into per-object state structures: :c:type:"
"`struct drm_plane_state <drm_plane_state>` for planes, :c:type:`struct "
"drm_crtc_state <drm_crtc_state>` for CRTCs and :c:type:`struct "
"drm_connector_state <drm_connector_state>` for connectors. These are the "
"only objects with userspace-visible and settable state. For internal state "
"drivers can subclass these structures through embedding, or add entirely new "
"state structures for their globally shared hardware functions, see :c:type:"
"`struct drm_private_state<drm_private_state>`."
msgstr ""

#: ../../../gpu/drm-kms.rst:267
msgid ""
"An atomic update is assembled and validated as an entirely free-standing "
"pile of structures within the :c:type:`drm_atomic_state <drm_atomic_state>` "
"container. Driver private state structures are also tracked in the same "
"structure; see the next chapter.  Only when a state is committed is it "
"applied to the driver and modeset objects. This way rolling back an update "
"boils down to releasing memory and unreferencing objects like framebuffers."
msgstr ""

#: ../../../gpu/drm-kms.rst:274
msgid ""
"Locking of atomic state structures is internally using :c:type:`struct "
"drm_modeset_lock <drm_modeset_lock>`. As a general rule the locking "
"shouldn't be exposed to drivers, instead the right locks should be "
"automatically acquired by any function that duplicates or peeks into a "
"state, like e.g. drm_atomic_get_crtc_state().  Locking only protects the "
"software data structure, ordering of committing state changes to hardware is "
"sequenced using :c:type:`struct drm_crtc_commit <drm_crtc_commit>`."
msgstr ""

#: ../../../gpu/drm-kms.rst:282
msgid ""
"Read on in this chapter, and also in :ref:`drm_atomic_helper` for more "
"detailed coverage of specific topics."
msgstr ""

#: ../../../gpu/drm-kms.rst:286
msgid "Handling Driver Private State"
msgstr ""

#: ../../../gpu/drm-kms:288: drivers/gpu/drm/drm_atomic.c:737
msgid ""
"Very often the DRM objects exposed to userspace in the atomic modeset api (:"
"c:type:`drm_connector`, :c:type:`drm_crtc` and :c:type:`drm_plane`) do not "
"map neatly to the underlying hardware. Especially for any kind of shared "
"resources (e.g. shared clocks, scaler units, bandwidth and fifo limits "
"shared among a group of planes or CRTCs, and so on) it makes sense to model "
"these as independent objects. Drivers then need to do similar state tracking "
"and commit ordering for such private (since not exposed to userspace) "
"objects as the atomic core and helpers already provide for connectors, "
"planes and CRTCs."
msgstr ""

#: ../../../gpu/drm-kms:288: drivers/gpu/drm/drm_atomic.c:746
msgid ""
"To make this easier on drivers the atomic core provides some support to "
"track driver private state objects using struct :c:type:`drm_private_obj`, "
"with the associated state struct :c:type:`drm_private_state`."
msgstr ""

#: ../../../gpu/drm-kms:288: drivers/gpu/drm/drm_atomic.c:750
msgid ""
"Similar to userspace-exposed objects, private state structures can be "
"acquired by calling drm_atomic_get_private_obj_state(). This also takes care "
"of locking, hence drivers should not have a need to call drm_modeset_lock() "
"directly. Sequence of the actual hardware state commit is not handled, "
"drivers might need to keep track of struct drm_crtc_commit within subclassed "
"structure of :c:type:`drm_private_state` as necessary, e.g. similar to :c:"
"type:`drm_plane_state.commit <drm_plane_state>`. See also :c:type:"
"`drm_atomic_state.fake_commit <drm_atomic_state>`."
msgstr ""

#: ../../../gpu/drm-kms:288: drivers/gpu/drm/drm_atomic.c:758
msgid ""
"All private state structures contained in a :c:type:`drm_atomic_state` "
"update can be iterated using for_each_oldnew_private_obj_in_state(), "
"for_each_new_private_obj_in_state() and for_each_old_private_obj_in_state(). "
"Drivers are recommended to wrap these for each type of driver private state "
"object they have, filtering on :c:type:`drm_private_obj.funcs "
"<drm_private_obj>` using for_each_if(), at least if they want to iterate "
"over all objects of a given type."
msgstr ""

#: ../../../gpu/drm-kms:288: drivers/gpu/drm/drm_atomic.c:765
msgid ""
"An earlier way to handle driver private state was by subclassing struct :c:"
"type:`drm_atomic_state`. But since that encourages non-standard ways to "
"implement the check/commit split atomic requires (by using e.g. \"check and "
"rollback or commit instead\" of \"duplicate state, check, then either commit "
"or release duplicated state) it is deprecated in favour of using :c:type:"
"`drm_private_state`."
msgstr ""

#: ../../../gpu/drm-kms.rst:292
msgid "Atomic Mode Setting Function Reference"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:35
msgid "track modeset commits on a CRTC"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:74
#: include/drm/drm_atomic.h:920 include/drm/drm_atomic.h:944
#: include/drm/drm_atomic.h:964 ../../../gpu/drm-kms:318:
#: include/drm/drm_crtc.h:82 include/drm/drm_crtc.h:1183
#: include/drm/drm_crtc.h:1311 include/drm/drm_crtc.h:1321
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:59
#: include/drm/drm_plane.h:684 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1010 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:180
msgid "``crtc``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:75
msgid "DRM CRTC for this commit."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:81
#: include/drm/drm_atomic.h:394
msgid "``ref``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:82
msgid ""
"Reference count for this structure. Needed to allow blocking on completions "
"without the risk of the completion disappearing meanwhile."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:90
msgid "``flip_done``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:91
msgid ""
"Will be signaled when the hardware has flipped to the new set of buffers. "
"Signals at the same time as when the drm event for this commit is sent to "
"userspace, or when an out-fence is singalled. Note that for most hardware, "
"in most cases this happens after **hw_done** is signalled."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:97
msgid ""
"Completion of this stage is signalled implicitly by calling "
"drm_crtc_send_vblank_event() on :c:type:`drm_crtc_state.event "
"<drm_crtc_state>`."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:104
msgid "``hw_done``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:105
msgid ""
"Will be signalled when all hw register changes for this commit have been "
"written out. Especially when disabling a pipe this can be much later than "
"**flip_done**, since that can signal already when the screen goes black, "
"whereas to fully shut down a pipe more register I/O is required."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:111
msgid ""
"Note that this does not need to include separately reference-counted "
"resources like backing storage buffer pinning, or runtime pm management."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:115
msgid ""
"Drivers should call drm_atomic_helper_commit_hw_done() to signal completion "
"of this stage."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:122
msgid "``cleanup_done``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:123
msgid ""
"Will be signalled after old buffers have been cleaned up by calling "
"drm_atomic_helper_cleanup_planes(). Since this can only happen after a "
"vblank wait completed it might be a bit later. This completion is useful to "
"throttle updates and avoid hardware updates getting ahead of the buffer "
"cleanup too much."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:129
msgid ""
"Drivers should call drm_atomic_helper_commit_cleanup_done() to signal "
"completion of this stage."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:136
msgid "``commit_entry``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:137
msgid ""
"Entry on the per-CRTC :c:type:`drm_crtc.commit_list <drm_crtc>`. Protected "
"by $drm_crtc.commit_lock."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:144
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:321
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:56
msgid "``event``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:145
msgid ":c:type:`drm_pending_vblank_event` pointer to clean up private events."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:151
msgid "``abort_completion``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:152
msgid ""
"A flag that's set after drm_atomic_helper_setup_commit() takes a second "
"reference for the completion of $drm_crtc_state.event. It's used by the free "
"code to remove the second reference if commit fails."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:36
msgid ""
"This structure is used to track pending modeset changes and atomic commit on "
"a per-CRTC basis. Since updating the list should never block, this structure "
"is reference counted to allow waiters to safely wait on an event to "
"complete, without holding any locks."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:41
msgid ""
"It has 3 different events in total to allow a fine-grained synchronization "
"between outstanding updates::"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:62
msgid ""
"The important bit to know is that :c:type:`cleanup_done` is the terminal "
"event, but the ordering between :c:type:`flip_done` and :c:type:`hw_done` is "
"entirely up to the specific driver and modeset state change."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:66
msgid ""
"For an implementation of how to use this look at "
"drm_atomic_helper_setup_commit() from the atomic helper library."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:69
msgid "See also drm_crtc_commit_wait()."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:200
msgid "atomic state functions for private objects"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:211
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:619
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:384
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1470
msgid "``atomic_duplicate_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:212
msgid ""
"Duplicate the current state of the private object and return it. It is an "
"error to call this before obj->state has been initialized."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:217
msgid ""
"Duplicated atomic state or NULL when obj->state is not initialized or "
"allocation failed."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:224
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:652
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:417
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1503
msgid "``atomic_destroy_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:225
msgid "Frees the private object state created with **atomic_duplicate_state**."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:232
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:826
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:523
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1584
msgid "``atomic_print_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:233
msgid ""
"If driver subclasses :c:type:`struct drm_private_state <drm_private_state>`, "
"it should implement this optional hook for printing additional driver "
"specific state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:236
msgid ""
"Do not call this directly, use drm_atomic_private_obj_print_state() instead."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:201
msgid ""
"These hooks are used by atomic helpers to create, swap and destroy states of "
"private objects. The structure itself is used as a vtable to identify the "
"associated private object type. Each private object type that needs to be "
"added to the atomic states is expected to have an implementation of these "
"hooks and pass a pointer to its drm_private_state_funcs struct to "
"drm_atomic_get_private_obj_state()."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:245
msgid "base struct for driver private atomic object"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:288
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:938
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:126
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:638
#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:392
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1910
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:96
#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:80
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:34
#: include/drm/drm_property.h:82
msgid "``head``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:289
msgid ""
"List entry used to attach a private object to a :c:type:`drm_device` (queued "
"to :c:type:`drm_mode_config.privobj_list <drm_mode_config>`)."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:294
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1782
msgid "``lock``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:295
msgid "Modeset lock to protect the state object."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:299
#: include/drm/drm_atomic.h:333 ../../../gpu/drm-kms:318:
#: include/drm/drm_crtc.h:386 include/drm/drm_crtc.h:1092
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:254
#: include/drm/drm_plane.h:728 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1041 include/drm/drm_connector.h:2236
msgid "``state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:300
msgid "Current atomic state for this driver private object."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:305
msgid ""
"Functions to manipulate the state of this driver private object, see :c:type:"
"`drm_private_state_funcs`."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:246
msgid ""
"A driver private object is initialized by calling "
"drm_atomic_private_obj_init() and cleaned up by calling "
"drm_atomic_private_obj_fini()."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:250
msgid ""
"Currently only tracks the state update functions and the opaque driver "
"private state itself, but in the future might also track which :c:type:"
"`drm_modeset_lock` is required to duplicate and update this object's state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:254
msgid ""
"All private objects must be initialized before the DRM device they are "
"attached to is registered to the DRM subsystem (call to drm_dev_register()) "
"and should stay around until this DRM device is unregistered (call to "
"drm_dev_unregister()). In other words, private objects lifetime is tied to "
"the DRM device lifetime. This implies that:"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:260
msgid ""
"1/ all calls to drm_atomic_private_obj_init() must be done before calling"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:261
msgid "drm_dev_register()"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:262
msgid ""
"2/ all calls to drm_atomic_private_obj_fini() must be done after calling"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:263
msgid "drm_dev_unregister()"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:265
msgid ""
"If that private object is used to store a state shared by multiple CRTCs, "
"proper care must be taken to ensure that non-blocking commits are properly "
"ordered to avoid a use-after-free issue."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:269
msgid ""
"Indeed, assuming a sequence of two non-blocking :c:type:`drm_atomic_commit` "
"on two different :c:type:`drm_crtc` using different :c:type:`drm_plane` and :"
"c:type:`drm_connector`, so with no resources shared, there's no guarantee on "
"which commit is going to happen first. However, the second :c:type:"
"`drm_atomic_commit` will consider the first :c:type:`drm_private_obj` its "
"old state, and will be in charge of freeing it whenever the second :c:type:"
"`drm_atomic_commit` is done."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:276
msgid ""
"If the first :c:type:`drm_atomic_commit` happens after it, it will consider "
"its :c:type:`drm_private_obj` the new state and will be likely to access it, "
"resulting in an access to a freed memory region. Drivers should store (and "
"get a reference to) the :c:type:`drm_crtc_commit` structure in our private "
"state in :c:type:`drm_mode_config_helper_funcs.atomic_commit_setup "
"<drm_mode_config_helper_funcs>`, and then wait for that commit to complete "
"as the first step of :c:type:`drm_mode_config_helper_funcs."
"atomic_commit_tail <drm_mode_config_helper_funcs>`, similar to "
"drm_atomic_helper_wait_for_dependencies()."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:315
msgid "``drm_for_each_privobj (privobj, dev)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:313
msgid "private object iterator"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:319
msgid "``privobj``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:315
msgid "pointer to the current private object. Updated after each iteration"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:318
#: include/drm/drm_atomic.h:401 ../../../gpu/drm-kms:318:
#: include/drm/drm_crtc.h:933 include/drm/drm_crtc.h:1240
#: include/drm/drm_crtc.h:1308 include/drm/drm_crtc.h:1318
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:122
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:634
#: include/drm/drm_plane.h:840 include/drm/drm_plane.h:885
#: include/drm/drm_plane.h:961 include/drm/drm_plane.h:973
#: include/drm/drm_plane.h:986 ../../../gpu/drm-kms:410:
#: include/drm/drm_panic.h:92 include/drm/drm_panic.h:143
#: include/drm/drm_panic.h:166 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1894 include/drm/drm_connector.h:2494
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:95
#: include/drm/drm_encoder.h:231 include/drm/drm_encoder.h:254
#: include/drm/drm_encoder.h:328 include/drm/drm_encoder.h:340
#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:158
#: include/drm/drm_modeset_lock.h:191 ../../../gpu/drm-kms:527:
#: include/drm/drm_property.h:187 include/drm/drm_property.h:203
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:118
msgid "``dev``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:317
msgid "the DRM device we want get private objects from"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:318
msgid "Allows one to iterate over all private objects attached to **dev**"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:325
msgid "base struct for driver private object state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:334
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:387
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:255
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1042
msgid "backpointer to global drm_atomic_state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:338
#: include/drm/drm_atomic.h:1084 include/drm/drm_atomic.h:1104
#: include/drm/drm_atomic.h:1122 ../../../gpu/drm-kms:342:
#: include/drm/drm_framebuffer.h:203
msgid "``obj``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:339
msgid "backpointer to the private object"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:326
msgid ""
"Currently only contains a backpointer to the overall atomic update, and the "
"relevant private object but in the future also might hold synchronization "
"information similar to e.g. :c:type:`drm_crtc.commit <drm_crtc>`."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:349
msgid "Atomic commit structure"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:395
msgid "Count of all references to this update (will not be freed until zero)."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:402
msgid "Parent DRM Device."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:406
msgid "``allow_modeset``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:407
msgid ""
"Allow full modeset. This is used by the ATOMIC IOCTL handler to implement "
"the DRM_MODE_ATOMIC_ALLOW_MODESET flag. Drivers should generally not consult "
"this flag, but instead look at the output of "
"drm_atomic_crtc_needs_modeset(). The detailed rules are:"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:412
msgid ""
"Drivers must not consult **allow_modeset** in the atomic commit path. Use "
"drm_atomic_crtc_needs_modeset() instead."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:415
msgid ""
"Drivers must consult **allow_modeset** before adding unrelated struct "
"drm_crtc_state to this commit by calling drm_atomic_get_crtc_state(). See "
"also the warning in the documentation for that function."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:420
msgid ""
"Drivers must never change this flag, it is under the exclusive control of "
"userspace."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:423
msgid ""
"Drivers may consult **allow_modeset** in the atomic check path, if they have "
"the choice between an optimal hardware configuration which requires a "
"modeset, and a less optimal configuration which can be committed without a "
"modeset. An example would be suboptimal scanout FIFO allocation resulting in "
"increased idle power consumption. This allows userspace to avoid flickering "
"and delays for the normal composition loop at reasonable cost."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:434
msgid "``legacy_cursor_update``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:435
msgid "Hint to enforce legacy cursor IOCTL semantics."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:437
msgid ""
"WARNING: This is thoroughly broken and pretty much impossible to implement "
"correctly. Drivers must ignore this and should instead implement :c:type:"
"`drm_plane_helper_funcs.atomic_async_check <drm_plane_helper_funcs>` and :c:"
"type:`drm_plane_helper_funcs.atomic_async_commit <drm_plane_helper_funcs>` "
"hooks. New users of this flag are not allowed."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:447
msgid "``async_update``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:448
msgid "hint for asynchronous plane update"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:452
msgid "``duplicated``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:453
msgid ""
"Indicates whether or not this atomic state was duplicated using "
"drm_atomic_helper_duplicate_state(). Drivers and atomic helpers should use "
"this to fixup normal  inconsistencies in duplicated states."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:462
msgid "``planes``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:463
msgid ""
"Pointer to array of **drm_plane** and **drm_plane_state** part of this "
"update."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:470
msgid "``crtcs``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:471
msgid ""
"Pointer to array of **drm_crtc** and **drm_crtc_state** part of this update."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:479
msgid "size of the **connectors** array"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:483
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1187
msgid "``connectors``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:484
msgid ""
"Pointer to array of **drm_connector** and **drm_connector_state** part of "
"this update."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:491
msgid "``num_private_objs``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:492
msgid "size of the **private_objs** array"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:496
msgid "``private_objs``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:497
msgid ""
"Pointer to array of **drm_private_obj** and **drm_private_obj_state** part "
"of this update."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:505
msgid "acquire context for this atomic modeset state update"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:509
msgid "``fake_commit``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:510
msgid ""
"Used for signaling unbound planes/connectors. When a connector or plane is "
"not bound to any CRTC, it's still important to preserve linearity to prevent "
"the atomic states from being freed too early."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:514
msgid ""
"This commit (if set) is not bound to any CRTC, but will be completed when "
"drm_atomic_helper_commit_hw_done() is called."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:521
msgid "``commit_work``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:522
msgid ""
"Work item which can be used by the driver or helpers to execute the commit "
"without blocking."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:350
msgid ""
"This structure is the kernel counterpart of **drm_mode_atomic** and "
"represents an atomic commit that transitions from an old to a new display "
"state. It contains all the objects affected by the atomic commit and both "
"the new state structures and pointers to the old state structures for these."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:356
msgid ""
"States are added to an atomic update by calling drm_atomic_get_crtc_state(), "
"drm_atomic_get_plane_state(), drm_atomic_get_connector_state(), or for "
"private state structures, drm_atomic_get_private_obj_state()."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:360
#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:128
#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:945
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2141
#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1071
msgid "**NOTE**"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:361
msgid ""
"struct drm_atomic_state first started as a single collection of entities "
"state pointers (drm_plane_state, drm_crtc_state, etc.)."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:364
msgid ""
"At atomic_check time, you could get the state about to be committed from "
"drm_atomic_state, and the one currently running from the entities state "
"pointer (drm_crtc.state, for example). After the call to "
"drm_atomic_helper_swap_state(), the entities state pointer would contain the "
"state previously checked, and the drm_atomic_state structure the old state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:371
msgid ""
"Over time, and in order to avoid confusion, drm_atomic_state has grown to "
"have both the old state (ie, the state we replace) and the new state (ie, "
"the state we want to apply). Those names are stable during the commit "
"process, which makes it easier to reason about."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:376
msgid ""
"You can still find some traces of that evolution through some hooks or "
"callbacks taking a drm_atomic_state parameter called names like "
"\"old_state\". This doesn't necessarily mean that the previous "
"drm_atomic_state is passed, but rather that this used to be the state "
"collection we were replacing after drm_atomic_helper_swap_state(), but the "
"variable name was never updated."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:383
msgid ""
"Some atomic operations implementations followed a similar process. We first "
"started to pass the entity state only. However, it was pretty cumbersome for "
"drivers, and especially CRTCs, to retrieve the states of other components. "
"Thus, we switched to passing the whole drm_atomic_state as a parameter to "
"those operations. Similarly, the transition isn't complete yet, and one "
"might still find atomic operations taking a drm_atomic_state pointer, or a "
"component state pointer. The former is the preferred form."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:532
msgid "acquire a reference to the CRTC commit"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:538
#: include/drm/drm_atomic.h:553 ../../../gpu/drm-kms:297:
#: drivers/gpu/drm/drm_atomic.c:65
msgid "``struct drm_crtc_commit *commit``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:533
#: include/drm/drm_atomic.h:548
msgid "CRTC commit"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:534
msgid "Increases the reference of **commit**."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:537
msgid "The pointer to **commit**, with reference increased."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:547
msgid "release a reference to the CRTC commmit"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:549
msgid ""
"This releases a reference to **commit** which is freed after removing the "
"final reference. No locking required and callable from any context."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:565
msgid "acquire a reference to the atomic state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:571
#: include/drm/drm_atomic.h:586 ../../../gpu/drm-kms:297:
#: drivers/gpu/drm/drm_atomic.c:103 drivers/gpu/drm/drm_atomic.c:118
#: drivers/gpu/drm/drm_atomic.c:194 drivers/gpu/drm/drm_atomic.c:278
#: drivers/gpu/drm/drm_atomic.c:332 drivers/gpu/drm/drm_atomic.c:516
#: drivers/gpu/drm/drm_atomic.c:825 drivers/gpu/drm/drm_atomic.c:1056
#: drivers/gpu/drm/drm_atomic.c:1086 drivers/gpu/drm/drm_atomic.c:1116
#: drivers/gpu/drm/drm_atomic.c:1225 drivers/gpu/drm/drm_atomic.c:1297
#: drivers/gpu/drm/drm_atomic.c:1341 drivers/gpu/drm/drm_atomic.c:1402
#: drivers/gpu/drm/drm_atomic.c:1447 drivers/gpu/drm/drm_atomic.c:1555
#: drivers/gpu/drm/drm_atomic.c:1588 ../../../gpu/drm-kms:389:
#: drivers/gpu/drm/drm_blend.c:502 ../../../gpu/drm-kms:395:
#: drivers/gpu/drm/drm_damage_helper.c:62
msgid "``struct drm_atomic_state *state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:566
#: include/drm/drm_atomic.h:581
msgid "The atomic state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:567
msgid "Returns a new reference to the **state**"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:580
msgid "release a reference to the atomic state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:582
msgid ""
"This releases a reference to **state** which is freed after removing the "
"final reference. No locking required and callable from any context."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:640
msgid "get CRTC state, if it exists"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:646
#: include/drm/drm_atomic.h:664 include/drm/drm_atomic.h:678
#: include/drm/drm_atomic.h:693 include/drm/drm_atomic.h:711
#: include/drm/drm_atomic.h:726 include/drm/drm_atomic.h:741
#: include/drm/drm_atomic.h:764 include/drm/drm_atomic.h:784
#: include/drm/drm_atomic.h:804 ../../../gpu/drm-kms:297:
#: drivers/gpu/drm/drm_atomic.c:884 drivers/gpu/drm/drm_atomic.c:906
#: drivers/gpu/drm/drm_atomic.c:928 drivers/gpu/drm/drm_atomic.c:966
#: drivers/gpu/drm/drm_atomic.c:1253 drivers/gpu/drm/drm_atomic.c:1275
#: drivers/gpu/drm/drm_atomic.c:1794
msgid "``const struct drm_atomic_state *state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:641
#: include/drm/drm_atomic.h:659 include/drm/drm_atomic.h:673
#: include/drm/drm_atomic.h:688 include/drm/drm_atomic.h:706
#: include/drm/drm_atomic.h:721 include/drm/drm_atomic.h:736
#: include/drm/drm_atomic.h:759 include/drm/drm_atomic.h:779
#: include/drm/drm_atomic.h:799 ../../../gpu/drm-kms:297:
#: drivers/gpu/drm/drm_atomic.c:327 drivers/gpu/drm/drm_atomic.c:511
#: drivers/gpu/drm/drm_atomic.c:879 drivers/gpu/drm/drm_atomic.c:901
#: drivers/gpu/drm/drm_atomic.c:1111 drivers/gpu/drm/drm_atomic.c:1220
#: drivers/gpu/drm/drm_atomic.c:1248 drivers/gpu/drm/drm_atomic.c:1270
msgid "global atomic state object"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:643
#: include/drm/drm_atomic.h:661 include/drm/drm_atomic.h:675
#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:329
#: drivers/gpu/drm/drm_atomic.c:1338 drivers/gpu/drm/drm_atomic.c:1399
#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:178
#: drivers/gpu/drm/drm_atomic_uapi.c:264 ../../../gpu/drm-kms:321:
#: drivers/gpu/drm/drm_crtc.c:316 drivers/gpu/drm/drm_crtc.c:400
#: drivers/gpu/drm/drm_crtc.c:482 drivers/gpu/drm/drm_crtc.c:919
#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:158
#: drivers/gpu/drm/drm_color_mgmt.c:203 drivers/gpu/drm/drm_color_mgmt.c:649
#: drivers/gpu/drm/drm_color_mgmt.c:668 drivers/gpu/drm/drm_color_mgmt.c:698
#: drivers/gpu/drm/drm_color_mgmt.c:733 drivers/gpu/drm/drm_color_mgmt.c:759
#: drivers/gpu/drm/drm_color_mgmt.c:788 drivers/gpu/drm/drm_color_mgmt.c:808
#: drivers/gpu/drm/drm_color_mgmt.c:835 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:293 ../../../gpu/drm-kms:635:
#: drivers/gpu/drm/drm_vblank.c:407 drivers/gpu/drm/drm_vblank.c:593
#: drivers/gpu/drm/drm_vblank.c:608 drivers/gpu/drm/drm_vblank.c:669
#: drivers/gpu/drm/drm_vblank.c:814 drivers/gpu/drm/drm_vblank.c:908
#: drivers/gpu/drm/drm_vblank.c:970 drivers/gpu/drm/drm_vblank.c:997
#: drivers/gpu/drm/drm_vblank.c:1068 drivers/gpu/drm/drm_vblank.c:1120
#: drivers/gpu/drm/drm_vblank.c:1231 drivers/gpu/drm/drm_vblank.c:1270
#: drivers/gpu/drm/drm_vblank.c:1321 drivers/gpu/drm/drm_vblank.c:1335
#: drivers/gpu/drm/drm_vblank.c:1413 drivers/gpu/drm/drm_vblank.c:1446
#: drivers/gpu/drm/drm_vblank.c:1476 drivers/gpu/drm/drm_vblank.c:1523
#: drivers/gpu/drm/drm_vblank.c:1584 drivers/gpu/drm/drm_vblank.c:1979
#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:244
#: drivers/gpu/drm/drm_vblank_work.c:263
msgid "``struct drm_crtc *crtc``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:642
#: include/drm/drm_atomic.h:660 include/drm/drm_atomic.h:674
msgid "CRTC to grab"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:643
msgid ""
"This function returns the CRTC state for the given CRTC, or NULL if the CRTC "
"is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:646
msgid ""
"This function is deprecated, **drm_atomic_get_old_crtc_state** or "
"**drm_atomic_get_new_crtc_state** should be used instead."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:658
msgid "get old CRTC state, if it exists"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:661
msgid ""
"This function returns the old CRTC state for the given CRTC, or NULL if the "
"CRTC is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:672
msgid "get new CRTC state, if it exists"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:675
msgid ""
"This function returns the new CRTC state for the given CRTC, or NULL if the "
"CRTC is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:687
#: include/drm/drm_atomic.h:705 include/drm/drm_atomic.h:720
msgid "get plane state, if it exists"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:690
#: include/drm/drm_atomic.h:708 include/drm/drm_atomic.h:723
#: include/drm/drm_atomic.h:801 ../../../gpu/drm-kms:297:
#: drivers/gpu/drm/drm_atomic.c:513 ../../../gpu/drm-kms:327:
#: drivers/gpu/drm/drm_color_mgmt.c:524 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:509 drivers/gpu/drm/drm_plane.c:682
#: drivers/gpu/drm/drm_plane.c:741 drivers/gpu/drm/drm_plane.c:780
#: drivers/gpu/drm/drm_plane.c:914 drivers/gpu/drm/drm_plane.c:1655
#: drivers/gpu/drm/drm_plane.c:1763 drivers/gpu/drm/drm_plane.c:1794
#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:219
#: drivers/gpu/drm/drm_blend.c:251 drivers/gpu/drm/drm_blend.c:352
#: drivers/gpu/drm/drm_blend.c:405 drivers/gpu/drm/drm_blend.c:555
msgid "``struct drm_plane *plane``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:689
#: include/drm/drm_atomic.h:707 include/drm/drm_atomic.h:722
#: include/drm/drm_atomic.h:800
msgid "plane to grab"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:690
msgid ""
"This function returns the plane state for the given plane, or NULL if the "
"plane is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:693
msgid ""
"This function is deprecated, **drm_atomic_get_old_plane_state** or "
"**drm_atomic_get_new_plane_state** should be used instead."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:708
msgid ""
"This function returns the old plane state for the given plane, or NULL if "
"the plane is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:723
msgid ""
"This function returns the new plane state for the given plane, or NULL if "
"the plane is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:735
#: include/drm/drm_atomic.h:758 include/drm/drm_atomic.h:778
msgid "get connector state, if it exists"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:738
#: include/drm/drm_atomic.h:761 include/drm/drm_atomic.h:781
#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1113
#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:109
#: drivers/gpu/drm/drm_modes.c:1719 drivers/gpu/drm/drm_modes.c:1883
#: drivers/gpu/drm/drm_modes.c:2765 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:2384 include/drm/drm_connector.h:2395
#: include/drm/drm_connector.h:2407 ../../../gpu/drm-kms:437:
#: drivers/gpu/drm/drm_connector.c:385 drivers/gpu/drm/drm_connector.c:418
#: drivers/gpu/drm/drm_connector.c:459 drivers/gpu/drm/drm_connector.c:504
#: drivers/gpu/drm/drm_connector.c:549 drivers/gpu/drm/drm_connector.c:637
#: drivers/gpu/drm/drm_connector.c:655 drivers/gpu/drm/drm_connector.c:690
#: drivers/gpu/drm/drm_connector.c:713 drivers/gpu/drm/drm_connector.c:731
#: drivers/gpu/drm/drm_connector.c:753 drivers/gpu/drm/drm_connector.c:820
#: drivers/gpu/drm/drm_connector.c:893 drivers/gpu/drm/drm_connector.c:919
#: drivers/gpu/drm/drm_connector.c:1902 drivers/gpu/drm/drm_connector.c:2052
#: drivers/gpu/drm/drm_connector.c:2070 drivers/gpu/drm/drm_connector.c:2376
#: drivers/gpu/drm/drm_connector.c:2407 drivers/gpu/drm/drm_connector.c:2613
#: drivers/gpu/drm/drm_connector.c:2638 drivers/gpu/drm/drm_connector.c:2717
#: drivers/gpu/drm/drm_connector.c:2746 drivers/gpu/drm/drm_connector.c:2791
#: drivers/gpu/drm/drm_connector.c:2821 drivers/gpu/drm/drm_connector.c:2855
#: drivers/gpu/drm/drm_connector.c:2876 drivers/gpu/drm/drm_connector.c:2909
#: drivers/gpu/drm/drm_connector.c:2957 drivers/gpu/drm/drm_connector.c:2978
#: drivers/gpu/drm/drm_connector.c:3035 drivers/gpu/drm/drm_connector.c:3065
#: drivers/gpu/drm/drm_connector.c:3099 drivers/gpu/drm/drm_connector.c:3128
#: drivers/gpu/drm/drm_connector.c:3186
msgid "``struct drm_connector *connector``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:737
#: include/drm/drm_atomic.h:760 include/drm/drm_atomic.h:780
msgid "connector to grab"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:738
msgid ""
"This function returns the connector state for the given connector, or NULL "
"if the connector is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:741
msgid ""
"This function is deprecated, **drm_atomic_get_old_connector_state** or "
"**drm_atomic_get_new_connector_state** should be used instead."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:761
msgid ""
"This function returns the old connector state for the given connector, or "
"NULL if the connector is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:781
msgid ""
"This function returns the new connector state for the given connector, or "
"NULL if the connector is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:798
msgid "get current plane state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:801
msgid ""
"This function returns the plane state for the given plane, either from "
"**state**, or if the plane isn't part of the atomic state update, from "
"**plane**. This is useful in atomic check callbacks, when drivers need to "
"peek at, but not change, state of other planes, since it avoids threading an "
"error code back up the call chain."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:807
#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1477
msgid "WARNING:"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:809
msgid ""
"Note that this function is in general unsafe since it doesn't check for the "
"required locking for access state structures. Drivers must ensure that it is "
"safe to access the returned state structure through other means. One common "
"example is when planes are fixed to a single CRTC, and the driver knows that "
"the CRTC lock is held already. In that case holding the CRTC lock gives a "
"read-lock on all planes connected to that CRTC. But if planes can be "
"reassigned things get more tricky. In that case it's better to use "
"drm_atomic_get_plane_state and wire up full error handling."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:819
msgid "Read-only pointer to the current plane state."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:852
msgid ""
"``for_each_oldnew_connector_in_state (__state, connector, "
"old_connector_state, new_connector_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:850
#: include/drm/drm_atomic.h:874 include/drm/drm_atomic.h:895
msgid "iterate over all connectors in an atomic update"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:856
#: include/drm/drm_atomic.h:880 include/drm/drm_atomic.h:901
#: include/drm/drm_atomic.h:923 include/drm/drm_atomic.h:947
#: include/drm/drm_atomic.h:967 include/drm/drm_atomic.h:988
#: include/drm/drm_atomic.h:1010 include/drm/drm_atomic.h:1032
#: include/drm/drm_atomic.h:1048 include/drm/drm_atomic.h:1066
#: include/drm/drm_atomic.h:1087 include/drm/drm_atomic.h:1107
#: include/drm/drm_atomic.h:1125
msgid "``__state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:851
#: include/drm/drm_atomic.h:875 include/drm/drm_atomic.h:896
#: include/drm/drm_atomic.h:918 include/drm/drm_atomic.h:942
#: include/drm/drm_atomic.h:962 include/drm/drm_atomic.h:983
#: include/drm/drm_atomic.h:1006 include/drm/drm_atomic.h:1028
#: include/drm/drm_atomic.h:1043 include/drm/drm_atomic.h:1061
#: include/drm/drm_atomic.h:1082 include/drm/drm_atomic.h:1102
#: include/drm/drm_atomic.h:1120
msgid ":c:type:`struct drm_atomic_state <drm_atomic_state>` pointer"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:853
#: include/drm/drm_atomic.h:877 include/drm/drm_atomic.h:898
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1006
#: include/drm/drm_connector.h:2552 include/drm/drm_connector.h:2564
#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:94
msgid "``connector``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:852
#: include/drm/drm_atomic.h:876 include/drm/drm_atomic.h:897
msgid ":c:type:`struct drm_connector <drm_connector>` iteration cursor"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:854
#: include/drm/drm_atomic.h:878
msgid "``old_connector_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:853
#: include/drm/drm_atomic.h:877
msgid ""
":c:type:`struct drm_connector_state <drm_connector_state>` iteration cursor "
"for the old state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:856
#: include/drm/drm_atomic.h:899
msgid "``new_connector_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:855
#: include/drm/drm_atomic.h:898
msgid ""
":c:type:`struct drm_connector_state <drm_connector_state>` iteration cursor "
"for the new state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:858
#: include/drm/drm_atomic.h:880 include/drm/drm_atomic.h:901
#: include/drm/drm_atomic.h:923 include/drm/drm_atomic.h:946
#: include/drm/drm_atomic.h:966 include/drm/drm_atomic.h:988
#: include/drm/drm_atomic.h:1011 include/drm/drm_atomic.h:1032
#: include/drm/drm_atomic.h:1047 include/drm/drm_atomic.h:1065
#: include/drm/drm_atomic.h:1087 include/drm/drm_atomic.h:1106
#: include/drm/drm_atomic.h:1124
msgid "``__i``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:857
#: include/drm/drm_atomic.h:879 include/drm/drm_atomic.h:900
#: include/drm/drm_atomic.h:922 include/drm/drm_atomic.h:945
#: include/drm/drm_atomic.h:965 include/drm/drm_atomic.h:987
#: include/drm/drm_atomic.h:1010 include/drm/drm_atomic.h:1031
#: include/drm/drm_atomic.h:1046 include/drm/drm_atomic.h:1064
#: include/drm/drm_atomic.h:1086 include/drm/drm_atomic.h:1105
#: include/drm/drm_atomic.h:1123
msgid "int iteration cursor, for macro-internal use"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:858
msgid ""
"This iterates over all connectors in an atomic update, tracking both old and "
"new state. This is useful in places where the state delta needs to be "
"considered, for example in atomic check functions."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:876
msgid ""
"``for_each_old_connector_in_state (__state, connector, old_connector_state, "
"__i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:880
msgid ""
"This iterates over all connectors in an atomic update, tracking only the old "
"state. This is useful in disable functions, where we need the old state the "
"hardware is still in."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:897
msgid ""
"``for_each_new_connector_in_state (__state, connector, new_connector_state, "
"__i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:901
msgid ""
"This iterates over all connectors in an atomic update, tracking only the new "
"state. This is useful in enable functions, where we need the new state the "
"hardware should be in when the atomic commit operation has completed."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:919
msgid ""
"``for_each_oldnew_crtc_in_state (__state, crtc, old_crtc_state, "
"new_crtc_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:917
#: include/drm/drm_atomic.h:941 include/drm/drm_atomic.h:961
msgid "iterate over all CRTCs in an atomic update"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:919
#: include/drm/drm_atomic.h:943 include/drm/drm_atomic.h:963
msgid ":c:type:`struct drm_crtc <drm_crtc>` iteration cursor"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:921
#: include/drm/drm_atomic.h:945
msgid "``old_crtc_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:920
#: include/drm/drm_atomic.h:944
msgid ""
":c:type:`struct drm_crtc_state <drm_crtc_state>` iteration cursor for the "
"old state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:922
#: include/drm/drm_atomic.h:965
msgid "``new_crtc_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:921
#: include/drm/drm_atomic.h:964
msgid ""
":c:type:`struct drm_crtc_state <drm_crtc_state>` iteration cursor for the "
"new state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:923
msgid ""
"This iterates over all CRTCs in an atomic update, tracking both old and new "
"state. This is useful in places where the state delta needs to be "
"considered, for example in atomic check functions."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:943
msgid "``for_each_old_crtc_in_state (__state, crtc, old_crtc_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:946
msgid ""
"This iterates over all CRTCs in an atomic update, tracking only the old "
"state. This is useful in disable functions, where we need the old state the "
"hardware is still in."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:963
msgid "``for_each_new_crtc_in_state (__state, crtc, new_crtc_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:966
msgid ""
"This iterates over all CRTCs in an atomic update, tracking only the new "
"state. This is useful in enable functions, where we need the new state the "
"hardware should be in when the atomic commit operation has completed."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:984
msgid ""
"``for_each_oldnew_plane_in_state (__state, plane, old_plane_state, "
"new_plane_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:982
#: include/drm/drm_atomic.h:1042 include/drm/drm_atomic.h:1060
msgid "iterate over all planes in an atomic update"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:985
#: include/drm/drm_atomic.h:1008 include/drm/drm_atomic.h:1030
#: include/drm/drm_atomic.h:1045 include/drm/drm_atomic.h:1063
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:55
#: include/drm/drm_plane.h:964 include/drm/drm_plane.h:976
#: include/drm/drm_plane.h:989
msgid "``plane``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:984
#: include/drm/drm_atomic.h:1007 include/drm/drm_atomic.h:1029
#: include/drm/drm_atomic.h:1044 include/drm/drm_atomic.h:1062
msgid ":c:type:`struct drm_plane <drm_plane>` iteration cursor"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:986
#: include/drm/drm_atomic.h:1009 include/drm/drm_atomic.h:1046
msgid "``old_plane_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:985
#: include/drm/drm_atomic.h:1008 include/drm/drm_atomic.h:1045
msgid ""
":c:type:`struct drm_plane_state <drm_plane_state>` iteration cursor for the "
"old state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:987
#: include/drm/drm_atomic.h:1010 include/drm/drm_atomic.h:1031
#: include/drm/drm_atomic.h:1064
msgid "``new_plane_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:986
#: include/drm/drm_atomic.h:1009 include/drm/drm_atomic.h:1030
#: include/drm/drm_atomic.h:1063
msgid ""
":c:type:`struct drm_plane_state <drm_plane_state>` iteration cursor for the "
"new state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:988
msgid ""
"This iterates over all planes in an atomic update, tracking both old and new "
"state. This is useful in places where the state delta needs to be "
"considered, for example in atomic check functions."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1006
msgid ""
"``for_each_oldnew_plane_in_state_reverse (__state, plane, old_plane_state, "
"new_plane_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1004
msgid "iterate over all planes in an atomic update in reverse order"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1011
msgid ""
"This iterates over all planes in an atomic update in reverse order, tracking "
"both old and  new state. This is useful in places where the state delta "
"needs to be considered, for example in atomic check functions."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1028
msgid ""
"``for_each_new_plane_in_state_reverse (__state, plane, new_plane_state, "
"__i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1026
msgid ""
"other than only tracking new state, it's the same as "
"for_each_oldnew_plane_in_state_reverse"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1044
msgid "``for_each_old_plane_in_state (__state, plane, old_plane_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1047
msgid ""
"This iterates over all planes in an atomic update, tracking only the old "
"state. This is useful in disable functions, where we need the old state the "
"hardware is still in."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1062
msgid "``for_each_new_plane_in_state (__state, plane, new_plane_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1065
msgid ""
"This iterates over all planes in an atomic update, tracking only the new "
"state. This is useful in enable functions, where we need the new state the "
"hardware should be in when the atomic commit operation has completed."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1083
msgid ""
"``for_each_oldnew_private_obj_in_state (__state, obj, old_obj_state, "
"new_obj_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1081
#: include/drm/drm_atomic.h:1101 include/drm/drm_atomic.h:1119
msgid "iterate over all private objects in an atomic update"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1083
#: include/drm/drm_atomic.h:1103 include/drm/drm_atomic.h:1121
msgid ":c:type:`struct drm_private_obj <drm_private_obj>` iteration cursor"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1085
#: include/drm/drm_atomic.h:1105
msgid "``old_obj_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1084
#: include/drm/drm_atomic.h:1104
msgid ""
":c:type:`struct drm_private_state <drm_private_state>` iteration cursor for "
"the old state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1086
#: include/drm/drm_atomic.h:1123
msgid "``new_obj_state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1085
#: include/drm/drm_atomic.h:1122
msgid ""
":c:type:`struct drm_private_state <drm_private_state>` iteration cursor for "
"the new state"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1087
msgid ""
"This iterates over all private objects in an atomic update, tracking both "
"old and new state. This is useful in places where the state delta needs to "
"be considered, for example in atomic check functions."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1103
msgid ""
"``for_each_old_private_obj_in_state (__state, obj, old_obj_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1106
msgid ""
"This iterates over all private objects in an atomic update, tracking only "
"the old state. This is useful in disable functions, where we need the old "
"state the hardware is still in."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1121
msgid ""
"``for_each_new_private_obj_in_state (__state, obj, new_obj_state, __i)``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1124
msgid ""
"This iterates over all private objects in an atomic update, tracking only "
"the new state. This is useful in enable functions, where we need the new "
"state the hardware should be in when the atomic commit operation has "
"completed."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1138
msgid "compute combined modeset need"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1144
#: include/drm/drm_atomic.h:1170
msgid "``const struct drm_crtc_state *state``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1139
#: include/drm/drm_atomic.h:1165
msgid ":c:type:`drm_crtc_state` for the CRTC"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1140
msgid ""
"To give drivers flexibility :c:type:`struct drm_crtc_state <drm_crtc_state>` "
"has 3 booleans to track whether the state CRTC changed enough to need a full "
"modeset cycle: mode_changed, active_changed and connectors_changed. This "
"helper simply combines these three to compute the overall need for a modeset "
"for **state**."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1145
msgid ""
"The atomic helper code sets these booleans, but drivers can and should "
"change them appropriately to accurately represent whether a modeset is "
"really needed. In general, drivers should avoid full modesets whenever "
"possible."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1150
msgid ""
"For example if the CRTC mode has changed, and the hardware is able to enact "
"the requested mode change without going through a full modeset, the driver "
"should clear mode_changed in its :c:type:`drm_mode_config_funcs.atomic_check "
"<drm_mode_config_funcs>` implementation."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1164
msgid "compute whether CRTC is actually active"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1166
msgid ""
"When in self refresh mode, the crtc_state->active value will be false, since "
"the CRTC is off. However in some cases we're interested in whether the CRTC "
"is active, or effectively active (ie: it's connected to an active display). "
"In these cases, use this function instead of just checking active."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1179
msgid "bus configuration"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1196
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:142
#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:62
#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:26
msgid "``format``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1197
msgid "format used on this bus (one of the MEDIA_BUS_FMT_* format)"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1199
msgid ""
"This field should not be directly modified by drivers "
"(drm_atomic_bridge_chain_select_bus_fmts() takes care of the bus format "
"negotiation)."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1205
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:190
#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:89
#: include/drm/drm_panic.h:140 include/drm/drm_panic.h:163
#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:270
#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:156
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:92
msgid "``flags``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1206
msgid "DRM_BUS_* flags used on this bus"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1180
msgid ""
"This structure stores the configuration of a physical bus between two "
"components in an output pipeline, usually between two bridges, an encoder "
"and a bridge, or a bridge and a connector."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1184
msgid ""
"The bus configuration is stored in :c:type:`drm_bridge_state` separately for "
"the input and output buses, as seen from the point of view of each bridge. "
"The bus configuration of a bridge output is usually identical to the "
"configuration of the next bridge's input, but may differ if the signals are "
"modified between the two bridges, for instance by an inverter on the board. "
"The input and output configurations of a bridge may differ if the bridge "
"modifies the signals internally, for instance by performing format "
"conversion, or modifying signals polarities."
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1211
msgid "Atomic bridge state object"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1215
#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:961
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:132
#: include/drm/drm_framebuffer.h:297 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:660 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1927 ../../../gpu/drm-kms:446:
#: include/drm/drm_writeback.h:23 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:97 ../../../gpu/drm-kms:527:
#: include/drm/drm_property.h:87 include/drm/drm_property.h:202
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:44
#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:24
msgid "``base``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1216
msgid "inherit from :c:type:`drm_private_state`"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1220
msgid "``bridge``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1221
msgid "the bridge this state refers to"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1225
msgid "``input_bus_cfg``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1226
msgid "input bus configuration"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1230
msgid "``output_bus_cfg``"
msgstr ""

#: ../../../gpu/drm-kms:294: include/drm/drm_atomic.h:1231
msgid "output bus configuration"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:59
msgid "Waits for a commit to complete"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:60
msgid ":c:type:`drm_crtc_commit` to wait for"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:61
msgid ""
"Waits for a given :c:type:`drm_crtc_commit` to be programmed into the "
"hardware and flipped to."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:65
msgid "0 on success, a negative error code otherwise."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:97
msgid "release memory initialized by drm_atomic_state_init"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:99
#: drivers/gpu/drm/drm_atomic.c:117 drivers/gpu/drm/drm_atomic.c:189
#: drivers/gpu/drm/drm_atomic.c:273 drivers/gpu/drm/drm_atomic.c:1292
#: drivers/gpu/drm/drm_atomic.c:1336 drivers/gpu/drm/drm_atomic.c:1397
msgid "atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:100
msgid ""
"Free all the memory allocated by drm_atomic_state_init. This should only be "
"used by drivers which are still subclassing :c:type:`drm_atomic_state` and "
"haven't switched to :c:type:`drm_private_state` yet."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:115
msgid "init new atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:118
msgid ""
"Default implementation for filling in a new atomic state. This should only "
"be used by drivers which are still subclassing :c:type:`drm_atomic_state` "
"and haven't switched to :c:type:`drm_private_state` yet."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:160
msgid "allocate atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:162
msgid "This allocates an empty atomic state to track updates."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:188
msgid "clear base atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:190
msgid ""
"Default implementation for clearing atomic state. This should only be used "
"by drivers which are still subclassing :c:type:`drm_atomic_state` and "
"haven't switched to :c:type:`drm_private_state` yet."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:272
msgid "clear state object"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:274
msgid ""
"When the w/w mutex algorithm detects a deadlock we need to back off and drop "
"all locks. So someone else could sneak in and change the current modeset "
"configuration. Which means that all the state assembled in **state** is no "
"longer an atomic update to the current state, but to some arbitrary earlier "
"state. Which could break assumptions the driver's :c:type:"
"`drm_mode_config_funcs.atomic_check <drm_mode_config_funcs>` likely relies "
"on."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:281
msgid ""
"Hence we must clear all cached state and completely start over, using this "
"function."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:298
msgid "free all memory for an atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:304
msgid "``struct kref *ref``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:299
msgid "This atomic state to deallocate"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:300
msgid ""
"This frees all memory associated with an atomic state, including all the per-"
"object state for planes, CRTCs and connectors."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:326
msgid "get CRTC state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:328
msgid "CRTC to get state object for"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:329
msgid ""
"This function returns the CRTC state for the given CRTC, allocating it if "
"needed. It will also grab the relevant CRTC lock to make sure that the state "
"is consistent."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:333
msgid ""
"WARNING: Drivers may only add new CRTC states to a **state** if "
"drm_atomic_state.allow_modeset is set, or if it's a driver-internal commit "
"not created by userspace through an IOCTL call."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:338
#: drivers/gpu/drm/drm_atomic.c:518 drivers/gpu/drm/drm_atomic.c:1118
msgid ""
"Either the allocated state or the error code encoded into the pointer. When "
"the error is EDEADLK then the w/w mutex code has detected a deadlock and the "
"entire atomic sequence must be restarted. All other errors are fatal."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:510
msgid "get plane state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:512
msgid "plane to get state object for"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:513
msgid ""
"This function returns the plane state for the given plane, allocating it if "
"needed. It will also grab the relevant plane lock to make sure that the "
"state is consistent."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:775
msgid "initialize private object"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:776
msgid "DRM device this object will be attached to"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:778
#: drivers/gpu/drm/drm_atomic.c:810 drivers/gpu/drm/drm_atomic.c:822
#: drivers/gpu/drm/drm_atomic.c:881 drivers/gpu/drm/drm_atomic.c:903
msgid "``struct drm_private_obj *obj``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:777
#: drivers/gpu/drm/drm_atomic.c:805
msgid "private object"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:779
msgid "``struct drm_private_state *state``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:778
msgid "initial private object state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:780
msgid "``const struct drm_private_state_funcs *funcs``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:779
msgid ""
"pointer to the struct of function pointers that identify the object type"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:781
msgid ""
"Initialize the private object, which can be embedded into any driver private "
"object that needs its own atomic state."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:804
msgid "finalize private object"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:806
msgid "Finalize the private object."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:819
msgid "get private object state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:820
msgid "global atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:821
msgid "private object to get the state for"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:822
msgid ""
"This function returns the private object state for the given private object, "
"allocating the state if needed. It will also grab the relevant private "
"object lock to make sure that the state is consistent."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:827
msgid "Either the allocated state or the error code encoded into a pointer."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:880
#: drivers/gpu/drm/drm_atomic.c:902
msgid "private_obj to grab"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:881
msgid ""
"This function returns the old private object state for the given "
"private_obj, or NULL if the private_obj is not part of the global atomic "
"state."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:903
msgid ""
"This function returns the new private object state for the given "
"private_obj, or NULL if the private_obj is not part of the global atomic "
"state."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:922
msgid "Get old connector for an encoder"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:923
#: drivers/gpu/drm/drm_atomic.c:961 drivers/gpu/drm/drm_atomic.c:1051
#: drivers/gpu/drm/drm_atomic.c:1081
msgid "Atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:925
#: drivers/gpu/drm/drm_atomic.c:963 drivers/gpu/drm/drm_atomic.c:1053
#: drivers/gpu/drm/drm_atomic.c:1083 drivers/gpu/drm/drm_atomic.c:1294
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:652
#: drivers/gpu/drm/drm_connector.c:688 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:296 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:146 drivers/gpu/drm/drm_encoder.c:188
#: drivers/gpu/drm/drm_encoder.c:273
msgid "``struct drm_encoder *encoder``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:924
#: drivers/gpu/drm/drm_atomic.c:962
msgid "The encoder to fetch the connector state for"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:925
msgid ""
"This function finds and returns the connector that was connected to "
"**encoder** as specified by the **state**."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:928
msgid ""
"If there is no connector in **state** which previously had **encoder** "
"connected to it, this function will return NULL. While this may seem like an "
"invalid use case, it is sometimes useful to differentiate commits which had "
"no prior connectors attached to **encoder** vs ones that did (and to inspect "
"their state). This is especially true in enable hooks because the pipeline "
"has changed."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:935
#: drivers/gpu/drm/drm_atomic.c:972
msgid ""
"If you don't have access to the atomic state, see "
"drm_atomic_get_connector_for_encoder()."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:939
msgid ""
"The old connector connected to **encoder**, or NULL if the encoder is not "
"connected."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:960
msgid "Get new connector for an encoder"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:963
msgid ""
"This function finds and returns the connector that will be connected to "
"**encoder** as specified by the **state**."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:966
msgid ""
"If there is no connector in **state** which will have **encoder** connected "
"to it, this function will return NULL. While this may seem like an invalid "
"use case, it is sometimes useful to differentiate commits which have no "
"connectors attached to **encoder** vs ones that do (and to inspect their "
"state). This is especially true in disable hooks because the pipeline will "
"change."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:976
msgid ""
"The new connector connected to **encoder**, or NULL if the encoder is not "
"connected."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:997
msgid "Get connector currently assigned to an encoder"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1003
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:272
#: include/drm/drm_encoder.h:284
msgid "``const struct drm_encoder *encoder``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:998
msgid "The encoder to find the connector of"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1000
#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:246
#: drivers/gpu/drm/drm_modeset_lock.c:267
#: drivers/gpu/drm/drm_modeset_lock.c:277
#: drivers/gpu/drm/drm_modeset_lock.c:343
#: drivers/gpu/drm/drm_modeset_lock.c:380
#: drivers/gpu/drm/drm_modeset_lock.c:435
msgid "``struct drm_modeset_acquire_ctx *ctx``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:999
msgid "Modeset locking context"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1000
msgid ""
"This function finds and returns the connector currently assigned to an "
"**encoder**."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1003
msgid ""
"It is similar to the drm_atomic_get_old_connector_for_encoder() and "
"drm_atomic_get_new_connector_for_encoder() helpers, but doesn't require "
"access to the atomic state. If you have access to it, prefer using these. "
"This helper is typically useful in situations where you don't have access to "
"the atomic state, like detect, link repair, threaded interrupt handlers, or "
"hooks from other frameworks (ALSA, CEC, etc.)."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1012
msgid ""
"The connector connected to **encoder**, or an error pointer otherwise. When "
"the error is EDEADLK, a deadlock has been detected and the sequence must be "
"restarted."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1050
msgid "Get old crtc for an encoder"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1052
#: drivers/gpu/drm/drm_atomic.c:1082
msgid "The encoder to fetch the crtc state for"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1053
msgid ""
"This function finds and returns the crtc that was connected to **encoder** "
"as specified by the **state**."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1057
msgid ""
"The old crtc connected to **encoder**, or NULL if the encoder is not "
"connected."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1080
msgid "Get new crtc for an encoder"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1083
msgid ""
"This function finds and returns the crtc that will be connected to "
"**encoder** as specified by the **state**."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1087
msgid ""
"The new crtc connected to **encoder**, or NULL if the encoder is not "
"connected."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1110
msgid "get connector state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1112
msgid "connector to get state object for"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1113
msgid ""
"This function returns the connector state for the given connector, "
"allocating it if needed. It will also grab the relevant connector lock to "
"make sure that the state is consistent."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1219
msgid "get bridge state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1222
#: drivers/gpu/drm/drm_atomic.c:1250 drivers/gpu/drm/drm_atomic.c:1272
msgid "``struct drm_bridge *bridge``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1221
msgid "bridge to get state object for"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1222
msgid ""
"This function returns the bridge state for the given bridge, allocating it "
"if needed. It will also grab the relevant bridge lock to make sure that the "
"state is consistent."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1227
msgid ""
"Either the allocated state or the error code encoded into the pointer. When "
"the error is EDEADLK then the w/w mutex code has detected a deadlock and the "
"entire atomic sequence must be restarted."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1247
msgid "get old bridge state, if it exists"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1249
#: drivers/gpu/drm/drm_atomic.c:1271
msgid "bridge to grab"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1250
msgid ""
"This function returns the old bridge state for the given bridge, or NULL if "
"the bridge is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1269
msgid "get new bridge state, if it exists"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1272
msgid ""
"This function returns the new bridge state for the given bridge, or NULL if "
"the bridge is not part of the global atomic state."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1291
msgid "add bridges attached to an encoder"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1293
msgid "DRM encoder"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1294
msgid ""
"This function adds all bridges attached to **encoder**. This is needed to "
"add bridge states to **state** and make them available when :c:type:"
"`drm_bridge_funcs.atomic_check\\(\\) <drm_bridge_funcs>`, :c:type:"
"`drm_bridge_funcs.atomic_pre_enable\\(\\) <drm_bridge_funcs>`, :c:type:"
"`drm_bridge_funcs.atomic_enable\\(\\) <drm_bridge_funcs>`, :c:type:"
"`drm_bridge_funcs.atomic_disable_post_disable\\(\\) <drm_bridge_funcs>` are "
"called."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1301
#: drivers/gpu/drm/drm_atomic.c:1346 drivers/gpu/drm/drm_atomic.c:1410
#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:183
#: drivers/gpu/drm/drm_atomic_uapi.c:269
msgid ""
"0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK "
"then the w/w mutex code has detected a deadlock and the entire atomic "
"sequence must be restarted. All other errors are fatal."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1335
msgid "add connectors for CRTC"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1337
#: drivers/gpu/drm/drm_atomic.c:1398 ../../../gpu/drm-kms:327:
#: drivers/gpu/drm/drm_color_mgmt.c:153
msgid "DRM CRTC"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1338
msgid ""
"This function walks the current configuration and adds all connectors "
"currently using **crtc** to the atomic configuration **state**. Note that "
"this function must acquire the connection mutex. This can potentially cause "
"unneeded serialization if the update is just for the planes on one CRTC. "
"Hence drivers and helpers should only call this when really needed (e.g. "
"when a full modeset needs to happen due to some change)."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1396
msgid "add planes for CRTC"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1399
msgid ""
"This function walks the current configuration and adds all planes currently "
"used by **crtc** to the atomic configuration **state**. This is useful when "
"an atomic commit also needs to check all currently enabled plane on "
"**crtc**, e.g. when changing the mode. It's also useful when re-enabling a "
"CRTC to avoid special code to force-enable all planes."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1405
msgid ""
"Since acquiring a plane state will always also acquire the w/w mutex of the "
"current CRTC for that plane (if there is any) adding all the plane states "
"for a CRTC will not reduce parallelism of atomic updates."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1441
msgid "check whether a given config would work"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1442
#: drivers/gpu/drm/drm_atomic.c:1550 drivers/gpu/drm/drm_atomic.c:1583
#: drivers/gpu/drm/drm_atomic.c:1789
msgid "atomic configuration to check"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1443
#: drivers/gpu/drm/drm_atomic.c:1551 drivers/gpu/drm/drm_atomic.c:1584
msgid ""
"Note that this function can return -EDEADLK if the driver needed to acquire "
"more locks but encountered a deadlock. The caller must then do the usual w/w "
"backoff dance and restart. All other errors are fatal."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1448
#: drivers/gpu/drm/drm_atomic.c:1559 drivers/gpu/drm/drm_atomic.c:1592
#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:222
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1549
msgid "commit configuration atomically"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1555
#: drivers/gpu/drm/drm_atomic.c:1588
msgid ""
"This function will take its own reference on **state**. Callers should "
"always release their reference with drm_atomic_state_put()."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1582
msgid "atomic nonblocking commit"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1788
msgid "prints drm atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1791
#: drivers/gpu/drm/drm_atomic.c:1883
msgid "``struct drm_printer *p``"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1790
msgid "drm printer"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1791
msgid ""
"This functions prints the drm atomic state snapshot using the drm printer "
"which is passed to it. This snapshot can be used for debugging purposes."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1794
msgid ""
"Note that this function looks into the new state objects and hence its not "
"safe to be used after the call to drm_atomic_helper_commit_hw_done()."
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1880
msgid "dump entire device atomic state"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1881
msgid "the drm device"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1882
msgid "where to print the state to"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1883
msgid ""
"Just for debugging.  Drivers might want an option to dump state to dmesg in "
"case of error irq's.  (Hint, you probably want to ratelimit this!)"
msgstr ""

#: ../../../gpu/drm-kms:297: drivers/gpu/drm/drm_atomic.c:1887
msgid ""
"The caller must wrap this drm_modeset_lock_all_ctx() and "
"drm_modeset_drop_locks(). If this is called from error irq handler, it "
"should not be enabled by default - if you are debugging errors you might not "
"care that this is racey, but calling this without all modeset locks held is "
"inherently unsafe."
msgstr ""

#: ../../../gpu/drm-kms.rst:301
msgid "Atomic Mode Setting IOCTL and UAPI Functions"
msgstr ""

#: ../../../gpu/drm-kms:303: drivers/gpu/drm/drm_atomic_uapi.c:48
msgid ""
"This file contains the marshalling and demarshalling glue for the atomic "
"UAPI in all its forms: The monster ATOMIC IOCTL itself, code for "
"GET_PROPERTY and SET_PROPERTY IOCTLs. Plus interface functions for "
"compatibility helpers and drivers which have special needs to construct "
"their own atomic updates, e.g. for load detect or similar."
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:58
#: drivers/gpu/drm/drm_atomic_uapi.c:110
msgid "set mode for CRTC"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:64
#: drivers/gpu/drm/drm_atomic_uapi.c:116
msgid "``struct drm_crtc_state *state``"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:59
#: drivers/gpu/drm/drm_atomic_uapi.c:111
msgid "the CRTC whose incoming state to update"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:61
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:657
#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:446
#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:59
#: drivers/gpu/drm/drm_modes.c:1287 drivers/gpu/drm/drm_modes.c:1318
#: drivers/gpu/drm/drm_modes.c:1450 drivers/gpu/drm/drm_modes.c:1662
#: drivers/gpu/drm/drm_modes.c:1694 drivers/gpu/drm/drm_modes.c:1722
#: drivers/gpu/drm/drm_modes.c:2706 drivers/gpu/drm/drm_modes.c:2726
#: drivers/gpu/drm/drm_modes.c:2745 ../../../gpu/drm-kms:635:
#: drivers/gpu/drm/drm_vblank.c:605
msgid "``const struct drm_display_mode *mode``"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:60
msgid "kernel-internal mode to use for the CRTC, or NULL to disable"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:61
msgid ""
"Set a mode (originating from the kernel) on the desired CRTC state and "
"update the enable property."
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:65
#: drivers/gpu/drm/drm_atomic_uapi.c:119
msgid "Zero on success, error code on failure. Cannot return -EDEADLK."
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:113
#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:602
#: drivers/gpu/drm/drm_property.c:632
msgid "``struct drm_property_blob *blob``"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:112
msgid "pointer to blob property to use for mode"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:113
msgid ""
"Set a mode (originating from a blob property) on the desired CRTC state. "
"This function will take a reference on the blob property for the CRTC state, "
"and release the reference held on the state's existing mode property, if any "
"was set."
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:175
msgid "set CRTC for plane"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:181
#: drivers/gpu/drm/drm_atomic_uapi.c:237 ../../../gpu/drm-kms:395:
#: drivers/gpu/drm/drm_damage_helper.c:59
msgid "``struct drm_plane_state *plane_state``"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:176
msgid "the plane whose incoming state to update"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:177
msgid "CRTC to use for the plane"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:178
msgid ""
"Changing the assigned CRTC for a plane requires us to grab the lock and "
"state for the new CRTC, as needed. This function takes care of all these "
"details besides updating the pointer in the state object itself."
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:231
msgid "set framebuffer for plane"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:232
msgid "atomic state object for the plane"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:234
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:230
#: include/drm/drm_framebuffer.h:241 include/drm/drm_framebuffer.h:261
#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:849
#: drivers/gpu/drm/drm_framebuffer.c:944 drivers/gpu/drm/drm_framebuffer.c:972
#: drivers/gpu/drm/drm_framebuffer.c:1141 ../../../gpu/drm-kms:395:
#: drivers/gpu/drm/drm_damage_helper.c:96
msgid "``struct drm_framebuffer *fb``"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:233
msgid "fb to use for the plane"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:234
msgid ""
"Changing the assigned framebuffer for a plane requires us to grab a "
"reference to the new fb and drop the reference to the old fb, if there is "
"one. This function takes care of all these details besides updating the "
"pointer in the state object itself."
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:261
msgid "set CRTC for connector"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:267
#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:460
msgid "``struct drm_connector_state *conn_state``"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:262
msgid "atomic state object for the connector"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:263
msgid "CRTC to use for the connector"
msgstr ""

#: ../../../gpu/drm-kms:306: drivers/gpu/drm/drm_atomic_uapi.c:264
msgid ""
"Changing the assigned CRTC for a connector requires us to grab the lock and "
"state for the new CRTC, as needed. This function takes care of all these "
"details besides updating the pointer in the state object itself."
msgstr ""

#: ../../../gpu/drm-kms.rst:310
msgid "CRTC Abstraction"
msgstr ""

#: ../../../gpu/drm-kms:312: drivers/gpu/drm/drm_crtc.c:56
msgid ""
"A CRTC represents the overall display pipeline. It receives pixel data from :"
"c:type:`drm_plane` and blends them together. The :c:type:`drm_display_mode` "
"is also attached to the CRTC, specifying display timings. On the output side "
"the data is fed to one or more :c:type:`drm_encoder`, which are then each "
"connected to one :c:type:`drm_connector`."
msgstr ""

#: ../../../gpu/drm-kms:312: drivers/gpu/drm/drm_crtc.c:62
msgid ""
"To create a CRTC, a KMS driver allocates and zeroes an instance of :c:type:"
"`struct drm_crtc <drm_crtc>` (possibly as part of a larger structure) and "
"registers it with a call to drm_crtc_init_with_planes()."
msgstr ""

#: ../../../gpu/drm-kms:312: drivers/gpu/drm/drm_crtc.c:66
msgid ""
"The CRTC is also the entry point for legacy modeset operations (see :c:type:"
"`drm_crtc_funcs.set_config <drm_crtc_funcs>`), legacy plane operations (see :"
"c:type:`drm_crtc_funcs.page_flip <drm_crtc_funcs>` and :c:type:"
"`drm_crtc_funcs.cursor_set2 <drm_crtc_funcs>`), and other legacy operations "
"like :c:type:`drm_crtc_funcs.gamma_set <drm_crtc_funcs>`. For atomic drivers "
"all these features are controlled through :c:type:`drm_property` and :c:type:"
"`drm_mode_config_funcs.atomic_check <drm_mode_config_funcs>`."
msgstr ""

#: ../../../gpu/drm-kms.rst:316
msgid "CRTC Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:67
msgid "mutable CRTC state"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:83
msgid "backpointer to the CRTC"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:86
msgid "``enable``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:87
msgid ""
"Whether the CRTC should be enabled, gates all other state. This controls "
"reservations of shared resources. Actual hardware state is controlled by "
"**active**."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:93
msgid "``active``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:94
msgid ""
"Whether the CRTC is actively displaying (used for DPMS). Implies that "
"**enable** is set. The driver must not release any shared resources if "
"**active** is set to false but **enable** still true, because userspace "
"expects that a DPMS ON always succeeds."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:99
msgid ""
"Hence drivers must not consult **active** in their various :c:type:"
"`drm_mode_config_funcs.atomic_check <drm_mode_config_funcs>` callback to "
"reject an atomic commit. They can consult it to aid in the computation of "
"derived hardware state, since even in the DPMS OFF state the display "
"hardware should be as much powered down as when the CRTC is completely "
"disabled through setting **enable** to false."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:108
msgid "``planes_changed``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:109
msgid ""
"Planes on this crtc are updated. Used by the atomic helpers and drivers to "
"steer the atomic commit control flow."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:114
msgid "``mode_changed``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:115
msgid ""
"**mode** or **enable** has been changed. Used by the atomic helpers and "
"drivers to steer the atomic commit control flow. See also "
"drm_atomic_crtc_needs_modeset()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:119
msgid ""
"Drivers are supposed to set this for any CRTC state changes that require a "
"full modeset. They can also reset it to false if e.g. a **mode** change can "
"be done without a full modeset by only changing scaler settings."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:126
msgid "``active_changed``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:127
msgid ""
"**active** has been toggled. Used by the atomic helpers and drivers to steer "
"the atomic commit control flow. See also drm_atomic_crtc_needs_modeset()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:133
msgid "``connectors_changed``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:134
msgid ""
"Connectors to this crtc have been updated, either in their state or routing. "
"Used by the atomic helpers and drivers to steer the atomic commit control "
"flow. See also drm_atomic_crtc_needs_modeset()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:139
msgid ""
"Drivers are supposed to set this as-needed from their own atomic check code, "
"e.g. from :c:type:`drm_encoder_helper_funcs.atomic_check "
"<drm_encoder_helper_funcs>`"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:143
msgid "``zpos_changed``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:144
msgid ""
"zpos values of planes on this crtc have been updated. Used by the atomic "
"helpers and drivers to steer the atomic commit control flow."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:149
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:258
msgid "``color_mgmt_changed``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:150
msgid ""
"Color management properties have changed (**gamma_lut**, **degamma_lut** or "
"**ctm**). Used by the atomic helpers and drivers to steer the atomic commit "
"control flow."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:156
msgid "``no_vblank``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:157
msgid ""
"Reflects the ability of a CRTC to send VBLANK events. This state usually "
"depends on the pipeline configuration. If set to true, DRM atomic helpers "
"will send out a fake VBLANK event during display updates after all hardware "
"changes have been committed. This is implemented in "
"drm_atomic_helper_fake_vblank()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:163
msgid ""
"One usage is for drivers and/or hardware without support for VBLANK "
"interrupts. Such drivers typically do not initialize vblanking (i.e., call "
"drm_vblank_init() with the number of CRTCs). For CRTCs without initialized "
"vblanking, this field is set to true in drm_atomic_helper_check_modeset(), "
"and a fake VBLANK event will be send out on each update of the display "
"pipeline by drm_atomic_helper_fake_vblank()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:171
msgid ""
"Another usage is CRTCs feeding a writeback connector operating in oneshot "
"mode. In this case the fake VBLANK event is only generated when a job is "
"queued to the writeback connector, and we want the core to fake VBLANK "
"events when this part of the pipeline hasn't changed but others had or when "
"the CRTC and connectors are being disabled."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:178
msgid ""
"__drm_atomic_helper_crtc_duplicate_state() will not reset the value from the "
"current state, the CRTC driver is then responsible for updating this field "
"when needed."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:182
msgid ""
"Note that the combination of :c:type:`drm_crtc_state.event <drm_crtc_state>` "
"== NULL and :c:type:`drm_crtc_state.no_blank <drm_crtc_state>` == true is "
"valid and usually used when the writeback connector attached to the CRTC has "
"a new job queued. In this case the driver will send the VBLANK event on its "
"own when the writeback job is complete."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:192
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:962
msgid "``plane_mask``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:193
msgid "Bitmask of drm_plane_mask(plane) of planes attached to this CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:198
msgid "``connector_mask``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:199
msgid ""
"Bitmask of drm_connector_mask(connector) of connectors attached to this CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:204
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:329
msgid "``encoder_mask``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:205
msgid "Bitmask of drm_encoder_mask(encoder) of encoders attached to this CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:210
msgid "``adjusted_mode``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:211
msgid ""
"Internal display timings which can be used by the driver to handle "
"differences between the mode requested by userspace in **mode** and what is "
"actually programmed into the hardware."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:215
msgid ""
"For drivers using :c:type:`drm_bridge`, this stores hardware display timings "
"used between the CRTC and the first bridge. For other drivers, the meaning "
"of the adjusted_mode field is purely driver implementation defined "
"information, and will usually be used to store the hardware display timings "
"used between the CRTC and encoder blocks."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:225
#: include/drm/drm_crtc.h:1016 include/drm/drm_crtc.h:1184
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:904
msgid "``mode``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:226
msgid ""
"Display timings requested by userspace. The driver should try to match the "
"refresh rate as close as possible (but note that it's undefined what exactly "
"is close enough, e.g. some of the HDMI modes only differ in less than 1% of "
"the refresh rate). The active width and height as observed by userspace for "
"positioning planes must match exactly."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:233
msgid ""
"For external connectors where the sink isn't fixed (like with a built-in "
"panel), this mode here should match the physical mode on the wire to the "
"last details (i.e. including sync polarities and everything)."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:242
msgid "``mode_blob``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:243
msgid ""
":c:type:`drm_property_blob` for **mode**, for exposing the mode to atomic "
"userspace."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:248
msgid "``degamma_lut``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:249
msgid ""
"Lookup table for converting framebuffer pixel data before apply the color "
"conversion matrix **ctm**. See drm_crtc_enable_color_mgmt(). The blob (if "
"not NULL) is an array of :c:type:`struct drm_color_lut <drm_color_lut>`."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:257
msgid "``ctm``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:258
msgid ""
"Color transformation matrix. See drm_crtc_enable_color_mgmt(). The blob (if "
"not NULL) is a :c:type:`struct drm_color_ctm <drm_color_ctm>`."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:265
msgid "``gamma_lut``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:266
msgid ""
"Lookup table for converting pixel data after the color conversion matrix "
"**ctm**.  See drm_crtc_enable_color_mgmt(). The blob (if not NULL) is an "
"array of :c:type:`struct drm_color_lut <drm_color_lut>`."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:270
#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:85
msgid ""
"Note that for mostly historical reasons stemming from Xorg heritage, this is "
"also used to store the color map (also sometimes color lut, CLUT or color "
"palette) for indexed formats like DRM_FORMAT_C8."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:278
msgid "``target_vblank``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:279
msgid "Target vertical blank period when a page flip should take effect."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:286
msgid "``async_flip``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:287
msgid ""
"This is set when DRM_MODE_PAGE_FLIP_ASYNC is set in the legacy PAGE_FLIP "
"IOCTL. It's not wired up for the atomic IOCTL itself yet."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:294
msgid "``vrr_enabled``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:295
msgid ""
"Indicates if variable refresh rate should be enabled for the CRTC. Support "
"for the requested vrr state will depend on driver and hardware capabiltiy - "
"lacking support is not treated as failure."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:303
msgid "``self_refresh_active``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:304
msgid ""
"Used by the self refresh helpers to denote when a self refresh transition is "
"occurring. This will be set on enable/disable callbacks when self refresh is "
"being enabled or disabled. In some cases, it may not be desirable to fully "
"shut off the crtc during self refresh. CRTC's can inspect this flag and "
"determine the best course of action."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:314
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:240
msgid "``scaling_filter``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:315
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:241
msgid "Scaling filter to be applied"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:322
msgid ""
"Optional pointer to a DRM event to signal upon completion of the state "
"update. The driver must send out the event when the atomic commit operation "
"completes. There are two cases:"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:326
msgid ""
"The event is for a CRTC which is being disabled through this atomic commit. "
"In that case the event can be send out any time after the hardware has "
"stopped scanning out the current framebuffers. It should contain the "
"timestamp and counter for the last vblank before the display pipeline was "
"shut off. The simplest way to achieve that is calling "
"drm_crtc_send_vblank_event() somewhen after drm_crtc_vblank_off() has been "
"called."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:334
msgid ""
"For a CRTC which is enabled at the end of the commit (even when it undergoes "
"an full modeset) the vblank timestamp and counter must be for the vblank "
"right before the first frame that scans out the new set of buffers. Again "
"the event can only be sent out after the hardware has stopped scanning out "
"the old buffers."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:340
msgid ""
"Events for disabled CRTCs are not allowed, and drivers can ignore that case."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:343
msgid ""
"For very simple hardware without VBLANK interrupt, enabling :c:type:`struct "
"drm_crtc_state <drm_crtc_state>`.no_vblank makes DRM's atomic commit helpers "
"send a fake VBLANK event at the end of the display update after all hardware "
"changes have been applied. See drm_atomic_helper_fake_vblank()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:349
msgid ""
"For more complex hardware this can be handled by the "
"drm_crtc_send_vblank_event() function, which the driver should call on the "
"provided event upon completion of the atomic commit. Note that if the driver "
"supports vblank signalling and timestamping the vblank counters and "
"timestamps must agree with the ones returned from page flip events. With the "
"current vblank helper infrastructure this can be achieved by holding a "
"vblank reference while the page flip is pending, acquired through "
"drm_crtc_vblank_get() and released with drm_crtc_vblank_put(). Drivers are "
"free to implement their own vblank counter and timestamp tracking though, e."
"g. if they have accurate timestamp registers in hardware."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:362
msgid ""
"For hardware which supports some means to synchronize vblank interrupt "
"delivery with committing display state there's also "
"drm_crtc_arm_vblank_event(). See the documentation of that function for a "
"detailed discussion of the constraints it needs to be used safely."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:368
msgid ""
"If the device can't notify of flip completion in a race-free way at all, "
"then the event should be armed just after the page flip is committed. In the "
"worst case the driver will send the event to userspace one frame too late. "
"This doesn't allow for a real atomic update, but it should avoid tearing."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:378
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:247
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1045
msgid "``commit``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:379
msgid ""
"This tracks how the commit for this update proceeds through the various "
"phases. This is never cleared, except when we destroy the state, so that "
"subsequent commits can synchronize with previous ones."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:68
msgid ""
"Note that the distinction between **enable** and **active** is rather "
"subtle: Flipping **active** while **enable** is set without changing "
"anything else may never return in a failure from the :c:type:"
"`drm_mode_config_funcs.atomic_check <drm_mode_config_funcs>` callback. "
"Userspace assumes that a DPMS On will always succeed. In other words: "
"**enable** controls resource assignment, **active** controls the actual "
"hardware state."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:75
msgid ""
"The three booleans active_changed, connectors_changed and mode_changed are "
"intended to indicate whether a full modeset is needed, rather than strictly "
"describing what has changed in a commit. See also: "
"drm_atomic_crtc_needs_modeset()"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:391
msgid "control CRTCs for a given device"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:404
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:355
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1325
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:42
msgid "``reset``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:405
msgid ""
"Reset CRTC hardware and software state to off. This function isn't called by "
"the core directly, only through drm_mode_config_reset(). It's not a helper "
"hook only for historical reasons."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:409
msgid ""
"Atomic drivers can use drm_atomic_helper_crtc_reset() to reset atomic state "
"using this hook."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:416
msgid "``cursor_set``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:417
msgid ""
"Update the cursor image. The cursor position is relative to the CRTC and can "
"be partially or fully outside of the visible area."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:420
msgid ""
"Note that contrary to all other KMS functions the legacy cursor entry points "
"don't take a framebuffer object, but instead take directly a raw buffer "
"object id from the driver's buffer manager (which is either GEM or TTM for "
"current drivers)."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:425
#: include/drm/drm_crtc.h:447 include/drm/drm_crtc.h:467
msgid ""
"This entry point is deprecated, drivers should instead implement universal "
"plane support and register a proper cursor plane using "
"drm_crtc_init_with_planes()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:429
msgid "This callback is optional"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:433
#: include/drm/drm_crtc.h:455 include/drm/drm_crtc.h:475
#: include/drm/drm_crtc.h:517 include/drm/drm_crtc.h:612
#: include/drm/drm_crtc.h:781 include/drm/drm_crtc.h:797
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:71
#: include/drm/drm_framebuffer.h:95 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:316 include/drm/drm_plane.h:339
#: include/drm/drm_plane.h:377 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1319 include/drm/drm_connector.h:1422
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1180
#: drivers/gpu/drm/drm_connector.c:2099 drivers/gpu/drm/drm_connector.c:2146
#: drivers/gpu/drm/drm_connector.c:2243 drivers/gpu/drm/drm_connector.c:2689
msgid "0 on success or a negative error code on failure."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:440
msgid "``cursor_set2``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:441
msgid ""
"Update the cursor image, including hotspot information. The hotspot must not "
"affect the cursor position in CRTC coordinates, but is only meant as a hint "
"for virtualized display hardware to coordinate the guests and hosts cursor "
"position. The cursor hotspot is relative to the cursor image. Otherwise this "
"works exactly like **cursor_set**."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:451
#: include/drm/drm_crtc.h:471 include/drm/drm_crtc.h:484
#: include/drm/drm_crtc.h:555
msgid "This callback is optional."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:463
msgid "``cursor_move``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:464
msgid ""
"Update the cursor position. The cursor does not need to be visible when this "
"hook is called."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:481
msgid "``gamma_set``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:482
msgid "Set gamma on the CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:486
msgid ""
"Atomic drivers who want to support gamma tables should implement the atomic "
"color management support, enabled by calling drm_crtc_enable_color_mgmt(), "
"which then supports the legacy gamma interface through the "
"drm_atomic_helper_legacy_gamma_set() compatibility implementation."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:498
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:45
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:346
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1460
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:51
msgid "``destroy``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:499
msgid ""
"Clean up CRTC resources. This is only called at driver unload time through "
"drm_mode_config_cleanup() since a CRTC cannot be hotplugged in DRM."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:507
msgid "``set_config``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:508
msgid ""
"This is the main legacy entry point to change the modeset state on a CRTC. "
"All the details of the desired configuration are passed in a :c:type:`struct "
"drm_mode_set <drm_mode_set>` - see there for details."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:512
msgid ""
"Drivers implementing atomic modeset should use "
"drm_atomic_helper_set_config() to implement this hook."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:524
msgid "``page_flip``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:525
msgid "Legacy entry point to schedule a flip to the given framebuffer."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:527
msgid ""
"Page flipping is a synchronization mechanism that replaces the frame buffer "
"being scanned out by the CRTC with a new frame buffer during vertical "
"blanking, avoiding tearing (except when requested otherwise through the "
"DRM_MODE_PAGE_FLIP_ASYNC flag). When an application requests a page flip the "
"DRM core verifies that the new frame buffer is large enough to be scanned "
"out by the CRTC in the currently configured mode and then calls this hook "
"with a pointer to the new frame buffer."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:536
msgid ""
"The driver must wait for any pending rendering to the new framebuffer to "
"complete before executing the flip. It should also wait for any pending "
"rendering from other drivers if the underlying buffer is a shared dma-buf."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:541
msgid ""
"An application can request to be notified when the page flip has completed. "
"The drm core will supply a :c:type:`struct drm_event <drm_event>` in the "
"event parameter in this case. This can be handled by the "
"drm_crtc_send_vblank_event() function, which the driver should call on the "
"provided event upon completion of the flip. Note that if the driver supports "
"vblank signalling and timestamping the vblank counters and timestamps must "
"agree with the ones returned from page flip events. With the current vblank "
"helper infrastructure this can be achieved by holding a vblank reference "
"while the page flip is pending, acquired through drm_crtc_vblank_get() and "
"released with drm_crtc_vblank_put(). Drivers are free to implement their own "
"vblank counter and timestamp tracking though, e.g. if they have accurate "
"timestamp registers in hardware."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:559
msgid ""
"Very early versions of the KMS ABI mandated that the driver must block (but "
"not reject) any rendering to the old framebuffer until the flip operation "
"has completed and the old framebuffer is no longer visible. This requirement "
"has been lifted, and userspace is instead expected to request delivery of an "
"event and wait with recycling old buffers until such has been received."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:568
msgid ""
"0 on success or a negative error code on failure. Note that if a page flip "
"operation is already pending the callback should return -EBUSY. Pageflips on "
"a disabled CRTC (either by setting a NULL mode or just runtime disabled "
"through DPMS respectively the new atomic \"ACTIVE\" state) should result in "
"an -EINVAL error code. Note that drm_atomic_helper_page_flip() checks this "
"already for atomic drivers."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:583
msgid "``page_flip_target``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:584
msgid ""
"Same as **page_flip** but with an additional parameter specifying the "
"absolute target vertical blank period (as reported by "
"drm_crtc_vblank_count()) when the flip should take effect."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:588
msgid ""
"Note that the core code calls drm_crtc_vblank_get before this entry point, "
"and will call drm_crtc_vblank_put if this entry point returns any non-0 "
"error code. It's the driver's responsibility to call drm_crtc_vblank_put "
"after this entry point returns 0, typically when the flip completes."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:602
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:367
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1412
msgid "``set_property``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:603
msgid ""
"This is the legacy entry point to update a property attached to the CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:606
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:371
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1416
msgid ""
"This callback is optional if the driver does not support any legacy driver-"
"private properties. For atomic drivers it is not used because property "
"handling is done entirely in the DRM core."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:620
msgid ""
"Duplicate the current atomic state for this CRTC and return it. The core and "
"helpers guarantee that any atomic state duplicated with this hook and still "
"owned by the caller (i.e. not transferred to the driver by calling :c:type:"
"`drm_mode_config_funcs.atomic_commit <drm_mode_config_funcs>`) will be "
"cleaned up by calling the **atomic_destroy_state** hook in this structure."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:627
#: include/drm/drm_crtc.h:656 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:392 include/drm/drm_plane.h:421
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1478
#: include/drm/drm_connector.h:1507
msgid "This callback is mandatory for atomic drivers."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:629
msgid ""
"Atomic drivers which don't subclass :c:type:`struct drm_crtc_state "
"<drm_crtc_state>` should use drm_atomic_helper_crtc_duplicate_state(). "
"Drivers that subclass the state structure to extend it with driver-private "
"state should use __drm_atomic_helper_crtc_duplicate_state() to make sure "
"shared state is duplicated in a consistent fashion across drivers."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:635
msgid ""
"It is an error to call this hook before :c:type:`drm_crtc.state <drm_crtc>` "
"has been initialized correctly."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:640
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:405
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1491
msgid ""
"If the duplicate state references refcounted resources this hook must "
"acquire a reference for each of them. The driver must release these "
"references again in **atomic_destroy_state**."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:646
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:411
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1497
msgid "Duplicated atomic state or NULL when the allocation failed."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:653
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:418
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1504
msgid ""
"Destroy a state duplicated with **atomic_duplicate_state** and release or "
"unreference all resources it references"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:663
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:428
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1514
msgid "``atomic_set_property``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:664
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:429
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1515
msgid ""
"Decode a driver-private property value and store the decoded value into the "
"passed-in state structure. Since the atomic core decodes all standardized "
"properties (even for extensions beyond the core set of properties which "
"might not be implemented by all drivers) this requires drivers to subclass "
"the state structure."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:670
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:435
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1521
msgid ""
"Such driver-private properties should really only be implemented for truly "
"hardware/vendor specific state. Instead it is preferred to standardize "
"atomic extension and decode the properties used to expose such an extension "
"in the core."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:675
msgid ""
"Do not call this function directly, use drm_atomic_crtc_set_property() "
"instead."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:678
#: include/drm/drm_crtc.h:716 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:443 include/drm/drm_plane.h:482
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1529
#: include/drm/drm_connector.h:1568
msgid ""
"This callback is optional if the driver does not support any driver-private "
"atomic properties."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:683
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:448
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1534
msgid ""
"This function is called in the state assembly phase of atomic modesets, "
"which can be aborted for any reason (including on userspace's request to "
"just check whether a configuration would be possible). Drivers MUST NOT "
"touch any persistent state (hardware or software) or data structures except "
"the passed in **state** parameter."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:689
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:454
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1540
msgid ""
"Also since userspace controls in which order properties are set this "
"function must not do any input validation (since the state update is "
"incomplete and hence likely inconsistent). Instead any such input validation "
"must be done in the various atomic_check callbacks."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:696
msgid ""
"0 if the property has been found, -EINVAL if the property isn't implemented "
"by the driver (which should never happen, the core only asks for properties "
"attached to this CRTC). No other validation is allowed by the driver. The "
"core already checks that the property value is within the range (integer, "
"valid enum value, ...) the driver set when registering the property."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:709
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:475
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1561
msgid "``atomic_get_property``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:710
msgid ""
"Reads out the decoded driver-private property. This is used to implement the "
"GETCRTC IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:713
msgid ""
"Do not call this function directly, use drm_atomic_crtc_get_property() "
"instead."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:721
msgid ""
"0 on success, -EINVAL if the property isn't implemented by the driver (which "
"should never happen, the core only asks for properties attached to this "
"CRTC)."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:732
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:497
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1429
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:60
msgid "``late_register``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:733
msgid ""
"This optional hook can be used to register additional userspace interfaces "
"attached to the crtc like debugfs interfaces. It is called late in the "
"driver load sequence from drm_dev_register(). Everything added from this "
"callback should be unregistered in the early_unregister callback."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:739
#: include/drm/drm_crtc.h:856 include/drm/drm_crtc.h:868
#: include/drm/drm_crtc.h:914 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:504 include/drm/drm_plane.h:544
#: include/drm/drm_plane.h:560 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1236 include/drm/drm_connector.h:1439
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:67
msgid "Returns:"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:741
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:506
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1441
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:69
msgid "0 on success, or a negative error code on failure."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:747
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:512
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1447
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:75
msgid "``early_unregister``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:748
msgid ""
"This optional hook should be used to unregister the additional userspace "
"interfaces attached to the crtc from **late_register**. It is called from "
"drm_dev_unregister(), early in the driver unload sequence to disable "
"userspace access before data structures are torndown."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:758
msgid "``set_crc_source``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:759
msgid ""
"Changes the source of CRC checksums of frames at the request of userspace, "
"typically for testing purposes. The sources available are specific of each "
"driver and a ``NULL`` value indicates that CRC generation is to be switched "
"off."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:764
msgid ""
"When CRC generation is enabled, the driver should call "
"drm_crtc_add_crc_entry() at each frame, providing any information that "
"characterizes the frame contents in the crcN arguments, as provided from the "
"configured source. Drivers must accept an \"auto\" source name that will "
"select a default source for this CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:770
msgid ""
"This may trigger an atomic modeset commit if necessary, to enable CRC "
"generation."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:773
msgid ""
"Note that \"auto\" can depend upon the current modeset configuration, e.g. "
"it could pick an encoder or output specific CRC sampling point."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:776
#: include/drm/drm_crtc.h:792
msgid ""
"This callback is optional if the driver does not support any CRC generation "
"functionality."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:787
msgid "``verify_crc_source``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:788
msgid ""
"verifies the source of CRC checksums of frames before setting the source for "
"CRC and during crc open. Source parameter can be NULL while disabling crc "
"source."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:803
msgid "``get_crc_sources``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:804
msgid ""
"Driver callback for getting a list of all the available sources for CRC "
"generation. This callback depends upon verify_crc_source, So "
"verify_crc_source callback should be implemented before implementing this. "
"Driver can pass full list of available crc sources, this callback does the "
"verification on each crc-source before passing it to userspace."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:811
msgid ""
"This callback is optional if the driver does not support exporting of "
"possible CRC sources list."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:816
msgid ""
"a constant character pointer to the list of all the available CRC sources. "
"On failure driver should return NULL. count should be updated with number of "
"sources in list. if zero we don't process any source from the list."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:827
msgid ""
"If driver subclasses :c:type:`struct drm_crtc_state <drm_crtc_state>`, it "
"should implement this optional hook for printing additional driver specific "
"state."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:830
msgid "Do not call this directly, use drm_atomic_crtc_print_state() instead."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:838
msgid "``get_vblank_counter``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:839
msgid ""
"Driver callback for fetching a raw hardware vblank counter for the CRTC. "
"It's meant to be used by new drivers as the replacement of :c:type:"
"`drm_driver.get_vblank_counter <drm_driver>` hook."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:843
msgid ""
"This callback is optional. If a device doesn't have a hardware counter, the "
"driver can simply leave the hook as NULL. The DRM core will account for "
"missed vblank events while interrupts where disabled based on system "
"timestamps."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:848
msgid ""
"Wraparound handling and loss of events due to modesetting is dealt with in "
"the DRM core code, as long as drivers call drm_crtc_vblank_off() and "
"drm_crtc_vblank_on() when disabling or enabling a CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:853
msgid ""
"See also :c:type:`drm_device.vblank_disable_immediate <drm_device>` and :c:"
"type:`drm_device.max_vblank_count <drm_device>`."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:858
msgid "Raw vblank counter value."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:864
msgid "``enable_vblank``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:865
msgid ""
"Enable vblank interrupts for the CRTC. It's meant to be used by new drivers "
"as the replacement of :c:type:`drm_driver.enable_vblank <drm_driver>` hook."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:870
msgid ""
"Zero on success, appropriate errno if the vblank interrupt cannot be enabled."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:877
msgid "``disable_vblank``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:878
msgid ""
"Disable vblank interrupts for the CRTC. It's meant to be used by new drivers "
"as the replacement of :c:type:`drm_driver.disable_vblank <drm_driver>` hook."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:885
msgid "``get_vblank_timestamp``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:886
msgid ""
"Called by drm_get_last_vbltimestamp(). Should return a precise timestamp "
"when the most recent vblank interval ended or will end."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:889
msgid ""
"Specifically, the timestamp in **vblank_time** should correspond as closely "
"as possible to the time when the first video scanline of the video frame "
"after the end of vblank will start scanning out, the time immediately after "
"end of the vblank interval. If the **crtc** is currently inside vblank, this "
"will be a time in the future. If the **crtc** is currently scanning out a "
"frame, this will be the past start time of the current scanout. This is "
"meant to adhere to the OpenML OML_sync_control extension specification."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:898
msgid "Parameters:"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:900
msgid "crtc:"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:901
msgid "CRTC for which timestamp should be returned."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:902
msgid "max_error:"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:903
msgid ""
"Maximum allowable timestamp error in nanoseconds. Implementation should "
"strive to provide timestamp with an error of at most max_error nanoseconds. "
"Returns true upper bound on error for timestamp."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:907
msgid "vblank_time:"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:908
msgid "Target location for returned vblank timestamp."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:909
msgid "in_vblank_irq:"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:910
#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:669
#: drivers/gpu/drm/drm_vblank.c:814
msgid ""
"True when called from drm_crtc_handle_vblank().  Some drivers need to apply "
"some workarounds for gpu-specific vblank irq quirks if flag is set."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:916
msgid ""
"True on success, false on failure, which means the core should fallback to a "
"simple timestamp taken in drm_crtc_handle_vblank()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:392
msgid ""
"The drm_crtc_funcs structure is the central CRTC management structure in the "
"DRM.  Each CRTC controls one or more connectors (note that the name CRTC is "
"simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc. "
"connectors, not just CRTs)."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:397
msgid ""
"Each driver is responsible for filling out this structure at startup time, "
"in addition to providing other modesetting features, like i2c and DDC bus "
"accessors."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:927
msgid "central CRTC control structure"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:934
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1895
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:96
msgid "parent DRM device"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:935
msgid "``port``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:936
msgid "OF node used by drm_of_find_possible_crtcs()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:939
msgid ""
"List of all CRTCs on **dev**, linked from :c:type:`drm_mode_config.crtc_list "
"<drm_mode_config>`. Invariant over the lifetime of **dev** and therefore "
"does not need locking."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:946
#: include/drm/drm_crtc.h:1243 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:646 include/drm/drm_plane.h:846
#: include/drm/drm_plane.h:891 ../../../gpu/drm-kms:419:
#: include/drm/drm_modes.h:399 ../../../gpu/drm-kms:434:
#: include/drm/drm_connector.h:1622 include/drm/drm_connector.h:1930
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:98
#: include/drm/drm_encoder.h:232 include/drm/drm_encoder.h:253
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:35
#: include/drm/drm_property.h:169
msgid "``name``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:947
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:647
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1931
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:99
msgid "human readable name, can be overwritten by the driver"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:951
msgid ""
"This provides a read lock for the overall CRTC state (mode, dpms state, ...) "
"and a write lock for everything which can be update without a full modeset "
"(fb, cursor data, CRTC properties ...). A full modeset also need to grab :c:"
"type:`drm_mode_config.connection_mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:956
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:655
msgid "For atomic drivers specifically this protects **state**."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:962
msgid "base KMS object for ID tracking etc."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:965
#: include/drm/drm_crtc.h:1240
msgid "``primary``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:966
msgid ""
"Primary plane for this CRTC. Note that this is only relevant for legacy "
"IOCTL, it specifies the plane implicitly used by the SETCRTC and PAGE_FLIP "
"IOCTLs. It does not have any significance beyond that."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:974
#: include/drm/drm_crtc.h:1241
msgid "``cursor``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:975
msgid ""
"Cursor plane for this CRTC. Note that this is only relevant for legacy "
"IOCTL, it specifies the plane implicitly used by the SETCURSOR and "
"SETCURSOR2 IOCTLs. It does not have any significance beyond that."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:983
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:719
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1941
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:140
msgid "``index``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:984
msgid ""
"Position inside the mode_config.list, can be used as an array index. It is "
"invariant over the lifetime of the CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:989
msgid "``cursor_x``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:990
msgid ""
"Current x position of the cursor, used for universal cursor planes because "
"the SETCURSOR IOCTL only can update the framebuffer without supplying the "
"coordinates. Drivers should not use this directly, atomic drivers should "
"look at :c:type:`drm_plane_state.crtc_x <drm_plane_state>` of the cursor "
"plane instead."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:997
msgid "``cursor_y``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:998
msgid ""
"Current y position of the cursor, used for universal cursor planes because "
"the SETCURSOR IOCTL only can update the framebuffer without supplying the "
"coordinates. Drivers should not use this directly, atomic drivers should "
"look at :c:type:`drm_plane_state.crtc_y <drm_plane_state>` of the cursor "
"plane instead."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1006
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:233
msgid "``enabled``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1007
msgid ""
"Is this CRTC enabled? Should only be used by legacy drivers, atomic drivers "
"should instead consult :c:type:`drm_crtc_state.enable <drm_crtc_state>` and :"
"c:type:`drm_crtc_state.active <drm_crtc_state>`. Atomic drivers can update "
"this by calling drm_atomic_helper_update_legacy_modeset_state()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1017
msgid ""
"Current mode timings. Should only be used by legacy drivers, atomic drivers "
"should instead consult :c:type:`drm_crtc_state.mode <drm_crtc_state>`. "
"Atomic drivers can update this by calling "
"drm_atomic_helper_update_legacy_modeset_state()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1026
#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:216
msgid "``hwmode``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1027
msgid ""
"Programmed mode in hw, after adjustments for encoders, crtc, panel scaling "
"etc. Should only be used by legacy drivers, for high precision vblank "
"timestamps in drm_crtc_vblank_helper_get_vblank_timestamp()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1032
msgid ""
"Note that atomic drivers should not use this, but instead use :c:type:"
"`drm_crtc_state.adjusted_mode <drm_crtc_state>`. And for high-precision "
"timestamps drm_crtc_vblank_helper_get_vblank_timestamp() used :c:type:"
"`drm_vblank_crtc.hwmode <drm_vblank_crtc>`, which is filled out by calling "
"drm_calc_timestamping_constants()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1042
#: include/drm/drm_crtc.h:1185
msgid "``x``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1043
msgid ""
"x position on screen. Should only be used by legacy drivers, atomic drivers "
"should look at :c:type:`drm_plane_state.crtc_x <drm_plane_state>` of the "
"primary plane instead. Updated by calling "
"drm_atomic_helper_update_legacy_modeset_state()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1050
#: include/drm/drm_crtc.h:1186
msgid "``y``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1051
msgid ""
"y position on screen. Should only be used by legacy drivers, atomic drivers "
"should look at :c:type:`drm_plane_state.crtc_y <drm_plane_state>` of the "
"primary plane instead. Updated by calling "
"drm_atomic_helper_update_legacy_modeset_state()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1059
msgid "CRTC control functions"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1062
msgid "``gamma_size``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1063
msgid ""
"Size of legacy gamma ramp reported to userspace. Set up by calling "
"drm_mode_crtc_set_gamma_size()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1066
#: include/drm/drm_crtc.h:1075
msgid ""
"Note that atomic drivers need to instead use :c:type:`drm_crtc_state."
"gamma_lut <drm_crtc_state>`. See drm_crtc_enable_color_mgmt()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1071
msgid "``gamma_store``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1072
msgid ""
"Gamma ramp values used by the legacy SETGAMMA and GETGAMMA IOCTls. Set up by "
"calling drm_mode_crtc_set_gamma_size()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1083
msgid "property tracking for this CRTC"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1086
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:787
msgid "``scaling_filter_property``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1087
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:788
msgid "property to apply a particular filter while scaling."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1093
msgid "Current atomic state for this CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1095
msgid ""
"This is protected by **mutex**. Note that nonblocking atomic commits access "
"the current CRTC state without taking locks. Either by going through the :c:"
"type:`struct drm_atomic_state <drm_atomic_state>` pointers, see "
"for_each_oldnew_crtc_in_state(), for_each_old_crtc_in_state() and "
"for_each_new_crtc_in_state(). Or through careful ordering of atomic commit "
"operations as implemented in the atomic helpers, see :c:type:`struct "
"drm_crtc_commit <drm_crtc_commit>`."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1107
msgid "``commit_list``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1108
msgid ""
"List of :c:type:`drm_crtc_commit` structures tracking pending commits. "
"Protected by **commit_lock**. This list holds its own full reference, as "
"does the ongoing commit."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1112
msgid ""
"\"Note that the commit for a state change is also tracked in :c:type:"
"`drm_crtc_state.commit <drm_crtc_state>`. For accessing the immediately "
"preceding commit in an atomic update it is recommended to just use that "
"pointer in the old CRTC state, since accessing that doesn't need any locking "
"or list-walking. **commit_list** should only be used to stall for "
"framebuffer cleanup that's signalled through :c:type:`drm_crtc_commit."
"cleanup_done <drm_crtc_commit>`.\""
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1124
msgid "``commit_lock``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1125
msgid "Spinlock to protect **commit_list**."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1131
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2232
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:196
msgid "``debugfs_entry``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1132
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:197
msgid "Debugfs directory for this CRTC."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1138
msgid "``crc``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1139
msgid "Configuration settings of CRC capture."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1145
#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:63
msgid "``fence_context``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1146
#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:64
msgid "timeline context used for fence operations."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1152
#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:69
msgid "``fence_lock``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1153
#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:70
msgid "spinlock to protect the fences in the fence_context."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1158
#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:75
msgid "``fence_seqno``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1159
msgid ""
"Seqno variable used as monotonic counter for the fences created on the "
"CRTC's timeline."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1166
#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:82
msgid "``timeline_name``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1167
msgid "The name of the CRTC's fence timeline."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1173
msgid "``self_refresh_data``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1174
msgid "Holds the state for the self refresh helpers"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1176
msgid "Initialized via drm_self_refresh_helper_init()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:928
msgid ""
"Each CRTC may have one or more connectors associated with it.  This "
"structure allows the CRTC to be controlled."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1181
msgid "new values for a CRTC config change"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1182
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:67
#: include/drm/drm_plane.h:693 ../../../gpu/drm-kms:446:
#: include/drm/drm_writeback.h:123
msgid "``fb``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1183
msgid "framebuffer to use for new config"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1184
msgid "CRTC whose configuration we're about to change"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1185
msgid "mode timings to use"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1186
#: include/drm/drm_crtc.h:1187
msgid "position of this CRTC relative to **fb**"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1188
msgid "array of connectors to drive with this CRTC if possible"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1188
msgid "``num_connectors``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1189
msgid "size of **connectors** array"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1189
msgid ""
"This represents a modeset configuration for the legacy SETCRTC ioctl and is "
"also used internally. Atomic drivers instead use :c:type:`drm_atomic_state`."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1236
msgid ""
"``drmm_crtc_alloc_with_planes (dev, type, member, primary, cursor, funcs, "
"name, ...)``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1234
msgid ""
"Allocate and initialize a new CRTC object with specified primary and cursor "
"planes."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1237
msgid "the type of the struct which contains struct :c:type:`drm_crtc`"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1239
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:838
#: include/drm/drm_plane.h:883 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:229
msgid "``member``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1238
msgid "the name of the :c:type:`drm_crtc` within **type**."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1239
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:316
#: drivers/gpu/drm/drm_crtc.c:400
msgid "Primary plane for CRTC"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1240
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:317
#: drivers/gpu/drm/drm_crtc.c:401
msgid "Cursor plane for CRTC"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1241
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:318
#: drivers/gpu/drm/drm_crtc.c:402
msgid "callbacks for the new CRTC"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1242
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:319
#: drivers/gpu/drm/drm_crtc.c:403
msgid "printf style format string for the CRTC name, or NULL for default name"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1244
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:321
#: drivers/gpu/drm/drm_crtc.c:405 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:847 include/drm/drm_plane.h:892
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:518
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:233
#: include/drm/drm_encoder.h:254 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:150 drivers/gpu/drm/drm_encoder.c:277
msgid "``...``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1 ../../../gpu/drm-kms:321:
#: drivers/gpu/drm/drm_crtc.c:1 ../../../gpu/drm-kms:380:
#: include/drm/drm_plane.h:1 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:1 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:1 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:1
msgid "variable arguments"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1243
msgid ""
"Allocates and initializes a new crtc object. Cleanup is automatically "
"handled through registering drmm_crtc_cleanup() with drmm_add_action()."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1246
#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:414
msgid "The **drm_crtc_funcs.destroy** hook must be NULL."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1249
msgid "Pointer to new crtc, or ERR_PTR on failure."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1259
msgid "find the index of a registered CRTC"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1265
#: include/drm/drm_crtc.h:1277 ../../../gpu/drm-kms:321:
#: drivers/gpu/drm/drm_crtc.c:657
msgid "``const struct drm_crtc *crtc``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1260
msgid "CRTC to find index for"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1261
msgid ""
"Given a registered CRTC, return the index of that CRTC within a DRM device's "
"list of CRTCs."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1271
msgid "find the mask of a registered CRTC"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1272
msgid "CRTC to find mask for"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1273
msgid ""
"Given a registered CRTC, return the mask bit of that CRTC for the :c:type:"
"`drm_encoder.possible_crtcs <drm_encoder>` and :c:type:`drm_plane."
"possible_crtcs <drm_plane>` fields."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1286
msgid "look up a CRTC object from its ID"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1288
#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:916
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:942
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2362
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:305
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:302
msgid "drm file to check for lease against."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1289
msgid ":c:type:`drm_mode_object` ID"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1290
msgid ""
"This can be used to look up a CRTC from its userspace ID. Only used by "
"drivers for legacy IOCTLs and interface, nowadays extensions to the KMS "
"userspace interface should be done using :c:type:`drm_property`."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1307
msgid "``drm_for_each_crtc (crtc, dev)``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1305
msgid "iterate over all CRTCs"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1306
#: include/drm/drm_crtc.h:1316
msgid "a :c:type:`struct drm_crtc <drm_crtc>` as the loop cursor"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1307
#: include/drm/drm_crtc.h:1317
msgid "the :c:type:`struct drm_device <drm_device>`"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1308
#: include/drm/drm_crtc.h:1318
msgid "Iterate over all CRTCs of **dev**."
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1317
msgid "``drm_for_each_crtc_reverse (crtc, dev)``"
msgstr ""

#: ../../../gpu/drm-kms:318: include/drm/drm_crtc.h:1315
msgid "iterate over all CRTCs in reverse order"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:77
msgid "find the registered CRTC at an index"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:80
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:717
msgid "``int idx``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:79
msgid "index of registered CRTC to find for"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:80
msgid ""
"Given a CRTC index, return the registered CRTC from DRM device's list of "
"CRTCs with matching index. This is the inverse of drm_crtc_index(). It's "
"useful in the vblank callbacks (like :c:type:`drm_driver.enable_vblank "
"<drm_driver>` or :c:type:`drm_driver.disable_vblank <drm_driver>`), since "
"that still deals with indices instead of pointers to :c:type:`struct "
"drm_crtc <drm_crtc>`.\""
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:312
#: drivers/gpu/drm/drm_crtc.c:396
msgid "Initialise a new CRTC object with specified primary and cursor planes."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:315
#: drivers/gpu/drm/drm_crtc.c:399
msgid "CRTC object to init"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:317
#: drivers/gpu/drm/drm_crtc.c:401
msgid "``struct drm_plane *primary``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:318
#: drivers/gpu/drm/drm_crtc.c:402
msgid "``struct drm_plane *cursor``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:319
#: drivers/gpu/drm/drm_crtc.c:403
msgid "``const struct drm_crtc_funcs *funcs``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:320
#: drivers/gpu/drm/drm_crtc.c:404 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:517 ../../../gpu/drm-kms:437:
#: drivers/gpu/drm/drm_connector.c:1270 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:149 drivers/gpu/drm/drm_encoder.c:276
#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:87
#: drivers/gpu/drm/drm_property.c:148 drivers/gpu/drm/drm_property.c:195
#: drivers/gpu/drm/drm_property.c:263 drivers/gpu/drm/drm_property.c:291
#: drivers/gpu/drm/drm_property.c:319 drivers/gpu/drm/drm_property.c:358
#: drivers/gpu/drm/drm_property.c:381
msgid "``const char *name``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:320
msgid ""
"Inits a new object created as base part of a driver crtc object. Drivers "
"should use this function instead of drm_crtc_init(), which is only provided "
"for backwards compatibility with drivers which do not yet support universal "
"planes). For really simple hardware which has only 1 plane look at "
"drm_simple_display_pipe_init() instead. The :c:type:`drm_crtc_funcs.destroy "
"<drm_crtc_funcs>` hook should call drm_crtc_cleanup() and kfree() the crtc "
"structure. The crtc structure should not be allocated with devm_kzalloc()."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:329
#: drivers/gpu/drm/drm_crtc.c:416
msgid ""
"The **primary** and **cursor** planes are only relevant for legacy uAPI, "
"see :c:type:`drm_crtc.primary <drm_crtc>` and :c:type:`drm_crtc.cursor "
"<drm_crtc>`."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:332
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:521
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:394
#: drivers/gpu/drm/drm_connector.c:471 drivers/gpu/drm/drm_connector.c:824
#: drivers/gpu/drm/drm_connector.c:921 drivers/gpu/drm/drm_connector.c:2794
#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:155
msgid "**Note**"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:333
msgid ""
"consider using drmm_crtc_alloc_with_planes() or drmm_crtc_init_with_planes() "
"instead of drm_crtc_init_with_planes() to let the DRM managed resource "
"infrastructure take care of cleanup and deallocation."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:404
msgid ""
"Inits a new object created as base part of a driver crtc object. Drivers "
"should use this function instead of drm_crtc_init(), which is only provided "
"for backwards compatibility with drivers which do not yet support universal "
"planes). For really simple hardware which has only 1 plane look at "
"drm_simple_display_pipe_init() instead."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:410
msgid ""
"Cleanup is automatically handled through registering drmm_crtc_cleanup() "
"with drmm_add_action(). The crtc structure should be allocated with "
"drmm_kzalloc()."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:476
msgid "Clean up the core crtc usage"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:477
msgid "CRTC to cleanup"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:478
msgid ""
"This function cleans up **crtc** and removes it from the DRM mode setting "
"core. Note that the function does *not* free the crtc structure itself, this "
"is the responsibility of the caller."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:630
msgid ""
"helper to call :c:type:`drm_mode_config_funcs.set_config "
"<drm_mode_config_funcs>`"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:636
msgid "``struct drm_mode_set *set``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:631
msgid "modeset config to set"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:632
msgid ""
"This is a little helper to wrap internal calls to the :c:type:"
"`drm_mode_config_funcs.set_config <drm_mode_config_funcs>` driver interface. "
"The only thing it adds is correct refcounting dance."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:636
msgid "This should only be used by non-atomic legacy drivers."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:639
#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:205
#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:372
#: drivers/gpu/drm/drm_blend.c:411 ../../../gpu/drm-kms:395:
#: drivers/gpu/drm/drm_damage_helper.c:107 ../../../gpu/drm-kms:437:
#: drivers/gpu/drm/drm_connector.c:657 drivers/gpu/drm/drm_connector.c:2377
#: drivers/gpu/drm/drm_connector.c:2411 drivers/gpu/drm/drm_connector.c:2467
#: drivers/gpu/drm/drm_connector.c:2614 drivers/gpu/drm/drm_connector.c:2639
#: drivers/gpu/drm/drm_connector.c:2663 drivers/gpu/drm/drm_connector.c:2720
#: drivers/gpu/drm/drm_connector.c:2822 drivers/gpu/drm/drm_connector.c:2855
#: drivers/gpu/drm/drm_connector.c:2875 drivers/gpu/drm/drm_connector.c:2909
#: drivers/gpu/drm/drm_connector.c:2989 drivers/gpu/drm/drm_connector.c:3039
#: drivers/gpu/drm/drm_connector.c:3067
msgid "Zero on success, negative errno on failure."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:651
msgid "Checks that a framebuffer is big enough for the CRTC viewport"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:653
msgid "CRTC that framebuffer will be displayed on"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:655
msgid "``int x``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:654
msgid "x panning"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:656
msgid "``int y``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:655
msgid "y panning"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:656
msgid "mode that framebuffer will be displayed under"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:658
#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:253
msgid "``const struct drm_framebuffer *fb``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:657
msgid "framebuffer to check size of"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:913
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1757
msgid "create a new scaling filter property"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:916
msgid "drm CRTC"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:918
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1762
msgid "``unsigned int supported_filters``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:917
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1761
msgid ""
"bitmask of supported scaling filters, must include "
"BIT(DRM_SCALING_FILTER_DEFAULT)."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:919
msgid ""
"This function lets driver to enable the scaling filter property on a given "
"CRTC."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:923
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1767
#: drivers/gpu/drm/drm_plane.c:1796 ../../../gpu/drm-kms:389:
#: drivers/gpu/drm/drm_blend.c:574
msgid "Zero for success or -errno"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:944
msgid "check if the given CRTC state is in clone mode"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:950
msgid "``struct drm_crtc_state *crtc_state``"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:946
msgid "CRTC state to check"
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:947
msgid ""
"This function determines if the given CRTC state is being cloned by multiple "
"encoders."
msgstr ""

#: ../../../gpu/drm-kms:321: drivers/gpu/drm/drm_crtc.c:951
msgid "True if the CRTC state is in clone mode. False otherwise"
msgstr ""

#: ../../../gpu/drm-kms.rst:325
msgid "Color Management Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:124
msgid "``u64 user_input``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:120
#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:35
msgid "input value"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:122
msgid "``u32 m``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:121
msgid "number of integer bits, only support m <= 32, include the sign-bit"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:123
msgid "``u32 n``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:122
msgid "number of fractional bits, only support n <= 32"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:119
msgid ""
"Convert and clamp S31.32 sign-magnitude to Qm.n (signed 2's complement). The "
"sign-bit BIT(m+n-1) and above are 0 for positive value and 1 for negative "
"the range of value is [-2^(m-1), 2^(m-1) - 2^-n]"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:123
msgid ""
"For example A Q3.12 format number: - required bit: 3 + 12 = 15bits - range: "
"[-2^2, 2^2 - 2^−15]"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:133
msgid "the m can be zero if all bit_precision are used to present fractional"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:134
msgid "bits like Q0.32"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:152
msgid "enable color management properties"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:155
msgid "``uint degamma_lut_size``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:154
msgid "the size of the degamma lut (before CSC)"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:156
msgid "``bool has_ctm``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:155
msgid "whether to attach ctm_property for CSC matrix"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:157
msgid "``uint gamma_lut_size``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:156
msgid "the size of the gamma lut (after CSC)"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:157
msgid ""
"This function lets the driver enable the color correction properties on a "
"CRTC. This includes 3 degamma, csc and gamma properties that userspace can "
"set and 2 size properties to inform the userspace of the lut sizes. Each of "
"the properties are optional. The gamma and degamma properties are only "
"attached if their size is not 0 and ctm_property is only attached if has_ctm "
"is true."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:197
msgid "set the gamma table size"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:198
msgid "CRTC to set the gamma table size for"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:200
msgid "``int gamma_size``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:199
msgid "size of the gamma table"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:200
msgid ""
"Drivers which support gamma tables should set this to the supported gamma "
"table size when initializing the CRTC. Currently the drm core only supports "
"a fixed gamma table size."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:518
msgid "color encoding related plane properties"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:519
msgid "plane object"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:521
msgid "``u32 supported_encodings``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:520
msgid "bitfield indicating supported color encodings"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:522
msgid "``u32 supported_ranges``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:521
msgid "bitfileld indicating supported color ranges"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:523
msgid "``enum drm_color_encoding default_encoding``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:522
msgid "default color encoding"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:524
msgid "``enum drm_color_range default_range``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:523
msgid "default color range"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:524
msgid ""
"Create and attach plane specific COLOR_ENCODING and COLOR_RANGE properties "
"to **plane**. The supported encodings and ranges should be provided in "
"supported_encodings and supported_ranges bitmasks. Each bit set in the "
"bitmask indicates that its number as enum value is supported."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:596
msgid "check validity of lookup table"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:602
msgid "``const struct drm_property_blob *lut``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:597
msgid "property blob containing LUT to check"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:599
msgid "``u32 tests``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:598
msgid "bitmask of tests to run"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:599
msgid ""
"Helper to check whether a userspace-provided lookup table is valid and "
"satisfies hardware requirements.  Drivers pass a bitmask indicating which of "
"the tests in :c:type:`drm_color_lut_tests` should be performed."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:603
msgid "Returns 0 on success, -EINVAL on failure."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:643
msgid "Programs gamma ramp for RGB888-like formats"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:644
#: drivers/gpu/drm/drm_color_mgmt.c:663 drivers/gpu/drm/drm_color_mgmt.c:693
#: drivers/gpu/drm/drm_color_mgmt.c:728 drivers/gpu/drm/drm_color_mgmt.c:754
#: drivers/gpu/drm/drm_color_mgmt.c:783 drivers/gpu/drm/drm_color_mgmt.c:803
#: drivers/gpu/drm/drm_color_mgmt.c:830
msgid "The displaying CRTC"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:646
#: drivers/gpu/drm/drm_color_mgmt.c:665 drivers/gpu/drm/drm_color_mgmt.c:695
#: drivers/gpu/drm/drm_color_mgmt.c:805
msgid "``const struct drm_color_lut *lut``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:645
#: drivers/gpu/drm/drm_color_mgmt.c:664 drivers/gpu/drm/drm_color_mgmt.c:694
msgid "The gamma ramp to program"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:647
#: drivers/gpu/drm/drm_color_mgmt.c:666 drivers/gpu/drm/drm_color_mgmt.c:696
#: drivers/gpu/drm/drm_color_mgmt.c:730 drivers/gpu/drm/drm_color_mgmt.c:756
#: drivers/gpu/drm/drm_color_mgmt.c:785
msgid "``drm_crtc_set_lut_func set_gamma``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:646
#: drivers/gpu/drm/drm_color_mgmt.c:665 drivers/gpu/drm/drm_color_mgmt.c:695
#: drivers/gpu/drm/drm_color_mgmt.c:729 drivers/gpu/drm/drm_color_mgmt.c:755
#: drivers/gpu/drm/drm_color_mgmt.c:784 drivers/gpu/drm/drm_color_mgmt.c:831
msgid "Callback for programming the hardware gamma LUT"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:647
msgid ""
"Programs the gamma ramp specified in **lut** to hardware. The input gamma "
"ramp must have 256 entries per color component."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:662
msgid "Programs gamma ramp for RGB565-like formats"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:666
msgid ""
"Programs the gamma ramp specified in **lut** to hardware. The input gamma "
"ramp must have 256 entries per color component. The helper interpolates the "
"individual color components to reduce the number of entries to 5/6/5."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:692
msgid "Programs gamma ramp for RGB555-like formats"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:696
msgid ""
"Programs the gamma ramp specified in **lut** to hardware. The input gamma "
"ramp must have 256 entries per color component. The helper interpolates the "
"individual color components to reduce the number of entries to 5/5/5."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:727
msgid "Programs a default gamma ramp for RGB888-like formats"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:730
#: drivers/gpu/drm/drm_color_mgmt.c:756 drivers/gpu/drm/drm_color_mgmt.c:785
msgid "Programs a default gamma ramp to hardware."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:753
msgid "Programs a default gamma ramp for RGB565-like formats"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:782
msgid "Programs a default gamma ramp for RGB555-like formats"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:802
msgid "Programs palette for C8-like formats"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:804
msgid "The palette to program"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:806
#: drivers/gpu/drm/drm_color_mgmt.c:832
msgid "``drm_crtc_set_lut_func set_palette``"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:805
msgid "Callback for programming the hardware palette"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:806
msgid ""
"Programs the palette specified in **lut** to hardware. The input palette "
"must have 256 entries per color component."
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:829
msgid "Programs a default palette for C8-like formats"
msgstr ""

#: ../../../gpu/drm-kms:327: drivers/gpu/drm/drm_color_mgmt.c:832
msgid "Programs a default palette to hardware."
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:34
msgid "clamp and round LUT entries"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:40
msgid "``u32 user_input``"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:37
msgid "``int bit_precision``"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:36
msgid "number of bits the hw LUT supports"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:37
msgid ""
"Extract a degamma/gamma LUT value provided by user (in the form of :c:type:"
"`drm_color_lut` entries) and round it to the precision supported by the "
"hardware, following OpenGL int<->float conversion rules (see eg. OpenGL 4.6 "
"specification - 2.3.5 Fixed-Point Data Conversions)."
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:64
msgid "calculate the number of entries in the LUT"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:70
msgid "``const struct drm_property_blob *blob``"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:65
msgid "blob containing the LUT"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:67
msgid "The number of entries in the color LUT stored in **blob**."
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:95
msgid "hw-specific LUT tests to perform"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:99
#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:576
#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:50
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:66
#: include/drm/drm_connector.h:99 include/drm/drm_connector.h:156
#: include/drm/drm_connector.h:342 include/drm/drm_connector.h:358
#: include/drm/drm_connector.h:387 include/drm/drm_connector.h:446
#: include/drm/drm_connector.h:470 include/drm/drm_connector.h:564
msgid "**Constants**"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:101
msgid "``DRM_COLOR_LUT_EQUAL_CHANNELS``"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:102
msgid ""
"Checks whether the entries of a LUT all have equal values for the red, "
"green, and blue channels.  Intended for hardware that only accepts a single "
"value per LUT entry and assumes that value applies to all three color "
"components."
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:107
msgid "``DRM_COLOR_LUT_NON_DECREASING``"
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:108
msgid ""
"Checks whether the entries of a LUT are always flat or increasing (never "
"decreasing)."
msgstr ""

#: ../../../gpu/drm-kms:330: include/drm/drm_color_mgmt.h:96
msgid ""
"The drm_color_lut_check() function takes a bitmask of the values here to "
"determine which tests to apply to a userspace-provided LUT."
msgstr ""

#: ../../../gpu/drm-kms.rst:334
msgid "Frame Buffer Abstraction"
msgstr ""

#: ../../../gpu/drm-kms:336: drivers/gpu/drm/drm_framebuffer.c:42
msgid ""
"Frame buffers are abstract memory objects that provide a source of pixels to "
"scanout to a CRTC. Applications explicitly request the creation of frame "
"buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and receive an opaque "
"handle that can be passed to the KMS CRTC control, plane configuration and "
"page flip functions."
msgstr ""

#: ../../../gpu/drm-kms:336: drivers/gpu/drm/drm_framebuffer.c:48
msgid ""
"Frame buffers rely on the underlying memory manager for allocating backing "
"storage. When creating a frame buffer applications pass a memory handle (or "
"a list of memory handles for multi-planar formats) through the :c:type:"
"`struct drm_mode_fb_cmd2 <drm_mode_fb_cmd2>` argument. For drivers using GEM "
"as their userspace buffer management interface this would be a GEM handle.  "
"Drivers are however free to use their own backing storage object handles, e."
"g. vmwgfx directly exposes special TTM handles to userspace and so expects "
"TTM handles in the create ioctl and not GEM handles."
msgstr ""

#: ../../../gpu/drm-kms:336: drivers/gpu/drm/drm_framebuffer.c:57
msgid ""
"Framebuffers are tracked with :c:type:`struct drm_framebuffer "
"<drm_framebuffer>`. They are published using drm_framebuffer_init() - after "
"calling that function userspace can use and access the framebuffer object. "
"The helper function drm_helper_mode_fill_fb_struct() can be used to pre-fill "
"the required metadata fields."
msgstr ""

#: ../../../gpu/drm-kms:336: drivers/gpu/drm/drm_framebuffer.c:63
msgid ""
"The lifetime of a drm framebuffer is controlled with a reference count, "
"drivers can grab additional references with drm_framebuffer_get() and drop "
"them again with drm_framebuffer_put(). For driver-private framebuffers for "
"which the last reference is never dropped (e.g. for the fbdev framebuffer "
"when the struct :c:type:`struct drm_framebuffer <drm_framebuffer>` is "
"embedded into the fbdev helper struct) drivers can manually clean up a "
"framebuffer at module unload time with drm_framebuffer_unregister_private(). "
"But doing this is not recommended, and it's better to have a normal free-"
"standing :c:type:`struct drm_framebuffer <drm_framebuffer>`."
msgstr ""

#: ../../../gpu/drm-kms.rst:340
msgid "Frame Buffer Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:41
msgid "framebuffer hooks"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:46
msgid ""
"Clean up framebuffer resources, specifically also unreference the backing "
"storage. The core guarantees to call this function for every framebuffer "
"successfully created by calling :c:type:`drm_mode_config_funcs.fb_create "
"<drm_mode_config_funcs>`. Drivers must also call drm_framebuffer_cleanup() "
"to release DRM core resources for this framebuffer."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:57
msgid "``create_handle``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:58
msgid ""
"Create a buffer handle in the driver-specific buffer manager (either GEM or "
"TTM) valid for the passed-in :c:type:`struct drm_file <drm_file>`. This is "
"used by the core to implement the GETFB IOCTL, which returns (for "
"sufficiently priviledged user) also a native buffer handle. This can be used "
"for seamless transitions between modesetting clients by copying the current "
"screen contents to a private buffer and blending between that and the new "
"contents."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:66
msgid ""
"GEM based drivers should call drm_gem_handle_create() to create the handle."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:78
msgid "``dirty``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:79
msgid "Optional callback for the dirty fb IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:81
msgid ""
"Userspace can notify the driver via this callback that an area of the "
"framebuffer has changed and should be flushed to the display hardware. This "
"can also be used internally, e.g. by the fbdev emulation, though that's not "
"the case currently."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:86
msgid ""
"See documentation in drm_mode.h for the struct drm_mode_fb_dirty_cmd for "
"more information as all the semantics and arguments have a one to one "
"mapping on this function."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:90
msgid ""
"Atomic drivers should use drm_atomic_helper_dirtyfb() to implement this hook."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:107
msgid "frame buffer object"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:123
msgid "DRM device this framebuffer belongs to"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:127
msgid ""
"Place on the :c:type:`drm_mode_config.fb_list <drm_mode_config>`, access "
"protected by :c:type:`drm_mode_config.fb_lock <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:133
msgid "base modeset object structure, contains the reference count."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:137
msgid "``comm``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:138
msgid "Name of the process allocating the fb, used for fb dumping."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:143
msgid "framebuffer format information"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:147
msgid "framebuffer vfunc table"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:150
msgid "``pitches``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:151
msgid ""
"Line stride per buffer. For userspace created object this is copied from "
"drm_mode_fb_cmd2."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:155
msgid "``offsets``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:156
msgid ""
"Offset from buffer start to the actual pixel data in bytes, per buffer. For "
"userspace created object this is copied from drm_mode_fb_cmd2."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:160
msgid ""
"Note that this is a linear offset and does not take into account tiling or "
"buffer layout per **modifier**. It is meant to be used when the actual pixel "
"data for this framebuffer plane starts at an offset, e.g. when multiple "
"planes are allocated within the same backing storage buffer object. For "
"tiled layouts this generally means its **offsets** must at least be tile-"
"size aligned, but hardware often has stricter requirements."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:168
msgid ""
"This should not be used to specifiy x/y pixel offsets into the buffer data "
"(even for linear buffers). Specifying an x/y pixel offset is instead done "
"through the source rectangle in :c:type:`struct drm_plane_state "
"<drm_plane_state>`."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:173
msgid "``modifier``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:174
msgid ""
"Data layout modifier. This is used to describe tiling, or also special "
"layouts (like compression) of auxiliary buffers. For userspace created "
"object this is copied from drm_mode_fb_cmd2."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:180
#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:53
msgid "``width``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:181
msgid "Logical width of the visible area of the framebuffer, in pixels."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:185
#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:58
msgid "``height``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:186
msgid "Logical height of the visible area of the framebuffer, in pixels."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:191
msgid "Framebuffer flags like DRM_MODE_FB_INTERLACED or DRM_MODE_FB_MODIFIERS."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:195
msgid "``internal_flags``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:196
msgid "Framebuffer flags like DRM_FRAMEBUFFER_HAS_HANDLE_REF."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:199
msgid "``filp_head``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:200
msgid ""
"Placed on :c:type:`drm_file.fbs <drm_file>`, protected by :c:type:`drm_file."
"fbs_lock <drm_file>`."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:204
msgid "GEM objects backing the framebuffer, one per plane (optional)."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:206
msgid ""
"This is used by the GEM framebuffer helpers, see e.g. drm_gem_fb_create()."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:108
msgid ""
"Note that the fb is refcounted for the benefit of driver internals, for "
"example some hw, disabling a CRTC/plane is asynchronous, and scanout does "
"not actually complete until the next vblank.  So some cleanup (like "
"releasing the reference(s) on the backing GEM bo(s)) should be deferred.  In "
"cases like this, the driver would like to hold a ref to the fb even though "
"it has already been removed from userspace perspective. See "
"drm_framebuffer_get() and drm_framebuffer_put()."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:117
msgid "The refcount is stored inside the mode object **base**."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:224
msgid "acquire a framebuffer reference"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:225
#: include/drm/drm_framebuffer.h:236
msgid "DRM framebuffer"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:226
msgid "This function increments the framebuffer's reference count."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:235
msgid "release a framebuffer reference"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:237
msgid ""
"This function decrements the framebuffer's reference count and frees the "
"framebuffer if the reference count drops to zero."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:247
msgid "read the framebuffer reference count."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:248
msgid "framebuffer"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:249
msgid "This functions returns the framebuffer's reference count."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:258
msgid "store a reference to the fb"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:264
msgid "``struct drm_framebuffer **p``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:259
msgid "location to store framebuffer"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:260
msgid "new framebuffer (maybe NULL)"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:261
msgid ""
"This functions sets the location to store a reference to the framebuffer, "
"unreferencing the framebuffer that was previously stored in that location."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:291
msgid "a special afbc frame buffer object"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:298
msgid "base framebuffer structure."
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:301
msgid "``block_width``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:302
msgid "width of a single afbc block"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:305
msgid "``block_height``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:306
msgid "height of a single afbc block"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:309
msgid "``aligned_width``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:310
msgid "aligned frame buffer width"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:313
msgid "``aligned_height``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:314
msgid "aligned frame buffer height"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:317
msgid "``offset``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:318
msgid "offset of the first afbc header"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:321
msgid "``afbc_size``"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:322
msgid "minimum size of afbc buffer"
msgstr ""

#: ../../../gpu/drm-kms:342: include/drm/drm_framebuffer.h:292
msgid ""
"A derived class of struct drm_framebuffer, dedicated for afbc use cases."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:846
msgid "initialize a framebuffer"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:848
msgid "framebuffer to be initialized"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:850
msgid "``const struct drm_framebuffer_funcs *funcs``"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:849
msgid "... with these functions"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:850
msgid ""
"Allocates an ID for the framebuffer's parent mode object, sets its mode "
"functions & device file and adds it to the master fd list."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:853
msgid ""
"IMPORTANT: This functions publishes the fb and makes it available for "
"concurrent access by other users. Which means by this point the fb _must_ be "
"fully set up - since all the fb attributes are invariant over its lifetime, "
"no further locking but only correct reference counting is required."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:914
msgid "look up a drm framebuffer and grab a reference"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:917
msgid "id of the fb object"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:918
msgid ""
"If successful, this grabs an additional reference to the framebuffer - "
"callers need to make sure to eventually unreference the returned framebuffer "
"again, using drm_framebuffer_put()."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:938
msgid "unregister a private fb from the lookup idr"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:939
msgid "fb to unregister"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:940
msgid ""
"Drivers need to call this when cleaning up driver-private framebuffers, e.g. "
"those used for fbdev. Note that the caller must hold a reference of its own, "
"i.e. the object may not be destroyed through this call (since it'll lead to "
"a locking inversion)."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:946
msgid ""
"This function is deprecated. For driver-private framebuffers it is not "
"recommended to embed a framebuffer struct info fbdev struct, instead, a "
"framebuffer pointer is preferred and drm_framebuffer_put() should be called "
"when the framebuffer is to be cleaned up."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:966
msgid "remove a framebuffer object"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:967
#: drivers/gpu/drm/drm_framebuffer.c:1136
msgid "framebuffer to remove"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:968
msgid ""
"Cleanup framebuffer. This function is intended to be used from the drivers :"
"c:type:`drm_framebuffer_funcs.destroy <drm_framebuffer_funcs>` callback. It "
"can also be used to clean up driver private framebuffers embedded into a "
"larger structure."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:972
msgid ""
"Note that this function does not remove the fb from active usage - if it is "
"still used anywhere, hilarity can ensue since userspace could call getfb on "
"the id and get back -EINVAL. Obviously no concern at driver unload time."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:976
msgid ""
"Also, the framebuffer will not be removed from the lookup idr - for user-"
"created framebuffers this will happen in the rmfb ioctl. For driver-private "
"objects (e.g. for fbdev) drivers need to explicitly call "
"drm_framebuffer_unregister_private."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:1135
msgid "remove and unreference a framebuffer object"
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:1137
msgid ""
"Scans all the CRTCs and planes in **dev**'s mode_config.  If they're using "
"**fb**, removes it, setting it to NULL. Then drops the reference to the "
"passed-in framebuffer. Might take the modeset locks."
msgstr ""

#: ../../../gpu/drm-kms:345: drivers/gpu/drm/drm_framebuffer.c:1141
msgid ""
"Note that this function optimizes the cleanup away if the caller holds the "
"last reference to the framebuffer. It is also guaranteed to not take the "
"modeset locks in this case."
msgstr ""

#: ../../../gpu/drm-kms.rst:349
msgid "DRM Format Handling"
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:34
msgid ""
"In the DRM subsystem, framebuffer pixel formats are described using the "
"fourcc codes defined in `include/uapi/drm/drm_fourcc.h`. In addition to the "
"fourcc code, a Format Modifier may optionally be provided, in order to "
"further describe the buffer's format - for example tiling or compression."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:42
msgid ""
"Format modifiers are used in conjunction with a fourcc code, forming a "
"unique fourcc:modifier pair. This format:modifier pair must fully define the "
"format and data layout of the buffer, and should be the only way to describe "
"that particular buffer."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:47
msgid ""
"Having multiple fourcc:modifier pairs which describe the same layout should "
"be avoided, as such aliases run the risk of different drivers exposing "
"different names for the same data format, forcing userspace to understand "
"that they are aliases."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:52
msgid ""
"Format modifiers may change any property of the buffer, including the number "
"of planes and/or the required allocation size. Format modifiers are vendor-"
"namespaced, and as such the relationship between a fourcc code and a "
"modifier is specific to the modifier being used. For example, some modifiers "
"may preserve meaning - such as number of planes - from the fourcc code, "
"whereas others may not."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:59
msgid ""
"Modifiers must uniquely encode buffer layout. In other words, a buffer must "
"match only a single modifier. A modifier must not be a subset of layouts of "
"another modifier. For instance, it's incorrect to encode pitch alignment in "
"a modifier: a buffer may match a 64-pixel aligned modifier and a 32-pixel "
"aligned modifier. That said, modifiers can have implicit minimal "
"requirements."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:66
msgid ""
"For modifiers where the combination of fourcc code and modifier can alias, a "
"canonical pair needs to be defined and used by all drivers. Preferred "
"combinations are also encouraged where all combinations might lead to "
"confusion and unnecessarily reduced interoperability. An example for the "
"latter is AFBC, where the ABGR layouts are preferred over ARGB layouts."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:72
msgid "There are two kinds of modifier users:"
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:74
msgid ""
"Kernel and user-space drivers: for drivers it's important that modifiers "
"don't alias, otherwise two drivers might support the same format but use "
"different aliases, preventing them from sharing buffers in an efficient "
"format."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:78
msgid ""
"Higher-level programs interfacing with KMS/GBM/EGL/Vulkan/etc: these users "
"see modifiers as opaque tokens they can check for equality and intersect. "
"These users mustn't need to know to reason about the modifier value (i.e. "
"they are not expected to extract information out of the modifier)."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:83
msgid ""
"Vendors should document their modifier usage in as much detail as possible, "
"to ensure maximum compatibility across devices, drivers and applications."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:87
msgid ""
"The authoritative list of format modifier codes is found in `include/uapi/"
"drm/drm_fourcc.h`"
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:93
msgid ""
"Because this is the authoritative source for pixel formats and modifiers "
"referenced by GL, Vulkan extensions and other standards and hence used both "
"by open source and closed source driver stacks, the usual requirement for an "
"upstream in-kernel or open source userspace user does not apply."
msgstr ""

#: ../../../gpu/drm-kms:351: include/uapi/drm/drm_fourcc.h:98
msgid ""
"To ensure, as much as feasible, compatibility across stacks and avoid "
"confusion with incompatible enumerations stakeholders for all relevant "
"driver stacks should approve additions."
msgstr ""

#: ../../../gpu/drm-kms.rst:355
msgid "Format Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:32
msgid "``DRM_FORMAT_MAX_PLANES``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:30
msgid "maximum number of planes a DRM format can have"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:59
msgid "information about a DRM format"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:63
msgid "4CC format identifier (DRM_FORMAT_*)"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:66
msgid "``depth``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:67
msgid ""
"Color depth (number of bits per pixel excluding padding bits), valid for a "
"subset of RGB formats only. This is a legacy field, do not use in new code "
"and set to 0 for new formats."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:74
msgid "``num_planes``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:75
msgid "Number of color planes (1 to 3)"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:2
msgid "anonymous"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:79
msgid "``cpp``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:80
msgid ""
"Number of bytes per pixel (per plane), this is aliased with "
"**char_per_block**. It is deprecated in favour of using the triplet "
"**char_per_block**, **block_w**, **block_h** for better describing the pixel "
"format."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:89
msgid "``char_per_block``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:90
msgid ""
"Number of bytes per block (per plane), where blocks are defined as a "
"rectangle of pixels which are stored next to each other in a byte aligned "
"memory region. Together with **block_w** and **block_h** this is used to "
"properly describe tiles in tiled formats or to describe groups of pixels in "
"packed formats for which the memory needed for a single pixel is not byte "
"aligned."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:98
msgid ""
"**cpp** has been kept for historical reasons because there are a lot of "
"places in drivers where it's used. In drm core for generic code paths the "
"preferred way is to use **char_per_block**, drm_format_info_block_width() "
"and drm_format_info_block_height() which allows handling both block and non-"
"block formats in the same way."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:105
msgid ""
"For formats that are intended to be used only with non-linear modifiers both "
"**cpp** and **char_per_block** must be 0 in the generic format table. "
"Drivers could supply accurate information from their drm_mode_config."
"get_format_info hook if they want the core to be validating the pitch."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:116
msgid "``block_w``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:117
msgid ""
"Block width in pixels, this is intended to be accessed through "
"drm_format_info_block_width()"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:124
msgid "``block_h``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:125
msgid ""
"Block height in pixels, this is intended to be accessed through "
"drm_format_info_block_height()"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:131
msgid "``hsub``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:132
msgid "Horizontal chroma subsampling factor"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:133
msgid "``vsub``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:134
msgid "Vertical chroma subsampling factor"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:136
msgid "``has_alpha``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:137
msgid "Does the format embeds an alpha component?"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:139
msgid "``is_yuv``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:140
msgid "Is it a YUV format?"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:142
msgid "``is_color_indexed``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:143
msgid "Is it a color-indexed format?"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:147
msgid ""
"check that the format info matches a YUV format with data laid in a single "
"plane"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:153
#: include/drm/drm_fourcc.h:167 include/drm/drm_fourcc.h:181
#: include/drm/drm_fourcc.h:195 include/drm/drm_fourcc.h:210
#: include/drm/drm_fourcc.h:225 include/drm/drm_fourcc.h:240
#: include/drm/drm_fourcc.h:255 include/drm/drm_fourcc.h:270
#: include/drm/drm_fourcc.h:292 ../../../gpu/drm-kms:360:
#: drivers/gpu/drm/drm_fourcc.c:451 drivers/gpu/drm/drm_fourcc.c:471
#: drivers/gpu/drm/drm_fourcc.c:491 drivers/gpu/drm/drm_fourcc.c:510
msgid "``const struct drm_format_info *info``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:149
#: include/drm/drm_fourcc.h:163 include/drm/drm_fourcc.h:177
#: include/drm/drm_fourcc.h:191 include/drm/drm_fourcc.h:206
#: include/drm/drm_fourcc.h:221 include/drm/drm_fourcc.h:236
#: include/drm/drm_fourcc.h:251
msgid "format info"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:151
msgid ""
"A boolean indicating whether the format info matches a packed YUV format."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:161
msgid ""
"check that the format info matches a YUV format with data laid in two planes "
"(luminance and chrominance)"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:165
msgid ""
"A boolean indicating whether the format info matches a semiplanar YUV format."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:175
msgid ""
"check that the format info matches a YUV format with data laid in three "
"planes (one for each YUV component)"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:179
msgid ""
"A boolean indicating whether the format info matches a planar YUV format."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:189
msgid "check that the format info matches a YUV format with 4:1:0 sub-sampling"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:193
msgid ""
"A boolean indicating whether the format info matches a YUV format with 4:1:0 "
"sub-sampling."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:204
msgid "check that the format info matches a YUV format with 4:1:1 sub-sampling"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:208
msgid ""
"A boolean indicating whether the format info matches a YUV format with 4:1:1 "
"sub-sampling."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:219
msgid "check that the format info matches a YUV format with 4:2:0 sub-sampling"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:223
msgid ""
"A boolean indicating whether the format info matches a YUV format with 4:2:0 "
"sub-sampling."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:234
msgid "check that the format info matches a YUV format with 4:2:2 sub-sampling"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:238
msgid ""
"A boolean indicating whether the format info matches a YUV format with 4:2:2 "
"sub-sampling."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:249
msgid "check that the format info matches a YUV format with 4:4:4 sub-sampling"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:253
msgid ""
"A boolean indicating whether the format info matches a YUV format with 4:4:4 "
"sub-sampling."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:264
msgid "width of the plane given the first plane"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:265
#: include/drm/drm_fourcc.h:287 ../../../gpu/drm-kms:360:
#: drivers/gpu/drm/drm_fourcc.c:446 drivers/gpu/drm/drm_fourcc.c:466
#: drivers/gpu/drm/drm_fourcc.c:486 drivers/gpu/drm/drm_fourcc.c:505
msgid "pixel format info"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:267
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3034
msgid "``int width``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:266
msgid "width of the first plane"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:268
#: include/drm/drm_fourcc.h:290 ../../../gpu/drm-kms:360:
#: drivers/gpu/drm/drm_fourcc.c:448 drivers/gpu/drm/drm_fourcc.c:468
#: drivers/gpu/drm/drm_fourcc.c:488 drivers/gpu/drm/drm_fourcc.c:507
msgid "``int plane``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:267
#: include/drm/drm_fourcc.h:289 ../../../gpu/drm-kms:360:
#: drivers/gpu/drm/drm_fourcc.c:447 drivers/gpu/drm/drm_fourcc.c:467
#: drivers/gpu/drm/drm_fourcc.c:487 drivers/gpu/drm/drm_fourcc.c:506
msgid "plane index"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:269
msgid ""
"The width of **plane**, given that the width of the first plane is **width**."
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:286
msgid "height of the plane given the first plane"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:289
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3035
msgid "``int height``"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:288
msgid "height of the first plane"
msgstr ""

#: ../../../gpu/drm-kms:357: include/drm/drm_fourcc.h:291
msgid ""
"The height of **plane**, given that the height of the first plane is "
"**height**."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:34
#: drivers/gpu/drm/drm_fourcc.c:108
msgid "compute drm fourcc code from legacy description"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:40
#: drivers/gpu/drm/drm_fourcc.c:111
msgid "``uint32_t bpp``"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:35
#: drivers/gpu/drm/drm_fourcc.c:110
msgid "bits per pixels"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:37
#: drivers/gpu/drm/drm_fourcc.c:112
msgid "``uint32_t depth``"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:36
#: drivers/gpu/drm/drm_fourcc.c:111
msgid "bit depth per pixel"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:37
msgid ""
"Computes a drm fourcc pixel format code for the given **bpp**/**depth** "
"values."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:112
msgid ""
"Computes a drm fourcc pixel format code for the given **bpp**/**depth** "
"values. Unlike drm_mode_legacy_fb_format() this looks at the drivers "
"mode_config, and depending on the :c:type:`drm_mode_config."
"quirk_addfb_prefer_host_byte_order <drm_mode_config>` flag it returns little "
"endian byte order or host byte order framebuffer formats."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:143
msgid "Compute DRM 4CC code from color mode"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:146
msgid "``unsigned int color_mode``"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:145
msgid "command-line color mode"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:146
msgid ""
"Computes a DRM 4CC pixel format code for the given color mode using "
"drm_driver_color_mode(). The color mode is in the format used and the kernel "
"command line. It specifies the number of bits per pixel and color depth in a "
"single value."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:151
msgid ""
"Useful in fbdev emulation code, since that deals in those values. The helper "
"does not consider YUV or other complicated formats. This means only legacy "
"formats are supported (fmt->depth is a legacy field), but the framebuffer "
"emulation can only deal with such formats, specifically RGB/BGA formats."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:397
msgid "query information for a given format"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:403
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:911
#: drivers/gpu/drm/drm_plane.c:991
msgid "``u32 format``"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:398
#: drivers/gpu/drm/drm_fourcc.c:420 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:910 drivers/gpu/drm/drm_plane.c:990
msgid "pixel format (DRM_FORMAT_*)"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:399
msgid ""
"The caller should only pass a supported pixel format to this function. "
"Unsupported pixel formats will generate a warning in the kernel log."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:403
#: drivers/gpu/drm/drm_fourcc.c:423
msgid ""
"The instance of struct drm_format_info that describes the pixel format, or "
"NULL if the format is unsupported."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:418
msgid "query information for a given framebuffer configuration"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:421
msgid "``u32 pixel_format``"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:422
#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:912
#: drivers/gpu/drm/drm_plane.c:992
msgid "``u64 modifier``"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:421
msgid "modifier"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:445
msgid "width in pixels of block."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:449
msgid "The width in pixels of a block, depending on the plane index."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:465
msgid "height in pixels of a block"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:469
msgid "The height in pixels of a block, depending on the plane index."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:485
msgid "number of bits per pixel"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:489
msgid "The actual number of bits per pixel, depending on the plane index."
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:504
msgid "computes the minimum required pitch in bytes"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:508
msgid "``unsigned int buffer_width``"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:507
msgid "buffer width in pixels"
msgstr ""

#: ../../../gpu/drm-kms:360: drivers/gpu/drm/drm_fourcc.c:509
msgid ""
"The minimum required pitch in bytes for a buffer by taking into "
"consideration the pixel format information and the buffer width."
msgstr ""

#: ../../../gpu/drm-kms.rst:366
msgid "Dumb Buffer Objects"
msgstr ""

#: ../../../gpu/drm-kms:368: drivers/gpu/drm/drm_dumb_buffers.c:35
msgid ""
"The KMS API doesn't standardize backing storage object creation and leaves "
"it to driver-specific ioctls. Furthermore actually creating a buffer object "
"even for GEM-based drivers is done through a driver-specific ioctl - GEM "
"only has a common userspace interface for sharing and destroying objects. "
"While not an issue for full-fledged graphics stacks that include device-"
"specific userspace components (in libdrm for instance), this limit makes DRM-"
"based early boot graphics unnecessarily complex."
msgstr ""

#: ../../../gpu/drm-kms:368: drivers/gpu/drm/drm_dumb_buffers.c:43
msgid ""
"Dumb objects partly alleviate the problem by providing a standard API to "
"create dumb buffers suitable for scanout, which can then be used to create "
"KMS frame buffers."
msgstr ""

#: ../../../gpu/drm-kms:368: drivers/gpu/drm/drm_dumb_buffers.c:47
msgid ""
"To support dumb objects drivers must implement the :c:type:`drm_driver."
"dumb_create <drm_driver>` and :c:type:`drm_driver.dumb_map_offset "
"<drm_driver>` operations (the latter defaults to drm_gem_dumb_map_offset() "
"if not set). Drivers that don't use GEM handles additionally need to "
"implement the :c:type:`drm_driver.dumb_destroy <drm_driver>` operation. See "
"the callbacks for further details."
msgstr ""

#: ../../../gpu/drm-kms:368: drivers/gpu/drm/drm_dumb_buffers.c:53
msgid ""
"Note that dumb objects may not be used for gpu acceleration, as has been "
"attempted on some ARM embedded platforms. Such drivers really must have a "
"hardware-specific ioctl to allocate suitable buffer objects."
msgstr ""

#: ../../../gpu/drm-kms.rst:372
msgid "Plane Abstraction"
msgstr ""

#: ../../../gpu/drm-kms:374: drivers/gpu/drm/drm_plane.c:40
msgid ""
"A plane represents an image source that can be blended with or overlaid on "
"top of a CRTC during the scanout process. Planes take their input data from "
"a :c:type:`drm_framebuffer` object. The plane itself specifies the cropping "
"and scaling of that image, and where it is placed on the visible area of a "
"display pipeline, represented by :c:type:`drm_crtc`. A plane can also have "
"additional properties that specify how the pixels are positioned and "
"blended, like rotation or Z-position. All these properties are stored in :c:"
"type:`drm_plane_state`."
msgstr ""

#: ../../../gpu/drm-kms:374: drivers/gpu/drm/drm_plane.c:48
msgid ""
"Unless explicitly specified (via CRTC property or otherwise), the active "
"area of a CRTC will be black by default. This means portions of the active "
"area which are not covered by a plane will be black, and alpha blending of "
"any planes with the CRTC background will blend with black at the lowest zpos."
msgstr ""

#: ../../../gpu/drm-kms:374: drivers/gpu/drm/drm_plane.c:53
msgid ""
"To create a plane, a KMS drivers allocates and zeroes an instances of :c:"
"type:`struct drm_plane <drm_plane>` (possibly as part of a larger structure) "
"and registers it with a call to drm_universal_plane_init()."
msgstr ""

#: ../../../gpu/drm-kms:374: drivers/gpu/drm/drm_plane.c:57
msgid ""
"Each plane has a type, see enum drm_plane_type. A plane can be compatible "
"with multiple CRTCs, see :c:type:`drm_plane.possible_crtcs <drm_plane>`."
msgstr ""

#: ../../../gpu/drm-kms:374: drivers/gpu/drm/drm_plane.c:60
msgid ""
"Each CRTC must have a unique primary plane userspace can attach to enable "
"the CRTC. In other words, userspace must be able to attach a different "
"primary plane to each CRTC at the same time. Primary planes can still be "
"compatible with multiple CRTCs. There must be exactly as many primary planes "
"as there are CRTCs."
msgstr ""

#: ../../../gpu/drm-kms:374: drivers/gpu/drm/drm_plane.c:66
msgid ""
"Legacy uAPI doesn't expose the primary and cursor planes directly. DRM core "
"relies on the driver to set the primary and optionally the cursor plane used "
"for legacy IOCTLs. This is done by calling drm_crtc_init_with_planes(). All "
"drivers must provide one primary plane per CRTC to avoid surprising legacy "
"userspace too much."
msgstr ""

#: ../../../gpu/drm-kms.rst:378
msgid "Plane Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:46
msgid "mutable plane state"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:56
msgid "backpointer to the plane"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:60
msgid ""
"Currently bound CRTC, NULL if disabled. Do not write this directly, use "
"drm_atomic_set_crtc_for_plane()"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:68
msgid ""
"Currently bound framebuffer. Do not write this directly, use "
"drm_atomic_set_fb_for_plane()"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:75
msgid "``fence``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:76
msgid ""
"Optional fence to wait for before scanning out **fb**. The core atomic code "
"will set this when userspace is using explicit fencing. Do not write this "
"field directly for a driver's implicit fence."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:80
msgid ""
"Drivers should store any implicit fence in this from their :c:type:"
"`drm_plane_helper_funcs.prepare_fb <drm_plane_helper_funcs>` callback. See "
"drm_gem_plane_helper_prepare_fb() for a suitable helper."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:88
msgid "``crtc_x``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:89
msgid ""
"Left position of visible portion of plane on crtc, signed dest location "
"allows it to be partially off screen."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:96
msgid "``crtc_y``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:97
msgid ""
"Upper position of visible portion of plane on crtc, signed dest location "
"allows it to be partially off screen."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:103
msgid "``crtc_w``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:104
msgid "width of visible portion of plane on crtc"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:104
msgid "``crtc_h``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:105
msgid "height of visible portion of plane on crtc"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:108
msgid "``src_x``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:109
msgid ""
"left position of visible portion of plane within plane (in 16.16 fixed "
"point)."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:113
msgid "``src_y``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:114
msgid ""
"upper position of visible portion of plane within plane (in 16.16 fixed "
"point)."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:118
msgid "``src_h``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:119
msgid "height of visible portion of plane (in 16.16)"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:117
msgid "``src_w``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:118
msgid "width of visible portion of plane (in 16.16)"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:121
msgid "``hotspot_x``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:122
msgid "x offset to mouse cursor hotspot"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:122
msgid "``hotspot_y``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:123
msgid "y offset to mouse cursor hotspot"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:126
msgid "``alpha``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:127
msgid ""
"Opacity of the plane with 0 as completely transparent and 0xffff as "
"completely opaque. See drm_plane_create_alpha_property() for more details."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:134
msgid "``pixel_blend_mode``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:135
msgid ""
"The alpha blending equation selection, describing how the pixels from the "
"current plane are composited with the background. Value can be one of "
"DRM_MODE_BLEND_*"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:142
msgid "``rotation``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:143
msgid ""
"Rotation of the plane. See drm_plane_create_rotation_property() for more "
"details."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:149
msgid "``zpos``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:150
msgid "Priority of the given plane on crtc (optional)."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:152
msgid ""
"User-space may set mutable zpos properties so that multiple active planes on "
"the same CRTC have identical zpos values. This is a user-space bug, but "
"drivers can solve the conflict by comparing the plane object IDs; the plane "
"with a higher ID is stacked on top of a plane with a lower ID."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:158
msgid ""
"See drm_plane_create_zpos_property() and "
"drm_plane_create_zpos_immutable_property() for more details."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:164
msgid "``normalized_zpos``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:165
msgid ""
"Normalized value of zpos: unique, range from 0 to N-1 where N is the number "
"of active planes for given crtc. Note that the driver must set :c:type:"
"`drm_mode_config.normalize_zpos <drm_mode_config>` or call "
"drm_atomic_normalize_zpos() to update this before it can be trusted."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:173
msgid "``color_encoding``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:174
msgid "Color encoding for non RGB formats"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:180
msgid "``color_range``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:181
msgid "Color range for non RGB formats"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:187
msgid "``fb_damage_clips``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:188
msgid ""
"Blob representing damage (area in plane framebuffer that changed since last "
"plane update) as an array of :c:type:`drm_mode_rect` in framebuffer "
"coodinates of the attached framebuffer. Note that unlike plane src, damage "
"clips are not in 16.16 fixed point."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:193
msgid ""
"See drm_plane_get_damage_clips() and drm_plane_get_damage_clips_count() for "
"accessing these."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:200
msgid "``ignore_damage_clips``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:201
msgid ""
"Set by drivers to indicate the drm_atomic_helper_damage_iter_init() helper "
"that the **fb_damage_clips** blob property should be ignored."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:204
msgid "See :ref:`damage_tracking_properties` for more information."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:210
msgid "``src``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:211
msgid "source coordinates of the plane (in 16.16)."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:213
#: include/drm/drm_plane.h:223
msgid ""
"When using drm_atomic_helper_check_plane_state(), the coordinates are "
"clipped, but the driver may choose to use unclipped coordinates instead when "
"the hardware performs the clipping automatically."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:220
msgid "``dst``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:221
msgid "clipped destination coordinates of the plane."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:232
msgid "``visible``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:233
msgid ""
"Visibility of the plane. This can be false even if fb!=NULL and crtc!=NULL, "
"due to clipping."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:248
msgid ""
"Tracks the pending commit to prevent use-after-free conditions, and for "
"async plane updates."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:251
msgid "May be NULL."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:259
msgid ""
"Color management properties have changed. Used by the atomic helpers and "
"drivers to steer the atomic commit control flow."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:47
msgid ""
"Please note that the destination coordinates **crtc_x**, **crtc_y**, "
"**crtc_h** and **crtc_w** and the source coordinates **src_x**, **src_y**, "
"**src_h** and **src_w** are the raw coordinates provided by userspace. "
"Drivers should use drm_atomic_helper_check_plane_state() and only use the "
"derived rectangles in **src** and **dst** to program the hardware."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:290
msgid "driver plane control functions"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:294
msgid "``update_plane``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:295
msgid ""
"This is the legacy entry point to enable and configure the plane for the "
"given CRTC and framebuffer. It is never called to disable the plane, i.e. "
"the passed-in crtc and fb paramters are never NULL."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:299
msgid ""
"The source rectangle in frame buffer memory coordinates is given by the "
"src_x, src_y, src_w and src_h parameters (as 16.16 fixed point values). "
"Devices that don't support subpixel plane coordinates can ignore the "
"fractional part."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:304
msgid ""
"The destination rectangle in CRTC coordinates is given by the crtc_x, "
"crtc_y, crtc_w and crtc_h parameters (as integer values). Devices scale the "
"source rectangle to the destination rectangle. If scaling is not supported, "
"and the source rectangle size doesn't match the destination rectangle size, "
"the driver must return a -<errorname>EINVAL</errorname> error."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:311
msgid ""
"Drivers implementing atomic modeset should use "
"drm_atomic_helper_update_plane() to implement this hook."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:328
msgid "``disable_plane``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:329
msgid ""
"This is the legacy entry point to disable the plane. The DRM core calls this "
"method in response to a DRM_IOCTL_MODE_SETPLANE IOCTL call with the frame "
"buffer ID set to 0.  Disabled planes must not be processed by the CRTC."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:334
msgid ""
"Drivers implementing atomic modeset should use "
"drm_atomic_helper_disable_plane() to implement this hook."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:347
msgid ""
"Clean up plane resources. This is only called at driver unload time through "
"drm_mode_config_cleanup() since a plane cannot be hotplugged in DRM."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:356
msgid ""
"Reset plane hardware and software state to off. This function isn't called "
"by the core directly, only through drm_mode_config_reset(). It's not a "
"helper hook only for historical reasons."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:360
msgid ""
"Atomic drivers can use drm_atomic_helper_plane_reset() to reset atomic state "
"using this hook."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:368
msgid ""
"This is the legacy entry point to update a property attached to the plane."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:385
msgid ""
"Duplicate the current atomic state for this plane and return it. The core "
"and helpers guarantee that any atomic state duplicated with this hook and "
"still owned by the caller (i.e. not transferred to the driver by calling :c:"
"type:`drm_mode_config_funcs.atomic_commit <drm_mode_config_funcs>`) will be "
"cleaned up by calling the **atomic_destroy_state** hook in this structure."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:394
msgid ""
"Atomic drivers which don't subclass :c:type:`struct drm_plane_state "
"<drm_plane_state>` should use drm_atomic_helper_plane_duplicate_state(). "
"Drivers that subclass the state structure to extend it with driver-private "
"state should use __drm_atomic_helper_plane_duplicate_state() to make sure "
"shared state is duplicated in a consistent fashion across drivers."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:400
msgid ""
"It is an error to call this hook before :c:type:`drm_plane.state "
"<drm_plane>` has been initialized correctly."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:440
msgid ""
"Do not call this function directly, use drm_atomic_plane_set_property() "
"instead."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:461
msgid ""
"0 if the property has been found, -EINVAL if the property isn't implemented "
"by the driver (which shouldn't ever happen, the core only asks for "
"properties attached to this plane). No other validation is allowed by the "
"driver. The core already checks that the property value is within the range "
"(integer, valid enum value, ...) the driver set when registering the "
"property."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:476
msgid ""
"Reads out the decoded driver-private property. This is used to implement the "
"GETPLANE IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:479
msgid ""
"Do not call this function directly, use drm_atomic_plane_get_property() "
"instead."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:487
msgid ""
"0 on success, -EINVAL if the property isn't implemented by the driver (which "
"should never happen, the core only asks for properties attached to this "
"plane)."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:498
msgid ""
"This optional hook can be used to register additional userspace interfaces "
"attached to the plane like debugfs interfaces. It is called late in the "
"driver load sequence from drm_dev_register(). Everything added from this "
"callback should be unregistered in the early_unregister callback."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:513
msgid ""
"This optional hook should be used to unregister the additional userspace "
"interfaces attached to the plane from **late_register**. It is called from "
"drm_dev_unregister(), early in the driver unload sequence to disable "
"userspace access before data structures are torndown."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:524
msgid ""
"If driver subclasses :c:type:`struct drm_plane_state <drm_plane_state>`, it "
"should implement this optional hook for printing additional driver specific "
"state."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:527
msgid "Do not call this directly, use drm_atomic_plane_print_state() instead."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:535
msgid "``format_mod_supported``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:536
msgid ""
"This optional hook is used for the DRM to determine if the given format/"
"modifier combination is valid for the plane. This allows the DRM to generate "
"the correct format bitmask (which formats apply to which modifier), and to "
"validate modifiers at atomic_check time."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:541
msgid ""
"If not present, then any modifier in the plane's modifier list is allowed "
"with any of the plane's formats."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:546
#: include/drm/drm_plane.h:562
msgid ""
"True if the given modifier is valid for that format on the plane. False "
"otherwise."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:553
msgid "``format_mod_supported_async``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:554
msgid ""
"This optional hook is used for the DRM to determine if for asynchronous flip "
"the given format/modifier combination is valid for the plane. This allows "
"the DRM to generate the correct format bitmask (which formats apply to which "
"modifier), and to validate modifiers at atomic_check time."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:572
msgid "uapi plane type enumeration"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:578
msgid "``DRM_PLANE_TYPE_OVERLAY``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:579
msgid ""
"Overlay planes represent all non-primary, non-cursor planes. Some drivers "
"refer to these types of planes as \"sprites\" internally."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:582
msgid "``DRM_PLANE_TYPE_PRIMARY``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:583
msgid ""
"A primary plane attached to a CRTC is the most likely to be able to light up "
"the CRTC when no scaling/cropping is used and the plane covers the whole "
"CRTC."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:587
msgid "``DRM_PLANE_TYPE_CURSOR``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:588
msgid ""
"A cursor plane attached to a CRTC is more likely to be able to be enabled "
"when no scaling/cropping is used and the framebuffer has the size indicated "
"by :c:type:`drm_mode_config.cursor_width <drm_mode_config>` and :c:type:"
"`drm_mode_config.cursor_height <drm_mode_config>`. Additionally, if the "
"driver doesn't support modifiers, the framebuffer should have a linear "
"layout."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:573
msgid ""
"For historical reasons not all planes are made the same. This enumeration is "
"used to tell the different types of planes apart to implement the different "
"uapi semantics for them. For userspace which is universal plane aware and "
"which is using that atomic IOCTL there's no difference between these planes "
"(beyong what the driver and hardware can support of course)."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:579
msgid ""
"For compatibility with legacy userspace, only overlay planes are made "
"available to userspace by default. Userspace clients may set the :c:type:"
"`DRM_CLIENT_CAP_UNIVERSAL_PLANES` client capability bit to indicate that "
"they wish to receive a universal plane list containing all plane types. See "
"also drm_for_each_legacy_plane()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:585
msgid ""
"In addition to setting each plane's type, drivers need to setup the :c:type:"
"`drm_crtc.primary <drm_crtc>` and optionally :c:type:`drm_crtc.cursor "
"<drm_crtc>` pointers for legacy IOCTLs. See drm_crtc_init_with_planes()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:589
msgid ""
"WARNING: The values of this enum is UABI since they're exposed in the "
"\"type\" property."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:625
msgid "central DRM plane control structure"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:635
msgid "DRM device this plane belongs to"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:639
msgid ""
"List of all planes on **dev**, linked from :c:type:`drm_mode_config."
"plane_list <drm_mode_config>`. Invariant over the lifetime of **dev** and "
"therefore does not need locking."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:651
msgid ""
"Protects modeset plane state, together with the :c:type:`drm_crtc.mutex "
"<drm_crtc>` of CRTC this plane is linked to (when active, getting activated "
"or getting disabled)."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:661
msgid "base mode object"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:664
#: include/drm/drm_plane.h:839 include/drm/drm_plane.h:884
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:146
msgid "``possible_crtcs``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:665
msgid "pipes this plane can be bound to constructed from drm_crtc_mask()"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:668
msgid "``format_types``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:669
msgid "array of formats supported by this plane"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:670
#: include/drm/drm_plane.h:842 include/drm/drm_plane.h:887
msgid "``format_count``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:671
msgid "Size of the array pointed at by **format_types**."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:673
msgid "``format_default``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:674
msgid ""
"driver hasn't supplied supported formats for the plane. Used by the non-"
"atomic driver compatibility wrapper only."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:678
msgid "``modifiers``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:679
msgid "array of modifiers supported by this plane"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:680
msgid "``modifier_count``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:681
msgid "Size of the array pointed at by **modifier_count**."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:685
msgid ""
"Currently bound CRTC, only meaningful for non-atomic drivers. For atomic "
"drivers this is forced to be NULL, atomic drivers should instead check :c:"
"type:`drm_plane_state.crtc <drm_plane_state>`."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:694
msgid ""
"Currently bound framebuffer, only meaningful for non-atomic drivers. For "
"atomic drivers this is forced to be NULL, atomic drivers should instead "
"check :c:type:`drm_plane_state.fb <drm_plane_state>`."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:702
msgid "``old_fb``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:703
msgid ""
"Temporary tracking of the old fb while a modeset is ongoing. Only used by "
"non-atomic drivers, forced to be NULL for atomic drivers."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:710
msgid "plane control functions"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:713
msgid "property tracking for this plane"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:716
msgid ""
"Type of plane, see :c:type:`enum drm_plane_type <drm_plane_type>` for "
"details."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:720
msgid ""
"Position inside the mode_config.list, can be used as an array index. It is "
"invariant over the lifetime of the plane."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:729
msgid "Current atomic state for this plane."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:731
msgid ""
"This is protected by **mutex**. Note that nonblocking atomic commits access "
"the current plane state without taking locks. Either by going through the :c:"
"type:`struct drm_atomic_state <drm_atomic_state>` pointers, see "
"for_each_oldnew_plane_in_state(), for_each_old_plane_in_state() and "
"for_each_new_plane_in_state(). Or through careful ordering of atomic commit "
"operations as implemented in the atomic helpers, see :c:type:`struct "
"drm_crtc_commit <drm_crtc_commit>`."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:743
msgid "``alpha_property``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:744
msgid ""
"Optional alpha property for this plane. See "
"drm_plane_create_alpha_property()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:749
msgid "``zpos_property``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:750
msgid ""
"Optional zpos property for this plane. See drm_plane_create_zpos_property()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:755
msgid "``rotation_property``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:756
msgid ""
"Optional rotation property for this plane. See "
"drm_plane_create_rotation_property()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:761
msgid "``blend_mode_property``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:762
msgid ""
"Optional \"pixel blend mode\" enum property for this plane. Blend mode "
"property represents the alpha blending equation selection, describing how "
"the pixels from the current plane are composited with the background."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:770
msgid "``color_encoding_property``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:771
msgid ""
"Optional \"COLOR_ENCODING\" enum property for specifying color encoding for "
"non RGB formats. See drm_plane_create_color_properties()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:778
msgid "``color_range_property``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:779
msgid ""
"Optional \"COLOR_RANGE\" enum property for specifying color range for non "
"RGB formats. See drm_plane_create_color_properties()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:793
msgid "``hotspot_x_property``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:794
msgid "property to set mouse hotspot x offset."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:798
msgid "``hotspot_y_property``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:799
msgid "property to set mouse hotspot y offset."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:803
msgid "``kmsg_panic``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:804
msgid "Used to register a panic notifier for this plane"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:626
msgid ""
"Planes represent the scanout hardware of a display block. They receive their "
"input data from a :c:type:`drm_framebuffer` and feed it to a :c:type:"
"`drm_crtc`. Planes control the color conversion, see `Plane Composition "
"Properties`_ for more details, and are also involved in the color conversion "
"of input pixels, see `Color Management Properties`_ for details on that."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:836
msgid ""
"``drmm_universal_plane_alloc (dev, type, member, possible_crtcs, funcs, "
"formats, format_count, format_modifiers, plane_type, name, ...)``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:834
#: include/drm/drm_plane.h:879
msgid "Allocate and initialize an universal plane object"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:836
#: include/drm/drm_plane.h:881
msgid "the type of the struct which contains struct :c:type:`drm_plane`"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:837
#: include/drm/drm_plane.h:882
msgid "the name of the :c:type:`drm_plane` within **type**"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:838
#: include/drm/drm_plane.h:883 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:509
msgid "bitmask of possible CRTCs"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:839
#: include/drm/drm_plane.h:884 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:510
msgid "callbacks for the new plane"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:841
#: include/drm/drm_plane.h:886
msgid "``formats``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:840
#: include/drm/drm_plane.h:885 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:511
msgid "array of supported formats (DRM_FORMAT\\_\\*)"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:841
#: include/drm/drm_plane.h:886 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:512
msgid "number of elements in **formats**"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:843
#: include/drm/drm_plane.h:888
msgid "``format_modifiers``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:842
#: include/drm/drm_plane.h:887 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:513
msgid ""
"array of struct drm_format modifiers terminated by DRM_FORMAT_MOD_INVALID"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:845
#: include/drm/drm_plane.h:890
msgid "``plane_type``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:844
#: include/drm/drm_plane.h:889 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:515
msgid "type of plane (overlay, primary, cursor)"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:845
#: include/drm/drm_plane.h:890 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:516
msgid "printf style format string for the plane name, or NULL for default name"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:846
msgid ""
"Allocates and initializes a plane object of type **type**. Cleanup is "
"automatically handled through registering drm_plane_cleanup() with "
"drmm_add_action()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:850
msgid "The **drm_plane_funcs.destroy** hook must be NULL."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:852
#: include/drm/drm_plane.h:896 ../../../gpu/drm-kms:383:
#: drivers/gpu/drm/drm_plane.c:526
msgid ""
"Drivers that only support the DRM_FORMAT_MOD_LINEAR modifier support may set "
"**format_modifiers** to NULL. The plane will advertise the linear modifier."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:856
#: include/drm/drm_plane.h:900
msgid "Pointer to new plane, or ERR_PTR on failure."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:881
msgid ""
"``drm_universal_plane_alloc (dev, type, member, possible_crtcs, funcs, "
"formats, format_count, format_modifiers, plane_type, name, ...)``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:891
msgid ""
"Allocates and initializes a plane object of type **type**. The caller is "
"responsible for releasing the allocated memory with kfree()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:894
msgid "Drivers are encouraged to use drmm_universal_plane_alloc() instead."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:912
msgid "find the index of a registered plane"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:918
#: include/drm/drm_plane.h:930
msgid "``const struct drm_plane *plane``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:913
msgid "plane to find index for"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:914
msgid ""
"Given a registered plane, return the index of that plane within a DRM "
"device's list of planes."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:924
msgid "find the mask of a registered plane"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:925
msgid "plane to find mask for"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:940
msgid "find a :c:type:`drm_plane`"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:943
msgid "plane id"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:944
msgid ""
"Returns the plane with **id**, NULL if it doesn't exist. Simple wrapper "
"around drm_mode_object_find()."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:960
msgid "``drm_for_each_plane_mask (plane, dev, plane_mask)``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:958
msgid "iterate over planes specified by bitmask"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:959
#: include/drm/drm_plane.h:971 include/drm/drm_plane.h:984
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:326
#: include/drm/drm_encoder.h:338
msgid "the loop cursor"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:960
#: include/drm/drm_plane.h:972 include/drm/drm_plane.h:985
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:327
#: include/drm/drm_encoder.h:339
msgid "the DRM device"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:961
msgid "bitmask of plane indices"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:962
msgid "Iterate over all planes specified by bitmask."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:972
msgid "``drm_for_each_legacy_plane (plane, dev)``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:970
msgid "iterate over all planes for legacy userspace"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:973
msgid ""
"Iterate over all legacy planes of **dev**, excluding primary and cursor "
"planes. This is useful for implementing userspace apis when userspace is not "
"universal plane aware. See also :c:type:`enum drm_plane_type "
"<drm_plane_type>`."
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:985
msgid "``drm_for_each_plane (plane, dev)``"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:983
msgid "iterate over all planes"
msgstr ""

#: ../../../gpu/drm-kms:380: include/drm/drm_plane.h:986
msgid "Iterate over all planes of **dev**, include primary and cursor planes."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:506
msgid "Initialize a new universal plane object"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:508
msgid "plane object to init"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:510
msgid "``uint32_t possible_crtcs``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:511
msgid "``const struct drm_plane_funcs *funcs``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:512
msgid "``const uint32_t *formats``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:513
msgid "``unsigned int format_count``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:514
msgid "``const uint64_t *format_modifiers``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:516
msgid "``enum drm_plane_type type``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:517
msgid ""
"Initializes a plane object of type **type**. The :c:type:`drm_plane_funcs."
"destroy <drm_plane_funcs>` hook should call drm_plane_cleanup() and kfree() "
"the plane structure. The plane structure should not be allocated with "
"devm_kzalloc()."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:522
msgid ""
"consider using drmm_universal_plane_alloc() instead of "
"drm_universal_plane_init() to let the DRM managed resource infrastructure "
"take care of cleanup and deallocation."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:676
msgid "Clean up the core plane usage"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:677
msgid "plane to cleanup"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:678
msgid ""
"This function cleans up **plane** and removes it from the DRM mode setting "
"core. Note that the function does *not* free the plane structure itself, "
"this is the responsibility of the caller."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:714
msgid "find the registered plane at an index"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:716
msgid "index of registered plane to find for"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:717
msgid ""
"Given a plane index, return the registered plane from DRM device's list of "
"planes with matching index. This is the inverse of drm_plane_index()."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:735
msgid "Forcibly disable a plane"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:736
msgid "plane to disable"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:737
msgid "Forces the plane to be disabled."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:739
msgid ""
"Used when the plane's current framebuffer is destroyed, and when restoring "
"fbdev mode."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:742
msgid ""
"Note that this function is not suitable for atomic drivers, since it doesn't "
"wire through the lock acquisition context properly and hence can't handle "
"retries or driver private locks. You probably want to use "
"drm_atomic_helper_disable_plane() or "
"drm_atomic_helper_disable_planes_on_crtc() instead."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:775
msgid "drm plane object to set property value for"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:778
#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:380
msgid "``uint64_t value``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:778
msgid ""
"This functions sets a given property on a given plane object. This function "
"calls the driver's ->set_property callback and changes the software state of "
"the property if the callback succeeds."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:908
msgid "Check whether the plane supports this format and modifier combination"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:909
#: drivers/gpu/drm/drm_plane.c:1760 drivers/gpu/drm/drm_plane.c:1790
#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:214
#: drivers/gpu/drm/drm_blend.c:246 drivers/gpu/drm/drm_blend.c:347
#: drivers/gpu/drm/drm_blend.c:400 drivers/gpu/drm/drm_blend.c:550
msgid "drm plane"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:911
#: drivers/gpu/drm/drm_plane.c:991
msgid "data layout modifier"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:913
msgid ""
"Whether the plane supports the specified format and modifier combination."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:988
msgid "Check whether any plane supports this format and modifier combination"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:993
msgid ""
"Whether at least one plane supports the specified format and modifier "
"combination."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1649
msgid "Enables plane fb damage clips property."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1650
msgid "Plane on which to enable damage clips property."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1651
msgid ""
"This function lets driver to enable the damage clips property on a plane."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1665
msgid "Returns damage clips count."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1671
#: drivers/gpu/drm/drm_plane.c:1695 ../../../gpu/drm-kms:395:
#: drivers/gpu/drm/drm_damage_helper.c:211
#: drivers/gpu/drm/drm_damage_helper.c:301
msgid "``const struct drm_plane_state *state``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1666
#: drivers/gpu/drm/drm_plane.c:1690
msgid "Plane state."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1667
msgid ""
"Simple helper to get the number of :c:type:`drm_mode_rect` clips set by user-"
"space during plane update."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1671
msgid "Number of clips in plane fb_damage_clips blob property."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1689
msgid "Returns damage clips."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1691
msgid ""
"Note that this function returns uapi type :c:type:`drm_mode_rect`. Drivers "
"might want to use the helper functions drm_atomic_helper_damage_iter_init() "
"and drm_atomic_helper_damage_iter_next() or "
"drm_atomic_helper_damage_merged() if the driver can only handle a single "
"damage region at most."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1697
msgid "Damage clips in plane fb_damage_clips blob property."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1763
msgid ""
"This function lets driver to enable the scaling filter property on a given "
"plane."
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1788
msgid "create a size hints property"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1792
msgid "``const struct drm_plane_size_hint *hints``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1791
msgid "size hints"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1793
msgid "``int num_hints``"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1792
msgid "number of size hints"
msgstr ""

#: ../../../gpu/drm-kms:383: drivers/gpu/drm/drm_plane.c:1793
msgid "Create a size hints property for the plane."
msgstr ""

#: ../../../gpu/drm-kms.rst:387
msgid "Plane Composition Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:213
msgid "create a new alpha property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:215
msgid ""
"This function creates a generic, mutable, alpha property and enables support "
"for it in the DRM core. It is attached to **plane**."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:218
msgid ""
"The alpha property will be allowed to be within the bounds of 0 "
"(transparent) to 0xffff (opaque)."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:245
msgid "create a new rotation property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:248
#: drivers/gpu/drm/drm_blend.c:320
msgid "``unsigned int rotation``"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:247
msgid "initial value of the rotation property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:249
#: drivers/gpu/drm/drm_blend.c:317
msgid "``unsigned int supported_rotations``"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:248
msgid "bitmask of supported rotations and reflections"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:249
msgid ""
"This creates a new property with the selected support for transformations."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:251
msgid ""
"Since a rotation by 180° degress is the same as reflecting both along the x "
"and the y axis the rotation property is somewhat redundant. Drivers can use "
"drm_rotation_simplify() to normalize values of this property."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:255
msgid ""
"The property exposed to userspace is a bitmask property (see "
"drm_property_create_bitmask()) called \"rotation\" and has the following "
"bitmask enumaration values:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:259
msgid "DRM_MODE_ROTATE_0:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:260
msgid "\"rotate-0\""
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:261
msgid "DRM_MODE_ROTATE_90:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:262
msgid "\"rotate-90\""
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:263
msgid "DRM_MODE_ROTATE_180:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:264
msgid "\"rotate-180\""
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:265
msgid "DRM_MODE_ROTATE_270:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:266
msgid "\"rotate-270\""
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:267
msgid "DRM_MODE_REFLECT_X:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:268
msgid "\"reflect-x\""
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:269
msgid "DRM_MODE_REFLECT_Y:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:270
msgid "\"reflect-y\""
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:272
msgid ""
"Rotation is the specified amount in degrees in counter clockwise direction, "
"the X and Y axis are within the source rectangle, i.e.  the X/Y axis before "
"rotation. After reflection, the rotation is applied to the image sampled "
"from the source rectangle, before scaling it to fit the destination "
"rectangle."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:314
msgid "Try to simplify the rotation"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:315
msgid "Rotation to be simplified"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:316
msgid "Supported rotations"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:317
msgid ""
"Attempt to simplify the rotation to a form that is supported. Eg. if the "
"hardware supports everything except DRM_MODE_REFLECT_X one could call this "
"function like this:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:321
msgid "drm_rotation_simplify(rotation, DRM_MODE_ROTATE_0 |"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:322
msgid ""
"DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_180 | DRM_MODE_ROTATE_270 | "
"DRM_MODE_REFLECT_Y);"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:325
msgid ""
"to eliminate the DRM_MODE_REFLECT_X flag. Depending on what kind of "
"transforms the hardware supports, this function may not be able to produce a "
"supported transform, so the caller should check the result afterwards."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:346
msgid "create mutable zpos property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:349
#: drivers/gpu/drm/drm_blend.c:402
msgid "``unsigned int zpos``"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:348
msgid "initial value of zpos property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:350
msgid "``unsigned int min``"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:349
msgid "minimal possible value of zpos property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:351
msgid "``unsigned int max``"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:350
msgid "maximal possible value of zpos property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:351
msgid ""
"This function initializes generic mutable zpos property and enables support "
"for it in drm core. Drivers can then attach this property to planes to "
"enable support for configurable planes arrangement during blending "
"operation. Drivers that attach a mutable zpos property to any plane should "
"call the drm_atomic_normalize_zpos() helper during their implementation of :"
"c:type:`drm_mode_config_funcs.atomic_check\\(\\) <drm_mode_config_funcs>`, "
"which will update the normalized zpos values and store them in :c:type:"
"`drm_plane_state.normalized_zpos <drm_plane_state>`. Usually min should be "
"set to 0 and max to maximal number of planes for given crtc - 1."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:360
msgid ""
"If zpos of some planes cannot be changed (like fixed background or cursor/"
"topmost planes), drivers shall adjust the min/max values and assign those "
"planes immutable zpos properties with lower or higher values (for more "
"information, see drm_plane_create_zpos_immutable_property() function). In "
"such case drivers shall also assign proper initial zpos values for all "
"planes in its plane_reset() callback, so the planes will be always sorted "
"properly."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:367
msgid "See also drm_atomic_normalize_zpos()."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:369
#: drivers/gpu/drm/drm_blend.c:408
msgid "The property exposed to userspace is called \"zpos\"."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:399
msgid "create immuttable zpos property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:401
msgid "value of zpos property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:402
msgid ""
"This function initializes generic immutable zpos property and enables "
"support for it in drm core. Using this property driver lets userspace to get "
"the arrangement of the planes for blending operation and notifies it that "
"the hardware (or driver) doesn't support changing of the planes' order. For "
"mutable zpos see drm_plane_create_zpos_property()."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:499
msgid "calculate normalized zpos values for all crtcs"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:501
msgid "atomic state of DRM device"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:502
msgid ""
"This function calculates normalized zpos value for all modified planes in "
"the provided atomic state of DRM device."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:505
msgid ""
"For every CRTC this function checks new states of all planes assigned to it "
"and calculates normalized zpos value for these planes. Planes are compared "
"first by their zpos values, then by plane id (if zpos is equal). The plane "
"with lowest zpos value is at the bottom. The :c:type:`drm_plane_state."
"normalized_zpos <drm_plane_state>` is then filled with unique values from 0 "
"to number of active planes in crtc minus one."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:512
msgid "RETURNS Zero for success or -errno"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:549
msgid "create a new blend mode property"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:552
msgid "``unsigned int supported_modes``"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:551
msgid ""
"bitmask of supported modes, must include BIT(DRM_MODE_BLEND_PREMULTI). "
"Current DRM assumption is that alpha is premultiplied, and old userspace can "
"break if the property defaults to anything else."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:555
msgid "This creates a new property describing the blend mode."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:557
msgid ""
"The property exposed to userspace is an enumeration property (see "
"drm_property_create_enum()) called \"pixel blend mode\" and has the "
"following enumeration values:"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:561
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:154
msgid "\"None\":"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:562
msgid "Blend formula that ignores the pixel alpha."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:564
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:160
msgid "\"Pre-multiplied\":"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:565
msgid ""
"Blend formula that assumes the pixel color values have been already pre-"
"multiplied with the alpha channel values."
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:568
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:168
msgid "\"Coverage\":"
msgstr ""

#: ../../../gpu/drm-kms:389: drivers/gpu/drm/drm_blend.c:569
msgid ""
"Blend formula that assumes the pixel color values have not been pre-"
"multiplied and will do so when blending them to the background color values."
msgstr ""

#: ../../../gpu/drm-kms.rst:393
msgid "Plane Damage Tracking Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:56
msgid "Verify plane damage on atomic_check."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:57
msgid "The driver state object."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:58
msgid "Plane state for which to verify damage."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:59
msgid ""
"This helper function makes sure that damage from plane state is discarded "
"for full modeset. If there are more reasons a driver would want to do a full "
"plane update rather than processing individual damage regions, then those "
"cases should be taken care of here."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:64
msgid ""
"Note that :c:type:`drm_plane_state.fb_damage_clips <drm_plane_state>` == "
"NULL in plane state means that full plane update should happen. It also "
"ensure helper iterator will return :c:type:`drm_plane_state.src "
"<drm_plane_state>` as damage."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:90
msgid "Helper for dirtyfb."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:91
msgid "DRM framebuffer."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:92
msgid "Drm file for the ioctl call."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:94
msgid "``unsigned int flags``"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:93
msgid "Dirty fb annotate flags."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:95
msgid "``unsigned int color``"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:94
msgid "Color for annotate fill."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:96
msgid "``struct drm_clip_rect *clips``"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:95
msgid "Dirty region."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:97
msgid "``unsigned int num_clips``"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:96
msgid "Count of clip in clips."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:97
msgid ""
"A helper to implement :c:type:`drm_framebuffer_funcs.dirty "
"<drm_framebuffer_funcs>` using damage interface during plane update. If "
"num_clips is 0 then this helper will do a full plane update. This is the "
"same behaviour expected by DIRTFB IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:101
msgid ""
"Note that this helper is blocking implementation. This is what current "
"drivers and userspace expect in their DIRTYFB IOCTL implementation, as a way "
"to rate-limit userspace and make sure its rendering doesn't get ahead of "
"uploading new data too much."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:207
msgid "Initialize the damage iterator."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:213
#: drivers/gpu/drm/drm_damage_helper.c:262
msgid "``struct drm_atomic_helper_damage_iter *iter``"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:208
msgid "The iterator to initialize."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:210
#: drivers/gpu/drm/drm_damage_helper.c:304
msgid "``const struct drm_plane_state *old_state``"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:209
#: drivers/gpu/drm/drm_damage_helper.c:299
msgid "Old plane state for validation."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:210
#: drivers/gpu/drm/drm_damage_helper.c:300
msgid "Plane state from which to iterate the damage clips."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:211
msgid ""
"Initialize an iterator, which clips plane damage :c:type:`drm_plane_state."
"fb_damage_clips <drm_plane_state>` to plane :c:type:`drm_plane_state.src "
"<drm_plane_state>`. This iterator returns full plane src in case damage is "
"not present because either user-space didn't sent or driver discarded it (it "
"want to do full plane update). Currently this iterator returns full plane "
"src in case plane src changed but that can be changed in future to return "
"damage."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:218
msgid ""
"For the case when plane is not visible or plane update should not happen the "
"first call to iter_next will return false. Note that this helper use "
"clipped :c:type:`drm_plane_state.src <drm_plane_state>`, so driver calling "
"this helper should have called drm_atomic_helper_check_plane_state() earlier."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:256
msgid "Advance the damage iterator."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:257
#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:39
msgid "The iterator to advance."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:259
#: drivers/gpu/drm/drm_damage_helper.c:302
msgid "``struct drm_rect *rect``"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:258
#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:40
msgid "Return a rectangle in fb coordinate clipped to plane src."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:259
msgid ""
"Since plane src is in 16.16 fixed point and damage clips are whole number, "
"this iterator round off clips that intersect with plane src. Round down for "
"x1/y1 and round up for x2/y2 for the intersected coordinate. Similar "
"rounding off for full plane src, in case it's returned as damage. This "
"iterator will skip damage clips outside of plane src."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:266
msgid ""
"If the first call to iterator next returns false then it means no need to "
"update the plane."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:266
msgid "True if the output is valid, false if reached the end."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:298
msgid "Merged plane damage"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:301
msgid "Returns the merged damage rectangle"
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:302
msgid ""
"This function merges any valid plane damage clips into one rectangle and "
"returns it in **rect**."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:305
msgid ""
"For details see: drm_atomic_helper_damage_iter_init() and "
"drm_atomic_helper_damage_iter_next()."
msgstr ""

#: ../../../gpu/drm-kms:395: drivers/gpu/drm/drm_damage_helper.c:309
msgid "True if there is valid plane damage otherwise false."
msgstr ""

#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:40
msgid "``drm_atomic_for_each_plane_damage (iter, rect)``"
msgstr ""

#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:38
msgid "Iterator macro for plane damage."
msgstr ""

#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:44
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2549
msgid "``iter``"
msgstr ""

#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:41
msgid "``rect``"
msgstr ""

#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:41
msgid ""
"Note that if the first call to iterator macro return false then no need to "
"do plane update. Iterator will return full plane src when damage is not "
"passed by user-space."
msgstr ""

#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:50
msgid "Closure structure for damage iterator."
msgstr ""

#: ../../../gpu/drm-kms:398: include/drm/drm_damage_helper.h:51
msgid ""
"This structure tracks state needed to walk the list of plane damage clips."
msgstr ""

#: ../../../gpu/drm-kms.rst:402
msgid "Plane Panic Feature"
msgstr ""

#: ../../../gpu/drm-kms:404: drivers/gpu/drm/drm_panic.c:49
msgid ""
"To enable DRM panic for a driver, the primary plane must implement a :c:type:"
"`drm_plane_helper_funcs.get_scanout_buffer <drm_plane_helper_funcs>` helper "
"function. It is then automatically registered to the drm panic handler. When "
"a panic occurs, the :c:type:`drm_plane_helper_funcs.get_scanout_buffer "
"<drm_plane_helper_funcs>` will be called, and the driver can provide a "
"framebuffer so the panic handler can draw the panic screen on it. Currently "
"only linear buffer and a few color formats are supported. Optionally the "
"driver can also provide a :c:type:`drm_plane_helper_funcs.panic_flush "
"<drm_plane_helper_funcs>` callback, that will be called after that, to send "
"additional commands to the hardware to make the scanout buffer visible."
msgstr ""

#: ../../../gpu/drm-kms.rst:408
msgid "Plane Panic Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:19
msgid "DRM scanout buffer"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:27
msgid "drm format of the scanout buffer."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:33
msgid "``map``"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:34
msgid ""
"Virtual address of the scanout buffer, either in memory or iomem. The "
"scanout buffer should be in linear format, and can be directly sent to the "
"display hardware. Tearing is not an issue for the panic screen."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:43
msgid "``pages``"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:44
msgid ""
"Optional, if the scanout buffer is not mapped, set this field to the array "
"of pages of the scanout buffer. The panic code will use "
"kmap_local_page_try_from_panic() to map one page at a time to write all the "
"pixels. This array shouldn't be allocated from the get_scanoutbuffer() "
"callback. The scanout buffer should be in linear format."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:54
msgid "Width of the scanout buffer, in pixels."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:59
msgid "Height of the scanout buffer, in pixels."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:63
msgid "``pitch``"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:64
msgid "Length in bytes between the start of two consecutive lines."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:68
msgid "``set_pixel``"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:69
msgid ""
"Optional function, to set a pixel color on the framebuffer. It allows to "
"handle special tiling format inside the driver. It takes precedence over the "
"**map** and **pages** fields."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:76
msgid "``private``"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:77
msgid "private pointer that you can use in the callbacks set_pixel()"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:20
msgid ""
"This structure holds the information necessary for drm_panic to draw the "
"panic screen, and display it."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:88
msgid "``drm_panic_trylock (dev, flags)``"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:86
msgid "try to enter the panic printing critical section"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:87
#: include/drm/drm_panic.h:138 include/drm/drm_panic.h:161
msgid "struct drm_device"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:88
#: include/drm/drm_panic.h:139
msgid "unsigned long irq flags you need to pass to the unlock() counterpart"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:89
msgid ""
"This function must be called by any panic printing code. The panic printing "
"attempt must be aborted if the trylock fails."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:92
msgid ""
"Panic printing code can make the following assumptions while holding the "
"panic lock:"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:95
msgid ""
"Anything protected by drm_panic_lock() and drm_panic_unlock() pairs is safe "
"to access."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:98
msgid ""
"Furthermore the panic printing code only registers in drm_dev_unregister() "
"and gets removed in drm_dev_unregister(). This allows the panic code to "
"safely access any state which is invariant in between these two function "
"calls, like the list of planes :c:type:`drm_mode_config.plane_list "
"<drm_mode_config>` or most of the struct drm_plane structure."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:104
msgid ""
"Specifically thanks to the protection around plane updates in "
"drm_atomic_helper_swap_state() the following additional guarantees hold:"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:107
msgid "It is safe to deference the drm_plane.state pointer."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:109
msgid ""
"Anything in struct drm_plane_state or the driver's subclass thereof which "
"stays invariant after the atomic check code has finished is safe to access. "
"Specifically this includes the reference counted pointers to framebuffer and "
"buffer objects."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:114
msgid ""
"Anything set up by :c:type:`drm_plane_helper_funcs.fb_prepare "
"<drm_plane_helper_funcs>` and cleaned up :c:type:`drm_plane_helper_funcs."
"fb_cleanup <drm_plane_helper_funcs>` is safe to access, as long as it stays "
"invariant between these two calls. This also means that for drivers using "
"dynamic buffer management the framebuffer is pinned, and therefer all "
"relevant datastructures can be accessed without taking any further locks "
"(which would be impossible in panic context anyway)."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:121
msgid ""
"Importantly, software and hardware state set up by :c:type:"
"`drm_plane_helper_funcs.begin_fb_access <drm_plane_helper_funcs>` and :c:"
"type:`drm_plane_helper_funcs.end_fb_access <drm_plane_helper_funcs>` is not "
"safe to access."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:125
msgid ""
"Drivers must not make any assumptions about the actual state of the "
"hardware, unless they explicitly protected these hardware access with "
"drm_panic_lock() and drm_panic_unlock()."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:130
msgid "``0`` when failing to acquire the raw spinlock, nonzero on success."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:139
msgid "``drm_panic_lock (dev, flags)``"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:137
msgid "protect panic printing relevant state"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:140
msgid ""
"This function must be called to protect software and hardware state that the "
"panic printing code must be able to rely on. The protected sections must be "
"as small as possible. It uses the irqsave/irqrestore variant, and can be "
"called from irq handler. Examples include:"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:145
msgid ""
"Access to peek/poke or other similar registers, if that is the way the "
"driver prints the pixels into the scanout buffer at panic time."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:148
msgid ""
"Updates to pointers like :c:type:`drm_plane.state <drm_plane>`, allowing the "
"panic handler to safely deference these. This is done in "
"drm_atomic_helper_swap_state()."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:151
msgid ""
"An state that isn't invariant and that the driver must be able to access "
"during panic printing."
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:162
msgid "``drm_panic_unlock (dev, flags)``"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:160
msgid "end of the panic printing critical section"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:162
msgid "irq flags that were returned when acquiring the lock"
msgstr ""

#: ../../../gpu/drm-kms:410: include/drm/drm_panic.h:163
msgid ""
"Unlocks the raw spinlock acquired by either drm_panic_lock() or "
"drm_panic_trylock()."
msgstr ""

#: ../../../gpu/drm-kms:413: drivers/gpu/drm/drm_panic.c:911
msgid "the drm device that may supports drm_panic"
msgstr ""

#: ../../../gpu/drm-kms:413: drivers/gpu/drm/drm_panic.c:912
msgid "returns true if the drm device supports drm_panic"
msgstr ""

#: ../../../gpu/drm-kms.rst:417
msgid "Display Modes Function Reference"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:46
msgid "hardware support status of a mode"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:52
msgid "``MODE_OK``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:53
msgid "Mode OK"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:55
msgid "``MODE_HSYNC``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:56
msgid "hsync out of range"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:58
msgid "``MODE_VSYNC``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:59
msgid "vsync out of range"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:61
msgid "``MODE_H_ILLEGAL``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:62
msgid "mode has illegal horizontal timings"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:64
msgid "``MODE_V_ILLEGAL``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:65
msgid "mode has illegal vertical timings"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:67
msgid "``MODE_BAD_WIDTH``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:68
msgid "requires an unsupported linepitch"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:70
msgid "``MODE_NOMODE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:71
msgid "no mode with a matching name"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:73
msgid "``MODE_NO_INTERLACE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:74
msgid "interlaced mode not supported"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:76
msgid "``MODE_NO_DBLESCAN``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:77
msgid "doublescan mode not supported"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:79
msgid "``MODE_NO_VSCAN``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:80
msgid "multiscan mode not supported"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:82
msgid "``MODE_MEM``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:83
msgid "insufficient video memory"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:85
msgid "``MODE_VIRTUAL_X``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:86
msgid "mode width too large for specified virtual size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:88
msgid "``MODE_VIRTUAL_Y``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:89
msgid "mode height too large for specified virtual size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:91
msgid "``MODE_MEM_VIRT``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:92
msgid "insufficient video memory given virtual size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:94
msgid "``MODE_NOCLOCK``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:95
msgid "no fixed clock available"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:97
msgid "``MODE_CLOCK_HIGH``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:98
msgid "clock required is too high"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:100
msgid "``MODE_CLOCK_LOW``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:101
msgid "clock required is too low"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:103
msgid "``MODE_CLOCK_RANGE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:104
msgid "clock/mode isn't in a ClockRange"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:106
msgid "``MODE_BAD_HVALUE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:107
msgid "horizontal timing was out of range"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:109
msgid "``MODE_BAD_VVALUE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:110
msgid "vertical timing was out of range"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:112
msgid "``MODE_BAD_VSCAN``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:113
msgid "VScan value out of range"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:115
msgid "``MODE_HSYNC_NARROW``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:116
msgid "horizontal sync too narrow"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:118
msgid "``MODE_HSYNC_WIDE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:119
msgid "horizontal sync too wide"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:121
msgid "``MODE_HBLANK_NARROW``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:122
msgid "horizontal blanking too narrow"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:124
msgid "``MODE_HBLANK_WIDE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:125
msgid "horizontal blanking too wide"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:127
msgid "``MODE_VSYNC_NARROW``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:128
msgid "vertical sync too narrow"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:130
msgid "``MODE_VSYNC_WIDE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:131
msgid "vertical sync too wide"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:133
msgid "``MODE_VBLANK_NARROW``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:134
msgid "vertical blanking too narrow"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:136
msgid "``MODE_VBLANK_WIDE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:137
msgid "vertical blanking too wide"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:139
msgid "``MODE_PANEL``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:140
msgid "exceeds panel dimensions"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:142
msgid "``MODE_INTERLACE_WIDTH``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:143
msgid "width too large for interlaced mode"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:145
msgid "``MODE_ONE_WIDTH``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:146
msgid "only one width is supported"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:148
msgid "``MODE_ONE_HEIGHT``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:149
msgid "only one height is supported"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:151
msgid "``MODE_ONE_SIZE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:152
msgid "only one resolution is supported"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:154
msgid "``MODE_NO_REDUCED``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:155
msgid "monitor doesn't accept reduced blanking"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:157
msgid "``MODE_NO_STEREO``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:158
msgid "stereo modes not supported"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:160
msgid "``MODE_NO_420``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:161
msgid "ycbcr 420 modes not supported"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:163
msgid "``MODE_STALE``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:164
msgid "mode has become stale"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:166
msgid "``MODE_BAD``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:167
msgid "unspecified reason"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:169
msgid "``MODE_ERROR``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:170
msgid "error condition"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:87
msgid ""
"This enum is used to filter out modes not supported by the driver/hardware "
"combination."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:144
msgid "``DRM_MODE_RES_MM (res, dpi)``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:142
msgid "Calculates the display size from resolution and DPI"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:148
msgid "``res``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:143
msgid "The resolution in pixel"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:145
msgid "``dpi``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:144
msgid "The number of dots per inch"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:159
msgid "``DRM_MODE_INIT (hz, hd, vd, hd_mm, vd_mm)``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:157
msgid "Initialize display mode"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:163
msgid "``hz``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:158
msgid "Vertical refresh rate in Hertz"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:160
#: include/drm/drm_modes.h:177
msgid "``hd``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:159
#: include/drm/drm_modes.h:172
msgid "Horizontal resolution, width"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:161
#: include/drm/drm_modes.h:174
msgid "``vd``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:160
#: include/drm/drm_modes.h:173
msgid "Vertical resolution, height"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:162
#: include/drm/drm_modes.h:175
msgid "``hd_mm``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:161
#: include/drm/drm_modes.h:174
msgid "Display width in millimeters"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:163
#: include/drm/drm_modes.h:176
msgid "``vd_mm``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:162
#: include/drm/drm_modes.h:175
msgid "Display height in millimeters"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:163
msgid ""
"This macro initializes a :c:type:`drm_display_mode` that contains "
"information about refresh rate, resolution and physical size."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:173
msgid "``DRM_SIMPLE_MODE (hd, vd, hd_mm, vd_mm)``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:171
msgid "Simple display mode"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:176
msgid ""
"This macro initializes a :c:type:`drm_display_mode` that only contains info "
"about resolution and physical size."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:198
msgid "DRM kernel-internal display mode structure"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:254
msgid "``clock``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:255
msgid "Pixel clock in kHz."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:199
msgid "``hdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:200
msgid "horizontal display size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:200
msgid "``hsync_start``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:201
msgid "horizontal sync start"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:201
msgid "``hsync_end``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:202
msgid "horizontal sync end"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:202
msgid "``htotal``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:203
msgid "horizontal total size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:203
msgid "``hskew``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:204
msgid "horizontal skew?!"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:204
msgid "``vdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:205
msgid "vertical display size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:205
msgid "``vsync_start``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:206
msgid "vertical sync start"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:206
msgid "``vsync_end``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:207
msgid "vertical sync end"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:207
msgid "``vtotal``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:208
msgid "vertical total size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:208
msgid "``vscan``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:209
msgid "vertical scan?!"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:271
msgid "Sync and timing flags:"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:273
msgid "DRM_MODE_FLAG_PHSYNC: horizontal sync is active high."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:274
msgid "DRM_MODE_FLAG_NHSYNC: horizontal sync is active low."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:275
msgid "DRM_MODE_FLAG_PVSYNC: vertical sync is active high."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:276
msgid "DRM_MODE_FLAG_NVSYNC: vertical sync is active low."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:277
msgid "DRM_MODE_FLAG_INTERLACE: mode is interlaced."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:278
msgid "DRM_MODE_FLAG_DBLSCAN: mode uses doublescan."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:279
msgid "DRM_MODE_FLAG_CSYNC: mode uses composite sync."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:280
msgid "DRM_MODE_FLAG_PCSYNC: composite sync is active high."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:281
msgid "DRM_MODE_FLAG_NCSYNC: composite sync is active low."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:282
msgid "DRM_MODE_FLAG_HSKEW: hskew provided (not used?)."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:283
msgid "DRM_MODE_FLAG_BCAST: <deprecated>"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:284
msgid "DRM_MODE_FLAG_PIXMUX: <deprecated>"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:285
msgid "DRM_MODE_FLAG_DBLCLK: double-clocked mode."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:286
msgid "DRM_MODE_FLAG_CLKDIV2: half-clocked mode."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:288
msgid "Additionally there's flags to specify how 3D modes are packed:"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:290
msgid "DRM_MODE_FLAG_3D_NONE: normal, non-3D mode."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:291
msgid "DRM_MODE_FLAG_3D_FRAME_PACKING: 2 full frames for left and right."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:292
msgid "DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: interleaved like fields."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:293
msgid "DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: interleaved lines."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:294
msgid "DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: side-by-side full frames."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:295
msgid "DRM_MODE_FLAG_3D_L_DEPTH: ?"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:296
msgid "DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: ?"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:297
msgid "DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: frame split into top and bottom parts."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:299
msgid ""
"DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: frame split into left and right parts."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:306
msgid "``crtc_clock``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:307
msgid ""
"Actual pixel or dot clock in the hardware. This differs from the logical "
"**clock** when e.g. using interlacing, double-clocking, stereo modes or "
"other fancy stuff that changes the timings and signals actually sent over "
"the wire."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:312
msgid "This is again in kHz."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:314
msgid ""
"Note that with digital outputs like HDMI or DP there's usually a massive "
"confusion between the dot clock and the signal clock at the bit encoding "
"level. Especially when a 8b/10b encoding is used and the difference is "
"exactly a factor of 10."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:209
msgid "``crtc_hdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:210
msgid "hardware mode horizontal display size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:210
msgid "``crtc_hblank_start``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:211
msgid "hardware mode horizontal blank start"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:211
msgid "``crtc_hblank_end``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:212
msgid "hardware mode horizontal blank end"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:212
msgid "``crtc_hsync_start``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:213
msgid "hardware mode horizontal sync start"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:213
msgid "``crtc_hsync_end``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:214
msgid "hardware mode horizontal sync end"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:214
msgid "``crtc_htotal``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:215
msgid "hardware mode horizontal total size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:215
msgid "``crtc_hskew``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:216
msgid "hardware mode horizontal skew?!"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:216
msgid "``crtc_vdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:217
msgid "hardware mode vertical display size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:217
msgid "``crtc_vblank_start``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:218
msgid "hardware mode vertical blank start"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:218
msgid "``crtc_vblank_end``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:219
msgid "hardware mode vertical blank end"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:219
msgid "``crtc_vsync_start``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:220
msgid "hardware mode vertical sync start"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:220
msgid "``crtc_vsync_end``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:221
msgid "hardware mode vertical sync end"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:221
msgid "``crtc_vtotal``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:222
msgid "hardware mode vertical total size"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:336
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:683
msgid "``width_mm``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:337
#: include/drm/drm_modes.h:345
msgid "Addressable size of the output in mm, projectors should set this to 0."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:344
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:688
msgid "``height_mm``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:353
msgid ""
"A bitmask of flags, mostly about the source of a mode. Possible flags are:"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:356
msgid ""
"DRM_MODE_TYPE_PREFERRED: Preferred mode, usually the native resolution of an "
"LCD panel. There should only be one preferred mode per connector at any "
"given time."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:359
msgid ""
"DRM_MODE_TYPE_DRIVER: Mode created by the driver, which is all of them "
"really. Drivers must set this bit for all modes they create and expose to "
"userspace."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:362
msgid ""
"DRM_MODE_TYPE_USERDEF: Mode defined or selected via the kernel command line."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:365
msgid ""
"Plus a big list of flags which shouldn't be used at all, but are still "
"around since these flags are also used in the userspace ABI. We no longer "
"accept modes with these types though:"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:369
msgid ""
"DRM_MODE_TYPE_BUILTIN: Meant for hard-coded modes, unused. Use "
"DRM_MODE_TYPE_DRIVER instead."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:371
msgid ""
"DRM_MODE_TYPE_DEFAULT: Again a leftover, use DRM_MODE_TYPE_PREFERRED instead."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:373
msgid ""
"DRM_MODE_TYPE_CLOCK_C and DRM_MODE_TYPE_CRTC_C: Define leftovers which are "
"stuck around for hysterical raisins only. No one has an idea what they were "
"meant for. Don't use."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:381
msgid "``expose_to_userspace``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:382
msgid ""
"Indicates whether the mode is to be exposed to the userspace. This is to "
"maintain a set of exposed modes while preparing user-mode's list in "
"drm_mode_getconnector ioctl. The purpose of this only lies in the ioctl "
"function, and is not to be used outside the function."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:393
msgid "struct list_head for mode lists."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:400
msgid "Human-readable name of the mode, filled out with drm_mode_set_name()."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:406
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1998
msgid "``status``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:407
msgid ""
"Status of the mode, used to filter out modes not supported by the hardware. "
"See enum :c:type:`drm_mode_status`."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:414
#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1069
msgid "``picture_aspect_ratio``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:415
msgid "Field for setting the HDMI picture aspect ratio of a mode."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:222
msgid ""
"This is the kernel API display mode information structure. For the user-"
"space version see struct drm_mode_modeinfo."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:225
msgid ""
"The horizontal and vertical timings are defined per the following diagram."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:242
msgid ""
"This structure contains two copies of timings. First are the plain timings, "
"which specify the logical mode, as it would be for a progressive 1:1 scanout "
"at the refresh rate userspace can observe through vblank timestamps. Then "
"there's the hardware timings, which are corrected for interlacing, double-"
"clocking and similar things. They are provided as a convenience, and can be "
"appropriately computed using drm_mode_set_crtcinfo()."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:249
msgid "For printing you can use ``DRM_MODE_FMT`` and DRM_MODE_ARG()."
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:425
msgid "``DRM_MODE_FMT``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:423
msgid "printf string for :c:type:`struct drm_display_mode <drm_display_mode>`"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:430
msgid "``DRM_MODE_ARG (m)``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:428
msgid ""
"printf arguments for :c:type:`struct drm_display_mode <drm_display_mode>`"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:434
msgid "``m``"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:429
msgid "display mode"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:440
msgid "check for stereo mode flags"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:441
msgid "drm_display_mode to check"
msgstr ""

#: ../../../gpu/drm-kms:419: include/drm/drm_modes.h:443
msgid ""
"True if the mode is one of the stereo modes (like side-by-side), false if "
"not."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:53
msgid "print a mode to dmesg"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:54
msgid "mode to print"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:55
msgid "Describe **mode** using DRM_DEBUG."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:65
msgid "create a new display mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:67
msgid ""
"Create a new, cleared drm_display_mode with kzalloc, allocate an ID for it "
"and return it."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:71
msgid "Pointer to new mode on success, NULL on error."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:87
msgid "remove a mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:90
#: drivers/gpu/drm/drm_modes.c:106 drivers/gpu/drm/drm_modes.c:1270
msgid "``struct drm_display_mode *mode``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:89
msgid "mode to remove"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:90
msgid ""
"Release **mode**'s unique ID, then free it **mode** structure itself using "
"kfree."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:103
msgid "add a mode to a connector's probed_mode list"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:104
msgid "connector the new mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:105
msgid "mode data"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:106
msgid ""
"Add **mode** to **connector**'s probed_mode list for later use. This list "
"should then in a second step get filtered and all the modes actually "
"supported by the hardware moved to the **connector**'s modes list."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:525
msgid "create a display mode for an analog TV"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:528
msgid "``enum drm_connector_tv_mode tv_mode``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:527
msgid "TV Mode standard to create a mode for. See DRM_MODE_TV_MODE_*."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:529
msgid "``unsigned long pixel_clock_hz``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:528
msgid "Pixel Clock Frequency, in Hertz"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:530
msgid "``unsigned int hdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:529
#: drivers/gpu/drm/drm_modes.c:602 drivers/gpu/drm/drm_modes.c:830
#: drivers/gpu/drm/drm_modes.c:1022
msgid "hdisplay size"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:531
msgid "``unsigned int vdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:530
#: drivers/gpu/drm/drm_modes.c:603 drivers/gpu/drm/drm_modes.c:831
#: drivers/gpu/drm/drm_modes.c:1023
msgid "vdisplay size"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:532
msgid "``bool interlace``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:531
#: drivers/gpu/drm/drm_modes.c:606 drivers/gpu/drm/drm_modes.c:833
#: drivers/gpu/drm/drm_modes.c:1025
msgid "whether to compute an interlaced mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:532
msgid ""
"This function creates a struct drm_display_mode instance suited for an "
"analog TV output, for one of the usual analog TV modes. Where this is "
"DRM_MODE_TV_MODE_MONOCHROME, a 625-line mode will be created."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:536
msgid ""
"Note that **hdisplay** is larger than the usual constraints for the PAL and "
"NTSC timings, and we'll choose to ignore most timings constraints to reach "
"those resolutions."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:541
msgid ""
"A pointer to the mode, allocated with drm_mode_create(). Returns NULL on "
"error."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:600
msgid "create a modeline based on the CVT algorithm"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:603
#: drivers/gpu/drm/drm_modes.c:831 drivers/gpu/drm/drm_modes.c:1023
msgid "``int hdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:604
#: drivers/gpu/drm/drm_modes.c:832 drivers/gpu/drm/drm_modes.c:1024
msgid "``int vdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:605
#: drivers/gpu/drm/drm_modes.c:833 drivers/gpu/drm/drm_modes.c:1025
msgid "``int vrefresh``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:604
msgid "vrefresh rate"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:606
msgid "``bool reduced``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:605
msgid "whether to use reduced blanking"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:607
#: drivers/gpu/drm/drm_modes.c:834 drivers/gpu/drm/drm_modes.c:1026
msgid "``bool interlaced``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:608
msgid "``bool margins``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:607
msgid "whether to add margins (borders)"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:608
msgid ""
"This function is called to generate the modeline based on CVT algorithm "
"according to the hdisplay, vdisplay, vrefresh. It is based from the VESA(TM) "
"Coordinated Video Timing Generator by Graham Loveridge April 9, 2003 "
"available at http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:614
msgid ""
"And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c. "
"What I have done is to translate it by using integer calculation."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:618
msgid ""
"The modeline based on the CVT algorithm stored in a drm_display_mode object. "
"The display mode object is allocated with drm_mode_create(). Returns NULL "
"when no mode could be allocated."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:828
msgid "create the modeline based on the full GTF algorithm"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:832
#: drivers/gpu/drm/drm_modes.c:1024
msgid "vrefresh rate."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:835
#: drivers/gpu/drm/drm_modes.c:1027
msgid "``int margins``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:834
#: drivers/gpu/drm/drm_modes.c:1026
msgid "desired margin (borders) size"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:836
msgid "``int GTF_M``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:835
#: drivers/gpu/drm/drm_modes.c:836 drivers/gpu/drm/drm_modes.c:837
#: drivers/gpu/drm/drm_modes.c:838
msgid "extended GTF formula parameters"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:837
msgid "``int GTF_2C``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:838
msgid "``int GTF_K``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:839
msgid "``int GTF_2J``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:839
msgid ""
"GTF feature blocks specify C and J in multiples of 0.5, so we pass them in "
"here multiplied by two.  For a C of 40, pass in 80."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:843
msgid ""
"The modeline based on the full GTF algorithm stored in a drm_display_mode "
"object. The display mode object is allocated with drm_mode_create(). Returns "
"NULL when no mode could be allocated."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1020
msgid "create the modeline based on the GTF algorithm"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1027
msgid "return the modeline based on GTF algorithm"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1029
msgid ""
"This function is to create the modeline based on the GTF algorithm. "
"Generalized Timing Formula is derived from:"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1032
msgid ""
"GTF Spreadsheet by Andy Morrish (1/5/97) available at https://www.vesa.org"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1035
msgid ""
"And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c. What I "
"have done is to translate it by using integer calculation. I also refer to "
"the function of fb_get_mode in the file of drivers/video/fbmon.c"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1040
msgid "Standard GTF parameters::"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1048
msgid ""
"The modeline based on the GTF algorithm stored in a drm_display_mode object. "
"The display mode object is allocated with drm_mode_create(). Returns NULL "
"when no mode could be allocated."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1065
msgid "fill in **dmode** using **vm**,"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1071
#: drivers/gpu/drm/drm_modes.c:1152
msgid "``const struct videomode *vm``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1066
msgid "videomode structure to use as source"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1068
#: drivers/gpu/drm/drm_modes.c:1181 drivers/gpu/drm/drm_modes.c:1217
msgid "``struct drm_display_mode *dmode``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1067
msgid "drm_display_mode structure to use as destination"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1068
msgid "Fills out **dmode** using the display mode specified in **vm**."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1106
msgid "fill in **vm** using **dmode**,"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1112
msgid "``const struct drm_display_mode *dmode``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1107
msgid "drm_display_mode structure to use as source"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1109
msgid "``struct videomode *vm``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1108
msgid "videomode structure to use as destination"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1109
msgid "Fills out **vm** using the display mode specified in **dmode**."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1146
msgid ""
"extract information about pixelclk and DE polarity from videomode and store "
"it in a separate variable"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1148
msgid "videomode structure to use"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1150
#: drivers/gpu/drm/drm_modes.c:1182 drivers/gpu/drm/drm_modes.c:1218
msgid "``u32 *bus_flags``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1149
msgid "information about pixelclk, sync and DE polarity will be stored here"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1151
msgid ""
"Sets DRM_BUS_FLAG_DE_(LOW|HIGH),  DRM_BUS_FLAG_PIXDATA_DRIVE_(POS|NEG)EDGE "
"and DISPLAY_FLAGS_SYNC_(POS|NEG)EDGE in **bus_flags** according to "
"DISPLAY_FLAGS found in **vm**"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1178
msgid "get a drm_display_mode from devicetree"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1184
#: drivers/gpu/drm/drm_modes.c:1220
msgid "``struct device_node *np``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1179
msgid "device_node with the timing specification"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1180
#: drivers/gpu/drm/drm_modes.c:1216
msgid "will be set to the return value"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1181
#: drivers/gpu/drm/drm_modes.c:1217
msgid "information about pixelclk, sync and DE polarity"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1183
msgid "``int index``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1182
msgid "index into the list of display timings in devicetree"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1183
msgid ""
"This function is expensive and should only be used, if only one mode is to "
"be read from DT. To get multiple modes start with of_get_display_timings and "
"work with that instead."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1188
msgid ""
"0 on success, a negative errno code when no of videomode node was found."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1214
msgid "get a panel-timing drm_display_mode from devicetree"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1215
msgid "device_node with the panel-timing specification"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1218
msgid ""
"The mandatory Device Tree properties width-mm and height-mm are read and set "
"on the display mode."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1222
msgid "Zero on success, negative error code on failure."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1264
msgid "set the name on a mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1265
msgid "name will be set in this mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1266
msgid ""
"Set the name of **mode** to a standard format which is <hdisplay>x<vdisplay> "
"with an optional 'i' suffix for interlaced modes."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1281
msgid "get the vrefresh of a mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1282
#: drivers/gpu/drm/drm_modes.c:1335
msgid "mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1284
msgid "**modes**'s vrefresh rate in Hz, rounded to the nearest integer."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1312
msgid "Fetches hdisplay/vdisplay for given mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1313
msgid "mode to query"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1315
msgid "``int *hdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1314
msgid "hdisplay value to fill in"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1316
msgid "``int *vdisplay``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1315
msgid "vdisplay value to fill in"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1316
msgid ""
"The vdisplay value will be doubled if the specified mode is a stereo mode of "
"the appropriate layout."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1334
msgid "set CRTC modesetting timing parameters"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1340
msgid "``struct drm_display_mode *p``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1337
msgid "``int adjust_flags``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1336
msgid "a combination of adjustment flags"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1337
msgid ""
"Setup the CRTC modesetting timing parameters for **p**, adjusting if "
"necessary."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1339
msgid ""
"The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of "
"interlaced modes."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1341
msgid ""
"The CRTC_STEREO_DOUBLE flag can be used to compute the timings for buffers "
"containing two eyes (only adjust the timings when needed, eg. for \"frame "
"packing\" or \"side by side full\")."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1344
msgid ""
"The CRTC_NO_DBLSCAN and CRTC_NO_VSCAN flags request that adjustment *not* be "
"performed for doublescan and vscan > 1 modes respectively."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1413
msgid "copy the mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1419
#: drivers/gpu/drm/drm_modes.c:1436
msgid "``struct drm_display_mode *dst``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1414
#: drivers/gpu/drm/drm_modes.c:1431
msgid "mode to overwrite"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1416
#: drivers/gpu/drm/drm_modes.c:1433
msgid "``const struct drm_display_mode *src``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1415
#: drivers/gpu/drm/drm_modes.c:1432
msgid "mode to copy"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1416
msgid ""
"Copy an existing mode into another mode, preserving the list head of the "
"destination mode."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1430
msgid "initialize the mode from another mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1433
msgid ""
"Copy an existing mode into another mode, zeroing the list head of the "
"destination mode. Typically used to guarantee the list head is not left with "
"stack garbage in on-stack modes."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1447
msgid "allocate and duplicate an existing mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1448
msgid "drm_device to allocate the duplicated mode for"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1449
msgid "mode to duplicate"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1450
msgid ""
"Just allocate a new mode, copy the existing mode into it, and return a "
"pointer to it.  Used to create new instances of established modes."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1454
msgid "Pointer to duplicated mode on success, NULL on error."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1521
msgid "test modes for (partial) equality"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1527
#: drivers/gpu/drm/drm_modes.c:1572 drivers/gpu/drm/drm_modes.c:1594
#: drivers/gpu/drm/drm_modes.c:1615
msgid "``const struct drm_display_mode *mode1``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1522
#: drivers/gpu/drm/drm_modes.c:1567 drivers/gpu/drm/drm_modes.c:1589
#: drivers/gpu/drm/drm_modes.c:1610
msgid "first mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1524
#: drivers/gpu/drm/drm_modes.c:1569 drivers/gpu/drm/drm_modes.c:1591
#: drivers/gpu/drm/drm_modes.c:1612
msgid "``const struct drm_display_mode *mode2``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1523
#: drivers/gpu/drm/drm_modes.c:1568 drivers/gpu/drm/drm_modes.c:1590
#: drivers/gpu/drm/drm_modes.c:1611
msgid "second mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1525
msgid "``unsigned int match_flags``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1524
msgid "which parts need to match (DRM_MODE_MATCH_*)"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1525
#: drivers/gpu/drm/drm_modes.c:1569
msgid "Check to see if **mode1** and **mode2** are equivalent."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1528
msgid "True if the modes are (partially) equal, false otherwise."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1566
#: drivers/gpu/drm/drm_modes.c:1588 drivers/gpu/drm/drm_modes.c:1609
msgid "test modes for equality"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1572
#: drivers/gpu/drm/drm_modes.c:1595 drivers/gpu/drm/drm_modes.c:1616
msgid "True if the modes are equal, false otherwise."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1591
msgid ""
"Check to see if **mode1** and **mode2** are equivalent, but don't check the "
"pixel clocks."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1612
msgid ""
"Check to see if **mode1** and **mode2** are equivalent, but don't check the "
"pixel clocks nor the stereo layout."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1659
msgid "make sure the mode is somewhat sane"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1661
#: drivers/gpu/drm/drm_modes.c:1689 drivers/gpu/drm/drm_modes.c:1717
msgid "mode to check"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1662
msgid ""
"First do basic validation on the mode, and then allow the driver to check "
"for device/driver specific limitations via the optional :c:type:"
"`drm_mode_config_helper_funcs.mode_valid <drm_mode_config_helper_funcs>` "
"hook."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1667
#: drivers/gpu/drm/drm_modes.c:1698 drivers/gpu/drm/drm_modes.c:1723
msgid "The mode status"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1688
msgid "make sure modes adhere to size constraints"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1691
msgid "``int maxX``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1690
msgid "maximum width"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1692
msgid "``int maxY``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1691
msgid "maximum height"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1692
msgid ""
"This function is a helper which can be used to validate modes against size "
"limitations of the DRM device/connector. If a mode is too big its status "
"member is updated with the appropriate validation failure code. The list "
"itself is not changed."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1716
msgid "add 'ycbcr420-only' modes only when allowed"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1718
msgid "drm connector under action"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1719
msgid ""
"This function is a helper which can be used to filter out any YCBCR420 only "
"mode, when the source doesn't support it."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1796
msgid "remove invalid modes from mode list"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1799
#: drivers/gpu/drm/drm_modes.c:1871
msgid "``struct list_head *mode_list``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1798
msgid "list of modes to check"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1800
msgid "``bool verbose``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1799
msgid "be verbose about it"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1800
msgid ""
"This helper function can be used to prune a display mode list after "
"validation has been completed. All modes whose status is not MODE_OK will be "
"removed from the list, and if **verbose** the status code and mode name is "
"also printed to dmesg."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1865
msgid "sort mode list"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1866
msgid "list of drm_display_mode structures to sort"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1867
msgid ""
"Sort **mode_list** by favorability, moving good modes to the head of the "
"list."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1877
msgid "update the mode list for the connector"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1878
msgid "the connector to update"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1879
msgid ""
"This moves the modes from the **connector** probed_modes list to the actual "
"mode list. It compares the probed mode against the current list and only "
"adds different/new modes."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:1883
msgid ""
"This is just a helper functions doesn't validate any modes itself and also "
"doesn't prune any invalid modes. Callers need to do that themselves."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2338
msgid "parse command line modeline for connector"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2344
msgid "``const char *mode_option``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2339
msgid "optional per connector mode option"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2341
msgid "``const struct drm_connector *connector``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2340
msgid "connector to parse modeline for"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2342
msgid "``struct drm_cmdline_mode *mode``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2341
msgid "preallocated drm_cmdline_mode structure to fill out"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2342
msgid ""
"This parses **mode_option** command line modeline for modes and options to "
"configure the connector."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2345
msgid ""
"This uses the same parameters as the fb modedb.c, except for an extra force-"
"enable, force-enable-digital and force-disable bit at the end::"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2350
msgid ""
"Additionals options can be provided following the mode, using a comma to "
"separate each option. Valid options can be found in Documentation/fb/modedb."
"rst."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2354
msgid ""
"The intermediate drm_cmdline_mode structure is required to store additional "
"options from the command line modline like the force-enable/disable flag."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2358
msgid "True if a valid modeline has been parsed, false otherwise."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2532
msgid "convert a command line modeline into a DRM display mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2533
msgid "DRM device to create the new mode for"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2535
msgid "``struct drm_cmdline_mode *cmd``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2534
msgid "input command line modeline"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2536
msgid "Pointer to converted mode on success, NULL on error."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2701
msgid "if a given videomode can be only supported in YCBCR420 output format"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2707
#: drivers/gpu/drm/drm_modes.c:2727 drivers/gpu/drm/drm_modes.c:2746
msgid "``const struct drm_display_info *display``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2704
msgid "display under action"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2705
#: drivers/gpu/drm/drm_modes.c:2725 drivers/gpu/drm/drm_modes.c:2744
msgid "video mode to be tested."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2707
#: drivers/gpu/drm/drm_modes.c:2746
msgid "true if the mode can be supported in YCBCR420 format false if not."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2721
msgid ""
"if a given videomode can be supported in YCBCR420 output format also (along "
"with RGB/YCBCR444/422)"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2724
#: drivers/gpu/drm/drm_modes.c:2743
msgid "display under action."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2727
msgid "true if the mode can be support YCBCR420 format false if not."
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2740
msgid "if a given videomode can be supported in YCBCR420 output format"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2759
msgid "Sets the preferred mode of a connector"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2760
msgid "connector whose mode list should be processed"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2762
msgid "``int hpref``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2761
msgid "horizontal resolution of preferred mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2763
msgid "``int vpref``"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2762
msgid "vertical resolution of preferred mode"
msgstr ""

#: ../../../gpu/drm-kms:422: drivers/gpu/drm/drm_modes.c:2763
msgid ""
"Marks a mode as preferred if it matches the resolution specified by "
"**hpref** and **vpref**."
msgstr ""

#: ../../../gpu/drm-kms.rst:426
msgid "Connector Abstraction"
msgstr ""

#: ../../../gpu/drm-kms:428: drivers/gpu/drm/drm_connector.c:47
msgid ""
"In DRM connectors are the general abstraction for display sinks, and include "
"also fixed panels or anything else that can display pixels in some form. As "
"opposed to all other KMS objects representing hardware (like CRTC, encoder "
"or plane abstractions) connectors can be hotplugged and unplugged at "
"runtime. Hence they are reference-counted using drm_connector_get() and "
"drm_connector_put()."
msgstr ""

#: ../../../gpu/drm-kms:428: drivers/gpu/drm/drm_connector.c:54
msgid ""
"KMS driver must create, initialize, register and attach at a :c:type:`struct "
"drm_connector <drm_connector>` for each such sink. The instance is created "
"as other KMS objects and initialized by setting the following fields. The "
"connector is initialized with a call to drm_connector_init() with a pointer "
"to the :c:type:`struct drm_connector_funcs <drm_connector_funcs>` and a "
"connector type, and then exposed to userspace with a call to "
"drm_connector_register()."
msgstr ""

#: ../../../gpu/drm-kms:428: drivers/gpu/drm/drm_connector.c:61
msgid ""
"Connectors must be attached to an encoder to be used. For devices that map "
"connectors to encoders 1:1, the connector should be attached at "
"initialization time with a call to drm_connector_attach_encoder(). The "
"driver must also set the :c:type:`drm_connector.encoder <drm_connector>` "
"field to point to the attached encoder."
msgstr ""

#: ../../../gpu/drm-kms:428: drivers/gpu/drm/drm_connector.c:67
msgid ""
"For connectors which are not fixed (like built-in panels) the driver needs "
"to support hotplug notifications. The simplest way to do that is by using "
"the probe helpers, see drm_kms_helper_poll_init() for connectors which don't "
"have hardware support for hotplug interrupts. Connectors with hardware "
"hotplug support can instead use e.g. drm_helper_hpd_irq_event()."
msgstr ""

#: ../../../gpu/drm-kms.rst:432
msgid "Connector Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:62
msgid "status for a :c:type:`drm_connector`"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:68
msgid "``connector_status_connected``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:69
msgid ""
"The connector is definitely connected to a sink device, and can be enabled."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:72
msgid "``connector_status_disconnected``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:73
msgid ""
"The connector isn't connected to a sink device which can be autodetect. For "
"digital outputs like DP or HDMI (which can be realiable probed) this means "
"there's really nothing there. It is driver-dependent whether a connector "
"with this status can be lit up or not."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:79
msgid "``connector_status_unknown``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:80
msgid ""
"The connector's status could not be reliably detected. This happens when "
"probing would either cause flicker (like load-detection when the connector "
"is in use), or when a hardware resource isn't available (like when load-"
"detection needs a free CRTC). It should be possible to light up the "
"connector with one of the listed fallback modes. For default configuration "
"userspace should only try to light up connectors with unknown status when "
"there's not connector with **connector_status_connected**."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:63
msgid ""
"This enum is used to track the connector status. There are no separate "
"#defines for the uapi!"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:95
msgid "userspace registration status for a :c:type:`drm_connector`"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:101
msgid "``DRM_CONNECTOR_INITIALIZING``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:102
msgid ""
"The connector has just been created, but has yet to be exposed to userspace. "
"There should be no additional restrictions to how the state of this "
"connector may be modified."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:107
msgid "``DRM_CONNECTOR_REGISTERED``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:108
msgid ""
"The connector has been fully initialized and registered with sysfs, as such "
"it has been exposed to userspace. There should be no additional restrictions "
"to how the state of this connector may be modified."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:113
msgid "``DRM_CONNECTOR_UNREGISTERED``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:114
msgid ""
"The connector has either been exposed to userspace and has since been "
"unregistered and removed from userspace, or the connector was unregistered "
"before it had a chance to be exposed to userspace (e.g. still in the "
"**DRM_CONNECTOR_INITIALIZING** state). When a connector is unregistered, "
"there are additional restrictions to how its state may be modified:"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:122
msgid ""
"An unregistered connector may only have its DPMS changed from On->Off. Once "
"DPMS is changed to Off, it may not be switched back to On."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:125
msgid ""
"Modesets are not allowed on unregistered connectors, unless they would "
"result in disabling its assigned CRTCs. This means disabling a CRTC on an "
"unregistered connector is OK, but enabling one is not."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:129
msgid ""
"Removing a CRTC from an unregistered connector is OK, but new CRTCs may "
"never be assigned to an unregistered connector."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:96
msgid ""
"This enum is used to track the status of initializing a connector and "
"registering it with userspace, so that DRM can prevent bogus modesets on "
"connectors that no longer exist."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:152
msgid "Analog TV output mode"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:158
msgid "``DRM_MODE_TV_MODE_NTSC``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:159
msgid "CCIR System M (aka 525-lines) together with the NTSC Color Encoding."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:162
msgid "``DRM_MODE_TV_MODE_NTSC_443``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:163
msgid ""
"Variant of **DRM_MODE_TV_MODE_NTSC**. Uses a color subcarrier frequency of "
"4.43 MHz."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:167
msgid "``DRM_MODE_TV_MODE_NTSC_J``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:168
msgid ""
"Variant of **DRM_MODE_TV_MODE_NTSC** used in Japan. Uses a black level "
"equals to the blanking level."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:172
msgid "``DRM_MODE_TV_MODE_PAL``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:173
msgid "CCIR System B together with the PAL color system."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:176
msgid "``DRM_MODE_TV_MODE_PAL_M``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:177
msgid "CCIR System M (aka 525-lines) together with the PAL color encoding"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:180
msgid "``DRM_MODE_TV_MODE_PAL_N``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:181
msgid ""
"CCIR System N together with the PAL color encoding. It uses 625 lines, but "
"has a color subcarrier frequency of 3.58MHz, the SECAM color space, and "
"narrower channels compared to most of the other PAL variants."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:186
msgid "``DRM_MODE_TV_MODE_SECAM``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:187
msgid "CCIR System B together with the SECAM color system."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:190
msgid "``DRM_MODE_TV_MODE_MONOCHROME``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:191
#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2035
msgid ""
"Use timings appropriate to the DRM mode, including equalizing pulses for a "
"525-line or 625-line mode, with no pedestal or color encoding."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:195
msgid "``DRM_MODE_TV_MODE_MAX``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:196
msgid "Number of analog TV output modes."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:198
msgid "Internal implementation detail; this is not uABI."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:153
msgid ""
"This enum is used to indicate the TV output mode used on an analog TV "
"connector."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:156
msgid ""
"WARNING: The values of this enum is uABI since they're exposed in the \"TV "
"mode\" connector property."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:223
msgid "sink's scrambling support."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:227
msgid "``supported``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:228
msgid "scrambling supported for rates > 340 Mhz."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:231
msgid "``low_rates``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:232
msgid "scrambling supported for rates <= 340 Mhz."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:258
msgid "DSC capabilities of HDMI sink"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:265
msgid "``v_1p2``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:266
msgid "flag for dsc1.2 version support by sink"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:268
msgid "``native_420``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:269
msgid "Does sink support DSC with 4:2:0 compression"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:272
msgid "``all_bpp``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:273
msgid "Does sink support all bpp with 4:4:4: or 4:2:2 compressed formats"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:278
msgid "``bpc_supported``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:279
msgid "compressed bpc supported by sink : 10, 12 or 16 bpc"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:282
msgid "``max_slices``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:283
msgid "maximum number of Horizontal slices supported by"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:285
msgid "``clk_per_slice``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:286
msgid "max pixel clock in MHz supported per slice"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:288
#: include/drm/drm_connector.h:330
msgid "``max_lanes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:289
msgid "dsc max lanes supported for Fixed rate Link training"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:291
#: include/drm/drm_connector.h:327
msgid "``max_frl_rate_per_lane``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:292
msgid "maximum frl rate with DSC per lane"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:294
msgid "``total_chunk_kbytes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:295
msgid "max size of chunks in KBs supported per line"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:259
msgid ""
"Describes the DSC support provided by HDMI 2.1 sink. The information is "
"fetched fom additional HFVSDB blocks defined for HDMI 2.1."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:299
msgid "runtime information about the connected HDMI sink"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:305
msgid "``scdc``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:306
msgid "sink's scdc support and capabilities"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:309
msgid "``y420_vdb_modes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:310
msgid ""
"bitmap of modes which can support ycbcr420 output only (not normal RGB/"
"YCBCR444/422 outputs). The max VIC defined by the CEA-861-G spec is 219, so "
"the size is 256 bits to map up to 256 VICs."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:317
msgid "``y420_cmdb_modes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:318
msgid ""
"bitmap of modes which can support ycbcr420 output also, along with normal "
"HDMI outputs. The max VIC defined by the CEA-861-G spec is 219, so the size "
"is 256 bits to map up to 256 VICs."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:324
msgid "``y420_dc_modes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:325
msgid "bitmap of deep color support index"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:328
msgid "support fixed rate link"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:331
msgid "supported by sink"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:333
msgid "``dsc_cap``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:334
msgid "DSC capabilities of the sink"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:300
msgid ""
"Describes if a given display supports advanced HDMI 2.0 features. This "
"information is available in CEA-861-F extension blocks (like HF-VSDB)."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:338
msgid "connector's link_status property value"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:344
msgid "``DRM_LINK_STATUS_GOOD``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:345
msgid "DP Link is Good as a result of successful link training"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:348
msgid "``DRM_LINK_STATUS_BAD``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:349
msgid "DP Link is BAD as a result of link training failure"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:339
msgid ""
"This enum is used as the connector's link status property value. It is set "
"to the values defined in uapi."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:354
msgid "panel_orientation info for :c:type:`drm_display_info`"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:360
msgid "``DRM_MODE_PANEL_ORIENTATION_UNKNOWN``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:361
msgid ""
"The drm driver has not provided any panel orientation information (normal "
"for non panels) in this case the \"panel orientation\" connector prop will "
"not be attached."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:367
msgid "``DRM_MODE_PANEL_ORIENTATION_NORMAL``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:368
msgid "The top side of the panel matches the top side of the device's casing."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:371
msgid "``DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:372
msgid ""
"The top side of the panel matches the bottom side of the device's casing, "
"iow the panel is mounted upside-down."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:376
msgid "``DRM_MODE_PANEL_ORIENTATION_LEFT_UP``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:377
msgid "The left side of the panel matches the top side of the device's casing."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:380
msgid "``DRM_MODE_PANEL_ORIENTATION_RIGHT_UP``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:381
msgid ""
"The right side of the panel matches the top side of the device's casing."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:355
msgid ""
"This enum is used to track the (LCD) panel orientation. There are no "
"separate #defines for the uapi!"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:383
msgid "Broadcast RGB Selection for an HDMI **drm_connector**"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:389
msgid "``DRM_HDMI_BROADCAST_RGB_AUTO``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:390
msgid "The RGB range is selected automatically based on the mode."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:393
msgid "``DRM_HDMI_BROADCAST_RGB_FULL``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:394
msgid "Full range RGB is forced."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:396
msgid "``DRM_HDMI_BROADCAST_RGB_LIMITED``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:397
msgid "Limited range RGB is forced."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:409
msgid "Panel's Monitor range in EDID for :c:type:`drm_display_info`"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:415
msgid "``min_vfreq``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:416
msgid ""
"This is the min supported refresh rate in Hz from EDID's detailed monitor "
"range."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:417
msgid "``max_vfreq``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:418
msgid ""
"This is the max supported refresh rate in Hz from EDID's detailed monitor "
"range"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:410
msgid ""
"This struct is used to store a frequency range supported by panel as parsed "
"from EDID's detailed monitor range descriptor block."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:426
msgid ""
"Panel's luminance range for :c:type:`drm_display_info`. Calculated using "
"data in EDID"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:432
msgid "``min_luminance``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:433
msgid "This is the min supported luminance value"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:434
msgid "``max_luminance``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:435
msgid "This is the max supported luminance value"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:427
msgid ""
"This struct is used to store a luminance range supported by panel as "
"calculated using data from EDID's static hdr metadata."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:442
msgid "privacy screen status"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:448
msgid "``PRIVACY_SCREEN_DISABLED``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:449
msgid "The privacy-screen on the panel is disabled"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:451
msgid "``PRIVACY_SCREEN_ENABLED``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:452
msgid "The privacy-screen on the panel is enabled"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:454
msgid "``PRIVACY_SCREEN_DISABLED_LOCKED``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:455
msgid ""
"The privacy-screen on the panel is disabled and locked (cannot be changed)"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:457
msgid "``PRIVACY_SCREEN_ENABLED_LOCKED``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:458
msgid ""
"The privacy-screen on the panel is enabled and locked (cannot be changed)"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:443
msgid ""
"This enum is used to track and control the state of the integrated privacy "
"screen present on some display panels, via the \"privacy-screen sw-state\" "
"and \"privacy-screen hw-state\" properties. Note the _LOCKED enum values are "
"only valid for the \"privacy-screen hw-state\" property."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:466
msgid "color space"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:472
msgid "``DRM_MODE_COLORIMETRY_DEFAULT``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:473
#: include/drm/drm_connector.h:476
msgid "Driver specific behavior."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:475
msgid "``DRM_MODE_COLORIMETRY_NO_DATA``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:478
msgid "``DRM_MODE_COLORIMETRY_SMPTE_170M_YCC``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:479
msgid "(HDMI) SMPTE ST 170M colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:482
msgid "``DRM_MODE_COLORIMETRY_BT709_YCC``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:483
msgid "(HDMI, DP) ITU-R BT.709 colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:486
msgid "``DRM_MODE_COLORIMETRY_XVYCC_601``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:487
msgid "(HDMI, DP) xvYCC601 colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:490
msgid "``DRM_MODE_COLORIMETRY_XVYCC_709``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:491
msgid "(HDMI, DP) xvYCC709 colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:494
msgid "``DRM_MODE_COLORIMETRY_SYCC_601``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:495
msgid "(HDMI, DP) sYCC601 colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:498
msgid "``DRM_MODE_COLORIMETRY_OPYCC_601``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:499
msgid "(HDMI, DP) opYCC601 colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:502
msgid "``DRM_MODE_COLORIMETRY_OPRGB``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:503
msgid "(HDMI, DP) opRGB colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:506
msgid "``DRM_MODE_COLORIMETRY_BT2020_CYCC``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:507
msgid ""
"(HDMI, DP) ITU-R BT.2020 Y'c C'bc C'rc (constant luminance) colorimetry "
"format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:510
msgid "``DRM_MODE_COLORIMETRY_BT2020_RGB``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:511
msgid "(HDMI, DP) ITU-R BT.2020 R' G' B' colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:514
msgid "``DRM_MODE_COLORIMETRY_BT2020_YCC``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:515
msgid "(HDMI, DP) ITU-R BT.2020 Y' C'b C'r colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:518
msgid "``DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:519
msgid "(HDMI) SMPTE ST 2113 P3D65 colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:522
msgid "``DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:523
msgid "(HDMI) SMPTE ST 2113 P3DCI colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:526
msgid "``DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:527
msgid "(DP) RGB wide gamut fixed point colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:530
msgid "``DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:531
msgid ""
"(DP) RGB wide gamut floating point (scRGB (IEC 61966-2-2)) colorimetry format"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:535
msgid "``DRM_MODE_COLORIMETRY_BT601_YCC``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:536
msgid ""
"(DP) ITU-R BT.601 colorimetry format The DP spec does not say whether this "
"is the 525 or the 625 line version."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:541
msgid "``DRM_MODE_COLORIMETRY_COUNT``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:542
msgid "Not a valid value; merely used four counting"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:467
msgid ""
"This enum is a consolidated colorimetry list supported by HDMI and DP "
"protocol standard. The respective connectors will register a property with "
"the subset of this list (supported by that respective protocol). Userspace "
"will set the colorspace through a colorspace property which will be created "
"and exposed to userspace."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:474
msgid ""
"DP definitions come from the DP v2.0 spec HDMI definitions come from the "
"CTA-861-H spec"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:560
msgid "bus_flags info for :c:type:`drm_display_info`"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:566
msgid "``DRM_BUS_FLAG_DE_LOW``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:567
msgid "The Data Enable signal is active low"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:569
msgid "``DRM_BUS_FLAG_DE_HIGH``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:570
msgid "The Data Enable signal is active high"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:572
msgid "``DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:573
msgid "Data is driven on the rising edge of the pixel clock"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:575
msgid "``DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:576
msgid "Data is driven on the falling edge of the pixel clock"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:578
msgid "``DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:579
msgid "Data is sampled on the rising edge of the pixel clock"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:581
msgid "``DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:582
msgid "Data is sampled on the falling edge of the pixel clock"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:584
msgid "``DRM_BUS_FLAG_DATA_MSB_TO_LSB``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:585
msgid "Data is transmitted MSB to LSB on the bus"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:587
msgid "``DRM_BUS_FLAG_DATA_LSB_TO_MSB``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:588
msgid "Data is transmitted LSB to MSB on the bus"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:590
msgid "``DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:591
msgid "Sync signals are driven on the rising edge of the pixel clock"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:593
msgid "``DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:594
msgid "Sync signals are driven on the falling edge of the pixel clock"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:596
msgid "``DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:597
msgid "Sync signals are sampled on the rising edge of the pixel clock"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:599
msgid "``DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:600
msgid "Sync signals are sampled on the falling edge of the pixel clock"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:602
msgid "``DRM_BUS_FLAG_SHARP_SIGNALS``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:603
msgid "Set if the Sharp-specific signals (SPL, CLS, PS, REV) must be used"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:561
msgid ""
"This enum defines signal polarities and clock edge information for signals "
"on a bus as bitmask flags."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:564
msgid ""
"The clock edge information is conveyed by two sets of symbols, "
"DRM_BUS_FLAGS_*_DRIVE_\\* and DRM_BUS_FLAGS_*_SAMPLE_\\*. When this enum is "
"used to describe a bus from the point of view of the transmitter, the "
"\\*_DRIVE_\\* flags should be used. When used from the point of view of the "
"receiver, the \\*_SAMPLE_\\* flags should be used. The \\*_DRIVE_\\* and "
"\\*_SAMPLE_\\* flags alias each other, with the \\*_SAMPLE_POSEDGE and "
"\\*_SAMPLE_NEGEDGE flags being equal to \\*_DRIVE_NEGEDGE and "
"\\*_DRIVE_POSEDGE respectively. This simplifies code as signals are usually "
"sampled on the opposite edge of the driving edge. Transmitters and receivers "
"may however need to take other signal timings into account to convert "
"between driving and sample edges."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:671
msgid "runtime data about the connected sink"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:684
msgid "Physical width in mm."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:689
msgid "Physical height in mm."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:693
msgid "``bpc``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:694
msgid "Maximum bits per color channel. Used by HDMI and DP outputs."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:698
msgid "``subpixel_order``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:699
msgid "Subpixel order of LCD panels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:708
#: include/drm/drm_connector.h:1733
msgid "``panel_orientation``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:709
msgid ""
"Read only connector property for built-in panels, indicating the orientation "
"of the panel vs the device's casing. drm_connector_init() sets this to "
"DRM_MODE_PANEL_ORIENTATION_UNKNOWN. When not UNKNOWN this gets used by the "
"drm_fb_helpers to rotate the fb to compensate and gets exported as prop to "
"userspace."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:717
msgid "``color_formats``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:718
msgid ""
"HDMI Color formats, selects between RGB and YCrCb modes. Used "
"DRM_COLOR_FORMAT\\_ defines, which are _not_ the same ones as used to "
"describe the pixel format in framebuffers, and also don't match the formats "
"in **bus_formats** which are shared with v4l."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:725
msgid "``bus_formats``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:726
msgid ""
"Pixel data format on the wire, somewhat redundant with **color_formats**. "
"Array of size **num_bus_formats** encoded using MEDIA_BUS_FMT\\_ defines "
"shared with v4l and media drivers."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:731
msgid "``num_bus_formats``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:732
msgid "Size of **bus_formats** array."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:736
msgid "``bus_flags``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:737
msgid ""
"Additional information (like pixel signal polarity) for the pixel data on "
"the bus, using :c:type:`enum drm_bus_flags <drm_bus_flags>` values "
"DRM_BUS_FLAGS\\_."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:743
msgid "``max_tmds_clock``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:744
msgid ""
"Maximum TMDS clock rate supported by the sink in kHz. 0 means undefined."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:749
msgid "``dvi_dual``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:750
msgid "Dual-link DVI sink?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:754
msgid "``is_hdmi``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:755
msgid "True if the sink is an HDMI device."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:757
msgid ""
"This field shall be used instead of calling drm_detect_hdmi_monitor() when "
"possible."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:762
msgid "``has_audio``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:763
msgid "True if the sink supports audio."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:765
msgid ""
"This field shall be used instead of calling drm_detect_monitor_audio() when "
"possible."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:770
msgid "``has_hdmi_infoframe``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:771
msgid "Does the sink support the HDMI infoframe?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:775
msgid "``rgb_quant_range_selectable``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:776
msgid "Does the sink support selecting the RGB quantization range?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:781
msgid "``edid_hdmi_rgb444_dc_modes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:782
msgid ""
"Mask of supported hdmi deep color modes in RGB 4:4:4. Even more stuff "
"redundant with **bus_formats**."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:787
msgid "``edid_hdmi_ycbcr444_dc_modes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:788
msgid ""
"Mask of supported hdmi deep color modes in YCbCr 4:4:4. Even more stuff "
"redundant with **bus_formats**."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:793
msgid "``cea_rev``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:794
msgid "CEA revision of the HDMI sink."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:798
#: include/drm/drm_connector.h:1148 include/drm/drm_connector.h:2295
msgid "``hdmi``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:799
msgid "advance features of a HDMI sink."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:803
msgid "``hdr_sink_metadata``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:804
msgid "HDR Metadata Information read from sink"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:808
msgid "``non_desktop``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:809
msgid "Non desktop display (HMD)."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:813
msgid "``monitor_range``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:814
msgid "Frequency range supported by monitor range descriptor"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:818
msgid "``luminance_range``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:819
msgid "Luminance range supported by panel"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:823
msgid "``mso_stream_count``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:824
msgid ""
"eDP Multi-SST Operation (MSO) stream count from the DisplayID VESA vendor "
"block. 0 for conventional Single-Stream Transport (SST), or 2 or 4 MSO "
"streams."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:830
msgid "``mso_pixel_overlap``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:831
msgid "eDP MSO segment pixel overlap, 0-8 pixels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:835
msgid "``max_dsc_bpp``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:836
msgid ""
"Maximum DSC target bitrate, if it is set to 0 the monitor's default value is "
"used instead."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:841
msgid "``vics``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:842
msgid "Array of vics_len VICs. Internal to EDID parsing."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:846
msgid "``vics_len``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:847
msgid "Number of elements in vics. Internal to EDID parsing."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:851
msgid "``quirks``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:852
msgid ""
"EDID based quirks. DRM core and drivers can query the **drm_edid_quirk** "
"quirks using drm_edid_has_quirk(), the rest of the quirks also tracked here "
"are internal to EDID parsing."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:858
msgid "``source_physical_address``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:859
msgid ""
"Source Physical Address from HDMI Vendor-Specific Data Block, for CEC usage."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:862
msgid "Defaults to CEC_PHYS_ADDR_INVALID (0xffff)."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:672
msgid ""
"Describes a given display (e.g. CRT or flat panel) and its limitations. For "
"fixed display sinks like built-in panels there's not much difference between "
"this and :c:type:`struct drm_connector <drm_connector>`. But for sinks with "
"a real cable this structure is meant to describe all the things at the other "
"end of the cable."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:677
msgid ""
"For sinks which provide an EDID this can be filled out by calling "
"drm_add_edid_modes()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:871
msgid "TV connector related margins"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:878
msgid "``bottom``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:879
msgid "Bottom margin in pixels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:883
msgid "``left``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:884
msgid "Left margin in pixels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:888
msgid "``right``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:889
msgid "Right margin in pixels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:893
msgid "``top``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:894
msgid "Top margin in pixels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:872
msgid ""
"Describes the margins in pixels to put around the image on TV connectors to "
"deal with overscan."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:899
msgid "TV connector related states"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:900
msgid "``select_subconnector``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:901
msgid "selected subconnector"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:901
msgid "``subconnector``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:902
msgid "detected subconnector"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:902
#: include/drm/drm_connector.h:1707
msgid "``margins``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:903
msgid "TV margins"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:903
msgid "``legacy_mode``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:904
msgid "Legacy TV mode, driver specific value"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:905
msgid "TV mode"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:905
msgid "``brightness``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:906
msgid "brightness in percent"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:906
msgid "``contrast``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:907
msgid "contrast in percent"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:907
msgid "``flicker_reduction``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:908
msgid "flicker reduction in percent"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:908
msgid "``overscan``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:909
msgid "overscan in percent"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:909
msgid "``saturation``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:910
msgid "saturation in percent"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:910
msgid "``hue``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:911
msgid "hue in percent"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:927
msgid "HDMI Infoframe container"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:931
#: include/drm/drm_connector.h:1880 ../../../gpu/drm-kms:527:
#: include/drm/drm_property.h:208
msgid "``data``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:932
msgid "HDMI Infoframe structure"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:936
msgid "``set``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:937
msgid "Is the content of **data** valid?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1003
msgid "mutable connector state"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1007
msgid "backpointer to the connector"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1011
msgid "CRTC to connect connector to, NULL if disabled."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1013
msgid ""
"Do not change this directly, use drm_atomic_set_crtc_for_connector() instead."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1018
msgid "``best_encoder``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1019
msgid ""
"Used by the atomic helpers to select the encoder, through the :c:type:"
"`drm_connector_helper_funcs.atomic_best_encoder "
"<drm_connector_helper_funcs>` or :c:type:`drm_connector_helper_funcs."
"best_encoder <drm_connector_helper_funcs>` callbacks."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1023
msgid ""
"This is also used in the atomic helpers to map encoders to their current and "
"previous connectors, see drm_atomic_get_old_connector_for_encoder() and "
"drm_atomic_get_new_connector_for_encoder()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1028
msgid ""
"NOTE: Atomic drivers must fill this out (either themselves or through "
"helpers), for otherwise the GETCONNECTOR and GETENCODER IOCTLs will not "
"return correct data to userspace."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1036
msgid "``link_status``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1037
msgid ""
"Connector link_status to keep track of whether link is GOOD or BAD to notify "
"userspace if retraining is necessary."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1046
msgid "Tracks the pending commit to prevent use-after-free conditions."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1048
msgid "Is only set when **crtc** is NULL."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1051
msgid "``tv``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1052
msgid "TV connector state"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1055
msgid "``self_refresh_aware``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1056
msgid ""
"This tracks whether a connector is aware of the self refresh state. It "
"should be set to true for those connector implementations which understand "
"the self refresh state. This is needed since the crtc registers the self "
"refresh helpers and it doesn't know if the connectors downstream have "
"implemented self refresh entry/exit."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1062
msgid ""
"Drivers should set this to true in atomic_check if they know how to handle "
"self_refresh requests."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1070
msgid "Connector property to control the HDMI infoframe aspect ratio setting."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1073
msgid ""
"The ``DRM_MODE_PICTURE_ASPECT_``\\* values much match the values for :c:type:"
"`enum hdmi_picture_aspect <hdmi_picture_aspect>`"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1078
msgid "``content_type``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1079
msgid ""
"Connector property to control the HDMI infoframe content type setting. The "
"``DRM_MODE_CONTENT_TYPE_``\\* values much match the values."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1086
msgid "``hdcp_content_type``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1087
msgid ""
"Connector property to pass the type of protected content. This is most "
"commonly used for HDCP."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1092
msgid "``scaling_mode``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1093
msgid ""
"Connector property to control the upscaling, mostly used for built-in panels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1098
msgid "``content_protection``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1099
msgid ""
"Connector property to request content protection. This is most commonly used "
"for HDCP."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1104
msgid "``colorspace``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1105
msgid ""
"State variable for Connector property to request colorspace change on Sink. "
"This is most commonly used to switch to wider color gamuts like BT2020."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1111
msgid "``writeback_job``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1112
msgid "Writeback job for writeback connectors"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1114
msgid ""
"Holds the framebuffer and out-fence for a writeback connector. As the "
"writeback completion may be asynchronous to the normal commit cycle, the "
"writeback job lifetime is managed separately from the normal atomic state by "
"this object."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1119
#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:56
msgid ""
"See also: drm_writeback_queue_job() and drm_writeback_signal_completion()"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1124
msgid "``max_requested_bpc``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1125
msgid "Connector property to limit the maximum bit depth of the pixels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1130
#: include/drm/drm_connector.h:2072
msgid "``max_bpc``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1131
msgid ""
"Connector max_bpc based on the requested max_bpc property and the connector "
"bpc limitations obtained from edid."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1136
msgid "``privacy_screen_sw_state``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1137
msgid "See :ref:`Standard Connector Properties<standard_connector_properties>`"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1142
msgid "``hdr_output_metadata``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1143
msgid "DRM blob property for HDR output metadata"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1149
msgid ""
"HDMI-related variable and properties. Filled by "
"**drm_atomic_helper_connector_hdmi_check\\(\\)**."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1205
#: include/drm/drm_connector.h:1225
msgid "drm_hdmi_connector control functions"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1209
msgid "``phys_addr_invalidate``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1210
msgid "mark CEC physical address as invalid"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1212
msgid ""
"The callback to mark CEC physical address as invalid, abstracting the "
"operation."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1217
msgid "``phys_addr_set``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1218
msgid "set CEC physical address"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1220
msgid "The callback to set CEC physical address, abstracting the operation."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1229
msgid "``tmds_char_rate_valid``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1230
msgid ""
"This callback is invoked at atomic_check time to figure out whether a "
"particular TMDS character rate is supported by the driver."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1234
msgid "The **tmds_char_rate_valid** callback is optional."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1238
msgid ""
"Either :c:type:`drm_mode_status.MODE_OK <drm_mode_status>` or one of the "
"failure reasons in :c:type:`enum drm_mode_status <drm_mode_status>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1248
msgid "``clear_infoframe``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1249
msgid ""
"This callback is invoked through "
"**drm_atomic_helper_connector_hdmi_update_infoframes** during a commit to "
"clear the infoframes into the hardware. It will be called multiple times, "
"once for every disabled infoframe type."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1255
msgid "The **clear_infoframe** callback is optional."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1257
#: include/drm/drm_connector.h:1274
msgid "Returns: 0 on success, a negative error code otherwise"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1265
msgid "``write_infoframe``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1266
msgid ""
"This callback is invoked through "
"**drm_atomic_helper_connector_hdmi_update_infoframes** during a commit to "
"program the infoframes into the hardware. It will be called multiple times, "
"once for every updated infoframe type."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1272
msgid "The **write_infoframe** callback is mandatory."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1283
msgid "``read_edid``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1284
msgid ""
"This callback is used by the framework as a replacement for reading the EDID "
"from connector->ddc. It is still recommended to provide connector->ddc "
"instead of implementing this callback. Returned EDID should be freed via the "
"drm_edid_free()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1289
msgid "The **read_edid** callback is optional."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1291
msgid "Returns: Valid EDID on success, NULL in case of failure."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1299
msgid "control connectors on a given device"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1307
#: include/drm/drm_connector.h:2134
msgid "``dpms``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1308
msgid ""
"Legacy entry point to set the per-connector DPMS state. Legacy DPMS is "
"exposed as a standard property on the connector, but diverted to this "
"callback in the drm core. Note that atomic drivers don't implement the 4 "
"level DPMS support on the connector any more, but instead only have an on/"
"off \"ACTIVE\" property on the CRTC object."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1314
msgid ""
"This hook is not used by atomic drivers, remapping of the legacy DPMS "
"property is entirely handled in the DRM core."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1326
msgid ""
"Reset connector hardware and software state to off. This function isn't "
"called by the core directly, only through drm_mode_config_reset(). It's not "
"a helper hook only for historical reasons."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1330
msgid ""
"Atomic drivers can use drm_atomic_helper_connector_reset() to reset atomic "
"state using this hook."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1337
msgid "``detect``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1338
msgid ""
"Check to see if anything is attached to the connector. The parameter force "
"is set to false whilst polling, true when checking the connector due to a "
"user request. force can be used by the driver to avoid expensive, "
"destructive operations during automated probing."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1343
msgid ""
"This callback is optional, if not implemented the connector will be "
"considered as always being attached."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1346
#: include/drm/drm_connector.h:1377
msgid "FIXME:"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1348
#: include/drm/drm_connector.h:1379
msgid ""
"Note that this hook is only called by the probe helper. It's not in the "
"helper library vtable purely for historical reasons. The only DRM core entry "
"point to probe connector state is **fill_modes**."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1352
msgid ""
"Note that the helper library will already hold :c:type:`drm_mode_config."
"connection_mutex <drm_mode_config>`. Drivers which need to grab additional "
"locks to avoid races with concurrent modeset changes need to use :c:type:"
"`drm_connector_helper_funcs.detect_ctx <drm_connector_helper_funcs>` instead."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1357
msgid ""
"Also note that this callback can be called no matter the state the connector "
"is in. Drivers that need the underlying device to be powered to perform the "
"detection will first need to make sure it's been properly enabled."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1364
msgid "drm_connector_status indicating the connector's status."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1371
#: include/drm/drm_connector.h:1715 include/drm/drm_connector.h:2146
msgid "``force``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1372
msgid ""
"This function is called to update internal encoder state when the connector "
"is forced to a certain state by userspace, either through the sysfs "
"interfaces or on the kernel cmdline. In that case the **detect** callback "
"isn't called."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1387
msgid "``fill_modes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1388
msgid ""
"Entry point for output detection and basic mode validation. The driver "
"should reprobe the output if needed (e.g. when hotplug handling is "
"unreliable), add all detected modes to :c:type:`drm_connector.modes "
"<drm_connector>` and filter out any the device can't support in any "
"configuration. It also needs to filter out any modes wider or higher than "
"the parameters max_width and max_height indicate."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1395
msgid ""
"The drivers must also prune any modes no longer valid from :c:type:"
"`drm_connector.modes <drm_connector>`. Furthermore it must update :c:type:"
"`drm_connector.status <drm_connector>` and :c:type:`drm_connector.edid "
"<drm_connector>`.  If no EDID has been received for this output connector-"
">edid must be NULL."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1400
msgid ""
"Drivers using the probe helpers should use "
"drm_helper_probe_single_connector_modes() to implement this function."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1406
msgid ""
"The number of modes detected and filled into :c:type:`drm_connector.modes "
"<drm_connector>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1413
msgid ""
"This is the legacy entry point to update a property attached to the "
"connector."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1430
msgid ""
"This optional hook can be used to register additional userspace interfaces "
"attached to the connector, light backlight control, i2c, DP aux or similar "
"interfaces. It is called late in the driver load sequence from "
"drm_connector_register() when registering all the core drm connector "
"interfaces. Everything added from this callback should be unregistered in "
"the early_unregister callback."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1437
#: include/drm/drm_connector.h:1454
msgid ""
"This is called while holding :c:type:`drm_connector.mutex <drm_connector>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1448
msgid ""
"This optional hook should be used to unregister the additional userspace "
"interfaces attached to the connector from late_register(). It is called from "
"drm_connector_unregister(), early in the driver unload sequence to disable "
"userspace access before data structures are torndown."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1461
msgid ""
"Clean up connector resources. This is called at driver unload time through "
"drm_mode_config_cleanup(). It can also be called at runtime when a connector "
"is being hot-unplugged for drivers that support connector hotplugging (e.g. "
"DisplayPort MST)."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1471
msgid ""
"Duplicate the current atomic state for this connector and return it. The "
"core and helpers guarantee that any atomic state duplicated with this hook "
"and still owned by the caller (i.e. not transferred to the driver by "
"calling :c:type:`drm_mode_config_funcs.atomic_commit "
"<drm_mode_config_funcs>`) will be cleaned up by calling the "
"**atomic_destroy_state** hook in this structure."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1480
msgid ""
"Atomic drivers which don't subclass :c:type:`struct drm_connector_state "
"<drm_connector_state>` should use "
"drm_atomic_helper_connector_duplicate_state(). Drivers that subclass the "
"state structure to extend it with driver-private state should use "
"__drm_atomic_helper_connector_duplicate_state() to make sure shared state is "
"duplicated in a consistent fashion across drivers."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1486
msgid ""
"It is an error to call this hook before :c:type:`drm_connector.state "
"<drm_connector>` has been initialized correctly."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1526
msgid ""
"Do not call this function directly, use drm_atomic_connector_set_property() "
"instead."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1547
msgid ""
"0 if the property has been found, -EINVAL if the property isn't implemented "
"by the driver (which shouldn't ever happen, the core only asks for "
"properties attached to this connector). No other validation is allowed by "
"the driver. The core already checks that the property value is within the "
"range (integer, valid enum value, ...) the driver set when registering the "
"property."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1562
msgid ""
"Reads out the decoded driver-private property. This is used to implement the "
"GETCONNECTOR IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1565
msgid ""
"Do not call this function directly, use drm_atomic_connector_get_property() "
"instead."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1573
msgid ""
"0 on success, -EINVAL if the property isn't implemented by the driver (which "
"shouldn't ever happen, the core only asks for properties attached to this "
"connector)."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1585
msgid ""
"If driver subclasses :c:type:`struct drm_connector_state "
"<drm_connector_state>`, it should implement this optional hook for printing "
"additional driver specific state."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1588
msgid ""
"Do not call this directly, use drm_atomic_connector_print_state() instead."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1596
msgid "``oob_hotplug_event``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1597
msgid ""
"This will get called when a hotplug-event for a drm-connector has been "
"received from a source outside the display driver / device."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1605
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:86
msgid "``debugfs_init``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1606
msgid "Allows connectors to create connector-specific debugfs files."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1300
msgid ""
"Each CRTC may have one or more connectors attached to it.  The functions "
"below allow the core DRM code to control connectors, enumerate available "
"modes, etc."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1613
msgid "DRM Mode passed through the kernel command-line"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1623
msgid "Name of the mode."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1629
msgid "``specified``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1630
msgid "Has a mode been read from the command-line?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1636
msgid "``refresh_specified``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1637
msgid "Did the mode have a preferred refresh rate?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1643
msgid "``bpp_specified``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1644
msgid "Did the mode have a preferred BPP?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1650
msgid "``pixel_clock``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1651
msgid "Pixel Clock in kHz. Optional."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1657
msgid "``xres``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1658
msgid "Active resolution on the X axis, in pixels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1664
msgid "``yres``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1665
msgid "Active resolution on the Y axis, in pixels."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1671
msgid "``bpp``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1672
msgid "Bits per pixels for the mode."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1678
msgid "``refresh``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1679
msgid "Refresh rate, in Hertz."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1685
msgid "``rb``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1686
msgid "Do we need to use reduced blanking?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1692
msgid "``interlace``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1693
msgid "The mode is interlaced."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1699
msgid "``cvt``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1700
msgid ""
"The timings will be calculated using the VESA Coordinated Video Timings "
"instead of looking up the mode from a table."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1708
msgid ""
"Add margins to the mode calculation (1.8% of xres rounded down to 8 pixels "
"and 1.8% of yres)."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1716
msgid ""
"Ignore the hotplug state of the connector, and force its state to one of the "
"DRM_FORCE_* values."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1723
msgid "``rotation_reflection``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1724
msgid ""
"Initial rotation and reflection of the mode setup from the command line. See "
"DRM_MODE_ROTATE_* and DRM_MODE_REFLECT_*. The only rotations supported are "
"DRM_MODE_ROTATE_0 and DRM_MODE_ROTATE_180."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1734
msgid ""
"drm-connector \"panel orientation\" property override value, "
"DRM_MODE_PANEL_ORIENTATION_UNKNOWN if not set."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1741
msgid "``tv_margins``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1742
msgid "TV margins to apply to the mode."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1746
msgid "``tv_mode``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1747
msgid "TV mode standard. See DRM_MODE_TV_MODE_*."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1751
msgid "``tv_mode_specified``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1752
msgid "Did the mode have a preferred TV mode?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1614
msgid ""
"Each connector can have an initial mode with additional options passed "
"through the kernel command line. This structure allows to express those "
"parameters and will be filled by the command-line parser."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1759
msgid "DRM gemeric HDMI Codec-related structure"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1767
msgid ""
"Implementation of the HDMI codec functionality to be used by the DRM HDMI "
"Codec framework."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1774
msgid "``codec_pdev``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1775
msgid ""
"Platform device created to hold the HDMI Codec. It will be automatically "
"unregistered during drm_connector_cleanup()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1783
msgid "Mutex to protect **last_state**, **plugged_cb** and **plugged_cb_dev**."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1789
msgid "``plugged_cb``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1790
msgid ""
"Callback to be called when the HDMI sink get plugged to or unplugged from "
"this connector. This is assigned by the framework when requested by the ASoC "
"code."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1798
msgid "``plugged_cb_dev``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1799
msgid "The data for **plugged_cb\\(\\)**. It is being provided by the ASoC."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1805
msgid "``last_state``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1806
msgid ""
"Last plugged state recored by the framework. It is used to correctly report "
"the state to **plugged_cb\\(\\)**."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1813
msgid "``dai_port``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1814
msgid "The port in DT that is used for the Codec DAI."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1760
msgid ""
"HDMI drivers usually incorporate a HDMI Codec. This structure expresses the "
"generic HDMI Codec as used by the DRM HDMI Codec framework."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1866
msgid "DRM Connector CEC-related structure"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1871
msgid "protects all fields in this structure."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1876
msgid "CEC Control Functions"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1881
msgid "CEC implementation-specific data"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1886
msgid "central DRM connector control structure"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1896
msgid "``kdev``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1897
msgid "kernel device for sysfs attributes"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1898
msgid "``attr``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1899
msgid "sysfs attributes"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1901
msgid "``fwnode``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1902
msgid "associated fwnode supplied by platform firmware"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1904
msgid ""
"Drivers can set this to associate a fwnode with a connector, drivers are "
"expected to get a reference on the fwnode when setting this. "
"drm_connector_cleanup() will call fwnode_handle_put() on this."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1911
msgid ""
"List of all connectors on a **dev**, linked from :c:type:`drm_mode_config."
"connector_list <drm_mode_config>`. Protected by :c:type:`drm_mode_config."
"connector_list_lock <drm_mode_config>`, but please only use :c:type:"
"`drm_connector_list_iter` to walk this list."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1920
msgid "``global_connector_list_entry``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1921
msgid ""
"Connector entry in the global connector-list, used by "
"drm_connector_find_by_fwnode()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1928
#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:98
#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:88
#: include/drm/drm_property.h:203
msgid "base KMS object"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1935
msgid ""
"Lock for general connector state, but currently only protects "
"**registered**. Most of the connector state is still protected by :c:type:"
"`drm_mode_config.mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1942
msgid ""
"Compacted connector index, which matches the position inside the mode_config."
"list for drivers not supporting hot-add/removing. Can be used as an array "
"index. It is invariant over the lifetime of the connector."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1949
msgid "``connector_type``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1950
msgid "one of the DRM_MODE_CONNECTOR_<foo> types from drm_mode.h"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1953
msgid "``connector_type_id``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1954
msgid "index into connector type enum"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1956
msgid "``interlace_allowed``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1957
msgid ""
"Can this connector handle interlaced modes? Only used by "
"drm_helper_probe_single_connector_modes() for mode filtering."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1962
msgid "``doublescan_allowed``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1963
msgid ""
"Can this connector handle doublescan? Only used by "
"drm_helper_probe_single_connector_modes() for mode filtering."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1968
msgid "``stereo_allowed``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1969
msgid ""
"Can this connector handle stereo modes? Only used by "
"drm_helper_probe_single_connector_modes() for mode filtering."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1975
msgid "``ycbcr_420_allowed``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1976
msgid ""
"This bool indicates if this connector is capable of handling YCBCR 420 "
"output. While parsing the EDID blocks it's very helpful to know if the "
"source is capable of handling YCBCR 420 outputs."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1983
msgid "``registration_state``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1984
msgid ""
"Is this connector initializing, exposed (registered) with userspace, or "
"unregistered?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1987
msgid "Protected by **mutex**."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1991
msgid "``modes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1992
msgid ""
"Modes available on this connector (from fill_modes() + user). Protected by :"
"c:type:`drm_mode_config.mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1999
msgid ""
"One of the drm_connector_status enums (connected, not, or unknown). "
"Protected by :c:type:`drm_mode_config.mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2005
msgid "``probed_modes``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2006
msgid ""
"These are modes added by probing with DDC or the BIOS, before filtering is "
"applied. Used by the probe helpers. Protected by :c:type:`drm_mode_config."
"mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2013
msgid "``display_info``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2014
msgid ""
"Display information is filled from EDID information when a display is "
"detected. For non hot-pluggable displays such as flat panels in embedded "
"systems, the driver should initialize the :c:type:`drm_display_info.width_mm "
"<drm_display_info>` and :c:type:`drm_display_info.height_mm "
"<drm_display_info>` fields with the physical size of the display."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2020
msgid "Protected by :c:type:`drm_mode_config.mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2024
msgid "connector control functions"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2027
msgid "``edid_blob_ptr``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2028
msgid ""
"DRM property containing EDID if present. Protected by :c:type:"
"`drm_mode_config.mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2031
msgid ""
"This must be updated only by calling drm_edid_connector_update() or "
"drm_connector_update_edid_property()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2034
msgid "This must not be used by drivers directly."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2038
msgid "property tracking for this connector"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2042
msgid ""
"Optional atomic property to control the upscaling. See "
"drm_connector_attach_content_protection_property()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2047
msgid "``vrr_capable_property``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2048
msgid ""
"Optional property to help userspace query hardware support for variable "
"refresh rate on a connector. connector. Drivers can add the property to a "
"connector by calling drm_connector_attach_vrr_capable_property()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2053
msgid ""
"This should be updated only by calling "
"drm_connector_set_vrr_capable_property()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2058
msgid "``colorspace_property``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2059
msgid ""
"Connector property to set the suitable colorspace supported by the sink."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2064
msgid "``path_blob_ptr``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2065
msgid ""
"DRM blob property data for the DP MST path property. This should only be "
"updated by calling drm_connector_set_path_property()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2073
msgid "Maximum bits per color channel the connector supports."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2077
msgid "``max_bpc_property``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2078
msgid ""
"Default connector property for the max bpc to be driven out of the connector."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2082
msgid "``privacy_screen``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2083
msgid "drm_privacy_screen for this connector, or NULL."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2085
msgid "``privacy_screen_notifier``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2086
msgid "privacy-screen notifier_block"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2089
msgid "``privacy_screen_sw_state_property``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2090
msgid ""
"Optional atomic property for the connector to control the integrated privacy "
"screen."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2095
msgid "``privacy_screen_hw_state_property``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2096
msgid ""
"Optional atomic property for the connector to report the actual integrated "
"privacy screen state."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2101
msgid "``broadcast_rgb_property``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2102
msgid "Connector property to set the Broadcast RGB selection to output with."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2111
msgid "``polled``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2112
msgid "Connector polling mode, a combination of"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2114
msgid "DRM_CONNECTOR_POLL_HPD"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2115
msgid ""
"The connector generates hotplug events and doesn't need to be periodically "
"polled. The CONNECT and DISCONNECT flags must not be set together with the "
"HPD flag."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2119
msgid "DRM_CONNECTOR_POLL_CONNECT"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2120
msgid "Periodically poll the connector for connection."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2122
msgid "DRM_CONNECTOR_POLL_DISCONNECT"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2123
msgid ""
"Periodically poll the connector for disconnection, without causing "
"flickering even when the connector is in use. DACs should rarely do this "
"without a lot of testing."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2127
msgid "Set to 0 for connectors that don't support connection status discovery."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2135
msgid ""
"Current dpms state. For legacy drivers the :c:type:`drm_connector_funcs.dpms "
"<drm_connector_funcs>` callback must update this. For atomic drivers, this "
"is handled by the core atomic code, and drivers must only take :c:type:"
"`drm_crtc_state.active <drm_crtc_state>` into account."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2144
msgid "``cmdline_mode``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2145
msgid "mode line parsed from the kernel cmdline for this connector"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2147
msgid "a DRM_FORCE_<foo> state for forced mode sets"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2150
msgid "``edid_override``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2151
msgid "Override EDID set via debugfs."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2153
msgid ""
"Do not modify or access outside of the drm_edid_override_* family of "
"functions."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2158
msgid "``edid_override_mutex``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2159
msgid "Protect access to edid_override."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2162
msgid "``epoch_counter``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2163
msgid "used to detect any other changes in connector, besides status"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2166
msgid "``possible_encoders``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2167
msgid ""
"Bit mask of encoders that can drive this connector, drm_encoder_index() "
"determines the index into the bitfield and the bits are set with "
"drm_connector_attach_encoder()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2173
#: include/drm/drm_connector.h:2561 ../../../gpu/drm-kms:446:
#: include/drm/drm_writeback.h:28 ../../../gpu/drm-kms:461:
#: include/drm/drm_encoder.h:331 include/drm/drm_encoder.h:343
msgid "``encoder``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2174
msgid ""
"Currently bound encoder driving this connector, if any. Only really "
"meaningful for non-atomic drivers. Atomic drivers should instead look at :c:"
"type:`drm_connector_state.best_encoder <drm_connector_state>`, and in case "
"they need the CRTC driving this output, :c:type:`drm_connector_state.crtc "
"<drm_connector_state>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2181
msgid "``eld``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2182
msgid "EDID-like data, if present, protected by **eld_mutex**"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2183
msgid "``eld_mutex``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2184
msgid "protection for concurrenct access to **eld**"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2186
msgid "``latency_present``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2187
msgid "AV delay info from ELD, if found"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2189
msgid "``video_latency``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2190
msgid ""
"Video latency info from ELD, if found. [0]: progressive, [1]: interlaced"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2194
msgid "``audio_latency``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2195
msgid "audio latency info from ELD, if found [0]: progressive, [1]: interlaced"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2200
msgid "``ddc``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2201
msgid ""
"associated ddc adapter. A connector usually has its associated ddc adapter. "
"If a driver uses this field, then an appropriate symbolic link is created in "
"connector sysfs directory to make it easy for the user to tell which i2c "
"adapter is for a particular display."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2207
msgid "The field should be set by calling drm_connector_init_with_ddc()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2211
msgid "``null_edid_counter``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2212
msgid ""
"track sinks that give us all zeros for the EDID. Needed to workaround some "
"HW bugs where we get all 0s"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2216
msgid "``bad_edid_counter``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2217
msgid "track sinks that give us an EDID with invalid checksum"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2220
msgid "``edid_corrupt``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2221
msgid ""
"Indicates whether the last read EDID was corrupt. Used in Displayport "
"compliance testing - Displayport Link CTS Core 1.2 rev1.1 4.2.2.6"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2226
msgid "``real_edid_checksum``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2227
msgid ""
"real edid checksum for corrupted edid block. Required in Displayport 1.4 "
"compliance testing rev1.1 4.2.2.6"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2233
msgid "debugfs directory for this connector"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2237
msgid "Current atomic state for this connector."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2239
msgid ""
"This is protected by :c:type:`drm_mode_config.connection_mutex "
"<drm_mode_config>`. Note that nonblocking atomic commits access the current "
"connector state without taking locks. Either by going through the :c:type:"
"`struct drm_atomic_state <drm_atomic_state>` pointers, see "
"for_each_oldnew_connector_in_state(), for_each_old_connector_in_state() and "
"for_each_new_connector_in_state(). Or through careful ordering of atomic "
"commit operations as implemented in the atomic helpers, see :c:type:`struct "
"drm_crtc_commit <drm_crtc_commit>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2254
msgid "``tile_blob_ptr``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2255
msgid ""
"DRM blob property data for the tile property (used mostly by DP MST). This "
"is meant for screens which are driven through separate display pipelines "
"represented by :c:type:`drm_crtc`, which might not be running with genlocked "
"clocks. For tiled panels which are genlocked, like dual-link LVDS or dual-"
"link DSI, the driver should try to not expose the tiling and virtualize "
"both :c:type:`drm_crtc` and :c:type:`drm_plane` if needed."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2262
msgid ""
"This should only be updated by calling drm_connector_set_tile_property()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2268
msgid "``has_tile``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2269
msgid "is this connector connected to a tiled monitor"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2270
msgid "``tile_group``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2271
msgid "tile group for the connected monitor"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2272
msgid "``tile_is_single_monitor``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2273
msgid "whether the tile is one monitor housing"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2275
msgid "``num_h_tile``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2276
msgid "number of horizontal tiles in the tile group"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2276
msgid "``num_v_tile``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2277
msgid "number of vertical tiles in the tile group"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2278
msgid "``tile_h_loc``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2279
msgid "horizontal location of this tile"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2279
msgid "``tile_v_loc``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2280
msgid "vertical location of this tile"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2281
msgid "``tile_h_size``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2282
msgid "horizontal size of this tile."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2282
msgid "``tile_v_size``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2283
msgid "vertical size of this tile."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2286
msgid "``free_node``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2287
msgid ""
"List used only by :c:type:`drm_connector_list_iter` to be able to clean up a "
"connector from any context, in conjunction with :c:type:`drm_mode_config."
"connector_free_work <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2296
msgid "HDMI-related variable and properties."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2300
msgid "``hdmi_audio``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2301
msgid "HDMI codec properties and non-DRM state."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2305
msgid "``cec``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2306
msgid "CEC-related data."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:1887
msgid ""
"Each connector may be connected to one or more CRTCs, or may be clonable by "
"another connector if they can share a CRTC.  Each connector also has a "
"specific position in the broader display (referred to as a 'screen' though "
"it could span multiple monitors)."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2360
msgid "lookup connector object"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2363
msgid "connector object id"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2364
msgid ""
"This function looks up the connector object specified by id add takes a "
"reference to it."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2378
msgid "acquire a connector reference"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2379
#: include/drm/drm_connector.h:2390 include/drm/drm_connector.h:2403
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2066
msgid "DRM connector"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2380
msgid "This function increments the connector's refcount."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2389
msgid "release a connector reference"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2391
msgid ""
"This function decrements the connector's reference count and frees the "
"object if the reference count drops to zero."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2401
msgid "has the connector been unregistered from userspace?"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2404
msgid ""
"Checks whether or not **connector** has been unregistered from userspace."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2407
msgid ""
"True if the connector was unregistered, false if the connector is registered "
"or has not yet been registered with userspace."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2492
msgid "Tile group metadata"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2494
msgid "reference count"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2496
msgid "tile group id exposed to userspace"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2496
msgid "``group_data``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2497
msgid "Sink-private data identifying this group"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2497
msgid ""
"**group_data** corresponds to displayid vend/prod/serial for external "
"screens with an EDID."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2516
#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1036
#: drivers/gpu/drm/drm_connector.c:1073 drivers/gpu/drm/drm_connector.c:1111
msgid "connector_list iterator"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2517
msgid ""
"This iterator tracks state needed to be able to walk the connector_list "
"within struct drm_mode_config. Only use together with "
"drm_connector_list_iter_begin(), drm_connector_list_iter_end() and "
"drm_connector_list_iter_next() respectively the convenience macro "
"drm_for_each_connector_iter()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2523
msgid ""
"Note that the return value of drm_connector_list_iter_next() is only valid "
"up to the next drm_connector_list_iter_next() or "
"drm_connector_list_iter_end() call. If you want to use the connector later, "
"then you need to grab your own reference first using drm_connector_get()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2548
msgid "``drm_for_each_connector_iter (connector, iter)``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2546
msgid "connector_list iterator macro"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2547
msgid ":c:type:`struct drm_connector <drm_connector>` pointer used as cursor"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2548
msgid ":c:type:`struct drm_connector_list_iter <drm_connector_list_iter>`"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2549
msgid ""
"Note that **connector** is only valid within the list body, if you want to "
"use **connector** after calling drm_connector_list_iter_end() then you need "
"to grab your own reference first using drm_connector_get()."
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2560
msgid "``drm_connector_for_each_possible_encoder (connector, encoder)``"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2558
msgid "iterate connector's possible encoders"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2559
msgid ":c:type:`struct drm_connector <drm_connector>` pointer"
msgstr ""

#: ../../../gpu/drm-kms:434: include/drm/drm_connector.h:2560
msgid ":c:type:`struct drm_encoder <drm_encoder>` pointer used as cursor"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:134
msgid "return a string for connector type"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:140
msgid "``unsigned int type``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:135
msgid "The connector type (DRM_MODE_CONNECTOR_*)"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:137
msgid "the name of the connector type, or NULL if the type is not valid."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:382
#: drivers/gpu/drm/drm_connector.c:456 drivers/gpu/drm/drm_connector.c:501
msgid "Init a preallocated connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:384
#: drivers/gpu/drm/drm_connector.c:417 drivers/gpu/drm/drm_connector.c:458
#: drivers/gpu/drm/drm_connector.c:503
msgid "the connector to init"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:386
#: drivers/gpu/drm/drm_connector.c:419 drivers/gpu/drm/drm_connector.c:460
#: drivers/gpu/drm/drm_connector.c:505 drivers/gpu/drm/drm_connector.c:552
msgid "``const struct drm_connector_funcs *funcs``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:385
#: drivers/gpu/drm/drm_connector.c:418 drivers/gpu/drm/drm_connector.c:459
#: drivers/gpu/drm/drm_connector.c:504 drivers/gpu/drm/drm_connector.c:551
msgid "callbacks for this connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:387
#: drivers/gpu/drm/drm_connector.c:420 drivers/gpu/drm/drm_connector.c:461
#: drivers/gpu/drm/drm_connector.c:506 drivers/gpu/drm/drm_connector.c:554
msgid "``int connector_type``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:386
#: drivers/gpu/drm/drm_connector.c:419 drivers/gpu/drm/drm_connector.c:460
#: drivers/gpu/drm/drm_connector.c:505 drivers/gpu/drm/drm_connector.c:553
msgid "user visible type of the connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:387
#: drivers/gpu/drm/drm_connector.c:462 drivers/gpu/drm/drm_connector.c:507
msgid ""
"Initialises a preallocated connector. Connectors should be subclassed as "
"part of driver connector objects."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:390
#: drivers/gpu/drm/drm_connector.c:465
msgid ""
"At driver unload time the driver's :c:type:`drm_connector_funcs.destroy "
"<drm_connector_funcs>` hook should call drm_connector_cleanup() and free the "
"connector structure. The connector structure should not be allocated with "
"devm_kzalloc()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:395
msgid ""
"consider using drmm_connector_init() instead of drm_connector_init() to let "
"the DRM managed resource infrastructure take care of cleanup and "
"deallocation."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:415
msgid "Init a preallocated dynamic connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:421
#: drivers/gpu/drm/drm_connector.c:462 drivers/gpu/drm/drm_connector.c:507
#: drivers/gpu/drm/drm_connector.c:555
msgid "``struct i2c_adapter *ddc``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:420
#: drivers/gpu/drm/drm_connector.c:461
msgid "pointer to the associated ddc adapter"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:421
msgid ""
"Initialises a preallocated dynamic connector. Connectors should be "
"subclassed as part of driver connector objects. The connector structure "
"should not be allocated with devm_kzalloc()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:425
msgid ""
"Drivers should call this for dynamic connectors which can be hotplugged "
"after drm_dev_register() has been called already, e.g. DP MST connectors. "
"For all other - static - connectors, drivers should call one of the "
"drm_connector_init*()/drmm_connector_init*() functions."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:430
msgid ""
"After calling this function the drivers must call "
"drm_connector_dynamic_register()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:433
msgid ""
"To remove the connector the driver must call drm_connector_unregister() "
"followed by drm_connector_put(). Putting the last reference will call the "
"driver's :c:type:`drm_connector_funcs.destroy <drm_connector_funcs>` hook, "
"which in turn must call drm_connector_cleanup() and free the connector "
"structure."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:469
msgid "Ensures that the ddc field of the connector is correctly set."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:472
msgid ""
"consider using drmm_connector_init() instead of "
"drm_connector_init_with_ddc() to let the DRM managed resource infrastructure "
"take care of cleanup and deallocation."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:506
#: drivers/gpu/drm/drm_connector.c:554
msgid "optional pointer to the associated ddc adapter"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:510
#: drivers/gpu/drm/drm_connector.c:560
msgid ""
"Cleanup is automatically handled with a call to drm_connector_cleanup() in a "
"DRM-managed action."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:513
#: drivers/gpu/drm/drm_connector.c:563
msgid "The connector structure should be allocated with drmm_kzalloc()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:515
#: drivers/gpu/drm/drm_connector.c:565
msgid "The **drm_connector_funcs.destroy** hook must be NULL."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:546
msgid "Init a preallocated HDMI connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:548
msgid "A pointer to the HDMI connector to init"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:550
msgid "``const char *vendor``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:549
msgid "HDMI Controller Vendor name"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:551
msgid "``const char *product``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:550
msgid "HDMI Controller Product name"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:553
msgid "``const struct drm_connector_hdmi_funcs *hdmi_funcs``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:552
msgid "HDMI-related callbacks for this connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:556
msgid "``unsigned long supported_formats``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:555
msgid "Bitmask of **hdmi_colorspace** listing supported output formats"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:557
msgid "``unsigned int max_bpc``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:556
msgid "Maximum bits per char the HDMI connector supports"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:557
msgid ""
"Initialises a preallocated HDMI connector. Connectors can be subclassed as "
"part of driver connector objects."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:631
msgid "attach edid property."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:632
#: drivers/gpu/drm/drm_connector.c:686
msgid "the connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:633
msgid ""
"Some connector types like DRM_MODE_CONNECTOR_VIRTUAL do not get a edid "
"property attached by default.  This function can be used to explicitly "
"enable the edid property in these cases."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:649
msgid "attach a connector to an encoder"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:650
msgid "connector to attach"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:651
msgid "encoder to attach **connector** to"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:652
msgid ""
"This function links up a connector to an encoder. Note that the routing "
"restrictions between encoders and crtcs are exposed to userspace through the "
"possible_clones and possible_crtcs bitmasks."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:684
msgid "check if the connector and encoder are associated with each other"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:687
msgid "the encoder"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:689
msgid "True if **encoder** is one of the possible encoders for **connector**."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:707
msgid "invalidate CEC physical address"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:708
#: drivers/gpu/drm/drm_connector.c:726
msgid "connector undergoing CEC operation"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:709
msgid "Invalidated CEC physical address set for this DRM connector."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:725
msgid "propagate CEC physical address"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:727
msgid ""
"Propagate CEC physical address from the display_info to this DRM connector."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:747
msgid "cleans up an initialised connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:748
msgid "connector to cleanup"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:749
msgid "Cleans up the connector but doesn't free the object."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:814
msgid "register a connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:815
#: drivers/gpu/drm/drm_connector.c:888
msgid "the connector to register"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:816
msgid ""
"Register userspace interfaces for a connector. Drivers shouldn't call this "
"function. Static connectors will be registered automatically by DRM core "
"from drm_dev_register(), dynamic connectors (MST) should be registered by "
"drivers calling drm_connector_dynamic_register()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:821
msgid ""
"When the connector is no longer available, callers must call "
"drm_connector_unregister()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:825
msgid ""
"Existing uses of this function in drivers should be a nop already and are "
"scheduled to be removed."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:887
msgid "register a dynamic connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:889
msgid ""
"Register userspace interfaces for a connector. Only call this for connectors "
"initialized by calling drm_connector_dynamic_init(). All other connectors "
"will be registered automatically when calling drm_dev_register()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:893
msgid ""
"When the connector is no longer available the driver must call "
"drm_connector_unregister()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:913
msgid "unregister a connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:914
msgid "the connector to unregister"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:915
msgid ""
"Unregister userspace interfaces for a connector. Drivers should call this "
"for dynamic connectors (MST) only, which were registered explicitly by "
"calling drm_connector_dynamic_register(). All other - static - connectors "
"will be unregistered automatically by DRM core and drivers shouldn't call "
"this function for those."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:922
msgid ""
"Existing uses of this function in drivers for static connectors should be a "
"nop already and are scheduled to be removed."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:986
msgid "return a string for connector status"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:992
#: drivers/gpu/drm/drm_connector.c:3491
msgid "``enum drm_connector_status status``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:987
msgid "connector status to compute name of"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:988
msgid ""
"In contrast to the other drm_get_*_name functions this one here returns a "
"const pointer and hence is threadsafe."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:992
msgid "connector status string"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1034
msgid "initialize a connector_list iterator"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1037
#: drivers/gpu/drm/drm_connector.c:1078 drivers/gpu/drm/drm_connector.c:1116
msgid "``struct drm_connector_list_iter *iter``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1037
msgid ""
"Sets **iter** up to walk the :c:type:`drm_mode_config.connector_list "
"<drm_mode_config>` of **dev**. **iter** must always be cleaned up again by "
"calling drm_connector_list_iter_end(). Iteration itself happens using "
"drm_connector_list_iter_next() or drm_for_each_connector_iter()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1072
msgid "return next connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1075
msgid ""
"the next connector for **iter**, or NULL when the list walk has completed."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1110
msgid "tear down a connector_list iterator"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1112
msgid ""
"Tears down **iter** and releases any resources (like :c:type:`drm_connector` "
"references) acquired while walking the list. This must always be called, "
"both when the iteration completes fully or when it was aborted without "
"walking the entire list."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1143
msgid "return a string for a given subpixel enum"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1149
msgid "``enum subpixel_order order``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1144
msgid "enum of subpixel_order"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1145
msgid ""
"Note you could abuse this and return something out of bounds, but that would "
"be a caller error.  No unscrubbed user data should make it here."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1149
msgid "string describing an enumerated subpixel property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1171
msgid "set the supported bus formats"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1177
msgid "``struct drm_display_info *info``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1172
msgid "display info to store bus formats in"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1174
#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:156
#: drivers/gpu/drm/drm_writeback.c:301 drivers/gpu/drm/drm_writeback.c:380
msgid "``const u32 *formats``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1173
msgid "array containing the supported bus formats"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1175
msgid "``unsigned int num_formats``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1174
msgid "the number of entries in the fmts array"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1175
msgid ""
"Store the supported bus formats in display info structure. See "
"MEDIA_BUS_FMT_* definitions in include/uapi/linux/media-bus-format.h for a "
"full list of available formats."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1264
msgid "Translates a TV mode name into its enum value"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1265
msgid "TV Mode name we want to convert"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1267
msgid "``size_t len``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1266
msgid "Length of **name**"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1267
msgid "Translates **name** into an enum drm_connector_tv_mode."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1270
msgid "the enum value on success, a negative errno otherwise."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1863
msgid "create DVI-I specific connector properties"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1865
msgid "Called by a driver the first time a DVI-I connector is made."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1868
#: drivers/gpu/drm/drm_connector.c:2051 drivers/gpu/drm/drm_connector.c:2287
msgid "``0``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1896
msgid "create subconnector property for DP"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1897
msgid "drm_connector to attach property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:1898
msgid "Called by a driver when DP connector is created."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2046
msgid "attach content-type property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2047
msgid "connector to attach content type property on."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2048
msgid "Called by a driver the first time a HDMI connector is made."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2064
msgid "attach TV connector margin properties"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2067
msgid ""
"Called by a driver when it needs to attach TV margin props to a connector. "
"Typically used on SDTV and HDMI connectors."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2091
msgid "create TV connector margin properties"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2093
msgid ""
"Called by a driver's HDMI connector initialization routine, this function "
"creates the TV margin properties for a given device. No need to call this "
"function for an SDTV connector, it's already called from "
"drm_mode_create_tv_properties_legacy()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2132
#: drivers/gpu/drm/drm_connector.c:2236
msgid "create TV specific connector properties"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2135
msgid "``unsigned int num_modes``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2134
msgid "number of different TV formats (modes) supported"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2136
msgid "``const char * const modes[]``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2135
msgid "array of pointers to strings containing name of each format"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2136
msgid ""
"Called by a driver's TV initialization routine, this function creates the TV "
"specific connector properties for a given device.  Caller is responsible for "
"allocating a list of format names and passing them to this routine."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2142
msgid ""
"This functions registers the deprecated \"mode\" connector property to "
"select the analog TV mode (ie, NTSC, PAL, etc.). New drivers must use "
"drm_mode_create_tv_properties() instead."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2239
msgid "``unsigned int supported_tv_modes``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2238
msgid "Bitmask of TV modes supported (See DRM_MODE_TV_MODE_*)"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2239
msgid ""
"Called by a driver's TV initialization routine, this function creates the TV "
"specific connector properties for a given device."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2277
msgid "create scaling mode property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2279
#: drivers/gpu/drm/drm_connector.c:2463 drivers/gpu/drm/drm_connector.c:2659
msgid ""
"Called by a driver the first time it's needed, must be attached to desired "
"connectors."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2282
msgid ""
"Atomic drivers should use drm_connector_attach_scaling_mode_property() "
"instead to correctly assign :c:type:`drm_connector_state.scaling_mode "
"<drm_connector_state>` in the atomic state."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2370
msgid "creates the vrr_capable property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2372
msgid "connector to create the vrr_capable property on."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2373
msgid ""
"This is used by atomic drivers to add support for querying variable refresh "
"rate capability for a connector."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2401
msgid "attach atomic scaling mode property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2402
msgid "connector to attach scaling mode property on."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2404
msgid "``u32 scaling_mode_mask``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2403
msgid "or'ed mask of BIT(``DRM_MODE_SCALE_``\\*)."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2404
msgid ""
"This is used to add support for scaling mode to atomic drivers. The scaling "
"mode will be set to :c:type:`drm_connector_state.scaling_mode "
"<drm_connector_state>` and can be used from :c:type:"
"`drm_connector_helper_funcs->atomic_check <drm_connector_helper_funcs>` for "
"validation."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2408
msgid "This is the atomic version of drm_mode_create_scaling_mode_property()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2461
msgid "create aspect ratio property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2607
msgid "create hdmi colorspace property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2608
#: drivers/gpu/drm/drm_connector.c:2633
msgid "connector to create the Colorspace property on."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2610
#: drivers/gpu/drm/drm_connector.c:2635
msgid "``u32 supported_colorspaces``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2609
#: drivers/gpu/drm/drm_connector.c:2634
msgid "bitmap of supported color spaces"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2610
msgid ""
"Called by a driver the first time it's needed, must be attached to desired "
"HDMI connectors."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2632
msgid "create dp colorspace property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2635
msgid ""
"Called by a driver the first time it's needed, must be attached to desired "
"DP connectors."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2657
msgid "create content type property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2684
msgid "create suggests offset properties"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2686
msgid "Create the suggested x/y offset property for connectors."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2711
#: drivers/gpu/drm/drm_connector.c:2740
msgid "set tile property on connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2712
#: drivers/gpu/drm/drm_connector.c:2741
msgid "connector to set property on."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2714
msgid "``const char *path``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2713
msgid "path to use for property; must not be NULL."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2714
msgid ""
"This creates a property to expose to userspace to specify a connector path. "
"This is mainly used for DisplayPort MST where connectors have a topology and "
"we want to allow userspace to give them more meaningful names."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2742
msgid ""
"This looks up the tile information for a connector, and creates a property "
"for userspace to parse if it exists. The property is of the form of 8 "
"integers using ':' as a separator. This is used for dual port tiled displays "
"with DisplayPort SST or DisplayPort MST connectors."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2749
msgid "Zero on success, errno on failure."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2785
msgid "Set link status property of a connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2786
#: drivers/gpu/drm/drm_connector.c:2953
msgid "drm connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2788
msgid "``uint64_t link_status``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2787
msgid "new value of link status property (0: Good, 1: Bad)"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2788
msgid ""
"In usual working scenario, this link status property will always be set to "
"\"GOOD\". If something fails during or after a mode set, the kernel driver "
"may set this link status property to \"BAD\". The caller then needs to send "
"a hotplug uevent for userspace to re-check the valid modes through "
"GET_CONNECTOR_IOCTL and retry modeset."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2795
msgid ""
"Drivers cannot rely on userspace to support this property and issue a "
"modeset. As such, they may choose to handle issues (like re-training a link) "
"without userspace's intervention."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2799
msgid ""
"The reason for adding this property is to handle link training failures, but "
"it is not limited to DP or link training. For example, if we implement "
"asynchronous setcrtc, this property can be used to report any failures in "
"that."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2815
msgid "attach \"max bpc\" property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2816
msgid "connector to attach max bpc property on."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2818
msgid "``int min``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2817
msgid "The minimum bit depth supported by the connector."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2819
msgid "``int max``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2818
msgid "The maximum bit depth supported by the connector."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2819
msgid "This is used to add support for limiting the bit depth on a connector."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2849
msgid "attach \"HDR_OUTPUT_METADA\" property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2850
#: drivers/gpu/drm/drm_connector.c:2871 drivers/gpu/drm/drm_connector.c:2904
msgid "connector to attach the property on."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2851
msgid "This is used to allow the userspace to send HDR Metadata to the driver."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2870
msgid "attach \"Broadcast RGB\" property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2872
msgid "This is used to add support for forcing the RGB range on a connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2903
msgid "attach \"Colorspace\" property"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2905
msgid ""
"This is used to allow the userspace to signal the output colorspace to the "
"driver."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2923
msgid "checks if the hdr metadata changed"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2929
msgid "``struct drm_connector_state *old_state``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2924
msgid "old connector state to compare"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2926
msgid "``struct drm_connector_state *new_state``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2925
msgid "new connector state to compare"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2926
msgid ""
"This is used by HDR-enabled drivers to test whether the HDR metadata have "
"changed between two different connector state (and thus probably requires a "
"full blown mode change)."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2931
msgid "True if the metadata are equal, False otherwise"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2951
msgid "sets the variable refresh rate capable property for a connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2955
msgid "``bool capable``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2954
msgid "True if the connector is variable refresh rate capable"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2955
msgid ""
"Should be used by atomic drivers to update the indicated support for "
"variable refresh rate over a connector."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2972
msgid "sets the connector's panel_orientation"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2973
msgid "connector for which to set the panel-orientation property."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2975
#: drivers/gpu/drm/drm_connector.c:3033
msgid "``enum drm_panel_orientation panel_orientation``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2974
#: drivers/gpu/drm/drm_connector.c:3032
msgid "drm_panel_orientation value to set"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2975
msgid ""
"This function sets the connector's panel_orientation and attaches a \"panel "
"orientation\" property to the connector."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2978
msgid ""
"Calling this function on a connector where the panel_orientation has already "
"been set is a no-op (e.g. the orientation has been overridden with a kernel "
"commandline option)."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2982
msgid ""
"It is allowed to call this function with a panel_orientation of "
"DRM_MODE_PANEL_ORIENTATION_UNKNOWN, in which case it is a no-op."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:2985
msgid ""
"The function shouldn't be called in panel after drm is registered (i.e. "
"drm_dev_register() is called in drm)."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3029
msgid "set the connector's panel_orientation after checking for quirks"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3031
#: drivers/gpu/drm/drm_connector.c:3061
msgid "connector for which to init the panel-orientation property."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3033
msgid "width in pixels of the panel, used for panel quirk detection"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3034
msgid "height in pixels of the panel, used for panel quirk detection"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3035
msgid ""
"Like drm_connector_set_panel_orientation(), but with a check for platform "
"specific (e.g. DMI based) quirks overriding the passed in panel_orientation."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3059
msgid "set the connector's panel_orientation from panel's callback."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3063
msgid "``struct drm_panel *panel``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3062
msgid "panel that can provide orientation information."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3063
msgid ""
"Drm drivers should call this function before drm_dev_register(). Orientation "
"is obtained from panel's .get_orientation() callback."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3093
msgid "create the drm connecter's privacy-screen properties."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3095
msgid "connector for which to create the privacy-screen properties"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3096
msgid ""
"This function creates the \"privacy-screen sw-state\" and \"privacy-screen "
"hw-state\" properties for the connector. They are not attached."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3122
msgid "attach the drm connecter's privacy-screen properties."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3124
msgid "connector on which to attach the privacy-screen properties"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3125
msgid ""
"This function attaches the \"privacy-screen sw-state\" and \"privacy-screen "
"hw-state\" properties to the connector. The initial state of both is set to "
"\"Disabled\"."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3180
msgid "attach a privacy-screen to the connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3182
msgid "connector to attach the privacy-screen to"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3184
msgid "``struct drm_privacy_screen *priv``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3183
msgid "drm_privacy_screen to attach"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3184
msgid ""
"Create and attach the standard privacy-screen properties and register a "
"generic notifier for generating sysfs-connector-status-events on external "
"changes to the privacy-screen status. This function takes ownership of the "
"passed in drm_privacy_screen and will call drm_privacy_screen_put() on it "
"when the connector is destroyed."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3205
msgid "update connector's privacy-screen sw-state"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3211
msgid "``const struct drm_connector_state *connector_state``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3206
msgid "connector-state to update the privacy-screen for"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3207
msgid ""
"This function calls drm_privacy_screen_set_sw_state() on the connector's "
"privacy-screen."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3210
msgid "If the connector has no privacy-screen, then this is a no-op."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3488
msgid "Report out-of-band hotplug event to connector"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3494
msgid "``struct fwnode_handle *connector_fwnode``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3489
msgid "fwnode_handle to report the event on"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3490
msgid "hot plug detect logical state"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3491
msgid ""
"On some hardware a hotplug event notification may come from outside the "
"display driver / device. An example of this is some USB Type-C setups where "
"the hardware muxes the DisplayPort data and aux-lines but does not pass the "
"altmode HPD status bit to the GPU's DP HPD pin."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3496
msgid ""
"This function can be used to report these out-of-band events after obtaining "
"a drm_connector reference through calling drm_connector_find_by_fwnode()."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3541
msgid "drop a reference to a tile group."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3544
msgid "``struct drm_tile_group *tg``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3543
msgid "tile group to drop reference to."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3544
msgid "drop reference to tile group and free if 0."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3555
msgid "get a reference to an existing tile group"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3558
#: drivers/gpu/drm/drm_connector.c:3588
msgid "``const char topology[8]``"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3557
#: drivers/gpu/drm/drm_connector.c:3587
msgid "8-bytes unique per monitor."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3558
msgid "Use the unique bytes to get a reference to an existing tile group."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3561
msgid "tile group or NULL if not found."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3585
msgid "create a tile group from a displayid description"
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3588
msgid ""
"Create a tile group for the unique monitor, and get a unique identifier for "
"the tile group."
msgstr ""

#: ../../../gpu/drm-kms:437: drivers/gpu/drm/drm_connector.c:3592
msgid "new tile group or NULL."
msgstr ""

#: ../../../gpu/drm-kms.rst:441
msgid "Writeback Connectors"
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:25
msgid ""
"Writeback connectors are used to expose hardware which can write the output "
"from a CRTC to a memory buffer. They are used and act similarly to other "
"types of connectors, with some important differences:"
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:29
msgid ""
"Writeback connectors don't provide a way to output visually to the user."
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:31
msgid ""
"Writeback connectors are visible to userspace only when the client sets "
"DRM_CLIENT_CAP_WRITEBACK_CONNECTORS."
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:34
msgid "Writeback connectors don't have EDID."
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:36
msgid ""
"A framebuffer may only be attached to a writeback connector when the "
"connector is attached to a CRTC. The WRITEBACK_FB_ID property which sets the "
"framebuffer applies only to a single commit (see below). A framebuffer may "
"not be attached while the CRTC is off."
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:41
msgid ""
"Unlike with planes, when a writeback framebuffer is removed by userspace DRM "
"makes no attempt to remove it from active use by the connector. This is "
"because no method is provided to abort a writeback operation, and in any "
"case making a new commit whilst a writeback is ongoing is undefined (see "
"WRITEBACK_OUT_FENCE_PTR below). As soon as the current writeback is "
"finished, the framebuffer will automatically no longer be in active use. As "
"it will also have already been removed from the framebuffer list, there will "
"be no way for any userspace application to retrieve a reference to it in the "
"intervening period."
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:51
msgid ""
"Writeback connectors have some additional properties, which userspace can "
"use to query and control them:"
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:54
msgid "\"WRITEBACK_FB_ID\":"
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:55
msgid ""
"Write-only object property storing a DRM_MODE_OBJECT_FB: it stores the "
"framebuffer to be written by the writeback connector. This property is "
"similar to the FB_ID property on planes, but will always read as zero and is "
"not preserved across commits. Userspace must set this property to an output "
"buffer every time it wishes the buffer to get filled."
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:62
msgid "\"WRITEBACK_PIXEL_FORMATS\":"
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:63
msgid ""
"Immutable blob property to store the supported pixel formats table. The data "
"is an array of u32 DRM_FORMAT_* fourcc values. Userspace can use this blob "
"to find out what pixel formats are supported by the connector's writeback "
"engine."
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:68
msgid "\"WRITEBACK_OUT_FENCE_PTR\":"
msgstr ""

#: ../../../gpu/drm-kms:443: drivers/gpu/drm/drm_writeback.c:69
msgid ""
"Userspace can use this property to provide a pointer for the kernel to fill "
"with a sync_file file descriptor, which will signal once the writeback is "
"finished. The value should be the address of a 32-bit signed integer, cast "
"to a u64. Userspace should wait for this fence to signal before making "
"another commit affecting any of the same CRTCs, Planes or Connectors. "
"**Failure to do so will result in undefined behaviour.** For this reason it "
"is strongly recommended that all userspace applications making use of "
"writeback connectors *always* retrieve an out-fence for the commit and use "
"it appropriately. From userspace, this property will always read as zero."
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:19
msgid "DRM writeback connector"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:24
msgid "base drm_connector object"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:29
msgid ""
"Internal encoder used by the connector to fulfill the DRM framework "
"requirements. The users of the **drm_writeback_connector** control the "
"behaviour of the **encoder** by passing the **enc_funcs** parameter to "
"drm_writeback_connector_init() function. For users of "
"drm_writeback_connector_init_with_encoder(), this field is not valid as the "
"encoder is managed within their drivers."
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:39
msgid "``pixel_formats_blob_ptr``"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:40
msgid ""
"DRM blob property data for the pixel formats list on writeback connectors "
"See also drm_writeback_connector_init()"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:47
msgid "``job_lock``"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:48
msgid "Protects job_queue"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:51
msgid "``job_queue``"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:52
msgid ""
"Holds a list of a connector's writeback jobs; the last item is the most "
"recent. The first item may be either waiting for the hardware to begin "
"writing, or currently being written."
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:76
msgid ""
"Seqno variable used as monotonic counter for the fences created on the "
"connector's timeline."
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:83
msgid "The name of the connector's fence timeline."
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:90
msgid "DRM writeback job"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:95
msgid "Back-pointer to the writeback connector associated with the job"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:101
msgid "``prepared``"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:102
msgid "Set when the job has been prepared with drm_writeback_prepare_job()"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:108
msgid "``cleanup_work``"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:109
msgid ""
"Used to allow drm_writeback_signal_completion to defer dropping the "
"framebuffer reference to a workqueue"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:116
msgid "``list_entry``"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:117
msgid "List item for the writeback connector's **job_queue**"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:124
msgid ""
"Framebuffer to be written to by the writeback connector. Do not set "
"directly, use drm_writeback_set_fb()"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:131
msgid "``out_fence``"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:132
msgid "Fence which will signal once the writeback has completed"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:138
msgid "``priv``"
msgstr ""

#: ../../../gpu/drm-kms:446: include/drm/drm_writeback.h:139
msgid "Driver-private data"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:150
msgid "Initialize a writeback connector and its properties"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:153
#: drivers/gpu/drm/drm_writeback.c:298 drivers/gpu/drm/drm_writeback.c:377
#: drivers/gpu/drm/drm_writeback.c:463 drivers/gpu/drm/drm_writeback.c:532
msgid "``struct drm_writeback_connector *wb_connector``"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:152
#: drivers/gpu/drm/drm_writeback.c:297 drivers/gpu/drm/drm_writeback.c:376
msgid "Writeback connector to initialize"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:154
#: drivers/gpu/drm/drm_writeback.c:300 drivers/gpu/drm/drm_writeback.c:378
msgid "``const struct drm_connector_funcs *con_funcs``"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:153
#: drivers/gpu/drm/drm_writeback.c:299 drivers/gpu/drm/drm_writeback.c:377
msgid "Connector funcs vtable"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:155
msgid "``const struct drm_encoder_helper_funcs *enc_helper_funcs``"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:154
msgid "Encoder helper funcs vtable to be used by the internal encoder"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:155
#: drivers/gpu/drm/drm_writeback.c:300 drivers/gpu/drm/drm_writeback.c:379
msgid "Array of supported pixel formats for the writeback engine"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:157
#: drivers/gpu/drm/drm_writeback.c:302 drivers/gpu/drm/drm_writeback.c:381
msgid "``int n_formats``"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:156
#: drivers/gpu/drm/drm_writeback.c:301 drivers/gpu/drm/drm_writeback.c:380
msgid "Length of the formats array"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:158
msgid "``u32 possible_crtcs``"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:157
msgid "possible crtcs for the internal writeback encoder"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:158
msgid ""
"This function creates the writeback-connector-specific properties if they "
"have not been already created, initializes the connector as type "
"DRM_MODE_CONNECTOR_WRITEBACK, and correctly initializes the property values. "
"It will also create an internal encoder associated with the "
"drm_writeback_connector and set it to use the **enc_helper_funcs** vtable "
"for the encoder helper."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:165
msgid ""
"Drivers should always use this function instead of drm_connector_init() to "
"set up writeback connectors."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:169
#: drivers/gpu/drm/drm_writeback.c:319 drivers/gpu/drm/drm_writeback.c:389
msgid "0 on success, or a negative error code"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:293
#: drivers/gpu/drm/drm_writeback.c:372
msgid "Initialize a writeback connector with a custom encoder"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:299
#: drivers/gpu/drm/drm_writeback.c:379
msgid "``struct drm_encoder *enc``"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:298
msgid "handle to the already initialized drm encoder"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:302
#: drivers/gpu/drm/drm_writeback.c:383
msgid ""
"This function creates the writeback-connector-specific properties if they "
"have not been already created, initializes the connector as type "
"DRM_MODE_CONNECTOR_WRITEBACK, and correctly initializes the property values."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:307
msgid ""
"This function assumes that the drm_writeback_connector's encoder has already "
"been created and initialized before invoking this function."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:310
msgid ""
"In addition, this function also assumes that callers of this API will manage "
"assigning the encoder helper functions, possible_crtcs and any other encoder "
"specific operation."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:314
msgid ""
"Drivers should always use this function instead of drm_connector_init() to "
"set up writeback connectors if they want to manage themselves the lifetime "
"of the associated encoder."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:378
msgid "Encoder to connect this writeback connector"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:381
msgid ""
"This function initialize a writeback connector and register its cleanup."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:457
msgid "Queue a writeback job for later signalling"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:458
msgid "The writeback connector to queue a job on"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:459
msgid "The connector state containing the job to queue"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:460
msgid ""
"This function adds the job contained in **conn_state** to the job_queue for "
"a writeback connector. It takes ownership of the writeback job and sets the "
"**conn_state->writeback_job** to NULL, and so no access to the job may be "
"performed by the caller after this function returns."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:465
msgid ""
"Drivers must ensure that for a given writeback connector, jobs are queued in "
"exactly the same order as they will be completed by the hardware (and "
"signaled via drm_writeback_signal_completion)."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:469
msgid ""
"For every call to drm_writeback_queue_job() there must be exactly one call "
"to drm_writeback_signal_completion()"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:472
msgid "See also: drm_writeback_signal_completion()"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:526
msgid "Signal the completion of a writeback job"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:527
msgid "The writeback connector whose job is complete"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:529
msgid "``int status``"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:528
msgid "Status code to set in the writeback out_fence (0 for success)"
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:529
msgid ""
"Drivers should call this to signal the completion of a previously queued "
"writeback job. It should be called as soon as possible after the hardware "
"has finished writing, and may be called from interrupt context. It is the "
"driver's responsibility to ensure that for a given connector, the hardware "
"completes writeback jobs in the same order as they are queued."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:535
msgid ""
"Unless the driver is holding its own reference to the framebuffer, it must "
"not be accessed after calling this function."
msgstr ""

#: ../../../gpu/drm-kms:449: drivers/gpu/drm/drm_writeback.c:538
msgid "See also: drm_writeback_queue_job()"
msgstr ""

#: ../../../gpu/drm-kms.rst:453
msgid "Encoder Abstraction"
msgstr ""

#: ../../../gpu/drm-kms:455: drivers/gpu/drm/drm_encoder.c:36
msgid ""
"Encoders represent the connecting element between the CRTC (as the overall "
"pixel pipeline, represented by :c:type:`struct drm_crtc <drm_crtc>`) and the "
"connectors (as the generic sink entity, represented by :c:type:`struct "
"drm_connector <drm_connector>`). An encoder takes pixel data from a CRTC and "
"converts it to a format suitable for any attached connector. Encoders are "
"objects exposed to userspace, originally to allow userspace to infer cloning "
"and connector/CRTC restrictions. Unfortunately almost all drivers get this "
"wrong, making the uabi pretty much useless. On top of that the exposed "
"restrictions are too simple for today's hardware, and the recommended way to "
"infer restrictions is by using the DRM_MODE_ATOMIC_TEST_ONLY flag for the "
"atomic IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:455: drivers/gpu/drm/drm_encoder.c:47
msgid ""
"Otherwise encoders aren't used in the uapi at all (any modeset request from "
"userspace directly connects a connector with a CRTC), drivers are therefore "
"free to use them however they wish. Modeset helper libraries make strong use "
"of encoders to facilitate code sharing. But for more complex settings it is "
"usually better to move shared code into a separate :c:type:`drm_bridge`. "
"Compared to encoders, bridges also have the benefit of being purely an "
"internal abstraction since they are not exposed to userspace at all."
msgstr ""

#: ../../../gpu/drm-kms:455: drivers/gpu/drm/drm_encoder.c:55
msgid ""
"Encoders are initialized with drm_encoder_init() and cleaned up using "
"drm_encoder_cleanup()."
msgstr ""

#: ../../../gpu/drm-kms.rst:459
msgid "Encoder Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:36
msgid "encoder controls"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:43
msgid ""
"Reset encoder hardware and software state to off. This function isn't called "
"by the core directly, only through drm_mode_config_reset(). It's not a "
"helper hook only for historical reasons."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:52
msgid ""
"Clean up encoder resources. This is only called at driver unload time "
"through drm_mode_config_cleanup() since an encoder cannot be hotplugged in "
"DRM."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:61
msgid ""
"This optional hook can be used to register additional userspace interfaces "
"attached to the encoder. It is called late in the driver load sequence from "
"drm_dev_register(). Everything added from this callback should be "
"unregistered in the early_unregister callback."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:76
msgid ""
"This optional hook should be used to unregister the additional userspace "
"interfaces attached to the encoder from **late_register**. It is called from "
"drm_dev_unregister(), early in the driver unload sequence to disable "
"userspace access before data structures are torndown."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:87
msgid "Allows encoders to create encoder-specific debugfs files."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:37
msgid "Encoders sit between CRTCs and connectors."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:94
msgid "central DRM encoder structure"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:97
msgid "list management"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:112
#: include/drm/drm_encoder.h:231 include/drm/drm_encoder.h:252
msgid "``encoder_type``"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:113
msgid ""
"One of the DRM_MODE_ENCODER_<foo> types in drm_mode.h. The following encoder "
"types are defined thus far:"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:116
msgid "DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:118
msgid "DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:120
msgid ""
"DRM_MODE_ENCODER_LVDS for display panels, or in general any panel with a "
"proprietary parallel connector."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:123
msgid ""
"DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video, Component, SCART)."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:126
msgid "DRM_MODE_ENCODER_VIRTUAL for virtual machine displays"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:128
msgid "DRM_MODE_ENCODER_DSI for panels connected using the DSI serial bus."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:130
msgid "DRM_MODE_ENCODER_DPI for panels connected using the DPI parallel bus."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:133
msgid ""
"DRM_MODE_ENCODER_DPMST for special fake encoders used to allow mutliple DP "
"MST streams to share one physical encoder."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:141
msgid ""
"Position inside the mode_config.list, can be used as an array index. It is "
"invariant over the lifetime of the encoder."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:147
msgid ""
"Bitmask of potential CRTC bindings, using drm_crtc_index() as the index into "
"the bitfield. The driver must set the bits for all :c:type:`drm_crtc` "
"objects this encoder can be connected to before calling drm_dev_register()."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:152
#: include/drm/drm_encoder.h:173
msgid "You will get a WARN if you get this wrong in the driver."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:154
msgid ""
"Note that since CRTC objects can't be hotplugged the assigned indices are "
"stable and hence known before registering all objects."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:159
msgid "``possible_clones``"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:160
msgid ""
"Bitmask of potential sibling encoders for cloning, using drm_encoder_index() "
"as the index into the bitfield. The driver must set the bits for all :c:type:"
"`drm_encoder` objects which can clone a :c:type:`drm_crtc` together with "
"this encoder before calling drm_dev_register(). Drivers should set the bit "
"representing the encoder itself, too. Cloning bits should be set such that "
"when two encoders can be used in a cloned configuration, they both should "
"have each another bits set."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:169
msgid ""
"As an exception to the above rule if the driver doesn't implement any "
"cloning it can leave **possible_clones** set to 0. The core will "
"automagically fix this up by setting the bit for the encoder itself."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:175
msgid ""
"Note that since encoder objects can't be hotplugged the assigned indices are "
"stable and hence known before registering all objects."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:181
msgid ""
"Currently bound CRTC, only really meaningful for non-atomic drivers.  Atomic "
"drivers should instead check :c:type:`drm_connector_state.crtc "
"<drm_connector_state>`."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:187
msgid "``bridge_chain``"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:188
msgid ""
"Bridges attached to this encoder. Drivers shall not access this field "
"directly."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:100
msgid "control functions, can be NULL for simple managed encoders"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:101
msgid ""
"CRTCs drive pixels to encoders, which convert them into signals appropriate "
"for a given connector or set of connectors."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:227
msgid ""
"``drmm_encoder_alloc (dev, type, member, funcs, encoder_type, name, ...)``"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:225
#: include/drm/drm_encoder.h:248
msgid "Allocate and initialize an encoder"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:227
msgid "the type of the struct which contains struct :c:type:`drm_encoder`"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:228
msgid "the name of the :c:type:`drm_encoder` within **type**"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:229
#: include/drm/drm_encoder.h:250 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:273
msgid "callbacks for this encoder (optional)"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:230
#: include/drm/drm_encoder.h:251 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:147 drivers/gpu/drm/drm_encoder.c:274
msgid "user visible type of the encoder"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:231
#: include/drm/drm_encoder.h:252 ../../../gpu/drm-kms:464:
#: drivers/gpu/drm/drm_encoder.c:148 drivers/gpu/drm/drm_encoder.c:275
msgid ""
"printf style format string for the encoder name, or NULL for default name"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:232
msgid ""
"Allocates and initializes an encoder. Encoder should be subclassed as part "
"of driver encoder objects. Cleanup is automatically handled through "
"registering drm_encoder_cleanup() with drmm_add_action()."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:236
#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:281
msgid "The **drm_encoder_funcs.destroy** hook must be NULL."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:239
msgid "Pointer to new encoder, or ERR_PTR on failure."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:250
msgid "``drmm_plain_encoder_alloc (dev, funcs, encoder_type, name, ...)``"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:253
msgid ""
"This is a simplified version of drmm_encoder_alloc(), which only allocates "
"and returns a struct drm_encoder instance, with no subclassing."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:257
msgid "Pointer to the new drm_encoder struct, or ERR_PTR on failure."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:266
msgid "find the index of a registered encoder"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:267
msgid "encoder to find index for"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:268
msgid ""
"Given a registered encoder, return the index of that encoder within a DRM "
"device's list of encoders."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:278
msgid "find the mask of a registered encoder"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:279
msgid "encoder to find mask for"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:280
msgid ""
"Given a registered encoder, return the mask bit of that encoder for an "
"encoder's possible_clones field."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:290
msgid "can a given crtc drive a given encoder?"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:291
msgid "encoder to test"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:292
msgid "crtc to test"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:293
msgid ""
"Returns false if **encoder** can't be driven by **crtc**, true otherwise."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:303
msgid "find a :c:type:`drm_encoder`"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:306
msgid "encoder id"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:307
msgid ""
"Returns the encoder with **id**, NULL if it doesn't exist. Simple wrapper "
"around drm_mode_object_find()."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:327
msgid "``drm_for_each_encoder_mask (encoder, dev, encoder_mask)``"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:325
msgid "iterate over encoders specified by bitmask"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:328
msgid "bitmask of encoder indices"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:329
msgid "Iterate over all encoders specified by bitmask."
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:339
msgid "``drm_for_each_encoder (encoder, dev)``"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:337
msgid "iterate over all encoders"
msgstr ""

#: ../../../gpu/drm-kms:461: include/drm/drm_encoder.h:340
msgid "Iterate over all encoders of **dev**."
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:143
msgid "Init a preallocated encoder"
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:145
#: drivers/gpu/drm/drm_encoder.c:272
msgid "the encoder to init"
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:147
#: drivers/gpu/drm/drm_encoder.c:274
msgid "``const struct drm_encoder_funcs *funcs``"
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:146
msgid "callbacks for this encoder"
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:148
#: drivers/gpu/drm/drm_encoder.c:275
msgid "``int encoder_type``"
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:149
msgid ""
"Initializes a preallocated encoder. Encoder should be subclassed as part of "
"driver encoder objects. At driver unload time the driver's :c:type:"
"`drm_encoder_funcs.destroy <drm_encoder_funcs>` hook should call "
"drm_encoder_cleanup() and kfree() the encoder structure. The encoder "
"structure should not be allocated with devm_kzalloc()."
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:156
msgid ""
"consider using drmm_encoder_alloc() or drmm_encoder_init() instead of "
"drm_encoder_init() to let the DRM managed resource infrastructure take care "
"of cleanup and deallocation."
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:182
msgid "cleans up an initialised encoder"
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:183
msgid "encoder to cleanup"
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:184
msgid "Cleans up the encoder but doesn't free the object."
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:270
msgid "Initialize a preallocated encoder"
msgstr ""

#: ../../../gpu/drm-kms:464: drivers/gpu/drm/drm_encoder.c:276
msgid ""
"Initializes a preallocated encoder. Encoder should be subclassed as part of "
"driver encoder objects. Cleanup is automatically handled through registering "
"drm_encoder_cleanup() with drmm_add_action(). The encoder structure should "
"be allocated with drmm_kzalloc()."
msgstr ""

#: ../../../gpu/drm-kms.rst:468
msgid "KMS Locking"
msgstr ""

#: ../../../gpu/drm-kms:470: drivers/gpu/drm/drm_modeset_lock.c:33
msgid ""
"As KMS moves toward more fine grained locking, and atomic ioctl where "
"userspace can indirectly control locking order, it becomes necessary to use :"
"c:type:`ww_mutex` and acquire-contexts to avoid deadlocks.  But because the "
"locking is more distributed around the driver code, we want a bit of extra "
"utility/tracking out of our acquire-ctx.  This is provided by :c:type:"
"`struct drm_modeset_lock <drm_modeset_lock>` and :c:type:`struct "
"drm_modeset_acquire_ctx <drm_modeset_acquire_ctx>`."
msgstr ""

#: ../../../gpu/drm-kms:470: drivers/gpu/drm/drm_modeset_lock.c:40
msgid ""
"For basic principles of :c:type:`ww_mutex`, see: Documentation/locking/ww-"
"mutex-design.rst"
msgstr ""

#: ../../../gpu/drm-kms:470: drivers/gpu/drm/drm_modeset_lock.c:42
msgid "The basic usage pattern is to::"
msgstr ""

#: ../../../gpu/drm-kms:470: drivers/gpu/drm/drm_modeset_lock.c:61
msgid ""
"For convenience this control flow is implemented in "
"DRM_MODESET_LOCK_ALL_BEGIN() and DRM_MODESET_LOCK_ALL_END() for the case "
"where all modeset locks need to be taken through drm_modeset_lock_all_ctx()."
msgstr ""

#: ../../../gpu/drm-kms:470: drivers/gpu/drm/drm_modeset_lock.c:65
msgid ""
"If all that is needed is a single modeset lock, then the :c:type:`struct "
"drm_modeset_acquire_ctx <drm_modeset_acquire_ctx>` is not needed and the "
"locking can be simplified by passing a NULL instead of ctx in the "
"drm_modeset_lock() call or calling  drm_modeset_lock_single_interruptible(). "
"To unlock afterwards call drm_modeset_unlock()."
msgstr ""

#: ../../../gpu/drm-kms:470: drivers/gpu/drm/drm_modeset_lock.c:71
msgid ""
"On top of these per-object locks using :c:type:`ww_mutex` there's also an "
"overall :c:type:`drm_mode_config.mutex <drm_mode_config>`, for protecting "
"everything else. Mostly this means probe state of connectors, and preventing "
"hotplug add/removal of connectors."
msgstr ""

#: ../../../gpu/drm-kms:470: drivers/gpu/drm/drm_modeset_lock.c:75
msgid ""
"Finally there's a bunch of dedicated locks to protect drm core internal "
"lists and lookup data structures."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:34
msgid "locking context (see ww_acquire_ctx)"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:35
msgid "``ww_ctx``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:36
msgid "base acquire ctx"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:36
msgid "``contended``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:37
msgid "used internally for -EDEADLK handling"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:37
msgid "``stack_depot``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:38
msgid "used internally for contention debugging"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:38
msgid "``locked``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:39
msgid "list of held locks"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:39
msgid "``trylock_only``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:40
msgid "trylock mode used in atomic contexts/panic notifiers"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:40
msgid "``interruptible``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:41
msgid "whether interruptible locking should be used."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:41
msgid ""
"Each thread competing for a set of locks must use one acquire ctx.  And if "
"any lock fxn returns -EDEADLK, it must backoff and retry."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:78
msgid "used for locking modeset resources."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:80
msgid "resource locking"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:81
msgid ""
"used to hold its place on :c:type:`drm_atomi_state.locked <drm_atomi_state>` "
"list when part of an atomic update"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:82
msgid "Used for locking CRTCs and other modeset resources."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:109
msgid "cleanup lock"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:115
#: include/drm/drm_modeset_lock.h:124 include/drm/drm_modeset_lock.h:133
#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:371
#: drivers/gpu/drm/drm_modeset_lock.c:383
#: drivers/gpu/drm/drm_modeset_lock.c:412
#: drivers/gpu/drm/drm_modeset_lock.c:427
msgid "``struct drm_modeset_lock *lock``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:110
msgid "lock to cleanup"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:118
msgid "equivalent to mutex_is_locked()"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:119
#: include/drm/drm_modeset_lock.h:128
msgid "lock to check"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:127
msgid "equivalent to lockdep_assert_held()"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:154
msgid "``DRM_MODESET_LOCK_ALL_BEGIN (dev, ctx, flags, ret)``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:152
msgid "Helper to acquire modeset locks"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:155
#: include/drm/drm_modeset_lock.h:188
msgid "``ctx``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:154
#: include/drm/drm_modeset_lock.h:187
msgid "local modeset acquire context, will be dereferenced"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:155
msgid "DRM_MODESET_ACQUIRE_* flags to pass to drm_modeset_acquire_init()"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:157
#: include/drm/drm_modeset_lock.h:189
msgid "``ret``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:156
#: include/drm/drm_modeset_lock.h:188
msgid "local ret/err/etc variable to track error status"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:157
msgid ""
"Use these macros to simplify grabbing all modeset locks using a local "
"context. This has the advantage of reducing boilerplate, but also properly "
"checking return values where appropriate."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:161
msgid "Any code run between BEGIN and END will be holding the modeset locks."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:163
msgid ""
"This must be paired with DRM_MODESET_LOCK_ALL_END(). We will jump back and "
"forth between the labels on deadlock and error conditions."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:166
msgid ""
"Drivers can acquire additional modeset locks. If any lock acquisition fails, "
"the control flow needs to jump to DRM_MODESET_LOCK_ALL_END() with the "
"**ret** parameter containing the return value of drm_modeset_lock()."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:171
msgid ""
"The only possible value of ret immediately after "
"DRM_MODESET_LOCK_ALL_BEGIN() is 0, so no error checking is necessary"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:187
msgid "``DRM_MODESET_LOCK_ALL_END (dev, ctx, ret)``"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:185
msgid "Helper to release and cleanup modeset locks"
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:189
msgid ""
"The other side of DRM_MODESET_LOCK_ALL_BEGIN(). It will bounce back to BEGIN "
"if ret is -EDEADLK."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:192
msgid ""
"It's important that you use the same ret variable for begin and end so "
"deadlock conditions are properly handled."
msgstr ""

#: ../../../gpu/drm-kms:473: include/drm/drm_modeset_lock.h:196
msgid ""
"ret will be untouched unless it is -EDEADLK on entry. That means that if you "
"successfully acquire the locks, ret will be whatever your code sets it to. "
"If there is a deadlock or other failure with acquire or backoff, ret will be "
"set to that failure. In both of these cases the code between BEGIN/END will "
"not be run, so the failure will reflect the inability to grab the locks."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:131
#: drivers/gpu/drm/drm_modeset_lock.c:432
msgid "take all modeset locks"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:133
msgid ""
"This function takes all modeset locks, suitable where a more fine-grained "
"scheme isn't (yet) implemented. Locks must be dropped by calling the "
"drm_modeset_unlock_all() function."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:137
msgid ""
"This function is deprecated. It allocates a lock acquisition context and "
"stores it in :c:type:`drm_device.mode_config <drm_device>`. This facilitate "
"conversion of existing code because it removes the need to manually deal "
"with the acquisition context, but it is also brittle because the context is "
"global and care must be taken not to nest calls. New code should use the "
"drm_modeset_lock_all_ctx() function and pass in the context explicitly."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:186
msgid "drop all modeset locks"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:188
msgid ""
"This function drops all modeset locks taken by a previous call to the "
"drm_modeset_lock_all() function."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:191
msgid ""
"This function is deprecated. It uses the lock acquisition context stored in :"
"c:type:`drm_device.mode_config <drm_device>`. This facilitates conversion of "
"existing code because it removes the need to manually deal with the "
"acquisition context, but it is also brittle because the context is global "
"and care must be taken not to nest calls. New code should pass the "
"acquisition context directly to the drm_modeset_drop_locks() function."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:218
msgid "check that all modeset locks are locked"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:219
msgid "device"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:220
msgid "Useful as a debug assert."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:240
msgid "initialize acquire context"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:241
#: drivers/gpu/drm/drm_modeset_lock.c:262
#: drivers/gpu/drm/drm_modeset_lock.c:272
#: drivers/gpu/drm/drm_modeset_lock.c:338
msgid "the acquire context"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:243
msgid "``uint32_t flags``"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:242
msgid "0 or ``DRM_MODESET_ACQUIRE_INTERRUPTIBLE``"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:243
msgid ""
"When passing ``DRM_MODESET_ACQUIRE_INTERRUPTIBLE`` to **flags**, all calls "
"to drm_modeset_lock() will perform an interruptible wait."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:261
msgid "cleanup acquire context"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:271
msgid "drop all locks"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:273
msgid "Drop all locks currently held against this acquire context."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:337
msgid "deadlock avoidance backoff"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:339
msgid ""
"If deadlock is detected (ie. drm_modeset_lock() returns -EDEADLK), you must "
"call this function to drop all currently held locks and block until the "
"contended lock becomes available."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:343
msgid ""
"This function returns 0 on success, or -ERESTARTSYS if this context is "
"initialized with ``DRM_MODESET_ACQUIRE_INTERRUPTIBLE`` and the wait has been "
"interrupted."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:365
msgid "initialize lock"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:366
msgid "lock to init"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:377
msgid "take modeset lock"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:378
#: drivers/gpu/drm/drm_modeset_lock.c:407
msgid "lock to take"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:379
msgid "acquire ctx"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:380
msgid ""
"If **ctx** is not NULL, then its ww acquire context is used and the lock "
"will be tracked by the context and can be released by calling "
"drm_modeset_drop_locks().  If -EDEADLK is returned, this means a deadlock "
"scenario has been detected and it is an error to attempt to take any more "
"locks without first calling drm_modeset_backoff()."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:386
msgid ""
"If the **ctx** is not NULL and initialized with "
"``DRM_MODESET_ACQUIRE_INTERRUPTIBLE``, this function will fail with -"
"ERESTARTSYS when interrupted."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:390
msgid ""
"If **ctx** is NULL then the function call behaves like a normal, "
"uninterruptible non-nesting mutex_lock() call."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:406
msgid "take a single modeset lock"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:408
msgid ""
"This function behaves as drm_modeset_lock() with a NULL context, but "
"performs interruptible waits."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:411
msgid "This function returns 0 on success, or -ERESTARTSYS when interrupted."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:421
msgid "drop modeset lock"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:422
msgid "lock to release"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:434
msgid "lock acquisition context"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:435
msgid ""
"This function takes all modeset locks, suitable where a more fine-grained "
"scheme isn't (yet) implemented."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:438
msgid ""
"Unlike drm_modeset_lock_all(), it doesn't take the :c:type:`drm_mode_config."
"mutex <drm_mode_config>` since that lock isn't required for modeset state "
"changes. Callers which need to grab that lock too need to do so outside of "
"the acquire context **ctx**."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:443
msgid ""
"Locks acquired with this function should be released by calling the "
"drm_modeset_drop_locks() function on **ctx**."
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:446
msgid "See also: DRM_MODESET_LOCK_ALL_BEGIN() and DRM_MODESET_LOCK_ALL_END()"
msgstr ""

#: ../../../gpu/drm-kms:476: drivers/gpu/drm/drm_modeset_lock.c:449
msgid "0 on success or a negative error-code on failure."
msgstr ""

#: ../../../gpu/drm-kms.rst:480
msgid "KMS Properties"
msgstr ""

#: ../../../gpu/drm-kms.rst:482
msgid ""
"This section of the documentation is primarily aimed at user-space "
"developers. For the driver APIs, see the other sections."
msgstr ""

#: ../../../gpu/drm-kms.rst:486
msgid "Requirements"
msgstr ""

#: ../../../gpu/drm-kms.rst:488
msgid ""
"KMS drivers might need to add extra properties to support new features. Each "
"new property introduced in a driver needs to meet a few requirements, in "
"addition to the one mentioned above:"
msgstr ""

#: ../../../gpu/drm-kms.rst:492
msgid "It must be standardized, documenting:"
msgstr ""

#: ../../../gpu/drm-kms.rst:494
msgid "The full, exact, name string;"
msgstr ""

#: ../../../gpu/drm-kms.rst:495
msgid "If the property is an enum, all the valid value name strings;"
msgstr ""

#: ../../../gpu/drm-kms.rst:496
msgid "What values are accepted, and what these values mean;"
msgstr ""

#: ../../../gpu/drm-kms.rst:497
msgid "What the property does and how it can be used;"
msgstr ""

#: ../../../gpu/drm-kms.rst:498
msgid "How the property might interact with other, existing properties."
msgstr ""

#: ../../../gpu/drm-kms.rst:500
msgid ""
"It must provide a generic helper in the core code to register that property "
"on the object it attaches to."
msgstr ""

#: ../../../gpu/drm-kms.rst:503
msgid ""
"Its content must be decoded by the core and provided in the object's "
"associated state structure. That includes anything drivers might want to "
"precompute, like struct drm_clip_rect for planes."
msgstr ""

#: ../../../gpu/drm-kms.rst:507
msgid ""
"Its initial state must match the behavior prior to the property "
"introduction. This might be a fixed value matching what the hardware does, "
"or it may be inherited from the state the firmware left the system in during "
"boot."
msgstr ""

#: ../../../gpu/drm-kms.rst:512
msgid "An IGT test must be submitted where reasonable."
msgstr ""

#: ../../../gpu/drm-kms.rst:514
msgid ""
"For historical reasons, non-standard, driver-specific properties exist. If a "
"KMS driver wants to add support for one of those properties, the "
"requirements for new properties apply where possible. Additionally, the "
"documented behavior must match the de facto semantics of the existing "
"property to ensure compatibility. Developers of the driver that first added "
"the property should help with those tasks and must ACK the documented "
"behavior if possible."
msgstr ""

#: ../../../gpu/drm-kms.rst:522
msgid "Property Types and Blob Property Support"
msgstr ""

#: ../../../gpu/drm-kms:524: drivers/gpu/drm/drm_property.c:36
msgid ""
"Properties as represented by :c:type:`drm_property` are used to extend the "
"modeset interface exposed to userspace. For the atomic modeset IOCTL "
"properties are even the only way to transport metadata about the desired new "
"modeset configuration from userspace to the kernel. Properties have a well-"
"defined value range, which is enforced by the drm core. See the "
"documentation of the flags member of :c:type:`struct drm_property "
"<drm_property>` for an overview of the different property types and ranges."
msgstr ""

#: ../../../gpu/drm-kms:524: drivers/gpu/drm/drm_property.c:44
msgid ""
"Properties don't store the current value directly, but need to be "
"instantiated by attaching them to a :c:type:`drm_mode_object` with "
"drm_object_attach_property()."
msgstr ""

#: ../../../gpu/drm-kms:524: drivers/gpu/drm/drm_property.c:48
msgid ""
"Property values are only 64bit. To support bigger piles of data (like gamma "
"tables, color correction matrices or large structures) a property can "
"instead point at a :c:type:`drm_property_blob` with that additional data."
msgstr ""

#: ../../../gpu/drm-kms:524: drivers/gpu/drm/drm_property.c:52
msgid ""
"Properties are defined by their symbolic name, userspace must keep a per-"
"object mapping from those names to the property ID used in the atomic IOCTL "
"and in the get/set property IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:33
msgid "symbolic values for enumerations"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:42
msgid "``value``"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:43
msgid "numeric property value for this enum entry"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:45
msgid ""
"If the property has the type :c:type:`DRM_MODE_PROP_BITMASK`, **value** "
"stores a bitshift, not a bitmask. In other words, the enum entry is enabled "
"if the bit number **value** is set in the property's value. This enum entry "
"has the bitmask ``1 << value``."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:35
msgid ""
"list of enum values, linked to :c:type:`drm_property.enum_list "
"<drm_property>`"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:36
msgid "symbolic name for the enum"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:36
msgid ""
"For enumeration and bitmask properties this structure stores the symbolic "
"decoding for each value. This is used for example for the rotation property."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:55
msgid "modeset object property"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:83
msgid "per-device list of properties, for cleanup."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:93
msgid ""
"Property flags and type. A property needs to be one of the following types:"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:96
msgid "DRM_MODE_PROP_RANGE"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:97
msgid ""
"Range properties report their minimum and maximum admissible unsigned "
"values. The KMS core verifies that values set by application fit in that "
"range. The range is unsigned. Range properties are created using "
"drm_property_create_range()."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:102
msgid "DRM_MODE_PROP_SIGNED_RANGE"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:103
msgid ""
"Range properties report their minimum and maximum admissible unsigned "
"values. The KMS core verifies that values set by application fit in that "
"range. The range is signed. Range properties are created using "
"drm_property_create_signed_range()."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:108
msgid "DRM_MODE_PROP_ENUM"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:109
msgid ""
"Enumerated properties take a numerical value that ranges from 0 to the "
"number of enumerated values defined by the property minus one, and associate "
"a free-formed string name to each value. Applications can retrieve the list "
"of defined value-name pairs and use the numerical value to get and set "
"property instance values. Enum properties are created using "
"drm_property_create_enum()."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:116
msgid "DRM_MODE_PROP_BITMASK"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:117
msgid ""
"Bitmask properties are enumeration properties that additionally restrict all "
"enumerated values to the 0..63 range. Bitmask property instance values "
"combine one or more of the enumerated bits defined by the property. Bitmask "
"properties are created using drm_property_create_bitmask()."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:123
msgid "DRM_MODE_PROP_OBJECT"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:124
msgid ""
"Object properties are used to link modeset objects. This is used extensively "
"in the atomic support to create the display pipeline, by linking :c:type:"
"`drm_framebuffer` to :c:type:`drm_plane`, :c:type:`drm_plane` to :c:type:"
"`drm_crtc` and :c:type:`drm_connector` to :c:type:`drm_crtc`. An object "
"property can only link to a specific type of :c:type:`drm_mode_object`, this "
"limit is enforced by the core. Object properties are created using "
"drm_property_create_object()."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:132
msgid ""
"Object properties work like blob properties, but in a more general fashion. "
"They are limited to atomic drivers and must have the DRM_MODE_PROP_ATOMIC "
"flag set."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:136
msgid "DRM_MODE_PROP_BLOB"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:137
msgid ""
"Blob properties store a binary blob without any format restriction. The "
"binary blobs are created as KMS standalone objects, and blob property "
"instance values store the ID of their associated blob object. Blob "
"properties are created by calling drm_property_create() with "
"DRM_MODE_PROP_BLOB as the type."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:143
msgid ""
"Actual blob objects to contain blob data are created using "
"drm_property_create_blob(), or through the corresponding IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:146
msgid ""
"Besides the built-in limit to only accept blob objects blob properties work "
"exactly like object properties. The only reasons blob properties exist is "
"backwards compatibility with existing userspace."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:151
msgid "In addition a property can have any combination of the below flags:"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:153
msgid "DRM_MODE_PROP_ATOMIC"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:154
msgid ""
"Set for properties which encode atomic modeset state. Such properties are "
"not exposed to legacy userspace."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:157
msgid "DRM_MODE_PROP_IMMUTABLE"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:158
msgid ""
"Set for properties whose values cannot be changed by userspace. The kernel "
"is allowed to update the value of these properties. This is generally used "
"to expose probe state to userspace, e.g. the EDID, or the connector path "
"property on DP MST sinks. Kernel can update the value of an immutable "
"property by calling drm_object_property_set_value()."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:170
msgid "symbolic name of the properties"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:174
msgid "``num_values``"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:175
msgid "size of the **values** array."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:180
msgid ""
"Array with limits and values for the property. The interpretation of these "
"limits is dependent upon the type per **flags**."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:192
msgid "``enum_list``"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:193
msgid ""
"List of :c:type:`drm_prop_enum_list` structures with the symbolic names for "
"enum and bitmask values."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:56
msgid ""
"This structure represent a modeset object property. It combines both the "
"name of the property with the set of permissible values. This means that "
"when a driver wants to use a property with the same name on different "
"objects, but with different value ranges, then it must create property for "
"each one. An example would be rotation of :c:type:`drm_plane`, when e.g. the "
"primary plane cannot be rotated. But if both the name and the value range "
"match, then the same property structure can be instantiated multiple times "
"for the same object. Userspace must be able to cope with this and cannot "
"assume that the same symbolic property will have the same modeset object ID "
"on all modeset objects."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:67
msgid ""
"Properties are created by one of the special functions, as explained in "
"detail in the **flags** structure member."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:70
msgid ""
"To actually expose a property it must be attached to each object using "
"drm_object_attach_property(). Currently properties can only be attached to :"
"c:type:`drm_connector`, :c:type:`drm_crtc` and :c:type:`drm_plane`."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:74
msgid ""
"Properties are also used as the generic metadatatransport for the atomic "
"IOCTL. Everything that was set directly in structures in the legacy modeset "
"IOCTLs (like the plane source or destination windows, or e.g. the links to "
"the CRTC) is exposed as a property with the DRM_MODE_PROP_ATOMIC flag set."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:201
msgid "Blob data for :c:type:`drm_property`"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:204
msgid "``head_global``"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:205
msgid ""
"entry on the global blob list in :c:type:`drm_mode_config.property_blob_list "
"<drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:206
msgid "``head_file``"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:207
msgid ""
"entry on the per-file blob list in :c:type:`drm_file.blobs <drm_file>` list."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:207
msgid "``length``"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:208
msgid "size of the blob in bytes, invariant over the lifetime of the object"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:209
msgid "actual data, embedded at the end of this structure"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:209
msgid ""
"Blobs are used to store bigger values than what fits directly into the 64 "
"bits available for a :c:type:`drm_property`."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:212
msgid ""
"Blobs are reference counted using drm_property_blob_get() and "
"drm_property_blob_put(). They are created using drm_property_create_blob()."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:234
msgid "check the type of a property"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:235
msgid "property to check"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:236
msgid "property type to compare with"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:237
msgid ""
"This is a helper function becauase the uapi encoding of property types is a "
"bit special for historical reasons."
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:300
msgid "find property object"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:303
msgid "property object id"
msgstr ""

#: ../../../gpu/drm-kms:527: include/drm/drm_property.h:304
msgid ""
"This function looks up the property object specified by id and returns it."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:83
msgid "create a new property type"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:86
#: drivers/gpu/drm/drm_property.c:147 drivers/gpu/drm/drm_property.c:194
#: drivers/gpu/drm/drm_property.c:262 drivers/gpu/drm/drm_property.c:290
#: drivers/gpu/drm/drm_property.c:318 drivers/gpu/drm/drm_property.c:357
msgid "``u32 flags``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:85
#: drivers/gpu/drm/drm_property.c:146 drivers/gpu/drm/drm_property.c:193
#: drivers/gpu/drm/drm_property.c:261 drivers/gpu/drm/drm_property.c:289
#: drivers/gpu/drm/drm_property.c:317 drivers/gpu/drm/drm_property.c:356
msgid "flags specifying the property type"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:86
#: drivers/gpu/drm/drm_property.c:147 drivers/gpu/drm/drm_property.c:194
#: drivers/gpu/drm/drm_property.c:262 drivers/gpu/drm/drm_property.c:290
#: drivers/gpu/drm/drm_property.c:318 drivers/gpu/drm/drm_property.c:357
msgid "name of the property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:88
#: drivers/gpu/drm/drm_property.c:150
msgid "``int num_values``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:87
#: drivers/gpu/drm/drm_property.c:149
msgid "number of pre-defined values"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:88
#: drivers/gpu/drm/drm_property.c:150 drivers/gpu/drm/drm_property.c:265
#: drivers/gpu/drm/drm_property.c:293 drivers/gpu/drm/drm_property.c:320
#: drivers/gpu/drm/drm_property.c:358
msgid ""
"This creates a new generic drm property which can then be attached to a drm "
"object with drm_object_attach_property(). The returned property object must "
"be freed with drm_property_destroy(), which is done automatically when "
"calling drm_mode_config_cleanup()."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:94
#: drivers/gpu/drm/drm_property.c:159 drivers/gpu/drm/drm_property.c:207
#: drivers/gpu/drm/drm_property.c:274 drivers/gpu/drm/drm_property.c:302
#: drivers/gpu/drm/drm_property.c:329 drivers/gpu/drm/drm_property.c:366
msgid "A pointer to the newly created property on success, NULL on failure."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:144
msgid "create a new enumeration property type"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:149
#: drivers/gpu/drm/drm_property.c:196
msgid "``const struct drm_prop_enum_list *props``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:148
msgid "enumeration lists with property values"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:155
msgid ""
"Userspace is only allowed to set one of the predefined values for "
"enumeration properties."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:191
msgid "create a new bitmask property type"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:195
msgid "enumeration lists with property bitflags"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:197
msgid "``int num_props``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:196
msgid "size of the **props** array"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:198
msgid "``uint64_t supported_bits``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:197
msgid "bitmask of all supported enumeration values"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:198
msgid ""
"This creates a new bitmask drm property which can then be attached to a drm "
"object with drm_object_attach_property(). The returned property object must "
"be freed with drm_property_destroy(), which is done automatically when "
"calling drm_mode_config_cleanup()."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:203
msgid ""
"Compared to plain enumeration properties userspace is allowed to set any "
"or'ed together combination of the predefined property bitflag values"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:259
msgid "create a new unsigned ranged property type"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:264
msgid "``uint64_t min``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:263
#: drivers/gpu/drm/drm_property.c:291
msgid "minimum value of the property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:265
msgid "``uint64_t max``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:264
#: drivers/gpu/drm/drm_property.c:292
msgid "maximum value of the property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:270
msgid ""
"Userspace is allowed to set any unsigned integer value in the (min, max) "
"range inclusive."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:287
msgid "create a new signed ranged property type"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:292
msgid "``int64_t min``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:293
msgid "``int64_t max``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:298
msgid ""
"Userspace is allowed to set any signed integer value in the (min, max) range "
"inclusive."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:315
msgid "create a new object property type"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:319
msgid "object type from DRM_MODE_OBJECT_* defines"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:325
msgid ""
"Userspace is only allowed to set this to any property value of the given "
"**type**. Only useful for atomic properties, which is enforced."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:354
msgid "create a new boolean property type"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:363
msgid ""
"This is implemented as a ranged property with only {0, 1} as valid values."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:377
msgid "add a possible value to an enumeration property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:378
msgid "enumeration property to change"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:379
msgid "value of the new enumeration"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:380
msgid "symbolic name of the new enumeration"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:381
msgid "This functions adds enumerations to a property."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:383
msgid ""
"It's use is deprecated, drivers should use one of the more specific helpers "
"to directly create the property with all enumerations already attached."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:434
msgid "destroy a drm property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:436
msgid "property to destroy"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:437
msgid ""
"This function frees a property including any attached resources like "
"enumeration values."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:542
msgid "Create new blob property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:543
msgid "DRM device to create property for"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:545
#: drivers/gpu/drm/drm_property.c:669
msgid "``size_t length``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:544
msgid "Length to allocate for blob data"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:546
#: drivers/gpu/drm/drm_property.c:670
msgid "``const void *data``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:545
msgid "If specified, copies data into blob"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:546
msgid ""
"Creates a new blob property for a specified DRM device, optionally copying "
"data. Note that blob properties are meant to be invariant, hence the data "
"must be filled out before the blob is used as the value of any property."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:551
msgid ""
"New blob property with a single reference on success, or an ERR_PTR value on "
"failure."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:596
msgid "release a blob property reference"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:597
#: drivers/gpu/drm/drm_property.c:627
msgid "DRM blob property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:598
msgid "Releases a reference to a blob property. May free the object."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:626
msgid "acquire blob property reference"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:628
msgid ""
"Acquires a reference to an existing blob property. Returns **blob**, which "
"allows this to be used as a shorthand in assignments."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:640
msgid "look up a blob property and take a reference"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:642
msgid "id of the blob property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:643
msgid ""
"If successful, this takes an additional reference to the blob property. "
"callers need to make sure to eventually unreferenced the returned property "
"again, using drm_property_blob_put()."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:648
msgid "NULL on failure, pointer to the blob on success."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:665
msgid "replace existing blob property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:668
msgid "``struct drm_property_blob **replace``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:667
msgid "location of blob property pointer to be replaced"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:668
msgid "length of data for new blob, or 0 for no data"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:669
msgid "content for new blob, or NULL for no data"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:671
msgid "``struct drm_mode_object *obj_holds_id``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:670
msgid "optional object for property holding blob ID"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:672
msgid "``struct drm_property *prop_holds_id``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:671
msgid ""
"optional property holding blob ID **return** 0 on success or error on failure"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:673
msgid ""
"This function will replace a global property in the blob list, optionally "
"updating a property which holds the ID of that property."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:676
msgid ""
"If length is 0 or data is NULL, no new blob will be created, and the holding "
"property, if specified, will be set to 0."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:679
msgid ""
"Access to the replace pointer is assumed to be protected by the caller, e.g. "
"by holding the relevant modesetting object lock for its parent."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:682
msgid ""
"For example, a drm_connector has a 'PATH' property, which contains the ID of "
"a blob property with the value of the MST path information. Calling this "
"function with replace pointing to the connector's path_blob_ptr, length and "
"data set for the new path information, obj_holds_id set to the connector's "
"base object, and prop_holds_id set to the path property name, will perform a "
"completely atomic update. The access to path_blob_ptr is protected by the "
"caller holding a lock on the connector."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:733
msgid "replace a blob property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:739
#: drivers/gpu/drm/drm_property.c:759
msgid "``struct drm_property_blob **blob``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:734
#: drivers/gpu/drm/drm_property.c:758
msgid "a pointer to the member blob to be replaced"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:736
msgid "``struct drm_property_blob *new_blob``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:735
msgid "the new blob to replace with"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:737
msgid "true if the blob was in fact replaced."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:756
msgid "replace a blob property taking a reference"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:760
msgid "``uint64_t blob_id``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:759
msgid "the id of the new blob to replace with"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:761
msgid "``ssize_t expected_size``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:760
msgid "expected size of the blob property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:762
msgid "``ssize_t expected_elem_size``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:761
msgid "expected size of an element in the blob property"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:763
msgid "``bool *replaced``"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:762
msgid "if the blob was in fact replaced"
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:763
msgid ""
"Look up the new blob from id, take its reference, check expected sizes of "
"the blob and its element and replace the old blob by the new one. Advertise "
"if the replacement operation was successful."
msgstr ""

#: ../../../gpu/drm-kms:530: drivers/gpu/drm/drm_property.c:768
msgid ""
"true if the blob was in fact replaced. -EINVAL if the new blob was not found "
"or sizes don't match."
msgstr ""

#: ../../../gpu/drm-kms.rst:536
msgid "Standard Connector Properties"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1447
msgid "DRM connectors have a few standardized properties:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1449
msgid "EDID:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1450
msgid ""
"Blob property which contains the current EDID read from the sink. This is "
"useful to parse sink identification information like vendor, model and "
"serial. Drivers should update this property by calling "
"drm_connector_update_edid_property(), usually after having parsed the EDID "
"using drm_add_edid_modes(). Userspace cannot change this property."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1457
msgid ""
"User-space should not parse the EDID to obtain information exposed via other "
"KMS properties (because the kernel might apply limits, quirks or fixups to "
"the EDID). For instance, user-space should not try to parse mode lists from "
"the EDID."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1461
msgid "DPMS:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1462
msgid ""
"Legacy property for setting the power state of the connector. For atomic "
"drivers this is only provided for backwards compatibility with existing "
"drivers, it remaps to controlling the \"ACTIVE\" property on the CRTC the "
"connector is linked to. Drivers should never set this property directly, it "
"is handled by the DRM core by calling the :c:type:`drm_connector_funcs.dpms "
"<drm_connector_funcs>` callback. For atomic drivers the remapping to the "
"\"ACTIVE\" property is implemented in the DRM core."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1470
msgid ""
"On atomic drivers any DPMS setproperty ioctl where the value does not change "
"is completely skipped, otherwise a full atomic commit will occur. On legacy "
"drivers the exact behavior is driver specific."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1474
msgid ""
"Note that this property cannot be set through the MODE_ATOMIC ioctl, "
"userspace must use \"ACTIVE\" on the CRTC instead."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1479
msgid ""
"For userspace also running on legacy drivers the \"DPMS\" semantics are a "
"lot more complicated. First, userspace cannot rely on the \"DPMS\" value "
"returned by the GETCONNECTOR actually reflecting reality, because many "
"drivers fail to update it. For atomic drivers this is taken care of in "
"drm_atomic_helper_update_legacy_modeset_state()."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1485
msgid ""
"The second issue is that the DPMS state is only well-defined when the "
"connector is connected to a CRTC. In atomic the DRM core enforces that "
"\"ACTIVE\" is off in such a case, no such checks exists for \"DPMS\"."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1489
msgid ""
"Finally, when enabling an output using the legacy SETCONFIG ioctl then "
"\"DPMS\" is forced to ON. But see above, that might not be reflected in the "
"software value on legacy drivers."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1493
msgid ""
"Summarizing: Only set \"DPMS\" when the connector is known to be enabled, "
"assume that a successful SETCONFIG call also sets \"DPMS\" to on, and never "
"read back the value of \"DPMS\" because it can be incorrect."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1496
msgid "PATH:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1497
msgid ""
"Connector path property to identify how this sink is physically connected. "
"Used by DP MST. This should be set by calling "
"drm_connector_set_path_property(), in the case of DP MST with the path "
"property the MST manager created. Userspace cannot change this property."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1503
msgid ""
"In the case of DP MST, the property has the format ``mst:<parent>-<ports>`` "
"where ``<parent>`` is the KMS object ID of the parent connector and "
"``<ports>`` is a hyphen-separated list of DP MST port numbers. Note, KMS "
"object IDs are not guaranteed to be stable across reboots."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1508
msgid "TILE:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1509
msgid ""
"Connector tile group property to indicate how a set of DRM connector compose "
"together into one logical screen. This is used by both high-res external "
"screens (often only using a single cable, but exposing multiple DP MST "
"sinks), or high-res integrated panels (like dual-link DSI) which are not gen-"
"locked. Note that for tiled panels which are genlocked, like dual-link LVDS "
"or dual-link DSI, the driver should try to not expose the tiling and "
"virtualise both :c:type:`drm_crtc` and :c:type:`drm_plane` if needed. "
"Drivers should update this value using drm_connector_set_tile_property(). "
"Userspace cannot change this property."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1518
msgid "link-status:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1519
msgid ""
"Connector link-status property to indicate the status of link. The default "
"value of link-status is \"GOOD\". If something fails during or after "
"modeset, the kernel driver may set this to \"BAD\" and issue a hotplug "
"uevent. Drivers should update this value using "
"drm_connector_set_link_status_property()."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1525
msgid ""
"When user-space receives the hotplug uevent and detects a \"BAD\" link-"
"status, the sink doesn't receive pixels anymore (e.g. the screen becomes "
"completely black). The list of available modes may have changed. User-space "
"is expected to pick a new mode if the current one has disappeared and "
"perform a new modeset with link-status set to \"GOOD\" to re-enable the "
"connector."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1532
msgid ""
"If multiple connectors share the same CRTC and one of them gets a \"BAD\" "
"link-status, the other are unaffected (ie. the sinks still continue to "
"receive pixels)."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1536
msgid ""
"When user-space performs an atomic commit on a connector with a \"BAD\" link-"
"status without resetting the property to \"GOOD\", the sink may still not "
"receive pixels. When user-space performs an atomic commit which resets the "
"link-status property to \"GOOD\" without the ALLOW_MODESET flag set, it "
"might fail because a modeset is required."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1542
msgid ""
"User-space can only change link-status to \"GOOD\", changing it to \"BAD\" "
"is a no-op."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1545
msgid ""
"For backwards compatibility with non-atomic userspace the kernel tries to "
"automatically set the link-status back to \"GOOD\" in the SETCRTC IOCTL. "
"This might fail if the mode is no longer valid, similar to how it might fail "
"if a different screen has been connected in the interim."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1550
msgid "non_desktop:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1551
msgid ""
"Indicates the output should be ignored for purposes of displaying a standard "
"desktop environment or console. This is most likely because the output "
"device is not rectilinear."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1554
msgid "Content Protection:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1555
msgid ""
"This property is used by userspace to request the kernel protect future "
"content communicated over the link. When requested, kernel will apply the "
"appropriate means of protection (most often HDCP), and use the property to "
"tell userspace the protection is active."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1560
msgid ""
"Drivers can set this up by calling "
"drm_connector_attach_content_protection_property() on initialization."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1563
#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1931
#: drivers/gpu/drm/drm_connector.c:1957 ../../../gpu/drm-kms:556:
#: drivers/gpu/drm/drm_crtc.c:224 ../../../gpu/drm-kms:562:
#: drivers/gpu/drm/drm_plane.c:86 ../../../gpu/drm-kms:570:
#: drivers/gpu/drm/drm_blend.c:199
msgid "The value of this property can be one of the following:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1565
msgid "DRM_MODE_CONTENT_PROTECTION_UNDESIRED = 0"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1566
msgid "The link is not protected, content is transmitted in the clear."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1567
msgid "DRM_MODE_CONTENT_PROTECTION_DESIRED = 1"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1568
msgid ""
"Userspace has requested content protection, but the link is not currently "
"protected. When in this state, kernel should enable Content Protection as "
"soon as possible."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1571
msgid "DRM_MODE_CONTENT_PROTECTION_ENABLED = 2"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1572
msgid ""
"Userspace has requested content protection, and the link is protected. Only "
"the driver can set the property to this value. If userspace attempts to set "
"to ENABLED, kernel will return -EINVAL."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1577
msgid "A few guidelines:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1579
msgid ""
"DESIRED state should be preserved until userspace de-asserts it by setting "
"the property to UNDESIRED. This means ENABLED should only transition to "
"UNDESIRED when the user explicitly requests it."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1582
msgid ""
"If the state is DESIRED, kernel should attempt to re-authenticate the link "
"whenever possible. This includes across disable/enable, dpms, hotplug, "
"downstream device changes, link status failures, etc.."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1585
msgid ""
"Kernel sends uevent with the connector id and property id through "
"**drm_hdcp_update_content_protection**, upon below kernel triggered "
"scenarios:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1589
msgid "DESIRED -> ENABLED (authentication success)"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1590
msgid "ENABLED -> DESIRED (termination of authentication)"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1591
msgid ""
"Please note no uevents for userspace triggered property state changes, which "
"can't fail such as"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1594
msgid "DESIRED/ENABLED -> UNDESIRED"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1595
msgid "UNDESIRED -> DESIRED"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1596
msgid ""
"Userspace is responsible for polling the property or listen to uevents to "
"determine when the value transitions from ENABLED to DESIRED. This signifies "
"the link is no longer protected and userspace should take appropriate action "
"(whatever that might be)."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1601
msgid "HDCP Content Type:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1602
msgid ""
"This Enum property is used by the userspace to declare the content type of "
"the display stream, to kernel. Here display stream stands for any display "
"content that userspace intended to display through HDCP encryption."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1607
msgid ""
"Content Type of a stream is decided by the owner of the stream, as \"HDCP "
"Type0\" or \"HDCP Type1\"."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1610
msgid "The value of the property can be one of the below:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1611
msgid "\"HDCP Type0\": DRM_MODE_HDCP_CONTENT_TYPE0 = 0"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1612
msgid "\"HDCP Type1\": DRM_MODE_HDCP_CONTENT_TYPE1 = 1"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1614
msgid ""
"When kernel starts the HDCP authentication (see \"Content Protection\" for "
"details), it uses the content type in \"HDCP Content Type\" for performing "
"the HDCP authentication with the display sink."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1618
msgid ""
"Please note in HDCP spec versions, a link can be authenticated with HDCP 2.2 "
"for Content Type 0/Content Type 1. Where as a link can be authenticated with "
"HDCP1.4 only for Content Type 0(though it is implicit in nature. As there is "
"no reference for Content Type in HDCP1.4)."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1623
msgid ""
"HDCP2.2 authentication protocol itself takes the \"Content Type\" as a "
"parameter, which is a input for the DP HDCP2.2 encryption algo."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1626
msgid ""
"In case of Type 0 content protection request, kernel driver can choose "
"either of HDCP spec versions 1.4 and 2.2. When HDCP2.2 is used for \"HDCP "
"Type 0\", a HDCP 2.2 capable repeater in the downstream can send that "
"content to a HDCP 1.4 authenticated HDCP sink (Type0 link). But if the "
"content is classified as \"HDCP Type 1\", above mentioned HDCP 2.2 repeater "
"wont send the content to the HDCP sink as it can't authenticate the HDCP1.4 "
"capable sink for \"HDCP Type 1\"."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1634
msgid ""
"Please note userspace can be ignorant of the HDCP versions used by the "
"kernel driver to achieve the \"HDCP Content Type\"."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1637
msgid ""
"At current scenario, classifying a content as Type 1 ensures that the "
"content will be displayed only through the HDCP2.2 encrypted link."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1640
msgid ""
"Note that the HDCP Content Type property is introduced at HDCP 2.2, and "
"defaults to type 0. It is only exposed by drivers supporting HDCP 2.2 (hence "
"supporting Type 0 and Type 1). Based on how next versions of HDCP specs are "
"defined content Type could be used for higher versions too."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1646
msgid ""
"If content type is changed when \"Content Protection\" is not UNDESIRED, "
"then kernel will disable the HDCP and re-enable with new type in the same "
"atomic commit. And when \"Content Protection\" is ENABLED, it means that "
"link is HDCP authenticated and encrypted, for the transmission of the Type "
"of stream mentioned at \"HDCP Content Type\"."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1652
msgid "HDR_OUTPUT_METADATA:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1653
msgid ""
"Connector property to enable userspace to send HDR Metadata to driver. This "
"metadata is based on the composition and blending policies decided by user, "
"taking into account the hardware and sink capabilities. The driver gets this "
"metadata and creates a Dynamic Range and Mastering Infoframe (DRM) in case "
"of HDMI, SDP packet (Non-audio INFOFRAME SDP v1.3) for DP. This is then sent "
"to sink. This notifies the sink of the upcoming frame's Color Encoding and "
"Luminance parameters."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1662
msgid ""
"Userspace first need to detect the HDR capabilities of sink by reading and "
"parsing the EDID. Details of HDR metadata for HDMI are added in CTA 861.G "
"spec. For DP , its defined in VESA DP Standard v1.4. It needs to then get "
"the metadata information of the video/game/app content which are encoded in "
"HDR (basically using HDR transfer functions). With this information it needs "
"to decide on a blending policy and compose the relevant layers/overlays into "
"a common format. Once this blending is done, userspace will be aware of the "
"metadata of the composed frame to be send to sink. It then uses this "
"property to communicate this metadata to driver which then make a Infoframe "
"packet and sends to sink based on the type of encoder connected."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1675
msgid "Userspace will be responsible to do Tone mapping operation in case:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1676
msgid "Some layers are HDR and others are SDR"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1677
msgid "HDR layers luminance is not same as sink"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1679
msgid ""
"It will even need to do colorspace conversion and get all layers to one "
"common colorspace for blending. It can use either GL, Media or display "
"engine to get this done based on the capabilities of the associated hardware."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1684
msgid ""
"Driver expects metadata to be put in :c:type:`struct hdr_output_metadata "
"<hdr_output_metadata>` structure from userspace. This is received as blob "
"and stored in :c:type:`drm_connector_state.hdr_output_metadata "
"<drm_connector_state>`. It parses EDID and saves the sink metadata in :c:"
"type:`struct hdr_sink_metadata <hdr_sink_metadata>`, as :c:type:"
"`drm_connector.display_info <drm_connector>`.hdr_sink_metadata.  Driver uses "
"drm_hdmi_infoframe_set_hdr_metadata() helper to set the HDR metadata, "
"hdmi_drm_infoframe_pack() to pack the infoframe as per spec, in case of HDMI "
"encoder."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1693
msgid "max bpc:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1694
msgid ""
"This range property is used by userspace to limit the bit depth. When used "
"the driver would limit the bpc in accordance with the valid range supported "
"by the hardware and sink. Drivers to use the function "
"drm_connector_attach_max_bpc_property() to create and attach the property to "
"the connector during initialization."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1700
msgid "Connectors also have one standardized atomic property:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1702
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:82
msgid "CRTC_ID:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1703
msgid ""
"Mode object ID of the :c:type:`drm_crtc` this connector should be connected "
"to."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1705
msgid "Connectors for LCD panels may also have one standardized property:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1707
msgid "panel orientation:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1708
msgid ""
"On some devices the LCD panel is mounted in the casing in such a way that "
"the up/top side of the panel does not match with the top side of the device. "
"Userspace can use this property to check for this. Note that input "
"coordinates from touchscreens (input devices with INPUT_PROP_DIRECT) will "
"still map 1:1 to the actual LCD panel coordinates, so if userspace rotates "
"the picture to adjust for the orientation it must also apply the same "
"transformation to the touchscreen input coordinates. This property is "
"initialized by calling drm_connector_set_panel_orientation() or "
"drm_connector_set_panel_orientation_with_quirk()"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1719
msgid "scaling mode:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1720
msgid ""
"This property defines how a non-native mode is upscaled to the native mode "
"of an LCD panel:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1723
msgid "None:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1724
msgid ""
"No upscaling happens, scaling is left to the panel. Not all drivers expose "
"this mode."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1726
#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1938
msgid "Full:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1727
msgid ""
"The output is upscaled to the full resolution of the panel, ignoring the "
"aspect ratio."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1729
msgid "Center:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1730
msgid ""
"No upscaling happens, the output is centered within the native resolution "
"the panel."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1732
msgid "Full aspect:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1733
msgid ""
"The output is upscaled to maximize either the width or height while "
"retaining the aspect ratio."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1736
msgid ""
"This property should be set up by calling "
"drm_connector_attach_scaling_mode_property(). Note that drivers can also "
"expose this property to external outputs, in which case they must support "
"\"None\", which should be the default (since external screens have a built-"
"in scaler)."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1742
msgid "subconnector:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1743
msgid ""
"This property is used by DVI-I, TVout and DisplayPort to indicate different "
"connector subtypes. Enum values more or less match with those from main "
"connector types. For DVI-I and TVout there is also a matching property "
"\"select subconnector\" allowing to switch between signal types. DP "
"subconnector corresponds to a downstream port."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1750
msgid "privacy-screen sw-state, privacy-screen hw-state:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1751
msgid ""
"These 2 optional properties can be used to query the state of the electronic "
"privacy screen that is available on some displays; and in some cases also "
"control the state. If a driver implements these properties then both "
"properties must be present."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1756
msgid ""
"\"privacy-screen hw-state\" is read-only and reflects the actual state of "
"the privacy-screen, possible values: \"Enabled\", \"Disabled, \"Enabled-"
"locked\", \"Disabled-locked\". The locked states indicate that the state "
"cannot be changed through the DRM API. E.g. there might be devices where the "
"firmware-setup options, or a hardware slider-switch, offer always on / off "
"modes."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1763
msgid ""
"\"privacy-screen sw-state\" can be set to change the privacy-screen state "
"when not locked. In this case the driver must update the hw-state property "
"to reflect the new state on completion of the commit of the sw-state "
"property. Setting the sw-state property when the hw-state is locked must be "
"interpreted by the driver as a request to change the state to the set state "
"when the hw-state becomes unlocked. E.g. if \"privacy-screen hw-state\" is "
"\"Enabled-locked\" and the sw-state gets set to \"Disabled\" followed by the "
"user unlocking the state by changing the slider-switch position, then the "
"driver must set the state to \"Disabled\" upon receiving the unlock event."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1774
msgid ""
"In some cases the privacy-screen's actual state might change outside of "
"control of the DRM code. E.g. there might be a firmware handled hotkey which "
"toggles the actual state, or the actual state might be changed through "
"another userspace API such as writing /proc/acpi/ibm/lcdshadow. In this case "
"the driver must update both the hw-state and the sw-state to reflect the new "
"value, overwriting any pending state requests in the sw-state. Any pending "
"sw-state requests are thus discarded."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1782
msgid ""
"Note that the ability for the state to change outside of control of the DRM "
"master process means that userspace must not cache the value of the sw-"
"state. Caching the sw-state value and including it in later atomic commits "
"may lead to overriding a state change done through e.g. a firmware handled "
"hotkey. Therefor userspace must not include the privacy-screen sw-state in "
"an atomic commit unless it wants to change its value."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1790
msgid "left margin, right margin, top margin, bottom margin:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1791
msgid ""
"Add margins to the connector's viewport. This is typically used to mitigate "
"overscan on TVs."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1794
msgid ""
"The value is the size in pixels of the black border which will be added. The "
"attached CRTC's content will be scaled to fill the whole area inside the "
"margin."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1798
msgid ""
"The margins configuration might be sent to the sink, e.g. via HDMI AVI "
"InfoFrames."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:1801
msgid ""
"Drivers can set up these properties by calling "
"drm_mode_create_tv_margin_properties()."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2488
msgid "Colorspace:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2489
msgid ""
"This property is used to inform the driver about the color encoding user "
"space configured the pixel operation properties to produce. The variants set "
"the colorimetry, transfer characteristics, and which YCbCr conversion should "
"be used when necessary. The transfer characteristics from "
"HDR_OUTPUT_METADATA takes precedence over this property. User space always "
"configures the pixel operation properties to produce full quantization range "
"data (see the Broadcast RGB property)."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2498
msgid ""
"Drivers inform the sink about what colorimetry, transfer characteristics, "
"YCbCr conversion, and quantization range to expect (this can depend on the "
"output mode, output format and other properties). Drivers also convert the "
"user space provided data to what the sink expects."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2504
msgid ""
"User space has to check if the sink supports all of the possible "
"colorimetries that the driver is allowed to pick by parsing the EDID."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2507
msgid ""
"For historical reasons this property exposes a number of variants which "
"result in undefined behavior."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2510
#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:226
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:201
msgid "Default:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2511
msgid "The behavior is driver-specific."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2513
msgid "BT2020_RGB:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2515
msgid "BT2020_YCC:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2516
msgid ""
"User space configures the pixel operation properties to produce RGB content "
"with Rec. ITU-R BT.2020 colorimetry, Rec. ITU-R BT.2020 (Table 4, RGB) "
"transfer characteristics and full quantization range. User space can use the "
"HDR_OUTPUT_METADATA property to set the transfer characteristics to PQ (Rec. "
"ITU-R BT.2100 Table 4) or HLG (Rec. ITU-R BT.2100 Table 5) in which case, "
"user space configures pixel operation properties to produce content with the "
"respective transfer characteristics. User space has to make sure the sink "
"supports Rec. ITU-R BT.2020 R'G'B' and Rec. ITU-R BT.2020 Y'C'BC'R "
"colorimetry. Drivers can configure the sink to use an RGB format, tell the "
"sink to expect Rec. ITU-R BT.2020 R'G'B' colorimetry and convert to the "
"appropriate quantization range. Drivers can configure the sink to use a "
"YCbCr format, tell the sink to expect Rec. ITU-R BT.2020 Y'C'BC'R "
"colorimetry, convert to YCbCr using the Rec. ITU-R BT.2020 non-constant "
"luminance conversion matrix and convert to the appropriate quantization "
"range. The variants BT2020_RGB and BT2020_YCC are equivalent and the driver "
"chooses between RGB and YCbCr on its own."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2539
msgid ""
"SMPTE_170M_YCC: BT709_YCC: XVYCC_601: XVYCC_709: SYCC_601: opYCC_601: opRGB: "
"BT2020_CYCC: DCI-P3_RGB_D65: DCI-P3_RGB_Theater: RGB_WIDE_FIXED: "
"RGB_WIDE_FLOAT:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2552
msgid "BT601_YCC:"
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2553
msgid "The behavior is undefined."
msgstr ""

#: ../../../gpu/drm-kms:538: drivers/gpu/drm/drm_connector.c:2555
msgid ""
"Because between HDMI and DP have different colorspaces, "
"drm_mode_create_hdmi_colorspace_property() is used for HDMI connector and "
"drm_mode_create_dp_colorspace_property() is used for DP connector."
msgstr ""

#: ../../../gpu/drm-kms.rst:542
msgid "HDMI Specific Connector Properties"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1920
msgid "Broadcast RGB (HDMI specific)"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1921
msgid ""
"Indicates the Quantization Range (Full vs Limited) used. The color "
"processing pipeline will be adjusted to match the value of the property, and "
"the Infoframes will be generated and sent accordingly."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1925
msgid ""
"This property is only relevant if the HDMI output format is RGB. If it's one "
"of the YCbCr variant, it will be ignored."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1928
msgid ""
"The CRTC attached to the connector must be configured by user-space to "
"always produce full-range pixels."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1933
msgid "Automatic:"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1934
msgid ""
"The quantization range is selected automatically based on the mode according "
"to the HDMI specifications (HDMI 1.4b - Section 6.6 - Video Quantization "
"Ranges)."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1939
msgid "Full quantization range is forced."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1941
msgid "Limited 16:235:"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1942
msgid ""
"Limited quantization range is forced. Unlike the name suggests, this works "
"for any number of bits-per-component."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1945
msgid ""
"Property values other than Automatic can result in colors being off (if "
"limited is selected but the display expects full), or a black screen (if "
"full is selected but the display expects limited)."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1949
msgid ""
"Drivers can set up this property by calling "
"drm_connector_attach_broadcast_rgb_property()."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1952
msgid "content type (HDMI specific):"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1953
msgid ""
"Indicates content type setting to be used in HDMI infoframes to indicate "
"content type for the external device, so that it adjusts its display "
"settings accordingly."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1959
msgid "No Data:"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1960
msgid "Content type is unknown"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1961
msgid "Graphics:"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1962
msgid "Content type is graphics"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1963
msgid "Photo:"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1964
msgid "Content type is photo"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1965
msgid "Cinema:"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1966
msgid "Content type is cinema"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1967
msgid "Game:"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1968
msgid "Content type is game"
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1970
msgid "The meaning of each content type is defined in CTA-861-G table 15."
msgstr ""

#: ../../../gpu/drm-kms:544: drivers/gpu/drm/drm_connector.c:1972
msgid ""
"Drivers can set up this property by calling "
"drm_connector_attach_content_type_property(). Decoding to infoframe values "
"is done through drm_hdmi_avi_infoframe_content_type()."
msgstr ""

#: ../../../gpu/drm-kms.rst:548
msgid "Analog TV Specific Connector Properties"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:1991
msgid "TV Mode:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:1992
msgid ""
"Indicates the TV Mode used on an analog TV connector. The value of this "
"property can be one of the following:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:1995
msgid "NTSC:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:1996
msgid ""
"TV Mode is CCIR System M (aka 525-lines) together with the NTSC Color "
"Encoding."
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:1999
msgid "NTSC-443:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2001
msgid ""
"TV Mode is CCIR System M (aka 525-lines) together with the NTSC Color "
"Encoding, but with a color subcarrier frequency of 4.43MHz"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2005
msgid "NTSC-J:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2007
msgid ""
"TV Mode is CCIR System M (aka 525-lines) together with the NTSC Color "
"Encoding, but with a black level equal to the blanking level."
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2011
msgid "PAL:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2013
msgid ""
"TV Mode is CCIR System B (aka 625-lines) together with the PAL Color "
"Encoding."
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2016
msgid "PAL-M:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2018
msgid ""
"TV Mode is CCIR System M (aka 525-lines) together with the PAL Color "
"Encoding."
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2021
msgid "PAL-N:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2023
msgid ""
"TV Mode is CCIR System N together with the PAL Color Encoding, a color "
"subcarrier frequency of 3.58MHz, the SECAM color space, and narrower "
"channels than other PAL variants."
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2028
msgid "SECAM:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2030
msgid ""
"TV Mode is CCIR System B (aka 625-lines) together with the SECAM Color "
"Encoding."
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2033
msgid "Mono:"
msgstr ""

#: ../../../gpu/drm-kms:550: drivers/gpu/drm/drm_connector.c:2039
msgid ""
"Drivers can set up this property by calling drm_mode_create_tv_properties()."
msgstr ""

#: ../../../gpu/drm-kms.rst:554
msgid "Standard CRTC Properties"
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:199
msgid "DRM CRTCs have a few standardized properties:"
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:201
msgid "ACTIVE:"
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:202
msgid ""
"Atomic property for setting the power state of the CRTC. When set to 1 the "
"CRTC will actively display content. When set to 0 the CRTC will be powered "
"off. There is no expectation that user-space will reset CRTC resources like "
"the mode and planes when setting ACTIVE to 0."
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:207
msgid ""
"User-space can rely on an ACTIVE change to 1 to never fail an atomic test as "
"long as no other property has changed. If a change to ACTIVE fails an atomic "
"test, this is a driver bug. For this reason setting ACTIVE to 0 must not "
"release internal resources (like reserved memory bandwidth or clock "
"generators)."
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:213
msgid ""
"Note that the legacy DPMS property on connectors is internally routed to "
"control this property for atomic drivers."
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:215
msgid "MODE_ID:"
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:216
msgid ""
"Atomic property for setting the CRTC display timings. The value is the ID of "
"a blob containing the DRM mode info. To disable the CRTC, user-space must "
"set this property to 0."
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:220
msgid "Setting MODE_ID to 0 will release reserved resources for the CRTC."
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:221
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:196
msgid "SCALING_FILTER:"
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:222
msgid "Atomic property for setting the scaling filter for CRTC scaler"
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:227
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:202
msgid "Driver's default scaling filter"
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:228
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:203
msgid "Nearest Neighbor:"
msgstr ""

#: ../../../gpu/drm-kms:556: drivers/gpu/drm/drm_crtc.c:229
#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:204
msgid "Nearest Neighbor scaling filter"
msgstr ""

#: ../../../gpu/drm-kms.rst:560
msgid "Standard Plane Properties"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:76
msgid "DRM planes have a few standardized properties:"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:78
msgid "type:"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:79
msgid "Immutable property describing the type of the plane."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:81
msgid ""
"For user-space which has enabled the :c:type:`DRM_CLIENT_CAP_ATOMIC` "
"capability, the plane type is just a hint and is mostly superseded by atomic "
"test-only commits. The type hint can still be used to come up more easily "
"with a plane configuration accepted by the driver."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:88
msgid "\"Primary\":"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:89
msgid ""
"To light up a CRTC, attaching a primary plane is the most likely to work if "
"it covers the whole CRTC and doesn't have scaling or cropping set up."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:93
msgid ""
"Drivers may support more features for the primary plane, user-space can find "
"out with test-only atomic commits."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:96
msgid ""
"Some primary planes are implicitly used by the kernel in the legacy IOCTLs :"
"c:type:`DRM_IOCTL_MODE_SETCRTC` and :c:type:`DRM_IOCTL_MODE_PAGE_FLIP`. "
"Therefore user-space must not mix explicit usage of any primary plane (e.g. "
"through an atomic commit) with these legacy IOCTLs."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:101
msgid "\"Cursor\":"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:102
msgid ""
"To enable this plane, using a framebuffer configured without scaling or "
"cropping and with the following properties is the most likely to work:"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:106
msgid ""
"If the driver provides the capabilities :c:type:`DRM_CAP_CURSOR_WIDTH` and :"
"c:type:`DRM_CAP_CURSOR_HEIGHT`, create the framebuffer with this size. "
"Otherwise, create a framebuffer with the size 64x64."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:109
msgid ""
"If the driver doesn't support modifiers, create a framebuffer with a linear "
"layout. Otherwise, use the IN_FORMATS plane property."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:112
msgid ""
"Drivers may support more features for the cursor plane, user-space can find "
"out with test-only atomic commits."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:115
msgid ""
"Some cursor planes are implicitly used by the kernel in the legacy IOCTLs :c:"
"type:`DRM_IOCTL_MODE_CURSOR` and :c:type:`DRM_IOCTL_MODE_CURSOR2`. Therefore "
"user-space must not mix explicit usage of any cursor plane (e.g. through an "
"atomic commit) with these legacy IOCTLs."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:120
msgid ""
"Some drivers may support cursors even if no cursor plane is exposed. In this "
"case, the legacy cursor IOCTLs can be used to configure the cursor."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:124
msgid "\"Overlay\":"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:125
msgid "Neither primary nor cursor."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:127
msgid ""
"Overlay planes are the only planes exposed when the :c:type:"
"`DRM_CLIENT_CAP_UNIVERSAL_PLANES` capability is disabled."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:130
msgid "IN_FORMATS:"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:131
msgid ""
"Blob property which contains the set of buffer format and modifier pairs "
"supported by this plane. The blob is a struct drm_format_modifier_blob. "
"Without this property the plane doesn't support buffers with modifiers. "
"Userspace cannot change this property."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:136
msgid ""
"Note that userspace can check the :c:type:`DRM_CAP_ADDFB2_MODIFIERS` driver "
"capability for general modifier support. If this flag is set then every "
"plane will have the IN_FORMATS property, even when it only supports "
"DRM_FORMAT_MOD_LINEAR. Before linux kernel release v5.1 there have been "
"various bugs in this area with inconsistencies between the capability flag "
"and per-plane properties."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:143
msgid "IN_FORMATS_ASYNC:"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:144
msgid ""
"Blob property which contains the set of buffer format and modifier pairs "
"supported by this plane for asynchronous flips. The blob is a struct "
"drm_format_modifier_blob. Userspace cannot change this property. This is an "
"optional property and if not present then user should expect a failure in "
"atomic ioctl when the modifier/format is not supported by that plane under "
"asynchronous flip."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:151
msgid "SIZE_HINTS:"
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:152
msgid ""
"Blob property which contains the set of recommended plane size which can "
"used for simple \"cursor like\" use cases (eg. no scaling). Using these "
"hints frees userspace from extensive probing of supported plane sizes "
"through atomic/setcursor ioctls."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:157
msgid ""
"The blob contains an array of struct drm_plane_size_hint, in order of "
"preference. For optimal usage userspace should pick the first size that "
"satisfies its own requirements."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:161
msgid ""
"Drivers should only attach this property to planes that support a very "
"limited set of sizes."
msgstr ""

#: ../../../gpu/drm-kms:562: drivers/gpu/drm/drm_plane.c:164
msgid ""
"Note that property value 0 (ie. no blob) is reserved for potential future "
"use. Current userspace is expected to ignore the property if the value is 0, "
"and fall back to some other means (eg. :c:type:`DRM_CAP_CURSOR_WIDTH` and :c:"
"type:`DRM_CAP_CURSOR_HEIGHT`) to determine the appropriate plane size to use."
msgstr ""

#: ../../../gpu/drm-kms.rst:568
msgid "Plane Composition Properties"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:39
msgid ""
"The basic plane composition model supported by standard plane properties "
"only has a source rectangle (in logical pixels within the :c:type:"
"`drm_framebuffer`), with sub-pixel accuracy, which is scaled up to a pixel-"
"aligned destination rectangle in the visible area of a :c:type:`drm_crtc`. "
"The visible area of a CRTC is defined by the horizontal and vertical visible "
"pixels (stored in **hdisplay** and **vdisplay**) of the requested mode "
"(stored in :c:type:`drm_crtc_state.mode <drm_crtc_state>`). These two "
"rectangles are both stored in the :c:type:`drm_plane_state`."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:47
msgid ""
"For the atomic ioctl the following standard (atomic) properties on the plane "
"object encode the basic plane composition model:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:50
msgid "SRC_X:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:51
msgid ""
"X coordinate offset for the source rectangle within the :c:type:"
"`drm_framebuffer`, in 16.16 fixed point. Must be positive."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:53
msgid "SRC_Y:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:54
msgid ""
"Y coordinate offset for the source rectangle within the :c:type:"
"`drm_framebuffer`, in 16.16 fixed point. Must be positive."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:56
msgid "SRC_W:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:57
msgid ""
"Width for the source rectangle within the :c:type:`drm_framebuffer`, in "
"16.16 fixed point. SRC_X plus SRC_W must be within the width of the source "
"framebuffer. Must be positive."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:60
msgid "SRC_H:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:61
msgid ""
"Height for the source rectangle within the :c:type:`drm_framebuffer`, in "
"16.16 fixed point. SRC_Y plus SRC_H must be within the height of the source "
"framebuffer. Must be positive."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:64
msgid "CRTC_X:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:65
msgid "X coordinate offset for the destination rectangle. Can be negative."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:66
msgid "CRTC_Y:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:67
msgid "Y coordinate offset for the destination rectangle. Can be negative."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:68
msgid "CRTC_W:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:69
msgid ""
"Width for the destination rectangle. CRTC_X plus CRTC_W can extend past the "
"currently visible horizontal area of the :c:type:`drm_crtc`."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:71
msgid "CRTC_H:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:72
msgid ""
"Height for the destination rectangle. CRTC_Y plus CRTC_H can extend past the "
"currently visible vertical area of the :c:type:`drm_crtc`."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:74
msgid "FB_ID:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:75
msgid ""
"Mode object ID of the :c:type:`drm_framebuffer` this plane should scan out."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:77
msgid ""
"When a KMS client is performing front-buffer rendering, it should set FB_ID "
"to the same front-buffer FB on each atomic commit. This implies to the "
"driver that it needs to re-read the same FB again. Otherwise drivers which "
"do not employ continuously repeated scanout cycles might not update the "
"screen."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:83
msgid ""
"Mode object ID of the :c:type:`drm_crtc` this plane should be connected to."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:85
msgid ""
"Note that the source rectangle must fully lie within the bounds of the :c:"
"type:`drm_framebuffer`. The destination rectangle can lie outside of the "
"visible area of the current mode of the CRTC. It must be appropriately "
"clipped by the driver, which can be done by calling "
"drm_plane_helper_check_update(). Drivers are also allowed to round the "
"subpixel sampling positions appropriately, but only to the next full pixel. "
"No pixel outside of the source rectangle may ever be sampled, which is "
"important when applying more sophisticated filtering than just a bilinear "
"one when scaling. The filtering mode when scaling is unspecified."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:95
msgid ""
"On top of this basic transformation additional properties can be exposed by "
"the driver:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:98
msgid "alpha:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:99
msgid ""
"Alpha is setup with drm_plane_create_alpha_property(). It controls the plane-"
"wide opacity, from transparent (0) to opaque (0xffff). It can be combined "
"with pixel alpha. The pixel values in the framebuffers are expected to not "
"be pre-multiplied by the global alpha associated to the plane."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:105
msgid "rotation:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:106
msgid ""
"Rotation is set up with drm_plane_create_rotation_property(). It adds a "
"rotation and reflection step between the source and destination rectangles. "
"Without this property the rectangle is only scaled, but not rotated or "
"reflected."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:111
msgid "Possbile values:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:113
msgid "\"rotate-<degrees>\":"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:114
msgid ""
"Signals that a drm plane is rotated <degrees> degrees in counter clockwise "
"direction."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:117
msgid "\"reflect-<axis>\":"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:118
msgid ""
"Signals that the contents of a drm plane is reflected along the <axis> axis, "
"in the same way as mirroring."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:121
msgid "reflect-x::"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:127
msgid "reflect-y::"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:133
msgid "zpos:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:134
msgid ""
"Z position is set up with drm_plane_create_zpos_immutable_property() and "
"drm_plane_create_zpos_property(). It controls the visibility of overlapping "
"planes. Without this property the primary plane is always below the cursor "
"plane, and ordering between all other planes is undefined. The positive Z "
"axis points towards the user, i.e. planes with lower Z position values are "
"underneath planes with higher Z position values. Two planes with the same Z "
"position value have undefined ordering. Note that the Z position value can "
"also be immutable, to inform userspace about the hard-coded stacking of "
"planes, see drm_plane_create_zpos_immutable_property(). If any plane has a "
"zpos property (either mutable or immutable), then all planes shall have a "
"zpos property."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:146
msgid "pixel blend mode:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:147
msgid ""
"Pixel blend mode is set up with drm_plane_create_blend_mode_property(). It "
"adds a blend mode for alpha blending equation selection, describing how the "
"pixels from the current plane are composited with the background."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:152
msgid "Three alpha blending equations are defined:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:155
msgid "Blend formula that ignores the pixel alpha::"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:161
msgid ""
"Blend formula that assumes the pixel color values have been already pre-"
"multiplied with the alpha channel values::"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:169
msgid ""
"Blend formula that assumes the pixel color values have not been pre-"
"multiplied and will do so when blending them to the background color values::"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:176
msgid "Using the following symbols:"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:178
msgid "\"fg.rgb\":"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:179
msgid "Each of the RGB component values from the plane's pixel"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:180
msgid "\"fg.alpha\":"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:181
msgid ""
"Alpha component value from the plane's pixel. If the plane's pixel format "
"has no alpha component, then this is assumed to be 1.0. In these cases, this "
"property has no effect, as all three equations become equivalent."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:185
msgid "\"bg.rgb\":"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:186
msgid "Each of the RGB component values from the background"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:187
msgid "\"plane_alpha\":"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:188
msgid ""
"Plane alpha value set by the plane \"alpha\" property. If the plane does not "
"expose the \"alpha\" property, then this is assumed to be 1.0"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:192
msgid ""
"Note that all the property extensions described here apply either to the "
"plane or the CRTC (e.g. for the background color, which currently is not "
"exposed and assumed to be black)."
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:197
msgid "Indicates scaling filter to be used for plane scaler"
msgstr ""

#: ../../../gpu/drm-kms:570: drivers/gpu/drm/drm_blend.c:206
msgid ""
"Drivers can set up this property for a plane by calling "
"drm_plane_create_scaling_filter_property"
msgstr ""

#: ../../../gpu/drm-kms.rst:576
msgid "Damage Tracking Properties"
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1581
msgid ""
"FB_DAMAGE_CLIPS is an optional plane property which provides a means to "
"specify a list of damage rectangles on a plane in framebuffer coordinates of "
"the framebuffer attached to the plane. In current context damage is the area "
"of plane framebuffer that has changed since last plane update (also called "
"page-flip), irrespective of whether currently attached framebuffer is same "
"as framebuffer attached during last plane update or not."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1588
msgid ""
"FB_DAMAGE_CLIPS is a hint to kernel which could be helpful for some drivers "
"to optimize internally especially for virtual devices where each framebuffer "
"change needs to be transmitted over network, usb, etc."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1592
msgid ""
"Since FB_DAMAGE_CLIPS is a hint so it is an optional property. User-space "
"can ignore damage clips property and in that case driver will do a full "
"plane update. In case damage clips are provided then it is guaranteed that "
"the area inside damage clips will be updated to plane. For efficiency driver "
"can do full update or can update more than specified in damage clips. Since "
"driver is free to read more, user-space must always render the entire "
"visible framebuffer. Otherwise there can be corruptions. Also, if a user-"
"space provides damage clips which doesn't encompass the actual damage to "
"framebuffer (since last plane update) can result in incorrect rendering."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1602
msgid ""
"FB_DAMAGE_CLIPS is a blob property with the layout of blob data is simply an "
"array of :c:type:`drm_mode_rect`. Unlike plane :c:type:`drm_plane_state.src "
"<drm_plane_state>` coordinates, damage clips are not in 16.16 fixed point. "
"Similar to plane src in framebuffer, damage clips cannot be negative. In "
"damage clip, x1/y1 are inclusive and x2/y2 are exclusive. While kernel does "
"not error for overlapped damage clips, it is strongly discouraged."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1609
msgid ""
"Drivers that are interested in damage interface for plane should enable "
"FB_DAMAGE_CLIPS property by calling drm_plane_enable_fb_damage_clips(). "
"Drivers implementing damage can use drm_atomic_helper_damage_iter_init() and "
"drm_atomic_helper_damage_iter_next() helper iterator function to get damage "
"rectangles clipped to :c:type:`drm_plane_state.src <drm_plane_state>`."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1615
msgid ""
"Note that there are two types of damage handling: frame damage and buffer "
"damage, the type of damage handling implemented depends on a driver's upload "
"target. Drivers implementing a per-plane or per-CRTC upload target need to "
"handle frame damage, while drivers implementing a per-buffer upload target "
"need to handle buffer damage."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1621
msgid ""
"The existing damage helpers only support the frame damage type, there is no "
"buffer age support or similar damage accumulation algorithm implemented yet."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1624
msgid ""
"Only drivers handling frame damage can use the mentioned damage helpers to "
"iterate over the damaged regions. Drivers that handle buffer damage, must "
"set :c:type:`drm_plane_state.ignore_damage_clips <drm_plane_state>` for "
"drm_atomic_helper_damage_iter_init() to know that damage clips should be "
"ignored and return :c:type:`drm_plane_state.src <drm_plane_state>` as the "
"damage rectangle, to force a full plane update."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1630
msgid ""
"Drivers with a per-buffer upload target could compare the :c:type:"
"`drm_plane_state.fb <drm_plane_state>` of the old and new plane states to "
"determine if the framebuffer attached to a plane has changed or not since "
"the last plane update. If :c:type:`drm_plane_state.fb <drm_plane_state>` has "
"changed, then :c:type:`drm_plane_state.ignore_damage_clips "
"<drm_plane_state>` must be set to true."
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1635
msgid ""
"That is because drivers with a per-plane upload target, expect the backing "
"storage buffer to not change for a given plane. If the upload buffer changes "
"between page flips, the new upload buffer has to be updated as a whole. This "
"can be improved in the future if support for frame damage is added to the "
"DRM damage helpers, similarly to how user-space already handle this case as "
"it is explained in the following documents:"
msgstr ""

#: ../../../gpu/drm-kms:578: drivers/gpu/drm/drm_plane.c:1642
msgid ""
"https://registry.khronos.org/EGL/extensions/KHR/"
"EGL_KHR_swap_buffers_with_damage.txt https://emersion.fr/blog/2019/intro-to-"
"damage-tracking/"
msgstr ""

#: ../../../gpu/drm-kms.rst:582
msgid "Color Management Properties"
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:37
msgid ""
"Color management or color space adjustments is supported through a set of 5 "
"properties on the :c:type:`drm_crtc` object. They are set up by calling "
"drm_crtc_enable_color_mgmt()."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:41
msgid "\"DEGAMMA_LUT”:"
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:42
msgid ""
"Blob property to set the degamma lookup table (LUT) mapping pixel data from "
"the framebuffer before it is given to the transformation matrix. The data is "
"interpreted as an array of :c:type:`struct drm_color_lut <drm_color_lut>` "
"elements. Hardware might choose not to use the full precision of the LUT "
"elements nor use all the elements of the LUT (for example the hardware might "
"choose to interpolate between LUT[0] and LUT[4])."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:49
msgid ""
"Setting this to NULL (blob property value set to 0) means a linear/pass-thru "
"gamma table should be used. This is generally the driver boot-up state too. "
"Drivers can access this blob through :c:type:`drm_crtc_state.degamma_lut "
"<drm_crtc_state>`."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:54
msgid "“DEGAMMA_LUT_SIZE”:"
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:55
msgid ""
"Unsinged range property to give the size of the lookup table to be set on "
"the DEGAMMA_LUT property (the size depends on the underlying hardware). If "
"drivers support multiple LUT sizes then they should publish the largest "
"size, and sub-sample smaller sized LUTs (e.g. for split-gamma modes) "
"appropriately."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:61
msgid "“CTM”:"
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:62
msgid ""
"Blob property to set the current transformation matrix (CTM) apply to pixel "
"data after the lookup through the degamma LUT and before the lookup through "
"the gamma LUT. The data is interpreted as a struct :c:type:`drm_color_ctm`."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:67
msgid ""
"Setting this to NULL (blob property value set to 0) means a unit/pass-thru "
"matrix should be used. This is generally the driver boot-up state too. "
"Drivers can access the blob for the color conversion matrix through :c:type:"
"`drm_crtc_state.ctm <drm_crtc_state>`."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:72
msgid "“GAMMA_LUT”:"
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:73
msgid ""
"Blob property to set the gamma lookup table (LUT) mapping pixel data after "
"the transformation matrix to data sent to the connector. The data is "
"interpreted as an array of :c:type:`struct drm_color_lut <drm_color_lut>` "
"elements. Hardware might choose not to use the full precision of the LUT "
"elements nor use all the elements of the LUT (for example the hardware might "
"choose to interpolate between LUT[0] and LUT[4])."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:80
msgid ""
"Setting this to NULL (blob property value set to 0) means a linear/pass-thru "
"gamma table should be used. This is generally the driver boot-up state too. "
"Drivers can access this blob through :c:type:`drm_crtc_state.gamma_lut "
"<drm_crtc_state>`."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:89
msgid "“GAMMA_LUT_SIZE”:"
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:90
msgid ""
"Unsigned range property to give the size of the lookup table to be set on "
"the GAMMA_LUT property (the size depends on the underlying hardware). If "
"drivers support multiple LUT sizes then they should publish the largest "
"size, and sub-sample smaller sized LUTs (e.g. for split-gamma modes) "
"appropriately."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:96
msgid ""
"There is also support for a legacy gamma table, which is set up by calling "
"drm_mode_crtc_set_gamma_size(). The DRM core will then alias the legacy "
"gamma ramp with \"GAMMA_LUT\" or, if that is unavailable, \"DEGAMMA_LUT\"."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:100
msgid ""
"Support for different non RGB color encodings is controlled through :c:type:"
"`drm_plane` specific COLOR_ENCODING and COLOR_RANGE properties. They are set "
"up by calling drm_plane_create_color_properties()."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:104
msgid "\"COLOR_ENCODING\":"
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:105
msgid ""
"Optional plane enum property to support different non RGB color encodings. "
"The driver can provide a subset of standard enum values supported by the DRM "
"plane."
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:109
msgid "\"COLOR_RANGE\":"
msgstr ""

#: ../../../gpu/drm-kms:584: drivers/gpu/drm/drm_color_mgmt.c:110
msgid ""
"Optional plane enum property to support different non RGB color parameter "
"ranges. The driver can provide a subset of standard enum values supported by "
"the DRM plane."
msgstr ""

#: ../../../gpu/drm-kms.rst:588
msgid "Tile Group Property"
msgstr ""

#: ../../../gpu/drm-kms:590: drivers/gpu/drm/drm_connector.c:3518
msgid ""
"Tile groups are used to represent tiled monitors with a unique integer "
"identifier. Tiled monitors using DisplayID v1.3 have a unique 8-byte handle, "
"we store this in a tile group, so we have a common identifier for all tiles "
"in a monitor group. The property is called \"TILE\". Drivers can manage tile "
"groups using drm_mode_create_tile_group(), drm_mode_put_tile_group() and "
"drm_mode_get_tile_group(). But this is only needed for internal panels where "
"the tile group information is exposed through a non-standard way."
msgstr ""

#: ../../../gpu/drm-kms.rst:594
msgid "Explicit Fencing Properties"
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1122
msgid ""
"Explicit fencing allows userspace to control the buffer synchronization "
"between devices. A Fence or a group of fences are transferred to/from "
"userspace using Sync File fds and there are two DRM properties for that. "
"IN_FENCE_FD on each DRM Plane to send fences to the kernel and OUT_FENCE_PTR "
"on each DRM CRTC to receive fences from the kernel."
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1128
msgid ""
"As a contrast, with implicit fencing the kernel keeps track of any ongoing "
"rendering, and automatically ensures that the atomic update waits for any "
"pending rendering to complete. This is usually tracked in :c:type:`struct "
"dma_resv <dma_resv>` which can also contain mandatory kernel fences. "
"Implicit syncing is how Linux traditionally worked (e.g. DRI2/3 on X.org), "
"whereas explicit fencing is what Android wants."
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1135
msgid "\"IN_FENCE_FD”:"
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1136
msgid ""
"Use this property to pass a fence that DRM should wait on before proceeding "
"with the Atomic Commit request and show the framebuffer for the plane on the "
"screen. The fence can be either a normal fence or a merged one, the "
"sync_file framework will handle both cases and use a fence_array if a merged "
"fence is received. Passing -1 here means no fences to wait on."
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1143
msgid ""
"If the Atomic Commit request has the DRM_MODE_ATOMIC_TEST_ONLY flag it will "
"only check if the Sync File is a valid one."
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1146
msgid ""
"On the driver side the fence is stored on the **fence** parameter of :c:type:"
"`struct drm_plane_state <drm_plane_state>`. Drivers which also support "
"implicit fencing should extract the implicit fence using "
"drm_gem_plane_helper_prepare_fb(), to make sure there's consistent behaviour "
"between drivers in precedence of implicit vs. explicit fencing."
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1152
msgid "\"OUT_FENCE_PTR”:"
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1153
msgid ""
"Use this property to pass a file descriptor pointer to DRM. Once the Atomic "
"Commit request call returns OUT_FENCE_PTR will be filled with the file "
"descriptor number of a Sync File. This Sync File contains the CRTC fence "
"that will be signaled when all framebuffers present on the Atomic Commit * "
"request for that given CRTC are scanned out on the screen."
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1160
msgid ""
"The Atomic Commit request fails if a invalid pointer is passed. If the "
"Atomic Commit request fails for any other reason the out fence fd returned "
"will be -1. On a Atomic Commit with the DRM_MODE_ATOMIC_TEST_ONLY flag the "
"out fence will also be set to -1."
msgstr ""

#: ../../../gpu/drm-kms:596: drivers/gpu/drm/drm_atomic_uapi.c:1165
msgid ""
"Note that out-fences don't have a special interface to drivers and are "
"internally represented by a :c:type:`struct drm_pending_vblank_event "
"<drm_pending_vblank_event>` in struct :c:type:`drm_crtc_state`, which is "
"also used by the nonblocking atomic commit helpers and for the DRM event "
"handling for existing userspace."
msgstr ""

#: ../../../gpu/drm-kms.rst:601
msgid "Variable Refresh Properties"
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2308
msgid ""
"Variable refresh rate capable displays can dynamically adjust their refresh "
"rate by extending the duration of their vertical front porch until page flip "
"or timeout occurs. This can reduce or remove stuttering and latency in "
"scenarios where the page flip does not align with the vblank interval."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2314
msgid ""
"An example scenario would be an application flipping at a constant rate of "
"48Hz on a 60Hz display. The page flip will frequently miss the vblank "
"interval and the same contents will be displayed twice. This can be observed "
"as stuttering for content with motion."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2319
msgid ""
"If variable refresh rate was active on a display that supported a variable "
"refresh range from 35Hz to 60Hz no stuttering would be observable for the "
"example scenario. The minimum supported variable refresh rate of 35Hz is "
"below the page flip frequency and the vertical front porch can be extended "
"until the page flip occurs. The vblank interval will be directly aligned to "
"the page flip rate."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2326
msgid ""
"Not all userspace content is suitable for use with variable refresh rate. "
"Large and frequent changes in vertical front porch duration may worsen "
"perceived stuttering for input sensitive applications."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2330
msgid ""
"Panel brightness will also vary with vertical front porch duration. Some "
"panels may have noticeable differences in brightness between the minimum "
"vertical front porch duration and the maximum vertical front porch duration. "
"Large and frequent changes in vertical front porch duration may produce "
"observable flickering for such panels."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2336
msgid ""
"Userspace control for variable refresh rate is supported via properties on "
"the :c:type:`drm_connector` and :c:type:`drm_crtc` objects."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2339
msgid "\"vrr_capable\":"
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2340
msgid ""
"Optional :c:type:`drm_connector` boolean property that drivers should attach "
"with drm_connector_attach_vrr_capable_property() on connectors that could "
"support variable refresh rates. Drivers should update the property value by "
"calling drm_connector_set_vrr_capable_property()."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2345
msgid "Absence of the property should indicate absence of support."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2347
msgid "\"VRR_ENABLED\":"
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2348
msgid ""
"Default :c:type:`drm_crtc` boolean property that notifies the driver that "
"the content on the CRTC is suitable for variable refresh rate presentation. "
"The driver will take this property as a hint to enable variable refresh rate "
"support if the receiver supports it, ie. if the \"vrr_capable\" property is "
"true on the :c:type:`drm_connector` object. The vertical front porch "
"duration will be extended until page-flip or timeout when enabled."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2356
msgid ""
"The minimum vertical front porch duration is defined as the vertical front "
"porch duration for the current mode."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2359
msgid ""
"The maximum vertical front porch duration is greater than or equal to the "
"minimum vertical front porch duration. The duration is derived from the "
"minimum supported variable refresh rate for the connector."
msgstr ""

#: ../../../gpu/drm-kms:603: drivers/gpu/drm/drm_connector.c:2363
msgid ""
"The driver may place further restrictions within these minimum and maximum "
"bounds."
msgstr ""

#: ../../../gpu/drm-kms.rst:607
msgid "Cursor Hotspot Properties"
msgstr ""

#: ../../../gpu/drm-kms:609: drivers/gpu/drm/drm_plane.c:263
msgid ""
"HOTSPOT_X: property to set mouse hotspot x offset. HOTSPOT_Y: property to "
"set mouse hotspot y offset."
msgstr ""

#: ../../../gpu/drm-kms:609: drivers/gpu/drm/drm_plane.c:266
msgid ""
"When the plane is being used as a cursor image to display a mouse pointer, "
"the \"hotspot\" is the offset within the cursor image where mouse events are "
"expected to go."
msgstr ""

#: ../../../gpu/drm-kms:609: drivers/gpu/drm/drm_plane.c:270
msgid ""
"Positive values move the hotspot from the top-left corner of the cursor "
"plane towards the right and bottom."
msgstr ""

#: ../../../gpu/drm-kms:609: drivers/gpu/drm/drm_plane.c:273
msgid ""
"Most display drivers do not need this information because the hotspot is not "
"actually connected to anything visible on screen. However, this is necessary "
"for display drivers like the para-virtualized drivers (eg qxl, vbox, virtio, "
"vmwgfx), that are attached to a user console with a mouse pointer.  Since "
"these consoles are often being remoted over a network, they would otherwise "
"have to wait to display the pointer movement to the user until a full "
"network round-trip has occurred.  New mouse events have to be sent from the "
"user's console, over the network to the virtual input devices, forwarded to "
"the desktop for processing, and then the cursor plane's position can be "
"updated and sent back to the user's console over the network. Instead, with "
"the hotspot information, the console can anticipate the new location, and "
"draw the mouse cursor there before the confirmation comes in. To do that "
"correctly, the user's console must be able predict how the desktop will "
"process mouse events, which normally requires the desktop's mouse topology "
"information, ie where each CRTC sits in the mouse coordinate space.  This is "
"typically sent to the para-virtualized drivers using some driver-specific "
"method, and the driver then forwards it to the console by way of the virtual "
"display device or hypervisor."
msgstr ""

#: ../../../gpu/drm-kms:609: drivers/gpu/drm/drm_plane.c:292
msgid ""
"The assumption is generally made that there is only one cursor plane being "
"used this way at a time, and that the desktop is feeding all mouse devices "
"into the same global pointer.  Para-virtualized drivers that require this "
"should only be exposing a single cursor plane, or find some other way to "
"coordinate with a userspace desktop that supports multiple pointers. If the "
"hotspot properties are set, the cursor plane is therefore assumed to be used "
"only for displaying a mouse cursor image, and the position of the combined "
"cursor plane + offset can therefore be used for coordinating with input from "
"a mouse device."
msgstr ""

#: ../../../gpu/drm-kms:609: drivers/gpu/drm/drm_plane.c:302
msgid ""
"The cursor will then be drawn either at the location of the plane in the "
"CRTC console, or as a free-floating cursor plane on the user's console "
"corresponding to their desktop mouse position."
msgstr ""

#: ../../../gpu/drm-kms:609: drivers/gpu/drm/drm_plane.c:306
msgid ""
"DRM clients which would like to work correctly on drivers which expose "
"hotspot properties should advertise DRM_CLIENT_CAP_CURSOR_PLANE_HOTSPOT. "
"Setting this property on drivers which do not special case cursor planes "
"will return EOPNOTSUPP, which can be used by userspace to gauge requirements "
"of the hardware/drivers they're running on. Advertising "
"DRM_CLIENT_CAP_CURSOR_PLANE_HOTSPOT implies that the userspace client will "
"be correctly setting the hotspot properties."
msgstr ""

#: ../../../gpu/drm-kms.rst:613
msgid "Existing KMS Properties"
msgstr ""

#: ../../../gpu/drm-kms.rst:615
msgid ""
"The following table gives description of drm properties exposed by various "
"modules/drivers. Because this table is very unwieldy, do not add any new "
"properties here. Instead document them in a section above."
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Owner Module/Drivers"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Group"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Property Name"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Type"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Property Values"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Object attached"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Description/Restrictions"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "DVI-I"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“subconnector”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "ENUM"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ “Unknown”, “DVI-D”, “DVI-A” }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Connector"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "TBD"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“select subconnector”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ “Automatic”, “DVI-D”, “DVI-A” }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "TV"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"Unknown\", \"Composite\", \"SVIDEO\", \"Component\", \"SCART\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"Automatic\", \"Composite\", \"SVIDEO\", \"Component\", \"SCART\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“mode”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"NTSC_M\", \"NTSC_J\", \"NTSC_443\", \"PAL_B\" } etc."
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“left margin”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "RANGE"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=100"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“right margin”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“top margin”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“bottom margin”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“brightness”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“contrast”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“flicker reduction”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“overscan”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“saturation”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“hue”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Virtual GPU"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“suggested X”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=0xffffffff"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "property to suggest an X offset for a connector"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“suggested Y”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "property to suggest an Y offset for a connector"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Optional"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"aspect ratio\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"None\", \"4:3\", \"16:9\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "TDB"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“audio”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"force-dvi\", \"off\", \"auto\", \"on\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "SDVO-TV"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"left_margin\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max= SDVO dependent"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"right_margin\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"top_margin\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"bottom_margin\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“hpos”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“vpos”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“sharpness”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“flicker_filter”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“flicker_filter_adaptive”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“flicker_filter_2d”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“tv_chroma_filter”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“tv_luma_filter”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“dot_crawl”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=1"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "SDVO-TV/LVDS"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "CDV gma-500"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Generic"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"Broadcast RGB\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ “Full”, “Limited 16:235” }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Poulsbo"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“backlight”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "armada"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "CRTC"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"CSC_YUV\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"Auto\" , \"CCIR601\", \"CCIR709\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"CSC_RGB\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"Auto\", \"Computer system\", \"Studio\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Overlay"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"colorkey\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=0xffffff"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Plane"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"colorkey_min\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"colorkey_max\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"colorkey_val\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"colorkey_alpha\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"colorkey_mode\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid ""
"{ \"disabled\", \"Y component\", \"U component\" , \"V component\", \"RGB\", "
"“R component\", \"G component\", \"B component\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"brightness\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=256 + 255"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"contrast\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=0x7fff"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"saturation\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "exynos"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"normal\", \"blank\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "i2c/ch7006_drv"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“scale”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=2"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid ""
"{ \"PAL\", \"PAL-M\",\"PAL-N\"}, ”PAL-Nc\" , \"PAL-60\", \"NTSC-M\", \"NTSC-"
"J\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "nouveau"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "NV10 Overlay"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=0x01ffffff"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=8192-1"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=1024"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=359"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“iturbt_709”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Nv04 Overlay"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“colorkey”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Display"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“dithering mode”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"auto\", \"off\", \"on\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“dithering depth”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid ""
"{ \"auto\", \"off\", \"on\", \"static 2x2\", \"dynamic 2x2\", \"temporal\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“underscan”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"auto\", \"6 bpc\", \"8 bpc\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“underscan hborder”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=128"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“underscan vborder”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“vibrant hue”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=180"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“color vibrance”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=200"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "omap"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“zorder”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Min=0, Max=3"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "CRTC, Plane"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "qxl"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“hotplug_mode_update\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "radeon"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“coherent”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "DAC enable load detect"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“load detection”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "TV Standard"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"tv standard\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid ""
"{ \"ntsc\", \"pal\", \"pal-m\", \"pal-60\", \"ntsc-j\" , \"scart-pal\", "
"\"pal-cn\", \"secam\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "legacy TMDS PLL detect"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"tmds_pll\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"driver\", \"bios\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Underscan"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"underscan\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"off\", \"on\", \"auto\" }"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"underscan hborder\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "\"underscan vborder\""
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "Audio"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "FMT Dithering"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "“dither”"
msgstr ""

#: ../../../gpu/kms-properties.csv:1
msgid "{ \"off\", \"on\" }"
msgstr ""

#: ../../../gpu/drm-kms.rst:624
msgid "Vertical Blanking"
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:43
msgid ""
"From the computer's perspective, every time the monitor displays a new frame "
"the scanout engine has \"scanned out\" the display image from top to bottom, "
"one row of pixels at a time. The current row of pixels is referred to as the "
"current scanline."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:48
msgid ""
"In addition to the display's visible area, there's usually a couple of extra "
"scanlines which aren't actually displayed on the screen. These extra "
"scanlines don't contain image data and are occasionally used for features "
"like audio and infoframes. The region made up of these scanlines is referred "
"to as the vertical blanking region, or vblank for short."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:55
msgid ""
"For historical reference, the vertical blanking period was designed to give "
"the electron gun (on CRTs) enough time to move back to the top of the screen "
"to start scanning out the next frame. Similar for horizontal blanking "
"periods. They were designed to give the electron gun enough time to move "
"back to the other side of the screen to start scanning the next scanline."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:89
msgid ""
"\"Physical top of display\" is the reference point for the high-precision/ "
"corrected timestamp."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:92
msgid ""
"On a lot of display hardware, programming needs to take effect during the "
"vertical blanking period so that settings like gamma, the image buffer "
"buffer to be scanned out, etc. can safely be changed without showing any "
"visual artifacts on the screen. In some unforgiving hardware, some of this "
"programming has to both start and end in the same vblank. To help with the "
"timing of the hardware programming, an interrupt is usually available to "
"notify the driver when it can start the updating of registers. The interrupt "
"is in this context named the vblank interrupt."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:101
msgid ""
"The vblank interrupt may be fired at different points depending on the "
"hardware. Some hardware implementations will fire the interrupt when the new "
"frame start, other implementations will fire the interrupt at different "
"points in time."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:106
msgid ""
"Vertical blanking plays a major role in graphics rendering. To achieve tear-"
"free display, users must synchronize page flips and/or rendering to vertical "
"blanking. The DRM API offers ioctls to perform page flips synchronized to "
"vertical blanking and wait for vertical blanking."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:111
msgid ""
"The DRM core handles most of the vertical blanking management logic, which "
"involves filtering out spurious interrupts, keeping race-free blanking "
"counters, coping with counter wrap-around and resets and keeping use counts. "
"It relies on the driver to generate vertical blanking interrupts and "
"optionally provide a hardware vertical blanking counter."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:117
msgid ""
"Drivers must initialize the vertical blanking handling core with a call to "
"drm_vblank_init(). Minimally, a driver needs to implement :c:type:"
"`drm_crtc_funcs.enable_vblank <drm_crtc_funcs>` and :c:type:`drm_crtc_funcs."
"disable_vblank <drm_crtc_funcs>` plus call drm_crtc_handle_vblank() in its "
"vblank interrupt handler for working vblank support."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:123
msgid ""
"Vertical blanking interrupts can be enabled by the DRM core or by drivers "
"themselves (for instance to handle page flipping operations).  The DRM core "
"maintains a vertical blanking use count to ensure that the interrupts are "
"not disabled while a user still needs them. To increment the use count, "
"drivers call drm_crtc_vblank_get() and release the vblank reference again "
"with drm_crtc_vblank_put(). In between these two calls vblank interrupts are "
"guaranteed to be enabled."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:131
msgid ""
"On many hardware disabling the vblank interrupt cannot be done in a race-"
"free manner, see :c:type:`drm_vblank_crtc_config.disable_immediate "
"<drm_vblank_crtc_config>` and :c:type:`drm_driver.max_vblank_count "
"<drm_driver>`. In that case the vblank core only disables the vblanks after "
"a timer has expired, which can be configured through the ``vblankoffdelay`` "
"module parameter."
msgstr ""

#: ../../../gpu/drm-kms:626: drivers/gpu/drm/drm_vblank.c:137
msgid ""
"Drivers for hardware without support for vertical-blanking interrupts must "
"not call drm_vblank_init(). For such drivers, atomic helpers will "
"automatically generate fake vblank events as part of the display update. "
"This functionality also can be controlled by the driver by enabling and "
"disabling struct drm_crtc_state.no_vblank."
msgstr ""

#: ../../../gpu/drm-kms.rst:630
msgid "Vertical Blanking and Interrupt Handling Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:40
msgid "pending vblank event tracking"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:45
msgid "Base structure for tracking pending DRM events."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:48
#: include/drm/drm_vblank.h:198
msgid "``pipe``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:49
msgid "drm_crtc_index() of the :c:type:`drm_crtc` this event is for."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:52
msgid "``sequence``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:53
msgid "frame event should be triggered at"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:57
msgid "Actual event which will be sent to userspace."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:60
msgid "``event.base``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:61
msgid "DRM event base class."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:65
msgid "``event.vbl``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:66
msgid ""
"Event payload for vblank events, requested through either the MODE_PAGE_FLIP "
"or MODE_ATOMIC IOCTL. Also generated by the legacy WAIT_VBLANK IOCTL, but "
"new userspace should use MODE_QUEUE_SEQUENCE and :c:type:`event.seq <event>` "
"instead."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:75
msgid "``event.seq``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:76
msgid "Event payload for the MODE_QUEUEU_SEQUENCE IOCTL."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:82
msgid "vblank configuration for a CRTC"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:86
msgid "``offdelay_ms``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:87
msgid ""
"Vblank off delay in ms, used to determine how long :c:type:`drm_vblank_crtc."
"disable_timer <drm_vblank_crtc>` waits before disabling."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:90
msgid "Defaults to the value of drm_vblank_offdelay in drm_crtc_vblank_on()."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:94
msgid "``disable_immediate``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:95
msgid ""
"See :c:type:`drm_device.vblank_disable_immediate <drm_device>` for the exact "
"semantics of immediate vblank disabling."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:98
msgid ""
"Additionally, this tracks the disable immediate value per crtc, just in case "
"it needs to differ from the default value for a given device."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:101
msgid ""
"Defaults to the value of :c:type:`drm_device.vblank_disable_immediate "
"<drm_device>` in drm_crtc_vblank_on()."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:107
msgid "vblank tracking for a CRTC"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:119
msgid "Pointer to the :c:type:`drm_device`."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:122
msgid "``queue``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:123
msgid "Wait queue for vblank waiters."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:126
msgid "``disable_timer``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:127
msgid ""
"Disable timer for the delayed vblank disabling hysteresis logic. Vblank "
"disabling is controlled through :c:type:`drm_vblank_crtc_config.offdelay_ms "
"<drm_vblank_crtc_config>` and the setting of the :c:type:`drm_device."
"max_vblank_count <drm_device>` value."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:134
msgid "``seqlock``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:135
msgid "Protect vblank count and time."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:140
msgid "Current software vblank counter."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:142
msgid ""
"Note that for a given vblank counter value drm_crtc_handle_vblank() and "
"drm_crtc_vblank_count() or drm_crtc_vblank_count_and_time() provide a "
"barrier: Any writes done before calling drm_crtc_handle_vblank() will be "
"visible to callers of the later functions, iff the vblank count is the same "
"or a later one."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:148
msgid ""
"IMPORTANT: This guarantee requires barriers, therefor never access this "
"field directly. Use drm_crtc_vblank_count() instead."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:154
msgid "``time``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:155
msgid "Vblank timestamp corresponding to **count**."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:160
msgid ""
"Number of users/waiters of the vblank interrupt. Only when this refcount "
"reaches 0 can the hardware interrupt be disabled using **disable_timer**."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:165
msgid "``last``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:166
msgid ""
"Protected by :c:type:`drm_device.vbl_lock <drm_device>`, used for wraparound "
"handling."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:169
msgid "``max_vblank_count``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:170
msgid ""
"Maximum value of the vblank registers for this crtc. This value +1 will "
"result in a wrap-around of the vblank register. It is used by the vblank "
"core to handle wrap-arounds."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:174
msgid ""
"If set to zero the vblank core will try to guess the elapsed vblanks between "
"times when the vblank interrupt is disabled through high-precision "
"timestamps. That approach is suffering from small races and imprecision over "
"longer time periods, hence exposing a hardware vblank counter is always "
"recommended."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:180
msgid ""
"This is the runtime configurable per-crtc maximum set through "
"drm_crtc_set_max_vblank_count(). If this is used the driver must leave the "
"device wide :c:type:`drm_device.max_vblank_count <drm_device>` at zero."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:184
msgid ""
"If non-zero, :c:type:`drm_crtc_funcs.get_vblank_counter <drm_crtc_funcs>` "
"must be set."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:189
msgid "``inmodeset``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:190
msgid ""
"Tracks whether the vblank is disabled due to a modeset. For legacy driver "
"bit 2 additionally tracks whether an additional temporary vblank reference "
"has been acquired to paper over the hardware counter resetting/jumping. KMS "
"drivers should instead just call drm_crtc_vblank_off() and "
"drm_crtc_vblank_on(), which explicitly save and restore the vblank count."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:199
msgid ""
"drm_crtc_index() of the :c:type:`drm_crtc` corresponding to this structure."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:203
msgid "``framedur_ns``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:204
msgid ""
"Frame/Field duration in ns, used by "
"drm_crtc_vblank_helper_get_vblank_timestamp() and computed by "
"drm_calc_timestamping_constants()."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:209
msgid "``linedur_ns``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:210
msgid ""
"Line duration in ns, used by drm_crtc_vblank_helper_get_vblank_timestamp() "
"and computed by drm_calc_timestamping_constants()."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:217
msgid ""
"Cache of the current hardware display mode. Only valid when **enabled** is "
"set. This is used by helpers like "
"drm_crtc_vblank_helper_get_vblank_timestamp(). We can't just access the "
"hardware mode by e.g. looking at :c:type:`drm_crtc_state.adjusted_mode "
"<drm_crtc_state>`, because that one is really hard to get from interrupt "
"context."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:227
msgid "``config``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:228
msgid ""
"Stores vblank configuration values for a given CRTC. Also, see "
"drm_crtc_vblank_on_config()."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:234
msgid ""
"Tracks the enabling state of the corresponding :c:type:`drm_crtc` to avoid "
"double-disabling and hence corrupting saved state. Needed by drivers not "
"using atomic KMS, since those might go through their CRTC disabling "
"functions multiple times."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:241
msgid "``worker``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:242
msgid "The :c:type:`kthread_worker` used for executing vblank works."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:246
msgid "``pending_work``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:247
msgid ""
"A list of scheduled :c:type:`drm_vblank_work` items that are waiting for a "
"future vblank."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:252
msgid "``work_wait_queue``"
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:253
msgid ""
"The wait queue used for signaling that a :c:type:`drm_vblank_work` item has "
"either finished executing, or was cancelled."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:108
msgid "This structure tracks the vblank state for one CRTC."
msgstr ""

#: ../../../gpu/drm-kms:632: include/drm/drm_vblank.h:110
msgid ""
"Note that for historical reasons - the vblank handling code is still shared "
"with legacy/non-kms drivers - this is a free-standing structure not directly "
"connected to :c:type:`struct drm_crtc <drm_crtc>`. But all public interface "
"functions are taking a :c:type:`struct drm_crtc <drm_crtc>` to hide this "
"implementation detail."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:401
msgid "retrieve the master vblank counter"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:402
#: drivers/gpu/drm/drm_vblank.c:903 drivers/gpu/drm/drm_vblank.c:966
msgid "which counter to retrieve"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:403
msgid ""
"This function is similar to drm_crtc_vblank_count() but this function "
"interpolates to handle a race with vblank interrupts using the high "
"precision timestamping support."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:407
msgid ""
"This is mostly useful for hardware that can obtain the scanout position, but "
"doesn't have a hardware frame counter."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:516
msgid "initialize vblank support"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:519
msgid "``unsigned int num_crtcs``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:518
msgid "number of CRTCs supported by **dev**"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:519
msgid ""
"This function initializes vblank support for **num_crtcs** display "
"pipelines. Cleanup is handled automatically through a cleanup function added "
"with drmm_add_action_or_reset()."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:524
#: drivers/gpu/drm/drm_vblank.c:1231
msgid "Zero on success or a negative error code on failure."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:565
msgid "test if vblanking has been initialized for a device"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:571
msgid "``const struct drm_device *dev``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:567
msgid "the device"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:568
msgid ""
"Drivers may call this function to test if vblank support is initialized for "
"a device. For most hardware this means that vblanking can also be enabled."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:572
msgid ""
"Atomic helpers use this function to initialize :c:type:`drm_crtc_state."
"no_vblank <drm_crtc_state>`. See also drm_atomic_helper_check_modeset()."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:576
msgid ""
"True if vblanking has been initialized for the given device, false otherwise."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:587
msgid "get vblank waitqueue for the CRTC"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:588
msgid "which CRTC's vblank waitqueue to retrieve"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:589
msgid ""
"This function returns a pointer to the vblank waitqueue for the CRTC. "
"Drivers can use this to implement vblank waits using wait_event() and "
"related functions."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:602
msgid "calculate vblank timestamp constants"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:603
msgid "drm_crtc whose timestamp constants should be updated."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:604
msgid "display mode containing the scanout timings"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:605
msgid ""
"Calculate and store various constants which are later needed by vblank and "
"swap-completion timestamping, e.g, by "
"drm_crtc_vblank_helper_get_vblank_timestamp(). They are derived from CRTC's "
"true scanout timing, so they take things like panel scaling or other "
"adjustments into account."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:663
#: drivers/gpu/drm/drm_vblank.c:808
msgid "precise vblank timestamp helper"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:665
#: drivers/gpu/drm/drm_vblank.c:810
msgid "CRTC whose vblank timestamp to retrieve"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:667
#: drivers/gpu/drm/drm_vblank.c:812
msgid "``int *max_error``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:666
#: drivers/gpu/drm/drm_vblank.c:811
msgid ""
"Desired maximum allowable error in timestamps (nanosecs) On return contains "
"true maximum error of timestamp"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:669
#: drivers/gpu/drm/drm_vblank.c:814
msgid "``ktime_t *vblank_time``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:668
#: drivers/gpu/drm/drm_vblank.c:813
msgid "Pointer to time which should receive the timestamp"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:670
#: drivers/gpu/drm/drm_vblank.c:815
msgid "``bool in_vblank_irq``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:673
msgid "``drm_vblank_get_scanout_position_func get_scanout_position``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:673
msgid ""
"Callback function to retrieve the scanout position. See **struct** "
"drm_crtc_helper_funcs.get_scanout_position."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:676
msgid ""
"Implements calculation of exact vblank timestamps from given "
"drm_display_mode timings and current video scanout position of a CRTC."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:679
#: drivers/gpu/drm/drm_vblank.c:823
msgid ""
"The current implementation only handles standard video modes. For double "
"scan and interlaced modes the driver is supposed to adjust the hardware mode "
"(taken from :c:type:`drm_crtc_state.adjusted <drm_crtc_state>` mode for "
"atomic modeset drivers) to match the scanout position reported."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:684
#: drivers/gpu/drm/drm_vblank.c:828
msgid ""
"Note that atomic drivers must call drm_calc_timestamping_constants() before "
"enabling a CRTC. The atomic helpers already take care of that in "
"drm_atomic_helper_calc_timestamping_constants()."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:689
#: drivers/gpu/drm/drm_vblank.c:833
msgid ""
"Returns true on success, and false on failure, i.e. when no accurate "
"timestamp could be acquired."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:818
msgid ""
"Implements calculation of exact vblank timestamps from given "
"drm_display_mode timings and current video scanout position of a CRTC. This "
"can be directly used as the :c:type:`drm_crtc_funcs.get_vblank_timestamp "
"<drm_crtc_funcs>` implementation of a kms driver if :c:type:"
"`drm_crtc_helper_funcs.get_scanout_position <drm_crtc_helper_funcs>` is "
"implemented."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:902
msgid "retrieve \"cooked\" vblank counter value"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:904
msgid ""
"Fetches the \"cooked\" vblank count value that represents the number of "
"vblank events since the system was booted, including lost events due to "
"modesetting activity. Note that this timer isn't correct against a racing "
"vblank interrupt (since it only reports the software vblank counter), see "
"drm_crtc_accurate_vblank_count() for such use-cases."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:910
#: drivers/gpu/drm/drm_vblank.c:973 drivers/gpu/drm/drm_vblank.c:1980
msgid ""
"Note that for a given vblank counter value drm_crtc_handle_vblank() and "
"drm_crtc_vblank_count() or drm_crtc_vblank_count_and_time() provide a "
"barrier: Any writes done before calling drm_crtc_handle_vblank() will be "
"visible to callers of the later functions, if the vblank count is the same "
"or a later one."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:916
#: drivers/gpu/drm/drm_vblank.c:979 drivers/gpu/drm/drm_vblank.c:1986
msgid "See also :c:type:`drm_vblank_crtc.count <drm_vblank_crtc>`."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:919
msgid "The software vblank counter."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:964
msgid ""
"retrieve \"cooked\" vblank counter value and the system timestamp "
"corresponding to that vblank counter value"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:968
#: drivers/gpu/drm/drm_vblank.c:994
msgid "``ktime_t *vblanktime``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:967
msgid "Pointer to time to receive the vblank timestamp."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:968
msgid ""
"Fetches the \"cooked\" vblank count value that represents the number of "
"vblank events since the system was booted, including lost events due to "
"modesetting activity. Returns corresponding system timestamp of the time of "
"the vblank interval that corresponds to the current vblank counter value."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:991
msgid "calculate the time of the next vblank"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:992
msgid "the crtc for which to calculate next vblank time"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:993
msgid "pointer to time to receive the next vblank timestamp."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:994
msgid ""
"Calculate the expected time of the start of the next vblank period, based on "
"time of previous vblank and frame duration"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1062
msgid "arm vblank event after pageflip"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1063
#: drivers/gpu/drm/drm_vblank.c:1115
msgid "the source CRTC of the vblank event"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1065
#: drivers/gpu/drm/drm_vblank.c:1117
msgid "``struct drm_pending_vblank_event *e``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1064
#: drivers/gpu/drm/drm_vblank.c:1116
msgid "the event to send"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1065
msgid ""
"A lot of drivers need to generate vblank events for the very next vblank "
"interrupt. For example when the page flip interrupt happens when the page "
"flip gets armed, but not when it actually executes within the next vblank "
"period. This helper function implements exactly the required vblank arming "
"behaviour."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1072
msgid ""
"Drivers using this to send out the :c:type:`drm_crtc_state.event "
"<drm_crtc_state>` as part of an atomic commit must ensure that the next "
"vblank happens at exactly the same time as the atomic commit is committed to "
"the hardware. This function itself does **not** protect against the next "
"vblank interrupt racing with either this function call or the atomic commit "
"operation. A possible sequence could be:"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1078
msgid "Driver commits new hardware state into vblank-synchronized registers."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1079
msgid ""
"A vblank happens, committing the hardware state. Also the corresponding "
"vblank interrupt is fired off and fully processed by the interrupt handler."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1082
msgid ""
"The atomic commit operation proceeds to call drm_crtc_arm_vblank_event()."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1083
msgid "The event is only send out for the next vblank, which is wrong."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1085
msgid ""
"An equivalent race can happen when the driver calls "
"drm_crtc_arm_vblank_event() before writing out the new hardware state."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1088
msgid ""
"The only way to make this work safely is to prevent the vblank from firing "
"(and the hardware from committing anything else) until the entire atomic "
"commit sequence has run to completion. If the hardware does not have such a "
"feature (e.g. using a \"go\" bit), then it is unsafe to use this functions. "
"Instead drivers need to manually send out the event from their interrupt "
"handler by calling drm_crtc_send_vblank_event() and make sure that there's "
"no possible race with the hardware committing the atomic update."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1096
msgid ""
"Caller must hold a vblank reference for the event **e** acquired by a "
"drm_crtc_vblank_get(), which will be dropped when the next vblank arrives."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1114
msgid "helper to send vblank event after pageflip"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1117
msgid ""
"Updates sequence # and timestamp on event for the most recently processed "
"vblank, and sends it to userspace.  Caller must hold event lock."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1120
msgid ""
"See drm_crtc_arm_vblank_event() for a helper which can be used in certain "
"situation, especially to send out events for atomic commit operations."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1225
msgid "get a reference count on vblank events"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1226
msgid "which CRTC to own"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1227
msgid ""
"Acquire a reference count on vblank events to avoid having them disabled "
"while in use."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1264
msgid "give up ownership of vblank events"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1265
msgid "which counter to give up"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1266
msgid ""
"Release ownership of a given vblank counter, turning off interrupts if "
"possible. Disable interrupts after :c:type:`drm_vblank_crtc_config."
"offdelay_ms <drm_vblank_crtc_config>` milliseconds."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1278
#: drivers/gpu/drm/drm_vblank.c:1315
msgid "wait for one vblank"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1281
#: drivers/gpu/drm/drm_vblank.c:1912
msgid "``unsigned int pipe``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1280
msgid "CRTC index"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1281
msgid ""
"This waits for one vblank to pass on **pipe**, using the irq driver "
"interfaces. It is a failure to call this when the vblank irq for **pipe** is "
"disabled, e.g. due to lack of driver support or because the crtc is off."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1285
msgid "This is the legacy version of drm_crtc_wait_one_vblank()."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1316
msgid "DRM crtc"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1317
msgid ""
"This waits for one vblank to pass on **crtc**, using the irq driver "
"interfaces. It is a failure to call this when the vblank irq for **crtc** is "
"disabled, e.g. due to lack of driver support or because the crtc is off."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1329
msgid "disable vblank events on a CRTC"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1330
#: drivers/gpu/drm/drm_vblank.c:1408 drivers/gpu/drm/drm_vblank.c:1441
#: drivers/gpu/drm/drm_vblank.c:1472 drivers/gpu/drm/drm_vblank.c:1518
#: drivers/gpu/drm/drm_vblank.c:1579
msgid "CRTC in question"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1331
msgid ""
"Drivers can use this function to shut down the vblank interrupt handling "
"when disabling a crtc. This function ensures that the latest vblank frame "
"count is stored so that drm_vblank_on can restore it again."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1335
msgid ""
"Drivers must use this function when the hardware vblank counter can get "
"reset, e.g. when suspending or disabling the **crtc** in general."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1407
msgid "reset vblank state to off on a CRTC"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1409
msgid ""
"Drivers can use this function to reset the vblank state to off at load time. "
"Drivers should use this together with the drm_crtc_vblank_off() and "
"drm_crtc_vblank_on() functions. The difference compared to "
"drm_crtc_vblank_off() is that this function doesn't save the vblank counter "
"and hence doesn't need to call any driver hooks."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1415
msgid ""
"This is useful for recovering driver state e.g. on driver load, or on resume."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1440
msgid "configure the hw max vblank counter value"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1443
msgid "``u32 max_vblank_count``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1442
msgid "max hardware vblank counter value"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1443
msgid ""
"Update the maximum hardware vblank counter value for **crtc** at runtime. "
"Useful for hardware where the operation of the hardware vblank counter "
"depends on the currently active display configuration."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1448
msgid ""
"For example, if the hardware vblank counter does not work when a specific "
"connector is active the maximum can be set to zero. And when that specific "
"connector isn't active the maximum can again be set to the appropriate non-"
"zero value."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1453
msgid "If used, must be called before drm_vblank_on()."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1470
msgid "enable vblank events on a CRTC with custom configuration options"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1474
msgid "``const struct drm_vblank_crtc_config *config``"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1473
msgid "Vblank configuration value"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1474
msgid ""
"See drm_crtc_vblank_on(). In addition, this function allows you to provide a "
"custom vblank configuration for a given CRTC."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1477
msgid ""
"Note that **config** is copied, the pointer does not need to stay valid "
"beyond this function call. For details of the parameters see struct "
"drm_vblank_crtc_config."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1517
msgid "enable vblank events on a CRTC"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1519
msgid ""
"This functions restores the vblank interrupt state captured with "
"drm_crtc_vblank_off() again and is generally called when enabling **crtc**. "
"Note that calls to drm_crtc_vblank_on() and drm_crtc_vblank_off() can be "
"unbalanced and so can also be unconditionally called in driver load code to "
"reflect the current hardware state of the crtc."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1525
msgid ""
"Note that unlike in drm_crtc_vblank_on_config(), default values are used."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1578
msgid "estimate missed vblanks and update vblank count."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1580
msgid ""
"Power manamement features can cause frame counter resets between vblank "
"disable and enable. Drivers can use this function in their :c:type:"
"`drm_crtc_funcs.enable_vblank <drm_crtc_funcs>` implementation to estimate "
"missed vblanks since the last :c:type:`drm_crtc_funcs.disable_vblank "
"<drm_crtc_funcs>` using timestamps and update the vblank counter."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1586
msgid ""
"Note that drivers must have race-free high-precision timestamping support, i."
"e.  :c:type:`drm_crtc_funcs.get_vblank_timestamp <drm_crtc_funcs>` must be "
"hooked up and :c:type:`drm_vblank_crtc_config.disable_immediate "
"<drm_vblank_crtc_config>` must be set to indicate the time-stamping "
"functions are race-free against vblank hardware counter increments."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1909
#: drivers/gpu/drm/drm_vblank.c:1973
msgid "handle a vblank event"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1911
msgid "index of CRTC where this event occurred"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1912
#: drivers/gpu/drm/drm_vblank.c:1975
msgid ""
"Drivers should call this routine in their vblank interrupt handlers to "
"update the vblank counter and send any signals that may be pending."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1915
msgid "This is the legacy version of drm_crtc_handle_vblank()."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1974
msgid "where this event occurred"
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1978
msgid "This is the native KMS version of drm_handle_vblank()."
msgstr ""

#: ../../../gpu/drm-kms:635: drivers/gpu/drm/drm_vblank.c:1989
msgid "True if the event was successfully handled, false on failure."
msgstr ""

#: ../../../gpu/drm-kms.rst:639
msgid "Vertical Blank Work"
msgstr ""

#: ../../../gpu/drm-kms:641: drivers/gpu/drm/drm_vblank_work.c:15
msgid ""
"Many DRM drivers need to program hardware in a time-sensitive manner, many "
"times with a deadline of starting and finishing within a certain region of "
"the scanout. Most of the time the safest way to accomplish this is to simply "
"do said time-sensitive programming in the driver's IRQ handler, which allows "
"drivers to avoid being preempted during these critical regions. Or even "
"better, the hardware may even handle applying such time-critical programming "
"independently of the CPU."
msgstr ""

#: ../../../gpu/drm-kms:641: drivers/gpu/drm/drm_vblank_work.c:23
msgid ""
"While there's a decent amount of hardware that's designed so that the CPU "
"doesn't need to be concerned with extremely time-sensitive programming, "
"there's a few situations where it can't be helped. Some unforgiving hardware "
"may require that certain time-sensitive programming be handled completely by "
"the CPU, and said programming may even take too long to handle in an IRQ "
"handler. Another such situation would be where the driver needs to perform a "
"task that needs to complete within a specific scanout period, but might "
"possibly block and thus cannot be handled in an IRQ context. Both of these "
"situations can't be solved perfectly in Linux since we're not a realtime "
"kernel, and thus the scheduler may cause us to miss our deadline if it "
"decides to preempt us. But for some drivers, it's good enough if we can "
"lower our chance of being preempted to an absolute minimum."
msgstr ""

#: ../../../gpu/drm-kms:641: drivers/gpu/drm/drm_vblank_work.c:37
msgid ""
"This is where :c:type:`drm_vblank_work` comes in. :c:type:`drm_vblank_work` "
"provides a simple generic delayed work implementation which delays work "
"execution until a particular vblank has passed, and then executes the work "
"at realtime priority. This provides the best possible chance at performing "
"time-sensitive hardware programming on time, even when the system is under "
"heavy load. :c:type:`drm_vblank_work` also supports rescheduling, so that "
"self re-arming work items can be easily implemented."
msgstr ""

#: ../../../gpu/drm-kms.rst:645
msgid "Vertical Blank Work Functions Reference"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:11
msgid ""
"A delayed work item which delays until a target vblank passes, and then "
"executes at realtime priority outside of IRQ context."
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:25
msgid ""
"The base :c:type:`kthread_work` item which will be executed by :c:type:"
"`drm_vblank_crtc.worker <drm_vblank_crtc>`. Drivers should not interact with "
"this directly, and instead rely on drm_vblank_work_init() to initialize this."
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:32
msgid "``vblank``"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:33
msgid "A pointer to :c:type:`drm_vblank_crtc` this work item belongs to."
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:38
msgid ""
"The target vblank this work will execute on. Drivers should not modify this "
"value directly, and instead use drm_vblank_work_schedule()"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:44
msgid "``cancelling``"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:45
msgid ""
"The number of drm_vblank_work_cancel_sync() calls that are currently "
"running. A work item cannot be rescheduled until all calls have finished."
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:51
msgid "``node``"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:52
msgid ""
"The position of this work item in :c:type:`drm_vblank_crtc.pending_work "
"<drm_vblank_crtc>`."
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:12
msgid ""
"See also: drm_vblank_work_schedule() drm_vblank_work_init() "
"drm_vblank_work_cancel_sync() drm_vblank_work_flush() "
"drm_vblank_work_flush_all()"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:60
msgid "``to_drm_vblank_work (_work)``"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:58
msgid ""
"Retrieve the respective :c:type:`drm_vblank_work` item from a :c:type:"
"`kthread_work`"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:64
msgid "``_work``"
msgstr ""

#: ../../../gpu/drm-kms:647: include/drm/drm_vblank_work.h:60
msgid "The :c:type:`kthread_work` embedded inside a :c:type:`drm_vblank_work`"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:90
msgid "schedule a vblank work"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:96
#: drivers/gpu/drm/drm_vblank_work.c:179 drivers/gpu/drm/drm_vblank_work.c:223
#: drivers/gpu/drm/drm_vblank_work.c:266
msgid "``struct drm_vblank_work *work``"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:91
msgid "vblank work to schedule"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:93
msgid "``u64 count``"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:92
msgid "target vblank count"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:94
msgid "``bool nextonmiss``"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:93
msgid "defer until the next vblank if target vblank was missed"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:94
msgid ""
"Schedule **work** for execution once the crtc vblank count reaches **count**."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:96
msgid ""
"If the crtc vblank count has already reached **count** and **nextonmiss** is "
"``false`` the work starts to execute immediately."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:99
msgid ""
"If the crtc vblank count has already reached **count** and **nextonmiss** is "
"``true`` the work is deferred until the next vblank (as if **count** has "
"been specified as crtc vblank count + 1)."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:103
msgid ""
"If **work** is already scheduled, this function will reschedule said work "
"using the new **count**. This can be used for self-rearming work items."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:107
msgid ""
"``1`` if **work** was successfully (re)scheduled, ``0`` if it was either "
"already scheduled or cancelled, or a negative error code on failure."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:173
msgid "cancel a vblank work and wait for it to finish executing"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:175
msgid "vblank work to cancel"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:176
msgid ""
"Cancel an already scheduled vblank work and wait for its execution to finish."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:179
msgid ""
"On return, **work** is guaranteed to no longer be scheduled or running, even "
"if it's self-arming."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:183
msgid ""
"``True`` if the work was cancelled before it started to execute, ``false`` "
"otherwise."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:217
msgid "wait for a scheduled vblank work to finish executing"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:219
msgid "vblank work to flush"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:220
msgid "Wait until **work** has finished executing once."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:238
msgid "flush all currently pending vblank work on crtc."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:239
msgid "crtc for which vblank work to flush"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:240
msgid ""
"Wait until all currently queued vblank work on **crtc** has finished "
"executing once."
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:260
msgid "initialize a vblank work item"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:261
msgid "vblank work item"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:262
msgid "CRTC whose vblank will trigger the work execution"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:264
msgid "``void (*func)(struct kthread_work *work)``"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:263
msgid "work function to be executed"
msgstr ""

#: ../../../gpu/drm-kms:650: drivers/gpu/drm/drm_vblank_work.c:264
msgid "Initialize a vblank work item for a specific crtc."
msgstr ""
