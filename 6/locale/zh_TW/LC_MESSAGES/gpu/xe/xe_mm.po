# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/xe/xe_mm.rst:5
msgid "Memory Management"
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:13
msgid "TTM manages (placement, eviction, etc...) all BOs in Xe."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:18
msgid ""
"Create a chunk of memory which can be used by the GPU. Placement rules "
"(sysmem or vram region) passed in upon creation. TTM handles placement of BO "
"and can trigger eviction of other BOs to make space for the new BO."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:25
msgid ""
"A kernel BO is created as part of driver load (e.g. uC firmware images, GuC "
"ADS, etc...) or a BO created as part of a user operation which requires a "
"kernel BO (e.g. engine state, memory for page tables, etc...). These BOs are "
"typically mapped in the GGTT (any kernel BOs aside memory for page tables "
"are in the GGTT), are pinned (can't move or be evicted at runtime), have a "
"vmap (Xe can access the memory via xe_map layer) and have contiguous "
"physical memory."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:33
msgid "More details of why kernel BOs are pinned and contiguous below."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:38
msgid ""
"A user BO is created via the DRM_IOCTL_XE_GEM_CREATE IOCTL. Once it is "
"created the BO can be mmap'd (via DRM_IOCTL_XE_GEM_MMAP_OFFSET) for user "
"access and it can be bound for GPU access (via DRM_IOCTL_XE_VM_BIND). All "
"user BOs are evictable and user BOs are never pinned by Xe. The allocation "
"of the backing store can be deferred from creation time until first use "
"which is either mmap, bind, or pagefault."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:48
msgid ""
"A private BO is a user BO created with a valid VM argument passed into the "
"create IOCTL. If a BO is private it cannot be exported via prime FD and "
"mappings can only be created for the BO within the VM it is tied to. Lastly, "
"the BO dma-resv slots / lock point to the VM's dma-resv slots / lock (all "
"private BOs to a VM share common dma-resv slots / lock)."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:57
msgid ""
"An external BO is a user BO created with a NULL VM argument passed into the "
"create IOCTL. An external BO can be shared with different UMDs / devices via "
"prime FD and the BO can be mapped into multiple VMs. An external BO has its "
"own unique dma-resv slots / lock. An external BO will be in an array of all "
"VMs which has a mapping of the BO. This allows VMs to lookup and lock all "
"external BOs mapped in the VM as needed."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:67
msgid ""
"When a user BO is created, a mask of valid placements is passed indicating "
"which memory regions are considered valid."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:70
msgid ""
"The memory region information is available via query uAPI (TODO: add link)."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:75
msgid ""
"BO validation (ttm_bo_validate) refers to ensuring a BO has a valid "
"placement. If a BO was swapped to temporary storage, a validation call will "
"trigger a move back to a valid (location where GPU can access BO) placement. "
"Validation of a BO may evict other BOs to make room for the BO being "
"validated."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:84
msgid ""
"All eviction (or in other words, moving a BO from one memory location to "
"another) is routed through TTM with a callback into Xe."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:90
msgid ""
"Runtime evictions refers to during normal operations where TTM decides it "
"needs to move a BO. Typically this is because TTM needs to make room for "
"another BO and the evicted BO is first BO on LRU list that is not locked."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:94
msgid ""
"An example of this is a new BO which can only be placed in VRAM but there is "
"not space in VRAM. There could be multiple BOs which have sysmem and VRAM "
"placement rules which currently reside in VRAM, TTM trigger a will move of "
"one (or multiple) of these BO(s) until there is room in VRAM to place the "
"new BO. The evicted BO(s) are valid but still need new bindings before the "
"BO used again (exec or compute mode rebind worker)."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:101
msgid ""
"Another example would be, TTM can't find a BO to evict which has another "
"valid placement. In this case TTM will evict one (or multiple) unlocked "
"BO(s) to a temporary unreachable (invalid) placement. The evicted BO(s) are "
"invalid and before next use need to be moved to a valid placement and "
"rebound."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:106
msgid ""
"In both cases, moves of these BOs are scheduled behind the fences in the "
"BO's dma-resv slots."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:109
msgid ""
"WW locking tries to ensures if 2 VMs use 51% of the memory forward progress "
"is made on both VMs."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:112
msgid ""
"Runtime eviction uses per a GT migration engine (TODO: link to migration "
"engine doc) to do a GPU memcpy from one location to another."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:118
msgid ""
"When BOs are moved, every mapping (VMA) of the BO needs to rebound before "
"the BO is used again. Every VMA is added to an evicted list of its VM when "
"the BO is moved. This is safe because of the VM locking structure (TODO: "
"link to VM locking doc). On the next use of a VM (exec or compute mode "
"rebind worker) the evicted VMA list is checked and rebinds are triggered. In "
"the case of faulting VM, the rebind is done in the page fault handler."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:128
msgid ""
"During device suspend / resume VRAM may lose power which means the contents "
"of VRAM's memory is blown away. Thus BOs present in VRAM at the time of "
"suspend must be moved to sysmem in order for their contents to be saved."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:132
msgid ""
"A simple TTM call (ttm_resource_manager_evict_all) can move all non-pinned "
"(user) BOs to sysmem. External BOs that are pinned need to be manually "
"evicted with a simple loop + xe_bo_evict call. It gets a little trickier "
"with kernel BOs."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:137
msgid ""
"Some kernel BOs are used by the GT migration engine to do moves, thus we "
"can't move all of the BOs via the GT migration engine. For simplity, use a "
"TTM memcpy (CPU) to move any kernel (pinned) BO on either suspend or resume."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:141
msgid ""
"Some kernel BOs need to be restored to the exact same physical location. TTM "
"makes this rather easy but the caveat is the memory must be contiguous. "
"Again for simplity, we enforce that all kernel (pinned) BOs are contiguous "
"and restored to the same physical location."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:146
msgid "Pinned external BOs in VRAM are restored on resume via the GPU."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:151
msgid ""
"Most kernel BOs have GGTT mappings which must be restored during the resume "
"process. All user BOs are rebound after validation on their next use."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:157
msgid ""
"Trim the list of BOs which is saved / restored via TTM memcpy on suspend / "
"resume. All we really need to save / restore via TTM memcpy is the memory "
"required for the GuC to load and the memory for the GT migrate engine to "
"operate."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:162
msgid ""
"Do not require kernel BOs to be contiguous in physical memory / restored to "
"the same physical address on resume. In all likelihood the only memory that "
"needs to be restored to the same physical address is memory used for page "
"tables. All of that memory is allocated 1 page at time so the contiguous "
"requirement isn't needed. Some work on the vmap code would need to be done "
"if kernel BOs are not contiguous too."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:169
msgid ""
"Make some kernel BO evictable rather than pinned. An example of this would "
"be engine state, in all likelihood if the dma-slots of these BOs where "
"properly used rather than pinning we could safely evict + rebind these BOs "
"as needed."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: ../drivers/gpu/drm/xe/xe_bo_doc.h:173
msgid ""
"Some kernel BOs do not need to be restored on resume (e.g. GuC ADS as that "
"is repopulated on resume), add flag to mark such objects as no save / "
"restore."
msgstr ""

#: ../../../gpu/xe/xe_mm.rst:11
msgid "GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:13: ../drivers/gpu/drm/xe/xe_ggtt.c:38
msgid ""
"Xe GGTT implements the support for a Global Virtual Address space that is "
"used for resources that are accessible to privileged (i.e. kernel-mode) "
"processes, and not tied to a specific user-level process. For example, the "
"Graphics micro-Controller (GuC) and Display Engine (if present) utilize this "
"Global address space."
msgstr ""

#: ../../../gpu/xe/xe_mm:13: ../drivers/gpu/drm/xe/xe_ggtt.c:44
msgid ""
"The Global GTT (GGTT) translates from the Global virtual address to a "
"physical address that can be accessed by HW. The GGTT is a flat, single-"
"level table."
msgstr ""

#: ../../../gpu/xe/xe_mm:13: ../drivers/gpu/drm/xe/xe_ggtt.c:47
msgid ""
"Xe implements a simplified version of the GGTT specifically managing only a "
"certain range of it that goes from the Write Once Protected Content Memory "
"(WOPCM) Layout to a predefined GUC_GGTT_TOP. This approach avoids "
"complications related to the GuC (Graphics Microcontroller) hardware "
"limitations. The GuC address space is limited on both ends of the GGTT, "
"because the GuC shim HW redirects accesses to those addresses to other HW "
"areas instead of going through the GGTT. On the bottom end, the GuC can't "
"access offsets below the WOPCM size, while on the top side the limit is "
"fixed at GUC_GGTT_TOP. To keep things simple, instead of checking each "
"object to see if they are accessed by GuC or not, we just exclude those "
"areas from the allocator. Additionally, to simplify the driver load, we use "
"the maximum WOPCM size in this logic instead of the programmed one, so we "
"don't need to wait until the actual size to be programmed is determined "
"(which requires FW fetch) before initializing the GGTT. These "
"simplifications might waste space in the GGTT (about 20-25 MBs depending on "
"the platform) but we can live with this. Another benefit of this is the GuC "
"bootrom can't access anything below the WOPCM max size so anything the "
"bootrom needs to access (e.g. a RSA key) needs to be placed in the GGTT "
"above the WOPCM max size. Starting the GGTT allocations above the WOPCM max "
"give us the correct placement for free."
msgstr ""

#: ../../../gpu/xe/xe_mm.rst:17
msgid "GGTT Internal API"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:17
msgid "Main GGTT struct"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:21
#: ../drivers/gpu/drm/xe/xe_ggtt_types.h:59
#: ../drivers/gpu/drm/xe/xe_ggtt_types.h:77
msgid "**Definition**::"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:37
#: ../drivers/gpu/drm/xe/xe_ggtt_types.h:68
#: ../drivers/gpu/drm/xe/xe_ggtt_types.h:85
msgid "**Members**"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:23
msgid "``tile``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:24
msgid "Back pointer to tile where this GGTT belongs"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:25
msgid "``size``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:26
msgid "Total size of this GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:30
msgid "``flags``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:31
msgid ""
"Flags for this GGTT Acceptable flags: - ``XE_GGTT_FLAGS_64K`` - if PTE size "
"is 64K. Otherwise, regular is 4K."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:35
msgid "``scratch``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:36
msgid "Internal object allocation used as a scratch page"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:37
msgid "``lock``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:38
msgid "Mutex lock to protect GGTT data"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:40
msgid "``gsm``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:41
msgid ""
"The iomem pointer to the actual location of the translation table located in "
"the GSM for easy PTE manipulation"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:44
msgid "``pt_ops``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:45
msgid "Page Table operations per platform"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:46
msgid "``mm``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:47
msgid "The memory manager used to manage individual GGTT allocations"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:48
msgid "``access_count``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:49
msgid "counts GGTT writes"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:50
msgid "``wq``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:51
msgid "Dedicated unordered work queue to process node removals"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:54
#: ../drivers/gpu/drm/xe/xe_ggtt_types.h:72 ../../../gpu/xe/xe_mm:22:
#: ../drivers/gpu/drm/xe/xe_ggtt.c:197 ../drivers/gpu/drm/xe/xe_ggtt.c:284
#: ../drivers/gpu/drm/xe/xe_ggtt.c:515 ../drivers/gpu/drm/xe/xe_ggtt.c:549
#: ../drivers/gpu/drm/xe/xe_ggtt.c:579 ../drivers/gpu/drm/xe/xe_ggtt.c:621
#: ../drivers/gpu/drm/xe/xe_ggtt.c:639 ../drivers/gpu/drm/xe/xe_ggtt.c:662
#: ../drivers/gpu/drm/xe/xe_ggtt.c:688 ../drivers/gpu/drm/xe/xe_ggtt.c:769
#: ../drivers/gpu/drm/xe/xe_ggtt.c:948 ../drivers/gpu/drm/xe/xe_ggtt.c:1065
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1105 ../drivers/gpu/drm/xe/xe_ggtt.c:1119
msgid "**Description**"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:18
msgid ""
"In general, each tile can contains its own Global Graphics Translation Table "
"(GGTT) instance."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:55
msgid "A node in GGTT."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:62
msgid "``ggtt``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:63
msgid "Back pointer to xe_ggtt where this region will be inserted at"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:64
msgid "``base``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:65
msgid "A drm_mm_node"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:66
msgid "``delayed_removal_work``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:67
msgid "The work struct for the delayed removal"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:68
msgid "``invalidate_on_remove``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:69
msgid "If it needs invalidation upon removal"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:56
msgid ""
"This struct needs to be initialized (only-once) with xe_ggtt_node_init() "
"before any node insertion, reservation, or 'ballooning'. It will, then, be "
"finalized by either xe_ggtt_node_remove() or xe_ggtt_node_deballoon()."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:73
msgid "GGTT Page table operations Which can vary from platform to platform."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:77
msgid "``pte_encode_flags``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:78
msgid "Encode PTE flags for a given BO"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:79
msgid "``ggtt_set_pte``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:80
msgid "Directly write into GGTT's PTE"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:81
msgid "``ggtt_get_pte``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: ../drivers/gpu/drm/xe/xe_ggtt_types.h:82
msgid "Directly read from GGTT's PTE"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:194
msgid "Allocate a GGTT for a given :c:type:`xe_tile`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:198
#: ../drivers/gpu/drm/xe/xe_ggtt.c:285 ../drivers/gpu/drm/xe/xe_ggtt.c:409
#: ../drivers/gpu/drm/xe/xe_ggtt.c:435 ../drivers/gpu/drm/xe/xe_ggtt.c:514
#: ../drivers/gpu/drm/xe/xe_ggtt.c:550 ../drivers/gpu/drm/xe/xe_ggtt.c:579
#: ../drivers/gpu/drm/xe/xe_ggtt.c:619 ../drivers/gpu/drm/xe/xe_ggtt.c:638
#: ../drivers/gpu/drm/xe/xe_ggtt.c:663 ../drivers/gpu/drm/xe/xe_ggtt.c:689
#: ../drivers/gpu/drm/xe/xe_ggtt.c:702 ../drivers/gpu/drm/xe/xe_ggtt.c:716
#: ../drivers/gpu/drm/xe/xe_ggtt.c:730 ../drivers/gpu/drm/xe/xe_ggtt.c:769
#: ../drivers/gpu/drm/xe/xe_ggtt.c:838 ../drivers/gpu/drm/xe/xe_ggtt.c:854
#: ../drivers/gpu/drm/xe/xe_ggtt.c:868 ../drivers/gpu/drm/xe/xe_ggtt.c:887
#: ../drivers/gpu/drm/xe/xe_ggtt.c:948 ../drivers/gpu/drm/xe/xe_ggtt.c:964
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1004 ../drivers/gpu/drm/xe/xe_ggtt.c:1044
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1064 ../drivers/gpu/drm/xe/xe_ggtt.c:1104
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1119
msgid "**Parameters**"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:200
msgid "``struct xe_tile *tile``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:195
msgid ":c:type:`xe_tile`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:196
msgid "Allocates a :c:type:`xe_ggtt` for a given tile."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:198
#: ../drivers/gpu/drm/xe/xe_ggtt.c:288 ../drivers/gpu/drm/xe/xe_ggtt.c:434
#: ../drivers/gpu/drm/xe/xe_ggtt.c:517 ../drivers/gpu/drm/xe/xe_ggtt.c:623
#: ../drivers/gpu/drm/xe/xe_ggtt.c:640 ../drivers/gpu/drm/xe/xe_ggtt.c:668
#: ../drivers/gpu/drm/xe/xe_ggtt.c:701 ../drivers/gpu/drm/xe/xe_ggtt.c:715
#: ../drivers/gpu/drm/xe/xe_ggtt.c:841 ../drivers/gpu/drm/xe/xe_ggtt.c:855
#: ../drivers/gpu/drm/xe/xe_ggtt.c:888 ../drivers/gpu/drm/xe/xe_ggtt.c:966
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1006 ../drivers/gpu/drm/xe/xe_ggtt.c:1044
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1066
msgid "**Return**"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:199
msgid ":c:type:`xe_ggtt` on success, or NULL when out of memory."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:281
msgid "Early GGTT initialization"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:287
#: ../drivers/gpu/drm/xe/xe_ggtt.c:437 ../drivers/gpu/drm/xe/xe_ggtt.c:581
#: ../drivers/gpu/drm/xe/xe_ggtt.c:665 ../drivers/gpu/drm/xe/xe_ggtt.c:732
#: ../drivers/gpu/drm/xe/xe_ggtt.c:771 ../drivers/gpu/drm/xe/xe_ggtt.c:840
#: ../drivers/gpu/drm/xe/xe_ggtt.c:856 ../drivers/gpu/drm/xe/xe_ggtt.c:870
#: ../drivers/gpu/drm/xe/xe_ggtt.c:889 ../drivers/gpu/drm/xe/xe_ggtt.c:1046
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1066 ../drivers/gpu/drm/xe/xe_ggtt.c:1106
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1121
msgid "``struct xe_ggtt *ggtt``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:282
#: ../drivers/gpu/drm/xe/xe_ggtt.c:432
msgid "the :c:type:`xe_ggtt` to be initialized"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:283
msgid ""
"It allows to create new mappings usable by the GuC. Mappings are not usable "
"by the HW engines, as it doesn't have scratch nor initial clear done to it "
"yet. That will happen in the regular, non-early GGTT initialization."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:289
#: ../drivers/gpu/drm/xe/xe_ggtt.c:434 ../drivers/gpu/drm/xe/xe_ggtt.c:518
#: ../drivers/gpu/drm/xe/xe_ggtt.c:624 ../drivers/gpu/drm/xe/xe_ggtt.c:641
#: ../drivers/gpu/drm/xe/xe_ggtt.c:841 ../drivers/gpu/drm/xe/xe_ggtt.c:855
#: ../drivers/gpu/drm/xe/xe_ggtt.c:966 ../drivers/gpu/drm/xe/xe_ggtt.c:1006
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1044
msgid "0 on success or a negative error code on failure."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:405
msgid "Remove a :c:type:`xe_ggtt_node` from the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:411
#: ../drivers/gpu/drm/xe/xe_ggtt.c:516 ../drivers/gpu/drm/xe/xe_ggtt.c:552
#: ../drivers/gpu/drm/xe/xe_ggtt.c:621 ../drivers/gpu/drm/xe/xe_ggtt.c:640
#: ../drivers/gpu/drm/xe/xe_ggtt.c:691 ../drivers/gpu/drm/xe/xe_ggtt.c:729
#: ../drivers/gpu/drm/xe/xe_ggtt.c:966 ../drivers/gpu/drm/xe/xe_ggtt.c:1006
msgid "``struct xe_ggtt_node *node``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:406
msgid "the :c:type:`xe_ggtt_node` to be removed"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:408
msgid "``bool invalidate``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:407
msgid "if node needs invalidation upon removal"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:431
msgid "Regular non-early GGTT initialization"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:510
msgid "prevent allocation of specified GGTT addresses"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:511
msgid "the :c:type:`xe_ggtt_node` to hold reserved GGTT node"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:513
#: ../drivers/gpu/drm/xe/xe_ggtt.c:838
msgid "``u64 start``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:512
msgid "the starting GGTT address of the reserved region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:514
#: ../drivers/gpu/drm/xe/xe_ggtt.c:839
msgid "``u64 end``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:513
msgid "then end GGTT address of the reserved region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:514
msgid ""
"To be used in cases where ggtt->lock is already taken. Use "
"xe_ggtt_node_remove_balloon_locked() to release a reserved GGTT node."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:546
msgid "release a reserved GGTT region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:547
msgid "the :c:type:`xe_ggtt_node` with reserved GGTT region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:548
msgid ""
"To be used in cases where ggtt->lock is already taken. See "
"xe_ggtt_node_insert_balloon_locked() for details."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:575
msgid "Shift GGTT nodes to adjust for a change in usable address range."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:576
msgid "the :c:type:`xe_ggtt` struct instance"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:578
msgid "``s64 shift``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:577
msgid "change to the location of area provisioned for current VF"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:578
msgid ""
"This function moves all nodes from the GGTT VM, to a temp list. These nodes "
"are expected to represent allocations in range formerly assigned to current "
"VF, before the range changed. When the GGTT VM is completely clear of any "
"nodes, they are re-added with shifted offsets."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:582
msgid ""
"The function has no ability of failing - because it shifts existing nodes, "
"without any additional processing. If the nodes were successfully existing "
"at the old address, they will do the same at the new one. A fail inside this "
"function would indicate that the list of nodes was either already damaged, "
"or that the shift brings the address range outside of valid bounds. Both "
"cases justify an assert rather than error code."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:615
msgid "Locked version to insert a :c:type:`xe_ggtt_node` into the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:616
#: ../drivers/gpu/drm/xe/xe_ggtt.c:635
msgid "the :c:type:`xe_ggtt_node` to be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:618
#: ../drivers/gpu/drm/xe/xe_ggtt.c:637
msgid "``u32 size``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:617
#: ../drivers/gpu/drm/xe/xe_ggtt.c:636
msgid "size of the node"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:619
#: ../drivers/gpu/drm/xe/xe_ggtt.c:638
msgid "``u32 align``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:618
#: ../drivers/gpu/drm/xe/xe_ggtt.c:637
msgid "alignment constrain of the node"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:620
msgid "``u32 mm_flags``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:619
msgid "flags to control the node behavior"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:620
msgid ""
"It cannot be called without first having called xe_ggtt_init() once. To be "
"used in cases where ggtt->lock is already taken."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:634
msgid "Insert a :c:type:`xe_ggtt_node` into the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:638
msgid "It cannot be called without first having called xe_ggtt_init() once."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:659
msgid "Initialize ``xe_ggtt_node`` struct"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:660
msgid ""
"the :c:type:`xe_ggtt` where the new node will later be inserted/reserved."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:661
msgid ""
"This function will allocate the struct ``xe_ggtt_node`` and return its "
"pointer. This struct will then be freed after the node removal upon "
"xe_ggtt_node_remove() or xe_ggtt_node_remove_balloon_locked(). Having "
"``xe_ggtt_node`` struct allocated doesn't mean that the node is already "
"allocated in GGTT. Only the xe_ggtt_node_insert(), "
"xe_ggtt_node_insert_locked(), xe_ggtt_node_insert_balloon_locked() will "
"ensure the node is inserted or reserved in GGTT."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:669
msgid "A pointer to ``xe_ggtt_node`` struct on success. An ERR_PTR otherwise."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:685
msgid "Forcebly finalize ``xe_ggtt_node`` struct"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:686
msgid "the :c:type:`xe_ggtt_node` to be freed"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:687
msgid ""
"If anything went wrong with either xe_ggtt_node_insert(), "
"xe_ggtt_node_insert_locked(), or xe_ggtt_node_insert_balloon_locked(); and "
"this **node** is not going to be reused, then, this function needs to be "
"called to free the ``xe_ggtt_node`` struct"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:698
msgid "Check if node is allocated in GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:704
#: ../drivers/gpu/drm/xe/xe_ggtt.c:718 ../drivers/gpu/drm/xe/xe_ggtt.c:950
msgid "``const struct xe_ggtt_node *node``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:699
msgid "the :c:type:`xe_ggtt_node` to be inspected"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:701
msgid "True if allocated, False otherwise."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:712
msgid "Get the size of page table entries needed to map a GGTT node."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:713
msgid "the :c:type:`xe_ggtt_node`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:715
msgid "GGTT node page table entries size in bytes."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:726
msgid "Map the BO into GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:727
#: ../drivers/gpu/drm/xe/xe_ggtt.c:766
msgid "the :c:type:`xe_ggtt` where node will be mapped"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:728
msgid "the :c:type:`xe_ggtt_node` where this BO is mapped"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:730
#: ../drivers/gpu/drm/xe/xe_ggtt.c:768 ../drivers/gpu/drm/xe/xe_ggtt.c:837
#: ../drivers/gpu/drm/xe/xe_ggtt.c:853 ../drivers/gpu/drm/xe/xe_ggtt.c:867
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1103
msgid "``struct xe_bo *bo``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:729
#: ../drivers/gpu/drm/xe/xe_ggtt.c:767
msgid "the :c:type:`xe_bo` to be mapped"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:731
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1104
msgid "``u16 pat_index``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:730
msgid "Which pat_index to use."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:765
msgid "Restore a mapping of a BO into GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:768
msgid "This is used to restore a GGTT mapping after suspend."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:834
msgid "Insert BO at a specific GGTT space"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:835
#: ../drivers/gpu/drm/xe/xe_ggtt.c:851
msgid "the :c:type:`xe_ggtt` where bo will be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:836
#: ../drivers/gpu/drm/xe/xe_ggtt.c:852
msgid "the :c:type:`xe_bo` to be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:837
msgid "address where it will be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:838
msgid "end of the range where it will be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:840
#: ../drivers/gpu/drm/xe/xe_ggtt.c:854
msgid "``struct drm_exec *exec``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:839
#: ../drivers/gpu/drm/xe/xe_ggtt.c:853
msgid "The drm_exec transaction to use for exhaustive eviction."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:850
msgid "Insert BO into GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:864
msgid "Remove a BO from the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:865
msgid "the :c:type:`xe_ggtt` where node will be removed"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:866
msgid "the :c:type:`xe_bo` to be removed"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:883
msgid "Largest GGTT hole"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:884
msgid "the :c:type:`xe_ggtt` that will be inspected"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:886
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1063
msgid "``u64 alignment``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:885
msgid "minimum alignment"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:887
msgid "``u64 *spare``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:886
msgid ""
"If not NULL: in: desired memory size to be spared / out: Adjusted possible "
"spare"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:888
msgid "size of the largest continuous GGTT region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:944
msgid "assign a GGTT region to the VF"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:945
msgid "the :c:type:`xe_ggtt_node` to update"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:947
#: ../drivers/gpu/drm/xe/xe_ggtt.c:965 ../drivers/gpu/drm/xe/xe_ggtt.c:1005
msgid "``u16 vfid``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:946
msgid "the VF identifier"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:947
msgid ""
"This function is used by the PF driver to assign a GGTT region to the VF. In "
"addition to PTE's VFID bits 11:2 also PRESENT bit 0 is set as on some "
"platforms VFs can't modify that either."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:960
msgid "Save a :c:type:`xe_ggtt_node` to a buffer."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:961
msgid "the :c:type:`xe_ggtt_node` to be saved"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:963
msgid "``void *dst``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:962
msgid "destination buffer"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:964
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1004
msgid "``size_t size``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:963
msgid "destination buffer size in bytes"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:964
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1004
msgid "VF identifier"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1000
msgid "Load a :c:type:`xe_ggtt_node` from a buffer."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1001
msgid "the :c:type:`xe_ggtt_node` to be loaded"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1003
msgid "``const void *src``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1002
msgid "source buffer"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1003
msgid "source buffer size in bytes"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1040
msgid "Dump GGTT for debug"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1041
msgid "the :c:type:`xe_ggtt` to be dumped"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1043
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1064
msgid "``struct drm_printer *p``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1042
msgid ""
"the :c:type:`drm_mm_printer` helper handle to be used to dump the information"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1060
msgid "Print holes"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1061
msgid "the :c:type:`xe_ggtt` to be inspected"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1062
msgid "min alignment"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1063
msgid "the :c:type:`drm_printer`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1064
msgid "Print GGTT ranges that are available and return total size available."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1067
msgid "Total available size."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1100
msgid "Get PTE encoding flags for BO"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1101
#: ../drivers/gpu/drm/xe/xe_ggtt.c:1116
msgid ":c:type:`xe_ggtt`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1102
msgid ":c:type:`xe_bo`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1103
msgid "The pat_index for the PTE."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1104
msgid ""
"This function returns the pte_flags for a given BO, without  address. It's "
"used for DPT to fill a GGTT mapped BO with a linear lookup table."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1115
msgid "Read a PTE from the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1118
msgid "``u64 offset``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1117
msgid "the offset for which the mapping should be read."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: ../drivers/gpu/drm/xe/xe_ggtt.c:1118
msgid "Used by testcases, and by display reading out an inherited bios FB."
msgstr ""

#: ../../../gpu/xe/xe_mm.rst:26
msgid "Pagetable building"
msgstr ""

#: ../../../gpu/xe/xe_mm:28: ../drivers/gpu/drm/xe/xe_pt.c:242
msgid ""
"Below we use the term \"page-table\" for both page-directories, containing "
"pointers to lower level page-directories or page-tables, and level 0 page-"
"tables that contain only page-table-entries pointing to memory pages."
msgstr ""

#: ../../../gpu/xe/xe_mm:28: ../drivers/gpu/drm/xe/xe_pt.c:246
msgid ""
"When inserting an address range in an already existing page-table tree there "
"will typically be a set of page-tables that are shared with other address "
"ranges, and a set that are private to this address range. The set of shared "
"page-tables can be at most two per level, and those can't be updated "
"immediately because the entries of those page-tables may still be in use by "
"the gpu for other mappings. Therefore when inserting entries into those, we "
"instead stage those insertions by adding insertion data into struct "
"xe_vm_pgtable_update structures. This data, (subtrees for the cpu and page-"
"table-entries for the gpu) is then added in a separate commit step. CPU-data "
"is committed while still under the vm lock, the object lock and for userptr, "
"the notifier lock in read mode. The GPU async data is committed either by "
"the GPU or CPU after fulfilling relevant dependencies. For non-shared page-"
"tables (and, in fact, for shared ones that aren't existing at the time of "
"staging), we add the data in-place without the special update structures. "
"This private part of the page-table tree will remain disconnected from the "
"vm page-table tree until data is committed to the shared page tables of the "
"vm tree in the commit phase."
msgstr ""
