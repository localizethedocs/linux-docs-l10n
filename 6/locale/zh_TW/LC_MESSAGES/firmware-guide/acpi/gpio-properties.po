# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../firmware-guide/acpi/gpio-properties.rst:5
msgid "_DSD Device Properties Related to GPIO"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:7
msgid ""
"With the release of ACPI 5.1, the _DSD configuration object finally allows "
"names to be given to GPIOs (and other things as well) returned by _CRS. "
"Previously we were only able to use an integer index to find the "
"corresponding GPIO, which is pretty error prone (it depends on the _CRS "
"output ordering, for example)."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:13
msgid ""
"With _DSD we can now query GPIOs using a name instead of an integer index, "
"like the ASL example below shows::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:40
msgid "The format of the supported GPIO property is::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:44
msgid "ref"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:45
msgid ""
"The device that has _CRS containing GpioIo()/GpioInt() resources, typically "
"this is the device itself (BTH in our case)."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:47
msgid "index"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:48
msgid "Index of the GpioIo()/GpioInt() resource in _CRS starting from zero."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:49
msgid "pin"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:50
msgid "Pin in the GpioIo()/GpioInt() resource. Typically this is zero."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:51
msgid "active_low"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:52
msgid "If 1, the GPIO is marked as active-low."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:54
msgid ""
"Since ACPI GpioIo() resource does not have a field saying whether it is "
"active-low or active-high, the \"active_low\" argument can be used here. "
"Setting it to 1 marks the GPIO as active-low."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:58
msgid ""
"Note, active_low in _DSD does not make sense for GpioInt() resource and must "
"be 0. GpioInt() resource has its own means of defining it."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:61
msgid ""
"In our Bluetooth example the \"reset-gpios\" refers to the second GpioIo() "
"resource, second pin in that resource with the GPIO number of 31."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:64
msgid ""
"The GpioIo() resource unfortunately doesn't explicitly provide an initial "
"state of the output pin which driver should use during its initialization."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:67
msgid ""
"Linux tries to use common sense here and derives the state from the bias and "
"polarity settings. The table below shows the expectations:"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:71
msgid "Pull Bias"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:71
msgid "Polarity"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:71
msgid "Requested..."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:73
msgid "Implicit"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:75
msgid "**Default**"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:75
#: ../../../firmware-guide/acpi/gpio-properties.rst:79
msgid "x"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:75
msgid "AS IS (assumed firmware configured it for us)"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:77
msgid "Explicit"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:79
msgid "**None**"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:79
msgid "AS IS (assumed firmware configured it for us) with no Pull Bias"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:82
msgid "**Up**"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:82
#: ../../../firmware-guide/acpi/gpio-properties.rst:88
msgid "x (no _DSD)"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:83
msgid "as high, assuming non-active"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:84
#: ../../../firmware-guide/acpi/gpio-properties.rst:92
msgid "Low"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:86
#: ../../../firmware-guide/acpi/gpio-properties.rst:90
msgid "High"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:86
msgid "as high, assuming active"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:88
msgid "**Down**"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:89
msgid "as low, assuming non-active"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:92
msgid "as low, assuming active"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:95
msgid ""
"That said, for our above example, since the bias setting is explicit and "
"_DSD is present, both GPIOs will be treated as active with a high polarity "
"and Linux will configure the pins in this state until a driver reprograms "
"them differently."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:100
msgid ""
"It is possible to leave holes in the array of GPIOs. This is useful in cases "
"like with SPI host controllers where some chip selects may be implemented as "
"GPIOs and some as native signals. For example a SPI host controller can have "
"chip selects 0 and 2 implemented as GPIOs and 1 as native::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:115
msgid ""
"Note, that historically ACPI has no means of the GPIO polarity and thus the "
"SPISerialBus() resource defines it on the per-chip basis. In order to avoid "
"a chain of negations, the GPIO polarity is considered being Active High. "
"Even for the cases when _DSD() is involved (see the example above) the GPIO "
"CS polarity must be defined Active High to avoid ambiguity."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:122
msgid "Other supported properties"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:124
msgid ""
"Following Device Tree compatible device properties are also supported by "
"_DSD device properties for GPIO controllers:"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:127
msgid "gpio-hog"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:128
msgid "output-high"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:129
msgid "output-low"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:130
msgid "input"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:131
msgid "line-name"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:133
msgid "Example::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:153
msgid "gpio-line-names"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:155
msgid ""
"The ``gpio-line-names`` declaration is a list of strings (\"names\"), which "
"describes each line/pin of a GPIO controller/expander. This list, contained "
"in a package, must be inserted inside the GPIO controller declaration of an "
"ACPI table (typically inside the DSDT). The ``gpio-line-names`` list must "
"respect the following rules (see also the examples):"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:161
msgid ""
"the first name in the list corresponds with the first line/pin of the GPIO "
"controller/expander"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:163
msgid ""
"the names inside the list must be consecutive (no \"holes\" are permitted)"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:164
msgid ""
"the list can be incomplete and can end before the last GPIO line: in other "
"words, it is not mandatory to fill all the GPIO lines"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:166
msgid ""
"empty names are allowed (two quotation marks ``\"\"`` correspond to an empty "
"name)"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:168
msgid "names inside one GPIO controller/expander must be unique"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:170
msgid ""
"Example of a GPIO controller of 16 lines, with an incomplete list with two "
"empty names::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:185
msgid ""
"At runtime, the above declaration produces the following result (using the "
"\"libgpiod\" tools)::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:210
msgid "Another example::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:220
msgid ""
"See Documentation/devicetree/bindings/gpio/gpio.txt for more information "
"about these properties."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:224
msgid "ACPI GPIO Mappings Provided by Drivers"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:226
msgid ""
"There are systems in which the ACPI tables do not contain _DSD but provide "
"_CRS with GpioIo()/GpioInt() resources and device drivers still need to work "
"with them."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:230
msgid ""
"In those cases ACPI device identification objects, _HID, _CID, _CLS, _SUB, "
"_HRV, available to the driver can be used to identify the device and that is "
"supposed to be sufficient to determine the meaning and purpose of all of the "
"GPIO lines listed by the GpioIo()/GpioInt() resources returned by _CRS.  In "
"other words, the driver is supposed to know what to use from the GpioIo()/"
"GpioInt() resources for once it has identified the device. Having done that, "
"it can simply assign names to the GPIO lines it is going to use and provide "
"the GPIO subsystem with a mapping between those names and the ACPI GPIO "
"resources corresponding to them."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:239
msgid ""
"To do that, the driver needs to define a mapping table as a NULL-terminated "
"array of struct acpi_gpio_mapping objects that each contains a name, a "
"pointer to an array of line data (struct acpi_gpio_params) objects and the "
"size of that array.  Each struct acpi_gpio_params object consists of three "
"fields, crs_entry_index, line_index, active_low, representing the index of "
"the target GpioIo()/GpioInt() resource in _CRS starting from zero, the index "
"of the target line in that resource starting from zero, and the active-low "
"flag for that line, respectively, in analogy with the _DSD GPIO property "
"format specified above."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:248
msgid ""
"For the example Bluetooth device discussed previously the data structures in "
"question would look like this::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:260
msgid ""
"Next, the mapping table needs to be passed as the second argument to "
"acpi_dev_add_driver_gpios() or its managed analogue that will register it "
"with the ACPI device object pointed to by its first argument. That should be "
"done in the driver's .probe() routine. On removal, the driver should "
"unregister its GPIO mapping table by calling acpi_dev_remove_driver_gpios() "
"on the ACPI device object where that table was previously registered."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:269
msgid "Using the _CRS fallback"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:271
msgid ""
"If a device does not have _DSD or the driver does not create ACPI GPIO "
"mapping, the Linux GPIO framework refuses to return any GPIOs. This is "
"because the driver does not know what it actually gets. For example, if we "
"have a device like below::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:288
msgid "The driver might expect to get the right GPIO when it does::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:294
msgid ""
"but since there is no way to know the mapping between \"reset\" and the "
"GpioIo() in _CRS the desc will hold ERR_PTR(-ENOENT)."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:297
msgid ""
"The driver author can solve this by passing the mapping explicitly (this is "
"the recommended way and it's documented in the above chapter)."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:300
msgid ""
"The ACPI GPIO mapping tables should not contaminate drivers that are not "
"knowing about which exact device they are servicing on. It implies that the "
"ACPI GPIO mapping tables are hardly linked to an ACPI ID and certain "
"objects, as listed in the above chapter, of the device in question."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:306
msgid "Getting GPIO descriptor"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:308
msgid "There are two main approaches to get GPIO resource from ACPI::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:313
msgid ""
"We may consider two different cases here, i.e. when connection ID is "
"provided and otherwise."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:316
msgid "Case 1::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:321
msgid ""
"Case 1 assumes that corresponding ACPI device description must have defined "
"device properties and will prevent from getting any GPIO resources otherwise."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:325
msgid "Case 2::"
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:330
msgid "Case 2 explicitly tells GPIO core to look for resources in _CRS."
msgstr ""

#: ../../../firmware-guide/acpi/gpio-properties.rst:332
msgid ""
"Be aware that gpiod_get_index() in cases 1 and 2, assuming that there are "
"two versions of ACPI device description provided and no mapping is present "
"in the driver, will return different resources. That's why a certain driver "
"has to handle them carefully as explained in the previous chapter."
msgstr ""
