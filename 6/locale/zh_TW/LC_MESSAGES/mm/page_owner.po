# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/page_owner.rst:3
msgid "page owner: Tracking about who allocated each page"
msgstr ""

#: ../../../mm/page_owner.rst:6
msgid "Introduction"
msgstr "介紹"

#: ../../../mm/page_owner.rst:8
msgid ""
"page owner is for the tracking about who allocated each page. It can be used "
"to debug memory leak or to find a memory hogger. When allocation happens, "
"information about allocation such as call stack and order of pages is stored "
"into certain storage for each page. When we need to know about status of all "
"pages, we can get and analyze this information."
msgstr ""

#: ../../../mm/page_owner.rst:15
msgid ""
"Although we already have tracepoint for tracing page allocation/free, using "
"it for analyzing who allocate each page is rather complex. We need to "
"enlarge the trace buffer for preventing overlapping until userspace program "
"launched. And, launched program continually dump out the trace buffer for "
"later analysis and it would change system behaviour with more possibility "
"rather than just keeping it in memory, so bad for debugging."
msgstr ""

#: ../../../mm/page_owner.rst:22
msgid ""
"page owner can also be used for various purposes. For example, accurate "
"fragmentation statistics can be obtained through gfp flag information of "
"each page. It is already implemented and activated if page owner is enabled. "
"Other usages are more than welcome."
msgstr ""

#: ../../../mm/page_owner.rst:27
msgid ""
"It can also be used to show all the stacks and their current number of "
"allocated base pages, which gives us a quick overview of where the memory is "
"going without the need to screen through all the pages and match the "
"allocation and free operation. It's also possible to show only a numeric "
"identifier of all the stacks (without stack traces) and their number of "
"allocated base pages (faster to read and parse, eg, for monitoring) that can "
"be matched with stacks later (show_handles and show_stacks_handles)."
msgstr ""

#: ../../../mm/page_owner.rst:35
msgid ""
"page owner is disabled by default. So, if you'd like to use it, you need to "
"add \"page_owner=on\" to your boot cmdline. If the kernel is built with page "
"owner and page owner is disabled in runtime due to not enabling boot option, "
"runtime overhead is marginal. If disabled in runtime, it doesn't require "
"memory to store owner information, so there is no runtime memory overhead. "
"And, page owner inserts just two unlikely branches into the page allocator "
"hotpath and if not enabled, then allocation is done like as the kernel "
"without page owner. These two unlikely branches should not affect to "
"allocation performance, especially if the static keys jump label patching "
"functionality is available. Following is the kernel's code size change due "
"to this facility."
msgstr ""

#: ../../../mm/page_owner.rst:47
msgid ""
"Although enabling page owner increases kernel size by several kilobytes, "
"most of this code is outside page allocator and its hot path. Building the "
"kernel with page owner and turning it on if needed would be great option to "
"debug kernel memory problem."
msgstr ""

#: ../../../mm/page_owner.rst:52
msgid ""
"There is one notice that is caused by implementation detail. page owner "
"stores information into the memory from struct page extension. This memory "
"is initialized some time later than that page allocator starts in sparse "
"memory system, so, until initialization, many pages can be allocated and "
"they would have no owner information. To fix it up, these early allocated "
"pages are investigated and marked as allocated in initialization phase. "
"Although it doesn't mean that they have the right owner information, at "
"least, we can tell whether the page is allocated or not, more accurately. On "
"2GB memory x86-64 VM box, 13343 early allocated pages are caught and marked, "
"although they are mostly allocated from struct page extension feature. "
"Anyway, after that, no page is left in un-tracking state."
msgstr ""

#: ../../../mm/page_owner.rst:66
msgid "Usage"
msgstr ""

#: ../../../mm/page_owner.rst:68
msgid "Build user-space helper::"
msgstr ""

#: ../../../mm/page_owner.rst:73
msgid "Enable page owner: add \"page_owner=on\" to boot cmdline."
msgstr ""

#: ../../../mm/page_owner.rst:75
msgid "Do the job that you want to debug."
msgstr ""

#: ../../../mm/page_owner.rst:77
msgid "Analyze information from page owner::"
msgstr ""

#: ../../../mm/page_owner.rst:152
msgid "The general output of ``page_owner_full.txt`` is as follows::"
msgstr ""

#: ../../../mm/page_owner.rst:167
msgid ""
"The ``page_owner_sort`` tool ignores ``PFN`` rows, puts the remaining rows "
"in buf, uses regexp to extract the page order value, counts the times and "
"pages of buf, and finally sorts them according to the parameter(s)."
msgstr ""

#: ../../../mm/page_owner.rst:171
msgid ""
"See the result about who allocated each page in the ``sorted_page_owner."
"txt``. General output::"
msgstr ""

#: ../../../mm/page_owner.rst:178
msgid ""
"By default, ``page_owner_sort`` is sorted according to the times of buf. If "
"you want to sort by the page nums of buf, use the ``-m`` parameter. The "
"detailed parameters are:"
msgstr ""

#: ../../../mm/page_owner.rst:182
msgid "fundamental function::"
msgstr ""

#: ../../../mm/page_owner.rst:202
msgid "additional function::"
msgstr ""

#: ../../../mm/page_owner.rst:242
msgid "STANDARD FORMAT SPECIFIERS"
msgstr ""
