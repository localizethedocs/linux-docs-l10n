# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/dma-buf.rst:2
msgid "Buffer Sharing and Synchronization (dma-buf)"
msgstr ""

#: ../../../driver-api/dma-buf.rst:4
msgid ""
"The dma-buf subsystem provides the framework for sharing buffers for "
"hardware (DMA) access across multiple device drivers and subsystems, and for "
"synchronizing asynchronous hardware access."
msgstr ""

#: ../../../driver-api/dma-buf.rst:8
msgid ""
"As an example, it is used extensively by the DRM subsystem to exchange "
"buffers between processes, contexts, library APIs within the same process, "
"and also to exchange buffers with other subsystems such as V4L2."
msgstr ""

#: ../../../driver-api/dma-buf.rst:13
msgid ""
"This document describes the way in which kernel subsystems can use and "
"interact with the three main primitives offered by dma-buf:"
msgstr ""

#: ../../../driver-api/dma-buf.rst:16
msgid ""
"dma-buf, representing a sg_table and exposed to userspace as a file "
"descriptor to allow passing between processes, subsystems, devices, etc;"
msgstr ""

#: ../../../driver-api/dma-buf.rst:19
msgid ""
"dma-fence, providing a mechanism to signal when an asynchronous hardware "
"operation has completed; and"
msgstr ""

#: ../../../driver-api/dma-buf.rst:21
msgid ""
"dma-resv, which manages a set of dma-fences for a particular dma-buf "
"allowing implicit (kernel-ordered) synchronization of work to preserve the "
"illusion of coherent access"
msgstr ""

#: ../../../driver-api/dma-buf.rst:27
msgid "Userspace API principles and use"
msgstr ""

#: ../../../driver-api/dma-buf.rst:29
msgid ""
"For more details on how to design your subsystem's API for dma-buf use, "
"please see Documentation/userspace-api/dma-buf-alloc-exchange.rst."
msgstr ""

#: ../../../driver-api/dma-buf.rst:34
msgid "Shared DMA Buffers"
msgstr ""

#: ../../../driver-api/dma-buf.rst:36
msgid ""
"This document serves as a guide to device-driver writers on what is the dma-"
"buf buffer sharing API, how to use it for exporting and using shared buffers."
msgstr ""

#: ../../../driver-api/dma-buf.rst:39
msgid ""
"Any device driver which wishes to be a part of DMA buffer sharing, can do so "
"as either the 'exporter' of buffers, or the 'user' or 'importer' of buffers."
msgstr ""

#: ../../../driver-api/dma-buf.rst:42
msgid ""
"Say a driver A wants to use buffers created by driver B, then we call B as "
"the exporter, and A as buffer-user/importer."
msgstr ""

#: ../../../driver-api/dma-buf.rst:45
msgid "The exporter"
msgstr ""

#: ../../../driver-api/dma-buf.rst:47
msgid ""
"implements and manages operations in :c:type:`struct dma_buf_ops "
"<dma_buf_ops>` for the buffer,"
msgstr ""

#: ../../../driver-api/dma-buf.rst:49
msgid "allows other users to share the buffer by using dma_buf sharing APIs,"
msgstr ""

#: ../../../driver-api/dma-buf.rst:50
msgid ""
"manages the details of buffer allocation, wrapped in a :c:type:`struct "
"dma_buf <dma_buf>`,"
msgstr ""

#: ../../../driver-api/dma-buf.rst:52
msgid "decides about the actual backing storage where this allocation happens,"
msgstr ""

#: ../../../driver-api/dma-buf.rst:53
msgid ""
"and takes care of any migration of scatterlist - for all (shared) users of "
"this buffer."
msgstr ""

#: ../../../driver-api/dma-buf.rst:56
msgid "The buffer-user"
msgstr ""

#: ../../../driver-api/dma-buf.rst:58
msgid "is one of (many) sharing users of the buffer."
msgstr ""

#: ../../../driver-api/dma-buf.rst:59
msgid "doesn't need to worry about how the buffer is allocated, or where."
msgstr ""

#: ../../../driver-api/dma-buf.rst:60
msgid ""
"and needs a mechanism to get access to the scatterlist that makes up this "
"buffer in memory, mapped into its own address space, so it can access the "
"same area of memory. This interface is provided by :c:type:`struct "
"dma_buf_attachment <dma_buf_attachment>`."
msgstr ""

#: ../../../driver-api/dma-buf.rst:65
msgid ""
"Any exporters or users of the dma-buf buffer sharing framework must have a "
"'select DMA_SHARED_BUFFER' in their respective Kconfigs."
msgstr ""

#: ../../../driver-api/dma-buf.rst:69
msgid "Userspace Interface Notes"
msgstr ""

#: ../../../driver-api/dma-buf.rst:71
msgid ""
"Mostly a DMA buffer file descriptor is simply an opaque object for "
"userspace, and hence the generic interface exposed is very minimal. There's "
"a few things to consider though:"
msgstr ""

#: ../../../driver-api/dma-buf.rst:75
msgid ""
"Since kernel 3.12 the dma-buf FD supports the llseek system call, but only "
"with offset=0 and whence=SEEK_END|SEEK_SET. SEEK_SET is supported to allow "
"the usual size discover pattern size = SEEK_END(0); SEEK_SET(0). Every other "
"llseek operation will report -EINVAL."
msgstr ""

#: ../../../driver-api/dma-buf.rst:80
msgid ""
"If llseek on dma-buf FDs isn't supported the kernel will report -ESPIPE for "
"all cases. Userspace can use this to detect support for discovering the dma-"
"buf size using llseek."
msgstr ""

#: ../../../driver-api/dma-buf.rst:84
msgid ""
"In order to avoid fd leaks on exec, the FD_CLOEXEC flag must be set on the "
"file descriptor.  This is not just a resource leak, but a potential security "
"hole.  It could give the newly exec'd application access to buffers, via the "
"leaked fd, to which it should otherwise not be permitted access."
msgstr ""

#: ../../../driver-api/dma-buf.rst:90
msgid ""
"The problem with doing this via a separate fcntl() call, versus doing it "
"atomically when the fd is created, is that this is inherently racy in a "
"multi-threaded app[3].  The issue is made worse when it is library code "
"opening/creating the file descriptor, as the application may not even be "
"aware of the fd's."
msgstr ""

#: ../../../driver-api/dma-buf.rst:96
msgid ""
"To avoid this problem, userspace must have a way to request O_CLOEXEC flag "
"be set when the dma-buf fd is created.  So any API provided by the exporting "
"driver to create a dmabuf fd must provide a way to let userspace control "
"setting of O_CLOEXEC flag passed in to dma_buf_fd()."
msgstr ""

#: ../../../driver-api/dma-buf.rst:101
msgid ""
"Memory mapping the contents of the DMA buffer is also supported. See the "
"discussion below on `CPU Access to DMA Buffer Objects`_ for the full details."
msgstr ""

#: ../../../driver-api/dma-buf.rst:104
msgid ""
"The DMA buffer FD is also pollable, see `Implicit Fence Poll Support`_ below "
"for details."
msgstr ""

#: ../../../driver-api/dma-buf.rst:107
msgid ""
"The DMA buffer FD also supports a few dma-buf-specific ioctls, see `DMA "
"Buffer ioctls`_ below for details."
msgstr ""

#: ../../../driver-api/dma-buf.rst:111
msgid "Basic Operation and Device DMA Access"
msgstr ""

#: ../../../driver-api/dma-buf:113: drivers/dma-buf/dma-buf.c:635
msgid ""
"For device DMA access to a shared DMA buffer the usual sequence of "
"operations is fairly simple:"
msgstr ""

#: ../../../driver-api/dma-buf:113: drivers/dma-buf/dma-buf.c:638
msgid ""
"The exporter defines his exporter instance using "
"DEFINE_DMA_BUF_EXPORT_INFO() and calls dma_buf_export() to wrap a private "
"buffer object into a :c:type:`dma_buf`. It then exports that :c:type:"
"`dma_buf` to userspace as a file descriptor by calling dma_buf_fd()."
msgstr ""

#: ../../../driver-api/dma-buf:113: drivers/dma-buf/dma-buf.c:643
msgid ""
"Userspace passes this file-descriptors to all drivers it wants this buffer "
"to share with: First the file descriptor is converted to a :c:type:`dma_buf` "
"using dma_buf_get(). Then the buffer is attached to the device using "
"dma_buf_attach()."
msgstr ""

#: ../../../driver-api/dma-buf:113: drivers/dma-buf/dma-buf.c:648
msgid ""
"Up to this stage the exporter is still free to migrate or reallocate the "
"backing storage."
msgstr ""

#: ../../../driver-api/dma-buf:113: drivers/dma-buf/dma-buf.c:651
msgid ""
"Once the buffer is attached to all devices userspace can initiate DMA access "
"to the shared buffer. In the kernel this is done by calling "
"dma_buf_map_attachment() and dma_buf_unmap_attachment()."
msgstr ""

#: ../../../driver-api/dma-buf:113: drivers/dma-buf/dma-buf.c:655
msgid ""
"Once a driver is done with a shared buffer it needs to call dma_buf_detach() "
"(after cleaning up any mappings) and then release the reference acquired "
"with dma_buf_get() by calling dma_buf_put()."
msgstr ""

#: ../../../driver-api/dma-buf:113: drivers/dma-buf/dma-buf.c:659
msgid ""
"For the detailed semantics exporters are expected to implement see :c:type:"
"`dma_buf_ops`."
msgstr ""

#: ../../../driver-api/dma-buf.rst:117
msgid "CPU Access to DMA Buffer Objects"
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1278
msgid ""
"There are multiple reasons for supporting CPU access to a dma buffer object:"
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1280
msgid ""
"Fallback operations in the kernel, for example when a device is connected "
"over USB and the kernel needs to shuffle the data around first before "
"sending it away. Cache coherency is handled by bracketing any transactions "
"with calls to dma_buf_begin_cpu_access() and dma_buf_end_cpu_access() access."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1286
msgid ""
"Since for most kernel internal dma-buf accesses need the entire buffer, a "
"vmap interface is introduced. Note that on very old 32-bit architectures "
"vmalloc space might be limited and result in vmap calls failing."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1290
msgid "Interfaces:"
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1297
msgid ""
"The vmap call can fail if there is no vmap support in the exporter, or if it "
"runs out of vmalloc space. Note that the dma-buf layer keeps a reference "
"count for all vmap access and calls down into the exporter's vmap function "
"only when no vmapping exists, and only unmaps it once. Protection against "
"concurrent vmap/vunmap calls is provided by taking the :c:type:`dma_buf.lock "
"<dma_buf>` mutex."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1303
msgid ""
"For full compatibility on the importer side with existing userspace "
"interfaces, which might already support mmap'ing buffers. This is needed in "
"many processing pipelines (e.g. feeding a software rendered image into a "
"hardware pipeline, thumbnail creation, snapshots, ...). Also, Android's ION "
"framework already supported this and for DMA buffer file descriptors to "
"replace ION buffers mmap support was needed."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1310
msgid ""
"There is no special interfaces, userspace simply calls mmap on the dma-buf "
"fd. But like for CPU access there's a need to bracket the actual access, "
"which is handled by the ioctl (DMA_BUF_IOCTL_SYNC). Note that "
"DMA_BUF_IOCTL_SYNC can fail with -EAGAIN or -EINTR, in which case it must be "
"restarted."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1316
msgid ""
"Some systems might need some sort of cache coherency management e.g. when "
"CPU and GPU domains are being accessed through dma-buf at the same time. To "
"circumvent this problem there are begin/end coherency markers, that forward "
"directly to existing dma-buf device drivers vfunc hooks. Userspace can make "
"use of those markers through the DMA_BUF_IOCTL_SYNC ioctl. The sequence "
"would be used like following:"
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1323
msgid "mmap dma-buf fd"
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1324
msgid ""
"for each drawing/upload cycle in CPU 1. SYNC_START ioctl, 2. read/write to "
"mmap area 3. SYNC_END ioctl. This can be repeated as often as you want (with "
"the new data being consumed by say the GPU or the scanout device)"
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1328
msgid "munmap once you don't need the buffer any more"
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1330
msgid ""
"For correctness and optimal performance, it is always required to use "
"SYNC_START and SYNC_END before and after, respectively, when accessing the "
"mapped address. Userspace cannot rely on coherent access, even when there "
"are systems where it just works without calling these ioctls."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1335
msgid "And as a CPU fallback in userspace processing pipelines."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1337
msgid ""
"Similar to the motivation for kernel cpu access it is again important that "
"the userspace code of a given importing subsystem can use the same "
"interfaces with a imported dma-buf buffer object as with a native buffer "
"object. This is especially important for drm where the userspace part of "
"contemporary OpenGL, X, and other drivers is huge, and reworking them to use "
"a different way to mmap a buffer rather invasive."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1344
msgid ""
"The assumption in the current dma-buf interfaces is that redirecting the "
"initial mmap is all that's needed. A survey of some of the existing "
"subsystems shows that no driver seems to do any nefarious thing like syncing "
"up with outstanding asynchronous processing on the device or allocating "
"special resources at fault time. So hopefully this is good enough, since "
"adding interfaces to intercept pagefaults and allow pte shootdowns would "
"increase the complexity quite a bit."
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1352
msgid "Interface:"
msgstr ""

#: ../../../driver-api/dma-buf:119: drivers/dma-buf/dma-buf.c:1358
msgid ""
"If the importing subsystem simply provides a special-purpose mmap call to "
"set up a mapping in userspace, calling do_mmap with :c:type:`dma_buf.file "
"<dma_buf>` will equally achieve that for a dma-buf object."
msgstr ""

#: ../../../driver-api/dma-buf.rst:123
msgid "Implicit Fence Poll Support"
msgstr ""

#: ../../../driver-api/dma-buf:125: drivers/dma-buf/dma-buf.c:254
msgid ""
"To support cross-device and cross-driver synchronization of buffer access "
"implicit fences (represented internally in the kernel with :c:type:`struct "
"dma_fence <dma_fence>`) can be attached to a :c:type:`dma_buf`. The glue for "
"that and a few related things are provided in the :c:type:`dma_resv` "
"structure."
msgstr ""

#: ../../../driver-api/dma-buf:125: drivers/dma-buf/dma-buf.c:259
msgid ""
"Userspace can query the state of these implicitly tracked fences using "
"poll() and related system calls:"
msgstr ""

#: ../../../driver-api/dma-buf:125: drivers/dma-buf/dma-buf.c:262
msgid ""
"Checking for EPOLLIN, i.e. read access, can be use to query the state of the "
"most recent write or exclusive fence."
msgstr ""

#: ../../../driver-api/dma-buf:125: drivers/dma-buf/dma-buf.c:265
msgid ""
"Checking for EPOLLOUT, i.e. write access, can be used to query the state of "
"all attached fences, shared and exclusive ones."
msgstr ""

#: ../../../driver-api/dma-buf:125: drivers/dma-buf/dma-buf.c:268
msgid ""
"Note that this only signals the completion of the respective fences, i.e. "
"the DMA transfers are complete. Cache flushing and any other necessary "
"preparations before CPU access can begin still need to happen."
msgstr ""

#: ../../../driver-api/dma-buf:125: drivers/dma-buf/dma-buf.c:272
msgid ""
"As an alternative to poll(), the set of fences on DMA buffer can be exported "
"as a :c:type:`sync_file` using :c:type:`dma_buf_sync_file_export`."
msgstr ""

#: ../../../driver-api/dma-buf.rst:129
msgid "DMA-BUF statistics"
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:20
msgid ""
"``/sys/kernel/debug/dma_buf/bufinfo`` provides an overview of every DMA-BUF "
"in the system. However, since debugfs is not safe to be mounted in "
"production, procfs and sysfs can be used to gather DMA-BUF statistics on "
"production systems."
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:25
msgid ""
"The ``/proc/<pid>/fdinfo/<fd>`` files in procfs can be used to gather "
"information about DMA-BUF fds. Detailed documentation about the interface is "
"present in Documentation/filesystems/proc.rst."
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:29
msgid ""
"Unfortunately, the existing procfs interfaces can only provide information "
"about the DMA-BUFs for which processes hold fds or have the buffers mmapped "
"into their address space. This necessitated the creation of the DMA-BUF "
"sysfs statistics interface to provide per-buffer information on production "
"systems."
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:34
msgid ""
"The interface at ``/sys/kernel/dmabuf/buffers`` exposes information about "
"every DMA-BUF when ``CONFIG_DMABUF_SYSFS_STATS`` is enabled."
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:37
msgid "The following stats are exposed by the interface:"
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:39
msgid "``/sys/kernel/dmabuf/buffers/<inode_number>/exporter_name``"
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:40
msgid "``/sys/kernel/dmabuf/buffers/<inode_number>/size``"
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:42
msgid ""
"The information in the interface can also be used to derive per-exporter "
"statistics. The data from the interface can be gathered on error conditions "
"or other important events to provide a snapshot of DMA-BUF usage. It can "
"also be collected periodically by telemetry to monitor various metrics."
msgstr ""

#: ../../../driver-api/dma-buf:130: drivers/dma-buf/dma-buf-sysfs-stats.c:47
msgid ""
"Detailed documentation about the interface is present in Documentation/ABI/"
"testing/sysfs-kernel-dmabuf-buffers."
msgstr ""

#: ../../../driver-api/dma-buf.rst:134
msgid "DMA Buffer ioctls"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:26
msgid "Synchronize with CPU access."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:30
#: include/uapi/linux/dma-buf.h:93 include/uapi/linux/dma-buf.h:145
#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:35
#: include/linux/dma-buf.h:286 include/linux/dma-buf.h:450
#: include/linux/dma-buf.h:485 include/linux/dma-buf.h:515
#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:143
#: include/linux/dma-resv.h:186 ../../../driver-api/dma-buf:195:
#: include/linux/dma-fence.h:36 include/linux/dma-fence.h:116
#: include/linux/dma-fence.h:129 ../../../driver-api/dma-buf:204:
#: include/linux/dma-fence-array.h:23 include/linux/dma-fence-array.h:33
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:22
#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:18
#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:28
#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:23
#: include/uapi/linux/sync_file.h:43 include/uapi/linux/sync_file.h:59
#: include/uapi/linux/sync_file.h:84
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:36
#: include/uapi/linux/dma-buf.h:100 include/uapi/linux/dma-buf.h:152
#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:52
#: include/linux/dma-buf.h:316 include/linux/dma-buf.h:457
#: include/linux/dma-buf.h:497 include/linux/dma-buf.h:527
#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:150
#: include/linux/dma-resv.h:199 ../../../driver-api/dma-buf:195:
#: include/linux/dma-fence.h:53 include/linux/dma-fence.h:123
#: include/linux/dma-fence.h:141 ../../../driver-api/dma-buf:204:
#: include/linux/dma-fence-array.h:30 include/linux/dma-fence-array.h:45
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:36
#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:26
#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:42
#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:33
#: include/uapi/linux/sync_file.h:53 include/uapi/linux/sync_file.h:70
#: include/uapi/linux/sync_file.h:91
msgid "**Members**"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:56
#: include/uapi/linux/dma-buf.h:120 include/uapi/linux/dma-buf.h:152
#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:516
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:42
#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:28
#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:23
#: include/uapi/linux/sync_file.h:43 include/uapi/linux/sync_file.h:58
msgid "``flags``"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:57
msgid "Set of access flags"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:59
msgid "DMA_BUF_SYNC_START:"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:60
msgid "Indicates the start of a map access session."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:62
msgid "DMA_BUF_SYNC_END:"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:63
msgid "Indicates the end of a map access session."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:65
msgid "DMA_BUF_SYNC_READ:"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:66
msgid ""
"Indicates that the mapped DMA buffer will be read by the client via the CPU "
"map."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:69
msgid "DMA_BUF_SYNC_WRITE:"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:70
msgid ""
"Indicates that the mapped DMA buffer will be written by the client via the "
"CPU map."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:73
msgid "DMA_BUF_SYNC_RW:"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:74
msgid "An alias for DMA_BUF_SYNC_READ | DMA_BUF_SYNC_WRITE."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:77
#: include/uapi/linux/dma-buf.h:140 include/uapi/linux/dma-buf.h:170
#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:675
#: drivers/dma-buf/dma-buf.c:767 drivers/dma-buf/dma-buf.c:790
#: drivers/dma-buf/dma-buf.c:816 drivers/dma-buf/dma-buf.c:933
#: drivers/dma-buf/dma-buf.c:995 drivers/dma-buf/dma-buf.c:1010
#: drivers/dma-buf/dma-buf.c:1034 drivers/dma-buf/dma-buf.c:1064
#: drivers/dma-buf/dma-buf.c:1088 drivers/dma-buf/dma-buf.c:1182
#: drivers/dma-buf/dma-buf.c:1211 drivers/dma-buf/dma-buf.c:1240
#: drivers/dma-buf/dma-buf.c:1262 drivers/dma-buf/dma-buf.c:1390
#: drivers/dma-buf/dma-buf.c:1433 drivers/dma-buf/dma-buf.c:1461
#: drivers/dma-buf/dma-buf.c:1501 drivers/dma-buf/dma-buf.c:1554
#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:438
#: include/linux/dma-buf.h:479 include/linux/dma-buf.h:490
#: include/linux/dma-buf.h:522 include/linux/dma-buf.h:537
#: include/linux/dma-buf.h:548 include/linux/dma-buf.h:562
#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:172
#: drivers/dma-buf/dma-resv.c:259 drivers/dma-buf/dma-resv.c:282
#: drivers/dma-buf/dma-resv.c:336 drivers/dma-buf/dma-resv.c:412
#: drivers/dma-buf/dma-resv.c:437 drivers/dma-buf/dma-resv.c:466
#: drivers/dma-buf/dma-resv.c:490 drivers/dma-buf/dma-resv.c:519
#: drivers/dma-buf/dma-resv.c:566 drivers/dma-buf/dma-resv.c:618
#: drivers/dma-buf/dma-resv.c:672 drivers/dma-buf/dma-resv.c:708
#: drivers/dma-buf/dma-resv.c:731 drivers/dma-buf/dma-resv.c:758
#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:97
#: include/linux/dma-resv.h:123 include/linux/dma-resv.h:178
#: include/linux/dma-resv.h:219 include/linux/dma-resv.h:243
#: include/linux/dma-resv.h:255 include/linux/dma-resv.h:267
#: include/linux/dma-resv.h:279 include/linux/dma-resv.h:300
#: include/linux/dma-resv.h:325 include/linux/dma-resv.h:353
#: include/linux/dma-resv.h:380 include/linux/dma-resv.h:398
#: include/linux/dma-resv.h:412 include/linux/dma-resv.h:431
#: include/linux/dma-resv.h:442 include/linux/dma-resv.h:459
#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:3
#: drivers/dma-buf/dma-fence.c:155 drivers/dma-buf/dma-fence.c:183
#: drivers/dma-buf/dma-fence.c:323 drivers/dma-buf/dma-fence.c:354
#: drivers/dma-buf/dma-fence.c:400 drivers/dma-buf/dma-fence.c:430
#: drivers/dma-buf/dma-fence.c:452 drivers/dma-buf/dma-fence.c:489
#: drivers/dma-buf/dma-fence.c:536 drivers/dma-buf/dma-fence.c:587
#: drivers/dma-buf/dma-fence.c:624 drivers/dma-buf/dma-fence.c:645
#: drivers/dma-buf/dma-fence.c:694 drivers/dma-buf/dma-fence.c:720
#: drivers/dma-buf/dma-fence.c:772 drivers/dma-buf/dma-fence.c:854
#: drivers/dma-buf/dma-fence.c:979 drivers/dma-buf/dma-fence.c:998
#: drivers/dma-buf/dma-fence.c:1047 drivers/dma-buf/dma-fence.c:1070
#: drivers/dma-buf/dma-fence.c:1090 drivers/dma-buf/dma-fence.c:1122
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:49
#: include/linux/dma-fence.h:118 include/linux/dma-fence.h:280
#: include/linux/dma-fence.h:294 include/linux/dma-fence.h:308
#: include/linux/dma-fence.h:409 include/linux/dma-fence.h:436
#: include/linux/dma-fence.h:468 include/linux/dma-fence.h:488
#: include/linux/dma-fence.h:505 include/linux/dma-fence.h:520
#: include/linux/dma-fence.h:545 include/linux/dma-fence.h:570
#: include/linux/dma-fence.h:595 include/linux/dma-fence.h:622
#: include/linux/dma-fence.h:658 include/linux/dma-fence.h:669
#: include/linux/dma-fence.h:680 ../../../driver-api/dma-buf:201:
#: drivers/dma-buf/dma-fence-array.c:176 drivers/dma-buf/dma-fence-array.c:195
#: drivers/dma-buf/dma-fence-array.c:241 drivers/dma-buf/dma-fence-array.c:275
#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:55
#: include/linux/dma-fence-array.h:73 ../../../driver-api/dma-buf:210:
#: drivers/dma-buf/dma-fence-chain.c:35 drivers/dma-buf/dma-fence-chain.c:84
#: drivers/dma-buf/dma-fence-chain.c:237 ../../../driver-api/dma-buf:213:
#: include/linux/dma-fence-chain.h:57 include/linux/dma-fence-chain.h:73
#: include/linux/dma-fence-chain.h:87 include/linux/dma-fence-chain.h:100
#: include/linux/dma-fence-chain.h:115 ../../../driver-api/dma-buf:219:
#: include/linux/dma-fence-unwrap.h:3 include/linux/dma-fence-unwrap.h:32
#: include/linux/dma-fence-unwrap.h:43 ../../../driver-api/dma-buf:225:
#: drivers/dma-buf/sync_file.c:60 drivers/dma-buf/sync_file.c:100
#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:34
#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:28
#: include/uapi/linux/sync_file.h:66 include/uapi/linux/sync_file.h:86
msgid "**Description**"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:27
msgid ""
"When a DMA buffer is accessed from the CPU via mmap, it is not always "
"possible to guarantee coherency between the CPU-visible map and underlying "
"memory.  To manage coherency, DMA_BUF_IOCTL_SYNC must be used to bracket any "
"CPU access to give the kernel the chance to shuffle memory around if needed."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:33
msgid ""
"Prior to accessing the map, the client must call DMA_BUF_IOCTL_SYNC with "
"DMA_BUF_SYNC_START and the appropriate read/write flags.  Once the access is "
"complete, the client should call DMA_BUF_IOCTL_SYNC with DMA_BUF_SYNC_END "
"and the same read/write flags."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:38
msgid ""
"The synchronization provided via DMA_BUF_IOCTL_SYNC only provides cache "
"coherency.  It does not prevent other processes or devices from accessing "
"the memory at the same time.  If synchronization with a GPU or other device "
"driver is required, it is the client's responsibility to wait for buffer to "
"be ready for reading or writing before calling this ioctl with "
"DMA_BUF_SYNC_START.  Likewise, the client must ensure that follow-up work is "
"not submitted to GPU or other device driver until after this ioctl has been "
"called with DMA_BUF_SYNC_END?"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:47
msgid ""
"If the driver or API with which the client is interacting uses implicit "
"synchronization, waiting for prior work to complete can be done via poll() "
"on the DMA buffer file descriptor.  If the driver or API requires explicit "
"synchronization, the client may have to wait on a sync_file or other "
"synchronization primitive outside the scope of the DMA buffer API."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:89
msgid "Get a sync_file from a dma-buf"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:121
#: include/uapi/linux/dma-buf.h:153
msgid "Read/write flags"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:123
#: include/uapi/linux/dma-buf.h:155
msgid "Must be DMA_BUF_SYNC_READ, DMA_BUF_SYNC_WRITE, or both."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:125
msgid ""
"If DMA_BUF_SYNC_READ is set and DMA_BUF_SYNC_WRITE is not set, the returned "
"sync file waits on any writers of the dma-buf to complete.  Waiting on the "
"returned sync file is equivalent to poll() with POLLIN."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:130
msgid ""
"If DMA_BUF_SYNC_WRITE is set, the returned sync file waits on any users of "
"the dma-buf (read or write) to complete.  Waiting on the returned sync file "
"is equivalent to poll() with POLLOUT. If both DMA_BUF_SYNC_WRITE and "
"DMA_BUF_SYNC_READ are set, this is equivalent to just DMA_BUF_SYNC_WRITE."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:136
#: include/uapi/linux/dma-buf.h:166
msgid "``fd``"
msgstr "``fd``"

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:137
msgid "Returned sync file descriptor"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:90
msgid ""
"Userspace can perform a DMA_BUF_IOCTL_EXPORT_SYNC_FILE to retrieve the "
"current set of fences on a dma-buf file descriptor as a sync_file.  CPU "
"waits via poll() or other driver-specific mechanisms typically wait on "
"whatever fences are on the dma-buf at the time the wait begins.  This is "
"similar except that it takes a snapshot of the current fences on the dma-buf "
"for waiting later instead of waiting immediately.  This is useful for modern "
"graphics APIs such as Vulkan which assume an explicit synchronization model "
"but still need to inter-operate with dma-buf."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:99
msgid "The intended usage pattern is the following:"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:101
msgid ""
"Export a sync_file with flags corresponding to the expected GPU usage via "
"DMA_BUF_IOCTL_EXPORT_SYNC_FILE."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:104
msgid ""
"Submit rendering work which uses the dma-buf.  The work should wait on the "
"exported sync file before rendering and produce another sync_file when "
"complete."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:108
msgid ""
"Import the rendering-complete sync_file into the dma-buf with flags "
"corresponding to the GPU usage via DMA_BUF_IOCTL_IMPORT_SYNC_FILE."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:111
msgid ""
"Unlike doing implicit synchronization via a GPU kernel driver's exec ioctl, "
"the above is not a single atomic operation.  If userspace wants to ensure "
"ordering via these fences, it is the respnosibility of userspace to use "
"locks or other mechanisms to ensure that no other context adds fences or "
"submits work between steps 1 and 3 above."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:141
msgid "Insert a sync_file into a dma-buf"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:157
msgid ""
"If DMA_BUF_SYNC_READ is set and DMA_BUF_SYNC_WRITE is not set, this inserts "
"the sync_file as a read-only fence.  Any subsequent implicitly synchronized "
"writes to this dma-buf will wait on this fence but reads will not."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:162
msgid ""
"If DMA_BUF_SYNC_WRITE is set, this inserts the sync_file as a write fence.  "
"All subsequent implicitly synchronized access to this dma-buf will wait on "
"this fence."
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:167
msgid "Sync file descriptor"
msgstr ""

#: ../../../driver-api/dma-buf:136: include/uapi/linux/dma-buf.h:142
msgid ""
"Userspace can perform a DMA_BUF_IOCTL_IMPORT_SYNC_FILE to insert a sync_file "
"into a dma-buf for the purposes of implicit synchronization with other dma-"
"buf consumers.  This allows clients using explicitly synchronized APIs such "
"as Vulkan to inter-op with dma-buf consumers which expect implicit "
"synchronization such as OpenGL or most media drivers/video."
msgstr ""

#: ../../../driver-api/dma-buf.rst:139
msgid "DMA-BUF locking convention"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:863
msgid ""
"In order to avoid deadlock situations between dma-buf exports and importers, "
"all dma-buf API users must follow the common dma-buf locking convention."
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:866
msgid "Convention for importers"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:868
msgid ""
"Importers must hold the dma-buf reservation lock when calling these "
"functions:"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:871
msgid "dma_buf_pin()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:872
msgid "dma_buf_unpin()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:873
msgid "dma_buf_map_attachment()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:874
msgid "dma_buf_unmap_attachment()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:875
msgid "dma_buf_vmap()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:876
msgid "dma_buf_vunmap()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:878
msgid ""
"Importers must not hold the dma-buf reservation lock when calling these "
"functions:"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:881
msgid "dma_buf_attach()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:882
msgid "dma_buf_dynamic_attach()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:883
msgid "dma_buf_detach()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:884
msgid "dma_buf_export()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:885
msgid "dma_buf_fd()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:886
msgid "dma_buf_get()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:887
msgid "dma_buf_put()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:888
msgid "dma_buf_mmap()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:889
msgid "dma_buf_begin_cpu_access()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:890
msgid "dma_buf_end_cpu_access()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:891
msgid "dma_buf_map_attachment_unlocked()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:892
msgid "dma_buf_unmap_attachment_unlocked()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:893
msgid "dma_buf_vmap_unlocked()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:894
msgid "dma_buf_vunmap_unlocked()"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:896
msgid "Convention for exporters"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:898
msgid ""
"These :c:type:`dma_buf_ops` callbacks are invoked with unlocked dma-buf "
"reservation and exporter can take the lock:"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:901
msgid ":c:type:`dma_buf_ops.attach\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:902
msgid ":c:type:`dma_buf_ops.detach\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:903
msgid ":c:type:`dma_buf_ops.release\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:904
msgid ":c:type:`dma_buf_ops.begin_cpu_access\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:905
msgid ":c:type:`dma_buf_ops.end_cpu_access\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:906
msgid ":c:type:`dma_buf_ops.mmap\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:908
msgid ""
"These :c:type:`dma_buf_ops` callbacks are invoked with locked dma-buf "
"reservation and exporter can't take the lock:"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:911
msgid ":c:type:`dma_buf_ops.pin\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:912
msgid ":c:type:`dma_buf_ops.unpin\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:913
msgid ":c:type:`dma_buf_ops.map_dma_buf\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:914
msgid ":c:type:`dma_buf_ops.unmap_dma_buf\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:915
msgid ":c:type:`dma_buf_ops.vmap\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:916
msgid ":c:type:`dma_buf_ops.vunmap\\(\\) <dma_buf_ops>`"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:918
msgid ""
"Exporters must hold the dma-buf reservation lock when calling these "
"functions:"
msgstr ""

#: ../../../driver-api/dma-buf:141: drivers/dma-buf/dma-buf.c:921
msgid "dma_buf_move_notify()"
msgstr ""

#: ../../../driver-api/dma-buf.rst:145
msgid "Kernel Functions and Structures Reference"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:666
msgid ""
"Creates a new dma_buf, and associates an anon file with this buffer, so it "
"can be exported. Also connect the allocator specific data and ops to the "
"buffer. Additionally, provide a name string for exporter; useful in "
"debugging."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:670
#: drivers/dma-buf/dma-buf.c:767 drivers/dma-buf/dma-buf.c:791
#: drivers/dma-buf/dma-buf.c:817 drivers/dma-buf/dma-buf.c:931
#: drivers/dma-buf/dma-buf.c:995 drivers/dma-buf/dma-buf.c:1010
#: drivers/dma-buf/dma-buf.c:1035 drivers/dma-buf/dma-buf.c:1065
#: drivers/dma-buf/dma-buf.c:1086 drivers/dma-buf/dma-buf.c:1180
#: drivers/dma-buf/dma-buf.c:1208 drivers/dma-buf/dma-buf.c:1237
#: drivers/dma-buf/dma-buf.c:1262 drivers/dma-buf/dma-buf.c:1387
#: drivers/dma-buf/dma-buf.c:1430 drivers/dma-buf/dma-buf.c:1459
#: drivers/dma-buf/dma-buf.c:1500 drivers/dma-buf/dma-buf.c:1553
#: drivers/dma-buf/dma-buf.c:1580 drivers/dma-buf/dma-buf.c:1604
#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:538
#: include/linux/dma-buf.h:549 include/linux/dma-buf.h:563
#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:139
#: drivers/dma-buf/dma-resv.c:151 drivers/dma-buf/dma-resv.c:172
#: drivers/dma-buf/dma-resv.c:260 drivers/dma-buf/dma-resv.c:281
#: drivers/dma-buf/dma-resv.c:334 drivers/dma-buf/dma-resv.c:413
#: drivers/dma-buf/dma-resv.c:438 drivers/dma-buf/dma-resv.c:467
#: drivers/dma-buf/dma-resv.c:491 drivers/dma-buf/dma-resv.c:519
#: drivers/dma-buf/dma-resv.c:562 drivers/dma-buf/dma-resv.c:617
#: drivers/dma-buf/dma-resv.c:670 drivers/dma-buf/dma-resv.c:707
#: drivers/dma-buf/dma-resv.c:730 drivers/dma-buf/dma-resv.c:758
#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:124
#: include/linux/dma-resv.h:229 include/linux/dma-resv.h:244
#: include/linux/dma-resv.h:256 include/linux/dma-resv.h:268
#: include/linux/dma-resv.h:279 include/linux/dma-resv.h:298
#: include/linux/dma-resv.h:325 include/linux/dma-resv.h:353
#: include/linux/dma-resv.h:380 include/linux/dma-resv.h:397
#: include/linux/dma-resv.h:413 include/linux/dma-resv.h:432
#: include/linux/dma-resv.h:443 include/linux/dma-resv.h:460
#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:129
#: drivers/dma-buf/dma-fence.c:156 drivers/dma-buf/dma-fence.c:184
#: drivers/dma-buf/dma-fence.c:293 drivers/dma-buf/dma-fence.c:324
#: drivers/dma-buf/dma-fence.c:354 drivers/dma-buf/dma-fence.c:400
#: drivers/dma-buf/dma-fence.c:431 drivers/dma-buf/dma-fence.c:453
#: drivers/dma-buf/dma-fence.c:487 drivers/dma-buf/dma-fence.c:537
#: drivers/dma-buf/dma-fence.c:588 drivers/dma-buf/dma-fence.c:625
#: drivers/dma-buf/dma-fence.c:643 drivers/dma-buf/dma-fence.c:695
#: drivers/dma-buf/dma-fence.c:720 drivers/dma-buf/dma-fence.c:770
#: drivers/dma-buf/dma-fence.c:849 drivers/dma-buf/dma-fence.c:978
#: drivers/dma-buf/dma-fence.c:998 drivers/dma-buf/dma-fence.c:1044
#: drivers/dma-buf/dma-fence.c:1067 drivers/dma-buf/dma-fence.c:1091
#: drivers/dma-buf/dma-fence.c:1123 ../../../driver-api/dma-buf:195:
#: include/linux/dma-fence.h:271 include/linux/dma-fence.h:281
#: include/linux/dma-fence.h:294 include/linux/dma-fence.h:309
#: include/linux/dma-fence.h:409 include/linux/dma-fence.h:437
#: include/linux/dma-fence.h:467 include/linux/dma-fence.h:488
#: include/linux/dma-fence.h:505 include/linux/dma-fence.h:520
#: include/linux/dma-fence.h:546 include/linux/dma-fence.h:570
#: include/linux/dma-fence.h:596 include/linux/dma-fence.h:622
#: include/linux/dma-fence.h:659 include/linux/dma-fence.h:670
#: include/linux/dma-fence.h:681 ../../../driver-api/dma-buf:201:
#: drivers/dma-buf/dma-fence-array.c:177 drivers/dma-buf/dma-fence-array.c:191
#: drivers/dma-buf/dma-fence-array.c:238 drivers/dma-buf/dma-fence-array.c:275
#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:56
#: include/linux/dma-fence-array.h:72 ../../../driver-api/dma-buf:210:
#: drivers/dma-buf/dma-fence-chain.c:36 drivers/dma-buf/dma-fence-chain.c:84
#: drivers/dma-buf/dma-fence-chain.c:235 ../../../driver-api/dma-buf:213:
#: include/linux/dma-fence-chain.h:58 include/linux/dma-fence-chain.h:74
#: include/linux/dma-fence-chain.h:101 include/linux/dma-fence-chain.h:115
#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:42
#: include/linux/dma-fence-unwrap.h:62 ../../../driver-api/dma-buf:225:
#: drivers/dma-buf/sync_file.c:61 drivers/dma-buf/sync_file.c:101
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:672
msgid "``const struct dma_buf_export_info *exp_info``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:671
msgid ""
"[in]    holds all the export related information provided by the exporter. "
"see :c:type:`struct dma_buf_export_info <dma_buf_export_info>` for further "
"details."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:674
msgid ""
"Returns, on success, a newly created struct dma_buf object, which wraps the "
"supplied private data and operations for struct dma_buf_ops. On either "
"missing ops, or error in allocating struct dma_buf, will return negative "
"error."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:679
msgid ""
"For most cases the easiest way to create **exp_info** is through the "
"``DEFINE_DMA_BUF_EXPORT_INFO`` macro."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:763
msgid "returns a file descriptor for the given struct dma_buf"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:769
#: drivers/dma-buf/dma-buf.c:819 drivers/dma-buf/dma-buf.c:933
#: drivers/dma-buf/dma-buf.c:997 drivers/dma-buf/dma-buf.c:1012
#: drivers/dma-buf/dma-buf.c:1264 drivers/dma-buf/dma-buf.c:1389
#: drivers/dma-buf/dma-buf.c:1432 drivers/dma-buf/dma-buf.c:1461
#: drivers/dma-buf/dma-buf.c:1502 drivers/dma-buf/dma-buf.c:1555
#: drivers/dma-buf/dma-buf.c:1582 drivers/dma-buf/dma-buf.c:1606
#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:551
#: include/linux/dma-buf.h:565
msgid "``struct dma_buf *dmabuf``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:764
msgid "[in]    pointer to dma_buf for which fd is required."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:766
msgid "``int flags``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:765
msgid "[in]    flags to give to fd"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:766
msgid "On success, returns an associated 'fd'. Else, returns error."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:787
msgid "returns the struct dma_buf related to an fd"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:793
#: ../../../driver-api/dma-buf:225: drivers/dma-buf/sync_file.c:103
msgid "``int fd``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:788
msgid "[in]    fd associated with the struct dma_buf to be returned"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:789
msgid ""
"On success, returns the struct dma_buf associated with an fd; uses file's "
"refcounting done by fget to increase refcount. returns ERR_PTR otherwise."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:813
msgid "decreases refcount of the buffer"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:814
msgid "[in]    buffer to reduce refcount of"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:815
msgid "Uses file's refcounting done implicitly by fput()."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:817
msgid ""
"If, as a result of this call, the refcount becomes 0, the 'release' file "
"operation related to this fd is called. It calls :c:type:`dma_buf_ops."
"release <dma_buf_ops>` vfunc in turn, and frees the memory allocated for "
"dmabuf when exported."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:927
msgid "Add the device to dma_buf's attachments list"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:928
#: drivers/dma-buf/dma-buf.c:992
msgid "[in]    buffer to attach device to."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:930
#: drivers/dma-buf/dma-buf.c:994
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:929
#: drivers/dma-buf/dma-buf.c:993
msgid "[in]    device to be attached."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:931
msgid "``const struct dma_buf_attach_ops *importer_ops``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:930
msgid "[in]    importer operations for the attachment"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:932
msgid "``void *importer_priv``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:931
msgid "[in]    importer private pointer for the attachment"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:932
msgid ""
"Returns struct dma_buf_attachment pointer for this attachment. Attachments "
"must be cleaned up by calling dma_buf_detach()."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:935
msgid ""
"Optionally this calls :c:type:`dma_buf_ops.attach <dma_buf_ops>` to allow "
"device-specific attach functionality."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:939
msgid ""
"A pointer to newly created :c:type:`dma_buf_attachment` on success, or a "
"negative error code wrapped into a pointer on failure."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:942
msgid ""
"Note that this can fail if the backing storage of **dmabuf** is in a place "
"not accessible to **dev**, and cannot be moved to a more suitable place. "
"This is indicated with the error code -EBUSY."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:991
msgid "Wrapper for dma_buf_dynamic_attach"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:994
msgid ""
"Wrapper to call dma_buf_dynamic_attach() for drivers which still use a "
"static mapping."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1006
msgid "Remove the given attachment from dmabuf's attachments list"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1007
msgid "[in]    buffer to detach from."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1009
#: drivers/dma-buf/dma-buf.c:1037 drivers/dma-buf/dma-buf.c:1067
#: drivers/dma-buf/dma-buf.c:1088 drivers/dma-buf/dma-buf.c:1182
#: drivers/dma-buf/dma-buf.c:1210 drivers/dma-buf/dma-buf.c:1239
msgid "``struct dma_buf_attachment *attach``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1008
msgid "[in]    attachment to be detached; is free'd after this call."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1009
msgid "Clean up a device attachment obtained by calling dma_buf_attach()."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1011
msgid ""
"Optionally this calls :c:type:`dma_buf_ops.detach <dma_buf_ops>` for device-"
"specific detach."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1031
msgid "Lock down the DMA-buf"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1032
msgid "[in]    attachment which should be pinned"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1033
msgid ""
"Only dynamic importers (who set up **attach** with dma_buf_dynamic_attach()) "
"may call this, and only for limited use cases like scanout and not for "
"temporary pin operations. It is not permitted to allow userspace to pin "
"arbitrary amounts of buffers through this interface."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1038
msgid "Buffers must be unpinned by calling dma_buf_unpin()."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1040
msgid "**Return**"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1041
#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:97
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1061
msgid "Unpin a DMA-buf"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1062
msgid "[in]    attachment which should be unpinned"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1063
msgid ""
"This unpins a buffer pinned by dma_buf_pin() and allows the exporter to move "
"any mapping of **attach** again and inform the importer through :c:type:"
"`dma_buf_attach_ops.move_notify <dma_buf_attach_ops>`."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1082
#: drivers/dma-buf/dma-buf.c:1176
msgid ""
"Returns the scatterlist table of the attachment; mapped into _device_ "
"address space. Is a wrapper for map_dma_buf() of the dma_buf_ops."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1085
#: drivers/dma-buf/dma-buf.c:1179
msgid "[in]    attachment whose scatterlist is to be returned"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1087
#: drivers/dma-buf/dma-buf.c:1181 drivers/dma-buf/dma-buf.c:1210
#: drivers/dma-buf/dma-buf.c:1239 drivers/dma-buf/dma-buf.c:1389
#: drivers/dma-buf/dma-buf.c:1432
msgid "``enum dma_data_direction direction``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1086
#: drivers/dma-buf/dma-buf.c:1180 drivers/dma-buf/dma-buf.c:1209
#: drivers/dma-buf/dma-buf.c:1238
msgid "[in]    direction of DMA transfer"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1087
msgid ""
"Returns sg_table containing the scatterlist to be returned; returns ERR_PTR "
"on error. May return -EINTR if it is interrupted by a signal."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1090
msgid ""
"On success, the DMA addresses and lengths in the returned scatterlist are "
"PAGE_SIZE aligned."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1093
msgid ""
"A mapping must be unmapped by using dma_buf_unmap_attachment(). Note that "
"the underlying backing storage is pinned for as long as a mapping exists, "
"therefore users/importers should not hold onto a mapping for undue amounts "
"of time."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1098
msgid ""
"Important: Dynamic importers must wait for the exclusive fence of the struct "
"dma_resv attached to the DMA-BUF first."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1181
msgid "Unlocked variant of dma_buf_map_attachment()."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1204
#: drivers/dma-buf/dma-buf.c:1233
msgid ""
"unmaps and decreases usecount of the buffer;might deallocate the scatterlist "
"associated. Is a wrapper for unmap_dma_buf() of dma_buf_ops."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1207
#: drivers/dma-buf/dma-buf.c:1236
msgid "[in]    attachment to unmap buffer from"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1209
#: drivers/dma-buf/dma-buf.c:1238
msgid "``struct sg_table *sg_table``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1208
#: drivers/dma-buf/dma-buf.c:1237
msgid "[in]    scatterlist info of the buffer to unmap"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1210
msgid ""
"This unmaps a DMA mapping for **attached** obtained by "
"dma_buf_map_attachment()."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1239
msgid "Unlocked variant of dma_buf_unmap_attachment()."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1258
msgid "notify attachments that DMA-buf is moving"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1260
msgid "[in]    buffer which is moving"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1261
msgid ""
"Informs all attachments that they need to destroy and recreate all their "
"mappings."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1383
msgid ""
"Must be called before accessing a dma_buf from the cpu in the kernel "
"context. Calls begin_cpu_access to allow exporter-specific preparations. "
"Coherency is only guaranteed in the specified range for the specified access "
"direction."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1387
msgid "[in]    buffer to prepare cpu access for."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1388
#: drivers/dma-buf/dma-buf.c:1431
msgid "[in]    direction of access."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1389
msgid ""
"After the cpu access is complete the caller should call "
"dma_buf_end_cpu_access(). Only when cpu access is bracketed by both calls is "
"it guaranteed to be coherent with other DMA access."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1393
msgid ""
"This function will also wait for any DMA transactions tracked through "
"implicit synchronization in :c:type:`dma_buf.resv <dma_buf>`. For DMA "
"transactions with explicit synchronization this function will only ensure "
"cache coherency, callers must ensure synchronization with such DMA "
"transactions on their own."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1398
#: drivers/dma-buf/dma-buf.c:1434 drivers/dma-buf/dma-buf.c:1465
msgid "Can return negative error values, returns 0 on success."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1426
msgid ""
"Must be called after accessing a dma_buf from the cpu in the kernel context. "
"Calls end_cpu_access to allow exporter-specific actions. Coherency is only "
"guaranteed in the specified range for the specified access direction."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1430
msgid "[in]    buffer to complete cpu access for."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1432
msgid "This terminates CPU access started with dma_buf_begin_cpu_access()."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1455
msgid "Setup up a userspace mmap with the given vma"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1456
msgid "[in]    buffer that should back the vma"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1458
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1457
msgid "[in]    vma for the mmap"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1459
msgid "``unsigned long pgoff``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1458
msgid ""
"[in]    offset in pages where this mmap should start within the dma-buf "
"buffer."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1460
msgid ""
"This function adjusts the passed in vma so that it points at the file of the "
"dma_buf operation. It also adjusts the starting pgoff and does bounds "
"checking on the size of the vma. Then it calls the exporters mmap function "
"to set up the mapping."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1496
#: drivers/dma-buf/dma-buf.c:1549
msgid ""
"Create virtual mapping for the buffer object into kernel address space. Same "
"restrictions as for vmap and friends apply."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1498
#: drivers/dma-buf/dma-buf.c:1551
msgid "[in]    buffer to vmap"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1500
#: drivers/dma-buf/dma-buf.c:1553 drivers/dma-buf/dma-buf.c:1579
#: drivers/dma-buf/dma-buf.c:1603
msgid "``struct iosys_map *map``"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1499
#: drivers/dma-buf/dma-buf.c:1552
msgid "[out]   returns the vmap pointer"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1500
msgid ""
"This call may fail due to lack of virtual mapping address space. These calls "
"are optional in drivers. The intended use for them is for mapping objects "
"linear in kernel space for high use objects."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1504
msgid ""
"To ensure coherency users must call dma_buf_begin_cpu_access() and "
"dma_buf_end_cpu_access() around any cpu access performed through this "
"mapping."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1508
#: drivers/dma-buf/dma-buf.c:1555
msgid "Returns 0 on success, or a negative errno code otherwise."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1553
msgid "Unlocked version of dma_buf_vmap()"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1576
#: drivers/dma-buf/dma-buf.c:1600
msgid "Unmap a vmap obtained by dma_buf_vmap."
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1577
#: drivers/dma-buf/dma-buf.c:1601
msgid "[in]    buffer to vunmap"
msgstr ""

#: ../../../driver-api/dma-buf:147: drivers/dma-buf/dma-buf.c:1578
#: drivers/dma-buf/dma-buf.c:1602
msgid "[in]    vmap pointer to vunmap"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:31
msgid "operations possible on struct dma_buf"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:38
msgid "``attach``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:39
msgid ""
"This is called from dma_buf_attach() to make sure that a given :c:type:"
"`dma_buf_attachment.dev <dma_buf_attachment>` can access the provided :c:"
"type:`dma_buf`. Exporters which support buffer objects in special locations "
"like VRAM or device-specific carveout areas should check whether the buffer "
"could be move to system memory (or directly accessed by the provided "
"device), and otherwise need to fail the attach operation."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:46
msgid ""
"The exporter should also in general check whether the current allocation "
"fulfills the DMA constraints of the new device. If this is not the case, and "
"the allocation cannot be moved, it should also fail the attach operation."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:51
msgid ""
"Any exporter-private housekeeping data can be stored in the :c:type:"
"`dma_buf_attachment.priv <dma_buf_attachment>` pointer."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:54
#: include/linux/dma-buf.h:71 include/linux/dma-buf.h:110
#: include/linux/dma-buf.h:211 include/linux/dma-buf.h:229
#: include/linux/dma-buf.h:268 ../../../driver-api/dma-buf:195:
#: include/linux/dma-fence.h:201 include/linux/dma-fence.h:250
msgid "This callback is optional."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:56
#: include/linux/dma-buf.h:95 include/linux/dma-buf.h:152
#: include/linux/dma-buf.h:213 include/linux/dma-buf.h:231
#: include/linux/dma-buf.h:270
msgid "Returns:"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:58
msgid ""
"0 on success, negative error code on failure. It might return -EBUSY to "
"signal that backing storage is already allocated and incompatible with the "
"requirements of requesting device."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:66
msgid "``detach``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:67
msgid ""
"This is called by dma_buf_detach() to release a :c:type:"
"`dma_buf_attachment`. Provided so that exporters can clean up any "
"housekeeping for an :c:type:`dma_buf_attachment`."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:77
msgid "``pin``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:78
msgid ""
"This is called by dma_buf_pin() and lets the exporter know that the DMA-buf "
"can't be moved any more. Ideally, the exporter should pin the buffer so that "
"it is generally accessible by all devices."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:83
msgid ""
"This is called with the :c:type:`dmabuf.resv <dmabuf>` object locked and is "
"mutual exclusive with **cache_sgt_mapping**."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:86
msgid ""
"This is called automatically for non-dynamic importers from dma_buf_attach()."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:89
msgid ""
"Note that similar to non-dynamic exporters in their **map_dma_buf** callback "
"the driver must guarantee that the memory is available for use and cleared "
"of any old data by the time this function returns. Drivers which pipeline "
"their buffer moves internally must wait for all moves and clears to complete."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:103
msgid "``unpin``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:104
msgid ""
"This is called by dma_buf_unpin() and lets the exporter know that the DMA-"
"buf can be moved again."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:107
msgid ""
"This is called with the dmabuf->resv object locked and is mutual exclusive "
"with **cache_sgt_mapping**."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:116
msgid "``map_dma_buf``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:117
msgid ""
"This is called by dma_buf_map_attachment() and is used to map a shared :c:"
"type:`dma_buf` into device address space, and it is mandatory. It can only "
"be called if **attach** has been called successfully."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:121
msgid ""
"This call may sleep, e.g. when the backing storage first needs to be "
"allocated, or moved to a location suitable for all currently attached "
"devices."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:125
msgid ""
"Note that any specific buffer attributes required for this function should "
"get added to device_dma_parameters accessible via :c:type:`device.dma_params "
"<device>` from the :c:type:`dma_buf_attachment`. The **attach** callback "
"should also check these constraints."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:130
msgid ""
"If this is being called for the first time, the exporter can now choose to "
"scan through the list of attachments for this buffer, collate the "
"requirements of the attached devices, and choose an appropriate backing "
"storage for the buffer."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:135
msgid ""
"Based on enum dma_data_direction, it might be possible to have multiple "
"users accessing at the same time (for reading, maybe), or any other kind of "
"sharing that the exporter might wish to make available to buffer-users."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:140
msgid ""
"This is always called with the dmabuf->resv object locked when the "
"dynamic_mapping flag is true."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:143
msgid ""
"Note that for non-dynamic exporters the driver must guarantee that that the "
"memory is available for use and cleared of any old data by the time this "
"function returns.  Drivers which pipeline their buffer moves internally must "
"wait for all moves and clears to complete. Dynamic exporters do not need to "
"follow this rule: For non-dynamic importers the buffer is already pinned "
"through **pin**, which has the same requirements. Dynamic importers otoh are "
"required to obey the dma_resv fences."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:154
msgid ""
"A :c:type:`sg_table` scatter list of the backing storage of the DMA buffer, "
"already mapped into the device address space of the :c:type:`device` "
"attached with the provided :c:type:`dma_buf_attachment`. The addresses and "
"lengths in the scatter list are PAGE_SIZE aligned."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:159
msgid ""
"On failure, returns a negative error value wrapped into a pointer. May also "
"return -EINTR when a signal was received while being blocked."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:163
msgid ""
"Note that exporters should not try to cache the scatter list, or return the "
"same one for multiple calls. Caching is done either by the DMA-BUF code (for "
"non-dynamic importers) or the importer. Ownership of the scatter list is "
"transferred to the caller, and returned by **unmap_dma_buf**."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:173
msgid "``unmap_dma_buf``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:174
msgid ""
"This is called by dma_buf_unmap_attachment() and should unmap and release "
"the :c:type:`sg_table` allocated in **map_dma_buf**, and it is mandatory. "
"For static dma_buf handling this might also unpin the backing storage if "
"this is the last mapping of the DMA buffer."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:189
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:226
msgid "``release``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:190
msgid ""
"Called after the last dma_buf_put to release the :c:type:`dma_buf`, and "
"mandatory."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:197
msgid "``begin_cpu_access``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:198
msgid ""
"This is called from dma_buf_begin_cpu_access() and allows the exporter to "
"ensure that the memory is actually coherent for cpu access. The exporter "
"also needs to ensure that cpu access is coherent for the access direction. "
"The direction can be used by the exporter to optimize the cache flushing, i."
"e. access with a different direction (read instead of write) might return "
"stale or even bogus data (e.g. when the exporter needs to copy the data to "
"temporary storage)."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:207
msgid ""
"Note that this is both called through the DMA_BUF_IOCTL_SYNC IOCTL command "
"for userspace mappings established through **mmap**, and also for kernel "
"mappings established with **vmap**."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:215
msgid ""
"0 on success or a negative error code on failure. This can for example fail "
"when the backing storage can't be allocated. Can also return -ERESTARTSYS or "
"-EINTR when the call has been interrupted and needs to be restarted."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:224
msgid "``end_cpu_access``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:225
msgid ""
"This is called from dma_buf_end_cpu_access() when the importer is done "
"accessing the CPU. The exporter can use this to flush caches and undo "
"anything else done in **begin_cpu_access**."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:233
msgid ""
"0 on success or a negative error code on failure. Can return -ERESTARTSYS or "
"-EINTR when the call has been interrupted and needs to be restarted."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:241
msgid "``mmap``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:242
msgid "This callback is used by the dma_buf_mmap() function"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:244
msgid ""
"Note that the mapping needs to be incoherent, userspace is expected to "
"bracket CPU access using the DMA_BUF_IOCTL_SYNC interface."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:247
msgid ""
"Because dma-buf buffers have invariant size over their lifetime, the dma-buf "
"core checks whether a vma is too large and rejects such mappings. The "
"exporter hence does not need to duplicate this check. Drivers do not need to "
"check this themselves."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:252
msgid ""
"If an exporter needs to manually flush caches and hence needs to fake "
"coherency for mmap support, it needs to be able to zap all the ptes pointing "
"at the backing storage. Now linux mm needs a struct address_space associated "
"with the struct file stored in vma->vm_file to do that with the function "
"unmap_mapping_range. But the dma_buf framework only backs every dma_buf fd "
"with the anon_file struct file, i.e. all dma_bufs share the same file."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:260
msgid ""
"Hence exporters need to setup their own file (and address_space) association "
"by setting vma->vm_file and adjusting vma->vm_pgoff in the dma_buf mmap "
"callback. In the specific case of a gem driver the exporter could use the "
"shmem file already provided by gem (and set vm_pgoff = 0). Exporters can "
"then zap ptes by unmapping the corresponding range of the struct "
"address_space associated with their own file."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:272
msgid "0 on success or a negative error code on failure."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:32
msgid "``vmap``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:33
msgid ""
"[optional] creates a virtual mapping for the buffer into kernel address "
"space. Same restrictions as for vmap and friends apply."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:34
msgid "``vunmap``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:35
msgid "[optional] unmaps a vmap from the buffer"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:282
msgid "shared buffer object"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:295
#: include/linux/dma-buf.h:515
msgid "``size``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:296
msgid "Size of the buffer; invariant over the lifetime of the buffer."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:302
#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:25
msgid "``file``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:303
msgid ""
"File pointer used for sharing buffers across, and for refcounting. See "
"dma_buf_get() and dma_buf_put()."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:310
msgid "``attachments``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:311
msgid ""
"List of dma_buf_attachment that denotes all devices attached, protected by :"
"c:type:`dma_resv` lock **resv**."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:317
#: include/linux/dma-buf.h:514 ../../../driver-api/dma-buf:195:
#: include/linux/dma-fence.h:34
msgid "``ops``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:318
msgid "dma_buf_ops associated with this buffer object."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:321
msgid "``vmapping_counter``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:322
msgid ""
"Used internally to refcnt the vmaps returned by dma_buf_vmap(). Protected by "
"**lock**."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:329
msgid "``vmap_ptr``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:330
msgid ""
"The current vmap ptr if **vmapping_counter** > 0. Protected by **lock**."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:335
#: include/linux/dma-buf.h:512
msgid "``exp_name``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:336
msgid "Name of the exporter; useful for debugging. Must not be NULL"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:342
#: include/linux/dma-buf.h:540 ../../../driver-api/dma-buf:234:
#: include/uapi/linux/sync_file.h:20 include/uapi/linux/sync_file.h:56
msgid "``name``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:343
msgid ""
"Userspace-provided name. Default value is NULL. If not NULL, length cannot "
"be longer than DMA_BUF_NAME_LEN, including NIL char. Useful for accounting "
"and debugging. Read/Write accesses are protected by **name_lock**"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:348
msgid "See the IOCTLs DMA_BUF_SET_NAME or DMA_BUF_SET_NAME_A/B"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:353
msgid "``name_lock``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:354
msgid "Spinlock to protect name access for read access."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:357
#: include/linux/dma-buf.h:513
msgid "``owner``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:358
msgid ""
"Pointer to exporter module; used for refcounting when exporter is a kernel "
"module."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:364
msgid "``list_node``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:365
msgid "node for dma_buf accounting and debugging."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:367
#: include/linux/dma-buf.h:486 include/linux/dma-buf.h:518
msgid "``priv``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:368
msgid "exporter specific private data for this buffer object."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:371
#: include/linux/dma-buf.h:517
msgid "``resv``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:372
msgid "Reservation object linked to this dma-buf."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:374
msgid "IMPLICIT SYNCHRONIZATION RULES:"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:376
msgid ""
"Drivers which support implicit synchronization of buffer access as e.g. "
"exposed in `Implicit Fence Poll Support`_ must follow the below rules."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:380
msgid ""
"Drivers must add a read fence through dma_resv_add_fence() with the "
"DMA_RESV_USAGE_READ flag for anything the userspace API considers a read "
"access. This highly depends upon the API and window system."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:384
msgid ""
"Similarly drivers must add a write fence through dma_resv_add_fence() with "
"the DMA_RESV_USAGE_WRITE flag for anything the userspace API considers write "
"access."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:388
msgid ""
"Drivers may just always add a write fence, since that only causes "
"unnecessary synchronization, but no correctness issues."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:391
msgid ""
"Some drivers only expose a synchronous userspace API with no pipelining "
"across drivers. These do not set any fences for their access. An example "
"here is v4l."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:395
msgid ""
"Driver should use dma_resv_usage_rw() when retrieving fences as dependency "
"for implicit synchronization."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:398
msgid "DYNAMIC IMPORTER RULES:"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:400
msgid ""
"Dynamic importers, see dma_buf_attachment_is_dynamic(), have additional "
"constraints on how they set up fences:"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:403
msgid ""
"Dynamic importers must obey the write fences and wait for them to signal "
"before allowing access to the buffer's underlying storage through the device."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:407
msgid ""
"Dynamic importers should set fences for any access that they can't disable "
"immediately from their :c:type:`dma_buf_attach_ops.move_notify "
"<dma_buf_attach_ops>` callback."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:411
msgid "IMPORTANT:"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:413
msgid ""
"All drivers and memory management related functions must obey the struct "
"dma_resv rules, specifically the rules for updating and obeying fences. See "
"enum dma_resv_usage for further descriptions."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:420
msgid "``poll``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:421
#: include/linux/dma-buf.h:424 include/linux/dma-buf.h:425
msgid "for userspace poll support"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:423
msgid "``cb_in``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:424
msgid "``cb_out``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:433
msgid "``sysfs_entry``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:434
msgid ""
"For exposing information about this buffer in sysfs. See also `DMA-BUF "
"statistics`_ for the uapi this enables."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:283
msgid ""
"This represents a shared buffer, created by calling dma_buf_export(). The "
"userspace representation is a normal file descriptor, which can be created "
"by calling dma_buf_fd()."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:287
msgid ""
"Shared dma buffers are reference counted using dma_buf_put() and "
"get_dma_buf()."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:290
msgid ""
"Device DMA access is handled by the separate :c:type:`struct "
"dma_buf_attachment <dma_buf_attachment>`."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:446
msgid "importer operations for an attachment"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:452
msgid "``allow_peer2peer``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:453
msgid ""
"If this is set to true the importer must be able to handle peer resources "
"without struct pages."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:460
msgid "``move_notify``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:461
msgid "[optional] notification that the DMA-buf is moving"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:463
msgid ""
"If this callback is provided the framework can avoid pinning the backing "
"store while mappings exists."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:466
msgid ""
"This callback is called with the lock of the reservation object associated "
"with the dma_buf held and the mapping function must be called with this lock "
"held as well. This makes sure that no mapping is created concurrently with "
"an ongoing move operation."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:471
msgid ""
"Mappings stay valid and are not directly affected by this callback. But the "
"DMA-buf can now be in a different physical location, so all mappings should "
"be destroyed and re-created as soon as possible."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:475
msgid ""
"New mappings can be created after this callback returns, and will point to "
"the new location of the DMA-buf."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:447
msgid "Attachment operations implemented by the importer."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:481
msgid "holds device-buffer attachment data"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:482
msgid "``dmabuf``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:483
msgid "buffer for this attachment."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:483
msgid "``dev``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:484
msgid "device attached to the buffer."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:484
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:113
msgid "``node``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:485
msgid "list of dma_buf_attachment, protected by dma_resv lock of the dmabuf."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:485
msgid "``peer2peer``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:486
msgid "true if the importer can handle peer resources without pages."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:487
msgid "``importer_ops``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:488
msgid ""
"importer operations for this attachment, if provided dma_buf_map/"
"unmap_attachment() must be called with the dma_resv lock held."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:489
msgid "``importer_priv``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:490
msgid "importer specific attachment data."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:487
msgid "exporter specific attachment data."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:490
msgid ""
"This structure holds the attachment information between the dma_buf buffer "
"and its user device(s). The list contains one attachment struct per device "
"attached to the buffer."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:494
msgid ""
"An attachment is created by calling dma_buf_attach(), and released again by "
"calling dma_buf_detach(). The DMA mapping itself needed to initiate a "
"transfer is created by dma_buf_map_attachment() and freed again by calling "
"dma_buf_unmap_attachment()."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:511
msgid "holds information needed to export a dma_buf"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:513
msgid "name of the exporter - useful for debugging."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:514
msgid "pointer to exporter module - used for refcounting kernel module"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:515
msgid "Attach allocator-defined dma buf ops to the new buffer"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:516
msgid "Size of the buffer - invariant over the lifetime of the buffer"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:517
msgid "mode flags for the file"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:518
msgid "reservation-object, NULL to allocate default one"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:519
msgid "Attach private data of allocator to this buffer"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:519
msgid ""
"This structure holds the information required to export the buffer. Used "
"with dma_buf_export() only."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:536
msgid "``DEFINE_DMA_BUF_EXPORT_INFO (name)``"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:534
msgid "helper macro for exporters"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:535
msgid "export-info name"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:536
msgid ""
"DEFINE_DMA_BUF_EXPORT_INFO macro defines the :c:type:`struct "
"dma_buf_export_info <dma_buf_export_info>`, zeroes it out and pre-populates "
"exp_name in it."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:545
msgid "convenience wrapper for get_file."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:546
msgid "[in]    pointer to dma_buf"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:547
msgid ""
"Increments the reference count on the dma-buf, needed in case of drivers "
"that either need to create additional references to the dmabuf on the kernel "
"side.  For example, an exporter that needs to keep a dmabuf ptr so that "
"subsequent exports don't create a new dmabuf."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:559
msgid "check if a DMA-buf uses dynamic mappings."
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:560
msgid "the DMA-buf to check"
msgstr ""

#: ../../../driver-api/dma-buf:150: include/linux/dma-buf.h:561
msgid ""
"Returns true if a DMA-buf exporter wants to be called with the dma_resv "
"locked for the map/unmap callbacks, false if it doesn't wants to be called "
"with the lock held."
msgstr ""

#: ../../../driver-api/dma-buf.rst:154
msgid "Reservation Objects"
msgstr ""

#: ../../../driver-api/dma-buf:156: drivers/dma-buf/dma-resv.c:45
msgid ""
"The reservation object provides a mechanism to manage a container of "
"dma_fence object associated with a resource. A reservation object can have "
"any number of fences attaches to it. Each fence carries an usage parameter "
"determining how the operation represented by the fence is using the "
"resource. The RCU mechanism is used to protect read access to fences from "
"locked write-side updates."
msgstr ""

#: ../../../driver-api/dma-buf:156: drivers/dma-buf/dma-resv.c:52
msgid "See struct dma_resv for more details."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:135
msgid "initialize a reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:141
#: drivers/dma-buf/dma-resv.c:153 drivers/dma-buf/dma-resv.c:174
#: drivers/dma-buf/dma-resv.c:262 drivers/dma-buf/dma-resv.c:283
#: drivers/dma-buf/dma-resv.c:336 drivers/dma-buf/dma-resv.c:564
#: drivers/dma-buf/dma-resv.c:619 drivers/dma-buf/dma-resv.c:672
#: drivers/dma-buf/dma-resv.c:709 drivers/dma-buf/dma-resv.c:732
#: drivers/dma-buf/dma-resv.c:760 ../../../driver-api/dma-buf:162:
#: include/linux/dma-resv.h:228 include/linux/dma-resv.h:327
#: include/linux/dma-resv.h:355 include/linux/dma-resv.h:382
#: include/linux/dma-resv.h:399 include/linux/dma-resv.h:415
#: include/linux/dma-resv.h:434 include/linux/dma-resv.h:445
#: include/linux/dma-resv.h:462
msgid "``struct dma_resv *obj``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:136
#: drivers/dma-buf/dma-resv.c:148 drivers/dma-buf/dma-resv.c:278
#: drivers/dma-buf/dma-resv.c:331 drivers/dma-buf/dma-resv.c:560
#: drivers/dma-buf/dma-resv.c:614 drivers/dma-buf/dma-resv.c:667
#: drivers/dma-buf/dma-resv.c:704 drivers/dma-buf/dma-resv.c:728
#: drivers/dma-buf/dma-resv.c:755 ../../../driver-api/dma-buf:162:
#: include/linux/dma-resv.h:322 include/linux/dma-resv.h:350
#: include/linux/dma-resv.h:377 include/linux/dma-resv.h:395
#: include/linux/dma-resv.h:410 include/linux/dma-resv.h:429
#: include/linux/dma-resv.h:440 include/linux/dma-resv.h:457
msgid "the reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:147
msgid "destroys a reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:168
msgid "Reserve space to add fences to a dma_resv object."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:169
msgid "reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:171
msgid "``unsigned int num_fences``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:170
msgid "number of fences we want to add"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:171
msgid ""
"Should be called before dma_resv_add_fence().  Must be called with **obj** "
"locked through dma_resv_lock()."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:174
msgid ""
"Note that the preallocated slots need to be re-reserved if **obj** is "
"unlocked at any time before calling dma_resv_add_fence(). This is validated "
"when CONFIG_DEBUG_MUTEXES is enabled."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:178
msgid "RETURNS Zero for success, or -errno"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:256
msgid "reset fences for debugging"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:257
msgid "the dma_resv object to reset"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:258
msgid ""
"Reset the number of pre-reserved fence slots to test that drivers do correct "
"slot allocation using dma_resv_reserve_fences(). See also :c:type:"
"`dma_resv_list.max_fences <dma_resv_list>`."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:277
msgid "Add a fence to the dma_resv obj"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:280
#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:356
#: drivers/dma-buf/dma-fence.c:402 drivers/dma-buf/dma-fence.c:433
#: drivers/dma-buf/dma-fence.c:455 drivers/dma-buf/dma-fence.c:489
#: drivers/dma-buf/dma-fence.c:590 drivers/dma-buf/dma-fence.c:627
#: drivers/dma-buf/dma-fence.c:645 drivers/dma-buf/dma-fence.c:697
#: drivers/dma-buf/dma-fence.c:722 drivers/dma-buf/dma-fence.c:772
#: drivers/dma-buf/dma-fence.c:980 drivers/dma-buf/dma-fence.c:1000
#: drivers/dma-buf/dma-fence.c:1046 drivers/dma-buf/dma-fence.c:1069
#: drivers/dma-buf/dma-fence.c:1093 drivers/dma-buf/dma-fence.c:1125
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:273
#: include/linux/dma-fence.h:283 include/linux/dma-fence.h:296
#: include/linux/dma-fence.h:411 include/linux/dma-fence.h:439
#: include/linux/dma-fence.h:469 include/linux/dma-fence.h:548
#: include/linux/dma-fence.h:572 include/linux/dma-fence.h:598
#: include/linux/dma-fence.h:624 include/linux/dma-fence.h:661
#: include/linux/dma-fence.h:672 include/linux/dma-fence.h:683
#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:277
#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:58
#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:38
#: drivers/dma-buf/dma-fence-chain.c:235 ../../../driver-api/dma-buf:213:
#: include/linux/dma-fence-chain.h:60 include/linux/dma-fence-chain.h:76
#: ../../../driver-api/dma-buf:225: drivers/dma-buf/sync_file.c:63
msgid "``struct dma_fence *fence``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:279
msgid "the fence to add"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:281
#: drivers/dma-buf/dma-resv.c:335 drivers/dma-buf/dma-resv.c:562
#: drivers/dma-buf/dma-resv.c:616 drivers/dma-buf/dma-resv.c:669
#: drivers/dma-buf/dma-resv.c:706 drivers/dma-buf/dma-resv.c:730
#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:229
msgid "``enum dma_resv_usage usage``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:280
msgid "how the fence is used, see enum dma_resv_usage"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:281
msgid ""
"Add a fence to a slot, **obj** must be locked with dma_resv_lock(), and "
"dma_resv_reserve_fences() has been called."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:284
msgid ""
"See also :c:type:`dma_resv.fence <dma_resv>` for a discussion of the "
"semantics."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:330
msgid "replace fences in the dma_resv obj"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:333
msgid "``uint64_t context``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:332
msgid "the context of the fences to replace"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:334
msgid "``struct dma_fence *replacement``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:333
msgid "the new fence to use instead"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:334
msgid "how the new fence is used, see enum dma_resv_usage"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:335
msgid ""
"Replace fences with a specified context with a new fence. Only valid if the "
"operation represented by the original fence has no longer access to the "
"resources represented by the dma_resv object when the new fence completes."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:339
msgid ""
"And example for using this is replacing a preemption fence with a page table "
"update fence which makes the resource inaccessible."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:409
msgid "first fence in an unlocked dma_resv obj."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:415
#: drivers/dma-buf/dma-resv.c:440 drivers/dma-buf/dma-resv.c:469
#: drivers/dma-buf/dma-resv.c:493 ../../../driver-api/dma-buf:162:
#: include/linux/dma-resv.h:231 include/linux/dma-resv.h:246
#: include/linux/dma-resv.h:258 include/linux/dma-resv.h:270
msgid "``struct dma_resv_iter *cursor``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:410
#: drivers/dma-buf/dma-resv.c:435 ../../../driver-api/dma-buf:162:
#: include/linux/dma-resv.h:265
msgid "the cursor with the current position"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:411
#: drivers/dma-buf/dma-resv.c:465
msgid "Subsequent fences are iterated with dma_resv_iter_next_unlocked()."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:413
msgid ""
"Beware that the iterator can be restarted.  Code which accumulates "
"statistics or similar needs to check for this with "
"dma_resv_iter_is_restarted(). For this reason prefer the locked "
"dma_resv_iter_first() whenever possible."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:417
msgid "Returns the first fence from an unlocked dma_resv obj."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:434
msgid "next fence in an unlocked dma_resv obj."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:436
msgid ""
"Beware that the iterator can be restarted.  Code which accumulates "
"statistics or similar needs to check for this with "
"dma_resv_iter_is_restarted(). For this reason prefer the locked "
"dma_resv_iter_next() whenever possible."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:440
msgid "Returns the next fence from an unlocked dma_resv obj."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:463
msgid "first fence from a locked dma_resv object"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:464
#: drivers/dma-buf/dma-resv.c:488
msgid "cursor to record the current position"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:467
msgid ""
"Return the first fence in the dma_resv object while holding the :c:type:"
"`dma_resv.lock <dma_resv>`."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:487
msgid "next fence from a locked dma_resv object"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:489
msgid ""
"Return the next fences from the dma_resv object while holding the :c:type:"
"`dma_resv.lock <dma_resv>`."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:515
msgid "Copy all fences from src to dst."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:521
msgid "``struct dma_resv *dst``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:516
msgid "the destination reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:518
msgid "``struct dma_resv *src``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:517
msgid "the source reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:518
msgid "Copy all fences from src to dst. dst-lock must be held."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:558
msgid "Get an object's fences fences without update side lock held"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:561
#: drivers/dma-buf/dma-resv.c:615 drivers/dma-buf/dma-resv.c:668
#: drivers/dma-buf/dma-resv.c:705 drivers/dma-buf/dma-resv.c:729
#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:228
msgid "controls which fences to include, see enum dma_resv_usage."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:563
msgid "``unsigned int *num_fences``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:562
msgid "the number of fences returned"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:564
msgid "``struct dma_fence ***fences``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:563
msgid ""
"the array of fence ptrs returned (array is krealloc'd to the required size, "
"and must be freed by caller)"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:565
msgid ""
"Retrieve all fences from the reservation object. Returns either zero or -"
"ENOMEM."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:613
msgid "Get a single fence for all the fences"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:617
msgid "``struct dma_fence **fence``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:616
msgid "the resulting fence"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:617
msgid ""
"Get a single fence representing all the fences inside the resv object. "
"Returns either 0 for success or -ENOMEM."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:620
msgid ""
"Warning: This can't be used like this when adding the fence back to the resv "
"object since that can lead to stack corruption when finalizing the "
"dma_fence_array."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:624
msgid "Returns 0 on success and negative error values on failure."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:666
msgid "Wait on reservation's objects fences"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:670
#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:487
#: drivers/dma-buf/dma-fence.c:770 drivers/dma-buf/dma-fence.c:850
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:621
msgid "``bool intr``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:669
msgid "if true, do interruptible wait"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:671
msgid "``unsigned long timeout``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:670
msgid "timeout value in jiffies or zero to return immediately"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:671
msgid ""
"Callers are not required to hold specific locks, but maybe hold "
"dma_resv_lock() already RETURNS Returns -ERESTARTSYS if interrupted, 0 if "
"the wait timed out, or greater than zero on success."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:703
msgid "Set a deadline on reservation's objects fences"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:707
#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:977
msgid "``ktime_t deadline``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:706
msgid "the requested deadline (MONOTONIC)"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:707
msgid ""
"May be called without holding the dma_resv lock.  Sets **deadline** on all "
"fences filtered by **usage**."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:726
msgid "Test if a reservation object's fences have been signaled."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:730
msgid ""
"Callers are not required to hold specific locks, but maybe hold "
"dma_resv_lock() already."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:733
msgid "RETURNS"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:735
msgid "True if all fences signaled, else false."
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:754
msgid "Dump description of the resv object into seq_file"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:757
#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:997
msgid "``struct seq_file *seq``"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:756
msgid "the seq_file to dump the description into"
msgstr ""

#: ../../../driver-api/dma-buf:159: drivers/dma-buf/dma-resv.c:757
msgid ""
"Dump a textual description of the fences inside an dma_resv object into the "
"seq_file."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:53
msgid "how the fences from a dma_resv obj are used"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:57
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:59
msgid "``DMA_RESV_USAGE_KERNEL``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:60
msgid "For in kernel memory management only."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:62
msgid ""
"This should only be used for things like copying or clearing memory with a "
"DMA hardware engine for the purpose of kernel memory management."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:66
msgid ""
"Drivers *always* must wait for those fences before accessing the resource "
"protected by the dma_resv object. The only exception for that is when the "
"resource is known to be locked down in place by pinning it previously."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:71
msgid "``DMA_RESV_USAGE_WRITE``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:72
msgid "Implicit write synchronization."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:74
msgid ""
"This should only be used for userspace command submissions which add an "
"implicit write dependency."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:77
msgid "``DMA_RESV_USAGE_READ``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:78
msgid "Implicit read synchronization."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:80
msgid ""
"This should only be used for userspace command submissions which add an "
"implicit read dependency."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:83
msgid "``DMA_RESV_USAGE_BOOKKEEP``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:84
msgid "No implicit sync."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:86
msgid ""
"This should be used by submissions which don't want to participate in any "
"implicit synchronization."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:89
msgid ""
"The most common cases are preemption fences, page table updates, TLB flushes "
"as well as explicitly synced user submissions."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:92
msgid ""
"Explicitly synced user submissions can be promoted to DMA_RESV_USAGE_READ or "
"DMA_RESV_USAGE_WRITE as needed using dma_buf_import_sync_file() when "
"implicit synchronization should become necessary after initial adding of the "
"fence."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:54
msgid ""
"This enum describes the different use cases for a dma_resv object and "
"controls which fences are returned when queried."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:57
msgid ""
"An important fact is that there is the order KERNEL<WRITE<READ<BOOKKEEP and "
"when the dma_resv object is asked for fences for one use case the fences for "
"the lower use case are returned as well."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:61
msgid ""
"For example when asking for WRITE fences then the KERNEL fences are returned "
"as well. Similar when asked for READ fences then both WRITE and KERNEL "
"fences are returned as well."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:65
msgid ""
"Already used fences can be promoted in the sense that a fence with "
"DMA_RESV_USAGE_BOOKKEEP could become DMA_RESV_USAGE_READ by adding it again "
"with this usage. But fences can never be degraded in the sense that a fence "
"with DMA_RESV_USAGE_WRITE could become DMA_RESV_USAGE_READ."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:120
msgid "helper for implicit sync"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:126
msgid "``bool write``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:121
msgid "true if we create a new implicit sync write"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:122
msgid ""
"This returns the implicit synchronization usage for write or read accesses, "
"see enum dma_resv_usage and :c:type:`dma_buf.resv <dma_buf>`."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:139
msgid "a reservation object manages fences for a buffer"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:157
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:37
#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:31
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:23
msgid "``lock``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:158
msgid ""
"Update side lock. Don't use directly, instead use the wrapper functions like "
"dma_resv_lock() and dma_resv_unlock()."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:161
msgid ""
"Drivers which use the reservation object to manage memory dynamically also "
"use this lock to protect buffer object state like placement, allocation "
"policies or throughout command submission."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:169
#: include/linux/dma-resv.h:209 ../../../driver-api/dma-buf:204:
#: include/linux/dma-fence-array.h:34
msgid "``fences``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:170
msgid "Array of fences which where added to the dma_resv object"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:172
msgid ""
"A new fence is added by calling dma_resv_add_fence(). Since this often needs "
"to be done past the point of no return in command submission it cannot fail, "
"and therefore sufficient slots need to be reserved by calling "
"dma_resv_reserve_fences()."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:140
msgid ""
"This is a container for dma_fence objects which needs to handle multiple use "
"cases."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:143
msgid ""
"One use is to synchronize cross-driver access to a struct dma_buf, either "
"for dynamic buffer management or just to handle implicit synchronization "
"between different users of the buffer in userspace. See :c:type:`dma_buf."
"resv <dma_buf>` for a more in-depth discussion."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:148
msgid ""
"The other major use is to manage access and locking within a driver in a "
"buffer based memory manager. struct ttm_buffer_object is the canonical "
"example here, since this is where reservation objects originated from. But "
"use in drivers is spreading and some drivers also manage struct "
"drm_gem_object with the same scheme."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:182
msgid "current position into the dma_resv fences"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:194
#: include/linux/dma-resv.h:297
msgid "``obj``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:195
msgid "The dma_resv object we iterate over"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:197
#: include/linux/dma-resv.h:298
msgid "``usage``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:198
msgid "Return fences with this usage or lower."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:200
#: include/linux/dma-resv.h:278 include/linux/dma-resv.h:299
#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:74
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:22
#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:44
#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:29
#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:22
msgid "``fence``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:201
msgid "the currently handled fence"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:203
msgid "``fence_usage``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:204
msgid "the usage of the current fence"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:206
#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:71
#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:28
msgid "``index``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:207
msgid "index into the shared fences"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:210
msgid "the shared fences; private, *MUST* not dereference"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:212
#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:32
#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:59
msgid "``num_fences``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:213
msgid "number of fences"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:215
msgid "``is_restarted``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:216
msgid "true if this is the first returned fence"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:183
msgid ""
"Don't touch this directly in the driver, use the accessor function instead."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:185
msgid "IMPORTANT"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:187
msgid ""
"When using the lockless iterators like dma_resv_iter_next_unlocked() or "
"dma_resv_for_each_fence_unlocked() beware that the iterator can be "
"restarted. Code which accumulates statistics or similar needs to check for "
"this with dma_resv_iter_is_restarted()."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:225
msgid "initialize a dma_resv_iter object"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:226
msgid "The dma_resv_iter object to initialize"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:227
msgid "The dma_resv object which we want to iterate over"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:240
msgid "cleanup a dma_resv_iter object"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:241
msgid "the dma_resv_iter object which should be cleaned up"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:242
msgid ""
"Make sure that the reference to the fence in the cursor is properly dropped."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:252
msgid "Return the usage of the current fence"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:253
msgid "the cursor of the current position"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:254
msgid "Returns the usage of the currently processed fence."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:264
msgid "test if this is the first fence after a restart"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:266
msgid "Return true if this is the first fence in an iteration after a restart."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:277
msgid "``dma_resv_for_each_fence_unlocked (cursor, fence)``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:275
msgid "unlocked fence iterator"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:281
#: include/linux/dma-resv.h:300 ../../../driver-api/dma-buf:219:
#: include/linux/dma-fence-unwrap.h:41
msgid "``cursor``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:276
#: include/linux/dma-resv.h:295
msgid "a struct dma_resv_iter pointer"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:277
#: include/linux/dma-resv.h:298 ../../../driver-api/dma-buf:210:
#: drivers/dma-buf/dma-fence-chain.c:234
msgid "the current fence"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:278
msgid ""
"Iterate over the fences in a struct dma_resv object without holding the :c:"
"type:`dma_resv.lock <dma_resv>` and using RCU instead. The cursor needs to "
"be initialized with dma_resv_iter_begin() and cleaned up with "
"dma_resv_iter_end(). Inside the iterator a reference to the dma_fence is "
"held and the RCU lock dropped."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:283
msgid ""
"Beware that the iterator can be restarted when the struct dma_resv for "
"**cursor** is modified. Code which accumulates statistics or similar needs "
"to check for this with dma_resv_iter_is_restarted(). For this reason prefer "
"the lock iterator dma_resv_for_each_fence() whenever possible."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:296
msgid "``dma_resv_for_each_fence (cursor, obj, usage, fence)``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:294
msgid "fence iterator"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:296
msgid "a dma_resv object pointer"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:297
msgid "controls which fences to return"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:299
msgid ""
"Iterate over the fences in a struct dma_resv object while holding the :c:"
"type:`dma_resv.lock <dma_resv>`. **all_fences** controls if the shared "
"fences are returned as well. The cursor initialisation is part of the "
"iterator and the fence stays valid as long as the lock is held and so no "
"extra reference to the fence is taken."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:321
#: include/linux/dma-resv.h:349
msgid "lock the reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:324
#: include/linux/dma-resv.h:352 include/linux/dma-resv.h:379
#: include/linux/dma-resv.h:397
msgid "``struct ww_acquire_ctx *ctx``"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:323
#: include/linux/dma-resv.h:351 include/linux/dma-resv.h:378
#: include/linux/dma-resv.h:396
msgid "the locking context"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:324
msgid ""
"Locks the reservation object for exclusive access and modification. Note, "
"that the lock is only against other writers, readers will run concurrently "
"with a writer under RCU. The seqlock is used to notify readers if they "
"overlap with a writer."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:329
#: include/linux/dma-resv.h:357
msgid ""
"As the reservation object may be locked by multiple parties in an undefined "
"order, a #ww_acquire_ctx is passed to unwind if a cycle is detected. See "
"ww_mutex_lock() and ww_acquire_init(). A reservation object may be locked by "
"itself by passing NULL as **ctx**."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:334
msgid ""
"When a die situation is indicated by returning -EDEADLK all locks held by "
"**ctx** must be unlocked and then dma_resv_lock_slow() called on **obj**."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:337
#: include/linux/dma-resv.h:366
msgid "Unlocked by calling dma_resv_unlock()."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:339
msgid "See also dma_resv_lock_interruptible() for the interruptible variant."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:352
msgid ""
"Locks the reservation object interruptible for exclusive access and "
"modification. Note, that the lock is only against other writers, readers "
"will run concurrently with a writer under RCU. The seqlock is used to notify "
"readers if they overlap with a writer."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:362
msgid ""
"When a die situation is indicated by returning -EDEADLK all locks held by "
"**ctx** must be unlocked and then dma_resv_lock_slow_interruptible() called "
"on **obj**."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:376
msgid "slowpath lock the reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:379
msgid ""
"Acquires the reservation object after a die case. This function will sleep "
"until the lock becomes available. See dma_resv_lock() as well."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:383
msgid ""
"See also dma_resv_lock_slow_interruptible() for the interruptible variant."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:393
msgid "slowpath lock the reservation object, interruptible"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:397
msgid ""
"Acquires the reservation object interruptible after a die case. This "
"function will sleep until the lock becomes available. See "
"dma_resv_lock_interruptible() as well."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:409
msgid "trylock the reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:411
msgid ""
"Tries to lock the reservation object for exclusive access and modification. "
"Note, that the lock is only against other writers, readers will run "
"concurrently with a writer under RCU. The seqlock is used to notify readers "
"if they overlap with a writer."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:416
msgid ""
"Also note that since no context is provided, no deadlock protection is "
"possible, which is also not needed for a trylock."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:419
msgid "Returns true if the lock was acquired, false otherwise."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:428
msgid "is the reservation object locked"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:430
msgid "Returns true if the mutex is locked, false if unlocked."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:439
msgid "returns the context used to lock the object"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:441
msgid ""
"Returns the context used to lock a reservation object or NULL if no context "
"was used or the object is not locked at all."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:444
msgid ""
"WARNING: This interface is pretty horrible, but TTM needs it because it "
"doesn't pass the struct ww_acquire_ctx around in some very long callchains. "
"Everyone else just uses it to check whether they're holding a reservation or "
"not."
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:456
msgid "unlock the reservation object"
msgstr ""

#: ../../../driver-api/dma-buf:162: include/linux/dma-resv.h:458
msgid "Unlocks the reservation object following exclusive access."
msgstr ""

#: ../../../driver-api/dma-buf.rst:166
msgid "DMA Fences"
msgstr ""

#: ../../../driver-api/dma-buf:168: drivers/dma-buf/dma-fence.c:39
msgid ""
"DMA fences, represented by :c:type:`struct dma_fence <dma_fence>`, are the "
"kernel internal synchronization primitive for DMA operations like GPU "
"rendering, video encoding/decoding, or displaying buffers on a screen."
msgstr ""

#: ../../../driver-api/dma-buf:168: drivers/dma-buf/dma-fence.c:43
msgid ""
"A fence is initialized using dma_fence_init() and completed using "
"dma_fence_signal(). Fences are associated with a context, allocated through "
"dma_fence_context_alloc(), and all fences on the same context are fully "
"ordered."
msgstr ""

#: ../../../driver-api/dma-buf:168: drivers/dma-buf/dma-fence.c:48
msgid ""
"Since the purposes of fences is to facilitate cross-device and cross-"
"application synchronization, there's multiple ways to use one:"
msgstr ""

#: ../../../driver-api/dma-buf:168: drivers/dma-buf/dma-fence.c:51
msgid ""
"Individual fences can be exposed as a :c:type:`sync_file`, accessed as a "
"file descriptor from userspace, created by calling sync_file_create(). This "
"is called explicit fencing, since userspace passes around explicit "
"synchronization points."
msgstr ""

#: ../../../driver-api/dma-buf:168: drivers/dma-buf/dma-fence.c:56
msgid ""
"Some subsystems also have their own explicit fencing primitives, like :c:"
"type:`drm_syncobj`. Compared to :c:type:`sync_file`, a :c:type:`drm_syncobj` "
"allows the underlying fence to be updated."
msgstr ""

#: ../../../driver-api/dma-buf:168: drivers/dma-buf/dma-fence.c:60
msgid ""
"Then there's also implicit fencing, where the synchronization points are "
"implicitly passed around as part of shared :c:type:`dma_buf` instances. Such "
"implicit fences are stored in :c:type:`struct dma_resv <dma_resv>` through "
"the :c:type:`dma_buf.resv <dma_buf>` pointer."
msgstr ""

#: ../../../driver-api/dma-buf.rst:172
msgid "DMA Fence Cross-Driver Contract"
msgstr ""

#: ../../../driver-api/dma-buf:174: drivers/dma-buf/dma-fence.c:69
msgid ""
"Since :c:type:`dma_fence` provide a cross driver contract, all drivers must "
"follow the same rules:"
msgstr ""

#: ../../../driver-api/dma-buf:174: drivers/dma-buf/dma-fence.c:72
msgid ""
"Fences must complete in a reasonable time. Fences which represent kernels "
"and shaders submitted by userspace, which could run forever, must be backed "
"up by timeout and gpu hang recovery code. Minimally that code must prevent "
"further command submission and force complete all in-flight fences, e.g. "
"when the driver or hardware do not support gpu reset, or if the gpu reset "
"failed for some reason. Ideally the driver supports gpu recovery which only "
"affects the offending userspace context, and no other userspace submissions."
msgstr ""

#: ../../../driver-api/dma-buf:174: drivers/dma-buf/dma-fence.c:81
msgid ""
"Drivers may have different ideas of what completion within a reasonable time "
"means. Some hang recovery code uses a fixed timeout, others a mix between "
"observing forward progress and increasingly strict timeouts. Drivers should "
"not try to second guess timeout handling of fences from other drivers."
msgstr ""

#: ../../../driver-api/dma-buf:174: drivers/dma-buf/dma-fence.c:87
msgid ""
"To ensure there's no deadlocks of dma_fence_wait() against other locks "
"drivers should annotate all code required to reach dma_fence_signal(), which "
"completes the fences, with dma_fence_begin_signalling() and "
"dma_fence_end_signalling()."
msgstr ""

#: ../../../driver-api/dma-buf:174: drivers/dma-buf/dma-fence.c:92
msgid ""
"Drivers are allowed to call dma_fence_wait() while holding dma_resv_lock(). "
"This means any code required for fence completion cannot acquire a :c:type:"
"`dma_resv` lock. Note that this also pulls in the entire established locking "
"hierarchy around dma_resv_lock() and dma_resv_unlock()."
msgstr ""

#: ../../../driver-api/dma-buf:174: drivers/dma-buf/dma-fence.c:97
msgid ""
"Drivers are allowed to call dma_fence_wait() from their :c:type:`shrinker` "
"callbacks. This means any code required for fence completion cannot allocate "
"memory with GFP_KERNEL."
msgstr ""

#: ../../../driver-api/dma-buf:174: drivers/dma-buf/dma-fence.c:101
msgid ""
"Drivers are allowed to call dma_fence_wait() from their :c:type:"
"`mmu_notifier` respectively :c:type:`mmu_interval_notifier` callbacks. This "
"means any code required for fence completion cannot allocate memory with "
"GFP_NOFS or GFP_NOIO. Only GFP_ATOMIC is permissible, which might fail."
msgstr ""

#: ../../../driver-api/dma-buf:174: drivers/dma-buf/dma-fence.c:106
msgid ""
"Note that only GPU drivers have a reasonable excuse for both requiring :c:"
"type:`mmu_interval_notifier` and :c:type:`shrinker` callbacks at the same "
"time as having to track asynchronous compute work using :c:type:`dma_fence`. "
"No driver outside of drivers/gpu should ever call dma_fence_wait() in such "
"contexts."
msgstr ""

#: ../../../driver-api/dma-buf.rst:178
msgid "DMA Fence Signalling Annotations"
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:195
msgid ""
"Proving correctness of all the kernel code around :c:type:`dma_fence` "
"through code review and testing is tricky for a few reasons:"
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:198
msgid ""
"It is a cross-driver contract, and therefore all drivers must follow the "
"same rules for lock nesting order, calling contexts for various functions "
"and anything else significant for in-kernel interfaces. But it is also "
"impossible to test all drivers in a single machine, hence brute-force N vs. "
"N testing of all combinations is impossible. Even just limiting to the "
"possible combinations is infeasible."
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:205
msgid ""
"There is an enormous amount of driver code involved. For render drivers "
"there's the tail of command submission, after fences are published, "
"scheduler code, interrupt and workers to process job completion, and "
"timeout, gpu reset and gpu hang recovery code. Plus for integration with "
"core mm with have :c:type:`mmu_notifier`, respectively :c:type:"
"`mmu_interval_notifier`, and :c:type:`shrinker`. For modesetting drivers "
"there's the commit tail functions between when fences for an atomic modeset "
"are published, and when the corresponding vblank completes, including any "
"interrupt processing and related workers. Auditing all that code, across all "
"drivers, is not feasible."
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:216
msgid ""
"Due to how many other subsystems are involved and the locking hierarchies "
"this pulls in there is extremely thin wiggle-room for driver-specific "
"differences. :c:type:`dma_fence` interacts with almost all of the core "
"memory handling through page fault handlers via :c:type:`dma_resv`, "
"dma_resv_lock() and dma_resv_unlock(). On the other side it also interacts "
"through all allocation sites through :c:type:`mmu_notifier` and :c:type:"
"`shrinker`."
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:223
msgid ""
"Furthermore lockdep does not handle cross-release dependencies, which means "
"any deadlocks between dma_fence_wait() and dma_fence_signal() can't be "
"caught at runtime with some quick testing. The simplest example is one "
"thread waiting on a :c:type:`dma_fence` while holding a lock::"
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:232
msgid ""
"while the other thread is stuck trying to acquire the same lock, which "
"prevents it from signalling the fence the previous thread is stuck waiting "
"on::"
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:240
msgid ""
"By manually annotating all code relevant to signalling a :c:type:`dma_fence` "
"we can teach lockdep about these dependencies, which also helps with the "
"validation headache since now lockdep can check all the rules for us::"
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:250
msgid ""
"For using dma_fence_begin_signalling() and dma_fence_end_signalling() to "
"annotate critical sections the following rules need to be observed:"
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:253
msgid ""
"All code necessary to complete a :c:type:`dma_fence` must be annotated, from "
"the point where a fence is accessible to other threads, to the point where "
"dma_fence_signal() is called. Un-annotated code can contain deadlock issues, "
"and due to the very strict rules and many corner cases it is infeasible to "
"catch these just with review or normal stress testing."
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:259
msgid ""
":c:type:`struct dma_resv <dma_resv>` deserves a special note, since the "
"readers are only protected by rcu. This means the signalling critical "
"section starts as soon as the new fences are installed, even before "
"dma_resv_unlock() is called."
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:263
msgid ""
"The only exception are fast paths and opportunistic signalling code, which "
"calls dma_fence_signal() purely as an optimization, but is not required to "
"guarantee completion of a :c:type:`dma_fence`. The usual example is a wait "
"IOCTL which calls dma_fence_signal(), while the mandatory completion path "
"goes through a hardware interrupt and possible job completion worker."
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:269
msgid ""
"To aid composability of code, the annotations can be freely nested, as long "
"as the overall locking hierarchy is consistent. The annotations also work "
"both in interrupt and process context. Due to implementation details this "
"requires that callers pass an opaque cookie from "
"dma_fence_begin_signalling() to dma_fence_end_signalling()."
msgstr ""

#: ../../../driver-api/dma-buf:180: drivers/dma-buf/dma-fence.c:275
msgid ""
"Validation against the cross driver contract is implemented by priming "
"lockdep with the relevant hierarchy at boot-up. This means even just testing "
"with a single device is enough to validate a driver, at least as far as "
"deadlocks with dma_fence_wait() against dma_fence_signal() are concerned."
msgstr ""

#: ../../../driver-api/dma-buf.rst:184
msgid "DMA Fence Deadline Hints"
msgstr ""

#: ../../../driver-api/dma-buf:186: drivers/dma-buf/dma-fence.c:934
msgid ""
"In an ideal world, it would be possible to pipeline a workload sufficiently "
"that a utilization based device frequency governor could arrive at a minimum "
"frequency that meets the requirements of the use-case, in order to minimize "
"power consumption.  But in the real world there are many workloads which "
"defy this ideal.  For example, but not limited to:"
msgstr ""

#: ../../../driver-api/dma-buf:186: drivers/dma-buf/dma-fence.c:940
msgid ""
"Workloads that ping-pong between device and CPU, with alternating periods of "
"CPU waiting for device, and device waiting on CPU.  This can result in "
"devfreq and cpufreq seeing idle time in their respective domains and in "
"result reduce frequency."
msgstr ""

#: ../../../driver-api/dma-buf:186: drivers/dma-buf/dma-fence.c:945
msgid ""
"Workloads that interact with a periodic time based deadline, such as double "
"buffered GPU rendering vs vblank sync'd page flipping.  In this scenario, "
"missing a vblank deadline results in an *increase* in idle time on the GPU "
"(since it has to wait an additional vblank period), sending a signal to the "
"GPU's devfreq to reduce frequency, when in fact the opposite is what is "
"needed."
msgstr ""

#: ../../../driver-api/dma-buf:186: drivers/dma-buf/dma-fence.c:952
msgid ""
"To this end, deadline hint(s) can be set on a :c:type:`dma_fence` via :c:"
"type:`dma_fence_set_deadline` (or indirectly via userspace facing ioctls "
"like :c:type:`sync_set_deadline`). The deadline hint provides a way for the "
"waiting driver, or userspace, to convey an appropriate sense of urgency to "
"the signaling driver."
msgstr ""

#: ../../../driver-api/dma-buf:186: drivers/dma-buf/dma-fence.c:957
msgid ""
"A deadline hint is given in absolute ktime (CLOCK_MONOTONIC for userspace "
"facing APIs).  The time could either be some point in the future (such as "
"the vblank based deadline for page-flipping, or the start of a compositor's "
"composition cycle), or the current time to indicate an immediate deadline "
"hint (Ie. forward progress cannot be made until this fence is signaled)."
msgstr ""

#: ../../../driver-api/dma-buf:186: drivers/dma-buf/dma-fence.c:963
msgid ""
"Multiple deadlines may be set on a given fence, even in parallel.  See the "
"documentation for :c:type:`dma_fence_ops.set_deadline <dma_fence_ops>`."
msgstr ""

#: ../../../driver-api/dma-buf:186: drivers/dma-buf/dma-fence.c:966
msgid ""
"The deadline hint is just that, a hint.  The driver that created the fence "
"may react by increasing frequency, making different scheduling choices, etc. "
"Or doing nothing at all."
msgstr ""

#: ../../../driver-api/dma-buf.rst:190
msgid "DMA Fences Functions Reference"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:125
msgid "return a signaled fence"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:131
#: drivers/dma-buf/dma-fence.c:295
msgid "``void``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1
msgid "no arguments"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:126
msgid ""
"Return a stub fence which is already signaled. The fence's timestamp "
"corresponds to the first time after boot this function is called."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:152
msgid "return a private, signaled fence"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:158
#: drivers/dma-buf/dma-fence.c:353 drivers/dma-buf/dma-fence.c:399
msgid "``ktime_t timestamp``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:153
msgid "timestamp when the fence was signaled"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:154
msgid "Return a newly allocated and signaled stub fence."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:180
msgid "allocate an array of fence contexts"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:186
msgid "``unsigned num``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:181
msgid "amount of contexts to allocate"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:182
msgid ""
"This function will return the first index of the number of fence contexts "
"allocated.  The fence context is used for setting :c:type:`dma_fence.context "
"<dma_fence>` to a unique number by passing the context to dma_fence_init()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:289
msgid "begin a critical DMA fence signalling section"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:290
msgid ""
"Drivers should use this to annotate the beginning of any code section "
"required to eventually complete :c:type:`dma_fence` by calling "
"dma_fence_signal()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:293
msgid ""
"The end of these critical sections are annotated with "
"dma_fence_end_signalling()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:297
msgid ""
"Opaque cookie needed by the implementation, which needs to be passed to "
"dma_fence_end_signalling()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:320
msgid "end a critical DMA fence signalling section"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:326
msgid "``bool cookie``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:321
msgid "opaque cookie from dma_fence_begin_signalling()"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:322
msgid ""
"Closes a critical section annotation opened by dma_fence_begin_signalling()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:350
#: drivers/dma-buf/dma-fence.c:396 drivers/dma-buf/dma-fence.c:427
#: drivers/dma-buf/dma-fence.c:449
msgid "signal completion of a fence"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:351
#: drivers/dma-buf/dma-fence.c:397 drivers/dma-buf/dma-fence.c:428
#: drivers/dma-buf/dma-fence.c:450
msgid "the fence to signal"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:352
#: drivers/dma-buf/dma-fence.c:398
msgid "fence signal timestamp in kernel's CLOCK_MONOTONIC time domain"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:353
#: drivers/dma-buf/dma-fence.c:399
msgid ""
"Signal completion for software callbacks on a fence, this will unblock "
"dma_fence_wait() calls and run all the callbacks added with "
"dma_fence_add_callback(). Can be called multiple times, but since a fence "
"can only go from the unsignaled to the signaled state and not back, it will "
"only be effective the first time. Set the timestamp provided as the fence "
"signal timestamp."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:360
msgid ""
"Unlike dma_fence_signal_timestamp(), this function must be called with :c:"
"type:`dma_fence.lock <dma_fence>` held."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:363
#: drivers/dma-buf/dma-fence.c:406 drivers/dma-buf/dma-fence.c:438
#: drivers/dma-buf/dma-fence.c:457
msgid ""
"Returns 0 on success and a negative error value when **fence** has been "
"signalled already."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:429
#: drivers/dma-buf/dma-fence.c:451
msgid ""
"Signal completion for software callbacks on a fence, this will unblock "
"dma_fence_wait() calls and run all the callbacks added with "
"dma_fence_add_callback(). Can be called multiple times, but since a fence "
"can only go from the unsignaled to the signaled state and not back, it will "
"only be effective the first time."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:435
msgid ""
"Unlike dma_fence_signal(), this function must be called with :c:type:"
"`dma_fence.lock <dma_fence>` held."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:483
msgid "sleep until the fence gets signaled or until timeout elapses"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:485
#: drivers/dma-buf/dma-fence.c:641 drivers/dma-buf/dma-fence.c:717
#: drivers/dma-buf/dma-fence.c:768 ../../../driver-api/dma-buf:195:
#: include/linux/dma-fence.h:619
msgid "the fence to wait on"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:486
#: drivers/dma-buf/dma-fence.c:769 drivers/dma-buf/dma-fence.c:849
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:620
msgid "if true, do an interruptible wait"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:488
#: drivers/dma-buf/dma-fence.c:771 drivers/dma-buf/dma-fence.c:851
msgid "``signed long timeout``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:487
#: drivers/dma-buf/dma-fence.c:770 drivers/dma-buf/dma-fence.c:850
msgid "timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:488
msgid ""
"Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the "
"remaining timeout in jiffies on success. Other error values may be returned "
"on custom implementations."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:492
msgid ""
"Performs a synchronous wait on this fence. It is assumed the caller directly "
"or indirectly (buf-mgr between reservation and committing) holds a reference "
"to the fence, otherwise the fence might be freed before return, resulting in "
"undefined behavior."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:497
msgid "See also dma_fence_wait() and dma_fence_wait_any_timeout()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:533
msgid "default release function for fences"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:539
msgid "``struct kref *kref``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:534
msgid ":c:type:`dma_fence.recfount <dma_fence>`"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:535
msgid ""
"This is the default release functions for :c:type:`dma_fence`. Drivers "
"shouldn't call this directly, but instead call dma_fence_put()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:584
msgid "default release function for :c:type:`dma_fence`."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:585
msgid "fence to release"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:586
msgid ""
"This is the default implementation for :c:type:`dma_fence_ops.release "
"<dma_fence_ops>`. It calls kfree_rcu() on **fence**."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:621
msgid "enable signaling on fence"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:622
msgid "the fence to enable"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:623
msgid ""
"This will request for sw signaling to be enabled, to make the fence complete "
"as soon as possible. This calls :c:type:`dma_fence_ops.enable_signaling "
"<dma_fence_ops>` internally."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:639
msgid "add a callback to be called when the fence is signaled"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:643
#: drivers/dma-buf/dma-fence.c:719
msgid "``struct dma_fence_cb *cb``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:642
msgid "the callback to register"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:644
msgid "``dma_fence_func_t func``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:643
msgid "the function to call"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:644
msgid ""
"Add a software callback to the fence. The caller should keep a reference to "
"the fence."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:647
msgid ""
"**cb** will be initialized by dma_fence_add_callback(), no initialization by "
"the caller is required. Any number of callbacks can be registered to a "
"fence, but a callback can only be registered to one fence at a time."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:651
msgid ""
"If fence is already signaled, this function will return -ENOENT (and *not* "
"call the callback)."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:654
msgid ""
"Note that the callback can be called from an atomic context or irq context."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:656
msgid ""
"Returns 0 in case of success, -ENOENT if the fence is already signaled and -"
"EINVAL in case of error."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:691
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:542
msgid "returns the status upon completion"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:692
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:543
msgid "the dma_fence to query"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:693
msgid ""
"This wraps dma_fence_get_status_locked() to return the error status "
"condition on a signaled fence. See dma_fence_get_status_locked() for more "
"details."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:697
#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:550
msgid ""
"Returns 0 if the fence has not yet been signaled, 1 if the fence has been "
"signaled without an error condition, or a negative error code if the fence "
"has been completed in err."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:716
msgid "remove a callback from the signaling list"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:718
msgid "the callback to remove"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:719
msgid ""
"Remove a previously queued callback from the fence. This function returns "
"true if the callback is successfully removed, or false if the fence has "
"already been signaled."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:723
msgid ""
"*WARNING*: Cancelling a callback should only be done if you really know what "
"you're doing, since deadlocks and race conditions could occur all too "
"easily. For this reason, it should only ever be done on hardware lockup "
"recovery, with a reference held to the fence."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:729
msgid ""
"Behaviour is undefined if **cb** has not been added to **fence** using "
"dma_fence_add_callback() beforehand."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:766
msgid "default sleep until the fence gets signaled or until timeout elapses"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:771
msgid ""
"Returns -ERESTARTSYS if interrupted, 0 if the wait timed out, or the "
"remaining timeout in jiffies on success. If timeout is zero the value one is "
"returned if the fence is already signaled for consistency with other "
"functions taking a jiffies timeout."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:845
msgid "sleep until any fence gets signaled or until timeout elapses"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:851
#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:191
#: drivers/dma-buf/dma-fence-array.c:237
msgid "``struct dma_fence **fences``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:847
msgid "array of fences to wait on"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:849
msgid "``uint32_t count``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:848
msgid "number of fences to wait on"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:852
msgid "``uint32_t *idx``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:851
msgid ""
"used to store the first signaled fence index, meaningful only on positive "
"return"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:853
msgid ""
"Returns -EINVAL on custom fence wait implementation, -ERESTARTSYS if "
"interrupted, 0 if the wait timed out, or the remaining timeout in jiffies on "
"success."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:857
msgid ""
"Synchronous waits for the first fence in the array to be signaled. The "
"caller needs to hold a reference to all fences in the array, otherwise a "
"fence might be freed before return, resulting in undefined behavior."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:861
msgid "See also dma_fence_wait() and dma_fence_wait_timeout()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:974
msgid "set desired fence-wait deadline hint"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:975
msgid "the fence that is to be waited on"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:976
msgid "the time by which the waiter hopes for the fence to be signaled"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:978
msgid ""
"Give the fence signaler a hint about an upcoming deadline, such as vblank, "
"by which point the waiter would prefer the fence to be signaled by.  This is "
"intended to give feedback to the fence signaler to aid in power management "
"decisions, such as boosting GPU frequency if a periodic vblank deadline is "
"approaching but the fence is not yet signaled.."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:994
msgid "Dump fence description into seq_file"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:995
msgid "the fence to describe"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:996
msgid "the seq_file to put the textual description into"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:997
msgid ""
"Dump a textual description of the fence and it's state into the seq_file."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1040
msgid "Initialize a custom fence."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1041
#: drivers/dma-buf/dma-fence.c:1064
msgid "the fence to initialize"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1043
#: drivers/dma-buf/dma-fence.c:1066
msgid "``const struct dma_fence_ops *ops``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1042
#: drivers/dma-buf/dma-fence.c:1065
msgid "the dma_fence_ops for operations on this fence"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1044
#: drivers/dma-buf/dma-fence.c:1067
msgid "``spinlock_t *lock``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1043
#: drivers/dma-buf/dma-fence.c:1066
msgid "the irqsafe spinlock to use for locking this fence"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1045
#: drivers/dma-buf/dma-fence.c:1068 ../../../driver-api/dma-buf:201:
#: drivers/dma-buf/dma-fence-array.c:192 drivers/dma-buf/dma-fence-array.c:238
#: drivers/dma-buf/dma-fence-array.c:274
msgid "``u64 context``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1044
#: drivers/dma-buf/dma-fence.c:1067
msgid "the execution context this fence is run on"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1046
#: drivers/dma-buf/dma-fence.c:1069
msgid "``u64 seqno``"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1045
#: drivers/dma-buf/dma-fence.c:1068
msgid "a linear increasing sequence number for this context"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1046
#: drivers/dma-buf/dma-fence.c:1069
msgid ""
"Initializes an allocated fence, the caller doesn't have to keep its refcount "
"after committing with this fence, but it will need to hold a refcount again "
"if :c:type:`dma_fence_ops.enable_signaling <dma_fence_ops>` gets called."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1050
msgid ""
"context and seqno are used for easy comparison between fences, allowing to "
"check which fence is later by simply using dma_fence_later()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1063
msgid "Initialize a custom fence with 64-bit seqno support."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1073
msgid ""
"Context and seqno are used for easy comparison between fences, allowing to "
"check which fence is later by simply using dma_fence_later()."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1087
msgid "Access the driver name"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1088
#: drivers/dma-buf/dma-fence.c:1120
msgid "the fence to query"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1089
msgid "Returns a driver name backing the dma-fence implementation."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1091
#: drivers/dma-buf/dma-fence.c:1123
msgid ""
"IMPORTANT CONSIDERATION: Dma-fence contract stipulates that access to driver "
"provided data (data not directly embedded into the object itself), such as "
"the :c:type:`dma_fence.lock <dma_fence>` and memory potentially accessed by "
"the :c:type:`dma_fence.ops <dma_fence>` functions, is forbidden after the "
"fence has been signalled. Drivers are allowed to free that data, and some do."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1098
#: drivers/dma-buf/dma-fence.c:1130
msgid ""
"To allow safe access drivers are mandated to guarantee a RCU grace period "
"between signalling the fence and freeing said data."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1101
#: drivers/dma-buf/dma-fence.c:1133
msgid ""
"As such access to the driver name is only valid inside a RCU locked section. "
"The pointer MUST be both queried and USED ONLY WITHIN a SINGLE block guarded "
"by the :c:type:`rcu_read_lock` and :c:type:`rcu_read_unlock` pair."
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1119
msgid "Access the timeline name"
msgstr ""

#: ../../../driver-api/dma-buf:192: drivers/dma-buf/dma-fence.c:1121
msgid "Returns a timeline name provided by the dma-fence implementation."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:32
msgid "software synchronization primitive"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:38
msgid "spin_lock_irqsave used for locking"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:35
msgid "dma_fence_ops associated with this fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:1
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:2
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:36
msgid "``cb_list``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:37
msgid "list of all callbacks to call"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:43
msgid "``timestamp``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:44
msgid "Timestamp when the fence was signaled."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:35
msgid "``rcu``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:36
msgid "used for releasing fence with kfree_rcu"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:38
msgid "``context``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:39
msgid ""
"execution context this fence belongs to, returned by "
"dma_fence_context_alloc()"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:40
msgid "``seqno``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:41
msgid ""
"the sequence number of this fence inside the execution context, can be "
"compared to decide which fence would be signaled later."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:43
msgid "A mask of DMA_FENCE_FLAG_* defined below"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:33
msgid "``refcount``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:34
msgid "refcount for this fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:44
msgid "``error``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:45
msgid ""
"Optional, only valid if < 0, must be set before calling dma_fence_signal, "
"indicates that the fence has completed with an error."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:46
msgid ""
"the flags member must be manipulated and read using the appropriate atomic "
"ops (bit_*), so taking the spinlock will not be needed most of the time."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:50
msgid ""
"DMA_FENCE_FLAG_SIGNALED_BIT - fence is already signaled "
"DMA_FENCE_FLAG_TIMESTAMP_BIT - timestamp recorded for fence signaling "
"DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT - enable_signaling might have been called "
"DMA_FENCE_FLAG_USER_BITS - start of the unused bits, can be used by the "
"implementer of the fence for its own purposes. Can be used in different ways "
"by different fence implementers, so do not rely on this."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:57
msgid ""
"Since atomic bitops are used, this is not guaranteed to be the case. "
"Particularly, if the bit was set, but dma_fence_signal was called right "
"before this bit was set, it would have been able to set the "
"DMA_FENCE_FLAG_SIGNALED_BIT, before enable_signaling was called. Adding a "
"check for DMA_FENCE_FLAG_SIGNALED_BIT after setting "
"DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT closes this race, and makes sure that after "
"dma_fence_signal was called, any enable_signaling call will have either been "
"completed, or never called at all."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:112
msgid "callback for dma_fence_add_callback()"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:114
msgid ""
"used by dma_fence_add_callback() to append this struct to fence::cb_list"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:114
msgid "``func``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:115
msgid "dma_fence_func_t to call"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:115
msgid ""
"This struct will be initialized by dma_fence_add_callback(), additional data "
"can be passed along by embedding dma_fence_cb in another struct."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:125
msgid "operations implemented for fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:130
msgid "``get_driver_name``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:131
msgid ""
"Returns the driver name. This is a callback to allow drivers to compute the "
"name at runtime, without having it to store permanently for each fence, or "
"build a cache of some sort."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:135
#: include/linux/dma-fence.h:147
msgid "This callback is mandatory."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:141
msgid "``get_timeline_name``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:142
msgid ""
"Return the name of the context this fence belongs to. This is a callback to "
"allow drivers to compute the name at runtime, without having it to store "
"permanently for each fence, or build a cache of some sort."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:153
msgid "``enable_signaling``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:154
msgid "Enable software signaling of fence."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:156
msgid ""
"For fence implementations that have the capability for hw->hw signaling, "
"they can implement this op to enable the necessary interrupts, or insert "
"commands into cmdstream, etc, to avoid these costly operations for the "
"common case where only hw->hw synchronization is required.  This is called "
"in the first dma_fence_wait() or dma_fence_add_callback() path to let the "
"fence implementation know that there is another driver waiting on the signal "
"(ie. hw->sw case)."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:165
msgid ""
"This is called with irq's disabled, so only spinlocks which disable IRQ's "
"can be used in the code outside of this callback."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:168
msgid ""
"A return value of false indicates the fence already passed, or some failure "
"occurred that made it impossible to enable signaling. True indicates "
"successful enabling."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:172
msgid ""
":c:type:`dma_fence.error <dma_fence>` may be set in enable_signaling, but "
"only when false is returned."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:175
msgid ""
"Since many implementations can call dma_fence_signal() even when before "
"**enable_signaling** has been called there's a race window, where the "
"dma_fence_signal() might result in the final fence reference being released "
"and its memory freed. To avoid this, implementations of this callback should "
"grab their own reference using dma_fence_get(), to be released when the "
"fence is signalled (through e.g. the interrupt handler)."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:183
msgid ""
"This callback is optional. If this callback is not present, then the driver "
"must always have signaling enabled."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:190
msgid "``signaled``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:191
msgid ""
"Peek whether the fence is signaled, as a fastpath optimization for e.g. "
"dma_fence_wait() or dma_fence_add_callback(). Note that this callback does "
"not need to make any guarantees beyond that a fence once indicates as "
"signalled must always return true from this callback. This callback may "
"return false even if the fence has completed already, in this case "
"information hasn't propogated throug the system yet. See also "
"dma_fence_is_signaled()."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:199
msgid "May set :c:type:`dma_fence.error <dma_fence>` if returning true."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:207
msgid "``wait``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:208
msgid ""
"Custom wait implementation, defaults to dma_fence_default_wait() if not set."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:211
msgid ""
"Deprecated and should not be used by new implementations. Only used by "
"existing implementations which need special handling for their hardware "
"reset procedure."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:215
msgid ""
"Must return -ERESTARTSYS if the wait is intr = true and the wait was "
"interrupted, and remaining jiffies if fence has signaled, or 0 if wait timed "
"out. Can also return other error values on custom implementations, which "
"should be treated as if the fence is signaled. For example a hardware lockup "
"could be reported like that."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:227
msgid ""
"Called on destruction of fence to release additional resources. Can be "
"called from irq context.  This callback is optional. If it is NULL, then "
"dma_fence_free() is instead called as the default implementation."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:236
msgid "``set_deadline``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:237
msgid ""
"Callback to allow a fence waiter to inform the fence signaler of an upcoming "
"deadline, such as vblank, by which point the waiter would prefer the fence "
"to be signaled by.  This is intended to give feedback to the fence signaler "
"to aid in power management decisions, such as boosting GPU frequency."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:243
msgid ""
"This is called without :c:type:`dma_fence.lock <dma_fence>` held, it can be "
"called multiple times and from any context.  Locking is up to the callee if "
"it has some state to manage.  If multiple deadlines are set, the expectation "
"is to track the soonest one.  If the deadline is before the current time, it "
"should be interpreted as an immediate deadline."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:267
msgid "decreases refcount of the fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:268
msgid "fence to reduce refcount of"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:277
msgid "increases refcount of the fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:278
#: include/linux/dma-fence.h:292
msgid "fence to increase refcount of"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:279
msgid "Returns the same fence, with refcount increased by 1."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:290
msgid "get a fence from a dma_resv_list with rcu read lock"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:293
msgid "Function returns NULL if no refcount could be obtained, or the fence."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:305
msgid "acquire a reference to an RCU tracked fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:311
msgid "``struct dma_fence __rcu **fencep``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:306
msgid "pointer to fence to increase refcount of"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:307
msgid ""
"Function returns NULL if no refcount could be obtained, or the fence. This "
"function handles acquiring a reference to a fence that may be reallocated "
"within the RCU grace period (such as with SLAB_TYPESAFE_BY_RCU), so long as "
"the caller is using RCU on the pointer to the fence."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:312
msgid ""
"An alternative mechanism is to employ a seqlock to protect a bunch of "
"fences, such as used by struct dma_resv. When using a seqlock, the seqlock "
"must be taken before and checked after a reference to the fence is acquired "
"(as shown here)."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:317
msgid "The caller is required to hold the RCU read lock."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:405
#: include/linux/dma-fence.h:433
msgid "Return an indication if the fence is signaled yet."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:407
#: include/linux/dma-fence.h:434
msgid "the fence to check"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:408
#: include/linux/dma-fence.h:435
msgid ""
"Returns true if the fence was already signaled, false if not. Since this "
"function doesn't enable signaling, it is not guaranteed to ever return true "
"if dma_fence_add_callback(), dma_fence_wait() or "
"dma_fence_enable_sw_signaling() haven't been called before."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:413
msgid "This function requires :c:type:`dma_fence.lock <dma_fence>` to be held."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:415
msgid "See also dma_fence_is_signaled()."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:440
msgid ""
"It's recommended for seqno fences to call dma_fence_signal when the "
"operation is complete, it makes it possible to prevent issues from "
"wraparound between time of issue and time of use by checking the return "
"value of this function before calling hardware-specific wait instructions."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:445
msgid "See also dma_fence_is_signaled_locked()."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:463
#: include/linux/dma-fence.h:484
msgid "return if f1 is chronologically later than f2"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:464
msgid "fence in whose context to do the comparison"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:466
msgid "``u64 f1``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:465
msgid "the first fence's seqno"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:467
msgid "``u64 f2``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:466
msgid "the second fence's seqno from the same context"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:467
msgid ""
"Returns true if f1 is chronologically later than f2. Both fences must be "
"from the same context, since a seqno is not common across contexts."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:490
#: include/linux/dma-fence.h:507 include/linux/dma-fence.h:522
msgid "``struct dma_fence *f1``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:485
#: include/linux/dma-fence.h:502 include/linux/dma-fence.h:517
msgid "the first fence from the same context"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:487
#: include/linux/dma-fence.h:504 include/linux/dma-fence.h:519
msgid "``struct dma_fence *f2``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:486
#: include/linux/dma-fence.h:503 include/linux/dma-fence.h:518
msgid "the second fence from the same context"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:487
msgid ""
"Returns true if f1 is chronologically later than f2. Both fences must be "
"from the same context, since a seqno is not re-used across contexts."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:501
msgid "return true if f1 is later or same as f2"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:504
msgid ""
"Returns true if f1 is chronologically later than f2 or the same fence. Both "
"fences must be from the same context, since a seqno is not re-used across "
"contexts."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:516
msgid "return the chronologically later fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:519
msgid ""
"Returns NULL if both fences are signaled, otherwise the fence that would be "
"signaled last. Both fences must be from the same context, since a seqno is "
"not re-used across contexts."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:544
msgid ""
"Drivers can supply an optional error status condition before they signal the "
"fence (to indicate whether the fence was completed due to an error rather "
"than success). The value of the status condition is only valid if the fence "
"has been signaled, dma_fence_get_status_locked() first checks the signal "
"state before reporting the error status."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:566
msgid "flag an error condition on the fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:567
msgid "the dma_fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:569
msgid "``int error``"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:568
msgid "the error to store"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:569
msgid ""
"Drivers can supply an optional error status condition before they signal the "
"fence, to indicate that the fence was completed due to an error rather than "
"success. This must be set before signaling (so that the value is visible "
"before any waiters on the signal callback are woken). This helper exists to "
"help catching erroneous setting of #dma_fence.error."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:575
msgid "Examples of error codes which drivers should use:"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:577
msgid ""
"``-ENODATA``   This operation produced no data, no other operation affected."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:578
msgid "``-ECANCELED`` All operations from the same context have been canceled."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:579
msgid "``-ETIME``     Operation caused a timeout and potentially device reset."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:592
msgid "helper to get the completion timestamp of a fence"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:593
msgid "fence to get the timestamp from."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:594
msgid ""
"After a fence is signaled the timestamp is updated with the signaling time, "
"but setting the timestamp can race with tasks waiting for the signaling. "
"This helper busy waits for the correct timestamp to appear."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:618
msgid "sleep until the fence gets signaled"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:621
msgid ""
"This function will return -ERESTARTSYS if interrupted by a signal, or 0 if "
"the fence was signaled. Other error values may be returned on custom "
"implementations."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:625
msgid ""
"Performs a synchronous wait on this fence. It is assumed the caller directly "
"or indirectly holds a reference to the fence, otherwise the fence might be "
"freed before return, resulting in undefined behavior."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:629
msgid "See also dma_fence_wait_timeout() and dma_fence_wait_any_timeout()."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:655
msgid "check if a fence is from the array subclass"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:656
#: include/linux/dma-fence.h:667 include/linux/dma-fence.h:678
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:71
msgid "the fence to test"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:657
msgid "Return true if it is a dma_fence_array and false otherwise."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:666
msgid "check if a fence is from the chain subclass"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:668
msgid "Return true if it is a dma_fence_chain and false otherwise."
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:677
msgid "check if a fence is a container for other fences"
msgstr ""

#: ../../../driver-api/dma-buf:195: include/linux/dma-fence.h:679
msgid ""
"Return true if this fence is a container for other fences, false otherwise. "
"This is important since we can't build up large fence structure or otherwise "
"we run into recursion during operation on those fences."
msgstr ""

#: ../../../driver-api/dma-buf.rst:199
msgid "DMA Fence Array"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:173
msgid "Allocate a custom fence array"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:179
#: drivers/dma-buf/dma-fence-array.c:190 drivers/dma-buf/dma-fence-array.c:240
msgid "``int num_fences``"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:174
#: drivers/dma-buf/dma-fence-array.c:189 drivers/dma-buf/dma-fence-array.c:235
msgid "[in]    number of fences to add in the array"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:175
msgid "Return dma fence array on success, NULL on failure"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:187
msgid "Init a custom fence array"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:193
msgid "``struct dma_fence_array *array``"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:188
msgid "[in]    dma fence array to arm"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:190
#: drivers/dma-buf/dma-fence-array.c:236
msgid "[in]    array containing the fences"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:191
#: drivers/dma-buf/dma-fence-array.c:237
msgid "[in]    fence context to use"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:193
#: drivers/dma-buf/dma-fence-array.c:239
msgid "``unsigned seqno``"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:192
#: drivers/dma-buf/dma-fence-array.c:238
msgid "[in]    sequence number to use"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:194
#: drivers/dma-buf/dma-fence-array.c:240
msgid "``bool signal_on_any``"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:193
#: drivers/dma-buf/dma-fence-array.c:239
msgid "[in]    signal on any fence in the array"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:194
msgid ""
"Implementation of **dma_fence_array_create** without allocation. Useful to "
"init a preallocated dma fence array in the path of reclaim or dma fence "
"signaling."
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:234
msgid "Create a custom fence array"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:240
msgid ""
"Allocate a dma_fence_array object and initialize the base fence with "
"dma_fence_init(). In case of error it returns NULL."
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:244
msgid ""
"The caller should allocate the fences array with num_fences size and fill it "
"with the fences it wants to add to the object. Ownership of this array is "
"taken and dma_fence_put() is used on each fence on release."
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:248
msgid ""
"If **signal_on_any** is true the fence array signals if any fence in the "
"array signals, otherwise it signals when all fences in the array signal."
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:271
msgid "Check if all fences are from the given context"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:272
msgid "[in]    fence or fence array"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:273
msgid "[in]    fence context to check all fences against"
msgstr ""

#: ../../../driver-api/dma-buf:201: drivers/dma-buf/dma-fence-array.c:274
msgid ""
"Checks the provided fence or, for a fence array, all fences in the array "
"against the given context. Returns false if any fence is from a different "
"context."
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:19
msgid "callback helper for fence array"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:20
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:32
#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:30
msgid "``cb``"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:21
msgid "fence callback structure for signaling"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:21
#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:24
msgid "``array``"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:22
msgid "reference to the parent fence array object"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:29
msgid "fence to represent an array of fences"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:30
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:19
msgid "``base``"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:31
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:20
msgid "fence base class"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:32
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:24
msgid "spinlock for fence handling"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:33
msgid "number of fences in the array"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:33
msgid "``num_pending``"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:34
msgid "fences in the array still pending"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:35
msgid "array of the fences"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:35
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:41
msgid "``work``"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:36
msgid "internal irq_work function"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:36
msgid "``callbacks``"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:37
msgid "array of callback helpers"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:52
msgid "cast a fence to a dma_fence_array"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:53
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:55
msgid "fence to cast to a dma_fence_array"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:54
msgid ""
"Returns NULL if the fence is not a dma_fence_array, or the dma_fence_array "
"otherwise."
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:70
msgid "``dma_fence_array_for_each (fence, index, head)``"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:68
msgid "iterate over all fences in array"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:69
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:112
#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:39
msgid "current fence"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:70
msgid "index into the array"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:72
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:114
#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:42
msgid "``head``"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:71
msgid "potential dma_fence_array object"
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:72
msgid ""
"Test if **array** is a dma_fence_array object and if yes iterate over all "
"fences in the array. If not just iterate over the fence in **array** itself."
msgstr ""

#: ../../../driver-api/dma-buf:204: include/linux/dma-fence-array.h:75
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:117
msgid "For a deep dive iterator see dma_fence_unwrap_for_each()."
msgstr ""

#: ../../../driver-api/dma-buf.rst:208
msgid "DMA Fence Chain"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:32
msgid "chain walking function"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:33
msgid "current chain node"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:34
msgid ""
"Walk the chain to the next node. Returns the next fence or NULL if we are at "
"the end of the chain. Garbage collects chain nodes which are already "
"signaled."
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:80
msgid "find fence chain node by seqno"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:86
msgid "``struct dma_fence **pfence``"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:81
msgid "pointer to the chain node where to start"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:83
#: drivers/dma-buf/dma-fence-chain.c:236
msgid "``uint64_t seqno``"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:82
msgid "the sequence number to search for"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:83
msgid ""
"Advance the fence pointer to the chain node which will signal this sequence "
"number. If no sequence number is provided then this is a no-op."
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:86
msgid ""
"Returns EINVAL if the fence is not a chain node or the sequence number has "
"not yet advanced far enough."
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:231
msgid "initialize a fence chain"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:237
#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:103
msgid "``struct dma_fence_chain *chain``"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:232
msgid "the chain node to initialize"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:234
msgid "``struct dma_fence *prev``"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:233
msgid "the previous fence"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:235
msgid "the sequence number to use for the fence chain"
msgstr ""

#: ../../../driver-api/dma-buf:210: drivers/dma-buf/dma-fence-chain.c:236
msgid ""
"Initialize a new chain node and either start a new chain or add the node to "
"the existing chain of the previous fence."
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:18
msgid "fence to represent an node of a fence chain"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:20
msgid "``prev``"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:21
msgid "previous fence of the chain"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:21
msgid "``prev_seqno``"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:22
msgid "original previous seqno before garbage collection"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:23
msgid "encapsulated fence"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:33
msgid "callback for signaling"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:35
msgid ""
"This is used to add the callback for signaling the complection of the fence "
"chain. Never used at the same time as the irq work."
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:42
msgid "irq work item for signaling"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:44
msgid ""
"Irq work structure to allow us to add the callback without running into lock "
"inversion. Never used at the same time as the callback."
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:54
msgid "cast a fence to a dma_fence_chain"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:56
msgid ""
"Returns NULL if the fence is not a dma_fence_chain, or the dma_fence_chain "
"otherwise."
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:70
msgid "return the contained fence"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:72
msgid ""
"If the fence is a dma_fence_chain the function returns the fence contained "
"inside the chain object, otherwise it returns the fence itself."
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:87
msgid "``dma_fence_chain_alloc ()``"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:86
msgid "Returns a new struct dma_fence_chain object or NULL on failure."
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:88
msgid ""
"This specialized allocator has to be a macro for its allocations to be "
"accounted separately (to have a separate alloc_tag). The typecast is "
"intentional to enforce typesafety."
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:98
msgid "chain node to free"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:99
msgid ""
"Frees up an allocated but not used struct dma_fence_chain object. This "
"doesn't need an RCU grace period since the fence was never initialized nor "
"published. After dma_fence_chain_init() has been called the fence must be "
"released by calling dma_fence_put(), and not through this function."
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:113
msgid "``dma_fence_chain_for_each (iter, head)``"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:111
msgid "iterate over all fences in chain"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:117
msgid "``iter``"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:113
msgid "starting point"
msgstr ""

#: ../../../driver-api/dma-buf:213: include/linux/dma-fence-chain.h:114
msgid ""
"Iterate over all fences in the chain. We keep a reference to the current "
"fence while inside the loop which must be dropped when breaking out."
msgstr ""

#: ../../../driver-api/dma-buf.rst:217
msgid "DMA Fence unwrap"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:14
msgid "cursor into the container structure"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:20
msgid "``chain``"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:21
msgid "potential dma_fence_chain, but can be other fence as well"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:25
msgid "potential dma_fence_array, but can be other fence as well"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:29
msgid "last returned index if **array** is really a dma_fence_array"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:15
msgid "Should be used with dma_fence_unwrap_for_each() iterator macro."
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:40
msgid "``dma_fence_unwrap_for_each (fence, cursor, head)``"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:38
msgid "iterate over all fences in containers"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:40
msgid "current position inside the containers"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:41
msgid "starting point for the iterator"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:42
msgid ""
"Unwrap dma_fence_chain and dma_fence_array containers and deep dive into all "
"potential fences in them. If **head** is just a normal fence only that one "
"is returned."
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:60
msgid "``dma_fence_unwrap_merge (...)``"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:58
msgid "unwrap and merge fences"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:64
msgid "``...``"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:59
msgid ""
"All fences given as parameters are unwrapped and merged back together as "
"flat dma_fence_array. Useful if multiple containers need to be merged "
"together."
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:62
msgid ""
"Implemented as a macro to allocate the necessary arrays on the stack and "
"account the stack frame size to the caller."
msgstr ""

#: ../../../driver-api/dma-buf:219: include/linux/dma-fence-unwrap.h:65
msgid ""
"Returns NULL on memory allocation failure, a dma_fence object representing "
"all the given fences otherwise."
msgstr ""

#: ../../../driver-api/dma-buf.rst:223
msgid "DMA Fence Sync File"
msgstr ""

#: ../../../driver-api/dma-buf:225: drivers/dma-buf/sync_file.c:57
msgid "creates a sync file"
msgstr ""

#: ../../../driver-api/dma-buf:225: drivers/dma-buf/sync_file.c:58
msgid "fence to add to the sync_fence"
msgstr ""

#: ../../../driver-api/dma-buf:225: drivers/dma-buf/sync_file.c:59
msgid ""
"Creates a sync_file containg **fence**. This function acquires and "
"additional reference of **fence** for the newly-created :c:type:`sync_file`, "
"if it succeeds. The sync_file can be released with fput(sync_file->file). "
"Returns the sync_file or NULL in case of error."
msgstr ""

#: ../../../driver-api/dma-buf:225: drivers/dma-buf/sync_file.c:97
msgid "get the fence related to the sync_file fd"
msgstr ""

#: ../../../driver-api/dma-buf:225: drivers/dma-buf/sync_file.c:98
msgid "sync_file fd to get the fence from"
msgstr ""

#: ../../../driver-api/dma-buf:225: drivers/dma-buf/sync_file.c:99
msgid ""
"Ensures **fd** references a valid sync_file and returns a fence that "
"represents all fence in the sync_file. On error NULL is returned."
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:24
msgid "sync file to export to the userspace"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:26
msgid "file representing this fence"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:38
msgid "``user_name``"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:39
msgid ""
"Name of the sync file provided by userspace, for merged fences. Otherwise "
"generated through driver callbacks (in which case the entire array is 0)."
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:26
msgid "``sync_file_list``"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:27
msgid "membership in global file list"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:27
msgid "``wq``"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:28
msgid "wait queue for fence signaling"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:29
msgid "flags for the sync_file"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:30
msgid "fence with the fences in the sync_file"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:31
msgid "fence callback information"
msgstr ""

#: ../../../driver-api/dma-buf:228: include/linux/sync_file.h:31
msgid "flags: POLL_ENABLED: whether userspace is currently poll()'ing or not"
msgstr ""

#: ../../../driver-api/dma-buf.rst:232
msgid "DMA Fence Sync File uABI"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:19
msgid "SYNC_IOC_MERGE: merge two fences"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:21
msgid "name of new fence"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:21
msgid "``fd2``"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:22
msgid "file descriptor of second fence"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:23
msgid "returns the fd of the new fence to userspace"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:24
msgid "merge_data flags"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:24
#: include/uapi/linux/sync_file.h:60 include/uapi/linux/sync_file.h:82
msgid "``pad``"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:25
#: include/uapi/linux/sync_file.h:61
msgid "padding for 64-bit alignment, should always be zero"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:25
msgid ""
"Creates a new fence containing copies of the sync_pts in both the calling fd "
"and sync_merge_data.fd2.  Returns the new fence's fd in sync_merge_data.fence"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:39
msgid "detailed fence information"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:40
msgid "``obj_name``"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:41
msgid "name of parent sync_timeline"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:41
msgid "``driver_name``"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:42
msgid "name of driver implementing the parent"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:42
#: include/uapi/linux/sync_file.h:57
msgid "``status``"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:43
msgid "status of the fence 0:active 1:signaled <0:error"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:44
msgid "fence_info flags"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:44
msgid "``timestamp_ns``"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:45
msgid "timestamp of status change in nanoseconds"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:55
msgid "SYNC_IOC_FILE_INFO: get detailed information on a sync_file"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:57
msgid "name of fence"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:58
msgid "status of fence. 1: signaled 0:active <0:error"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:59
msgid "sync_file_info flags"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:60
msgid "number of fences in the sync_file"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:61
msgid "``sync_fence_info``"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:62
msgid ""
"pointer to array of struct :c:type:`sync_fence_info` with all fences in the "
"sync_file"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:63
msgid ""
"Takes a struct sync_file_info. If num_fences is 0, the field is updated with "
"the actual number of fences. If num_fences is > 0, the system will use the "
"pointer provided on sync_fence_info to return up to num_fences of struct "
"sync_fence_info, with detailed fence information."
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:80
msgid "SYNC_IOC_SET_DEADLINE - set a deadline hint on a fence"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:81
msgid "``deadline_ns``"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:82
msgid "absolute time of the deadline"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:83
msgid "must be zero"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:83
msgid ""
"Allows userspace to set a deadline on a fence, see :c:type:"
"`dma_fence_set_deadline`"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:85
msgid ""
"The timebase for the deadline is CLOCK_MONOTONIC (same as vblank).  For "
"example"
msgstr ""

#: ../../../driver-api/dma-buf:234: include/uapi/linux/sync_file.h:88
msgid ""
"clock_gettime(CLOCK_MONOTONIC, :c:type:`t`); deadline_ns = (t.tv_sec * "
"1000000000L) + t.tv_nsec + ns_until_deadline"
msgstr ""

#: ../../../driver-api/dma-buf.rst:238
msgid "Indefinite DMA Fences"
msgstr ""

#: ../../../driver-api/dma-buf.rst:240
msgid ""
"At various times struct dma_fence with an indefinite time until "
"dma_fence_wait() finishes have been proposed. Examples include:"
msgstr ""

#: ../../../driver-api/dma-buf.rst:243
msgid ""
"Future fences, used in HWC1 to signal when a buffer isn't used by the "
"display any longer, and created with the screen update that makes the buffer "
"visible. The time this fence completes is entirely under userspace's control."
msgstr ""

#: ../../../driver-api/dma-buf.rst:247
msgid ""
"Proxy fences, proposed to handle &drm_syncobj for which the fence has not "
"yet been set. Used to asynchronously delay command submission."
msgstr ""

#: ../../../driver-api/dma-buf.rst:250
msgid ""
"Userspace fences or gpu futexes, fine-grained locking within a command "
"buffer that userspace uses for synchronization across engines or with the "
"CPU, which are then imported as a DMA fence for integration into existing "
"winsys protocols."
msgstr ""

#: ../../../driver-api/dma-buf.rst:255
msgid ""
"Long-running compute command buffers, while still using traditional end of "
"batch DMA fences for memory management instead of context preemption DMA "
"fences which get reattached when the compute job is rescheduled."
msgstr ""

#: ../../../driver-api/dma-buf.rst:259
msgid ""
"Common to all these schemes is that userspace controls the dependencies of "
"these fences and controls when they fire. Mixing indefinite fences with "
"normal in-kernel DMA fences does not work, even when a fallback timeout is "
"included to protect against malicious userspace:"
msgstr ""

#: ../../../driver-api/dma-buf.rst:264
msgid ""
"Only the kernel knows about all DMA fence dependencies, userspace is not "
"aware of dependencies injected due to memory management or scheduler "
"decisions."
msgstr ""

#: ../../../driver-api/dma-buf.rst:267
msgid ""
"Only userspace knows about all dependencies in indefinite fences and when "
"exactly they will complete, the kernel has no visibility."
msgstr ""

#: ../../../driver-api/dma-buf.rst:270
msgid ""
"Furthermore the kernel has to be able to hold up userspace command "
"submission for memory management needs, which means we must support "
"indefinite fences being dependent upon DMA fences. If the kernel also "
"support indefinite fences in the kernel like a DMA fence, like any of the "
"above proposal would, there is the potential for deadlocks."
msgstr ""

#: ../../../driver-api/dma-buf.rst:290
msgid ""
"This means that the kernel might accidentally create deadlocks through "
"memory management dependencies which userspace is unaware of, which randomly "
"hangs workloads until the timeout kicks in. Workloads, which from "
"userspace's perspective, do not contain a deadlock.  In such a mixed fencing "
"architecture there is no single entity with knowledge of all dependencies. "
"Therefore preventing such deadlocks from within the kernel is not possible."
msgstr ""

#: ../../../driver-api/dma-buf.rst:297
msgid ""
"The only solution to avoid dependencies loops is by not allowing indefinite "
"fences in the kernel. This means:"
msgstr ""

#: ../../../driver-api/dma-buf.rst:300
msgid ""
"No future fences, proxy fences or userspace fences imported as DMA fences, "
"with or without a timeout."
msgstr ""

#: ../../../driver-api/dma-buf.rst:303
msgid ""
"No DMA fences that signal end of batchbuffer for command submission where "
"userspace is allowed to use userspace fencing or long running compute "
"workloads. This also means no implicit fencing for shared buffers in these "
"cases."
msgstr ""

#: ../../../driver-api/dma-buf.rst:309
msgid "Recoverable Hardware Page Faults Implications"
msgstr ""

#: ../../../driver-api/dma-buf.rst:311
msgid ""
"Modern hardware supports recoverable page faults, which has a lot of "
"implications for DMA fences."
msgstr ""

#: ../../../driver-api/dma-buf.rst:314
msgid ""
"First, a pending page fault obviously holds up the work that's running on "
"the accelerator and a memory allocation is usually required to resolve the "
"fault. But memory allocations are not allowed to gate completion of DMA "
"fences, which means any workload using recoverable page faults cannot use "
"DMA fences for synchronization. Synchronization fences controlled by "
"userspace must be used instead."
msgstr ""

#: ../../../driver-api/dma-buf.rst:321
msgid ""
"On GPUs this poses a problem, because current desktop compositor protocols "
"on Linux rely on DMA fences, which means without an entirely new userspace "
"stack built on top of userspace fences, they cannot benefit from recoverable "
"page faults. Specifically this means implicit synchronization will not be "
"possible. The exception is when page faults are only used as migration hints "
"and never to on-demand fill a memory request. For now this means recoverable "
"page faults on GPUs are limited to pure compute workloads."
msgstr ""

#: ../../../driver-api/dma-buf.rst:329
msgid ""
"Furthermore GPUs usually have shared resources between the 3D rendering and "
"compute side, like compute units or command submission engines. If both a 3D "
"job with a DMA fence and a compute workload using recoverable page faults "
"are pending they could deadlock:"
msgstr ""

#: ../../../driver-api/dma-buf.rst:334
msgid ""
"The 3D workload might need to wait for the compute job to finish and release "
"hardware resources first."
msgstr ""

#: ../../../driver-api/dma-buf.rst:337
msgid ""
"The compute workload might be stuck in a page fault, because the memory "
"allocation is waiting for the DMA fence of the 3D workload to complete."
msgstr ""

#: ../../../driver-api/dma-buf.rst:340
msgid ""
"There are a few options to prevent this problem, one of which drivers need "
"to ensure:"
msgstr ""

#: ../../../driver-api/dma-buf.rst:343
msgid ""
"Compute workloads can always be preempted, even when a page fault is pending "
"and not yet repaired. Not all hardware supports this."
msgstr ""

#: ../../../driver-api/dma-buf.rst:346
msgid ""
"DMA fence workloads and workloads which need page fault handling have "
"independent hardware resources to guarantee forward progress. This could be "
"achieved through e.g. through dedicated engines and minimal compute unit "
"reservations for DMA fence workloads."
msgstr ""

#: ../../../driver-api/dma-buf.rst:351
msgid ""
"The reservation approach could be further refined by only reserving the "
"hardware resources for DMA fence workloads when they are in-flight. This "
"must cover the time from when the DMA fence is visible to other threads up "
"to moment when fence is completed through dma_fence_signal()."
msgstr ""

#: ../../../driver-api/dma-buf.rst:356
msgid ""
"As a last resort, if the hardware provides no useful reservation mechanics, "
"all workloads must be flushed from the GPU when switching between jobs "
"requiring DMA fences or jobs requiring page fault handling: This means all "
"DMA fences must complete before a compute job with page fault handling can "
"be inserted into the scheduler queue. And vice versa, before a DMA fence can "
"be made visible anywhere in the system, all compute workloads must be "
"preempted to guarantee all pending GPU page faults are flushed."
msgstr ""

#: ../../../driver-api/dma-buf.rst:364
msgid ""
"Only a fairly theoretical option would be to untangle these dependencies "
"when allocating memory to repair hardware page faults, either through "
"separate memory blocks or runtime tracking of the full dependency graph of "
"all DMA fences. This results very wide impact on the kernel, since resolving "
"the page on the CPU side can itself involve a page fault. It is much more "
"feasible and robust to limit the impact of handling hardware page faults to "
"the specific driver."
msgstr ""

#: ../../../driver-api/dma-buf.rst:372
msgid ""
"Note that workloads that run on independent hardware like copy engines or "
"other GPUs do not have any impact. This allows us to keep using DMA fences "
"internally in the kernel even for resolving hardware page faults, e.g. by "
"using copy engines to clear or copy memory needed to resolve the page fault."
msgstr ""

#: ../../../driver-api/dma-buf.rst:377
msgid ""
"In some ways this page fault problem is a special case of the `Infinite DMA "
"Fences` discussions: Infinite fences from compute workloads are allowed to "
"depend on DMA fences, but not the other way around. And not even the page "
"fault problem is new, because some other CPU thread in userspace might hit a "
"page fault which holds up a userspace fence - supporting page faults on GPUs "
"doesn't anything fundamentally new."
msgstr ""
