# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/ipmi.rst:3
msgid "The Linux IPMI Driver"
msgstr ""

#: ../../../driver-api/ipmi.rst:0
msgid "Author"
msgstr "作者"

#: ../../../driver-api/ipmi.rst:5
msgid "Corey Minyard <minyard@mvista.com> / <minyard@acm.org>"
msgstr ""

#: ../../../driver-api/ipmi.rst:7
msgid ""
"The Intelligent Platform Management Interface, or IPMI, is a standard for "
"controlling intelligent devices that monitor a system. It provides for "
"dynamic discovery of sensors in the system and the ability to monitor the "
"sensors and be informed when the sensor's values change or go outside "
"certain boundaries.  It also has a standardized database for field-"
"replaceable units (FRUs) and a watchdog timer."
msgstr ""

#: ../../../driver-api/ipmi.rst:15
msgid ""
"To use this, you need an interface to an IPMI controller in your system "
"(called a Baseboard Management Controller, or BMC) and management software "
"that can use the IPMI system."
msgstr ""

#: ../../../driver-api/ipmi.rst:19
msgid ""
"This document describes how to use the IPMI driver for Linux.  If you are "
"not familiar with IPMI itself, see the web site at https://www.intel.com/"
"design/servers/ipmi/index.htm.  IPMI is a big subject and I can't cover it "
"all here!"
msgstr ""

#: ../../../driver-api/ipmi.rst:25
msgid "Configuration"
msgstr ""

#: ../../../driver-api/ipmi.rst:27
msgid ""
"The Linux IPMI driver is modular, which means you have to pick several "
"things to have it work right depending on your hardware.  Most of these are "
"available in the 'Character Devices' menu then the IPMI menu."
msgstr ""

#: ../../../driver-api/ipmi.rst:32
msgid ""
"No matter what, you must pick 'IPMI top-level message handler' to use IPMI.  "
"What you do beyond that depends on your needs and hardware."
msgstr ""

#: ../../../driver-api/ipmi.rst:35
msgid ""
"The message handler does not provide any user-level interfaces. Kernel code "
"(like the watchdog) can still use it.  If you need access from userland, you "
"need to select 'Device interface for IPMI' if you want access through a "
"device driver."
msgstr ""

#: ../../../driver-api/ipmi.rst:40
msgid ""
"The driver interface depends on your hardware.  If your system properly "
"provides the SMBIOS info for IPMI, the driver will detect it and just work.  "
"If you have a board with a standard interface (These will generally be "
"either \"KCS\", \"SMIC\", or \"BT\", consult your hardware manual), choose "
"the 'IPMI SI handler' option.  A driver also exists for direct I2C access to "
"the IPMI management controller.  Some boards support this, but it is unknown "
"if it will work on every board.  For this, choose 'IPMI SMBus handler', but "
"be ready to try to do some figuring to see if it will work on your system if "
"the SMBIOS/ACPI information is wrong or not present.  It is fairly safe to "
"have both these enabled and let the drivers auto-detect what is present."
msgstr ""

#: ../../../driver-api/ipmi.rst:52
msgid ""
"You should generally enable ACPI on your system, as systems with IPMI can "
"have ACPI tables describing them."
msgstr ""

#: ../../../driver-api/ipmi.rst:55
msgid ""
"If you have a standard interface and the board manufacturer has done their "
"job correctly, the IPMI controller should be automatically detected (via "
"ACPI or SMBIOS tables) and should just work.  Sadly, many boards do not have "
"this information.  The driver attempts standard defaults, but they may not "
"work.  If you fall into this situation, you need to read the section below "
"named 'The SI Driver' or \"The SMBus Driver\" on how to hand-configure your "
"system."
msgstr ""

#: ../../../driver-api/ipmi.rst:63
msgid ""
"IPMI defines a standard watchdog timer.  You can enable this with the 'IPMI "
"Watchdog Timer' config option.  If you compile the driver into the kernel, "
"then via a kernel command-line option you can have the watchdog timer start "
"as soon as it initializes.  It also has a lot of other options, see the "
"'Watchdog' section below for more details. Note that you can also have the "
"watchdog continue to run if it is closed (by default it is disabled on "
"close).  Go into the 'Watchdog Cards' menu, enable 'Watchdog Timer Support', "
"and enable the option 'Disable watchdog shutdown on close'."
msgstr ""

#: ../../../driver-api/ipmi.rst:73
msgid ""
"IPMI systems can often be powered off using IPMI commands.  Select 'IPMI "
"Poweroff' to do this.  The driver will auto-detect if the system can be "
"powered off by IPMI.  It is safe to enable this even if your system doesn't "
"support this option.  This works on ATCA systems, the Radisys CPI1 card, and "
"any IPMI system that supports standard chassis management commands."
msgstr ""

#: ../../../driver-api/ipmi.rst:80
msgid ""
"If you want the driver to put an event into the event log on a panic, enable "
"the 'Generate a panic event to all BMCs on a panic' option.  If you want the "
"whole panic string put into the event log using OEM events, enable the "
"'Generate OEM events containing the panic string' option.  You can also "
"enable these dynamically by setting the module parameter named \"panic_op\" "
"in the ipmi_msghandler module to \"event\" or \"string\".  Setting that "
"parameter to \"none\" disables this function."
msgstr ""

#: ../../../driver-api/ipmi.rst:89
msgid "Basic Design"
msgstr ""

#: ../../../driver-api/ipmi.rst:91
msgid ""
"The Linux IPMI driver is designed to be very modular and flexible, you only "
"need to take the pieces you need and you can use it in many different ways.  "
"Because of that, it's broken into many chunks of code.  These chunks (by "
"module name) are:"
msgstr ""

#: ../../../driver-api/ipmi.rst:96
msgid ""
"ipmi_msghandler - This is the central piece of software for the IPMI "
"system.  It handles all messages, message timing, and responses.  The IPMI "
"users tie into this, and the IPMI physical interfaces (called System "
"Management Interfaces, or SMIs) also tie in here.  This provides the "
"kernelland interface for IPMI, but does not provide an interface for use by "
"application processes."
msgstr ""

#: ../../../driver-api/ipmi.rst:103
msgid ""
"ipmi_devintf - This provides a userland IOCTL interface for the IPMI driver, "
"each open file for this device ties in to the message handler as an IPMI "
"user."
msgstr ""

#: ../../../driver-api/ipmi.rst:107
msgid ""
"ipmi_si - A driver for various system interfaces.  This supports KCS, SMIC, "
"and BT interfaces.  Unless you have an SMBus interface or your own custom "
"interface, you probably need to use this."
msgstr ""

#: ../../../driver-api/ipmi.rst:111
msgid ""
"ipmi_ssif - A driver for accessing BMCs on the SMBus. It uses the I2C kernel "
"driver's SMBus interfaces to send and receive IPMI messages over the SMBus."
msgstr ""

#: ../../../driver-api/ipmi.rst:115
msgid "ipmi_powernv - A driver for access BMCs on POWERNV systems."
msgstr ""

#: ../../../driver-api/ipmi.rst:117
msgid ""
"ipmi_watchdog - IPMI requires systems to have a very capable watchdog "
"timer.  This driver implements the standard Linux watchdog timer interface "
"on top of the IPMI message handler."
msgstr ""

#: ../../../driver-api/ipmi.rst:121
msgid ""
"ipmi_poweroff - Some systems support the ability to be turned off via IPMI "
"commands."
msgstr ""

#: ../../../driver-api/ipmi.rst:124
msgid ""
"bt-bmc - This is not part of the main driver, but instead a driver for "
"accessing a BMC-side interface of a BT interface.  It is used on BMCs "
"running Linux to provide an interface to the host."
msgstr ""

#: ../../../driver-api/ipmi.rst:128
msgid "These are all individually selectable via configuration options."
msgstr ""

#: ../../../driver-api/ipmi.rst:130
msgid ""
"Much documentation for the interface is in the include files.  The IPMI "
"include files are:"
msgstr ""

#: ../../../driver-api/ipmi.rst:133
msgid ""
"linux/ipmi.h - Contains the user interface and IOCTL interface for IPMI."
msgstr ""

#: ../../../driver-api/ipmi.rst:135
msgid ""
"linux/ipmi_smi.h - Contains the interface for system management interfaces "
"(things that interface to IPMI controllers) to use."
msgstr ""

#: ../../../driver-api/ipmi.rst:138
msgid "linux/ipmi_msgdefs.h - General definitions for base IPMI messaging."
msgstr ""

#: ../../../driver-api/ipmi.rst:142
msgid "Addressing"
msgstr ""

#: ../../../driver-api/ipmi.rst:144
msgid ""
"The IPMI addressing works much like IP addresses, you have an overlay to "
"handle the different address types.  The overlay is::"
msgstr ""

#: ../../../driver-api/ipmi.rst:154
msgid ""
"The addr_type determines what the address really is.  The driver currently "
"understands two different types of addresses."
msgstr ""

#: ../../../driver-api/ipmi.rst:157
msgid "\"System Interface\" addresses are defined as::"
msgstr ""

#: ../../../driver-api/ipmi.rst:165
msgid ""
"and the type is IPMI_SYSTEM_INTERFACE_ADDR_TYPE.  This is used for talking "
"straight to the BMC on the current card.  The channel must be "
"IPMI_BMC_CHANNEL."
msgstr ""

#: ../../../driver-api/ipmi.rst:169
msgid ""
"Messages that are destined to go out on the IPMB bus going through the BMC "
"use the IPMI_IPMB_ADDR_TYPE address type.  The format is::"
msgstr ""

#: ../../../driver-api/ipmi.rst:180
msgid ""
"The \"channel\" here is generally zero, but some devices support more than "
"one channel, it corresponds to the channel as defined in the IPMI spec."
msgstr ""

#: ../../../driver-api/ipmi.rst:184
msgid ""
"There is also an IPMB direct address for a situation where the sender is "
"directly on an IPMB bus and doesn't have to go through the BMC. You can send "
"messages to a specific management controller (MC) on the IPMB using the "
"IPMI_IPMB_DIRECT_ADDR_TYPE with the following format::"
msgstr ""

#: ../../../driver-api/ipmi.rst:198
msgid ""
"The channel is always zero.  You can also receive commands from other MCs "
"that you have registered to handle and respond to them, so you can use this "
"to implement a management controller on a bus.."
msgstr ""

#: ../../../driver-api/ipmi.rst:203
msgid "Messages"
msgstr ""

#: ../../../driver-api/ipmi.rst:205
msgid "Messages are defined as::"
msgstr ""

#: ../../../driver-api/ipmi.rst:216
msgid ""
"The driver takes care of adding/stripping the header information.  The data "
"portion is just the data to be send (do NOT put addressing info here) or the "
"response.  Note that the completion code of a response is the first item in "
"\"data\", it is not stripped out because that is how all the messages are "
"defined in the spec (and thus makes counting the offsets a little easier :-)."
msgstr ""

#: ../../../driver-api/ipmi.rst:223
msgid ""
"When using the IOCTL interface from userland, you must provide a block of "
"data for \"data\", fill it, and set data_len to the length of the block of "
"data, even when receiving messages.  Otherwise the driver will have no place "
"to put the message."
msgstr ""

#: ../../../driver-api/ipmi.rst:228
msgid ""
"Messages coming up from the message handler in kernelland will come in as::"
msgstr ""

#: ../../../driver-api/ipmi.rst:253
msgid ""
"You should look at the receive type and handle the message appropriately."
msgstr ""

#: ../../../driver-api/ipmi.rst:258
msgid "The Upper Layer Interface (Message Handler)"
msgstr ""

#: ../../../driver-api/ipmi.rst:260
msgid ""
"The upper layer of the interface provides the users with a consistent view "
"of the IPMI interfaces.  It allows multiple SMI interfaces to be addressed "
"(because some boards actually have multiple BMCs on them) and the user "
"should not have to care what type of SMI is below them."
msgstr ""

#: ../../../driver-api/ipmi.rst:267
msgid "Watching For Interfaces"
msgstr ""

#: ../../../driver-api/ipmi.rst:269
msgid ""
"When your code comes up, the IPMI driver may or may not have detected if "
"IPMI devices exist.  So you might have to defer your setup until the device "
"is detected, or you might be able to do it immediately. To handle this, and "
"to allow for discovery, you register an SMI watcher with "
"ipmi_smi_watcher_register() to iterate over interfaces and tell you when "
"they come and go."
msgstr ""

#: ../../../driver-api/ipmi.rst:278
msgid "Creating the User"
msgstr ""

#: ../../../driver-api/ipmi.rst:280
msgid ""
"To use the message handler, you must first create a user using "
"ipmi_create_user.  The interface number specifies which SMI you want to "
"connect to, and you must supply callback functions to be called when data "
"comes in.  This also allows to you pass in a piece of data, the "
"handler_data, that will be passed back to you on all calls."
msgstr ""

#: ../../../driver-api/ipmi.rst:286
msgid "Once you are done, call ipmi_destroy_user() to get rid of the user."
msgstr ""

#: ../../../driver-api/ipmi.rst:288
msgid ""
"From userland, opening the device automatically creates a user, and closing "
"the device automatically destroys the user."
msgstr ""

#: ../../../driver-api/ipmi.rst:293
msgid "Messaging"
msgstr ""

#: ../../../driver-api/ipmi.rst:295
msgid ""
"To send a message from kernel-land, the ipmi_request_settime() call does "
"pretty much all message handling.  Most of the parameter are self-"
"explanatory.  However, it takes a \"msgid\" parameter.  This is NOT the "
"sequence number of messages.  It is simply a long value that is passed back "
"when the response for the message is returned.  You may use it for anything "
"you like."
msgstr ""

#: ../../../driver-api/ipmi.rst:302
msgid ""
"Responses come back in the function pointed to by the ipmi_recv_hndl field "
"of the \"handler\" that you passed in to ipmi_create_user(). Remember to "
"look at the receive type, too."
msgstr ""

#: ../../../driver-api/ipmi.rst:306
msgid ""
"From userland, you fill out an ipmi_req_t structure and use the "
"IPMICTL_SEND_COMMAND ioctl.  For incoming stuff, you can use select() or "
"poll() to wait for messages to come in.  However, you cannot use read() to "
"get them, you must call the IPMICTL_RECEIVE_MSG with the ipmi_recv_t "
"structure to actually get the message.  Remember that you must supply a "
"pointer to a block of data in the msg.data field, and you must fill in the "
"msg.data_len field with the size of the data. This gives the receiver a "
"place to actually put the message."
msgstr ""

#: ../../../driver-api/ipmi.rst:315
msgid ""
"If the message cannot fit into the data you provide, you will get an "
"EMSGSIZE error and the driver will leave the data in the receive queue.  If "
"you want to get it and have it truncate the message, use the "
"IPMICTL_RECEIVE_MSG_TRUNC ioctl."
msgstr ""

#: ../../../driver-api/ipmi.rst:320
msgid ""
"When you send a command (which is defined by the lowest-order bit of the "
"netfn per the IPMI spec) on the IPMB bus, the driver will automatically "
"assign the sequence number to the command and save the command.  If the "
"response is not received in the IPMI-specified 5 seconds, it will generate a "
"response automatically saying the command timed out.  If an unsolicited "
"response comes in (if it was after 5 seconds, for instance), that response "
"will be ignored."
msgstr ""

#: ../../../driver-api/ipmi.rst:328
msgid ""
"In kernelland, after you receive a message and are done with it, you MUST "
"call ipmi_free_recv_msg() on it, or you will leak messages.  Note that you "
"should NEVER mess with the \"done\" field of a message, that is required to "
"properly clean up the message."
msgstr ""

#: ../../../driver-api/ipmi.rst:333
msgid ""
"Note that when sending, there is an ipmi_request_supply_msgs() call that "
"lets you supply the smi and receive message.  This is useful for pieces of "
"code that need to work even if the system is out of buffers (the watchdog "
"timer uses this, for instance).  You supply your own buffer and own free "
"routines.  This is not recommended for normal use, though, since it is "
"tricky to manage your own buffers."
msgstr ""

#: ../../../driver-api/ipmi.rst:342
msgid "Events and Incoming Commands"
msgstr ""

#: ../../../driver-api/ipmi.rst:344
msgid ""
"The driver takes care of polling for IPMI events and receiving commands "
"(commands are messages that are not responses, they are commands that other "
"things on the IPMB bus have sent you).  To receive these, you must register "
"for them, they will not automatically be sent to you."
msgstr ""

#: ../../../driver-api/ipmi.rst:350
msgid ""
"To receive events, you must call ipmi_set_gets_events() and set the \"val\" "
"to non-zero.  Any events that have been received by the driver since startup "
"will immediately be delivered to the first user that registers for events.  "
"After that, if multiple users are registered for events, they will all "
"receive all events that come in."
msgstr ""

#: ../../../driver-api/ipmi.rst:356
msgid ""
"For receiving commands, you have to individually register commands you want "
"to receive.  Call ipmi_register_for_cmd() and supply the netfn and command "
"name for each command you want to receive.  You also specify a bitmask of "
"the channels you want to receive the command from (or use IPMI_CHAN_ALL for "
"all channels if you don't care).  Only one user may be registered for each "
"netfn/cmd/channel, but different users may register for different commands, "
"or the same command if the channel bitmasks do not overlap."
msgstr ""

#: ../../../driver-api/ipmi.rst:365
msgid ""
"To respond to a received command, set the response bit in the returned "
"netfn, use the address from the received message, and use the same msgid "
"that you got in the received message."
msgstr ""

#: ../../../driver-api/ipmi.rst:369
msgid "From userland, equivalent IOCTLs are provided to do these functions."
msgstr ""

#: ../../../driver-api/ipmi.rst:373
msgid "The Lower Layer (SMI) Interface"
msgstr ""

#: ../../../driver-api/ipmi.rst:375
msgid ""
"As mentioned before, multiple SMI interfaces may be registered to the "
"message handler, each of these is assigned an interface number when they "
"register with the message handler.  They are generally assigned in the order "
"they register, although if an SMI unregisters and then another one "
"registers, all bets are off."
msgstr ""

#: ../../../driver-api/ipmi.rst:381
msgid ""
"The ipmi_smi.h defines the interface for management interfaces, see that for "
"more details."
msgstr ""

#: ../../../driver-api/ipmi.rst:386
msgid "The SI Driver"
msgstr ""

#: ../../../driver-api/ipmi.rst:388
msgid ""
"The SI driver allows KCS, BT, and SMIC interfaces to be configured in the "
"system.  It discovers interfaces through a host of different methods, "
"depending on the system."
msgstr ""

#: ../../../driver-api/ipmi.rst:392
msgid ""
"You can specify up to four interfaces on the module load line and control "
"some module parameters::"
msgstr ""

#: ../../../driver-api/ipmi.rst:407
msgid ""
"Each of these except try... items is a list, the first item for the first "
"interface, second item for the second interface, etc."
msgstr ""

#: ../../../driver-api/ipmi.rst:410
msgid ""
"The si_type may be either \"kcs\", \"smic\", or \"bt\".  If you leave it "
"blank, it defaults to \"kcs\"."
msgstr ""

#: ../../../driver-api/ipmi.rst:413
msgid ""
"If you specify addrs as non-zero for an interface, the driver will use the "
"memory address given as the address of the device.  This overrides si_ports."
msgstr ""

#: ../../../driver-api/ipmi.rst:417
msgid ""
"If you specify ports as non-zero for an interface, the driver will use the I/"
"O port given as the device address."
msgstr ""

#: ../../../driver-api/ipmi.rst:420
msgid ""
"If you specify irqs as non-zero for an interface, the driver will attempt to "
"use the given interrupt for the device."
msgstr ""

#: ../../../driver-api/ipmi.rst:423
msgid ""
"The other try... items disable discovery by their corresponding names.  "
"These are all enabled by default, set them to zero to disable them.  The "
"tryplatform disables openfirmware."
msgstr ""

#: ../../../driver-api/ipmi.rst:427
msgid ""
"The next three parameters have to do with register layout.  The registers "
"used by the interfaces may not appear at successive locations and they may "
"not be in 8-bit registers.  These parameters allow the layout of the data in "
"the registers to be more precisely specified."
msgstr ""

#: ../../../driver-api/ipmi.rst:433
msgid ""
"The regspacings parameter give the number of bytes between successive "
"register start addresses.  For instance, if the regspacing is set to 4 and "
"the start address is 0xca2, then the address for the second register would "
"be 0xca6.  This defaults to 1."
msgstr ""

#: ../../../driver-api/ipmi.rst:438
msgid ""
"The regsizes parameter gives the size of a register, in bytes.  The data "
"used by IPMI is 8-bits wide, but it may be inside a larger register.  This "
"parameter allows the read and write type to be specified. It may be 1, 2, 4, "
"or 8.  The default is 1."
msgstr ""

#: ../../../driver-api/ipmi.rst:443
msgid ""
"Since the register size may be larger than 32 bits, the IPMI data may not be "
"in the lower 8 bits.  The regshifts parameter give the amount to shift the "
"data to get to the actual IPMI data."
msgstr ""

#: ../../../driver-api/ipmi.rst:447 ../../../driver-api/ipmi.rst:555
msgid ""
"The slave_addrs specifies the IPMI address of the local BMC.  This is "
"usually 0x20 and the driver defaults to that, but in case it's not, it can "
"be specified when the driver starts up."
msgstr ""

#: ../../../driver-api/ipmi.rst:451
msgid ""
"The force_ipmid parameter forcefully enables (if set to 1) or disables (if "
"set to 0) the kernel IPMI daemon.  Normally this is auto-detected by the "
"driver, but systems with broken interrupts might need an enable, or users "
"that don't want the daemon (don't need the performance, don't want the CPU "
"hit) can disable it."
msgstr ""

#: ../../../driver-api/ipmi.rst:457
msgid ""
"If unload_when_empty is set to 1, the driver will be unloaded if it doesn't "
"find any interfaces or all the interfaces fail to work.  The default is "
"one.  Setting to 0 is useful with the hotmod, but is obviously only useful "
"for modules."
msgstr ""

#: ../../../driver-api/ipmi.rst:462
msgid ""
"When compiled into the kernel, the parameters can be specified on the kernel "
"command line as::"
msgstr ""

#: ../../../driver-api/ipmi.rst:475
msgid "It works the same as the module parameters of the same names."
msgstr ""

#: ../../../driver-api/ipmi.rst:477
msgid ""
"If your IPMI interface does not support interrupts and is a KCS or SMIC "
"interface, the IPMI driver will start a kernel thread for the interface to "
"help speed things up.  This is a low-priority kernel thread that constantly "
"polls the IPMI driver while an IPMI operation is in progress.  The "
"force_kipmid module parameter will allow the user to force this thread on or "
"off.  If you force it off and don't have interrupts, the driver will run "
"VERY slowly.  Don't blame me, these interfaces suck."
msgstr ""

#: ../../../driver-api/ipmi.rst:486
msgid ""
"Unfortunately, this thread can use a lot of CPU depending on the interface's "
"performance.  This can waste a lot of CPU and cause various issues with "
"detecting idle CPU and using extra power.  To avoid this, the "
"kipmid_max_busy_us sets the maximum amount of time, in microseconds, that "
"kipmid will spin before sleeping for a tick.  This value sets a balance "
"between performance and CPU waste and needs to be tuned to your needs.  "
"Maybe, someday, auto-tuning will be added, but that's not a simple thing and "
"even the auto-tuning would need to be tuned to the user's desired "
"performance."
msgstr ""

#: ../../../driver-api/ipmi.rst:496
msgid ""
"The driver supports a hot add and remove of interfaces.  This way, "
"interfaces can be added or removed after the kernel is up and running. This "
"is done using /sys/modules/ipmi_si/parameters/hotmod, which is a write-only "
"parameter.  You write a string to this interface.  The string has the "
"format::"
msgstr ""

#: ../../../driver-api/ipmi.rst:504
msgid "The \"op\"s are::"
msgstr ""

#: ../../../driver-api/ipmi.rst:508
msgid ""
"You can specify more than one interface on the line.  The \"opt\"s are::"
msgstr ""

#: ../../../driver-api/ipmi.rst:516
msgid ""
"and these have the same meanings as discussed above.  Note that you can also "
"use this on the kernel command line for a more compact format for specifying "
"an interface.  Note that when removing an interface, only the first three "
"parameters (si type, address type, and address) are used for the "
"comparison.  Any options are ignored for removing."
msgstr ""

#: ../../../driver-api/ipmi.rst:523
msgid "The SMBus Driver (SSIF)"
msgstr ""

#: ../../../driver-api/ipmi.rst:525
msgid ""
"The SMBus driver allows up to 4 SMBus devices to be configured in the "
"system.  By default, the driver will only register with something it finds "
"in DMI or ACPI tables.  You can change this at module load time (for a "
"module) with::"
msgstr ""

#: ../../../driver-api/ipmi.rst:539
msgid ""
"The addresses are normal I2C addresses.  The adapter is the string name of "
"the adapter, as shown in /sys/bus/i2c/devices/i2c-<n>/name. It is *NOT* i2c-"
"<n> itself.  Also, the comparison is done ignoring spaces, so if the name is "
"\"This is an I2C chip\" you can say adapter_name=ThisisanI2cchip.  This is "
"because it's hard to pass in spaces in kernel parameters."
msgstr ""

#: ../../../driver-api/ipmi.rst:546
msgid ""
"The debug flags are bit flags for each BMC found, they are: IPMI messages: "
"1, driver state: 2, timing: 4, I2C probe: 8"
msgstr ""

#: ../../../driver-api/ipmi.rst:549
msgid ""
"The tryxxx parameters can be used to disable detecting interfaces from "
"various sources."
msgstr ""

#: ../../../driver-api/ipmi.rst:552
msgid ""
"Setting dbg_probe to 1 will enable debugging of the probing and detection "
"process for BMCs on the SMBusses."
msgstr ""

#: ../../../driver-api/ipmi.rst:559
msgid ""
"alerts_broken does not enable SMBus alert for SSIF. Otherwise SMBus alert "
"will be enabled on supported hardware."
msgstr ""

#: ../../../driver-api/ipmi.rst:562
msgid ""
"Discovering the IPMI compliant BMC on the SMBus can cause devices on the I2C "
"bus to fail. The SMBus driver writes a \"Get Device ID\" IPMI message as a "
"block write to the I2C bus and waits for a response. This action can be "
"detrimental to some I2C devices. It is highly recommended that the known I2C "
"address be given to the SMBus driver in the smb_addr parameter unless you "
"have DMI or ACPI data to tell the driver what to use."
msgstr ""

#: ../../../driver-api/ipmi.rst:570
msgid ""
"When compiled into the kernel, the addresses can be specified on the kernel "
"command line as::"
msgstr ""

#: ../../../driver-api/ipmi.rst:580
msgid "These are the same options as on the module command line."
msgstr ""

#: ../../../driver-api/ipmi.rst:582
msgid ""
"The I2C driver does not support non-blocking access or polling, so this "
"driver cannot do IPMI panic events, extend the watchdog at panic time, or "
"other panic-related IPMI functions without special kernel patches and driver "
"modifications.  You can get those at the openipmi web page."
msgstr ""

#: ../../../driver-api/ipmi.rst:588
msgid ""
"The driver supports a hot add and remove of interfaces through the I2C sysfs "
"interface."
msgstr ""

#: ../../../driver-api/ipmi.rst:592
msgid "The IPMI IPMB Driver"
msgstr ""

#: ../../../driver-api/ipmi.rst:594
msgid ""
"This driver is for supporting a system that sits on an IPMB bus; it allows "
"the interface to look like a normal IPMI interface.  Sending system "
"interface addressed messages to it will cause the message to go to the "
"registered BMC on the system (default at IPMI address 0x20)."
msgstr ""

#: ../../../driver-api/ipmi.rst:599
msgid ""
"It also allows you to directly address other MCs on the bus using the ipmb "
"direct addressing.  You can receive commands from other MCs on the bus and "
"they will be handled through the normal received command mechanism described "
"above."
msgstr ""

#: ../../../driver-api/ipmi.rst:604
msgid "Parameters are::"
msgstr ""

#: ../../../driver-api/ipmi.rst:610
msgid ""
"Loading the module will not result in the driver automatically starting "
"unless there is device tree information setting it up.  If you want to "
"instantiate one of these by hand, do::"
msgstr ""

#: ../../../driver-api/ipmi.rst:616
msgid ""
"Note that the address you give here is the I2C address, not the IPMI "
"address.  So if you want your MC address to be 0x60, you put 0x30 here.  See "
"the I2C driver info for more details."
msgstr ""

#: ../../../driver-api/ipmi.rst:620
msgid ""
"Command bridging to other IPMB buses through this interface does not work.  "
"The receive message queue is not implemented, by design.  There is only one "
"receive message queue on a BMC, and that is meant for the host drivers, not "
"something on the IPMB bus."
msgstr ""

#: ../../../driver-api/ipmi.rst:625
msgid ""
"A BMC may have multiple IPMB buses, which bus your device sits on depends on "
"how the system is wired.  You can fetch the channels with \"ipmitool channel "
"info <n>\" where <n> is the channel, with the channels being 0-7 and try the "
"IPMB channels."
msgstr ""

#: ../../../driver-api/ipmi.rst:631
msgid "Other Pieces"
msgstr ""

#: ../../../driver-api/ipmi.rst:634
msgid "Get the detailed info related with the IPMI device"
msgstr ""

#: ../../../driver-api/ipmi.rst:636
msgid ""
"Some users need more detailed information about a device, like where the "
"address came from or the raw base device for the IPMI interface. You can use "
"the IPMI smi_watcher to catch the IPMI interfaces as they come or go, and to "
"grab the information, you can use the function ipmi_get_smi_info(), which "
"returns the following structure::"
msgstr ""

#: ../../../driver-api/ipmi.rst:652
msgid ""
"Currently special info for only for SI_ACPI address sources is returned.  "
"Others may be added as necessary."
msgstr ""

#: ../../../driver-api/ipmi.rst:655
msgid ""
"Note that the dev pointer is included in the above structure, and assuming "
"ipmi_smi_get_info returns success, you must call put_device on the dev "
"pointer."
msgstr ""

#: ../../../driver-api/ipmi.rst:661
msgid "Watchdog"
msgstr ""

#: ../../../driver-api/ipmi.rst:663
msgid ""
"A watchdog timer is provided that implements the Linux-standard watchdog "
"timer interface.  It has three module parameters that can be used to control "
"it::"
msgstr ""

#: ../../../driver-api/ipmi.rst:671
msgid ""
"ifnum_to_use specifies which interface the watchdog timer should use. The "
"default is -1, which means to pick the first one registered."
msgstr ""

#: ../../../driver-api/ipmi.rst:674
msgid ""
"The timeout is the number of seconds to the action, and the pretimeout is "
"the amount of seconds before the reset that the pre-timeout panic will occur "
"(if pretimeout is zero, then pretimeout will not be enabled).  Note that the "
"pretimeout is the time before the final timeout.  So if the timeout is 50 "
"seconds and the pretimeout is 10 seconds, then the pretimeout will occur in "
"40 second (10 seconds before the timeout). The panic_wdt_timeout is the "
"value of timeout which is set on kernel panic, in order to let actions such "
"as kdump to occur during panic."
msgstr ""

#: ../../../driver-api/ipmi.rst:683
msgid ""
"The action may be \"reset\", \"power_cycle\", or \"power_off\", and "
"specifies what to do when the timer times out, and defaults to \"reset\"."
msgstr ""

#: ../../../driver-api/ipmi.rst:687
msgid ""
"The preaction may be \"pre_smi\" for an indication through the SMI "
"interface, \"pre_int\" for an indication through the SMI with an interrupts, "
"and \"pre_nmi\" for a NMI on a preaction.  This is how the driver is "
"informed of the pretimeout."
msgstr ""

#: ../../../driver-api/ipmi.rst:692
msgid ""
"The preop may be set to \"preop_none\" for no operation on a pretimeout, "
"\"preop_panic\" to set the preoperation to panic, or \"preop_give_data\" to "
"provide data to read from the watchdog device when the pretimeout occurs.  A "
"\"pre_nmi\" setting CANNOT be used with \"preop_give_data\" because you "
"can't do data operations from an NMI."
msgstr ""

#: ../../../driver-api/ipmi.rst:698
msgid ""
"When preop is set to \"preop_give_data\", one byte comes ready to read on "
"the device when the pretimeout occurs.  Select and fasync work on the "
"device, as well."
msgstr ""

#: ../../../driver-api/ipmi.rst:702
msgid ""
"If start_now is set to 1, the watchdog timer will start running as soon as "
"the driver is loaded."
msgstr ""

#: ../../../driver-api/ipmi.rst:705
msgid ""
"If nowayout is set to 1, the watchdog timer will not stop when the watchdog "
"device is closed.  The default value of nowayout is true if the "
"CONFIG_WATCHDOG_NOWAYOUT option is enabled, or false if not."
msgstr ""

#: ../../../driver-api/ipmi.rst:709
msgid ""
"When compiled into the kernel, the kernel command line is available for "
"configuring the watchdog::"
msgstr ""

#: ../../../driver-api/ipmi.rst:720
msgid "The options are the same as the module parameter options."
msgstr ""

#: ../../../driver-api/ipmi.rst:722
msgid ""
"The watchdog will panic and start a 120 second reset timeout if it gets a "
"pre-action.  During a panic or a reboot, the watchdog will start a 120 timer "
"if it is running to make sure the reboot occurs."
msgstr ""

#: ../../../driver-api/ipmi.rst:726
msgid ""
"Note that if you use the NMI preaction for the watchdog, you MUST NOT use "
"the nmi watchdog.  There is no reasonable way to tell if an NMI comes from "
"the IPMI controller, so it must assume that if it gets an otherwise "
"unhandled NMI, it must be from IPMI and it will panic immediately."
msgstr ""

#: ../../../driver-api/ipmi.rst:732
msgid ""
"Once you open the watchdog timer, you must write a 'V' character to the "
"device to close it, or the timer will not stop.  This is a new semantic for "
"the driver, but makes it consistent with the rest of the watchdog drivers in "
"Linux."
msgstr ""

#: ../../../driver-api/ipmi.rst:739
msgid "Panic Timeouts"
msgstr ""

#: ../../../driver-api/ipmi.rst:741
msgid ""
"The OpenIPMI driver supports the ability to put semi-custom and custom "
"events in the system event log if a panic occurs.  if you enable the "
"'Generate a panic event to all BMCs on a panic' option, you will get one "
"event on a panic in a standard IPMI event format.  If you enable the "
"'Generate OEM events containing the panic string' option, you will also get "
"a bunch of OEM events holding the panic string."
msgstr ""

#: ../../../driver-api/ipmi.rst:749
msgid "The field settings of the events are:"
msgstr ""

#: ../../../driver-api/ipmi.rst:751
msgid "Generator ID: 0x21 (kernel)"
msgstr ""

#: ../../../driver-api/ipmi.rst:752
msgid "EvM Rev: 0x03 (this event is formatting in IPMI 1.0 format)"
msgstr ""

#: ../../../driver-api/ipmi.rst:753
msgid "Sensor Type: 0x20 (OS critical stop sensor)"
msgstr ""

#: ../../../driver-api/ipmi.rst:754
msgid "Sensor #: The first byte of the panic string (0 if no panic string)"
msgstr ""

#: ../../../driver-api/ipmi.rst:755
msgid "Event Dir | Event Type: 0x6f (Assertion, sensor-specific event info)"
msgstr ""

#: ../../../driver-api/ipmi.rst:756
msgid "Event Data 1: 0xa1 (Runtime stop in OEM bytes 2 and 3)"
msgstr ""

#: ../../../driver-api/ipmi.rst:757
msgid "Event data 2: second byte of panic string"
msgstr ""

#: ../../../driver-api/ipmi.rst:758
msgid "Event data 3: third byte of panic string"
msgstr ""

#: ../../../driver-api/ipmi.rst:760
msgid ""
"See the IPMI spec for the details of the event layout.  This event is always "
"sent to the local management controller.  It will handle routing the message "
"to the right place"
msgstr ""

#: ../../../driver-api/ipmi.rst:764
msgid "Other OEM events have the following format:"
msgstr ""

#: ../../../driver-api/ipmi.rst:766
msgid "Record ID (bytes 0-1): Set by the SEL."
msgstr ""

#: ../../../driver-api/ipmi.rst:767
msgid "Record type (byte 2): 0xf0 (OEM non-timestamped)"
msgstr ""

#: ../../../driver-api/ipmi.rst:768
msgid "byte 3: The slave address of the card saving the panic"
msgstr ""

#: ../../../driver-api/ipmi.rst:769
msgid ""
"byte 4: A sequence number (starting at zero) The rest of the bytes (11 "
"bytes) are the panic string.  If the panic string is longer than 11 bytes, "
"multiple messages will be sent with increasing sequence numbers."
msgstr ""

#: ../../../driver-api/ipmi.rst:774
msgid ""
"Because you cannot send OEM events using the standard interface, this "
"function will attempt to find an SEL and add the events there.  It will "
"first query the capabilities of the local management controller. If it has "
"an SEL, then they will be stored in the SEL of the local management "
"controller.  If not, and the local management controller is an event "
"generator, the event receiver from the local management controller will be "
"queried and the events sent to the SEL on that device.  Otherwise, the "
"events go nowhere since there is nowhere to send them."
msgstr ""

#: ../../../driver-api/ipmi.rst:786
msgid "Poweroff"
msgstr ""

#: ../../../driver-api/ipmi.rst:788
msgid ""
"If the poweroff capability is selected, the IPMI driver will install a "
"shutdown function into the standard poweroff function pointer.  This is in "
"the ipmi_poweroff module.  When the system requests a powerdown, it will "
"send the proper IPMI commands to do this.  This is supported on several "
"platforms."
msgstr ""

#: ../../../driver-api/ipmi.rst:794
msgid ""
"There is a module parameter named \"poweroff_powercycle\" that may either be "
"zero (do a power down) or non-zero (do a power cycle, power the system off, "
"then power it on in a few seconds).  Setting ipmi_poweroff."
"poweroff_control=x will do the same thing on the kernel command line.  The "
"parameter is also available via the proc filesystem in /proc/sys/dev/ipmi/"
"poweroff_powercycle.  Note that if the system does not support power "
"cycling, it will always do the power off."
msgstr ""

#: ../../../driver-api/ipmi.rst:802
msgid ""
"The \"ifnum_to_use\" parameter specifies which interface the poweroff code "
"should use.  The default is -1, which means to pick the first one registered."
msgstr ""

#: ../../../driver-api/ipmi.rst:806
msgid ""
"Note that if you have ACPI enabled, the system will prefer using ACPI to "
"power off."
msgstr ""
