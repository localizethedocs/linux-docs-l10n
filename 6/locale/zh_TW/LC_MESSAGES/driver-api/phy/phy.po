# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/phy/phy.rst:3
msgid "PHY subsystem"
msgstr ""

#: ../../../driver-api/phy/phy.rst:0
msgid "Author"
msgstr ""

#: ../../../driver-api/phy/phy.rst:5
msgid "Kishon Vijay Abraham I <kishon@ti.com>"
msgstr ""

#: ../../../driver-api/phy/phy.rst:7
msgid ""
"This document explains the Generic PHY Framework along with the APIs "
"provided, and how-to-use."
msgstr ""

#: ../../../driver-api/phy/phy.rst:11
msgid "Introduction"
msgstr ""

#: ../../../driver-api/phy/phy.rst:13
msgid ""
"*PHY* is the abbreviation for physical layer. It is used to connect a device "
"to the physical medium e.g., the USB controller has a PHY to provide "
"functions such as serialization, de-serialization, encoding, decoding and is "
"responsible for obtaining the required data transmission rate. Note that "
"some USB controllers have PHY functionality embedded into it and others use "
"an external PHY. Other peripherals that use PHY include Wireless LAN, "
"Ethernet, SATA etc."
msgstr ""

#: ../../../driver-api/phy/phy.rst:21
msgid ""
"The intention of creating this framework is to bring the PHY drivers spread "
"all over the Linux kernel to drivers/phy to increase code re-use and for "
"better code maintainability."
msgstr ""

#: ../../../driver-api/phy/phy.rst:25
msgid ""
"This framework will be of use only to devices that use external PHY (PHY "
"functionality is not embedded within the controller)."
msgstr ""

#: ../../../driver-api/phy/phy.rst:29
msgid "Registering/Unregistering the PHY provider"
msgstr ""

#: ../../../driver-api/phy/phy.rst:31
msgid ""
"PHY provider refers to an entity that implements one or more PHY instances. "
"For the simple case where the PHY provider implements only a single instance "
"of the PHY, the framework provides its own implementation of of_xlate in "
"of_phy_simple_xlate. If the PHY provider implements multiple instances, it "
"should provide its own implementation of of_xlate. of_xlate is used only for "
"dt boot case."
msgstr ""

#: ../../../driver-api/phy/phy.rst:47
msgid ""
"of_phy_provider_register and devm_of_phy_provider_register macros can be "
"used to register the phy_provider and it takes device and of_xlate as "
"arguments. For the dt boot case, all PHY providers should use one of the "
"above 2 macros to register the PHY provider."
msgstr ""

#: ../../../driver-api/phy/phy.rst:52
msgid ""
"Often the device tree nodes associated with a PHY provider will contain a "
"set of children that each represent a single PHY. Some bindings may nest the "
"child nodes within extra levels for context and extensibility, in which case "
"the low level of_phy_provider_register_full() and "
"devm_of_phy_provider_register_full() macros can be used to override the node "
"containing the children."
msgstr ""

#: ../../../driver-api/phy/phy.rst:71
msgid ""
"devm_of_phy_provider_unregister and of_phy_provider_unregister can be used "
"to unregister the PHY."
msgstr ""

#: ../../../driver-api/phy/phy.rst:75
msgid "Creating the PHY"
msgstr ""

#: ../../../driver-api/phy/phy.rst:77
msgid ""
"The PHY driver should create the PHY in order for other peripheral "
"controllers to make use of it. The PHY framework provides 2 APIs to create "
"the PHY."
msgstr ""

#: ../../../driver-api/phy/phy.rst:88
msgid ""
"The PHY drivers can use one of the above 2 APIs to create the PHY by passing "
"the device pointer and phy ops. phy_ops is a set of function pointers for "
"performing PHY operations such as init, exit, power_on and power_off."
msgstr ""

#: ../../../driver-api/phy/phy.rst:93
msgid ""
"Inorder to dereference the private data (in phy_ops), the phy provider "
"driver can use phy_set_drvdata() after creating the PHY and use "
"phy_get_drvdata() in phy_ops to get back the private data."
msgstr ""

#: ../../../driver-api/phy/phy.rst:98
msgid "Getting a reference to the PHY"
msgstr ""

#: ../../../driver-api/phy/phy.rst:100
msgid ""
"Before the controller can make use of the PHY, it has to get a reference to "
"it. This framework provides the following APIs to get a reference to the PHY."
msgstr ""

#: ../../../driver-api/phy/phy.rst:118
msgid ""
"phy_get, devm_phy_get and devm_phy_optional_get can be used to get the PHY. "
"In the case of dt boot, the string arguments should contain the phy name as "
"given in the dt data and in the case of non-dt boot, it should contain the "
"label of the PHY.  The two devm_phy_get associates the device with the PHY "
"using devres on successful PHY get. On driver detach, release function is "
"invoked on the devres data and devres data is freed. The _optional_get "
"variants should be used when the phy is optional. These functions will never "
"return -ENODEV, but instead return NULL when the phy cannot be found. Some "
"generic drivers, such as ehci, may use multiple phys. In this case, "
"devm_of_phy_get or devm_of_phy_get_by_index can be used to get a phy "
"reference based on name or index."
msgstr ""

#: ../../../driver-api/phy/phy.rst:132
msgid ""
"It should be noted that NULL is a valid phy reference. All phy consumer "
"calls on the NULL phy become NOPs. That is the release calls, the phy_init() "
"and phy_exit() calls, and phy_power_on() and phy_power_off() calls are all "
"NOP when applied to a NULL phy. The NULL phy is useful in devices for "
"handling optional phy devices."
msgstr ""

#: ../../../driver-api/phy/phy.rst:139
msgid "Order of API calls"
msgstr ""

#: ../../../driver-api/phy/phy.rst:141
msgid "The general order of calls should be::"
msgstr ""

#: ../../../driver-api/phy/phy.rst:152
msgid ""
"Some PHY drivers may not implement :c:func:`phy_init` or :c:func:"
"`phy_power_on`, but controllers should always call these functions to be "
"compatible with other PHYs. Some PHYs may require :c:func:`phy_set_mode "
"<phy_set_mode_ext>`, while others may use a default mode (typically "
"configured via devicetree or other firmware). For compatibility, you should "
"always call this function if you know what mode you will be using. "
"Generally, this function should be called after :c:func:`phy_power_on`, "
"although some PHY drivers may allow it at any time."
msgstr ""

#: ../../../driver-api/phy/phy.rst:161
msgid "Releasing a reference to the PHY"
msgstr ""

#: ../../../driver-api/phy/phy.rst:163
msgid ""
"When the controller no longer needs the PHY, it has to release the reference "
"to the PHY it has obtained using the APIs mentioned in the above section. "
"The PHY framework provides 2 APIs to release a reference to the PHY."
msgstr ""

#: ../../../driver-api/phy/phy.rst:172
msgid ""
"Both these APIs are used to release a reference to the PHY and devm_phy_put "
"destroys the devres associated with this PHY."
msgstr ""

#: ../../../driver-api/phy/phy.rst:176
msgid "Destroying the PHY"
msgstr ""

#: ../../../driver-api/phy/phy.rst:178
msgid ""
"When the driver that created the PHY is unloaded, it should destroy the PHY "
"it created using one of the following 2 APIs::"
msgstr ""

#: ../../../driver-api/phy/phy.rst:184
msgid ""
"Both these APIs destroy the PHY and devm_phy_destroy destroys the devres "
"associated with this PHY."
msgstr ""

#: ../../../driver-api/phy/phy.rst:188
msgid "PM Runtime"
msgstr ""

#: ../../../driver-api/phy/phy.rst:190
msgid ""
"This subsystem is pm runtime enabled. So while creating the PHY, "
"pm_runtime_enable of the phy device created by this subsystem is called and "
"while destroying the PHY, pm_runtime_disable is called. Note that the phy "
"device created by this subsystem will be a child of the device that calls "
"phy_create (PHY provider device)."
msgstr ""

#: ../../../driver-api/phy/phy.rst:196
msgid ""
"So pm_runtime_get_sync of the phy_device created by this subsystem will "
"invoke pm_runtime_get_sync of PHY provider device because of parent-child "
"relationship. It should also be noted that phy_power_on and phy_power_off "
"performs phy_pm_runtime_get_sync and phy_pm_runtime_put respectively. There "
"are exported APIs like phy_pm_runtime_get, phy_pm_runtime_get_sync, "
"phy_pm_runtime_put and phy_pm_runtime_put_sync for performing PM operations."
msgstr ""

#: ../../../driver-api/phy/phy.rst:204
msgid "PHY Mappings"
msgstr ""

#: ../../../driver-api/phy/phy.rst:206
msgid ""
"In order to get reference to a PHY without help from DeviceTree, the "
"framework offers lookups which can be compared to clkdev that allow clk "
"structures to be bound to devices. A lookup can be made during runtime when "
"a handle to the struct phy already exists."
msgstr ""

#: ../../../driver-api/phy/phy.rst:211
msgid ""
"The framework offers the following API for registering and unregistering the "
"lookups::"
msgstr ""

#: ../../../driver-api/phy/phy.rst:220
msgid "DeviceTree Binding"
msgstr ""

#: ../../../driver-api/phy/phy.rst:222
msgid ""
"The documentation for PHY dt binding can be found @ Documentation/devicetree/"
"bindings/phy/phy-bindings.txt"
msgstr ""
