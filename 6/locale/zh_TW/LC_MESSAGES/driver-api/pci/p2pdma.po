# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/pci/p2pdma.rst:5
msgid "PCI Peer-to-Peer DMA Support"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:7
msgid ""
"The PCI bus has pretty decent support for performing DMA transfers between "
"two devices on the bus. This type of transaction is henceforth called Peer-"
"to-Peer (or P2P). However, there are a number of issues that make P2P "
"transactions tricky to do in a perfectly safe way."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:12
msgid ""
"For PCIe the routing of Transaction Layer Packets (TLPs) is well-defined up "
"until they reach a host bridge or root port. If the path includes PCIe "
"switches then based on the ACS settings the transaction can route entirely "
"within the PCIe hierarchy and never reach the root port. The kernel will "
"evaluate the PCIe topology and always permit P2P in these well-defined cases."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:18
msgid ""
"However, if the P2P transaction reaches the host bridge then it might have "
"to hairpin back out the same root port, be routed inside the CPU SOC to "
"another PCIe root port, or routed internally to the SOC."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:22
msgid ""
"The PCIe specification doesn't define the forwarding of transactions between "
"hierarchy domains and kernel defaults to blocking such routing. There is an "
"allow list to allow detecting known-good HW, in which case P2P between any "
"two PCIe devices will be permitted."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:27
msgid ""
"Since P2P inherently is doing transactions between two devices it requires "
"two drivers to be co-operating inside the kernel. The providing driver has "
"to convey its MMIO to the consuming driver. To meet the driver model "
"lifecycle rules the MMIO must have all DMA mapping removed, all CPU accesses "
"prevented, all page table mappings undone before the providing driver "
"completes remove()."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:33
msgid ""
"This requires the providing and consuming driver to actively work together "
"to guarantee that the consuming driver has stopped using the MMIO during a "
"removal cycle. This is done by either a synchronous invalidation shutdown or "
"waiting for all usage refcounts to reach zero."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:38
msgid ""
"At the lowest level the P2P subsystem offers a naked struct p2p_provider "
"that delegates lifecycle management to the providing driver. It is expected "
"that drivers using this option will wrap their MMIO memory in DMABUF and use "
"DMABUF to provide an invalidation shutdown. These MMIO addresess have no "
"struct page, and if used with mmap() must create special PTEs. As such there "
"are very few kernel uAPIs that can accept pointers to them; in particular "
"they cannot be used with read()/write(), including O_DIRECT."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:46
msgid ""
"Building on this, the subsystem offers a layer to wrap the MMIO in a "
"ZONE_DEVICE pgmap of MEMORY_DEVICE_PCI_P2PDMA to create struct pages. The "
"lifecycle of pgmap ensures that when the pgmap is destroyed all other "
"drivers have stopped using the MMIO. This option works with O_DIRECT flows, "
"in some cases, if the underlying subsystem supports handling "
"MEMORY_DEVICE_PCI_P2PDMA through FOLL_PCI_P2PDMA. The use of FOLL_LONGTERM "
"is prevented. As this relies on pgmap it also relies on architecture support "
"along with alignment and minimum size limitations."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:57
msgid "Driver Writer's Guide"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:59
msgid ""
"In a given P2P implementation there may be three or more different types of "
"kernel drivers in play:"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:62
msgid ""
"Provider - A driver which provides or publishes P2P resources like memory or "
"doorbell registers to other drivers."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:64
msgid ""
"Client - A driver which makes use of a resource by setting up a DMA "
"transaction to or from it."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:66
msgid ""
"Orchestrator - A driver which orchestrates the flow of data between clients "
"and providers."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:69
msgid ""
"In many cases there could be overlap between these three types (i.e., it may "
"be typical for a driver to be both a provider and a client)."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:72
msgid "For example, in the NVMe Target Copy Offload implementation:"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:74
msgid ""
"The NVMe PCI driver is both a client, provider and orchestrator in that it "
"exposes any CMB (Controller Memory Buffer) as a P2P memory resource "
"(provider), it accepts P2P memory pages as buffers in requests to be used "
"directly (client) and it can also make use of the CMB as submission queue "
"entries (orchestrator)."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:79
msgid ""
"The RDMA driver is a client in this arrangement so that an RNIC can DMA "
"directly to the memory exposed by the NVMe device."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:81
msgid ""
"The NVMe Target driver (nvmet) can orchestrate the data from the RNIC to the "
"P2P memory (CMB) and then to the NVMe device (and vice versa)."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:84
msgid ""
"This is currently the only arrangement supported by the kernel but one could "
"imagine slight tweaks to this that would allow for the same functionality. "
"For example, if a specific RNIC added a BAR with some memory behind it, its "
"driver could add support as a P2P provider and then the NVMe Target could "
"use the RNIC's memory instead of the CMB in cases where the NVMe cards in "
"use do not have CMB support."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:93
msgid "Provider Drivers"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:95
msgid ""
"A provider simply needs to register a BAR (or a portion of a BAR) as a P2P "
"DMA resource using :c:func:`pci_p2pdma_add_resource()`. This will register "
"struct pages for all the specified memory."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:99
msgid ""
"After that it may optionally publish all of its resources as P2P memory "
"using :c:func:`pci_p2pmem_publish()`. This will allow any orchestrator "
"drivers to find and use the memory. When marked in this way, the resource "
"must be regular memory with no side effects."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:104
msgid ""
"For the time being this is fairly rudimentary in that all resources are "
"typically going to be P2P memory. Future work will likely expand this to "
"include other types of resources like doorbells."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:110
msgid "Client Drivers"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:112
msgid ""
"A client driver only has to use the mapping API :c:func:`dma_map_sg()` and :"
"c:func:`dma_unmap_sg()` functions as usual, and the implementation will do "
"the right thing for the P2P capable memory."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:118
msgid "Orchestrator Drivers"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:120
msgid ""
"The first task an orchestrator driver must do is compile a list of all "
"client devices that will be involved in a given transaction. For example, "
"the NVMe Target driver creates a list including the namespace block device "
"and the RNIC in use. If the orchestrator has access to a specific P2P "
"provider to use it may check compatibility using :c:func:"
"`pci_p2pdma_distance()` otherwise it may find a memory provider that's "
"compatible with all clients using  :c:func:`pci_p2pmem_find()`. If more than "
"one provider is supported, the one nearest to all the clients will be chosen "
"first. If more than one provider is an equal distance away, the one returned "
"will be chosen at random (it is not an arbitrary but truly random). This "
"function returns the PCI device to use for the provider with a reference "
"taken and therefore when it's no longer needed it should be returned with "
"pci_dev_put()."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:134
msgid ""
"Once a provider is selected, the orchestrator can then use :c:func:"
"`pci_alloc_p2pmem()` and :c:func:`pci_free_p2pmem()` to allocate P2P memory "
"from the provider. :c:func:`pci_p2pmem_alloc_sgl()` and :c:func:"
"`pci_p2pmem_free_sgl()` are convenience functions for allocating scatter-"
"gather lists with P2P memory."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:141
msgid "Struct Page Caveats"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:143
msgid ""
"While the MEMORY_DEVICE_PCI_P2PDMA pages can be installed in VMAs, "
"pin_user_pages() and related will not return them unless FOLL_PCI_P2PDMA is "
"set."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:146
msgid ""
"The MEMORY_DEVICE_PCI_P2PDMA pages require care to support in the kernel. "
"The KVA is still MMIO and must still be accessed through the normal readX()/"
"writeX()/etc helpers. Direct CPU access (e.g. memcpy) is forbidden, just "
"like any other MMIO mapping. While this will actually work on some "
"architectures, others will experience corruption or just crash in the "
"kernel. Supporting FOLL_PCI_P2PDMA in a subsystem requires scrubbing it to "
"ensure no CPU access happens."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:156
msgid "Usage With DMABUF"
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:158
msgid ""
"DMABUF provides an alternative to the above struct page-based client/"
"provider/orchestrator system and should be used when struct page doesn't "
"exist. In this mode the exporting driver will wrap some of its MMIO in a "
"DMABUF and give the DMABUF FD to userspace."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:163
msgid ""
"Userspace can then pass the FD to an importing driver which will ask the "
"exporting driver to map it to the importer."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:166
msgid ""
"In this case the initiator and target pci_devices are known and the P2P "
"subsystem is used to determine the mapping type. The phys_addr_t-based DMA "
"API is used to establish the dma_addr_t."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:170
msgid ""
"Lifecycle is controlled by DMABUF move_notify(). When the exporting driver "
"wants to remove() it must deliver an invalidation shutdown to all DMABUF "
"importing drivers through move_notify() and synchronously DMA unmap all the "
"MMIO."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:174
msgid ""
"No importing driver can continue to have a DMA map to the MMIO after the "
"exporting driver has destroyed its p2p_provider."
msgstr ""

#: ../../../driver-api/pci/p2pdma.rst:179
msgid "P2P DMA Support Library"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:244
msgid "Initialise peer-to-peer DMA providers"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:248
#: ../drivers/pci/p2pdma.c:299 ../drivers/pci/p2pdma.c:370
#: ../drivers/pci/p2pdma.c:772 ../drivers/pci/p2pdma.c:848
#: ../drivers/pci/p2pdma.c:912 ../drivers/pci/p2pdma.c:949
#: ../drivers/pci/p2pdma.c:966 ../drivers/pci/p2pdma.c:992
#: ../drivers/pci/p2pdma.c:1026 ../drivers/pci/p2pdma.c:1046
#: ../drivers/pci/p2pdma.c:1122 ../drivers/pci/p2pdma.c:1177
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:250
#: ../drivers/pci/p2pdma.c:301 ../drivers/pci/p2pdma.c:372
#: ../drivers/pci/p2pdma.c:914 ../drivers/pci/p2pdma.c:951
#: ../drivers/pci/p2pdma.c:968 ../drivers/pci/p2pdma.c:994
#: ../drivers/pci/p2pdma.c:1028 ../drivers/pci/p2pdma.c:1048
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:245
#: ../drivers/pci/p2pdma.c:296
msgid "The PCI device to enable P2PDMA for"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:247
#: ../drivers/pci/p2pdma.c:299 ../drivers/pci/p2pdma.c:372
#: ../drivers/pci/p2pdma.c:775 ../drivers/pci/p2pdma.c:849
#: ../drivers/pci/p2pdma.c:912 ../drivers/pci/p2pdma.c:1047
#: ../drivers/pci/p2pdma.c:1125 ../drivers/pci/p2pdma.c:1179
msgid "**Description**"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:246
msgid ""
"This function initializes the peer-to-peer DMA infrastructure for a PCI "
"device. It allocates and sets up the necessary data structures to support "
"P2PDMA operations, including mapping type tracking."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:295
msgid "Get peer-to-peer DMA provider"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:298
#: ../drivers/pci/p2pdma.c:369
msgid "``int bar``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:297
msgid "BAR index to get provider"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:298
msgid ""
"This function gets peer-to-peer DMA provider for a PCI device. The lifetime "
"of the provider (and of course the MMIO) is bound to the lifetime of the "
"driver. A driver calling this function must ensure that all references to "
"the provider, and any DMA mappings created for any MMIO, are all cleaned up "
"before the driver remove() completes."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:304
msgid ""
"Since P2P is almost always shared with a second driver this means some "
"system to notify, invalidate and revoke the MMIO's DMA must be in place to "
"use this function. For example a revoke can be built using DMABUF."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:366
msgid "add memory for use as p2p memory"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:367
msgid "the device to add the memory to"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:368
msgid "PCI BAR to add"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:370
#: ../drivers/pci/p2pdma.c:911 ../drivers/pci/p2pdma.c:949
msgid "``size_t size``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:369
msgid "size of the memory to add, may be zero to use the whole BAR"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:371
msgid "``u64 offset``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:370
msgid "offset into the PCI BAR"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:371
msgid ""
"The memory will be given ZONE_DEVICE struct pages so that it may be used "
"with any DMA request."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:768
msgid ""
"Determine the cumulative distance between a p2pdma provider and the clients "
"in use."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:774
msgid "``struct pci_dev *provider``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:770
msgid "p2pdma provider to check against the client list"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:772
#: ../drivers/pci/p2pdma.c:850
msgid "``struct device **clients``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:771
#: ../drivers/pci/p2pdma.c:846
msgid "array of devices to check (NULL-terminated)"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:773
#: ../drivers/pci/p2pdma.c:848
msgid "``int num_clients``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:772
msgid "number of clients in the array"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:774
msgid "``bool verbose``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:773
msgid "if true, print warnings for devices when we return -1"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:774
msgid ""
"Returns -1 if any of the clients are not compatible, otherwise returns a "
"positive number where a lower number is the preferable choice. (If there's "
"one client that's the same as the provider it will return 0, which is best "
"choice)."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:779
msgid ""
"\"compatible\" means the provider and the clients are either all behind the "
"same PCI root port or the host bridges connected to each of the devices are "
"listed in the 'pci_p2pdma_whitelist'."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:844
msgid ""
"find a peer-to-peer DMA memory device compatible with the specified list of "
"clients and shortest distance"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:847
msgid "number of client devices in the list"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:848
msgid ""
"If multiple devices are behind the same switch, the one \"closest\" to the "
"client devices in use will be chosen first. (So if one of the providers is "
"the same as one of the clients, that provider will be used ahead of any "
"other providers that are unrelated). If multiple providers are an equal "
"distance away, one will be chosen at random."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:854
msgid ""
"Returns a pointer to the PCI device with a reference taken (use pci_dev_put "
"to return the reference) or NULL if no compatible device is found. The found "
"provider will also be assigned to the client list."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:908
msgid "allocate peer-to-peer DMA memory"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:909
#: ../drivers/pci/p2pdma.c:989 ../drivers/pci/p2pdma.c:1023
msgid "the device to allocate memory from"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:910
#: ../drivers/pci/p2pdma.c:991
msgid "number of bytes to allocate"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:911
msgid "Returns the allocated memory or NULL on error."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:945
msgid "free peer-to-peer DMA memory"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:946
#: ../drivers/pci/p2pdma.c:964
msgid "the device the memory was allocated from"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:948
#: ../drivers/pci/p2pdma.c:966
msgid "``void *addr``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:947
#: ../drivers/pci/p2pdma.c:965
msgid "address of the memory that was allocated"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:948
msgid "number of bytes that were allocated"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:962
msgid ""
"return the PCI bus address for a given virtual address obtained with "
"pci_alloc_p2pmem()"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:988
msgid "allocate peer-to-peer DMA memory in a scatterlist"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:991
msgid "``unsigned int *nents``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:990
msgid "the number of SG entries in the list"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:992
msgid "``u32 length``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:993
msgid "**Return**"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:993
msgid ""
"``NULL`` on error or :c:type:`struct scatterlist <scatterlist>` pointer and "
"**nents** on success"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1022
msgid "free a scatterlist allocated by pci_p2pmem_alloc_sgl()"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1025
msgid "``struct scatterlist *sgl``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1024
msgid "the allocated scatterlist"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1042
msgid ""
"publish the peer-to-peer DMA memory for use by other devices with "
"pci_p2pmem_find()"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1044
msgid "the device with peer-to-peer DMA memory to publish"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1046
msgid "``bool publish``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1045
msgid "set to true to publish the memory, false to unpublish it"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1046
msgid ""
"Published memory can be used by other PCI device drivers for peer-2-peer DMA "
"operations. Non-published memory is reserved for exclusive use of the device "
"driver that registers the peer-to-peer memory."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1118
msgid "parse a configfs/sysfs attribute store to enable p2pdma"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1124
msgid "``const char *page``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1120
msgid "contents of the value to be stored"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1122
msgid "``struct pci_dev **p2p_dev``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1121
msgid ""
"returns the PCI device that was selected to be used (if one was specified in "
"the stored value)"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1124
msgid "``bool *use_p2pdma``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1123
msgid "returns whether to enable p2pdma or not"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1124
msgid ""
"Parses an attribute value to decide whether to enable p2pdma. The value can "
"select a PCI device (using its full BDF device name) or a boolean (in any "
"format kstrtobool() accepts). A false value disables p2pdma, a true value "
"expects the caller to automatically find a compatible device and specifying "
"a PCI device expects the caller to use the specific provider."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1131
msgid ""
"pci_p2pdma_enable_show() should be used as the show operation for the "
"attribute."
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1134
#: ../drivers/pci/p2pdma.c:1181
msgid "Returns 0 on success"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1173
msgid "show a configfs/sysfs attribute indicating whether p2pdma is enabled"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1179
msgid "``char *page``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1175
msgid "contents of the stored value"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1177
msgid "``struct pci_dev *p2p_dev``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1176
msgid "the selected p2p device (NULL if no device is selected)"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1178
msgid "``bool use_p2pdma``"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1177
msgid "whether p2pdma has been enabled"
msgstr ""

#: ../../../driver-api/pci/p2pdma:181: ../drivers/pci/p2pdma.c:1178
msgid ""
"Attributes that use pci_p2pdma_enable_store() should use this function to "
"show the value of the attribute."
msgstr ""
