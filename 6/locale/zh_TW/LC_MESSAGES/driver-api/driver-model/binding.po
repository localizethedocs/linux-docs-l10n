# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/driver-model/binding.rst:3
msgid "Driver Binding"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:5
msgid ""
"Driver binding is the process of associating a device with a device driver "
"that can control it. Bus drivers have typically handled this because there "
"have been bus-specific structures to represent the devices and the drivers. "
"With generic device and device driver structures, most of the binding can "
"take place using common code."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:13
msgid "Bus"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:15
msgid ""
"The bus type structure contains a list of all devices that are on that bus "
"type in the system. When device_register is called for a device, it is "
"inserted into the end of this list. The bus object also contains a list of "
"all drivers of that bus type. When driver_register is called for a driver, "
"it is inserted at the end of this list. These are the two events which "
"trigger driver binding."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:24
msgid "device_register"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:26
msgid ""
"When a new device is added, the bus's list of drivers is iterated over to "
"find one that supports it. In order to determine that, the device ID of the "
"device must match one of the device IDs that the driver supports. The format "
"and semantics for comparing IDs is bus-specific. Instead of trying to derive "
"a complex state machine and matching algorithm, it is up to the bus driver "
"to provide a callback to compare a device against the IDs of a driver. The "
"bus returns 1 if a match was found; 0 otherwise."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:35
msgid "int match(struct device * dev, struct device_driver * drv);"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:37
msgid ""
"If a match is found, the device's driver field is set to the driver and the "
"driver's probe callback is called. This gives the driver a chance to verify "
"that it really does support the hardware, and that it's in a working state."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:43
msgid "Device Class"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:45
msgid ""
"Upon the successful completion of probe, the device is registered with the "
"class to which it belongs. Device drivers belong to one and only one class, "
"and that is set in the driver's devclass field. devclass_add_device is "
"called to enumerate the device within the class and actually register it "
"with the class, which happens with the class's register_dev callback."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:54
msgid "Driver"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:56
msgid ""
"When a driver is attached to a device, the device is inserted into the "
"driver's list of devices."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:61
msgid "sysfs"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:63
msgid ""
"A symlink is created in the bus's 'devices' directory that points to the "
"device's directory in the physical hierarchy."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:66
msgid ""
"A symlink is created in the driver's 'devices' directory that points to the "
"device's directory in the physical hierarchy."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:69
msgid ""
"A directory for the device is created in the class's directory. A symlink is "
"created in that directory that points to the device's physical location in "
"the sysfs tree."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:73
msgid ""
"A symlink can be created (though this isn't done yet) in the device's "
"physical directory to either its class directory, or the class's top-level "
"directory. One can also be created to point to its driver's directory also."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:80
msgid "driver_register"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:82
msgid ""
"The process is almost identical for when a new driver is added. The bus's "
"list of devices is iterated over to find a match. Devices that already have "
"a driver are skipped. All the devices are iterated over, to bind as many "
"devices as possible to the driver."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:89
msgid "Removal"
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:91
msgid ""
"When a device is removed, the reference count for it will eventually go to "
"0. When it does, the remove callback of the driver is called. It is removed "
"from the driver's list of devices and the reference count of the driver is "
"decremented. All symlinks between the two are removed."
msgstr ""

#: ../../../driver-api/driver-model/binding.rst:96
msgid ""
"When a driver is removed, the list of devices that it supports is iterated "
"over, and the driver's remove callback is called for each one. The device is "
"removed from that list and the symlinks removed."
msgstr ""
