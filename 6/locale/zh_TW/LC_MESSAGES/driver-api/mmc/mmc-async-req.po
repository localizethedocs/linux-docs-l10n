# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/mmc/mmc-async-req.rst:3
msgid "MMC Asynchronous Request"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:6
msgid "Rationale"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:8
msgid "How significant is the cache maintenance overhead?"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:10
msgid ""
"It depends. Fast eMMC and multiple cache levels with speculative cache pre-"
"fetch makes the cache overhead relatively significant. If the DMA "
"preparations for the next request are done in parallel with the current "
"transfer, the DMA preparation overhead would not affect the MMC performance."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:15
msgid ""
"The intention of non-blocking (asynchronous) MMC requests is to minimize the "
"time between when an MMC request ends and another MMC request begins."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:18
msgid ""
"Using mmc_wait_for_req(), the MMC controller is idle while dma_map_sg and "
"dma_unmap_sg are processing. Using non-blocking MMC requests makes it "
"possible to prepare the caches for next job in parallel with an active MMC "
"request."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:24
msgid "MMC block driver"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:26
msgid "The mmc_blk_issue_rw_rq() in the MMC block driver is made non-blocking."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:28
msgid ""
"The increase in throughput is proportional to the time it takes to prepare "
"(major part of preparations are dma_map_sg() and dma_unmap_sg()) a request "
"and how fast the memory is. The faster the MMC/SD is the more significant "
"the prepare request time becomes. Roughly the expected performance gain is "
"5% for large writes and 10% on large reads on a L2 cache platform. In power "
"save mode, when clocks run on a lower frequency, the DMA preparation may "
"cost even more. As long as these slower preparations are run in parallel "
"with the transfer performance won't be affected."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:38
msgid "Details on measurements from IOZone and mmc_test"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:40
msgid ""
"https://wiki.linaro.org/WorkingGroups/Kernel/Specs/StoragePerfMMC-async-req"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:43
msgid "MMC core API extension"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:45
msgid "There is one new public function mmc_start_req()."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:47
msgid ""
"It starts a new MMC command request for a host. The function isn't truly non-"
"blocking. If there is an ongoing async request it waits for completion of "
"that request and starts the new one and returns. It doesn't wait for the new "
"request to complete. If there is no ongoing request it starts the new "
"request and returns immediately."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:54
msgid "MMC host extensions"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:56
msgid ""
"There are two optional members in the mmc_host_ops -- pre_req() and "
"post_req() -- that the host driver may implement in order to move work to "
"before and after the actual mmc_host_ops.request() function is called."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:60
msgid ""
"In the DMA case pre_req() may do dma_map_sg() and prepare the DMA "
"descriptor, and post_req() runs the dma_unmap_sg()."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:64
msgid "Optimize for the first request"
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:66
msgid ""
"The first request in a series of requests can't be prepared in parallel with "
"the previous transfer, since there is no previous request."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:69
msgid ""
"The argument is_first_req in pre_req() indicates that there is no previous "
"request. The host driver may optimize for this scenario to minimize the "
"performance loss. A way to optimize for this is to split the current request "
"in two chunks, prepare the first chunk and start the request, and finally "
"prepare the second chunk and start the transfer."
msgstr ""

#: ../../../driver-api/mmc/mmc-async-req.rst:75
msgid ""
"Pseudocode to handle is_first_req scenario with minimal prepare overhead::"
msgstr ""
