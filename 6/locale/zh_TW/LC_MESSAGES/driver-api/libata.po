# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-10 10:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/libata.rst:3
msgid "libATA Developer's Guide"
msgstr ""

#: ../../../driver-api/libata.rst:0
msgid "Author"
msgstr "作者"

#: ../../../driver-api/libata.rst:5
msgid "Jeff Garzik"
msgstr ""

#: ../../../driver-api/libata.rst:8
msgid "Introduction"
msgstr "介紹"

#: ../../../driver-api/libata.rst:10
msgid ""
"libATA is a library used inside the Linux kernel to support ATA host "
"controllers and devices. libATA provides an ATA driver API, class transports "
"for ATA and ATAPI devices, and SCSI<->ATA translation for ATA devices "
"according to the T10 SAT specification."
msgstr ""

#: ../../../driver-api/libata.rst:15
msgid ""
"This Guide documents the libATA driver API, library functions, library "
"internals, and a couple sample ATA low-level drivers."
msgstr ""

#: ../../../driver-api/libata.rst:19
msgid "libata Driver API"
msgstr ""

#: ../../../driver-api/libata.rst:21
msgid ""
":c:type:`struct ata_port_operations <ata_port_operations>` is defined for "
"every low-level libata hardware driver, and it controls how the low-level "
"driver interfaces with the ATA and SCSI layers."
msgstr ""

#: ../../../driver-api/libata.rst:26
msgid ""
"FIS-based drivers will hook into the system with ``->qc_prep()`` and ``-"
">qc_issue()`` high-level hooks. Hardware which behaves in a manner similar "
"to PCI IDE hardware may utilize several generic helpers, defining at a bare "
"minimum the bus I/O addresses of the ATA shadow register blocks."
msgstr ""

#: ../../../driver-api/libata.rst:33
msgid ":c:type:`struct ata_port_operations <ata_port_operations>`"
msgstr ""

#: ../../../driver-api/libata.rst:36
msgid "Post-IDENTIFY device configuration"
msgstr ""

#: ../../../driver-api/libata.rst:43
msgid ""
"Called after IDENTIFY [PACKET] DEVICE is issued to each device found. "
"Typically used to apply device-specific fixups prior to issue of SET "
"FEATURES - XFER MODE, and prior to operation."
msgstr ""

#: ../../../driver-api/libata.rst:47
msgid "This entry may be specified as NULL in ata_port_operations."
msgstr ""

#: ../../../driver-api/libata.rst:50
msgid "Set PIO/DMA mode"
msgstr ""

#: ../../../driver-api/libata.rst:60
msgid ""
"Hooks called prior to the issue of SET FEATURES - XFER MODE command. The "
"optional ``->mode_filter()`` hook is called when libata has built a mask of "
"the possible modes. This is passed to the ``->mode_filter()`` function which "
"should return a mask of valid modes after filtering those unsuitable due to "
"hardware limits. It is not valid to use this interface to add modes."
msgstr ""

#: ../../../driver-api/libata.rst:67
msgid ""
"``dev->pio_mode`` and ``dev->dma_mode`` are guaranteed to be valid when ``-"
">set_piomode()`` and when ``->set_dmamode()`` is called. The timings for any "
"other drive sharing the cable will also be valid at this point. That is the "
"library records the decisions for the modes of each drive on a channel "
"before it attempts to set any of them."
msgstr ""

#: ../../../driver-api/libata.rst:73
msgid ""
"``->post_set_mode()`` is called unconditionally, after the SET FEATURES - "
"XFER MODE command completes successfully."
msgstr ""

#: ../../../driver-api/libata.rst:76
msgid ""
"``->set_piomode()`` is always called (if present), but ``->set_dma_mode()`` "
"is only called if DMA is possible."
msgstr ""

#: ../../../driver-api/libata.rst:80
msgid "Taskfile read/write"
msgstr ""

#: ../../../driver-api/libata.rst:88
msgid ""
"``->tf_load()`` is called to load the given taskfile into hardware "
"registers / DMA buffers. ``->tf_read()`` is called to read the hardware "
"registers / DMA buffers, to obtain the current set of taskfile register "
"values. Most drivers for taskfile-based hardware (PIO or MMIO) use :c:func:"
"`ata_sff_tf_load` and :c:func:`ata_sff_tf_read` for these hooks."
msgstr ""

#: ../../../driver-api/libata.rst:95
msgid "PIO data read/write"
msgstr ""

#: ../../../driver-api/libata.rst:102
msgid ""
"All bmdma-style drivers must implement this hook. This is the low-level "
"operation that actually copies the data bytes during a PIO data transfer. "
"Typically the driver will choose one of :c:func:`ata_sff_data_xfer`, or :c:"
"func:`ata_sff_data_xfer32`."
msgstr ""

#: ../../../driver-api/libata.rst:108
msgid "ATA command execute"
msgstr ""

#: ../../../driver-api/libata.rst:115
msgid ""
"causes an ATA command, previously loaded with ``->tf_load()``, to be "
"initiated in hardware. Most drivers for taskfile-based hardware use :c:func:"
"`ata_sff_exec_command` for this hook."
msgstr ""

#: ../../../driver-api/libata.rst:120
msgid "Per-cmd ATAPI DMA capabilities filter"
msgstr ""

#: ../../../driver-api/libata.rst:127 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:4658
msgid ""
"Allow low-level driver to filter ATA PACKET commands, returning a status "
"indicating whether or not it is OK to use DMA for the supplied PACKET "
"command."
msgstr ""

#: ../../../driver-api/libata.rst:131
msgid ""
"This hook may be specified as NULL, in which case libata will assume that "
"atapi dma can be supported."
msgstr ""

#: ../../../driver-api/libata.rst:135
msgid "Read specific ATA shadow registers"
msgstr ""

#: ../../../driver-api/libata.rst:143
msgid ""
"Reads the Status/AltStatus ATA shadow register from hardware. On some "
"hardware, reading the Status register has the side effect of clearing the "
"interrupt condition. Most drivers for taskfile-based hardware use :c:func:"
"`ata_sff_check_status` for this hook."
msgstr ""

#: ../../../driver-api/libata.rst:149
msgid "Write specific ATA shadow register"
msgstr ""

#: ../../../driver-api/libata.rst:156
msgid ""
"Write the device control ATA shadow register to the hardware. Most drivers "
"don't need to define this."
msgstr ""

#: ../../../driver-api/libata.rst:160
msgid "Select ATA device on bus"
msgstr ""

#: ../../../driver-api/libata.rst:167
msgid ""
"Issues the low-level hardware command(s) that causes one of N hardware "
"devices to be considered 'selected' (active and available for use) on the "
"ATA bus. This generally has no meaning on FIS-based devices."
msgstr ""

#: ../../../driver-api/libata.rst:171
msgid ""
"Most drivers for taskfile-based hardware use :c:func:`ata_sff_dev_select` "
"for this hook."
msgstr ""

#: ../../../driver-api/libata.rst:175
msgid "Private tuning method"
msgstr ""

#: ../../../driver-api/libata.rst:182
msgid ""
"By default libata performs drive and controller tuning in accordance with "
"the ATA timing rules and also applies blacklists and cable limits. Some "
"controllers need special handling and have custom tuning rules, typically "
"raid controllers that use ATA commands but do not actually do drive timing."
msgstr ""

#: ../../../driver-api/libata.rst:188
msgid "**Warning**"
msgstr ""

#: ../../../driver-api/libata.rst:190
msgid ""
"This hook should not be used to replace the standard controller tuning logic "
"when a controller has quirks. Replacing the default tuning logic in that "
"case would bypass handling for drive and bridge quirks that may be important "
"to data reliability. If a controller needs to filter the mode selection it "
"should use the mode_filter hook instead."
msgstr ""

#: ../../../driver-api/libata.rst:198
msgid "Control PCI IDE BMDMA engine"
msgstr ""

#: ../../../driver-api/libata.rst:208
msgid ""
"When setting up an IDE BMDMA transaction, these hooks arm (``-"
">bmdma_setup``), fire (``->bmdma_start``), and halt (``->bmdma_stop``) the "
"hardware's DMA engine. ``->bmdma_status`` is used to read the standard PCI "
"IDE DMA Status register."
msgstr ""

#: ../../../driver-api/libata.rst:213
msgid ""
"These hooks are typically either no-ops, or simply not implemented, in FIS-"
"based drivers."
msgstr ""

#: ../../../driver-api/libata.rst:216
msgid ""
"Most legacy IDE drivers use :c:func:`ata_bmdma_setup` for the :c:func:"
"`bmdma_setup` hook. :c:func:`ata_bmdma_setup` will write the pointer to the "
"PRD table to the IDE PRD Table Address register, enable DMA in the DMA "
"Command register, and call :c:func:`exec_command` to begin the transfer."
msgstr ""

#: ../../../driver-api/libata.rst:221
msgid ""
"Most legacy IDE drivers use :c:func:`ata_bmdma_start` for the :c:func:"
"`bmdma_start` hook. :c:func:`ata_bmdma_start` will write the ATA_DMA_START "
"flag to the DMA Command register."
msgstr ""

#: ../../../driver-api/libata.rst:225
msgid ""
"Many legacy IDE drivers use :c:func:`ata_bmdma_stop` for the :c:func:"
"`bmdma_stop` hook. :c:func:`ata_bmdma_stop` clears the ATA_DMA_START flag in "
"the DMA command register."
msgstr ""

#: ../../../driver-api/libata.rst:229
msgid ""
"Many legacy IDE drivers use :c:func:`ata_bmdma_status` as the :c:func:"
"`bmdma_status` hook."
msgstr ""

#: ../../../driver-api/libata.rst:233
msgid "High-level taskfile hooks"
msgstr ""

#: ../../../driver-api/libata.rst:241
msgid ""
"Higher-level hooks, these two hooks can potentially supersede several of the "
"above taskfile/DMA engine hooks. ``->qc_prep`` is called after the buffers "
"have been DMA-mapped, and is typically used to populate the hardware's DMA "
"scatter-gather table. Some drivers use the standard :c:func:"
"`ata_bmdma_qc_prep` and :c:func:`ata_bmdma_dumb_qc_prep` helper functions, "
"but more advanced drivers roll their own."
msgstr ""

#: ../../../driver-api/libata.rst:248
msgid ""
"``->qc_issue`` is used to make a command active, once the hardware and S/G "
"tables have been prepared. IDE BMDMA drivers use the helper function :c:func:"
"`ata_sff_qc_issue` for taskfile protocol-based dispatch. More advanced "
"drivers implement their own ``->qc_issue``."
msgstr ""

#: ../../../driver-api/libata.rst:253
msgid ""
":c:func:`ata_sff_qc_issue` calls ``->sff_tf_load()``, ``->bmdma_setup()``, "
"and ``->bmdma_start()`` as necessary to initiate a transfer."
msgstr ""

#: ../../../driver-api/libata.rst:257
msgid "Exception and probe handling (EH)"
msgstr ""

#: ../../../driver-api/libata.rst:265
msgid ""
":c:func:`ata_port_freeze` is called when HSM violations or some other "
"condition disrupts normal operation of the port. A frozen port is not "
"allowed to perform any operation until the port is thawed, which usually "
"follows a successful reset."
msgstr ""

#: ../../../driver-api/libata.rst:270
msgid ""
"The optional ``->freeze()`` callback can be used for freezing the port "
"hardware-wise (e.g. mask interrupt and stop DMA engine). If a port cannot be "
"frozen hardware-wise, the interrupt handler must ack and clear interrupts "
"unconditionally while the port is frozen."
msgstr ""

#: ../../../driver-api/libata.rst:275
msgid ""
"The optional ``->thaw()`` callback is called to perform the opposite of ``-"
">freeze()``: prepare the port for normal operation once again. Unmask "
"interrupts, start DMA engine, etc."
msgstr ""

#: ../../../driver-api/libata.rst:284
msgid ""
"``->error_handler()`` is a driver's hook into probe, hotplug, and recovery "
"and other exceptional conditions. The primary responsibility of an "
"implementation is to call :c:func:`ata_std_error_handler`."
msgstr ""

#: ../../../driver-api/libata.rst:288
msgid ""
":c:func:`ata_std_error_handler` will perform a standard error handling "
"sequence to resurect failed devices, detach lost devices and add new devices "
"(if any). This function will call the various reset operations for a port, "
"as needed. These operations are as follows."
msgstr ""

#: ../../../driver-api/libata.rst:293
msgid ""
"The 'prereset' operation (which may be NULL) is called during an EH reset, "
"before any other action is taken."
msgstr ""

#: ../../../driver-api/libata.rst:296
msgid ""
"The 'postreset' hook (which may be NULL) is called after the EH reset is "
"performed. Based on existing conditions, severity of the problem, and "
"hardware capabilities,"
msgstr ""

#: ../../../driver-api/libata.rst:300
msgid ""
"Either the 'softreset' operation or the 'hardreset' operation will be called "
"to perform the low-level EH reset. If both operations are defined, "
"'hardreset' is preferred and used. If both are not defined, no low-level "
"reset is performed and EH assumes that an ATA class device is connected "
"through the link."
msgstr ""

#: ../../../driver-api/libata.rst:311
msgid ""
"Perform any hardware-specific actions necessary to finish processing after "
"executing a probe-time or EH-time command via :c:func:`ata_exec_internal`."
msgstr ""

#: ../../../driver-api/libata.rst:316
msgid "Hardware interrupt handling"
msgstr ""

#: ../../../driver-api/libata.rst:324
msgid ""
"``->irq_handler`` is the interrupt handling routine registered with the "
"system, by libata. ``->irq_clear`` is called during probe just before the "
"interrupt handler is registered, to be sure hardware is quiet."
msgstr ""

#: ../../../driver-api/libata.rst:328
msgid ""
"The second argument, dev_instance, should be cast to a pointer to :c:type:"
"`struct ata_host_set <ata_host_set>`."
msgstr ""

#: ../../../driver-api/libata.rst:331
msgid ""
"Most legacy IDE drivers use :c:func:`ata_sff_interrupt` for the irq_handler "
"hook, which scans all ports in the host_set, determines which queued command "
"was active (if any), and calls ata_sff_host_intr(ap,qc)."
msgstr ""

#: ../../../driver-api/libata.rst:335
msgid ""
"Most legacy IDE drivers use :c:func:`ata_sff_irq_clear` for the :c:func:"
"`irq_clear` hook, which simply clears the interrupt and error flags in the "
"DMA status register."
msgstr ""

#: ../../../driver-api/libata.rst:340
msgid "SATA phy read/write"
msgstr ""

#: ../../../driver-api/libata.rst:350
msgid ""
"Read and write standard SATA phy registers. sc_reg is one of SCR_STATUS, "
"SCR_CONTROL, SCR_ERROR, or SCR_ACTIVE."
msgstr ""

#: ../../../driver-api/libata.rst:354
msgid "Init and shutdown"
msgstr ""

#: ../../../driver-api/libata.rst:363
msgid ""
"``->port_start()`` is called just after the data structures for each port "
"are initialized. Typically this is used to alloc per-port DMA buffers / "
"tables / rings, enable DMA engines, and similar tasks. Some drivers also use "
"this entry point as a chance to allocate driver-private memory for ``ap-"
">private_data``."
msgstr ""

#: ../../../driver-api/libata.rst:369
msgid ""
"Many drivers use :c:func:`ata_port_start` as this hook or call it from their "
"own :c:func:`port_start` hooks. :c:func:`ata_port_start` allocates space for "
"a legacy IDE PRD table and returns."
msgstr ""

#: ../../../driver-api/libata.rst:373
msgid ""
"``->port_stop()`` is called after ``->host_stop()``. Its sole function is to "
"release DMA/memory resources, now that they are no longer actively being "
"used. Many drivers also free driver-private data from port at this time."
msgstr ""

#: ../../../driver-api/libata.rst:377
msgid ""
"``->host_stop()`` is called after all ``->port_stop()`` calls have "
"completed. The hook must finalize hardware shutdown, release DMA and other "
"resources, etc. This hook may be specified as NULL, in which case it is not "
"called."
msgstr ""

#: ../../../driver-api/libata.rst:383
msgid "Error handling"
msgstr ""

#: ../../../driver-api/libata.rst:385
msgid ""
"This chapter describes how errors are handled under libata. Readers are "
"advised to read SCSI EH (Documentation/scsi/scsi_eh.rst) and ATA exceptions "
"doc first."
msgstr ""

#: ../../../driver-api/libata.rst:390
msgid "Origins of commands"
msgstr ""

#: ../../../driver-api/libata.rst:392
msgid ""
"In libata, a command is represented with :c:type:`struct ata_queued_cmd "
"<ata_queued_cmd>` or qc. qc's are preallocated during port initialization "
"and repetitively used for command executions. Currently only one qc is "
"allocated per port but yet-to-be-merged NCQ branch allocates one for each "
"tag and maps each qc to NCQ tag 1-to-1."
msgstr ""

#: ../../../driver-api/libata.rst:399
msgid ""
"libata commands can originate from two sources - libata itself and SCSI "
"midlayer. libata internal commands are used for initialization and error "
"handling. All normal blk requests and commands for SCSI emulation are passed "
"as SCSI commands through queuecommand callback of SCSI host template."
msgstr ""

#: ../../../driver-api/libata.rst:406
msgid "How commands are issued"
msgstr ""

#: ../../../driver-api/libata.rst:408
msgid "Internal commands"
msgstr ""

#: ../../../driver-api/libata.rst:409
msgid ""
"Once allocated qc's taskfile is initialized for the command to be executed. "
"qc currently has two mechanisms to notify completion. One is via ``qc-"
">complete_fn()`` callback and the other is completion ``qc->waiting``. ``qc-"
">complete_fn()`` callback is the asynchronous path used by normal SCSI "
"translated commands and ``qc->waiting`` is the synchronous (issuer sleeps in "
"process context) path used by internal commands."
msgstr ""

#: ../../../driver-api/libata.rst:417
msgid ""
"Once initialization is complete, host_set lock is acquired and the qc is "
"issued."
msgstr ""

#: ../../../driver-api/libata.rst:420
msgid "SCSI commands"
msgstr ""

#: ../../../driver-api/libata.rst:421
msgid ""
"All libata drivers use :c:func:`ata_scsi_queuecmd` as ``hostt-"
">queuecommand`` callback. scmds can either be simulated or translated. No qc "
"is involved in processing a simulated scmd. The result is computed right "
"away and the scmd is completed."
msgstr ""

#: ../../../driver-api/libata.rst:426
msgid ""
"``qc->complete_fn()`` callback is used for completion notification. ATA "
"commands use :c:func:`ata_scsi_qc_complete` while ATAPI commands use :c:func:"
"`atapi_qc_complete`. Both functions end up calling ``qc->scsidone`` to "
"notify upper layer when the qc is finished. After translation is completed, "
"the qc is issued with :c:func:`ata_qc_issue`."
msgstr ""

#: ../../../driver-api/libata.rst:432
msgid ""
"Note that SCSI midlayer invokes hostt->queuecommand while holding host_set "
"lock, so all above occur while holding host_set lock."
msgstr ""

#: ../../../driver-api/libata.rst:436
msgid "How commands are processed"
msgstr ""

#: ../../../driver-api/libata.rst:438
msgid ""
"Depending on which protocol and which controller are used, commands are "
"processed differently. For the purpose of discussion, a controller which "
"uses taskfile interface and all standard callbacks is assumed."
msgstr ""

#: ../../../driver-api/libata.rst:442
msgid ""
"Currently 6 ATA command protocols are used. They can be sorted into the "
"following four categories according to how they are processed."
msgstr ""

#: ../../../driver-api/libata.rst:445
msgid "ATA NO DATA or DMA"
msgstr ""

#: ../../../driver-api/libata.rst:446
msgid ""
"ATA_PROT_NODATA and ATA_PROT_DMA fall into this category. These types of "
"commands don't require any software intervention once issued. Device will "
"raise interrupt on completion."
msgstr ""

#: ../../../driver-api/libata.rst:450
msgid "ATA PIO"
msgstr ""

#: ../../../driver-api/libata.rst:451
msgid ""
"ATA_PROT_PIO is in this category. libata currently implements PIO with "
"polling. ATA_NIEN bit is set to turn off interrupt and pio_task on ata_wq "
"performs polling and IO."
msgstr ""

#: ../../../driver-api/libata.rst:455
msgid "ATAPI NODATA or DMA"
msgstr ""

#: ../../../driver-api/libata.rst:456
msgid ""
"ATA_PROT_ATAPI_NODATA and ATA_PROT_ATAPI_DMA are in this category. "
"packet_task is used to poll BSY bit after issuing PACKET command. Once BSY "
"is turned off by the device, packet_task transfers CDB and hands off "
"processing to interrupt handler."
msgstr ""

#: ../../../driver-api/libata.rst:461
msgid "ATAPI PIO"
msgstr ""

#: ../../../driver-api/libata.rst:462
msgid ""
"ATA_PROT_ATAPI is in this category. ATA_NIEN bit is set and, as in ATAPI "
"NODATA or DMA, packet_task submits cdb. However, after submitting cdb, "
"further processing (data transfer) is handed off to pio_task."
msgstr ""

#: ../../../driver-api/libata.rst:468
msgid "How commands are completed"
msgstr ""

#: ../../../driver-api/libata.rst:470
msgid ""
"Once issued, all qc's are either completed with :c:func:`ata_qc_complete` or "
"time out. For commands which are handled by interrupts, :c:func:"
"`ata_host_intr` invokes :c:func:`ata_qc_complete`, and, for PIO tasks, "
"pio_task invokes :c:func:`ata_qc_complete`. In error cases, packet_task may "
"also complete commands."
msgstr ""

#: ../../../driver-api/libata.rst:476
msgid ":c:func:`ata_qc_complete` does the following."
msgstr ""

#: ../../../driver-api/libata.rst:478
msgid "DMA memory is unmapped."
msgstr ""

#: ../../../driver-api/libata.rst:480
msgid "ATA_QCFLAG_ACTIVE is cleared from qc->flags."
msgstr ""

#: ../../../driver-api/libata.rst:482
msgid ""
":c:expr:`qc->complete_fn` callback is invoked. If the return value of the "
"callback is not zero. Completion is short circuited and :c:func:"
"`ata_qc_complete` returns."
msgstr ""

#: ../../../driver-api/libata.rst:486
msgid ":c:func:`__ata_qc_complete` is called, which does"
msgstr ""

#: ../../../driver-api/libata.rst:488
msgid "``qc->flags`` is cleared to zero."
msgstr ""

#: ../../../driver-api/libata.rst:490
msgid "``ap->active_tag`` and ``qc->tag`` are poisoned."
msgstr ""

#: ../../../driver-api/libata.rst:492
msgid "``qc->waiting`` is cleared & completed (in that order)."
msgstr ""

#: ../../../driver-api/libata.rst:494
msgid "qc is deallocated by clearing appropriate bit in ``ap->qactive``."
msgstr ""

#: ../../../driver-api/libata.rst:496
msgid ""
"So, it basically notifies upper layer and deallocates qc. One exception is "
"short-circuit path in #3 which is used by :c:func:`atapi_qc_complete`."
msgstr ""

#: ../../../driver-api/libata.rst:499
msgid ""
"For all non-ATAPI commands, whether it fails or not, almost the same code "
"path is taken and very little error handling takes place. A qc is completed "
"with success status if it succeeded, with failed status otherwise."
msgstr ""

#: ../../../driver-api/libata.rst:504
msgid ""
"However, failed ATAPI commands require more handling as REQUEST SENSE is "
"needed to acquire sense data. If an ATAPI command fails, :c:func:"
"`ata_qc_complete` is invoked with error status, which in turn invokes :c:"
"func:`atapi_qc_complete` via ``qc->complete_fn()`` callback."
msgstr ""

#: ../../../driver-api/libata.rst:509
msgid ""
"This makes :c:func:`atapi_qc_complete` set ``scmd->result`` to "
"SAM_STAT_CHECK_CONDITION, complete the scmd and return 1. As the sense data "
"is empty but ``scmd->result`` is CHECK CONDITION, SCSI midlayer will invoke "
"EH for the scmd, and returning 1 makes :c:func:`ata_qc_complete` to return "
"without deallocating the qc. This leads us to :c:func:`ata_scsi_error` with "
"partially completed qc."
msgstr ""

#: ../../../driver-api/libata.rst:517
msgid ":c:func:`ata_scsi_error`"
msgstr ""

#: ../../../driver-api/libata.rst:519
msgid ""
":c:func:`ata_scsi_error` is the current ``transportt-"
">eh_strategy_handler()`` for libata. As discussed above, this will be "
"entered in two cases - timeout and ATAPI error completion. This function "
"will check if a qc is active and has not failed yet. Such a qc will be "
"marked with AC_ERR_TIMEOUT such that EH will know to handle it later. Then "
"it calls low level libata driver's :c:func:`error_handler` callback."
msgstr ""

#: ../../../driver-api/libata.rst:526
msgid ""
"When the :c:func:`error_handler` callback is invoked it stops BMDMA and "
"completes the qc. Note that as we're currently in EH, we cannot call "
"scsi_done. As described in SCSI EH doc, a recovered scmd should be either "
"retried with :c:func:`scsi_queue_insert` or finished with :c:func:"
"`scsi_finish_command`. Here, we override ``qc->scsidone`` with :c:func:"
"`scsi_finish_command` and calls :c:func:`ata_qc_complete`."
msgstr ""

#: ../../../driver-api/libata.rst:533
msgid ""
"If EH is invoked due to a failed ATAPI qc, the qc here is completed but not "
"deallocated. The purpose of this half-completion is to use the qc as place "
"holder to make EH code reach this place. This is a bit hackish, but it works."
msgstr ""

#: ../../../driver-api/libata.rst:538
msgid ""
"Once control reaches here, the qc is deallocated by invoking :c:func:"
"`__ata_qc_complete` explicitly. Then, internal qc for REQUEST SENSE is "
"issued. Once sense data is acquired, scmd is finished by directly invoking :"
"c:func:`scsi_finish_command` on the scmd. Note that as we already have "
"completed and deallocated the qc which was associated with the scmd, we "
"don't need to/cannot call :c:func:`ata_qc_complete` again."
msgstr ""

#: ../../../driver-api/libata.rst:546
msgid "Problems with the current EH"
msgstr ""

#: ../../../driver-api/libata.rst:548
msgid ""
"Error representation is too crude. Currently any and all error conditions "
"are represented with ATA STATUS and ERROR registers. Errors which aren't ATA "
"device errors are treated as ATA device errors by setting ATA_ERR bit. "
"Better error descriptor which can properly represent ATA and other errors/"
"exceptions is needed."
msgstr ""

#: ../../../driver-api/libata.rst:554
msgid ""
"When handling timeouts, no action is taken to make device forget about the "
"timed out command and ready for new commands."
msgstr ""

#: ../../../driver-api/libata.rst:557
msgid ""
"EH handling via :c:func:`ata_scsi_error` is not properly protected from "
"usual command processing. On EH entrance, the device is not in quiescent "
"state. Timed out commands may succeed or fail any time. pio_task and "
"atapi_task may still be running."
msgstr ""

#: ../../../driver-api/libata.rst:562
msgid ""
"Too weak error recovery. Devices / controllers causing HSM mismatch errors "
"and other errors quite often require reset to return to known state. Also, "
"advanced error handling is necessary to support features like NCQ and "
"hotplug."
msgstr ""

#: ../../../driver-api/libata.rst:567
msgid ""
"ATA errors are directly handled in the interrupt handler and PIO errors in "
"pio_task. This is problematic for advanced error handling for the following "
"reasons."
msgstr ""

#: ../../../driver-api/libata.rst:571
msgid ""
"First, advanced error handling often requires context and internal qc "
"execution."
msgstr ""

#: ../../../driver-api/libata.rst:574
msgid ""
"Second, even a simple failure (say, CRC error) needs information gathering "
"and could trigger complex error handling (say, resetting & reconfiguring). "
"Having multiple code paths to gather information, enter EH and trigger "
"actions makes life painful."
msgstr ""

#: ../../../driver-api/libata.rst:579
msgid ""
"Third, scattered EH code makes implementing low level drivers difficult. Low "
"level drivers override libata callbacks. If EH is scattered over several "
"places, each affected callbacks should perform its part of error handling. "
"This can be error prone and painful."
msgstr ""

#: ../../../driver-api/libata.rst:585
msgid "libata Library"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:164
msgid "link iteration helper"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:168
#: ../drivers/ata/libata-core.c:228 ../drivers/ata/libata-core.c:530
#: ../drivers/ata/libata-core.c:848 ../drivers/ata/libata-core.c:904
#: ../drivers/ata/libata-core.c:929 ../drivers/ata/libata-core.c:953
#: ../drivers/ata/libata-core.c:976 ../drivers/ata/libata-core.c:1036
#: ../drivers/ata/libata-core.c:1093 ../drivers/ata/libata-core.c:1130
#: ../drivers/ata/libata-core.c:1428 ../drivers/ata/libata-core.c:1672
#: ../drivers/ata/libata-core.c:1729 ../drivers/ata/libata-core.c:3196
#: ../drivers/ata/libata-core.c:3210 ../drivers/ata/libata-core.c:3224
#: ../drivers/ata/libata-core.c:3237 ../drivers/ata/libata-core.c:3250
#: ../drivers/ata/libata-core.c:3291 ../drivers/ata/libata-core.c:3534
#: ../drivers/ata/libata-core.c:3721 ../drivers/ata/libata-core.c:3744
#: ../drivers/ata/libata-core.c:3790 ../drivers/ata/libata-core.c:4581
#: ../drivers/ata/libata-core.c:4691 ../drivers/ata/libata-core.c:4914
#: ../drivers/ata/libata-core.c:5029 ../drivers/ata/libata-core.c:5177
#: ../drivers/ata/libata-core.c:5204 ../drivers/ata/libata-core.c:5402
#: ../drivers/ata/libata-core.c:5415 ../drivers/ata/libata-core.c:5540
#: ../drivers/ata/libata-core.c:5652 ../drivers/ata/libata-core.c:5721
#: ../drivers/ata/libata-core.c:5838 ../drivers/ata/libata-core.c:5919
#: ../drivers/ata/libata-core.c:5983 ../drivers/ata/libata-core.c:6069
#: ../drivers/ata/libata-core.c:6216 ../drivers/ata/libata-core.c:6239
#: ../drivers/ata/libata-core.c:6370 ../drivers/ata/libata-core.c:6678
#: ../drivers/ata/libata-core.c:6711 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:282 ../drivers/ata/libata-core.c:308
#: ../drivers/ata/libata-core.c:340 ../drivers/ata/libata-core.c:369
#: ../drivers/ata/libata-core.c:427 ../drivers/ata/libata-core.c:481
#: ../drivers/ata/libata-core.c:599 ../drivers/ata/libata-core.c:642
#: ../drivers/ata/libata-core.c:711 ../drivers/ata/libata-core.c:873
#: ../drivers/ata/libata-core.c:1201 ../drivers/ata/libata-core.c:1252
#: ../drivers/ata/libata-core.c:1310 ../drivers/ata/libata-core.c:1406
#: ../drivers/ata/libata-core.c:1505 ../drivers/ata/libata-core.c:1706
#: ../drivers/ata/libata-core.c:1747 ../drivers/ata/libata-core.c:2010
#: ../drivers/ata/libata-core.c:2056 ../drivers/ata/libata-core.c:2094
#: ../drivers/ata/libata-core.c:2898 ../drivers/ata/libata-core.c:3263
#: ../drivers/ata/libata-core.c:3310 ../drivers/ata/libata-core.c:3362
#: ../drivers/ata/libata-core.c:3634 ../drivers/ata/libata-core.c:3815
#: ../drivers/ata/libata-core.c:3864 ../drivers/ata/libata-core.c:3897
#: ../drivers/ata/libata-core.c:4393 ../drivers/ata/libata-core.c:4408
#: ../drivers/ata/libata-core.c:4459 ../drivers/ata/libata-core.c:4536
#: ../drivers/ata/libata-core.c:4618 ../drivers/ata/libata-core.c:4660
#: ../drivers/ata/libata-core.c:4722 ../drivers/ata/libata-core.c:4745
#: ../drivers/ata/libata-core.c:4769 ../drivers/ata/libata-core.c:4805
#: ../drivers/ata/libata-core.c:4827 ../drivers/ata/libata-core.c:5053
#: ../drivers/ata/libata-core.c:5129 ../drivers/ata/libata-core.c:5153
#: ../drivers/ata/libata-core.c:5435 ../drivers/ata/libata-core.c:5470
#: ../drivers/ata/libata-core.c:5507 ../drivers/ata/libata-core.c:5788
#: ../drivers/ata/libata-core.c:6132 ../drivers/ata/libata-core.c:6149
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:180
#: ../drivers/ata/libata-eh.c:200 ../drivers/ata/libata-eh.c:224
#: ../drivers/ata/libata-eh.c:240 ../drivers/ata/libata-eh.c:269
#: ../drivers/ata/libata-eh.c:323 ../drivers/ata/libata-eh.c:349
#: ../drivers/ata/libata-eh.c:465 ../drivers/ata/libata-eh.c:483
#: ../drivers/ata/libata-eh.c:552 ../drivers/ata/libata-eh.c:585
#: ../drivers/ata/libata-eh.c:689 ../drivers/ata/libata-eh.c:814
#: ../drivers/ata/libata-eh.c:903 ../drivers/ata/libata-eh.c:940
#: ../drivers/ata/libata-eh.c:965 ../drivers/ata/libata-eh.c:984
#: ../drivers/ata/libata-eh.c:1005 ../drivers/ata/libata-eh.c:1045
#: ../drivers/ata/libata-eh.c:1063 ../drivers/ata/libata-eh.c:1081
#: ../drivers/ata/libata-eh.c:1109 ../drivers/ata/libata-eh.c:1131
#: ../drivers/ata/libata-eh.c:1150 ../drivers/ata/libata-eh.c:1195
#: ../drivers/ata/libata-eh.c:1209 ../drivers/ata/libata-eh.c:1228
#: ../drivers/ata/libata-eh.c:1248 ../drivers/ata/libata-eh.c:1291
#: ../drivers/ata/libata-eh.c:1327 ../drivers/ata/libata-eh.c:1349
#: ../drivers/ata/libata-eh.c:1388 ../drivers/ata/libata-eh.c:1419
#: ../drivers/ata/libata-eh.c:1456 ../drivers/ata/libata-eh.c:1511
#: ../drivers/ata/libata-eh.c:1569 ../drivers/ata/libata-eh.c:1618
#: ../drivers/ata/libata-eh.c:1762 ../drivers/ata/libata-eh.c:1862
#: ../drivers/ata/libata-eh.c:1953 ../drivers/ata/libata-eh.c:1973
#: ../drivers/ata/libata-eh.c:2111 ../drivers/ata/libata-eh.c:2261
#: ../drivers/ata/libata-eh.c:2401 ../drivers/ata/libata-eh.c:2447
#: ../drivers/ata/libata-eh.c:2569 ../drivers/ata/libata-eh.c:2764
#: ../drivers/ata/libata-eh.c:3423 ../drivers/ata/libata-eh.c:3476
#: ../drivers/ata/libata-eh.c:3524 ../drivers/ata/libata-eh.c:3769
#: ../drivers/ata/libata-eh.c:4017 ../drivers/ata/libata-eh.c:4076
#: ../drivers/ata/libata-eh.c:4113 ../drivers/ata/libata-eh.c:4190
#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:356
#: ../drivers/ata/libata-scsi.c:386 ../drivers/ata/libata-scsi.c:1046
#: ../drivers/ata/libata-scsi.c:1143 ../drivers/ata/libata-scsi.c:1179
#: ../drivers/ata/libata-scsi.c:1204 ../drivers/ata/libata-scsi.c:4372
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:242
#: ../drivers/ata/libata-scsi.c:416 ../drivers/ata/libata-scsi.c:456
#: ../drivers/ata/libata-scsi.c:564 ../drivers/ata/libata-scsi.c:728
#: ../drivers/ata/libata-scsi.c:802 ../drivers/ata/libata-scsi.c:977
#: ../drivers/ata/libata-scsi.c:1240 ../drivers/ata/libata-scsi.c:1301
#: ../drivers/ata/libata-scsi.c:1332 ../drivers/ata/libata-scsi.c:1348
#: ../drivers/ata/libata-scsi.c:1364 ../drivers/ata/libata-scsi.c:1380
#: ../drivers/ata/libata-scsi.c:1392 ../drivers/ata/libata-scsi.c:1535
#: ../drivers/ata/libata-scsi.c:1699 ../drivers/ata/libata-scsi.c:1784
#: ../drivers/ata/libata-scsi.c:1822 ../drivers/ata/libata-scsi.c:1911
#: ../drivers/ata/libata-scsi.c:1949 ../drivers/ata/libata-scsi.c:1977
#: ../drivers/ata/libata-scsi.c:2039 ../drivers/ata/libata-scsi.c:2077
#: ../drivers/ata/libata-scsi.c:2128 ../drivers/ata/libata-scsi.c:2158
#: ../drivers/ata/libata-scsi.c:2181 ../drivers/ata/libata-scsi.c:2219
#: ../drivers/ata/libata-scsi.c:2257 ../drivers/ata/libata-scsi.c:2308
#: ../drivers/ata/libata-scsi.c:2331 ../drivers/ata/libata-scsi.c:2473
#: ../drivers/ata/libata-scsi.c:2509 ../drivers/ata/libata-scsi.c:2526
#: ../drivers/ata/libata-scsi.c:2658 ../drivers/ata/libata-scsi.c:2746
#: ../drivers/ata/libata-scsi.c:2824 ../drivers/ata/libata-scsi.c:2969
#: ../drivers/ata/libata-scsi.c:3035 ../drivers/ata/libata-scsi.c:3301
#: ../drivers/ata/libata-scsi.c:3355 ../drivers/ata/libata-scsi.c:3468
#: ../drivers/ata/libata-scsi.c:3569 ../drivers/ata/libata-scsi.c:3801
#: ../drivers/ata/libata-scsi.c:3953 ../drivers/ata/libata-scsi.c:3979
#: ../drivers/ata/libata-scsi.c:4222 ../drivers/ata/libata-scsi.c:4250
#: ../drivers/ata/libata-scsi.c:4417 ../drivers/ata/libata-scsi.c:4641
#: ../drivers/ata/libata-scsi.c:4664 ../drivers/ata/libata-scsi.c:4744
#: ../drivers/ata/libata-scsi.c:4761 ../drivers/ata/libata-scsi.c:4799
#: ../drivers/ata/libata-scsi.c:4866 ../../../driver-api/libata:979:
#: ../drivers/ata/ata_piix.c:500 ../drivers/ata/ata_piix.c:535
#: ../drivers/ata/ata_piix.c:641 ../drivers/ata/ata_piix.c:657
#: ../drivers/ata/ata_piix.c:736 ../drivers/ata/ata_piix.c:752
#: ../drivers/ata/ata_piix.c:1312 ../drivers/ata/ata_piix.c:1633
#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:341
#: ../drivers/ata/sata_sil.c:588
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:170
#: ../drivers/ata/libata-core.c:227 ../drivers/ata/libata-core.c:3536
#: ../drivers/ata/libata-core.c:3723 ../drivers/ata/libata-core.c:3746
#: ../drivers/ata/libata-core.c:3792 ../drivers/ata/libata-core.c:5179
#: ../drivers/ata/libata-core.c:5206 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:371 ../drivers/ata/libata-core.c:3265
#: ../drivers/ata/libata-core.c:3636 ../drivers/ata/libata-core.c:5131
#: ../drivers/ata/libata-core.c:5155 ../drivers/ata/libata-core.c:5469
#: ../drivers/ata/libata-core.c:5509 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:1047 ../drivers/ata/libata-eh.c:1293
#: ../drivers/ata/libata-eh.c:1329 ../drivers/ata/libata-eh.c:1571
#: ../drivers/ata/libata-eh.c:2113 ../drivers/ata/libata-eh.c:2263
#: ../drivers/ata/libata-eh.c:2571 ../drivers/ata/libata-eh.c:3425
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:537
#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:343
msgid "``struct ata_link *link``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:165
msgid "the previous link, NULL to start"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:167
#: ../drivers/ata/libata-core.c:3198 ../drivers/ata/libata-core.c:3212
#: ../drivers/ata/libata-core.c:3226 ../drivers/ata/libata-core.c:3239
#: ../drivers/ata/libata-core.c:3252 ../drivers/ata/libata-core.c:5031
#: ../drivers/ata/libata-core.c:6680 ../drivers/ata/libata-core.c:6713
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:310
#: ../drivers/ata/libata-core.c:342 ../drivers/ata/libata-core.c:4410
#: ../drivers/ata/libata-core.c:5472 ../drivers/ata/libata-core.c:6151
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:242
#: ../drivers/ata/libata-eh.c:271 ../drivers/ata/libata-eh.c:467
#: ../drivers/ata/libata-eh.c:485 ../drivers/ata/libata-eh.c:584
#: ../drivers/ata/libata-eh.c:688 ../drivers/ata/libata-eh.c:816
#: ../drivers/ata/libata-eh.c:905 ../drivers/ata/libata-eh.c:967
#: ../drivers/ata/libata-eh.c:986 ../drivers/ata/libata-eh.c:1007
#: ../drivers/ata/libata-eh.c:1065 ../drivers/ata/libata-eh.c:1083
#: ../drivers/ata/libata-eh.c:1111 ../drivers/ata/libata-eh.c:1133
#: ../drivers/ata/libata-eh.c:1152 ../drivers/ata/libata-eh.c:2403
#: ../drivers/ata/libata-eh.c:2766 ../drivers/ata/libata-eh.c:3771
#: ../drivers/ata/libata-eh.c:4019 ../drivers/ata/libata-eh.c:4078
#: ../drivers/ata/libata-eh.c:4115 ../drivers/ata/libata-eh.c:4192
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:418
#: ../drivers/ata/libata-scsi.c:2971 ../../../driver-api/libata:979:
#: ../drivers/ata/ata_piix.c:502 ../drivers/ata/ata_piix.c:643
#: ../drivers/ata/ata_piix.c:659 ../drivers/ata/ata_piix.c:738
#: ../drivers/ata/ata_piix.c:754
msgid "``struct ata_port *ap``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:166
msgid "ATA port containing links to iterate"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:168
msgid "``enum ata_link_iter_mode mode``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:167
msgid "iteration mode, one of ATA_LITER_*"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:169
#: ../drivers/ata/libata-core.c:229 ../drivers/ata/libata-core.c:529
#: ../drivers/ata/libata-core.c:849 ../drivers/ata/libata-core.c:903
#: ../drivers/ata/libata-core.c:928 ../drivers/ata/libata-core.c:952
#: ../drivers/ata/libata-core.c:975 ../drivers/ata/libata-core.c:1035
#: ../drivers/ata/libata-core.c:1095 ../drivers/ata/libata-core.c:1132
#: ../drivers/ata/libata-core.c:1427 ../drivers/ata/libata-core.c:1671
#: ../drivers/ata/libata-core.c:1730 ../drivers/ata/libata-core.c:3195
#: ../drivers/ata/libata-core.c:3209 ../drivers/ata/libata-core.c:3223
#: ../drivers/ata/libata-core.c:3236 ../drivers/ata/libata-core.c:3249
#: ../drivers/ata/libata-core.c:3290 ../drivers/ata/libata-core.c:3534
#: ../drivers/ata/libata-core.c:3722 ../drivers/ata/libata-core.c:3744
#: ../drivers/ata/libata-core.c:3790 ../drivers/ata/libata-core.c:4582
#: ../drivers/ata/libata-core.c:4690 ../drivers/ata/libata-core.c:4913
#: ../drivers/ata/libata-core.c:5028 ../drivers/ata/libata-core.c:5176
#: ../drivers/ata/libata-core.c:5203 ../drivers/ata/libata-core.c:5402
#: ../drivers/ata/libata-core.c:5414 ../drivers/ata/libata-core.c:5539
#: ../drivers/ata/libata-core.c:5652 ../drivers/ata/libata-core.c:5722
#: ../drivers/ata/libata-core.c:5837 ../drivers/ata/libata-core.c:5983
#: ../drivers/ata/libata-core.c:6072 ../drivers/ata/libata-core.c:6215
#: ../drivers/ata/libata-core.c:6238 ../drivers/ata/libata-core.c:6369
#: ../drivers/ata/libata-core.c:6678 ../drivers/ata/libata-core.c:6715
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:281
#: ../drivers/ata/libata-core.c:307 ../drivers/ata/libata-core.c:339
#: ../drivers/ata/libata-core.c:368 ../drivers/ata/libata-core.c:426
#: ../drivers/ata/libata-core.c:480 ../drivers/ata/libata-core.c:599
#: ../drivers/ata/libata-core.c:642 ../drivers/ata/libata-core.c:715
#: ../drivers/ata/libata-core.c:875 ../drivers/ata/libata-core.c:1201
#: ../drivers/ata/libata-core.c:1252 ../drivers/ata/libata-core.c:1309
#: ../drivers/ata/libata-core.c:1406 ../drivers/ata/libata-core.c:1510
#: ../drivers/ata/libata-core.c:1705 ../drivers/ata/libata-core.c:1749
#: ../drivers/ata/libata-core.c:2009 ../drivers/ata/libata-core.c:2055
#: ../drivers/ata/libata-core.c:2097 ../drivers/ata/libata-core.c:2897
#: ../drivers/ata/libata-core.c:3262 ../drivers/ata/libata-core.c:3310
#: ../drivers/ata/libata-core.c:3362 ../drivers/ata/libata-core.c:3635
#: ../drivers/ata/libata-core.c:3816 ../drivers/ata/libata-core.c:3864
#: ../drivers/ata/libata-core.c:3898 ../drivers/ata/libata-core.c:4392
#: ../drivers/ata/libata-core.c:4407 ../drivers/ata/libata-core.c:4458
#: ../drivers/ata/libata-core.c:4535 ../drivers/ata/libata-core.c:4619
#: ../drivers/ata/libata-core.c:4659 ../drivers/ata/libata-core.c:4723
#: ../drivers/ata/libata-core.c:4744 ../drivers/ata/libata-core.c:4768
#: ../drivers/ata/libata-core.c:4805 ../drivers/ata/libata-core.c:4826
#: ../drivers/ata/libata-core.c:5052 ../drivers/ata/libata-core.c:5128
#: ../drivers/ata/libata-core.c:5152 ../drivers/ata/libata-core.c:5434
#: ../drivers/ata/libata-core.c:5471 ../drivers/ata/libata-core.c:5506
#: ../drivers/ata/libata-core.c:5787 ../drivers/ata/libata-core.c:6131
#: ../drivers/ata/libata-core.c:6148 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:3 ../drivers/ata/libata-eh.c:223
#: ../drivers/ata/libata-eh.c:271 ../drivers/ata/libata-eh.c:323
#: ../drivers/ata/libata-eh.c:349 ../drivers/ata/libata-eh.c:464
#: ../drivers/ata/libata-eh.c:482 ../drivers/ata/libata-eh.c:551
#: ../drivers/ata/libata-eh.c:586 ../drivers/ata/libata-eh.c:689
#: ../drivers/ata/libata-eh.c:813 ../drivers/ata/libata-eh.c:903
#: ../drivers/ata/libata-eh.c:939 ../drivers/ata/libata-eh.c:964
#: ../drivers/ata/libata-eh.c:983 ../drivers/ata/libata-eh.c:1004
#: ../drivers/ata/libata-eh.c:1044 ../drivers/ata/libata-eh.c:1062
#: ../drivers/ata/libata-eh.c:1080 ../drivers/ata/libata-eh.c:1108
#: ../drivers/ata/libata-eh.c:1130 ../drivers/ata/libata-eh.c:1149
#: ../drivers/ata/libata-eh.c:1194 ../drivers/ata/libata-eh.c:1208
#: ../drivers/ata/libata-eh.c:1227 ../drivers/ata/libata-eh.c:1247
#: ../drivers/ata/libata-eh.c:1292 ../drivers/ata/libata-eh.c:1328
#: ../drivers/ata/libata-eh.c:1348 ../drivers/ata/libata-eh.c:1388
#: ../drivers/ata/libata-eh.c:1418 ../drivers/ata/libata-eh.c:1455
#: ../drivers/ata/libata-eh.c:1512 ../drivers/ata/libata-eh.c:1568
#: ../drivers/ata/libata-eh.c:1617 ../drivers/ata/libata-eh.c:1761
#: ../drivers/ata/libata-eh.c:1863 ../drivers/ata/libata-eh.c:1952
#: ../drivers/ata/libata-eh.c:1972 ../drivers/ata/libata-eh.c:2112
#: ../drivers/ata/libata-eh.c:2260 ../drivers/ata/libata-eh.c:2400
#: ../drivers/ata/libata-eh.c:2446 ../drivers/ata/libata-eh.c:2568
#: ../drivers/ata/libata-eh.c:2763 ../drivers/ata/libata-eh.c:3423
#: ../drivers/ata/libata-eh.c:3475 ../drivers/ata/libata-eh.c:3523
#: ../drivers/ata/libata-eh.c:3770 ../drivers/ata/libata-eh.c:4016
#: ../drivers/ata/libata-eh.c:4075 ../drivers/ata/libata-eh.c:4112
#: ../drivers/ata/libata-eh.c:4189 ../../../driver-api/libata:601:
#: ../drivers/ata/libata-scsi.c:358 ../drivers/ata/libata-scsi.c:385
#: ../drivers/ata/libata-scsi.c:1045 ../drivers/ata/libata-scsi.c:1142
#: ../drivers/ata/libata-scsi.c:1179 ../drivers/ata/libata-scsi.c:1203
#: ../drivers/ata/libata-scsi.c:4372 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:241 ../drivers/ata/libata-scsi.c:417
#: ../drivers/ata/libata-scsi.c:456 ../drivers/ata/libata-scsi.c:564
#: ../drivers/ata/libata-scsi.c:728 ../drivers/ata/libata-scsi.c:805
#: ../drivers/ata/libata-scsi.c:976 ../drivers/ata/libata-scsi.c:1239
#: ../drivers/ata/libata-scsi.c:1300 ../drivers/ata/libata-scsi.c:1337
#: ../drivers/ata/libata-scsi.c:1353 ../drivers/ata/libata-scsi.c:1369
#: ../drivers/ata/libata-scsi.c:1379 ../drivers/ata/libata-scsi.c:1391
#: ../drivers/ata/libata-scsi.c:1534 ../drivers/ata/libata-scsi.c:1700
#: ../drivers/ata/libata-scsi.c:1785 ../drivers/ata/libata-scsi.c:1823
#: ../drivers/ata/libata-scsi.c:1912 ../drivers/ata/libata-scsi.c:1950
#: ../drivers/ata/libata-scsi.c:1978 ../drivers/ata/libata-scsi.c:2040
#: ../drivers/ata/libata-scsi.c:2078 ../drivers/ata/libata-scsi.c:2130
#: ../drivers/ata/libata-scsi.c:2160 ../drivers/ata/libata-scsi.c:2183
#: ../drivers/ata/libata-scsi.c:2221 ../drivers/ata/libata-scsi.c:2258
#: ../drivers/ata/libata-scsi.c:2310 ../drivers/ata/libata-scsi.c:2332
#: ../drivers/ata/libata-scsi.c:2475 ../drivers/ata/libata-scsi.c:2509
#: ../drivers/ata/libata-scsi.c:2527 ../drivers/ata/libata-scsi.c:2659
#: ../drivers/ata/libata-scsi.c:2747 ../drivers/ata/libata-scsi.c:2823
#: ../drivers/ata/libata-scsi.c:2969 ../drivers/ata/libata-scsi.c:3034
#: ../drivers/ata/libata-scsi.c:3303 ../drivers/ata/libata-scsi.c:3354
#: ../drivers/ata/libata-scsi.c:3469 ../drivers/ata/libata-scsi.c:3568
#: ../drivers/ata/libata-scsi.c:3803 ../drivers/ata/libata-scsi.c:3956
#: ../drivers/ata/libata-scsi.c:3978 ../drivers/ata/libata-scsi.c:4221
#: ../drivers/ata/libata-scsi.c:4250 ../drivers/ata/libata-scsi.c:4417
#: ../drivers/ata/libata-scsi.c:4640 ../drivers/ata/libata-scsi.c:4663
#: ../drivers/ata/libata-scsi.c:4743 ../drivers/ata/libata-scsi.c:4760
#: ../drivers/ata/libata-scsi.c:4801 ../drivers/ata/libata-scsi.c:4865
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:499
#: ../drivers/ata/ata_piix.c:535 ../drivers/ata/ata_piix.c:641
#: ../drivers/ata/ata_piix.c:658 ../drivers/ata/ata_piix.c:736
#: ../drivers/ata/ata_piix.c:752 ../drivers/ata/ata_piix.c:1311
#: ../drivers/ata/ata_piix.c:1633 ../../../driver-api/libata:985:
#: ../drivers/ata/sata_sil.c:341 ../drivers/ata/sata_sil.c:587
msgid "**Description**"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:168
#: ../drivers/ata/libata-core.c:228
msgid "LOCKING: Host lock or EH context."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:171
#: ../drivers/ata/libata-core.c:231 ../drivers/ata/libata-core.c:533
#: ../drivers/ata/libata-core.c:854 ../drivers/ata/libata-core.c:908
#: ../drivers/ata/libata-core.c:932 ../drivers/ata/libata-core.c:956
#: ../drivers/ata/libata-core.c:980 ../drivers/ata/libata-core.c:1041
#: ../drivers/ata/libata-core.c:1434 ../drivers/ata/libata-core.c:3541
#: ../drivers/ata/libata-core.c:3726 ../drivers/ata/libata-core.c:3752
#: ../drivers/ata/libata-core.c:4586 ../drivers/ata/libata-core.c:4697
#: ../drivers/ata/libata-core.c:5030 ../drivers/ata/libata-core.c:5184
#: ../drivers/ata/libata-core.c:5211 ../drivers/ata/libata-core.c:5544
#: ../drivers/ata/libata-core.c:5659 ../drivers/ata/libata-core.c:5729
#: ../drivers/ata/libata-core.c:5845 ../drivers/ata/libata-core.c:5990
#: ../drivers/ata/libata-core.c:6083 ../drivers/ata/libata-core.c:6726
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:287
#: ../drivers/ata/libata-core.c:648 ../drivers/ata/libata-core.c:1203
#: ../drivers/ata/libata-core.c:1253 ../drivers/ata/libata-core.c:1312
#: ../drivers/ata/libata-core.c:1518 ../drivers/ata/libata-core.c:1759
#: ../drivers/ata/libata-core.c:2101 ../drivers/ata/libata-core.c:2902
#: ../drivers/ata/libata-core.c:3317 ../drivers/ata/libata-core.c:3368
#: ../drivers/ata/libata-core.c:3645 ../drivers/ata/libata-core.c:3822
#: ../drivers/ata/libata-core.c:3869 ../drivers/ata/libata-core.c:3903
#: ../drivers/ata/libata-core.c:4540 ../drivers/ata/libata-core.c:4621
#: ../drivers/ata/libata-core.c:4665 ../drivers/ata/libata-core.c:4772
#: ../drivers/ata/libata-core.c:5134 ../drivers/ata/libata-core.c:5158
#: ../drivers/ata/libata-core.c:5511 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:327 ../drivers/ata/libata-eh.c:555
#: ../drivers/ata/libata-eh.c:1048 ../drivers/ata/libata-eh.c:1066
#: ../drivers/ata/libata-eh.c:1114 ../drivers/ata/libata-eh.c:1354
#: ../drivers/ata/libata-eh.c:1392 ../drivers/ata/libata-eh.c:1442
#: ../drivers/ata/libata-eh.c:1460 ../drivers/ata/libata-eh.c:1517
#: ../drivers/ata/libata-eh.c:1623 ../drivers/ata/libata-eh.c:1810
#: ../drivers/ata/libata-eh.c:1870 ../drivers/ata/libata-eh.c:2119
#: ../drivers/ata/libata-eh.c:3429 ../drivers/ata/libata-eh.c:3481
#: ../drivers/ata/libata-eh.c:3532 ../drivers/ata/libata-eh.c:3779
#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:365
#: ../drivers/ata/libata-scsi.c:1052 ../drivers/ata/libata-scsi.c:4381
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:419
#: ../drivers/ata/libata-scsi.c:458 ../drivers/ata/libata-scsi.c:566
#: ../drivers/ata/libata-scsi.c:738 ../drivers/ata/libata-scsi.c:1246
#: ../drivers/ata/libata-scsi.c:1305 ../drivers/ata/libata-scsi.c:1395
#: ../drivers/ata/libata-scsi.c:1544 ../drivers/ata/libata-scsi.c:1715
#: ../drivers/ata/libata-scsi.c:2825 ../drivers/ata/libata-scsi.c:2976
#: ../drivers/ata/libata-scsi.c:3035 ../drivers/ata/libata-scsi.c:3315
#: ../drivers/ata/libata-scsi.c:4223 ../drivers/ata/libata-scsi.c:4252
#: ../drivers/ata/libata-scsi.c:4646 ../drivers/ata/libata-scsi.c:4806
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1638
msgid "**Return**"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:172
msgid "Pointer to the next link."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:224
msgid "device iteration helper"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:230
#: ../drivers/ata/libata-core.c:1731 ../drivers/ata/libata-core.c:4583
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:284
#: ../drivers/ata/libata-core.c:429 ../drivers/ata/libata-core.c:483
#: ../drivers/ata/libata-core.c:601 ../drivers/ata/libata-core.c:641
#: ../drivers/ata/libata-core.c:1203 ../drivers/ata/libata-core.c:1254
#: ../drivers/ata/libata-core.c:1312 ../drivers/ata/libata-core.c:1408
#: ../drivers/ata/libata-core.c:1507 ../drivers/ata/libata-core.c:1749
#: ../drivers/ata/libata-core.c:2012 ../drivers/ata/libata-core.c:2058
#: ../drivers/ata/libata-core.c:2096 ../drivers/ata/libata-core.c:2900
#: ../drivers/ata/libata-core.c:3364 ../drivers/ata/libata-core.c:3817
#: ../drivers/ata/libata-core.c:3866 ../drivers/ata/libata-core.c:3899
#: ../drivers/ata/libata-core.c:4395 ../drivers/ata/libata-core.c:4461
#: ../drivers/ata/libata-core.c:4538 ../drivers/ata/libata-core.c:4620
#: ../drivers/ata/libata-core.c:5437 ../drivers/ata/libata-core.c:6134
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:325
#: ../drivers/ata/libata-eh.c:351 ../drivers/ata/libata-eh.c:1230
#: ../drivers/ata/libata-eh.c:1250 ../drivers/ata/libata-eh.c:1290
#: ../drivers/ata/libata-eh.c:1326 ../drivers/ata/libata-eh.c:1390
#: ../drivers/ata/libata-eh.c:1513 ../drivers/ata/libata-eh.c:1764
#: ../drivers/ata/libata-eh.c:1864 ../drivers/ata/libata-eh.c:3478
#: ../drivers/ata/libata-eh.c:3526 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:730 ../drivers/ata/libata-scsi.c:1701
#: ../drivers/ata/libata-scsi.c:1786 ../drivers/ata/libata-scsi.c:1824
#: ../drivers/ata/libata-scsi.c:1913 ../drivers/ata/libata-scsi.c:1951
#: ../drivers/ata/libata-scsi.c:1979 ../drivers/ata/libata-scsi.c:2041
#: ../drivers/ata/libata-scsi.c:2079 ../drivers/ata/libata-scsi.c:2130
#: ../drivers/ata/libata-scsi.c:2160 ../drivers/ata/libata-scsi.c:2183
#: ../drivers/ata/libata-scsi.c:2221 ../drivers/ata/libata-scsi.c:2259
#: ../drivers/ata/libata-scsi.c:2475 ../drivers/ata/libata-scsi.c:2528
#: ../drivers/ata/libata-scsi.c:2660 ../drivers/ata/libata-scsi.c:2748
#: ../drivers/ata/libata-scsi.c:3470 ../drivers/ata/libata-scsi.c:4252
#: ../drivers/ata/libata-scsi.c:4419 ../drivers/ata/libata-scsi.c:4643
#: ../drivers/ata/libata-scsi.c:4666 ../drivers/ata/libata-scsi.c:4746
#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:590
msgid "``struct ata_device *dev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:225
msgid "the previous device, NULL to start"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:226
msgid "ATA link containing devices to iterate"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:228
msgid "``enum ata_dev_iter_mode mode``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:227
msgid "iteration mode, one of ATA_DITER_*"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:232
msgid "Pointer to the next device."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:526
msgid "Determine ATAPI command type from SCSI opcode"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:532
msgid "``u8 opcode``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:527
msgid "SCSI opcode"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:528
msgid "Determine ATAPI command type from **opcode**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:530
#: ../drivers/ata/libata-core.c:851 ../drivers/ata/libata-core.c:905
#: ../drivers/ata/libata-core.c:929 ../drivers/ata/libata-core.c:953
#: ../drivers/ata/libata-core.c:977 ../drivers/ata/libata-core.c:1038
#: ../drivers/ata/libata-core.c:1431 ../drivers/ata/libata-core.c:5181
#: ../drivers/ata/libata-core.c:5208 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:641 ../drivers/ata/libata-core.c:714
#: ../drivers/ata/libata-core.c:3263 ../drivers/ata/libata-core.c:3314
#: ../drivers/ata/libata-core.c:3819 ../drivers/ata/libata-core.c:4461
#: ../drivers/ata/libata-core.c:5131 ../drivers/ata/libata-core.c:5155
#: ../drivers/ata/libata-core.c:5799 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:244 ../drivers/ata/libata-eh.c:275
#: ../drivers/ata/libata-eh.c:1131 ../drivers/ata/libata-eh.c:1150
#: ../drivers/ata/libata-eh.c:1248 ../drivers/ata/libata-eh.c:1295
#: ../drivers/ata/libata-eh.c:1330 ../drivers/ata/libata-eh.c:1351
#: ../drivers/ata/libata-eh.c:1570 ../drivers/ata/libata-eh.c:2569
#: ../drivers/ata/libata-eh.c:2764 ../drivers/ata/libata-eh.c:4018
#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1049
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:243
#: ../drivers/ata/libata-scsi.c:977 ../drivers/ata/libata-scsi.c:2312
#: ../drivers/ata/libata-scsi.c:2335 ../drivers/ata/libata-scsi.c:2476
#: ../drivers/ata/libata-scsi.c:2510 ../drivers/ata/libata-scsi.c:2660
#: ../drivers/ata/libata-scsi.c:3804 ../drivers/ata/libata-scsi.c:3957
msgid "LOCKING: None."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:534
msgid "ATAPI_{READ|WRITE|READ_CD|PASS_THRU|MISC}"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:844
msgid "Pack pio, mwdma and udma masks into xfer_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:850
msgid "``unsigned int pio_mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:845
msgid "pio_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:847
msgid "``unsigned int mwdma_mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:846
msgid "mwdma_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:848
msgid "``unsigned int udma_mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:847
msgid "udma_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:848
msgid ""
"Pack **pio_mask**, **mwdma_mask** and **udma_mask** into a single unsigned "
"int xfer_mask."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:855
msgid "Packed xfer_mask."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:900
msgid "Find matching XFER_* for the given xfer_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:906
#: ../drivers/ata/libata-core.c:978 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:875
msgid "``unsigned int xfer_mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:901
msgid "xfer_mask of interest"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:902
msgid ""
"Return matching XFER_* value for **xfer_mask**.  Only the highest bit of "
"**xfer_mask** is considered."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:909
msgid "Matching XFER_* value, 0xff if no match found."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:925
msgid "Find matching xfer_mask for XFER_*"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:931
#: ../drivers/ata/libata-core.c:955
msgid "``u8 xfer_mode``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:926
#: ../drivers/ata/libata-core.c:950
msgid "XFER_* of interest"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:927
msgid "Return matching xfer_mask for **xfer_mode**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:933
msgid "Matching xfer_mask, 0 if no match found."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:949
msgid "Find matching xfer_shift for XFER_*"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:951
msgid "Return matching xfer_shift for **xfer_mode**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:957
msgid "Matching xfer_shift, -1 if no match found."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:972
msgid "convert xfer_mask to string"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:973
msgid "mask of bits supported; only highest bit counts."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:974
msgid ""
"Determine string which represents the highest speed (highest bit in "
"**modemask**)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:981
msgid ""
"Constant C string representing highest speed listed in **mode_mask**, or the "
"constant C string \"<n/a>\"."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1032
msgid "determine device type based on ATA-spec signature"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1038
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:644
msgid "``const struct ata_taskfile *tf``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1033
msgid "ATA taskfile register set for device to be identified"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1034
msgid ""
"Determine from taskfile register contents whether a device is ATA or ATAPI, "
"as per \"Signature and persistence\" section of ATA/PI spec (volume 1, sect "
"5.14)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1042
msgid ""
"Device type, ``ATA_DEV_ATA``, ``ATA_DEV_ATAPI``, ``ATA_DEV_PMP``, "
"``ATA_DEV_ZAC``, or ``ATA_DEV_UNKNOWN`` the event of failure."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1089
msgid "Convert IDENTIFY DEVICE page into string"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1095
#: ../drivers/ata/libata-core.c:1132 ../drivers/ata/libata-core.c:1430
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1405
msgid "``const u16 *id``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1090
#: ../drivers/ata/libata-core.c:1127
msgid "IDENTIFY DEVICE results we will examine"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1092
#: ../drivers/ata/libata-core.c:1129
msgid "``unsigned char *s``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1091
#: ../drivers/ata/libata-core.c:1128
msgid "string into which data is output"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1093
#: ../drivers/ata/libata-core.c:1130
msgid "``unsigned int ofs``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1092
#: ../drivers/ata/libata-core.c:1129
msgid "offset into identify device page"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1094
#: ../drivers/ata/libata-core.c:1131
msgid "``unsigned int len``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1093
msgid "length of string to return. must be an even number."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1094
msgid ""
"The strings in the IDENTIFY DEVICE page are broken up into 16-bit chunks.  "
"Run through the string, and output each 8-bit chunk linearly, regardless of "
"platform."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1098
#: ../drivers/ata/libata-core.c:1135 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:601 ../drivers/ata/libata-core.c:1408
msgid "LOCKING: caller."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1126
msgid "Convert IDENTIFY DEVICE page into C string"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1130
msgid "length of string to return. must be an odd number."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1131
msgid ""
"This function is identical to ata_id_string except that it trims trailing "
"spaces and terminates the resulting string with null.  **len** must be "
"actual maximum length (even number) + 1."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1424
msgid "Compute xfermask from the given IDENTIFY data"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1425
msgid "IDENTIFY data to compute xfer mask from"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1426
msgid ""
"Compute the xfermask for this device. This is not as trivial as it seems if "
"we must consider early devices correctly."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1429
msgid "FIXME: pre IDE drive timing (do we care ?)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1435
msgid "Computed xfermask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1668
msgid "check if iordy needed"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1674
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1708
msgid "``const struct ata_device *adev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1669
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1703
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4247
msgid "ATA device"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1670
msgid ""
"Check if the current speed of the device requires IORDY. Used by various "
"controllers for chip configuration."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1725
msgid "default ID read method"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1726
#: ../drivers/ata/libata-core.c:3288 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:4390
msgid "device"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1728
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:598
#: ../drivers/ata/libata-core.c:1504
msgid "``struct ata_taskfile *tf``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1727
msgid "proposed taskfile"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1729
msgid "``__le16 *id``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1728
msgid "data buffer"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1729
msgid ""
"Issue the identify taskfile and hand back the buffer containing identify "
"data. For some RAID controllers and for pre ATA devices this function is "
"wrapped or replaced by the driver"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3192
msgid "return 40 wire cable type"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3193
#: ../drivers/ata/libata-core.c:3207 ../drivers/ata/libata-core.c:3221
#: ../drivers/ata/libata-core.c:3234 ../drivers/ata/libata-core.c:3247
msgid "port"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3194
msgid ""
"Helper method for drivers which want to hardwire 40 wire cable detection."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3206
msgid "return 80 wire cable type"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3208
msgid ""
"Helper method for drivers which want to hardwire 80 wire cable detection."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3220
msgid "return unknown PATA cable."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3222
msgid "Helper method for drivers which have no PATA cable detection."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3233
msgid "return ignored PATA cable."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3235
msgid ""
"Helper method for drivers which don't use cable type to limit transfer mode."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3246
msgid "return SATA cable type"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3248
msgid "Helper method for drivers which have SATA cables"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3287
msgid "return other device on cable"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3293
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:640
#: ../drivers/ata/ata_piix.c:656 ../drivers/ata/ata_piix.c:735
#: ../drivers/ata/ata_piix.c:751
msgid "``struct ata_device *adev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3289
msgid ""
"Obtain the other device on the same cable, or if none is present NULL is "
"returned"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3530
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3419
msgid "Program timings and issue SET FEATURES - XFER"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3531
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3420
msgid "link on which timings will be programmed"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3533
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2111
#: ../drivers/ata/libata-eh.c:3422
msgid "``struct ata_device **r_failed_dev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3532
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2110
#: ../drivers/ata/libata-eh.c:3421
msgid "out parameter for failed device"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3533
msgid ""
"Standard implementation of the function used to tune and set ATA device disk "
"transfer mode (PIO3, UDMA6, etc.).  If ata_dev_set_mode() fails, pointer to "
"the failing device is returned in **r_failed_dev**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3538
#: ../drivers/ata/libata-core.c:4583 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:4537 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:3426
msgid "LOCKING: PCI/etc. bus probe sem."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3542
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3870
#: ../drivers/ata/libata-core.c:3904 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:3430
msgid "0 on success, negative errno otherwise"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3717
msgid "wait for link to become ready after reset"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3718
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3631
msgid "link to be waited on"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3720
#: ../drivers/ata/libata-core.c:3743 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:3633 ../../../driver-api/libata:979:
#: ../drivers/ata/ata_piix.c:534
msgid "``unsigned long deadline``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3719
#: ../drivers/ata/libata-core.c:3742 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:3632 ../../../driver-api/libata:979:
#: ../drivers/ata/ata_piix.c:533
msgid "deadline jiffies for the operation"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3721
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3634
msgid "``int (*check_ready)(struct ata_link *link)``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3720
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3633
msgid "callback to check link readiness"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3721
msgid "Wait for **link** to become ready after reset."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3723
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:312
#: ../drivers/ata/libata-core.c:340 ../drivers/ata/libata-core.c:376
#: ../drivers/ata/libata-core.c:429 ../drivers/ata/libata-core.c:483
#: ../drivers/ata/libata-core.c:3642 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:324 ../drivers/ata/libata-eh.c:352
#: ../drivers/ata/libata-eh.c:467 ../drivers/ata/libata-eh.c:484
#: ../drivers/ata/libata-eh.c:1439 ../drivers/ata/libata-eh.c:2116
msgid "LOCKING: EH context."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3727
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3646
msgid "0 if **link** is ready before **deadline**; otherwise, -errno."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3740
msgid "prepare for reset"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3741
msgid "ATA link to be reset"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3743
msgid ""
"**link** is about to be reset.  Initialize it.  Failure from prereset makes "
"libata abort whole reset sequence and give up that port, so prereset should "
"be best-effort.  It does its best to prepare for reset sequence but if "
"things go wrong, it should just whine, not fail."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3749
#: ../drivers/ata/libata-core.c:3793 ../drivers/ata/libata-core.c:6723
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1756
#: ../drivers/ata/libata-core.c:2899 ../drivers/ata/libata-core.c:3866
#: ../drivers/ata/libata-core.c:3900 ../drivers/ata/libata-core.c:4618
#: ../drivers/ata/libata-core.c:5472
msgid "LOCKING: Kernel thread context (may sleep)"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3753
msgid "Always 0."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3786
msgid "standard postreset callback"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3787
msgid "the target ata_link"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3789
msgid "``unsigned int *classes``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3788
msgid "classes of attached devices"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3789
msgid ""
"This function is invoked after a successful reset.  Note that the device "
"might have been reset more than once using different reset methods before "
"postreset is invoked."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4577
msgid "Issue SET FEATURES"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4578
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4533
#: ../drivers/ata/libata-core.c:4615
msgid "Device to which command will be sent"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4580
msgid "``u8 subcmd``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4579
msgid "The SET FEATURES subcommand to be sent"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4581
msgid "``u8 action``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4580
msgid "The sector count represents a subcommand specific action"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4581
msgid ""
"Issue SET FEATURES command to device **dev** on port **ap** with sector count"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4587
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2102
#: ../drivers/ata/libata-core.c:4541 ../drivers/ata/libata-core.c:4622
msgid "0 on success, AC_ERR_* mask otherwise."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4687
msgid "Check whether a qc needs to be deferred"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4693
#: ../drivers/ata/libata-core.c:4916 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:713 ../drivers/ata/libata-core.c:4662
#: ../drivers/ata/libata-core.c:4724 ../drivers/ata/libata-core.c:4747
#: ../drivers/ata/libata-core.c:4771 ../drivers/ata/libata-core.c:4829
#: ../drivers/ata/libata-core.c:5055 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:942 ../drivers/ata/libata-eh.c:1197
#: ../drivers/ata/libata-eh.c:1211 ../drivers/ata/libata-eh.c:1421
#: ../drivers/ata/libata-eh.c:1458 ../drivers/ata/libata-eh.c:1620
#: ../drivers/ata/libata-eh.c:1955 ../drivers/ata/libata-eh.c:1975
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:244
#: ../drivers/ata/libata-scsi.c:979 ../drivers/ata/libata-scsi.c:1242
#: ../drivers/ata/libata-scsi.c:1303 ../drivers/ata/libata-scsi.c:1394
#: ../drivers/ata/libata-scsi.c:1537 ../drivers/ata/libata-scsi.c:2826
#: ../drivers/ata/libata-scsi.c:3037 ../drivers/ata/libata-scsi.c:3357
#: ../drivers/ata/libata-scsi.c:3571 ../drivers/ata/libata-scsi.c:3803
#: ../drivers/ata/libata-scsi.c:3955 ../drivers/ata/libata-scsi.c:3981
#: ../drivers/ata/libata-scsi.c:4224
msgid "``struct ata_queued_cmd *qc``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4688
msgid "ATA command in question"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4689
msgid ""
"Non-NCQ commands cannot run with any other command, NCQ or not.  As upper "
"layer only knows the queue depth, we are responsible for maintaining "
"exclusion.  This function checks whether a new command **qc** can be issued."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4694
#: ../drivers/ata/libata-core.c:4920 ../drivers/ata/libata-core.c:5027
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4662
#: ../drivers/ata/libata-core.c:4726 ../drivers/ata/libata-core.c:4745
#: ../drivers/ata/libata-core.c:4769 ../drivers/ata/libata-core.c:4828
#: ../drivers/ata/libata-core.c:5056 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:181 ../drivers/ata/libata-eh.c:202
#: ../drivers/ata/libata-eh.c:224 ../drivers/ata/libata-eh.c:906
#: ../drivers/ata/libata-eh.c:941 ../drivers/ata/libata-eh.c:987
#: ../drivers/ata/libata-eh.c:1006 ../drivers/ata/libata-eh.c:1045
#: ../drivers/ata/libata-eh.c:1090 ../drivers/ata/libata-eh.c:1111
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:735
#: ../drivers/ata/libata-scsi.c:808 ../drivers/ata/libata-scsi.c:1243
#: ../drivers/ata/libata-scsi.c:1302 ../drivers/ata/libata-scsi.c:1392
#: ../drivers/ata/libata-scsi.c:1541 ../drivers/ata/libata-scsi.c:1712
#: ../drivers/ata/libata-scsi.c:1791 ../drivers/ata/libata-scsi.c:1825
#: ../drivers/ata/libata-scsi.c:1913 ../drivers/ata/libata-scsi.c:1951
#: ../drivers/ata/libata-scsi.c:1982 ../drivers/ata/libata-scsi.c:2041
#: ../drivers/ata/libata-scsi.c:2079 ../drivers/ata/libata-scsi.c:2131
#: ../drivers/ata/libata-scsi.c:2161 ../drivers/ata/libata-scsi.c:2184
#: ../drivers/ata/libata-scsi.c:2222 ../drivers/ata/libata-scsi.c:2259
#: ../drivers/ata/libata-scsi.c:2530 ../drivers/ata/libata-scsi.c:2748
#: ../drivers/ata/libata-scsi.c:2822 ../drivers/ata/libata-scsi.c:2973
#: ../drivers/ata/libata-scsi.c:3470 ../drivers/ata/libata-scsi.c:3981
#: ../drivers/ata/libata-scsi.c:4419 ../drivers/ata/libata-scsi.c:4643
#: ../drivers/ata/libata-scsi.c:4745
msgid "LOCKING: spin_lock_irqsave(host lock)"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4698
msgid "ATA_DEFER_* if deferring is needed, 0 otherwise."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4910
msgid "Complete an active ATA command"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4911
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4824
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1192
msgid "Command to complete"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4912
msgid ""
"Indicate to the mid and upper layers that an ATA command has completed, with "
"either an ok or not-ok status."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4915
msgid ""
"Refrain from calling this function multiple times when successfully "
"completing multiple NCQ commands. ata_qc_complete_multiple() should be used "
"instead, which will properly update IRQ expect state."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5025
msgid "get bitmask of active qcs"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5026
msgid "port in question"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5031
msgid "Bitmask of active qcs"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5173
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5125
msgid "test whether the given link is online"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5174
#: ../drivers/ata/libata-core.c:5201 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:5126 ../drivers/ata/libata-core.c:5150
msgid "ATA link to test"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5175
msgid ""
"Test whether **link** is online.  This is identical to "
"ata_phys_link_online() when there's no slave link.  When there's a slave "
"link, this function should only be called on the master link and will return "
"true if any of M/S links is online."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5185
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5135
msgid "True if the port online status is available and online."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5200
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5149
msgid "test whether the given link is offline"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5202
msgid ""
"Test whether **link** is offline.  This is identical to "
"ata_phys_link_offline() when there's no slave link.  When there's a slave "
"link, this function should only be called on the master link and will return "
"true if both M/S links are offline."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5212
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5159
msgid "True if the port offline status is available and offline."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5398
msgid "suspend host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5404
#: ../drivers/ata/libata-core.c:5417 ../drivers/ata/libata-core.c:5542
#: ../drivers/ata/libata-core.c:5840 ../drivers/ata/libata-core.c:5921
#: ../drivers/ata/libata-core.c:5985 ../drivers/ata/libata-core.c:6071
#: ../drivers/ata/libata-core.c:6218
msgid "``struct ata_host *host``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5399
msgid "host to suspend"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5401
msgid "``pm_message_t mesg``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5400
msgid "PM message"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5401
msgid "Suspend **host**.  Actual operation is performed by port suspend."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5411
msgid "resume host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5412
msgid "host to resume"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5413
msgid "Resume **host**.  Actual operation is performed by port resume."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5536
msgid "allocate and initialize basic ATA port resources"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5537
msgid "ATA host this allocated port belongs to"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5538
msgid "Allocate and initialize basic ATA port resources."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5541
#: ../drivers/ata/libata-core.c:5656 ../drivers/ata/libata-core.c:5726
#: ../drivers/ata/libata-core.c:5842 ../drivers/ata/libata-core.c:5987
#: ../drivers/ata/libata-core.c:6080
msgid "LOCKING: Inherited from calling layer (may sleep)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5541
msgid "Allocate ATA port on success, NULL on failure."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5648
msgid "allocate and init basic ATA host resources"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5654
#: ../drivers/ata/libata-core.c:5723 ../drivers/ata/libata-core.c:5918
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5649
#: ../drivers/ata/libata-core.c:5718
msgid "generic device this host is associated with"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5651
#: ../drivers/ata/libata-core.c:5721
msgid "``int n_ports``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5650
msgid "the number of ATA ports associated with this host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5651
msgid ""
"Allocate and initialize basic ATA host resources.  LLD calls this function "
"to allocate a host, initializes it fully and attaches it using "
"ata_host_register()."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5656
#: ../drivers/ata/libata-core.c:5726
msgid "Allocate ATA host on success, NULL on failure."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5717
msgid "alloc host and init with port_info array"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5720
msgid "``const struct ata_port_info * const * ppi``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5719
msgid "array of ATA port_info to initialize host with"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5720
msgid "number of ATA ports attached to this host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5721
msgid ""
"Allocate ATA host and initialize with info from **ppi**.  If NULL "
"terminated, **ppi** may contain fewer entries than **n_ports**.  The last "
"entry will be used for the remaining ports."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5834
msgid "start and freeze ports of an ATA host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5835
msgid "ATA host to start ports for"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5836
msgid ""
"Start and then freeze ports of **host**.  Started status is recorded in host-"
">flags, so this function can be called multiple times.  Ports are guaranteed "
"to get started only once.  If host->ops is not initialized yet, it is set to "
"the first non-dummy port ops."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5846
msgid "0 if all ports are started successfully, -errno otherwise."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5915
msgid "Initialize a host struct for sas (ipr, libsas)"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5916
msgid "host to initialize"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5917
msgid "device host is attached to"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5919
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5790
msgid "``struct ata_port_operations *ops``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5918
msgid "port_ops"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5979
msgid "register initialized ATA host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5980
msgid "ATA host to register"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5982
#: ../drivers/ata/libata-core.c:6071
msgid "``const struct scsi_host_template *sht``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5981
msgid "template for SCSI host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5982
msgid ""
"Register initialized ATA host.  **host** is allocated using ata_host_alloc() "
"and fully initialized by LLD.  This function starts ports, registers "
"**host** with ATA and SCSI layers and probe registered devices."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5991
#: ../drivers/ata/libata-core.c:6084 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:1760
msgid "0 on success, -errno otherwise."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6065
msgid "start host, request IRQ and register it"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6066
msgid "target ATA host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6068
msgid "``int irq``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6067
msgid "IRQ to request"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6069
msgid "``irq_handler_t irq_handler``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6068
msgid "irq_handler used when requesting IRQ"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6070
msgid "``unsigned long irq_flags``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6069
msgid "irq_flags used when requesting IRQ"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6070
msgid "scsi_host_template to use when registering the host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6071
msgid ""
"After allocating an ATA host and initializing it, most libata LLDs perform "
"three steps to activate the host - start host, request IRQ and register it.  "
"This helper takes necessary arguments and performs the three steps in one go."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6076
msgid ""
"An invalid IRQ skips the IRQ registration and expects the host to have set "
"polling mode on the port. In this case, **irq_handler** should be NULL."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6212
msgid "Detach all ports of an ATA host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6213
msgid "Host to detach"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6214
msgid "Detach all ports of **host**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6216
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2011
#: ../drivers/ata/libata-core.c:2058 ../drivers/ata/libata-core.c:2098
#: ../drivers/ata/libata-core.c:5508 ../drivers/ata/libata-core.c:6132
#: ../drivers/ata/libata-core.c:6151 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:814 ../drivers/ata/libata-eh.c:1457
#: ../drivers/ata/libata-eh.c:1514 ../drivers/ata/libata-eh.c:1620
#: ../drivers/ata/libata-eh.c:1867 ../drivers/ata/libata-eh.c:2263
#: ../drivers/ata/libata-eh.c:2402 ../drivers/ata/libata-eh.c:3776
#: ../drivers/ata/libata-eh.c:4076 ../drivers/ata/libata-eh.c:4113
#: ../drivers/ata/libata-eh.c:4190 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:4665 ../drivers/ata/libata-scsi.c:4764
#: ../drivers/ata/libata-scsi.c:4867
msgid "LOCKING: Kernel thread context (may sleep)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6235
msgid "PCI layer callback for device removal"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6241
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1635
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6236
msgid "PCI device that was removed"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6237
msgid ""
"PCI layer indicates to libata via this hook that hot-unplug or module unload "
"event has occurred.  Detach all ports.  Resource release is handled via "
"devres."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6241
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1635
msgid "LOCKING: Inherited from PCI layer (may sleep)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6366
msgid "Platform layer callback for device removal"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6372
msgid "``struct platform_device *pdev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6367
msgid "Platform device that was removed"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6368
msgid ""
"Platform layer indicates to libata via this hook that hot-unplug or module "
"unload event has occurred.  Detach all ports.  Resource release is handled "
"via devres."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6372
msgid "LOCKING: Inherited from platform layer (may sleep)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6674
msgid "ATA EH owner aware msleep"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6675
msgid "ATA port to attribute the sleep to"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6677
msgid "``unsigned int msecs``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6676
msgid "duration to sleep in milliseconds"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6677
msgid ""
"Sleeps **msecs**.  If the current task is owner of **ap**'s EH, the "
"ownership is released before going to sleep and reacquired after the sleep "
"is complete.  IOW, other ports sharing the **ap->host** will be allowed to "
"own the EH while this task is sleeping."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6683
msgid "LOCKING: Might sleep."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6707
msgid "wait until register value changes"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6708
msgid "ATA port to wait register for, can be NULL"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6710
msgid "``void __iomem *reg``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6709
msgid "IO-mapped register"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6711
msgid "``u32 mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6710
msgid "Mask to apply to read register value"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6712
msgid "``u32 val``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6711
msgid "Wait condition"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6713
msgid "``unsigned int interval``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6712
msgid "polling interval in milliseconds"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6714
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1509
msgid "``unsigned int timeout``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6713
msgid "timeout in milliseconds"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6714
msgid ""
"Waiting for some bits of register to change is a common operation for ATA "
"controllers.  This function reads 32bit LE IO-mapped register **reg** and "
"tests for the following condition."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6718
msgid "(***reg** & mask) != val"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6720
msgid ""
"If the condition is met, it returns; otherwise, the process is repeated "
"after **interval_msec** until timeout."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6727
msgid "The final register value."
msgstr ""

#: ../../../driver-api/libata.rst:591
msgid "libata Core Internals"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:278
msgid "find physical link for a device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:279
msgid "ATA device to look up physical link for"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:280
msgid ""
"Look up physical link which **dev** is attached to.  Note that this is "
"different from **dev->link** only when **dev** is on slave link.  For all "
"other cases, it's the same as **dev->link**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:284
msgid "LOCKING: Don't care."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:288
msgid "Pointer to the found physical link."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:304
msgid "force cable type according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:305
#: ../drivers/ata/libata-core.c:337
msgid "ATA port of interest"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:306
msgid ""
"Force cable type according to libata.force and whine about it. The last "
"entry which has matching port number is used, so it can be specified as part "
"of device force parameters.  For example, both \"a:40c,1.00:udma4\" and "
"\"1.00:40c,udma4\" have the same effect."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:336
msgid "force port flags according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:338
msgid "Force port flags according to libata.force and whine about it."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:365
msgid "force link limits according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:366
msgid "ATA link of interest"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:367
msgid ""
"Force link flags and SATA spd limit according to libata.force and whine "
"about it.  When only the port part is specified (e.g. 1:), the limit applies "
"to all links connected to both the host link and all fan-out ports connected "
"via PMP.  If the device part is specified as 0 (e.g. 1.00:), it specifies "
"the first fan-out link not the host link.  Device number 15 always points to "
"the host link whether PMP is attached or not.  If the controller has slave "
"link, device number 16 points to it."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:423
msgid "force xfermask according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:424
#: ../drivers/ata/libata-core.c:478 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:2470
msgid "ATA device of interest"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:425
msgid ""
"Force xfer_mask according to libata.force and whine about it. For "
"consistency with link selection, device number 15 selects the first device "
"connected to the host link."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:477
msgid "force quirks according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:479
msgid ""
"Force quirks according to libata.force and whine about it. For consistency "
"with link selection, device number 15 selects the first device connected to "
"the host link."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:595
msgid "set taskfile r/w command and protocol"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:596
msgid "target device for the taskfile"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:597
msgid "taskfile to examine and configure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:598
msgid ""
"Examine the device configuration and tf->flags to determine the proper read/"
"write command and protocol to use for **tf**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:638
msgid "Read block address from ATA taskfile"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:639
msgid "ATA taskfile of interest"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:640
msgid "ATA device **tf** belongs to"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:644
msgid ""
"Read block address from **tf**.  This function can handle all three address "
"formats - LBA, LBA48 and CHS.  tf->protocol and flags select the address "
"format to use."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:649
msgid "Block address read from **tf**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:707
msgid "Build ATA taskfile for given read/write request"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:708
msgid "Metadata associated with the taskfile to build"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:710
msgid "``u64 block``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:709
msgid "Block address"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:711
msgid "``u32 n_block``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:710
msgid "Number of blocks"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:712
msgid "``unsigned int tf_flags``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:711
msgid "RW/FUA etc..."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:713
msgid "``int cdl``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:712
msgid "Command duration limit index"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:714
msgid "``int class``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:713
msgid "IO priority class"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:717
msgid ""
"Build ATA taskfile for the command **qc** for read/write request described "
"by **block**, **n_block**, **tf_flags** and **class**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:721
msgid ""
"0 on success, -ERANGE if the request is too large for **dev**, -EINVAL if "
"the request is invalid."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:869
msgid "Unpack xfer_mask into pio, mwdma and udma masks"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:870
msgid "xfer_mask to unpack"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:872
msgid "``unsigned int *pio_mask``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:871
msgid "resulting pio_mask"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:873
msgid "``unsigned int *mwdma_mask``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:872
msgid "resulting mwdma_mask"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:874
msgid "``unsigned int *udma_mask``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:873
msgid "resulting udma_mask"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:874
msgid ""
"Unpack **xfer_mask** into **pio_mask**, **mwdma_mask** and **udma_mask**. "
"Any NULL destination masks will be ignored."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1197
msgid "Read native max address"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1198
#: ../drivers/ata/libata-core.c:1249 ../drivers/ata/libata-core.c:1744
#: ../drivers/ata/libata-core.c:2007 ../drivers/ata/libata-core.c:2053
#: ../drivers/ata/libata-core.c:2091 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:320 ../drivers/ata/libata-eh.c:346
msgid "target device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1200
msgid "``u64 *max_sectors``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1199
msgid "out parameter for the result native max address"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1200
msgid ""
"Perform an LBA48 or LBA28 native size query upon the device in question."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1204
msgid ""
"0 on success, -EACCES if command is aborted by the drive. -EIO on other "
"errors."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1248
msgid "Set max sectors"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1251
msgid "``u64 new_sectors``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1250
msgid "new max sectors value to set for the device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1251
msgid "Set max sectors of **dev** to **new_sectors**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1254
msgid ""
"0 on success, -EACCES if command is aborted or denied (due to previous non-"
"volatile SET_MAX) by the drive.  -EIO on other errors."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1306
msgid "Resize a device with an HPA set"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1307
msgid "Device to resize"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1308
msgid ""
"Read the size of an LBA28 or LBA48 disk with HPA features and resize it if "
"required to the full size of the media. The caller must check the drive has "
"the HPA feature set enabled."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1313
#: ../drivers/ata/libata-core.c:5512 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:2120 ../drivers/ata/libata-eh.c:3482
#: ../drivers/ata/libata-eh.c:3780
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1402
msgid "IDENTIFY DEVICE info debugging output"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1403
msgid "device from which the information is fetched"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1404
msgid "IDENTIFY DEVICE page to dump"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1405
msgid "Dump selected 16-bit words from the given IDENTIFY DEVICE page."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1501
msgid "execute libata internal command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1502
msgid "Device to which the command is sent"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1503
msgid "Taskfile registers for the command and the result"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1505
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1334
#: ../drivers/ata/libata-scsi.c:1350 ../drivers/ata/libata-scsi.c:1366
#: ../drivers/ata/libata-scsi.c:1382
msgid "``const u8 *cdb``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1504
msgid "CDB for packet command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1506
msgid "``enum dma_data_direction dma_dir``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1505
msgid "Data transfer direction of the command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1507
#: ../drivers/ata/libata-core.c:2095
msgid "``void *buf``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1506
msgid "Data buffer of the command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1508
msgid "``unsigned int buflen``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1507
msgid "Length of data buffer"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1508
msgid "Timeout in msecs (0 for default)"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1509
msgid ""
"Executes libata internal command with timeout. **tf** contains the command "
"on entry and the result on return. Timeout and error conditions are reported "
"via the return value. No recovery action is taken after a command times out. "
"It is the caller's duty to clean up after timeout."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1515
msgid "LOCKING: None.  Should be called with kernel context, might sleep."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1519
msgid "Zero on success, AC_ERR_* mask on failure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1702
msgid "Return the non IORDY mask"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1704
msgid ""
"Compute the highest mode possible if we are not using iordy. Return -1 if no "
"iordy mode is available."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1743
msgid "Read ID data from the specified device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1746
msgid "``unsigned int *p_class``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1745
msgid "pointer to class of the target device (may be changed)"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1747
msgid "``unsigned int flags``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1746
msgid "ATA_READID_* flags"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1748
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2333
msgid "``u16 *id``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1747
msgid "buffer to read IDENTIFY data into"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1748
msgid ""
"Read ID data from the specified device.  ATA_CMD_ID_ATA is performed on ATA "
"devices and ATA_CMD_ID_ATAPI on ATAPI devices.  This function also issues "
"ATA_CMD_INIT_DEV_PARAMS for pre-ATA4 drives."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1753
msgid ""
"FIXME: ATA_CMD_ID_ATA is optional for early drives and right now we abort if "
"we hit that case."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2006
msgid "Set a device power mode to standby"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2008
msgid ""
"Issue a STANDBY IMMEDIATE command to set a device power mode to standby. For "
"an HDD device, this spins down the disks."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2052
msgid "Set a device power mode to active"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2054
msgid ""
"Issue a VERIFY command to enter to ensure that the device is in the active "
"power mode. For a spun-down HDD (standby or idle power mode), the VERIFY "
"command will complete after the disk spins up."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2090
msgid "read a specific log page"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2093
msgid "``u8 log``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2092
msgid "log to read"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2094
msgid "``u8 page``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2093
msgid "page to read"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2094
msgid "buffer to store read page"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2096
msgid "``unsigned int sectors``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2095
msgid "number of sectors to read"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2096
msgid "Read log page using READ_LOG_EXT command."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2894
msgid "Configure the specified ATA/ATAPI device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2895
msgid "Target device to configure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2896
msgid ""
"Configure **dev** according to **dev->id**.  Generic and low-level driver "
"specific fixups are also applied."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2903
msgid "0 on success, -errno otherwise"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3259
msgid "Print SATA link status"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3260
msgid "SATA link to printk link status about"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3261
msgid "This function prints link speed and status of a SATA link."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3306
msgid "find xfer mode for the specified cycle duration"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3312
msgid "``unsigned int xfer_shift``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3307
msgid "ATA_SHIFT_* value for transfer type to examine."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3309
msgid "``int cycle``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3308
msgid "cycle duration in ns"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3309
msgid ""
"Return matching xfer mode for **cycle**.  The returned mode is of the "
"transfer type specified by **xfer_shift**.  If **cycle** is too slow for "
"**xfer_shift**, 0xff is returned.  If **cycle** is faster than the fastest "
"known mode, the fasted mode is returned."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3318
msgid "Matching xfer_mode, 0xff if no match found."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3358
msgid "adjust dev xfer masks downward"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3359
msgid "Device to adjust xfer masks"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3361
msgid "``unsigned int sel``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3360
msgid "ATA_DNXFER_* selector"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3361
msgid ""
"Adjust xfer masks of **dev** downward.  Note that this function does not "
"apply the change.  Invoking ata_set_mode() afterwards will apply the limit."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3365
#: ../drivers/ata/libata-core.c:4808 ../drivers/ata/libata-core.c:5435
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1807
msgid "LOCKING: Inherited from caller."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3369
msgid "0 on success, negative errno on failure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3630
msgid "wait for link to become ready"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3634
msgid ""
"Wait for **link** to become ready.  **check_ready** should return positive "
"number if **link** is ready, 0 if it isn't, -ENODEV if link doesn't seem to "
"be occupied, other errno for other error conditions."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3639
msgid "Transient -ENODEV conditions are allowed for ATA_TMOUT_FF_WAIT."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3811
msgid "Determine whether new ID matches configured device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3812
msgid "device to compare against"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3814
#: ../drivers/ata/libata-core.c:3896
msgid "``unsigned int new_class``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3813
msgid "class of the new device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3815
msgid "``const u16 *new_id``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3814
msgid "IDENTIFY page of the new device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3815
msgid ""
"Compare **new_class** and **new_id** against **dev** and determine whether "
"**dev** is the device indicated by **new_class** and **new_id**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3823
msgid "1 if **dev** matches **new_class** and **new_id**, 0 otherwise."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3860
msgid "Re-read IDENTIFY data"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3861
msgid "target ATA device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3863
#: ../drivers/ata/libata-core.c:3897
msgid "``unsigned int readid_flags``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3862
#: ../drivers/ata/libata-core.c:3896
msgid "read ID flags"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3863
msgid ""
"Re-read IDENTIFY page and make sure **dev** is still attached to the port."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3893
msgid "Revalidate ATA device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3894
msgid "device to revalidate"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3895
msgid "new class code"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3897
msgid ""
"Re-read IDENTIFY page, make sure **dev** is still attached to the port and "
"reconfigure it according to the new IDENTIFY page."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4389
msgid "check drive side detection"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4391
msgid ""
"Perform drive side detection decoding, allowing for device vendors who can't "
"follow the documentation."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4404
msgid "40/80/SATA decider"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4405
msgid "port to consider"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4406
msgid ""
"This function encapsulates the policy for speed management in one place. At "
"the moment we don't cache the result but there is a good case for setting ap-"
">cbl to the result when we are called with unknown cables (and figuring out "
"if it impacts hotplug at all)."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4412
msgid "Return 1 if the cable appears to be 40 wire."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4455
msgid "Compute supported xfermask of the given device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4456
msgid "Device to compute xfermask for"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4457
msgid ""
"Compute supported xfermask of **dev** and store it in dev->*_mask.  This "
"function is responsible for applying all known limits including host "
"controller limits, device quirks, etc..."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4532
msgid "Issue SET FEATURES - XFER MODE command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4534
msgid ""
"Issue SET FEATURES - XFER MODE command to device **dev** on port **ap**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4614
msgid "Issue INIT DEV PARAMS command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4617
msgid "``u16 heads``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4616
msgid "Number of heads (taskfile parameter)"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4618
msgid "``u16 sectors``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4617
msgid "Number of sectors (taskfile parameter)"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4656
msgid "Check whether ATAPI DMA can be supported"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4657
msgid "Metadata associated with taskfile to check"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4666
msgid "0 when ATAPI DMA can be used nonzero otherwise"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4718
msgid "Associate command with scatter-gather table."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4719
msgid "Command to be associated"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4721
msgid "``struct scatterlist *sg``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4720
msgid "Scatter-gather table."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4722
msgid "``unsigned int n_elem``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4721
msgid "Number of elements in s/g table."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4722
msgid ""
"Initialize the data-related elements of queued_cmd **qc** to point to a "
"scatter-gather table **sg**, containing **n_elem** elements."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4741
msgid "Unmap DMA memory associated with command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4742
msgid "Command containing DMA memory to be released"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4743
msgid "Unmap all mapped DMA memory associated with this command."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4765
msgid "DMA-map the scatter-gather table associated with a command."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4766
msgid "Command with scatter-gather table to be mapped."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4767
msgid "DMA-map the scatter-gather table associated with queued_cmd **qc**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4773
msgid "Zero on success, negative on error."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4801
msgid "swap halves of 16-bit words in place"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4807
msgid "``u16 *buf``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4802
msgid "Buffer to swap"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4804
msgid "``unsigned int buf_words``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4803
msgid "Number of 16-bit words in buffer."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4804
msgid ""
"Swap halves of 16-bit words if needed to convert from little-endian byte "
"order to native cpu byte order, or vice-versa."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4823
msgid "free unused ata_queued_cmd"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4825
msgid ""
"Designed to free unused ata_queued_cmd object in case something prevents "
"using it."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5049
msgid "issue taskfile to device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5050
msgid "command to issue to device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5051
msgid ""
"Prepare an ATA command to submission to device. This includes mapping the "
"data into a DMA-able area, filling in the S/G table, and finally writing the "
"taskfile to hardware, starting the command."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5127
msgid ""
"Test whether **link** is online.  Note that this function returns 0 if "
"online status of **link** cannot be obtained, so ata_link_online(link) != !"
"ata_link_offline(link)."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5151
msgid ""
"Test whether **link** is offline.  Note that this function returns 0 if "
"offline status of **link** cannot be obtained, so ata_link_online(link) != !"
"ata_link_offline(link)."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5431
msgid "Initialize an ata_device structure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5432
msgid "Device structure to initialize"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5433
msgid "Initialize **dev** in preparation for probing."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5466
msgid "Initialize an ata_link structure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5467
msgid "ATA port link is attached to"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5468
msgid "Link structure to initialize"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5470
msgid "``int pmp``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5469
msgid "Port multiplier port number"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5470
msgid "Initialize **link**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5503
msgid "Initialize link->sata_spd_limit"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5504
msgid "Link to configure sata_spd_limit for"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5505
msgid ""
"Initialize ``link->[hw_]sata_spd_limit`` to the currently configured value."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5784
msgid "finalize ata_port_operations"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5785
msgid "ata_port_operations to finalize"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5786
msgid ""
"An ata_port_operations can inherit from another ops and that ops can again "
"inherit from another.  This can go on as many times as necessary as long as "
"there is no loop in the inheritance chain."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5791
msgid ""
"Ops tables are finalized when the host is started.  NULL or unspecified "
"entries are inherited from the closet ancestor which has the method and the "
"entry is populated with it. After finalization, the ops table directly "
"points to all the methods and ->inherits is no longer necessary and cleared."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5797
msgid "Using ATA_OP_NULL, inheriting ops can force a method to NULL."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6128
msgid "Free a device resources"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6129
msgid "Target ATA device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6130
msgid "Free resources allocated to support a device features."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6145
msgid "Detach ATA port in preparation of device removal"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6146
msgid "ATA port to be detached"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6147
msgid ""
"Detach all ATA devices and the associated SCSI devices of **ap**; then, "
"remove the associated SCSI host.  **ap** is guaranteed to be quiescent on "
"return from this function."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:176
msgid "push error description without adding separator"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:182
#: ../drivers/ata/libata-eh.c:202 ../drivers/ata/libata-eh.c:226
msgid "``struct ata_eh_info *ehi``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:177
#: ../drivers/ata/libata-eh.c:197 ../drivers/ata/libata-eh.c:221
msgid "target EHI"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:179
#: ../drivers/ata/libata-eh.c:199 ../drivers/ata/libata-eh.c:239
msgid "``const char *fmt``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:178
#: ../drivers/ata/libata-eh.c:198 ../drivers/ata/libata-eh.c:238
msgid "printf format string"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:180
#: ../drivers/ata/libata-eh.c:200 ../drivers/ata/libata-eh.c:240
msgid "``...``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:179
msgid "Format string according to **fmt** and append it to **ehi->desc**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:196
msgid "push error description with separator"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:199
msgid ""
"Format string according to **fmt** and append it to **ehi->desc**. If **ehi-"
">desc** is not empty, \", \" is added in-between."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:220
msgid "clean error description"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:222
msgid "Clear **ehi->desc**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:236
msgid "append port description"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:237
#: ../drivers/ata/libata-eh.c:266 ../drivers/ata/libata-eh.c:900
msgid "target ATA port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:239
msgid ""
"Format string according to **fmt** and append it to port description.  If "
"port description is not empty, \" \" is added in-between.  This function is "
"to be used while initializing ata_host.  The description is printed on host "
"registration."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:265
msgid "append PCI BAR description"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:268
msgid "``int bar``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:267
msgid "target PCI BAR"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:269
msgid "``ssize_t offset``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:268
msgid "offset into PCI BAR"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:270
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:269
msgid "name of the area"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:270
msgid ""
"If **offset** is negative, this function formats a string which contains the "
"name, address, size and type of the BAR and appends it to the port "
"description.  If **offset** is zero or positive, only name and offsetted "
"address is appended."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:319
msgid "determine timeout for an internal command"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:322
#: ../drivers/ata/libata-eh.c:348 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:4249
msgid "``u8 cmd``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:321
msgid "internal command to be issued"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:322
msgid "Determine timeout for internal command **cmd** for **dev**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:328
msgid "Determined timeout."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:345
msgid "notification for internal command timeout"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:347
msgid "internal command which timed out"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:348
msgid ""
"Notify EH that internal command **cmd** for **dev** timed out.  This "
"function should be called only for commands whose timeouts are determined "
"using ata_internal_cmd_timeout()."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:461
msgid "acquire EH ownership"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:462
msgid "ATA port to acquire EH ownership for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:463
msgid ""
"Acquire EH ownership for **ap**.  This is the basic exclusion mechanism for "
"ports sharing a host.  Only one port hanging off the same host can claim the "
"ownership of EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:479
msgid "release EH ownership"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:480
msgid "ATA port to release EH ownership for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:481
msgid ""
"Release EH ownership for **ap** if the caller.  The caller must have "
"acquired EH ownership using ata_eh_acquire() previously."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:548
msgid "SCSI layer error handler callback"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:554
#: ../drivers/ata/libata-eh.c:587 ../drivers/ata/libata-eh.c:691
msgid "``struct Scsi_Host *host``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:549
msgid "SCSI host on which error occurred"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:550
msgid "Handles SCSI-layer-thrown error events."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:552
msgid "LOCKING: Inherited from SCSI layer (none, can sleep)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:556
#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:366
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4807
msgid "Zero."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:581
msgid "error callback for a list of commands"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:582
msgid "scsi host containing the port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:583
msgid "ATA port within the host"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:585
msgid "``struct list_head *eh_work_q``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:584
msgid "list of commands to process"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:585
msgid ""
"process the given list of commands and return those finished to the ap-"
">eh_done_q.  This function is the first part of the libata error handler "
"which processes a given list of failed commands."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:685
msgid "recover the port after the commands"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:686
msgid "SCSI host containing the port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:687
msgid "the ATA port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:688
msgid ""
"Handle the recovery of the port **ap** after all the commands have been "
"recovered."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:810
msgid "Wait for the currently pending EH to complete"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:811
msgid "Port to wait EH for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:812
msgid "Wait until the currently pending EH is complete."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:899
msgid "set ATA_PFLAG_EH_PENDING and activate fast drain"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:902
msgid "``bool fastdrain``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:901
msgid "activate fast drain"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:902
msgid ""
"Set ATA_PFLAG_EH_PENDING and activate fast drain if **fastdrain** is non-"
"zero and EH wasn't pending before.  Fast drain ensures that EH kicks in in "
"timely manner."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:936
msgid "schedule qc for error handling"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:937
msgid "command to schedule error handling for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:938
msgid ""
"Schedule error handling for **qc**.  EH will kick in as soon as other "
"commands are drained."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:961
msgid "non-libsas ata_ports issue eh with this common routine"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:962
#: ../drivers/ata/libata-eh.c:1002
msgid "ATA port to schedule EH for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:963
msgid ""
"LOCKING: inherited from ata_port_schedule_eh spin_lock_irqsave(host lock)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:980
msgid "non-libsas ata_ports complete eh with this common routine"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:981
msgid "ATA port to end EH for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:982
msgid ""
"In the libata object model there is a 1:1 mapping of ata_port to shost, so "
"host fields can be directly manipulated under ap->lock, in the libsas case "
"we need to hold a lock at the ha->level to coordinate these events."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1001
msgid "schedule error handling without a qc"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1003
msgid ""
"Schedule error handling for **ap**.  EH will kick in as soon as all commands "
"are drained."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1041
msgid "abort all qc's on the link"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1042
msgid "ATA link to abort qc's for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1043
msgid "Abort all active qc's active on **link** and schedule EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1049
#: ../drivers/ata/libata-eh.c:1067
msgid "Number of aborted qc's."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1059
msgid "abort all qc's on the port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1060
msgid "ATA port to abort qc's for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1061
msgid "Abort all active qc's of **ap** and schedule EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1063
msgid "LOCKING: spin_lock_irqsave(host_set lock)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1077
msgid "freeze port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1078
#: ../drivers/ata/libata-eh.c:1106 ../drivers/ata/libata-eh.c:1128
msgid "ATA port to freeze"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1079
msgid ""
"This function is called when HSM violation or some other condition disrupts "
"normal operation of the port.  Frozen port is not allowed to perform any "
"operation until the port is thawed, which usually follows a successful reset."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1084
msgid ""
"ap->ops->freeze() callback can be used for freezing the port hardware-wise "
"(e.g. mask interrupt and stop DMA engine).  If a port cannot be frozen "
"hardware-wise, the interrupt handler must ack and clear interrupts "
"unconditionally while the port is frozen."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1105
msgid "abort & freeze port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1107
msgid ""
"Abort and freeze **ap**.  The freeze operation must be called first, because "
"some hardware requires special operations before the taskfile registers are "
"accessible."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1115
msgid "Number of aborted commands."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1127
msgid "EH helper to freeze port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1129
msgid "Freeze **ap**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1146
msgid "EH helper to thaw port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1147
msgid "ATA port to thaw"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1148
msgid "Thaw frozen port **ap**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1191
msgid "Complete an active ATA command from EH"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1193
msgid ""
"Indicate to the mid and upper layers that an ATA command has completed.  To "
"be used from EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1205
msgid "Tell midlayer to retry an ATA command after EH"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1206
msgid "Command to retry"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1207
msgid ""
"Indicate to the mid and upper layers that an ATA command should be retried.  "
"To be used from EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1210
msgid ""
"SCSI midlayer limits the number of retries to scmd->allowed. scmd->allowed "
"is incremented for commands which get retried due to unrelated failures (qc-"
">err_mask is zero)."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1224
msgid "disable ATA device"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1225
msgid "ATA device to disable"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1226
msgid "Disable **dev**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1228
msgid "Locking: EH context."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1244
msgid "detach ATA device"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1245
msgid "ATA device to detach"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1246
msgid "Detach **dev**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1287
msgid "about to perform eh_action"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1288
msgid "target ATA link"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1289
#: ../drivers/ata/libata-eh.c:1325
msgid "target ATA dev for per-dev action (can be NULL)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1291
#: ../drivers/ata/libata-eh.c:1327
msgid "``unsigned int action``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1290
msgid "action about to be performed"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1291
msgid ""
"Called just before performing EH actions to clear related bits in **link-"
">eh_info** such that eh actions are not unnecessarily repeated."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1323
msgid "EH action complete"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1324
msgid "ATA link for which EH actions are complete"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1326
msgid "action just completed"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1327
msgid ""
"Called right after performing EH actions to clear related bits in **link-"
">eh_context**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1345
msgid "convert err_mask to descriptive string"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1351
#: ../drivers/ata/libata-eh.c:1862
msgid "``unsigned int err_mask``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1346
msgid "error mask to convert to string"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1347
msgid ""
"Convert **err_mask** to descriptive string.  Errors are prioritized "
"according to severity and only the most severe error is reported."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1355
msgid "Descriptive string for **err_mask**"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1384
msgid "perform ATAPI TEST_UNIT_READY"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1385
msgid "target ATAPI device"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1387
msgid "``u8 *r_sense_key``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1386
msgid "out parameter for sense_key"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1387
msgid "Perform ATAPI TEST_UNIT_READY."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1389
#: ../drivers/ata/libata-eh.c:3478
msgid "LOCKING: EH context (may sleep)."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1393
msgid "0 on success, AC_ERR_* mask on failure."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1415
msgid "Disposition a qc based on sense data"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1416
msgid "qc to examine"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1417
msgid ""
"For a regular SCSI command, the SCSI completion callback (scsi_done()) will "
"call scsi_complete(), which will call scsi_decide_disposition(), which will "
"call scsi_check_sense(). scsi_complete() finally calls "
"scsi_finish_command(). This is fine for SCSI, since any eventual sense data "
"is usually returned in the completion itself (without invoking SCSI EH). "
"However, for a QC, we always need to fetch the sense data explicitly using "
"SCSI EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1425
msgid ""
"A command that is completed via SCSI EH will instead be completed using "
"scsi_eh_flush_done_q(), which will call scsi_finish_command() directly "
"(without ever calling scsi_check_sense())."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1429
msgid ""
"For a command that went through SCSI EH, it is the responsibility of the "
"SCSI EH strategy handler to call scsi_decide_disposition(), see e.g. how "
"scsi_eh_get_sense() calls scsi_decide_disposition() for SCSI LLDDs that do "
"not get the sense data as part of the completion."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1434
msgid ""
"Thus, for QC commands that went via SCSI EH, we need to call "
"scsi_check_sense() ourselves, similar to how scsi_eh_get_sense() calls "
"scsi_decide_disposition(), which calls scsi_check_sense(), in order to set "
"the correct SCSI ML byte (if any)."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1443
msgid "SUCCESS or FAILED or NEEDS_RETRY or ADD_TO_MLQUEUE"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1452
msgid "perform REQUEST_SENSE_DATA_EXT"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1453
msgid "qc to perform REQUEST_SENSE_SENSE_DATA_EXT to"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1454
msgid ""
"Perform REQUEST_SENSE_DATA_EXT after the device reported CHECK SENSE.  This "
"function is an EH helper."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1461
msgid "true if sense data could be fetched, false otherwise."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1507
msgid "perform ATAPI REQUEST_SENSE"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1508
msgid "device to perform REQUEST_SENSE to"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1510
msgid "``u8 *sense_buf``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1509
msgid "result sense data buffer (SCSI_SENSE_BUFFERSIZE bytes long)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1511
msgid "``u8 dfl_sense_key``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1510
msgid "default sense key to use"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1511
msgid ""
"Perform ATAPI REQUEST_SENSE after the device reported CHECK SENSE.  This "
"function is EH helper."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1518
msgid "0 on success, AC_ERR_* mask on failure"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1565
msgid "analyze SError for a failed port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1566
msgid "ATA link to analyze SError for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1567
msgid "Analyze SError if available and further determine cause of failure."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1614
msgid "analyze taskfile of a failed qc"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1615
msgid "qc to analyze"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1616
msgid ""
"Analyze taskfile of **qc** and further determine cause of failure.  This "
"function also requests ATAPI sense data if available."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1624
msgid "Determined recovery action"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1758
msgid "Determine speed down verdict"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1759
msgid "Device of interest"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1760
msgid ""
"This function examines error ring of **dev** and determines whether NCQ "
"needs to be turned off, transfer speed should be stepped down, or falling "
"back to PIO is necessary."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1764
msgid "ECAT_ATA_BUS    : ATA_BUS error for any command"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1766
msgid "ECAT_TOUT_HSM"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:-1
msgid "TIMEOUT for any command or HSM violation for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1767
msgid "IO commands"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1769
msgid "ECAT_UNK_DEV    : Unknown DEV error for IO commands"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1771
msgid "ECAT_DUBIOUS_*"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:-1
msgid "Identical to above three but occurred while"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1772
msgid "data transfer hasn't been verified."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1774
msgid "Verdicts are"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1776
msgid "NCQ_OFF         : Turn off NCQ."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1778
msgid "SPEED_DOWN"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:-1
msgid "Speed down transfer speed but don't fall back"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1779
msgid "to PIO."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1781
msgid "FALLBACK_TO_PIO : Fall back to PIO."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1783
msgid ""
"Even if multiple verdicts are returned, only one action is taken per error.  "
"An action triggered by non-DUBIOUS errors clears ering, while one triggered "
"by DUBIOUS_* errors doesn't. This is to expedite speed down decisions right "
"after device is initially configured."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1789
msgid ""
"The following are speed down rules.  #1 and #2 deal with DUBIOUS errors."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1792
msgid ""
"If more than one DUBIOUS_ATA_BUS or DUBIOUS_TOUT_HSM errors occurred during "
"last 5 mins, SPEED_DOWN and FALLBACK_TO_PIO."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1795
msgid ""
"If more than one DUBIOUS_TOUT_HSM or DUBIOUS_UNK_DEV errors occurred during "
"last 5 mins, NCQ_OFF."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1798
msgid ""
"If more than 8 ATA_BUS, TOUT_HSM or UNK_DEV errors occurred during last 5 "
"mins, FALLBACK_TO_PIO"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1801
msgid ""
"If more than 3 TOUT_HSM or UNK_DEV errors occurred during last 10 mins, "
"NCQ_OFF."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1804
msgid ""
"If more than 3 ATA_BUS or TOUT_HSM errors, or more than 6 UNK_DEV errors "
"occurred during last 10 mins, SPEED_DOWN."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1811
msgid "OR of ATA_EH_SPDN_* flags."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1858
msgid "record error and speed down if necessary"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1859
msgid "Failed device"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1861
msgid "``unsigned int eflags``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1860
msgid "mask of ATA_EFLAG_* flags"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1861
msgid "err_mask of the error"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1862
msgid ""
"Record error and examine error history to determine whether adjusting "
"transmission speed is necessary.  It also sets transmission limits "
"appropriately if such adjustment is necessary."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1871
msgid "Determined recovery action."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1949
msgid "analyze error and decide whether to retry"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1950
msgid "qc to possibly retry"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1951
msgid ""
"Look at the cause of the error and decide if a retry might be useful or "
"not.  We don't want to retry media errors because the drive itself has "
"probably already taken 10-30 seconds doing its own internal retries before "
"reporting the failure."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1969
msgid "check if we need to be quiet about a command error"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1970
msgid "qc to check"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1971
msgid ""
"Look at the qc flags anbd its scsi command request flags to determine if we "
"need to be quiet about the command failure."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2107
msgid "configure SATA interface power management"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2108
msgid "link to configure"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2110
msgid "``enum ata_lpm_policy policy``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2109
msgid "the link power management policy"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2111
msgid ""
"Enable SATA Interface power management.  This will enable Device Interface "
"Power Management (DIPM) for min_power and medium_power_with_dipm policies, "
"and then call driver specific callbacks for enabling Host Initiated Power "
"management."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2257
#: ../drivers/ata/libata-eh.c:2397
msgid "analyze error and determine recovery action"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2258
msgid "host link to perform autopsy on"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2259
msgid ""
"Analyze why **link** failed and determine which recovery actions are "
"needed.  This function also sets more detailed AC_ERR_* values and fills "
"sense data for ATAPI CHECK SENSE."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2398
msgid "host port to perform autopsy on"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2399
msgid ""
"Analyze all links of **ap** and determine why they failed and which recovery "
"actions are needed."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2443
msgid "get name for ATA command"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2449
msgid "``u8 command``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2444
msgid "ATA command code to get name for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2445
msgid "Return a textual name of the given command or \"unknown\""
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2447
msgid "LOCKING: None"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2565
#: ../drivers/ata/libata-eh.c:2760
msgid "report error handling to user"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2566
msgid "ATA link EH is going on"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2567
#: ../drivers/ata/libata-eh.c:2762
msgid "Report EH to user."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2761
msgid "ATA port to report EH about"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3422
msgid ""
"Set ATA device disk transfer mode (PIO3, UDMA6, etc.).  If ata_eh_set_mode() "
"fails, pointer to the failing device is returned in **r_failed_dev**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3472
msgid "Clear ATAPI UNIT ATTENTION after reset"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3473
msgid "ATAPI device to clear UA for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3474
msgid ""
"Resets and other operations can make an ATAPI device raise UNIT ATTENTION "
"which causes the next operation to fail.  This function clears UA."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3520
msgid "Retry FLUSH if necessary"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3521
msgid "ATA device which may need FLUSH retry"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3522
msgid ""
"If **dev** failed FLUSH, it needs to be reported upper layer immediately as "
"it means that **dev** failed to remap and already lost at least a sector and "
"further FLUSH retrials won't make any difference to the lost sector.  "
"However, if FLUSH failed for other reasons, for example transmission error, "
"FLUSH needs to be retried."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3529
msgid ""
"This function determines whether FLUSH failure retry is necessary and "
"performs it if so."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3533
msgid "0 if EH can continue, -errno if EH needs to be repeated."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3765
msgid "recover host port after error"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3766
msgid "host port to recover"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3768
msgid "``struct ata_reset_operations *reset_ops``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3767
msgid "The set of reset operations to use"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3769
msgid "``struct ata_link **r_failed_link``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3768
msgid "out parameter for failed link"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3769
msgid ""
"This is the alpha and omega, eum and yang, heart and soul of libata "
"exception handling.  On entry, actions required to recover each link and "
"hotplug requests are recorded in the link's eh_context.  This function "
"executes all the operations with appropriate retrials and fallbacks to "
"resurrect failed devices, detach goners and greet newcomers."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4013
msgid "finish up EH"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4014
msgid "host port to finish EH for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4015
msgid ""
"Recovery is complete.  Clean up EH states and retry or finish failed qcs."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4072
msgid "standard error handler"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4073
msgid "host port to handle error for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4074
msgid "Perform standard error handling sequence."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4109
msgid "perform port suspend operation"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4110
msgid "port to suspend"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4111
msgid "Suspend **ap**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4186
msgid "perform port resume operation"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4187
msgid "port to resume"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4188
msgid "Resume **ap**."
msgstr ""

#: ../../../driver-api/libata.rst:599
msgid "libata SCSI translation/emulation"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:352
msgid "generic bios head/sector/cylinder calculator used by sd."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:358
#: ../drivers/ata/libata-scsi.c:388 ../drivers/ata/libata-scsi.c:1145
#: ../drivers/ata/libata-scsi.c:1181 ../drivers/ata/libata-scsi.c:1206
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:415
msgid "``struct scsi_device *sdev``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:353
msgid "SCSI device for which BIOS geometry is to be determined"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:355
msgid "``struct gendisk *unused``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:354
msgid "gendisk associated with **sdev**"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:356
msgid "``sector_t capacity``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:355
msgid "capacity of SCSI device"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:357
msgid "``int geom[]``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:356
msgid "location to which geometry will be output"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:357
msgid ""
"Generic bios head/sector/cylinder calculator used by sd. Most BIOSes "
"nowadays expect a XXX/255/16  (CHS) mapping. Some situations may arise where "
"the disk is not bootable if this is not used."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:362
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:416
#: ../drivers/ata/libata-scsi.c:455 ../drivers/ata/libata-scsi.c:563
msgid "LOCKING: Defined by the SCSI layer.  We don't really care."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:382
msgid "unlock native capacity"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:383
msgid "SCSI device to adjust device capacity for"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:384
msgid ""
"This function is called if a partition on **sdev** extends beyond the end of "
"the device.  It requests EH to unlock HPA."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:387
msgid "LOCKING: Defined by the SCSI layer.  Might sleep."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1042
msgid "Check whether data transfer may overflow"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1048
msgid "``struct request *rq``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1043
msgid "request to be checked"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1044
msgid ""
"ATAPI commands which transfer variable length data to host might overflow "
"due to application error or hardware bug.  This function checks whether "
"overflow should be drained and ignored for **request**."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1053
msgid "1 if ; otherwise, 0."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1139
msgid "Early setup of SCSI device"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1140
#: ../drivers/ata/libata-scsi.c:1176
msgid "SCSI device to examine"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1141
msgid ""
"This is called from scsi_alloc_sdev() when the scsi device associated with "
"an ATA device is scanned on a port."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1144
#: ../drivers/ata/libata-scsi.c:1182 ../drivers/ata/libata-scsi.c:1209
msgid "LOCKING: Defined by SCSI layer.  We don't really care."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1175
msgid "Set SCSI device attributes"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1178
msgid "``struct queue_limits *lim``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1177
msgid "queue limits"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1178
msgid ""
"This is called before we actually start reading and writing to the device, "
"to configure certain SCSI mid-layer behaviors."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1200
msgid "SCSI device is about to be destroyed"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1201
msgid "SCSI device to be destroyed"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1202
msgid ""
"**sdev** is about to be destroyed for hot/warm unplugging.  If this "
"unplugging was initiated by libata as indicated by NULL dev->sdev, this "
"function doesn't have to do anything. Otherwise, SCSI layer initiated warm-"
"unplug is in progress. Clear dev->sdev, schedule the device for ATA detach "
"and invoke EH."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4368
msgid "Issue SCSI cdb to libata-managed device"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4374
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4801
msgid "``struct Scsi_Host *shost``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4369
msgid "SCSI host of command to be sent"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4371
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:727
#: ../drivers/ata/libata-scsi.c:1698 ../drivers/ata/libata-scsi.c:1783
#: ../drivers/ata/libata-scsi.c:1821 ../drivers/ata/libata-scsi.c:1910
#: ../drivers/ata/libata-scsi.c:1948 ../drivers/ata/libata-scsi.c:1976
#: ../drivers/ata/libata-scsi.c:2038 ../drivers/ata/libata-scsi.c:2076
#: ../drivers/ata/libata-scsi.c:2128 ../drivers/ata/libata-scsi.c:2158
#: ../drivers/ata/libata-scsi.c:2181 ../drivers/ata/libata-scsi.c:2219
#: ../drivers/ata/libata-scsi.c:2256 ../drivers/ata/libata-scsi.c:2525
#: ../drivers/ata/libata-scsi.c:2657 ../drivers/ata/libata-scsi.c:2745
#: ../drivers/ata/libata-scsi.c:3303 ../drivers/ata/libata-scsi.c:3467
#: ../drivers/ata/libata-scsi.c:4416
msgid "``struct scsi_cmnd *cmd``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4370
msgid "SCSI command to be sent"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4371
msgid ""
"In some cases, this function translates SCSI commands into ATA taskfiles, "
"and queues the taskfiles to be sent to hardware.  In other cases, this "
"function simulates a SCSI device by evaluating and responding to certain "
"SCSI commands.  This creates the overall effect of ATA and ATAPI devices "
"appearing as SCSI devices."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4378
msgid "LOCKING: ATA host lock"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4382
msgid ""
"Return value from __ata_scsi_queuecmd() if **cmd** can be queued, 0 "
"otherwise."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:238
msgid "Set ATA fields in sense buffer"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:239
msgid "ATA PASS-THROUGH command."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:240
msgid ""
"Populates \"ATA Status Return sense data descriptor\" / \"Fixed format sense "
"data\" with ATA taskfile fields."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:412
msgid "Handler for HDIO_GET_IDENTITY ioctl"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:413
msgid "target port"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:414
msgid "SCSI device to get identify data for"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:416
#: ../drivers/ata/libata-scsi.c:455 ../drivers/ata/libata-scsi.c:563
msgid "``void __user *arg``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:415
msgid "User buffer area for identify data"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:420
#: ../drivers/ata/libata-scsi.c:459 ../drivers/ata/libata-scsi.c:567
msgid "Zero on success, negative errno on error."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:452
msgid "Handler for HDIO_DRIVE_CMD ioctl"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:458
#: ../drivers/ata/libata-scsi.c:566
msgid "``struct scsi_device *scsidev``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:453
#: ../drivers/ata/libata-scsi.c:561
msgid "Device to which we are issuing command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:454
#: ../drivers/ata/libata-scsi.c:562
msgid "User provided data for issuing command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:560
msgid "Handler for HDIO_DRIVE_TASK ioctl"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:724
msgid "acquire new ata_queued_cmd reference"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:725
msgid "ATA device to which the new command is attached"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:726
msgid "SCSI command that originated this ATA command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:727
msgid ""
"Obtain a reference to an unused ata_queued_cmd structure, which is the basic "
"libata structure representing a single ATA command sent to the hardware."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:731
msgid ""
"If a command was available, fill in the SCSI-specific portions of the "
"structure with information on the current command."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:739
msgid "Command allocated, or ``NULL`` if none available."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:798
msgid "convert ATA error to SCSI error"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:804
msgid "``u8 drv_stat``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:799
msgid "value contained in ATA status register"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:801
msgid "``u8 drv_err``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:800
msgid "value contained in ATA error register"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:802
msgid "``u8 *sk``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:801
msgid "the sense key we'll fill out"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:803
msgid "``u8 *asc``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:802
msgid "the additional sense code we'll fill out"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:804
msgid "``u8 *ascq``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:803
msgid "the additional sense code qualifier we'll fill out"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:804
msgid ""
"Converts an ATA error into a SCSI error.  Fill out pointers to SK, ASC, and "
"ASCQ bytes for later use in fixed or descriptor format sense blocks."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:973
msgid "generate a SCSI fixed sense block"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:974
msgid "Command that we are erroring out"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:975
msgid "Generate sense block for a failed ATA command **qc**."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1236
msgid "Translate SCSI START STOP UNIT command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1237
#: ../drivers/ata/libata-scsi.c:1298 ../drivers/ata/libata-scsi.c:1389
#: ../drivers/ata/libata-scsi.c:1532 ../drivers/ata/libata-scsi.c:3798
#: ../drivers/ata/libata-scsi.c:3950 ../drivers/ata/libata-scsi.c:3976
msgid "Storage for translated ATA taskfile"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1238
msgid ""
"Sets up an ATA taskfile to issue STANDBY (to stop) or READ VERIFY (to "
"start). Perhaps these commands should be preceded by CHECK POWER MODE to see "
"what power mode the device is already in. [See SAT revision 5 at www.t10.org]"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1247
#: ../drivers/ata/libata-scsi.c:1306 ../drivers/ata/libata-scsi.c:1396
#: ../drivers/ata/libata-scsi.c:1545
msgid "Zero on success, non-zero on error."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1297
msgid "Translate SCSI SYNCHRONIZE CACHE command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1299
msgid "Sets up an ATA taskfile to issue FLUSH CACHE or FLUSH CACHE EXT."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1328
#: ../drivers/ata/libata-scsi.c:1344 ../drivers/ata/libata-scsi.c:1360
msgid "Get LBA and transfer length"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1329
#: ../drivers/ata/libata-scsi.c:1345 ../drivers/ata/libata-scsi.c:1361
#: ../drivers/ata/libata-scsi.c:1377
msgid "SCSI command to translate"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1331
#: ../drivers/ata/libata-scsi.c:1347 ../drivers/ata/libata-scsi.c:1363
msgid "``u64 *plba``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1334
#: ../drivers/ata/libata-scsi.c:1350 ../drivers/ata/libata-scsi.c:1366
msgid "the LBA"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1336
#: ../drivers/ata/libata-scsi.c:1352 ../drivers/ata/libata-scsi.c:1368
msgid "``u32 *plen``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1335
#: ../drivers/ata/libata-scsi.c:1351 ../drivers/ata/libata-scsi.c:1367
msgid "the transfer length"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1330
msgid "Calculate LBA and transfer length for 6-byte commands."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1346
msgid "Calculate LBA and transfer length for 10-byte commands."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1362
msgid "Calculate LBA and transfer length for 16-byte commands."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1376
msgid "Get duration limit descriptor index"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1378
msgid ""
"Returns the dld bits indicating the index of a command duration limit "
"descriptor."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1388
msgid "Translate SCSI VERIFY command into an ATA one"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1390
msgid "Converts SCSI VERIFY command to an ATA READ VERIFY command."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1531
msgid "Translate SCSI r/w command into an ATA one"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1533
msgid ""
"Converts any of six SCSI read/write commands into the ATA counterpart, "
"including starting sector (LBA), sector count, and taking into account the "
"device's LBA48 support."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1538
msgid ""
"Commands ``READ_6``, ``READ_10``, ``READ_16``, ``WRITE_6``, ``WRITE_10``, "
"and ``WRITE_16`` are currently supported."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1695
msgid "Translate then issue SCSI command to ATA device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1696
msgid "ATA device to which the command is addressed"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1697
msgid "SCSI command to execute"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1699
msgid "``ata_xlat_func_t xlat_func``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1698
msgid "Actor which translates **cmd** to an ATA taskfile"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1699
msgid ""
"Our ->queuecommand() function has decided that the SCSI command issued can "
"be directly translated into an ATA command, rather than handled internally."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1703
msgid ""
"This function sets up an ata_queued_cmd structure for the SCSI command, and "
"sends that ata_queued_cmd to the hardware."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1706
msgid ""
"The xlat_func argument (actor) returns 0 if ready to execute ATA command, "
"else 1 to finish translation. If 1 is returned then cmd->result (and "
"possibly cmd->sense_buffer) are assumed to be set reflecting an error "
"condition or clean (early) termination."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1716
msgid ""
"0 on success, SCSI_ML_QUEUE_DEVICE_BUSY if the command needs to be deferred."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1780
msgid "wrapper for SCSI command simulators"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1781
#: ../drivers/ata/libata-scsi.c:1819 ../drivers/ata/libata-scsi.c:1908
#: ../drivers/ata/libata-scsi.c:1946 ../drivers/ata/libata-scsi.c:1974
#: ../drivers/ata/libata-scsi.c:2036 ../drivers/ata/libata-scsi.c:2074
#: ../drivers/ata/libata-scsi.c:2126 ../drivers/ata/libata-scsi.c:2156
#: ../drivers/ata/libata-scsi.c:2179 ../drivers/ata/libata-scsi.c:2217
#: ../drivers/ata/libata-scsi.c:2254 ../drivers/ata/libata-scsi.c:2523
#: ../drivers/ata/libata-scsi.c:2655 ../drivers/ata/libata-scsi.c:2743
#: ../drivers/ata/libata-scsi.c:3465
msgid "Target device."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1782
#: ../drivers/ata/libata-scsi.c:1820 ../drivers/ata/libata-scsi.c:1909
#: ../drivers/ata/libata-scsi.c:1947 ../drivers/ata/libata-scsi.c:1975
#: ../drivers/ata/libata-scsi.c:2037 ../drivers/ata/libata-scsi.c:2075
#: ../drivers/ata/libata-scsi.c:2127 ../drivers/ata/libata-scsi.c:2157
#: ../drivers/ata/libata-scsi.c:2180 ../drivers/ata/libata-scsi.c:2218
#: ../drivers/ata/libata-scsi.c:2255 ../drivers/ata/libata-scsi.c:2524
#: ../drivers/ata/libata-scsi.c:2656 ../drivers/ata/libata-scsi.c:2744
#: ../drivers/ata/libata-scsi.c:3466
msgid "SCSI command of interest."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1784
msgid ""
"``unsigned int (*actor)(struct ata_device *dev, struct scsi_cmnd *cmd, u8 "
"*rbuf)``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1783
msgid "Callback hook for desired SCSI command simulator"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1784
msgid ""
"Takes care of the hard work of simulating a SCSI command... Mapping the "
"response buffer, calling the command's handler, and handling the handler's "
"return value.  This return value indicates whether the handler wishes the "
"SCSI command to be completed successfully (0), or not (in which case cmd-"
">result and sense buffer are assumed to be set)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1818
msgid "Simulate standard INQUIRY command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1822
#: ../drivers/ata/libata-scsi.c:1911 ../drivers/ata/libata-scsi.c:1949
#: ../drivers/ata/libata-scsi.c:1977 ../drivers/ata/libata-scsi.c:2039
#: ../drivers/ata/libata-scsi.c:2077 ../drivers/ata/libata-scsi.c:2129
#: ../drivers/ata/libata-scsi.c:2159 ../drivers/ata/libata-scsi.c:2182
#: ../drivers/ata/libata-scsi.c:2220 ../drivers/ata/libata-scsi.c:2257
#: ../drivers/ata/libata-scsi.c:2526 ../drivers/ata/libata-scsi.c:2658
#: ../drivers/ata/libata-scsi.c:2746 ../drivers/ata/libata-scsi.c:3468
msgid "``u8 *rbuf``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1821
#: ../drivers/ata/libata-scsi.c:1910 ../drivers/ata/libata-scsi.c:1948
#: ../drivers/ata/libata-scsi.c:1976 ../drivers/ata/libata-scsi.c:2038
#: ../drivers/ata/libata-scsi.c:2076 ../drivers/ata/libata-scsi.c:2128
#: ../drivers/ata/libata-scsi.c:2158 ../drivers/ata/libata-scsi.c:2181
#: ../drivers/ata/libata-scsi.c:2219 ../drivers/ata/libata-scsi.c:2256
#: ../drivers/ata/libata-scsi.c:2525 ../drivers/ata/libata-scsi.c:2657
#: ../drivers/ata/libata-scsi.c:2745 ../drivers/ata/libata-scsi.c:3467
msgid "Response buffer, to which simulated SCSI cmd output is sent."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1822
msgid ""
"Returns standard device identification data associated with non-VPD INQUIRY "
"command output."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1907
msgid "Simulate INQUIRY VPD page 0, list of pages"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1911
msgid "Returns list of inquiry VPD pages available."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1945
msgid "Simulate INQUIRY VPD page 80, device serial number"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1949
msgid "Returns ATA device serial number."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1973
msgid "Simulate INQUIRY VPD page 83, device identity"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1977
msgid "Yields two logical unit device identification designators:"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1978
msgid "vendor specific ASCII containing the ATA serial number"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1979
msgid ""
"SAT defined \"t10 vendor id based\" containing ASCII vendor name (\"ATA     "
"\"), model and serial numbers."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2035
msgid "Simulate INQUIRY VPD page 89, ATA info"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2039
msgid "Yields SAT-specified ATA VPD page."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2073
msgid "Simulate INQUIRY VPD page B0, Block Limits"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2077
msgid "Return data for the VPD page B0h (Block Limits)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2124
msgid "Simulate INQUIRY VPD page B1, Block Device Characteristics"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2129
msgid "Return data for the VPD page B1h (Block Device Characteristics)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2154
msgid "Simulate INQUIRY VPD page B2, Logical Block Provisioning"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2159
msgid "Return data for the VPD page B2h (Logical Block Provisioning)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2177
msgid "Simulate INQUIRY VPD page B6, Zoned Block Device Characteristics"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2182
msgid "Return data for the VPD page B2h (Zoned Block Device Characteristics)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2215
msgid "Simulate INQUIRY VPD page B9, Concurrent Positioning Ranges"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2220
msgid "Return data for the VPD page B9h (Concurrent Positioning Ranges)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2253
msgid "Simulate INQUIRY command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2257
msgid "Returns data associated with an INQUIRY command output."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2304
msgid "Prepare response for MODE SENSE"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2310
msgid "``u8 *dest``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2305
#: ../drivers/ata/libata-scsi.c:2329 ../drivers/ata/libata-scsi.c:2471
#: ../drivers/ata/libata-scsi.c:2506
msgid "output buffer"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2307
msgid "``const u8 *src``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2306
msgid "data being copied"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2308
msgid "``int n``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2307
msgid "length of mode page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2309
#: ../drivers/ata/libata-scsi.c:2331 ../drivers/ata/libata-scsi.c:2474
#: ../drivers/ata/libata-scsi.c:2508
msgid "``bool changeable``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2308
#: ../drivers/ata/libata-scsi.c:2330 ../drivers/ata/libata-scsi.c:2473
#: ../drivers/ata/libata-scsi.c:2507
msgid "whether changeable parameters are requested"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2309
msgid ""
"Generate a generic MODE SENSE page for either current or changeable "
"parameters."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2327
msgid "Simulate MODE SENSE caching info page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2328
msgid "device IDENTIFY data"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2330
#: ../drivers/ata/libata-scsi.c:2472 ../drivers/ata/libata-scsi.c:2511
msgid "``u8 *buf``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2331
msgid ""
"Generate a caching info page, which conditionally indicates write caching to "
"the SCSI layer, depending on device capabilities."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2469
msgid "Simulate MODE SENSE control mode page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2473
#: ../drivers/ata/libata-scsi.c:3952
msgid "``u8 spg``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2472
msgid "sub-page code"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2474
msgid "Generate a generic MODE SENSE control mode page."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2505
msgid "Simulate MODE SENSE r/w error recovery page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2508
msgid "Generate a generic MODE SENSE r/w error recovery page."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2522
msgid "Simulate MODE SENSE 6, 10 commands"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2526
msgid ""
"Simulate MODE SENSE commands. Assume this is invoked for direct access "
"devices (e.g. disks) only. There should be no block descriptor for other "
"device types."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2654
msgid "Simulate READ CAPACITY[ 16] commands"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2658
msgid "Simulate READ CAPACITY commands."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2742
msgid "Simulate REPORT LUNS command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2746
msgid "Simulate REPORT LUNS command."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2820
msgid "Initialize PACKET taskfile"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2821
#: ../drivers/ata/libata-scsi.c:3032
msgid "command structure to be initialized"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2826
#: ../drivers/ata/libata-scsi.c:3036
msgid "Zero on success, non-zero on failure."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2965
msgid "lookup ata_device from scsi_cmnd"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2966
msgid "ATA port to which the device is attached"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2968
msgid "``const struct scsi_device *scsidev``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2967
msgid "SCSI device from which we derive the ATA device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2968
msgid ""
"Given various information provided in struct scsi_cmnd, map that onto an ATA "
"bus, and using that mapping determine which ata_device is associated with "
"the SCSI command to be sent."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2977
msgid "Associated ATA device, or ``NULL`` if not found."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3031
msgid "convert ATA pass-thru CDB to taskfile"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3033
msgid "Handles either 12, 16, or 32-byte versions of the CDB."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3297
msgid "SATL Write Same to DSM Trim"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3298
msgid "SCSI command being translated"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3300
msgid "``u32 trmax``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3299
msgid "Maximum number of entries that will fit in sector_size bytes."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3301
msgid "``u64 sector``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3300
msgid "Starting sector"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3302
msgid "``u32 count``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3301
msgid "Total Range of request in logical sectors"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3302
msgid ""
"Rewrite the WRITE SAME descriptor to be a DSM TRIM little-endian formatted "
"descriptor."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3305
msgid "Upto 64 entries of the format:"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3306
msgid "63:48 Range Length 47:0  LBA"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3309
msgid ""
"Range Length of 0 is ignored. LBA's should be sorted order and not overlap."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3312
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3313
msgid "this is the same format as ADD LBA(S) TO NV CACHE PINNED SET"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3315
msgid "Number of bytes copied into sglist."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3351
msgid "SATL Write Same to ATA SCT Write Same"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3352
#: ../drivers/ata/libata-scsi.c:4219
msgid "Command to be translated"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3353
msgid ""
"Translate a SCSI WRITE SAME command to be either a DSM TRIM command or an "
"SCT Write Same command. Based on WRITE SAME has the UNMAP flag:"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3357
msgid "When set translate to DSM TRIM"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3358
msgid "When clear translate to SCT Write Same"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3464
msgid "Simulate a subset of MAINTENANCE_IN"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3468
msgid "Yields a subset to satisfy scsi_report_opcode()"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3565
msgid "convert ATA output"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3566
msgid "command structure returning the data"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3567
msgid ""
"Convert T-13 little-endian field representation into T-10 big-endian field "
"representation. What a mess."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3797
msgid "Simulate MODE SELECT for caching info page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3800
#: ../drivers/ata/libata-scsi.c:3953
msgid "``const u8 *buf``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3799
#: ../drivers/ata/libata-scsi.c:3952
msgid "input buffer"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3801
#: ../drivers/ata/libata-scsi.c:3954
msgid "``int len``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3800
#: ../drivers/ata/libata-scsi.c:3953
msgid "number of valid bytes in the input buffer"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3802
#: ../drivers/ata/libata-scsi.c:3955
msgid "``u16 *fp``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3801
#: ../drivers/ata/libata-scsi.c:3954
msgid "out parameter for the failed field on error"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3802
#: ../drivers/ata/libata-scsi.c:3955
msgid "Prepare a taskfile to modify caching information for the device."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3949
msgid "Simulate MODE SELECT for control page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3951
msgid "target sub-page of the control page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3975
msgid "Simulate MODE SELECT 6, 10 commands"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3977
msgid ""
"Converts a MODE SELECT command to an ATA SET FEATURES taskfile. Assume this "
"is invoked for direct access devices (e.g. disks) only. There should be no "
"block descriptor for other device types."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4218
msgid "SATL variable length CDB to Handler"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4220
msgid ""
"Translate a SCSI variable length CDB to specified commands. It checks a "
"service action value in CDB to call corresponding handler."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4224
msgid "Zero on success, non-zero on failure"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4246
msgid "check if SCSI to ATA translation is possible"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4248
msgid "SCSI command opcode to consider"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4249
msgid ""
"Look up the SCSI command given, and determine whether the SCSI command is to "
"be translated or simulated."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4253
msgid "Pointer to translation function if possible, ``NULL`` if not."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4413
msgid "simulate SCSI command on ATA device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4414
msgid "the target device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4415
msgid "SCSI command being sent to device."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4416
msgid ""
"Interprets and directly executes a select list of SCSI commands that can be "
"handled internally."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4637
msgid "offline attached SCSI device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4638
msgid "ATA device to offline attached SCSI device for"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4639
msgid ""
"This function is called from ata_eh_detach_dev() and is responsible for "
"taking the SCSI device attached to **dev** offline.  This function is called "
"with host lock which protects dev->sdev against clearing."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4647
msgid "true if attached SCSI device exists, false otherwise."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4660
msgid "remove attached SCSI device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4661
msgid "ATA device to remove attached SCSI device for"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4662
msgid ""
"This function is called from ata_eh_scsi_hotplug() and responsible for "
"removing the SCSI device attached to **dev**."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4740
msgid "send media change event"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4741
msgid "Pointer to the disk device with media change event"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4742
msgid "Tell the block layer to send a media change notification event."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4757
msgid "SCSI part of hotplug"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4763
#: ../drivers/ata/libata-scsi.c:4868
msgid "``struct work_struct *work``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4758
msgid "Pointer to ATA port to perform SCSI hotplug on"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4759
msgid ""
"Perform SCSI part of hotplug.  It's executed from a separate workqueue after "
"EH completes.  This is necessary because SCSI hot plugging requires working "
"EH and hot unplugging is synchronized with hot plugging with a mutex."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4795
msgid "indication for user-initiated bus scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4796
msgid "SCSI host to scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4798
msgid "``unsigned int channel``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4797
msgid "Channel to scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4799
msgid "``unsigned int id``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4798
msgid "ID to scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4800
msgid "``u64 lun``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4799
msgid "LUN to scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4800
msgid ""
"This function is called when user explicitly requests bus scan.  Set probe "
"pending flag and invoke EH."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4803
msgid "LOCKING: SCSI layer (we don't care)"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4862
msgid "initiate scsi_rescan_device()"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4863
msgid "Pointer to ATA port to perform scsi_rescan_device()"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4864
msgid ""
"After ATA pass thru (SAT) commands are executed successfully, libata need to "
"propagate the changes to SCSI layer."
msgstr ""

#: ../../../driver-api/libata.rst:608
msgid "ATA errors and exceptions"
msgstr ""

#: ../../../driver-api/libata.rst:610
msgid ""
"This chapter tries to identify what error/exception conditions exist for ATA/"
"ATAPI devices and describe how they should be handled in implementation-"
"neutral way."
msgstr ""

#: ../../../driver-api/libata.rst:614
msgid ""
"The term 'error' is used to describe conditions where either an explicit "
"error condition is reported from device or a command has timed out."
msgstr ""

#: ../../../driver-api/libata.rst:617
msgid ""
"The term 'exception' is either used to describe exceptional conditions which "
"are not errors (say, power or hotplug events), or to describe both errors "
"and non-error exceptional conditions. Where explicit distinction between "
"error and exception is necessary, the term 'non-error exception' is used."
msgstr ""

#: ../../../driver-api/libata.rst:624
msgid "Exception categories"
msgstr ""

#: ../../../driver-api/libata.rst:626
msgid ""
"Exceptions are described primarily with respect to legacy taskfile + bus "
"master IDE interface. If a controller provides other better mechanism for "
"error reporting, mapping those into categories described below shouldn't be "
"difficult."
msgstr ""

#: ../../../driver-api/libata.rst:631
msgid ""
"In the following sections, two recovery actions - reset and reconfiguring "
"transport - are mentioned. These are described further in `EH recovery "
"actions <#exrec>`__."
msgstr ""

#: ../../../driver-api/libata.rst:636
msgid "HSM violation"
msgstr ""

#: ../../../driver-api/libata.rst:638
msgid ""
"This error is indicated when STATUS value doesn't match HSM requirement "
"during issuing or execution any ATA/ATAPI command."
msgstr ""

#: ../../../driver-api/libata.rst:641
msgid ""
"ATA_STATUS doesn't contain !BSY && DRDY && !DRQ while trying to issue a "
"command."
msgstr ""

#: ../../../driver-api/libata.rst:644
msgid "!BSY && !DRQ during PIO data transfer."
msgstr ""

#: ../../../driver-api/libata.rst:646
msgid "DRQ on command completion."
msgstr ""

#: ../../../driver-api/libata.rst:648
msgid ""
"!BSY && ERR after CDB transfer starts but before the last byte of CDB is "
"transferred. ATA/ATAPI standard states that \"The device shall not terminate "
"the PACKET command with an error before the last byte of the command packet "
"has been written\" in the error outputs description of PACKET command and "
"the state diagram doesn't include such transitions."
msgstr ""

#: ../../../driver-api/libata.rst:655
msgid ""
"In these cases, HSM is violated and not much information regarding the error "
"can be acquired from STATUS or ERROR register. IOW, this error can be "
"anything - driver bug, faulty device, controller and/or cable."
msgstr ""

#: ../../../driver-api/libata.rst:659
msgid ""
"As HSM is violated, reset is necessary to restore known state. Reconfiguring "
"transport for lower speed might be helpful too as transmission errors "
"sometimes cause this kind of errors."
msgstr ""

#: ../../../driver-api/libata.rst:664
msgid "ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)"
msgstr ""

#: ../../../driver-api/libata.rst:666
msgid ""
"These are errors detected and reported by ATA/ATAPI devices indicating "
"device problems. For this type of errors, STATUS and ERROR register values "
"are valid and describe error condition. Note that some of ATA bus errors are "
"detected by ATA/ATAPI devices and reported using the same mechanism as "
"device errors. Those cases are described later in this section."
msgstr ""

#: ../../../driver-api/libata.rst:673
msgid ""
"For ATA commands, this type of errors are indicated by !BSY && ERR during "
"command execution and on completion."
msgstr ""

#: ../../../driver-api/libata.rst:676
msgid "For ATAPI commands,"
msgstr ""

#: ../../../driver-api/libata.rst:678
msgid ""
"!BSY && ERR && ABRT right after issuing PACKET indicates that PACKET command "
"is not supported and falls in this category."
msgstr ""

#: ../../../driver-api/libata.rst:681
msgid ""
"!BSY && ERR(==CHK) && !ABRT after the last byte of CDB is transferred "
"indicates CHECK CONDITION and doesn't fall in this category."
msgstr ""

#: ../../../driver-api/libata.rst:684
msgid ""
"!BSY && ERR(==CHK) && ABRT after the last byte of CDB is transferred "
"\\*probably\\* indicates CHECK CONDITION and doesn't fall in this category."
msgstr ""

#: ../../../driver-api/libata.rst:688
msgid ""
"Of errors detected as above, the following are not ATA/ATAPI device errors "
"but ATA bus errors and should be handled according to `ATA bus error "
"<#excatATAbusErr>`__."
msgstr ""

#: ../../../driver-api/libata.rst:692
msgid "CRC error during data transfer"
msgstr ""

#: ../../../driver-api/libata.rst:693
msgid ""
"This is indicated by ICRC bit in the ERROR register and means that "
"corruption occurred during data transfer. Up to ATA/ATAPI-7, the standard "
"specifies that this bit is only applicable to UDMA transfers but ATA/ATAPI-8 "
"draft revision 1f says that the bit may be applicable to multiword DMA and "
"PIO."
msgstr ""

#: ../../../driver-api/libata.rst:699
msgid "ABRT error during data transfer or on completion"
msgstr ""

#: ../../../driver-api/libata.rst:700
msgid ""
"Up to ATA/ATAPI-7, the standard specifies that ABRT could be set on ICRC "
"errors and on cases where a device is not able to complete a command. "
"Combined with the fact that MWDMA and PIO transfer errors aren't allowed to "
"use ICRC bit up to ATA/ATAPI-7, it seems to imply that ABRT bit alone could "
"indicate transfer errors."
msgstr ""

#: ../../../driver-api/libata.rst:706
msgid ""
"However, ATA/ATAPI-8 draft revision 1f removes the part that ICRC errors can "
"turn on ABRT. So, this is kind of gray area. Some heuristics are needed here."
msgstr ""

#: ../../../driver-api/libata.rst:710
msgid "ATA/ATAPI device errors can be further categorized as follows."
msgstr ""

#: ../../../driver-api/libata.rst:712
msgid "Media errors"
msgstr ""

#: ../../../driver-api/libata.rst:713
msgid ""
"This is indicated by UNC bit in the ERROR register. ATA devices reports UNC "
"error only after certain number of retries cannot recover the data, so "
"there's nothing much else to do other than notifying upper layer."
msgstr ""

#: ../../../driver-api/libata.rst:718
msgid ""
"READ and WRITE commands report CHS or LBA of the first failed sector but ATA/"
"ATAPI standard specifies that the amount of transferred data on error "
"completion is indeterminate, so we cannot assume that sectors preceding the "
"failed sector have been transferred and thus cannot complete those sectors "
"successfully as SCSI does."
msgstr ""

#: ../../../driver-api/libata.rst:724
msgid "Media changed / media change requested error"
msgstr ""

#: ../../../driver-api/libata.rst:725 ../../../driver-api/libata.rst:850
msgid "<<TODO: fill here>>"
msgstr ""

#: ../../../driver-api/libata.rst:727
msgid "Address error"
msgstr ""

#: ../../../driver-api/libata.rst:728
msgid ""
"This is indicated by IDNF bit in the ERROR register. Report to upper layer."
msgstr ""

#: ../../../driver-api/libata.rst:731
msgid "Other errors"
msgstr ""

#: ../../../driver-api/libata.rst:732
msgid ""
"This can be invalid command or parameter indicated by ABRT ERROR bit or some "
"other error condition. Note that ABRT bit can indicate a lot of things "
"including ICRC and Address errors. Heuristics needed."
msgstr ""

#: ../../../driver-api/libata.rst:736
msgid ""
"Depending on commands, not all STATUS/ERROR bits are applicable. These non-"
"applicable bits are marked with \"na\" in the output descriptions but up to "
"ATA/ATAPI-7 no definition of \"na\" can be found. However, ATA/ATAPI-8 draft "
"revision 1f describes \"N/A\" as follows."
msgstr ""

#: ../../../driver-api/libata.rst:741
msgid "3.2.3.3a N/A"
msgstr ""

#: ../../../driver-api/libata.rst:742
msgid ""
"A keyword the indicates a field has no defined value in this standard and "
"should not be checked by the host or device. N/A fields should be cleared to "
"zero."
msgstr ""

#: ../../../driver-api/libata.rst:746
msgid ""
"So, it seems reasonable to assume that \"na\" bits are cleared to zero by "
"devices and thus need no explicit masking."
msgstr ""

#: ../../../driver-api/libata.rst:750
msgid "ATAPI device CHECK CONDITION"
msgstr ""

#: ../../../driver-api/libata.rst:752
msgid ""
"ATAPI device CHECK CONDITION error is indicated by set CHK bit (ERR bit) in "
"the STATUS register after the last byte of CDB is transferred for a PACKET "
"command. For this kind of errors, sense data should be acquired to gather "
"information regarding the errors. REQUEST SENSE packet command should be "
"used to acquire sense data."
msgstr ""

#: ../../../driver-api/libata.rst:758
msgid ""
"Once sense data is acquired, this type of errors can be handled similarly to "
"other SCSI errors. Note that sense data may indicate ATA bus error (e.g. "
"Sense Key 04h HARDWARE ERROR && ASC/ASCQ 47h/00h SCSI PARITY ERROR). In such "
"cases, the error should be considered as an ATA bus error and handled "
"according to `ATA bus error <#excatATAbusErr>`__."
msgstr ""

#: ../../../driver-api/libata.rst:765
msgid "ATA device error (NCQ)"
msgstr ""

#: ../../../driver-api/libata.rst:767
msgid ""
"NCQ command error is indicated by cleared BSY and set ERR bit during NCQ "
"command phase (one or more NCQ commands outstanding). Although STATUS and "
"ERROR registers will contain valid values describing the error, READ LOG EXT "
"is required to clear the error condition, determine which command has failed "
"and acquire more information."
msgstr ""

#: ../../../driver-api/libata.rst:773
msgid ""
"READ LOG EXT Log Page 10h reports which tag has failed and taskfile register "
"values describing the error. With this information the failed command can be "
"handled as a normal ATA command error as in `ATA/ATAPI device error (non-"
"NCQ / non-CHECK CONDITION) <#excatDevErr>`__ and all other in-flight "
"commands must be retried. Note that this retry should not be counted - it's "
"likely that commands retried this way would have completed normally if it "
"were not for the failed command."
msgstr ""

#: ../../../driver-api/libata.rst:781
msgid ""
"Note that ATA bus errors can be reported as ATA device NCQ errors. This "
"should be handled as described in `ATA bus error <#excatATAbusErr>`__."
msgstr ""

#: ../../../driver-api/libata.rst:784
msgid ""
"If READ LOG EXT Log Page 10h fails or reports NQ, we're thoroughly screwed. "
"This condition should be treated according to `HSM violation "
"<#excatHSMviolation>`__."
msgstr ""

#: ../../../driver-api/libata.rst:789
msgid "ATA bus error"
msgstr ""

#: ../../../driver-api/libata.rst:791
msgid ""
"ATA bus error means that data corruption occurred during transmission over "
"ATA bus (SATA or PATA). This type of errors can be indicated by"
msgstr ""

#: ../../../driver-api/libata.rst:794
msgid ""
"ICRC or ABRT error as described in `ATA/ATAPI device error (non-NCQ / non-"
"CHECK CONDITION) <#excatDevErr>`__."
msgstr ""

#: ../../../driver-api/libata.rst:797
msgid ""
"Controller-specific error completion with error information indicating "
"transmission error."
msgstr ""

#: ../../../driver-api/libata.rst:800
msgid ""
"On some controllers, command timeout. In this case, there may be a mechanism "
"to determine that the timeout is due to transmission error."
msgstr ""

#: ../../../driver-api/libata.rst:803
msgid "Unknown/random errors, timeouts and all sorts of weirdities."
msgstr ""

#: ../../../driver-api/libata.rst:805
msgid ""
"As described above, transmission errors can cause wide variety of symptoms "
"ranging from device ICRC error to random device lockup, and, for many cases, "
"there is no way to tell if an error condition is due to transmission error "
"or not; therefore, it's necessary to employ some kind of heuristic when "
"dealing with errors and timeouts. For example, encountering repetitive ABRT "
"errors for known supported command is likely to indicate ATA bus error."
msgstr ""

#: ../../../driver-api/libata.rst:813
msgid ""
"Once it's determined that ATA bus errors have possibly occurred, lowering "
"ATA bus transmission speed is one of actions which may alleviate the "
"problem. See `Reconfigure transport <#exrecReconf>`__ for more information."
msgstr ""

#: ../../../driver-api/libata.rst:819
msgid "PCI bus error"
msgstr ""

#: ../../../driver-api/libata.rst:821
msgid ""
"Data corruption or other failures during transmission over PCI (or other "
"system bus). For standard BMDMA, this is indicated by Error bit in the BMDMA "
"Status register. This type of errors must be logged as it indicates "
"something is very wrong with the system. Resetting host controller is "
"recommended."
msgstr ""

#: ../../../driver-api/libata.rst:828
msgid "Late completion"
msgstr ""

#: ../../../driver-api/libata.rst:830
msgid ""
"This occurs when timeout occurs and the timeout handler finds out that the "
"timed out command has completed successfully or with error. This is usually "
"caused by lost interrupts. This type of errors must be logged. Resetting "
"host controller is recommended."
msgstr ""

#: ../../../driver-api/libata.rst:836
msgid "Unknown error (timeout)"
msgstr ""

#: ../../../driver-api/libata.rst:838
msgid ""
"This is when timeout occurs and the command is still processing or the host "
"and device are in unknown state. When this occurs, HSM could be in any valid "
"or invalid state. To bring the device to known state and make it forget "
"about the timed out command, resetting is necessary. The timed out command "
"may be retried."
msgstr ""

#: ../../../driver-api/libata.rst:844
msgid ""
"Timeouts can also be caused by transmission errors. Refer to `ATA bus error "
"<#excatATAbusErr>`__ for more details."
msgstr ""

#: ../../../driver-api/libata.rst:848
msgid "Hotplug and power management exceptions"
msgstr ""

#: ../../../driver-api/libata.rst:853
msgid "EH recovery actions"
msgstr ""

#: ../../../driver-api/libata.rst:855
msgid "This section discusses several important recovery actions."
msgstr ""

#: ../../../driver-api/libata.rst:858
msgid "Clearing error condition"
msgstr ""

#: ../../../driver-api/libata.rst:860
msgid ""
"Many controllers require its error registers to be cleared by error handler. "
"Different controllers may have different requirements."
msgstr ""

#: ../../../driver-api/libata.rst:863
msgid ""
"For SATA, it's strongly recommended to clear at least SError register during "
"error handling."
msgstr ""

#: ../../../driver-api/libata.rst:867
msgid "Reset"
msgstr ""

#: ../../../driver-api/libata.rst:869
msgid "During EH, resetting is necessary in the following cases."
msgstr ""

#: ../../../driver-api/libata.rst:871
msgid "HSM is in unknown or invalid state"
msgstr ""

#: ../../../driver-api/libata.rst:873
msgid "HBA is in unknown or invalid state"
msgstr ""

#: ../../../driver-api/libata.rst:875
msgid "EH needs to make HBA/device forget about in-flight commands"
msgstr ""

#: ../../../driver-api/libata.rst:877
msgid "HBA/device behaves weirdly"
msgstr ""

#: ../../../driver-api/libata.rst:879
msgid ""
"Resetting during EH might be a good idea regardless of error condition to "
"improve EH robustness. Whether to reset both or either one of HBA and device "
"depends on situation but the following scheme is recommended."
msgstr ""

#: ../../../driver-api/libata.rst:883
msgid ""
"When it's known that HBA is in ready state but ATA/ATAPI device is in "
"unknown state, reset only device."
msgstr ""

#: ../../../driver-api/libata.rst:886
msgid "If HBA is in unknown state, reset both HBA and device."
msgstr ""

#: ../../../driver-api/libata.rst:888
msgid ""
"HBA resetting is implementation specific. For a controller complying to "
"taskfile/BMDMA PCI IDE, stopping active DMA transaction may be sufficient "
"iff BMDMA state is the only HBA context. But even mostly taskfile/BMDMA PCI "
"IDE complying controllers may have implementation specific requirements and "
"mechanism to reset themselves. This must be addressed by specific drivers."
msgstr ""

#: ../../../driver-api/libata.rst:895
msgid ""
"OTOH, ATA/ATAPI standard describes in detail ways to reset ATA/ATAPI devices."
msgstr ""

#: ../../../driver-api/libata.rst:898
msgid "PATA hardware reset"
msgstr ""

#: ../../../driver-api/libata.rst:899
msgid ""
"This is hardware initiated device reset signalled with asserted PATA RESET- "
"signal. There is no standard way to initiate hardware reset from software "
"although some hardware provides registers that allow driver to directly "
"tweak the RESET- signal."
msgstr ""

#: ../../../driver-api/libata.rst:904
msgid "Software reset"
msgstr ""

#: ../../../driver-api/libata.rst:905
msgid ""
"This is achieved by turning CONTROL SRST bit on for at least 5us. Both PATA "
"and SATA support it but, in case of SATA, this may require controller-"
"specific support as the second Register FIS to clear SRST should be "
"transmitted while BSY bit is still set. Note that on PATA, this resets both "
"master and slave devices on a channel."
msgstr ""

#: ../../../driver-api/libata.rst:911
msgid "EXECUTE DEVICE DIAGNOSTIC command"
msgstr ""

#: ../../../driver-api/libata.rst:912
msgid ""
"Although ATA/ATAPI standard doesn't describe exactly, EDD implies some level "
"of resetting, possibly similar level with software reset. Host-side EDD "
"protocol can be handled with normal command processing and most SATA "
"controllers should be able to handle EDD's just like other commands. As in "
"software reset, EDD affects both devices on a PATA bus."
msgstr ""

#: ../../../driver-api/libata.rst:919
msgid ""
"Although EDD does reset devices, this doesn't suit error handling as EDD "
"cannot be issued while BSY is set and it's unclear how it will act when "
"device is in unknown/weird state."
msgstr ""

#: ../../../driver-api/libata.rst:923
msgid "ATAPI DEVICE RESET command"
msgstr ""

#: ../../../driver-api/libata.rst:924
msgid ""
"This is very similar to software reset except that reset can be restricted "
"to the selected device without affecting the other device sharing the cable."
msgstr ""

#: ../../../driver-api/libata.rst:928
msgid "SATA phy reset"
msgstr ""

#: ../../../driver-api/libata.rst:929
msgid ""
"This is the preferred way of resetting a SATA device. In effect, it's "
"identical to PATA hardware reset. Note that this can be done with the "
"standard SCR Control register. As such, it's usually easier to implement "
"than software reset."
msgstr ""

#: ../../../driver-api/libata.rst:934
msgid ""
"One more thing to consider when resetting devices is that resetting clears "
"certain configuration parameters and they need to be set to their previous "
"or newly adjusted values after reset."
msgstr ""

#: ../../../driver-api/libata.rst:938
msgid "Parameters affected are."
msgstr ""

#: ../../../driver-api/libata.rst:940
msgid "CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)"
msgstr ""

#: ../../../driver-api/libata.rst:942
msgid "Parameters set with SET FEATURES including transfer mode setting"
msgstr ""

#: ../../../driver-api/libata.rst:944
msgid "Block count set with SET MULTIPLE MODE"
msgstr ""

#: ../../../driver-api/libata.rst:946
msgid "Other parameters (SET MAX, MEDIA LOCK...)"
msgstr ""

#: ../../../driver-api/libata.rst:948
msgid ""
"ATA/ATAPI standard specifies that some parameters must be maintained across "
"hardware or software reset, but doesn't strictly specify all of them. Always "
"reconfiguring needed parameters after reset is required for robustness. Note "
"that this also applies when resuming from deep sleep (power-off)."
msgstr ""

#: ../../../driver-api/libata.rst:954
msgid ""
"Also, ATA/ATAPI standard requires that IDENTIFY DEVICE / IDENTIFY PACKET "
"DEVICE is issued after any configuration parameter is updated or a hardware "
"reset and the result used for further operation. OS driver is required to "
"implement revalidation mechanism to support this."
msgstr ""

#: ../../../driver-api/libata.rst:960
msgid "Reconfigure transport"
msgstr ""

#: ../../../driver-api/libata.rst:962
msgid ""
"For both PATA and SATA, a lot of corners are cut for cheap connectors, "
"cables or controllers and it's quite common to see high transmission error "
"rate. This can be mitigated by lowering transmission speed."
msgstr ""

#: ../../../driver-api/libata.rst:966
msgid "The following is a possible scheme Jeff Garzik suggested."
msgstr ""

#: ../../../driver-api/libata.rst:968
msgid "If more than $N (3?) transmission errors happen in 15 minutes,"
msgstr ""

#: ../../../driver-api/libata.rst:970
msgid "if SATA, decrease SATA PHY speed. if speed cannot be decreased,"
msgstr ""

#: ../../../driver-api/libata.rst:972
msgid "decrease UDMA xfer speed. if at UDMA0, switch to PIO4,"
msgstr ""

#: ../../../driver-api/libata.rst:974
msgid "decrease PIO xfer speed. if at PIO3, complain, but continue"
msgstr ""

#: ../../../driver-api/libata.rst:977
msgid "ata_piix Internals"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:496
msgid "Probe host controller cable detect info"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:497
msgid "Port for which cable detect info is desired"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:498
msgid ""
"Read 80c cable indicator from ATA PCI device's PCI config register.  This "
"register is normally set by firmware (BIOS)."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:501
#: ../drivers/ata/ata_piix.c:534 ../drivers/ata/ata_piix.c:642
#: ../drivers/ata/ata_piix.c:659 ../drivers/ata/ata_piix.c:737
#: ../drivers/ata/ata_piix.c:753
msgid "LOCKING: None (inherited from caller)."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:531
msgid "prereset for PATA host controller"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:532
msgid "Target link"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:637
#: ../drivers/ata/ata_piix.c:653
msgid "Initialize host controller PATA PIO timings"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:638
#: ../drivers/ata/ata_piix.c:654 ../drivers/ata/ata_piix.c:733
#: ../drivers/ata/ata_piix.c:749
msgid "Port whose timings we are configuring"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:639
#: ../drivers/ata/ata_piix.c:655
msgid "Drive in question"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:640
msgid "Set PIO mode for device, in host controller PCI config space."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:657
msgid "``int isich``"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:656
msgid "set if the chip is an ICH device"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:657
msgid "Set UDMA mode for device, in host controller PCI config space."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:732
#: ../drivers/ata/ata_piix.c:748
msgid "Initialize host controller PATA DMA timings"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:734
#: ../drivers/ata/ata_piix.c:750
msgid "um"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:735
#: ../drivers/ata/ata_piix.c:751
msgid "Set MW/UDMA mode for device, in host controller PCI config space."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1308
msgid "Check for problem 450NX setup"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1314
msgid "``struct pci_dev *ata_dev``"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1309
msgid "the PCI device to check"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1310
msgid ""
"Check for the present of 450NX errata #19 and errata #25. If they are found "
"return an error code so we can turn off DMA"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1629
msgid "Register PIIX ATA PCI device with kernel services"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1630
msgid "PCI device to register"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1632
msgid "``const struct pci_device_id *ent``"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1631
msgid "Entry in piix_pci_tbl matching with **pdev**"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1632
msgid ""
"Called from kernel PCI layer.  We probe for combined mode (sigh), and then "
"hand over control to libata, for it to do the rest."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1639
msgid "Zero on success, or -ERRNO value."
msgstr ""

#: ../../../driver-api/libata.rst:983
msgid "sata_sil Internals"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:337
msgid "wrap set_mode functions"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:338
msgid "link to set up"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:340
msgid "``struct ata_device **r_failed``"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:339
msgid "returned device when we fail"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:340
msgid ""
"Wrap the libata method for device setup as after the setup we need to "
"inspect the results and do some configuration work"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:584
msgid "Apply device/host-specific errata fixups"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:585
msgid "Device to be examined"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:586
msgid ""
"After the IDENTIFY [PACKET] DEVICE step is complete, and a device is known "
"to be present, this function is called. We apply two errata fixups which are "
"specific to Silicon Image, a Seagate and a Maxtor fixup."
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:591
msgid ""
"For certain Seagate devices, we must limit the maximum sectors to under 8K."
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:594
msgid "For certain Maxtor devices, we must not program the drive beyond udma5."
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:597
msgid ""
"Both fixups are unfairly pessimistic.  As soon as I get more information on "
"these errata, I will create a more exhaustive list, and apply the fixups to "
"only the specific devices/hosts/firmwares that need it."
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:602
msgid ""
"20040111 - Seagate drives affected by the Mod15Write bug are quirked The "
"Maxtor quirk is in sil_quirks, but I'm keeping the original pessimistic fix "
"for the following reasons... - There seems to be less info on it, only one "
"device gleaned off the Windows driver, maybe only one is affected.  More "
"info would be greatly appreciated. - But then again UDMA5 is hardly anything "
"to complain about"
msgstr ""

#: ../../../driver-api/libata.rst:989
msgid "Thanks"
msgstr ""

#: ../../../driver-api/libata.rst:991
msgid ""
"The bulk of the ATA knowledge comes thanks to long conversations with Andre "
"Hedrick (www.linux-ide.org), and long hours pondering the ATA and SCSI "
"specifications."
msgstr ""

#: ../../../driver-api/libata.rst:995
msgid ""
"Thanks to Alan Cox for pointing out similarities between SATA and SCSI, and "
"in general for motivation to hack on libata."
msgstr ""

#: ../../../driver-api/libata.rst:998
msgid ""
"libata's device detection method, ata_pio_devchk, and in general all the "
"early probing was based on extensive study of Hale Landis's probe/reset code "
"in his ATADRVR driver (www.ata-atapi.com)."
msgstr ""
