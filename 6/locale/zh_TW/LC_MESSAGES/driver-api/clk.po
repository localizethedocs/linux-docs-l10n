# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/clk.rst:3
msgid "The Common Clk Framework"
msgstr ""

#: ../../../driver-api/clk.rst:0
msgid "Author"
msgstr ""

#: ../../../driver-api/clk.rst:5
msgid "Mike Turquette <mturquette@ti.com>"
msgstr ""

#: ../../../driver-api/clk.rst:7
msgid ""
"This document endeavours to explain the common clk framework details, and "
"how to port a platform over to this framework.  It is not yet a detailed "
"explanation of the clock api in include/linux/clk.h, but perhaps someday it "
"will include that information."
msgstr ""

#: ../../../driver-api/clk.rst:13
msgid "Introduction and interface split"
msgstr ""

#: ../../../driver-api/clk.rst:15
msgid ""
"The common clk framework is an interface to control the clock nodes "
"available on various devices today.  This may come in the form of clock "
"gating, rate adjustment, muxing or other operations.  This framework is "
"enabled with the CONFIG_COMMON_CLK option."
msgstr ""

#: ../../../driver-api/clk.rst:20
msgid ""
"The interface itself is divided into two halves, each shielded from the "
"details of its counterpart.  First is the common definition of struct clk "
"which unifies the framework-level accounting and infrastructure that has "
"traditionally been duplicated across a variety of platforms.  Second is a "
"common implementation of the clk.h api, defined in drivers/clk/clk.c.  "
"Finally there is struct clk_ops, whose operations are invoked by the clk api "
"implementation."
msgstr ""

#: ../../../driver-api/clk.rst:28
msgid ""
"The second half of the interface is comprised of the hardware-specific "
"callbacks registered with struct clk_ops and the corresponding hardware-"
"specific structures needed to model a particular clock.  For the remainder "
"of this document any reference to a callback in struct clk_ops, such as ."
"enable or .set_rate, implies the hardware-specific implementation of that "
"code.  Likewise, references to struct clk_foo serve as a convenient "
"shorthand for the implementation of the hardware-specific bits for the "
"hypothetical \"foo\" hardware."
msgstr ""

#: ../../../driver-api/clk.rst:37
msgid ""
"Tying the two halves of this interface together is struct clk_hw, which is "
"defined in struct clk_foo and pointed to within struct clk_core.  This "
"allows for easy navigation between the two discrete halves of the common "
"clock interface."
msgstr ""

#: ../../../driver-api/clk.rst:43
msgid "Common data structures and api"
msgstr ""

#: ../../../driver-api/clk.rst:45
msgid ""
"Below is the common struct clk_core definition from drivers/clk/clk.c, "
"modified for brevity::"
msgstr ""

#: ../../../driver-api/clk.rst:61
msgid ""
"The members above make up the core of the clk tree topology.  The clk api "
"itself defines several driver-facing functions which operate on struct clk.  "
"That api is documented in include/linux/clk.h."
msgstr ""

#: ../../../driver-api/clk.rst:65
msgid ""
"Platforms and devices utilizing the common struct clk_core use the struct "
"clk_ops pointer in struct clk_core to perform the hardware-specific parts of "
"the operations defined in clk-provider.h::"
msgstr ""

#: ../../../driver-api/clk.rst:104
msgid "Hardware clk implementations"
msgstr ""

#: ../../../driver-api/clk.rst:106
msgid ""
"The strength of the common struct clk_core comes from its .ops and .hw "
"pointers which abstract the details of struct clk from the hardware-specific "
"bits, and vice versa.  To illustrate consider the simple gateable clk "
"implementation in drivers/clk/clk-gate.c::"
msgstr ""

#: ../../../driver-api/clk.rst:118
msgid ""
"struct clk_gate contains struct clk_hw hw as well as hardware-specific "
"knowledge about which register and bit controls this clk's gating. Nothing "
"about clock topology or accounting, such as enable_count or notifier_count, "
"is needed here.  That is all handled by the common framework code and struct "
"clk_core."
msgstr ""

#: ../../../driver-api/clk.rst:124
msgid "Let's walk through enabling this clk from driver code::"
msgstr ""

#: ../../../driver-api/clk.rst:132
msgid "The call graph for clk_enable is very simple::"
msgstr ""

#: ../../../driver-api/clk.rst:141
msgid "And the definition of clk_gate_set_bit::"
msgstr ""

#: ../../../driver-api/clk.rst:152
msgid "Note that to_clk_gate is defined as::"
msgstr ""

#: ../../../driver-api/clk.rst:156
msgid ""
"This pattern of abstraction is used for every clock hardware representation."
msgstr ""

#: ../../../driver-api/clk.rst:160
msgid "Supporting your own clk hardware"
msgstr ""

#: ../../../driver-api/clk.rst:162
msgid ""
"When implementing support for a new type of clock it is only necessary to "
"include the following header::"
msgstr ""

#: ../../../driver-api/clk.rst:167
msgid ""
"To construct a clk hardware structure for your platform you must define the "
"following::"
msgstr ""

#: ../../../driver-api/clk.rst:175
msgid ""
"To take advantage of your data you'll need to support valid operations for "
"your clk::"
msgstr ""

#: ../../../driver-api/clk.rst:183
msgid "Implement the above functions using container_of::"
msgstr ""

#: ../../../driver-api/clk.rst:198
msgid ""
"Below is a matrix detailing which clk_ops are mandatory based upon the "
"hardware capabilities of that clock.  A cell marked as \"y\" means "
"mandatory, a cell marked as \"n\" implies that either including that "
"callback is invalid or otherwise unnecessary.  Empty cells are either "
"optional or must be evaluated on a case-by-case basis."
msgstr ""

#: ../../../driver-api/clk.rst:204
msgid "clock hardware characteristics"
msgstr ""

#: ../../../driver-api/clk.rst:207
msgid "gate"
msgstr ""

#: ../../../driver-api/clk.rst:207
msgid "change rate"
msgstr ""

#: ../../../driver-api/clk.rst:207
msgid "single parent"
msgstr ""

#: ../../../driver-api/clk.rst:207
msgid "multiplexer"
msgstr ""

#: ../../../driver-api/clk.rst:207
msgid "root"
msgstr ""

#: ../../../driver-api/clk.rst:209
msgid ".prepare"
msgstr ""

#: ../../../driver-api/clk.rst:211
msgid ".unprepare"
msgstr ""

#: ../../../driver-api/clk.rst:214
msgid ".enable"
msgstr ""

#: ../../../driver-api/clk.rst:214 ../../../driver-api/clk.rst:216
#: ../../../driver-api/clk.rst:218 ../../../driver-api/clk.rst:221
#: ../../../driver-api/clk.rst:227 ../../../driver-api/clk.rst:230
#: ../../../driver-api/clk.rst:232
msgid "y"
msgstr ""

#: ../../../driver-api/clk.rst:216
msgid ".disable"
msgstr ""

#: ../../../driver-api/clk.rst:218
msgid ".is_enabled"
msgstr ""

#: ../../../driver-api/clk.rst:221
msgid ".recalc_rate"
msgstr ""

#: ../../../driver-api/clk.rst:223
msgid ".round_rate"
msgstr ""

#: ../../../driver-api/clk.rst:223 ../../../driver-api/clk.rst:225
msgid "y [1]_"
msgstr ""

#: ../../../driver-api/clk.rst:225
msgid ".determine_rate"
msgstr ""

#: ../../../driver-api/clk.rst:227
msgid ".set_rate"
msgstr ""

#: ../../../driver-api/clk.rst:230
msgid ".set_parent"
msgstr ""

#: ../../../driver-api/clk.rst:230 ../../../driver-api/clk.rst:232
msgid "n"
msgstr ""

#: ../../../driver-api/clk.rst:232
msgid ".get_parent"
msgstr ""

#: ../../../driver-api/clk.rst:235
msgid ".recalc_accuracy"
msgstr ""

#: ../../../driver-api/clk.rst:238
msgid ".init"
msgstr ""

#: ../../../driver-api/clk.rst:241
msgid "either one of round_rate or determine_rate is required."
msgstr ""

#: ../../../driver-api/clk.rst:243
msgid ""
"Finally, register your clock at run-time with a hardware-specific "
"registration function.  This function simply populates struct clk_foo's data "
"and then passes the common struct clk parameters to the framework with a "
"call to::"
msgstr ""

#: ../../../driver-api/clk.rst:250
msgid "See the basic clock types in ``drivers/clk/clk-*.c`` for examples."
msgstr ""

#: ../../../driver-api/clk.rst:253
msgid "Disabling clock gating of unused clocks"
msgstr ""

#: ../../../driver-api/clk.rst:255
msgid ""
"Sometimes during development it can be useful to be able to bypass the "
"default disabling of unused clocks. For example, if drivers aren't enabling "
"clocks properly but rely on them being on from the bootloader, bypassing the "
"disabling means that the driver will remain functional while the issues are "
"sorted out."
msgstr ""

#: ../../../driver-api/clk.rst:261
msgid ""
"You can see which clocks have been disabled by booting your kernel with "
"these parameters::"
msgstr ""

#: ../../../driver-api/clk.rst:266
msgid ""
"To bypass this disabling, include \"clk_ignore_unused\" in the bootargs to "
"the kernel."
msgstr ""

#: ../../../driver-api/clk.rst:270
msgid "Locking"
msgstr ""

#: ../../../driver-api/clk.rst:272
msgid ""
"The common clock framework uses two global locks, the prepare lock and the "
"enable lock."
msgstr ""

#: ../../../driver-api/clk.rst:275
msgid ""
"The enable lock is a spinlock and is held across calls to the .enable, ."
"disable operations. Those operations are thus not allowed to sleep, and "
"calls to the clk_enable(), clk_disable() API functions are allowed in atomic "
"context."
msgstr ""

#: ../../../driver-api/clk.rst:280
msgid ""
"For clk_is_enabled() API, it is also designed to be allowed to be used in "
"atomic context. However, it doesn't really make any sense to hold the enable "
"lock in core, unless you want to do something else with the information of "
"the enable state with that lock held. Otherwise, seeing if a clk is enabled "
"is a one-shot read of the enabled state, which could just as easily change "
"after the function returns because the lock is released. Thus the user of "
"this API needs to handle synchronizing the read of the state with whatever "
"they're using it for to make sure that the enable state doesn't change "
"during that time."
msgstr ""

#: ../../../driver-api/clk.rst:290
msgid ""
"The prepare lock is a mutex and is held across calls to all other "
"operations. All those operations are allowed to sleep, and calls to the "
"corresponding API functions are not allowed in atomic context."
msgstr ""

#: ../../../driver-api/clk.rst:294
msgid ""
"This effectively divides operations in two groups from a locking perspective."
msgstr ""

#: ../../../driver-api/clk.rst:296
msgid ""
"Drivers don't need to manually protect resources shared between the "
"operations of one group, regardless of whether those resources are shared by "
"multiple clocks or not. However, access to resources that are shared between "
"operations of the two groups needs to be protected by the drivers. An "
"example of such a resource would be a register that controls both the clock "
"rate and the clock enable/disable state."
msgstr ""

#: ../../../driver-api/clk.rst:303
msgid ""
"The clock framework is reentrant, in that a driver is allowed to call clock "
"framework functions from within its implementation of clock operations. This "
"can for instance cause a .set_rate operation of one clock being called from "
"within the .set_rate operation of another clock. This case must be "
"considered in the driver implementations, but the code flow is usually "
"controlled by the driver in that case."
msgstr ""

#: ../../../driver-api/clk.rst:310
msgid ""
"Note that locking must also be considered when code outside of the common "
"clock framework needs to access resources used by the clock operations. This "
"is considered out of scope of this document."
msgstr ""
