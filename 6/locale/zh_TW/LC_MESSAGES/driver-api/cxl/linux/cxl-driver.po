# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/cxl/linux/cxl-driver.rst:5
msgid "CXL Driver Operation"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:7
msgid "The devices described in this section are present in ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:12
msgid ""
"The :code:`cxl-cli` library, maintained as part of the NDTCL project, may be "
"used to script interactions with these devices."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:16
msgid "Drivers"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:17
msgid "The CXL driver is split into a number of drivers."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:19
msgid "cxl_core  - fundamental init interface and core object creation"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:20
msgid "cxl_port  - initializes root and provides port enumeration interface."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:21
msgid "cxl_acpi  - initializes root decoders and interacts with ACPI data."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:22
msgid "cxl_p/mem - initializes memory devices"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:23
msgid "cxl_pci   - uses cxl_port to enumerate the actual fabric hierarchy."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:26
msgid "Driver Devices"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:27
msgid ""
"Here is an example from a single-socket system with 4 host bridges. Two host "
"bridges have a single memory device attached, and the devices are "
"interleaved into a single memory region. The memory region has been "
"converted to dax. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:63
msgid ""
"For this section we'll explore the devices present in this configuration, "
"but we'll explore more configurations in-depth in example configurations "
"below."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:67
msgid "Base Devices"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:68
msgid ""
"Most devices in a CXL fabric are a `port` of some kind (because each device "
"mostly routes request from one device to the next, rather than provide a "
"direct service)."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:73
msgid "Root"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:74
msgid ""
"The `CXL Root` is logical object created by the `cxl_acpi` driver during :"
"code:`cxl_acpi_probe` - if the :code:`ACPI0017` `Compute Express Link Root "
"Object` Device Class is found."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:78
msgid "The Root contains links to:"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:80
msgid ""
"`Host Bridge Ports` defined by CHBS in the :doc:`CEDT<../platform/acpi/cedt>`"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:82
msgid "`Downstream Ports` typically connected to `Host Bridge Ports`."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:84
msgid "`Root Decoders` defined by CFMWS the :doc:`CEDT<../platform/acpi/cedt>`"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:102
msgid ""
"The root is first `logical port` in the CXL fabric, as presented by the "
"Linux CXL driver.  The `CXL root` is a special type of `switch port`, in "
"that it only has downstream port connections."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:107
msgid "Port"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:108
msgid ""
"A `port` object is better described as a `switch port`.  It may represent a "
"host bridge to the root or an actual switch port on a switch. A `switch "
"port` contains one or more decoders used to route memory requests downstream "
"ports, which may be connected to another `switch port` or an `endpoint port`."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:129
msgid ""
"CXL `Host Bridges` in the fabric are probed during :code:`cxl_acpi_probe` at "
"the time the `CXL Root` is probed.  The allows for the immediate logical "
"connection to between the root and host bridge."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:133
msgid "The root has a downstream port connection to a host bridge"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:135
msgid "The host bridge has an upstream port connection to the root."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:137
msgid ""
"The host bridge has one or more downstream port connections to switch or "
"endpoint ports."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:140
msgid ""
"A `Host Bridge` is a special type of CXL `switch port`. It is explicitly "
"defined in the ACPI specification via `ACPI0016` ID.  `Host Bridge` ports "
"will be probed at `acpi_probe` time, while similar ports on an actual switch "
"will be probed later.  Otherwise, switch and host bridge ports look very "
"similar - the both contain switch decoders which route accesses between "
"upstream and downstream ports."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:148
msgid "Endpoint"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:149
msgid ""
"An `endpoint` is a terminal port in the fabric.  This is a `logical device`, "
"and may be one of many `logical devices` presented by a memory device. It is "
"still considered a type of `port` in the fabric."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:153
msgid ""
"An `endpoint` contains `endpoint decoders` and the device's Coherent Device "
"Attribute Table (which describes the device's capabilities). ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:169
msgid "Memory Device (memdev)"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:170
msgid ""
"A `memdev` is probed and added by the `cxl_pci` driver in :code:"
"`cxl_pci_probe` and is managed by the `cxl_mem` driver. It primarily "
"provides the `IOCTL` interface to a memory device, via :code:`/dev/cxl/"
"memN`, and exposes various device configuration data. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:180
msgid ""
"A Memory Device is a discrete base object that is not a port.  While the "
"physical device it belongs to may also host an `endpoint`, the relationship "
"between an `endpoint` and a `memdev` is not captured in sysfs."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:185
msgid "Port Relationships"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:186
msgid ""
"In our example described above, there are four host bridges attached to the "
"root, and two of the host bridges have one endpoint attached."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:203
msgid "Decoders"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:204
msgid ""
"A `Decoder` is short for a CXL Host-Managed Device Memory (HDM) Decoder. It "
"is a device that routes accesses through the CXL fabric to an endpoint, and "
"at the endpoint translates a `Host Physical` to `Device Physical` Addressing."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:208
msgid ""
"The CXL 3.1 specification heavily implies that only endpoint decoders should "
"engage in translation of `Host Physical Address` to `Device Physical "
"Address`. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:220
msgid "These notes imply that there are two logical groups of decoders."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:222
msgid ""
"Routing Decoder - a decoder which routes accesses but does not translate "
"addresses from HPA to DPA."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:225
msgid ""
"Translating Decoder - a decoder which translates accesses from HPA to DPA "
"for an endpoint to service."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:228
msgid ""
"The CXL drivers distinguish 3 decoder types: root, switch, and endpoint. "
"Only endpoint decoders are Translating Decoders, all others are Routing "
"Decoders."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:231
msgid "PLATFORM VENDORS BE AWARE"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:233
msgid ""
"Linux makes a strong assumption that endpoint decoders are the only decoder "
"in the fabric that actively translates HPA to DPA.  Linux assumes routing "
"decoders pass the HPA unchanged to the next decoder in the fabric."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:237
msgid ""
"It is therefore assumed that any given decoder in the fabric will have an "
"address range that is a subset of its upstream port decoder. Any deviation "
"from this scheme undefined per the specification.  Linux prioritizes spec-"
"defined / architectural behavior."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:242
msgid ""
"Decoders may have one or more `Downstream Targets` if configured to "
"interleave memory accesses.  This will be presented in sysfs via the :code:"
"`target_list` parameter."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:247
msgid "Root Decoder"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:248
msgid ""
"A `Root Decoder` is logical construct of the physical address and interleave "
"configurations present in the CFMWS field of the :doc:`CEDT <../platform/"
"acpi/cedt>`. Linux presents this information as a decoder present in the "
"`CXL Root`.  We consider this a `Root Decoder`, though technically it exists "
"on the boundary of the CXL specification and platform-specific CXL root "
"implementations."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:255
msgid ""
"Linux considers these logical decoders a type of `Routing Decoder`, and is "
"the first decoder in the CXL fabric to receive a memory access from the "
"platform's memory controllers."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:259
msgid ""
"`Root Decoders` are created during :code:`cxl_acpi_probe`.  One root decoder "
"is created per CFMWS entry in the :doc:`CEDT <../platform/acpi/cedt>`."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:262
msgid ""
"The :code:`target_list` parameter is filled by the CFMWS target fields. "
"Targets of a root decoder are `Host Bridges`, which means interleave done at "
"the root decoder level is an `Inter-Host-Bridge Interleave`."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:266
msgid "Only root decoders are capable of `Inter-Host-Bridge Interleave`."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:268
msgid ""
"Such interleaves must be configured by the platform and described in the "
"ACPI CEDT CFMWS, as the target CXL host bridge UIDs in the CFMWS must match "
"the CXL host bridge UIDs in the CHBS field of the :doc:`CEDT <../platform/"
"acpi/cedt>` and the UID field of CXL Host Bridges defined in the :doc:`DSDT "
"<../platform/acpi/dsdt>`."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:274
msgid ""
"Interleave settings in a root decoder describe how to interleave accesses "
"among the *immediate downstream targets*, not the entire interleave set."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:277
msgid "The memory range described in the root decoder is used to"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:279
msgid "Create a memory region (:code:`region0` in this example), and"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:281
msgid ""
"Associate the region with an IO Memory Resource (:code:`kernel/resource.c`)"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:296
msgid ""
"The IO Memory Resource is created during early boot when the CFMWS region is "
"identified in the EFI Memory Map or E820 table (on x86)."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:299
msgid ""
"Root decoders are defined as a separate devtype, but are also a type of "
"`Switch Decoder` due to having downstream targets. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:306
msgid "Switch Decoder"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:307
msgid ""
"Any non-root, translating decoder is considered a `Switch Decoder`, and will "
"present with the type :code:`cxl_decoder_switch`. Both `Host Bridge` and "
"`CXL Switch` (device) decoders are of type :code:`cxl_decoder_switch`. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:322
msgid ""
"A `Switch Decoder` has associations between a region defined by a root "
"decoder and downstream target ports.  Interleaving done within a switch "
"decoder is a multi-downstream-port interleave (or `Intra-Host-Bridge "
"Interleave` for host bridges)."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:327
msgid ""
"Interleave settings in a switch decoder describe how to interleave accesses "
"among the *immediate downstream targets*, not the entire interleave set."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:330
msgid ""
"Switch decoders are created during :code:`cxl_switch_port_probe` in the :"
"code:`cxl_port` driver, and is created based on a PCI device's DVSEC "
"registers."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:334
msgid ""
"Switch decoder programming is validated during probe if the platform "
"programs them during boot (See `Auto Decoders` below), or on commit if "
"programmed at runtime (See `Runtime Programming` below)."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:340
msgid "Endpoint Decoder"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:341
msgid ""
"Any decoder attached to a *terminal* point in the CXL fabric (`An Endpoint`) "
"is considered an `Endpoint Decoder`. Endpoint decoders are of type :code:"
"`cxl_decoder_endpoint`. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:358
msgid ""
"An `Endpoint Decoder` has an association with a region defined by a root "
"decoder and describes the device-local resource associated with this region."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:361
msgid ""
"Unlike root and switch decoders, endpoint decoders translate `Host Physical` "
"to `Device Physical` address ranges.  The interleave settings on an endpoint "
"therefore describe the entire *interleave set*."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:365
msgid ""
"`Device Physical Address` regions must be committed in-order. For example, "
"the DPA region starting at 0x80000000 cannot be committed before the DPA "
"region starting at 0x0."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:369
msgid ""
"As of Linux v6.15, Linux does not support *imbalanced* interleave setups, "
"all endpoints in an interleave set are expected to have the same interleave "
"settings (granularity and ways must be the same)."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:373
msgid ""
"Endpoint decoders are created during :code:`cxl_endpoint_port_probe` in the :"
"code:`cxl_port` driver, and is created based on a PCI device's DVSEC "
"registers."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:377
msgid "Decoder Relationships"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:378
msgid ""
"In our example described above, there is one root decoder which routes "
"memory accesses over two host bridges.  Each host bridge has a decoder which "
"routes access to their singular endpoint targets.  Each endpoint has a "
"decoder which translates HPA to DPA and services the memory request."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:383
msgid ""
"The driver validates relationships between ports by decoder programming, so "
"we can think of decoders being related in a similarly hierarchical fashion "
"to ports."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:400
msgid "Regions"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:403
msgid "Memory Region"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:404
msgid ""
"A `Memory Region` is a logical construct that connects a set of CXL ports in "
"the fabric to an IO Memory Resource.  It is ultimately used to expose the "
"memory on these devices to the DAX subsystem via a `DAX Region`."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:408
msgid "An example RAM region: ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:416
msgid ""
"A memory region can be constructed during endpoint probe, if decoders were "
"programmed by BIOS/EFI (see `Auto Decoders`), or by creating a region "
"manually via a `Root Decoder`'s :code:`create_ram_region` or :code:"
"`create_pmem_region` interfaces."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:421
msgid ""
"The interleave settings in a `Memory Region` describe the configuration of "
"the `Interleave Set` - and are what can be expected to be seen in the "
"endpoint interleave settings."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:438
msgid "DAX Region"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:439
msgid ""
"A `DAX Region` is used to convert a CXL `Memory Region` to a DAX device. A "
"DAX device may then be accessed directly via a file descriptor interface, or "
"converted to System RAM via the DAX kmem driver.  See the DAX driver section "
"for more details. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:449
msgid "Mailbox Interfaces"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:450
msgid "A mailbox command interface for each device is exposed in ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:455
msgid ""
"These mailboxes may receive any specification-defined command. Raw commands "
"(custom commands) can only be sent to these interfaces if the build config :"
"code:`CXL_MEM_RAW_COMMANDS` is set.  This is considered a debug and/or "
"development interface, not an officially supported mechanism for creation of "
"vendor-specific commands (see the `fwctl` subsystem for that)."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:462
msgid "Decoder Programming"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:465
msgid "Runtime Programming"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:466
msgid ""
"During probe, the only decoders *required* to be programmed are `Root "
"Decoders`. In reality, `Root Decoders` are a logical construct to describe "
"the memory region and interleave configuration at the host bridge level - as "
"described in the ACPI CEDT CFMWS."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:471
msgid ""
"All other `Switch` and `Endpoint` decoders may be programmed by the user at "
"runtime - if the platform supports such configurations."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:474
msgid ""
"This interaction is what creates a `Software Defined Memory` environment."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:476
msgid ""
"See the :code:`cxl-cli` documentation for more information about how to "
"configure CXL decoders at runtime."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:480
msgid "Auto Decoders"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:481
msgid ""
"Auto Decoders are decoders programmed by BIOS/EFI at boot time, and are "
"almost always locked (cannot be changed).  This is done by a platform which "
"may have a static configuration - or certain quirks which may prevent "
"dynamic runtime changes to the decoders (such as requiring additional "
"controller programming within the CPU complex outside the scope of CXL)."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:487
msgid ""
"Auto Decoders are probed automatically as long as the devices and memory "
"regions they are associated with probe without issue.  When probing Auto "
"Decoders, the driver's primary responsibility is to ensure the fabric is "
"sane - as-if validating runtime programmed regions and decoders."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:492
msgid ""
"If Linux cannot validate auto-decoder configuration, the memory will not be "
"surfaced as a DAX device - and therefore not be exposed to the page "
"allocator - effectively stranding it."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:497
msgid "Interleave"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:499
msgid ""
"The Linux CXL driver supports `Cross-Link First` interleave. This dictates "
"how interleave is programmed at each decoder step, as the driver validates "
"the relationships between a decoder and it's parent."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:503
msgid ""
"For example, in a `Cross-Link First` interleave setup with 16 endpoints "
"attached to 4 host bridges, linux expects the following ways/granularity "
"across the root, host bridge, and endpoints respectively."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:507
msgid "4x4 cross-link first interleave settings"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:509
msgid "decoder"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:510
msgid "ways"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:511
msgid "granularity"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:513
msgid "root"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:514
#: ../../../driver-api/cxl/linux/cxl-driver.rst:518
msgid "4"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:515
#: ../../../driver-api/cxl/linux/cxl-driver.rst:523
msgid "256"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:517
msgid "host bridge"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:519
msgid "1024"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:521
msgid "endpoint"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:522
msgid "16"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:525
msgid ""
"At the root, every a given access will be routed to the :code:`((HPA / 256) "
"% 4)th` target host bridge. Within a host bridge, every :code:`((HPA / 1024) "
"% 4)th` target endpoint.  Each endpoint translates based on the entire 16 "
"device interleave set."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:530
msgid ""
"Unbalanced interleave sets are not supported - decoders at a similar point "
"in the hierarchy (e.g. all host bridge decoders) must have the same ways and "
"granularity configuration."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:535
msgid "At Root"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:536
msgid ""
"Root decoder interleave is defined by CFMWS field of the :doc:`CEDT <../"
"platform/acpi/cedt>`.  The CEDT may actually define multiple CFMWS "
"configurations to describe the same physical capacity, with the intent to "
"allow users to decide at runtime whether to online memory as interleaved or "
"non-interleaved. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:564
msgid ""
"In this example, the CFMWS defines two discrete non-interleaved 4GB regions "
"for each host bridge, and one interleaved 8GB region that targets both. This "
"would result in 3 root decoders presenting in the root. ::"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:586
msgid ""
"These decoders are not runtime programmable.  They are used to generate a "
"`Memory Region` to bring this memory online with runtime programmed settings "
"at the `Switch` and `Endpoint` decoders."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:591
msgid "At Host Bridge or Switch"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:592
msgid ""
"`Host Bridge` and `Switch` decoders are programmable via the following "
"fields:"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:594
#: ../../../driver-api/cxl/linux/cxl-driver.rst:611
msgid ":code:`start` - the HPA region associated with the memory region"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:595
#: ../../../driver-api/cxl/linux/cxl-driver.rst:612
msgid ":code:`size` - the size of the region"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:596
msgid ":code:`target_list` - the list of downstream ports"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:597
msgid ""
":code:`interleave_ways` - the number downstream ports to interleave across"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:598
#: ../../../driver-api/cxl/linux/cxl-driver.rst:614
msgid ":code:`interleave_granularity` - the granularity to interleave at."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:600
msgid ""
"Linux expects the :code:`interleave_granularity` of switch decoders to be "
"derived from their upstream port connections. In `Cross-Link First` "
"interleave configurations, the :code:`interleave_granularity` of a decoder "
"is equal to :code:`parent_interleave_granularity * parent_interleave_ways`."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:606
msgid "At Endpoint"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:607
msgid ""
"`Endpoint Decoders` are programmed similar to Host Bridge and Switch "
"decoders, with the exception that the ways and granularity are defined by "
"the interleave set (e.g. the interleave settings defined by the associated "
"`Memory Region`)."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:613
msgid ":code:`interleave_ways` - the number endpoints in the interleave set"
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:616
msgid ""
"These settings are used by endpoint decoders to *Translate* memory requests "
"from HPA to DPA.  This is why they must be aware of the entire interleave "
"set."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:619
msgid ""
"Linux does not support unbalanced interleave configurations.  As a result, "
"all endpoints in an interleave set must have the same ways and granularity."
msgstr ""

#: ../../../driver-api/cxl/linux/cxl-driver.rst:623
msgid "Example Configurations"
msgstr ""
