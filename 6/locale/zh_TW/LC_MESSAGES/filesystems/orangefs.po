# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/orangefs.rst:5
msgid "ORANGEFS"
msgstr ""

#: ../../../filesystems/orangefs.rst:7
msgid ""
"OrangeFS is an LGPL userspace scale-out parallel storage system. It is ideal "
"for large storage problems faced by HPC, BigData, Streaming Video, Genomics, "
"Bioinformatics."
msgstr ""

#: ../../../filesystems/orangefs.rst:11
msgid ""
"Orangefs, originally called PVFS, was first developed in 1993 by Walt Ligon "
"and Eric Blumer as a parallel file system for Parallel Virtual Machine (PVM) "
"as part of a NASA grant to study the I/O patterns of parallel programs."
msgstr ""

#: ../../../filesystems/orangefs.rst:16
msgid "Orangefs features include:"
msgstr ""

#: ../../../filesystems/orangefs.rst:18
msgid "Distributes file data among multiple file servers"
msgstr ""

#: ../../../filesystems/orangefs.rst:19
msgid "Supports simultaneous access by multiple clients"
msgstr ""

#: ../../../filesystems/orangefs.rst:20
msgid ""
"Stores file data and metadata on servers using local file system and access "
"methods"
msgstr ""

#: ../../../filesystems/orangefs.rst:22
msgid "Userspace implementation is easy to install and maintain"
msgstr ""

#: ../../../filesystems/orangefs.rst:23
msgid "Direct MPI support"
msgstr ""

#: ../../../filesystems/orangefs.rst:24
msgid "Stateless"
msgstr ""

#: ../../../filesystems/orangefs.rst:28
msgid "Mailing List Archives"
msgstr ""

#: ../../../filesystems/orangefs.rst:30
msgid "http://lists.orangefs.org/pipermail/devel_lists.orangefs.org/"
msgstr ""

#: ../../../filesystems/orangefs.rst:34
msgid "Mailing List Submissions"
msgstr ""

#: ../../../filesystems/orangefs.rst:36
msgid "devel@lists.orangefs.org"
msgstr ""

#: ../../../filesystems/orangefs.rst:40
msgid "Documentation"
msgstr ""

#: ../../../filesystems/orangefs.rst:42
msgid "http://www.orangefs.org/documentation/"
msgstr ""

#: ../../../filesystems/orangefs.rst:45
msgid "Running ORANGEFS On a Single Server"
msgstr ""

#: ../../../filesystems/orangefs.rst:47
msgid ""
"OrangeFS is usually run in large installations with multiple servers and "
"clients, but a complete filesystem can be run on a single machine for "
"development and testing."
msgstr ""

#: ../../../filesystems/orangefs.rst:51
msgid "On Fedora, install orangefs and orangefs-server::"
msgstr ""

#: ../../../filesystems/orangefs.rst:55
msgid ""
"There is an example server configuration file in /etc/orangefs/orangefs."
"conf.  Change localhost to your hostname if necessary."
msgstr ""

#: ../../../filesystems/orangefs.rst:59
msgid "To generate a filesystem to run xfstests against, see below."
msgstr ""

#: ../../../filesystems/orangefs.rst:61
msgid ""
"There is an example client configuration file in /etc/pvfs2tab.  It is a "
"single line.  Uncomment it and change the hostname if necessary.  This "
"controls clients which use libpvfs2.  This does not control the pvfs2-client-"
"core."
msgstr ""

#: ../../../filesystems/orangefs.rst:66
msgid "Create the filesystem::"
msgstr ""

#: ../../../filesystems/orangefs.rst:70 ../../../filesystems/orangefs.rst:135
msgid "Start the server::"
msgstr ""

#: ../../../filesystems/orangefs.rst:74
msgid "Test the server::"
msgstr ""

#: ../../../filesystems/orangefs.rst:78
msgid ""
"Start the client.  The module must be compiled in or loaded before this "
"point::"
msgstr ""

#: ../../../filesystems/orangefs.rst:83
msgid "Mount the filesystem::"
msgstr ""

#: ../../../filesystems/orangefs.rst:88
msgid "Userspace Filesystem Source"
msgstr ""

#: ../../../filesystems/orangefs.rst:90
msgid "http://www.orangefs.org/download"
msgstr ""

#: ../../../filesystems/orangefs.rst:92
msgid ""
"Orangefs versions prior to 2.9.3 would not be compatible with the upstream "
"version of the kernel client."
msgstr ""

#: ../../../filesystems/orangefs.rst:97
msgid "Building ORANGEFS on a Single Server"
msgstr ""

#: ../../../filesystems/orangefs.rst:99
msgid ""
"Where OrangeFS cannot be installed from distribution packages, it may be "
"built from source."
msgstr ""

#: ../../../filesystems/orangefs.rst:102
msgid ""
"You can omit --prefix if you don't care that things are sprinkled around in /"
"usr/local.  As of version 2.9.6, OrangeFS uses Berkeley DB by default, we "
"will probably be changing the default to LMDB soon."
msgstr ""

#: ../../../filesystems/orangefs.rst:114
msgid ""
"Create an orangefs config file by running pvfs2-genconfig and specifying a "
"target config file. Pvfs2-genconfig will prompt you through. Generally it "
"works fine to take the defaults, but you should use your server's hostname, "
"rather than \"localhost\" when it comes to that question::"
msgstr ""

#: ../../../filesystems/orangefs.rst:122
msgid "Create an /etc/pvfs2tab file (localhost is fine)::"
msgstr ""

#: ../../../filesystems/orangefs.rst:127
msgid "Create the mount point you specified in the tab file if needed::"
msgstr ""

#: ../../../filesystems/orangefs.rst:131
msgid "Bootstrap the server::"
msgstr ""

#: ../../../filesystems/orangefs.rst:139
msgid ""
"Now the server should be running. Pvfs2-ls is a simple test to verify that "
"the server is running::"
msgstr ""

#: ../../../filesystems/orangefs.rst:144
msgid ""
"If stuff seems to be working, load the kernel module and turn on the client "
"core::"
msgstr ""

#: ../../../filesystems/orangefs.rst:149
msgid "Mount your filesystem::"
msgstr ""

#: ../../../filesystems/orangefs.rst:155
msgid "Running xfstests"
msgstr ""

#: ../../../filesystems/orangefs.rst:157
msgid ""
"It is useful to use a scratch filesystem with xfstests.  This can be done "
"with only one server."
msgstr ""

#: ../../../filesystems/orangefs.rst:160
msgid ""
"Make a second copy of the FileSystem section in the server configuration "
"file, which is /etc/orangefs/orangefs.conf.  Change the Name to scratch. "
"Change the ID to something other than the ID of the first FileSystem section "
"(2 is usually a good choice)."
msgstr ""

#: ../../../filesystems/orangefs.rst:165
msgid "Then there are two FileSystem sections: orangefs and scratch."
msgstr ""

#: ../../../filesystems/orangefs.rst:167
msgid "This change should be made before creating the filesystem."
msgstr ""

#: ../../../filesystems/orangefs.rst:173
msgid "To run xfstests, create /etc/xfsqa.config::"
msgstr ""

#: ../../../filesystems/orangefs.rst:180
msgid "Then xfstests can be run::"
msgstr ""

#: ../../../filesystems/orangefs.rst:186
msgid "Options"
msgstr ""

#: ../../../filesystems/orangefs.rst:188
msgid "The following mount options are accepted:"
msgstr ""

#: ../../../filesystems/orangefs.rst:190
msgid "acl"
msgstr ""

#: ../../../filesystems/orangefs.rst:191
msgid "Allow the use of Access Control Lists on files and directories."
msgstr ""

#: ../../../filesystems/orangefs.rst:193
msgid "intr"
msgstr ""

#: ../../../filesystems/orangefs.rst:194
msgid ""
"Some operations between the kernel client and the user space filesystem can "
"be interruptible, such as changes in debug levels and the setting of tunable "
"parameters."
msgstr ""

#: ../../../filesystems/orangefs.rst:198
msgid "local_lock"
msgstr ""

#: ../../../filesystems/orangefs.rst:199
msgid ""
"Enable posix locking from the perspective of \"this\" kernel. The default "
"file_operations lock action is to return ENOSYS. Posix locking kicks in if "
"the filesystem is mounted with -o local_lock. Distributed locking is being "
"worked on for the future."
msgstr ""

#: ../../../filesystems/orangefs.rst:206
msgid "Debugging"
msgstr ""

#: ../../../filesystems/orangefs.rst:208
msgid ""
"If you want the debug (GOSSIP) statements in a particular source file (inode."
"c for example) go to syslog::"
msgstr ""

#: ../../../filesystems/orangefs.rst:213
msgid "No debugging (the default)::"
msgstr ""

#: ../../../filesystems/orangefs.rst:217
msgid "Debugging from several source files::"
msgstr ""

#: ../../../filesystems/orangefs.rst:221
msgid "All debugging::"
msgstr ""

#: ../../../filesystems/orangefs.rst:225
msgid "Get a list of all debugging keywords::"
msgstr ""

#: ../../../filesystems/orangefs.rst:231
msgid "Protocol between Kernel Module and Userspace"
msgstr ""

#: ../../../filesystems/orangefs.rst:233
msgid ""
"Orangefs is a user space filesystem and an associated kernel module. We'll "
"just refer to the user space part of Orangefs as \"userspace\" from here on "
"out. Orangefs descends from PVFS, and userspace code still uses PVFS for "
"function and variable names. Userspace typedefs many of the important "
"structures. Function and variable names in the kernel module have been "
"transitioned to \"orangefs\", and The Linux Coding Style avoids typedefs, so "
"kernel module structures that correspond to userspace structures are not "
"typedefed."
msgstr ""

#: ../../../filesystems/orangefs.rst:242
msgid ""
"The kernel module implements a pseudo device that userspace can read from "
"and write to. Userspace can also manipulate the kernel module through the "
"pseudo device with ioctl."
msgstr ""

#: ../../../filesystems/orangefs.rst:247
msgid "The Bufmap"
msgstr ""

#: ../../../filesystems/orangefs.rst:249
msgid ""
"At startup userspace allocates two page-size-aligned (posix_memalign) "
"mlocked memory buffers, one is used for IO and one is used for readdir "
"operations. The IO buffer is 41943040 bytes and the readdir buffer is "
"4194304 bytes. Each buffer contains logical chunks, or partitions, and a "
"pointer to each buffer is added to its own PVFS_dev_map_desc structure which "
"also describes its total size, as well as the size and number of the "
"partitions."
msgstr ""

#: ../../../filesystems/orangefs.rst:257
msgid ""
"A pointer to the IO buffer's PVFS_dev_map_desc structure is sent to a "
"mapping routine in the kernel module with an ioctl. The structure is copied "
"from user space to kernel space with copy_from_user and is used to "
"initialize the kernel module's \"bufmap\" (struct orangefs_bufmap), which "
"then contains:"
msgstr ""

#: ../../../filesystems/orangefs.rst:263
msgid "refcnt - a reference counter"
msgstr ""

#: ../../../filesystems/orangefs.rst:265
msgid ""
"desc_size - PVFS2_BUFMAP_DEFAULT_DESC_SIZE (4194304) - the IO buffer's "
"partition size, which represents the filesystem's block size and is used for "
"s_blocksize in super blocks."
msgstr ""

#: ../../../filesystems/orangefs.rst:268
msgid ""
"desc_count - PVFS2_BUFMAP_DEFAULT_DESC_COUNT (10) - the number of partitions "
"in the IO buffer."
msgstr ""

#: ../../../filesystems/orangefs.rst:270
msgid ""
"desc_shift - log2(desc_size), used for s_blocksize_bits in super blocks."
msgstr ""

#: ../../../filesystems/orangefs.rst:271
msgid "total_size - the total size of the IO buffer."
msgstr ""

#: ../../../filesystems/orangefs.rst:272
msgid "page_count - the number of 4096 byte pages in the IO buffer."
msgstr ""

#: ../../../filesystems/orangefs.rst:273
msgid ""
"page_array - a pointer to ``page_count * (sizeof(struct page*))`` bytes of "
"kcalloced memory. This memory is used as an array of pointers to each of the "
"pages in the IO buffer through a call to get_user_pages."
msgstr ""

#: ../../../filesystems/orangefs.rst:276
msgid ""
"desc_array - a pointer to ``desc_count * (sizeof(struct "
"orangefs_bufmap_desc))`` bytes of kcalloced memory. This memory is further "
"initialized:"
msgstr ""

#: ../../../filesystems/orangefs.rst:279
msgid ""
"user_desc is the kernel's copy of the IO buffer's ORANGEFS_dev_map_desc "
"structure. user_desc->ptr points to the IO buffer."
msgstr ""

#: ../../../filesystems/orangefs.rst:300
msgid ""
"buffer_index_array - a desc_count sized array of ints, used to indicate "
"which of the IO buffer's partitions are available to use."
msgstr ""

#: ../../../filesystems/orangefs.rst:302
msgid ""
"buffer_index_lock - a spinlock to protect buffer_index_array during update."
msgstr ""

#: ../../../filesystems/orangefs.rst:303
msgid ""
"readdir_index_array - a five (ORANGEFS_READDIR_DEFAULT_DESC_COUNT) element "
"int array used to indicate which of the readdir buffer's partitions are "
"available to use."
msgstr ""

#: ../../../filesystems/orangefs.rst:306
msgid ""
"readdir_index_lock - a spinlock to protect readdir_index_array during update."
msgstr ""

#: ../../../filesystems/orangefs.rst:310
msgid "Operations"
msgstr ""

#: ../../../filesystems/orangefs.rst:312
msgid ""
"The kernel module builds an \"op\" (struct orangefs_kernel_op_s) when it "
"needs to communicate with userspace. Part of the op contains the \"upcall\" "
"which expresses the request to userspace. Part of the op eventually contains "
"the \"downcall\" which expresses the results of the request."
msgstr ""

#: ../../../filesystems/orangefs.rst:317
msgid "The slab allocator is used to keep a cache of op structures handy."
msgstr ""

#: ../../../filesystems/orangefs.rst:319
msgid ""
"At init time the kernel module defines and initializes a request list and an "
"in_progress hash table to keep track of all the ops that are in flight at "
"any given time."
msgstr ""

#: ../../../filesystems/orangefs.rst:323
msgid "Ops are stateful:"
msgstr ""

#: ../../../filesystems/orangefs.rst:325
msgid "unknown"
msgstr ""

#: ../../../filesystems/orangefs.rst:326
msgid "op was just initialized"
msgstr ""

#: ../../../filesystems/orangefs.rst:327
msgid "waiting"
msgstr ""

#: ../../../filesystems/orangefs.rst:328
msgid "op is on request_list (upward bound)"
msgstr ""

#: ../../../filesystems/orangefs.rst:329
msgid "inprogr"
msgstr ""

#: ../../../filesystems/orangefs.rst:330
msgid "op is in progress (waiting for downcall)"
msgstr ""

#: ../../../filesystems/orangefs.rst:331
msgid "serviced"
msgstr ""

#: ../../../filesystems/orangefs.rst:332
msgid "op has matching downcall; ok"
msgstr ""

#: ../../../filesystems/orangefs.rst:333
msgid "purged"
msgstr ""

#: ../../../filesystems/orangefs.rst:334
msgid ""
"op has to start a timer since client-core exited uncleanly before servicing "
"op"
msgstr ""

#: ../../../filesystems/orangefs.rst:336
msgid "given up"
msgstr ""

#: ../../../filesystems/orangefs.rst:337
msgid "submitter has given up waiting for it"
msgstr ""

#: ../../../filesystems/orangefs.rst:339
msgid ""
"When some arbitrary userspace program needs to perform a filesystem "
"operation on Orangefs (readdir, I/O, create, whatever) an op structure is "
"initialized and tagged with a distinguishing ID number. The upcall part of "
"the op is filled out, and the op is passed to the \"service_operation\" "
"function."
msgstr ""

#: ../../../filesystems/orangefs.rst:345
msgid ""
"Service_operation changes the op's state to \"waiting\", puts it on the "
"request list, and signals the Orangefs file_operations.poll function through "
"a wait queue. Userspace is polling the pseudo-device and thus becomes aware "
"of the upcall request that needs to be read."
msgstr ""

#: ../../../filesystems/orangefs.rst:350
msgid ""
"When the Orangefs file_operations.read function is triggered, the request "
"list is searched for an op that seems ready-to-process. The op is removed "
"from the request list. The tag from the op and the filled-out upcall struct "
"are copy_to_user'ed back to userspace."
msgstr ""

#: ../../../filesystems/orangefs.rst:355
msgid ""
"If any of these (and some additional protocol) copy_to_users fail, the op's "
"state is set to \"waiting\" and the op is added back to the request list. "
"Otherwise, the op's state is changed to \"in progress\", and the op is "
"hashed on its tag and put onto the end of a list in the in_progress hash "
"table at the index the tag hashed to."
msgstr ""

#: ../../../filesystems/orangefs.rst:361
msgid ""
"When userspace has assembled the response to the upcall, it writes the "
"response, which includes the distinguishing tag, back to the pseudo device "
"in a series of io_vecs. This triggers the Orangefs file_operations."
"write_iter function to find the op with the associated tag and remove it "
"from the in_progress hash table. As long as the op's state is not "
"\"canceled\" or \"given up\", its state is set to \"serviced\". The "
"file_operations.write_iter function returns to the waiting vfs, and back to "
"service_operation through wait_for_matching_downcall."
msgstr ""

#: ../../../filesystems/orangefs.rst:370
msgid ""
"Service operation returns to its caller with the op's downcall part (the "
"response to the upcall) filled out."
msgstr ""

#: ../../../filesystems/orangefs.rst:373
msgid ""
"The \"client-core\" is the bridge between the kernel module and userspace. "
"The client-core is a daemon. The client-core has an associated watchdog "
"daemon. If the client-core is ever signaled to die, the watchdog daemon "
"restarts the client-core. Even though the client-core is restarted \"right "
"away\", there is a period of time during such an event that the client-core "
"is dead. A dead client-core can't be triggered by the Orangefs "
"file_operations.poll function. Ops that pass through service_operation "
"during a \"dead spell\" can timeout on the wait queue and one attempt is "
"made to recycle them. Obviously, if the client-core stays dead too long, the "
"arbitrary userspace processes trying to use Orangefs will be negatively "
"affected. Waiting ops that can't be serviced will be removed from the "
"request list and have their states set to \"given up\". In-progress ops that "
"can't be serviced will be removed from the in_progress hash table and have "
"their states set to \"given up\"."
msgstr ""

#: ../../../filesystems/orangefs.rst:389
msgid "Readdir and I/O ops are atypical with respect to their payloads."
msgstr ""

#: ../../../filesystems/orangefs.rst:391
msgid ""
"readdir ops use the smaller of the two pre-allocated pre-partitioned memory "
"buffers. The readdir buffer is only available to userspace. The kernel "
"module obtains an index to a free partition before launching a readdir op. "
"Userspace deposits the results into the indexed partition and then writes "
"them to back to the pvfs device."
msgstr ""

#: ../../../filesystems/orangefs.rst:397
msgid ""
"io (read and write) ops use the larger of the two pre-allocated pre-"
"partitioned memory buffers. The IO buffer is accessible from both userspace "
"and the kernel module. The kernel module obtains an index to a free "
"partition before launching an io op. The kernel module deposits write data "
"into the indexed partition, to be consumed directly by userspace. Userspace "
"deposits the results of read requests into the indexed partition, to be "
"consumed directly by the kernel module."
msgstr ""

#: ../../../filesystems/orangefs.rst:406
msgid ""
"Responses to kernel requests are all packaged in pvfs2_downcall_t structs. "
"Besides a few other members, pvfs2_downcall_t contains a union of structs, "
"each of which is associated with a particular response type."
msgstr ""

#: ../../../filesystems/orangefs.rst:411
msgid "The several members outside of the union are:"
msgstr ""

#: ../../../filesystems/orangefs.rst:413
msgid "``int32_t type``"
msgstr ""

#: ../../../filesystems/orangefs.rst:414
msgid "type of operation."
msgstr ""

#: ../../../filesystems/orangefs.rst:415
msgid "``int32_t status``"
msgstr ""

#: ../../../filesystems/orangefs.rst:416
msgid "return code for the operation."
msgstr ""

#: ../../../filesystems/orangefs.rst:417
msgid "``int64_t trailer_size``"
msgstr ""

#: ../../../filesystems/orangefs.rst:418
msgid "0 unless readdir operation."
msgstr ""

#: ../../../filesystems/orangefs.rst:419
msgid "``char *trailer_buf``"
msgstr ""

#: ../../../filesystems/orangefs.rst:420
msgid "initialized to NULL, used during readdir operations."
msgstr ""

#: ../../../filesystems/orangefs.rst:422
msgid ""
"The appropriate member inside the union is filled out for any particular "
"response."
msgstr ""

#: ../../../filesystems/orangefs.rst:425
msgid "PVFS2_VFS_OP_FILE_IO"
msgstr ""

#: ../../../filesystems/orangefs.rst:426
msgid "fill a pvfs2_io_response_t"
msgstr ""

#: ../../../filesystems/orangefs.rst:428
msgid "PVFS2_VFS_OP_LOOKUP"
msgstr ""

#: ../../../filesystems/orangefs.rst:429 ../../../filesystems/orangefs.rst:432
#: ../../../filesystems/orangefs.rst:435 ../../../filesystems/orangefs.rst:442
msgid "fill a PVFS_object_kref"
msgstr ""

#: ../../../filesystems/orangefs.rst:431
msgid "PVFS2_VFS_OP_CREATE"
msgstr ""

#: ../../../filesystems/orangefs.rst:434
msgid "PVFS2_VFS_OP_SYMLINK"
msgstr ""

#: ../../../filesystems/orangefs.rst:437
msgid "PVFS2_VFS_OP_GETATTR"
msgstr ""

#: ../../../filesystems/orangefs.rst:438
msgid ""
"fill in a PVFS_sys_attr_s (tons of stuff the kernel doesn't need) fill in a "
"string with the link target when the object is a symlink."
msgstr ""

#: ../../../filesystems/orangefs.rst:441
msgid "PVFS2_VFS_OP_MKDIR"
msgstr ""

#: ../../../filesystems/orangefs.rst:444
msgid "PVFS2_VFS_OP_STATFS"
msgstr ""

#: ../../../filesystems/orangefs.rst:445
msgid ""
"fill a pvfs2_statfs_response_t with useless info <g>. It is hard for us to "
"know, in a timely fashion, these statistics about our distributed network "
"filesystem."
msgstr ""

#: ../../../filesystems/orangefs.rst:449
msgid "PVFS2_VFS_OP_FS_MOUNT"
msgstr ""

#: ../../../filesystems/orangefs.rst:450
msgid ""
"fill a pvfs2_fs_mount_response_t which is just like a PVFS_object_kref "
"except its members are in a different order and \"__pad1\" is replaced with "
"\"id\"."
msgstr ""

#: ../../../filesystems/orangefs.rst:454
msgid "PVFS2_VFS_OP_GETXATTR"
msgstr ""

#: ../../../filesystems/orangefs.rst:455
msgid "fill a pvfs2_getxattr_response_t"
msgstr ""

#: ../../../filesystems/orangefs.rst:457
msgid "PVFS2_VFS_OP_LISTXATTR"
msgstr ""

#: ../../../filesystems/orangefs.rst:458
msgid "fill a pvfs2_listxattr_response_t"
msgstr ""

#: ../../../filesystems/orangefs.rst:460
msgid "PVFS2_VFS_OP_PARAM"
msgstr ""

#: ../../../filesystems/orangefs.rst:461
msgid "fill a pvfs2_param_response_t"
msgstr ""

#: ../../../filesystems/orangefs.rst:463
msgid "PVFS2_VFS_OP_PERF_COUNT"
msgstr ""

#: ../../../filesystems/orangefs.rst:464
msgid "fill a pvfs2_perf_count_response_t"
msgstr ""

#: ../../../filesystems/orangefs.rst:466
msgid "PVFS2_VFS_OP_FSKEY"
msgstr ""

#: ../../../filesystems/orangefs.rst:467
msgid "file a pvfs2_fs_key_response_t"
msgstr ""

#: ../../../filesystems/orangefs.rst:469
msgid "PVFS2_VFS_OP_READDIR"
msgstr ""

#: ../../../filesystems/orangefs.rst:470
msgid ""
"jamb everything needed to represent a pvfs2_readdir_response_t into the "
"readdir buffer descriptor specified in the upcall."
msgstr ""

#: ../../../filesystems/orangefs.rst:473
msgid ""
"Userspace uses writev() on /dev/pvfs2-req to pass responses to the requests "
"made by the kernel side."
msgstr ""

#: ../../../filesystems/orangefs.rst:476
msgid "A buffer_list containing:"
msgstr ""

#: ../../../filesystems/orangefs.rst:478
msgid ""
"a pointer to the prepared response to the request from the kernel (struct "
"pvfs2_downcall_t)."
msgstr ""

#: ../../../filesystems/orangefs.rst:480
msgid ""
"and also, in the case of a readdir request, a pointer to a buffer containing "
"descriptors for the objects in the target directory."
msgstr ""

#: ../../../filesystems/orangefs.rst:484
msgid ""
"... is sent to the function (PINT_dev_write_list) which performs the writev."
msgstr ""

#: ../../../filesystems/orangefs.rst:487
msgid "PINT_dev_write_list has a local iovec array: struct iovec io_array[10];"
msgstr ""

#: ../../../filesystems/orangefs.rst:489
msgid ""
"The first four elements of io_array are initialized like this for all "
"responses::"
msgstr ""

#: ../../../filesystems/orangefs.rst:505
msgid "Readdir responses initialize the fifth element io_array like this::"
msgstr ""

#: ../../../filesystems/orangefs.rst:514
msgid ""
"Orangefs exploits the dcache in order to avoid sending redundant requests to "
"userspace. We keep object inode attributes up-to-date with "
"orangefs_inode_getattr. Orangefs_inode_getattr uses two arguments to help it "
"decide whether or not to update an inode: \"new\" and \"bypass\". Orangefs "
"keeps private data in an object's inode that includes a short timeout value, "
"getattr_time, which allows any iteration of orangefs_inode_getattr to know "
"how long it has been since the inode was updated. When the object is not new "
"(new == 0) and the bypass flag is not set (bypass == 0) "
"orangefs_inode_getattr returns without updating the inode if getattr_time "
"has not timed out. Getattr_time is updated each time the inode is updated."
msgstr ""

#: ../../../filesystems/orangefs.rst:526
msgid ""
"Creation of a new object (file, dir, sym-link) includes the evaluation of "
"its pathname, resulting in a negative directory entry for the object. A new "
"inode is allocated and associated with the dentry, turning it from a "
"negative dentry into a \"productive full member of society\". Orangefs "
"obtains the new inode from Linux with new_inode() and associates the inode "
"with the dentry by sending the pair back to Linux with d_instantiate()."
msgstr ""

#: ../../../filesystems/orangefs.rst:534
msgid ""
"The evaluation of a pathname for an object resolves to its corresponding "
"dentry. If there is no corresponding dentry, one is created for it in the "
"dcache. Whenever a dentry is modified or verified Orangefs stores a short "
"timeout value in the dentry's d_time, and the dentry will be trusted for "
"that amount of time. Orangefs is a network filesystem, and objects can "
"potentially change out-of-band with any particular Orangefs kernel module "
"instance, so trusting a dentry is risky. The alternative to trusting "
"dentries is to always obtain the needed information from userspace - at "
"least a trip to the client-core, maybe to the servers. Obtaining information "
"from a dentry is cheap, obtaining it from userspace is relatively expensive, "
"hence the motivation to use the dentry when possible."
msgstr ""

#: ../../../filesystems/orangefs.rst:546
msgid ""
"The timeout values d_time and getattr_time are jiffy based, and the code is "
"designed to avoid the jiffy-wrap problem::"
msgstr ""

#: ../../../filesystems/orangefs.rst:555
msgid "from course notes by instructor Andy Wang"
msgstr ""
