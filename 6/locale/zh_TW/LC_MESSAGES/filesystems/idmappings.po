# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/idmappings.rst:4
msgid "Idmappings"
msgstr ""

#: ../../../filesystems/idmappings.rst:6
msgid ""
"Most filesystem developers will have encountered idmappings. They are used "
"when reading from or writing ownership to disk, reporting ownership to "
"userspace, or for permission checking. This document is aimed at filesystem "
"developers that want to know how idmappings work."
msgstr ""

#: ../../../filesystems/idmappings.rst:12
msgid "Formal notes"
msgstr ""

#: ../../../filesystems/idmappings.rst:14
msgid ""
"An idmapping is essentially a translation of a range of ids into another or "
"the same range of ids. The notational convention for idmappings that is "
"widely used in userspace is::"
msgstr ""

#: ../../../filesystems/idmappings.rst:20
msgid ""
"``u`` indicates the first element in the upper idmapset ``U`` and ``k`` "
"indicates the first element in the lower idmapset ``K``. The ``r`` parameter "
"indicates the range of the idmapping, i.e. how many ids are mapped. From now "
"on, we will always prefix ids with ``u`` or ``k`` to make it clear whether "
"we're talking about an id in the upper or lower idmapset."
msgstr ""

#: ../../../filesystems/idmappings.rst:26
msgid ""
"To see what this looks like in practice, let's take the following idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:30
msgid "and write down the mappings it will generate::"
msgstr ""

#: ../../../filesystems/idmappings.rst:36
msgid ""
"From a mathematical viewpoint ``U`` and ``K`` are well-ordered sets and an "
"idmapping is an order isomorphism from ``U`` into ``K``. So ``U`` and ``K`` "
"are order isomorphic. In fact, ``U`` and ``K`` are always well-ordered "
"subsets of the set of all possible ids usable on a given system."
msgstr ""

#: ../../../filesystems/idmappings.rst:41
msgid ""
"Looking at this mathematically briefly will help us highlight some "
"properties that make it easier to understand how we can translate between "
"idmappings. For example, we know that the inverse idmapping is an order "
"isomorphism as well::"
msgstr ""

#: ../../../filesystems/idmappings.rst:49
msgid ""
"Given that we are dealing with order isomorphisms plus the fact that we're "
"dealing with subsets we can embed idmappings into each other, i.e. we can "
"sensibly translate between different idmappings. For example, assume we've "
"been given the three idmappings::"
msgstr ""

#: ../../../filesystems/idmappings.rst:58
msgid ""
"and id ``k11000`` which has been generated by the first idmapping by mapping "
"``u1000`` from the upper idmapset down to ``k11000`` in the lower idmapset."
msgstr ""

#: ../../../filesystems/idmappings.rst:61
msgid ""
"Because we're dealing with order isomorphic subsets it is meaningful to ask "
"what id ``k11000`` corresponds to in the second or third idmapping. The "
"straightforward algorithm to use is to apply the inverse of the first "
"idmapping, mapping ``k11000`` up to ``u1000``. Afterwards, we can map "
"``u1000`` down using either the second idmapping mapping or third idmapping "
"mapping. The second idmapping would map ``u1000`` down to ``k21000``. The "
"third idmapping would map ``u1000`` down to ``k31000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:69
msgid "If we were given the same task for the following three idmappings::"
msgstr ""

#: ../../../filesystems/idmappings.rst:75
msgid ""
"we would fail to translate as the sets aren't order isomorphic over the full "
"range of the first idmapping anymore (However they are order isomorphic over "
"the full range of the second idmapping.). Neither the second or third "
"idmapping contain ``u1000`` in the upper idmapset ``U``. This is equivalent "
"to not having an id mapped. We can simply say that ``u1000`` is unmapped in "
"the second and third idmapping. The kernel will report unmapped ids as the "
"overflowuid ``(uid_t)-1`` or overflowgid ``(gid_t)-1`` to userspace."
msgstr ""

#: ../../../filesystems/idmappings.rst:83
msgid ""
"The algorithm to calculate what a given id maps to is pretty simple. First, "
"we need to verify that the range can contain our target id. We will skip "
"this step for simplicity. After that if we want to know what ``id`` maps to "
"we can do simple calculations:"
msgstr ""

#: ../../../filesystems/idmappings.rst:88
msgid "If we want to map from left to right::"
msgstr ""

#: ../../../filesystems/idmappings.rst:93
msgid "If we want to map from right to left::"
msgstr ""

#: ../../../filesystems/idmappings.rst:98
msgid ""
"Instead of \"left to right\" we can also say \"down\" and instead of \"right "
"to left\" we can also say \"up\". Obviously mapping down and up invert each "
"other."
msgstr ""

#: ../../../filesystems/idmappings.rst:101
msgid ""
"To see whether the simple formulas above work, consider the following two "
"idmappings::"
msgstr ""

#: ../../../filesystems/idmappings.rst:107
msgid ""
"Assume we are given ``k21000`` in the lower idmapset of the first idmapping. "
"We want to know what id this was mapped from in the upper idmapset of the "
"first idmapping. So we're mapping up in the first idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:114
msgid ""
"Now assume we are given the id ``u1100`` in the upper idmapset of the second "
"idmapping and we want to know what this id maps down to in the lower "
"idmapset of the second idmapping. This means we're mapping down in the "
"second idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:123
msgid "General notes"
msgstr ""

#: ../../../filesystems/idmappings.rst:125
msgid ""
"In the context of the kernel an idmapping can be interpreted as mapping a "
"range of userspace ids into a range of kernel ids::"
msgstr ""

#: ../../../filesystems/idmappings.rst:130
msgid ""
"A userspace id is always an element in the upper idmapset of an idmapping of "
"type ``uid_t`` or ``gid_t`` and a kernel id is always an element in the "
"lower idmapset of an idmapping of type ``kuid_t`` or ``kgid_t``. From now on "
"\"userspace id\" will be used to refer to the well known ``uid_t`` and "
"``gid_t`` types and \"kernel id\" will be used to refer to ``kuid_t`` and "
"``kgid_t``."
msgstr ""

#: ../../../filesystems/idmappings.rst:136
msgid ""
"The kernel is mostly concerned with kernel ids. They are used when "
"performing permission checks and are stored in an inode's ``i_uid`` and "
"``i_gid`` field. A userspace id on the other hand is an id that is reported "
"to userspace by the kernel, or is passed by userspace to the kernel, or a "
"raw device id that is written or read from disk."
msgstr ""

#: ../../../filesystems/idmappings.rst:142
msgid ""
"Note that we are only concerned with idmappings as the kernel stores them "
"not how userspace would specify them."
msgstr ""

#: ../../../filesystems/idmappings.rst:145
msgid ""
"For the rest of this document we will prefix all userspace ids with ``u`` "
"and all kernel ids with ``k``. Ranges of idmappings will be prefixed with "
"``r``. So an idmapping will be written as ``u0:k10000:r10000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:149
msgid ""
"For example, within this idmapping, the id ``u1000`` is an id in the upper "
"idmapset or \"userspace idmapset\" starting with ``u0``. And it is mapped to "
"``k11000`` which is a kernel id in the lower idmapset or \"kernel idmapset\" "
"starting with ``k10000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:154
msgid ""
"A kernel id is always created by an idmapping. Such idmappings are "
"associated with user namespaces. Since we mainly care about how idmappings "
"work we're not going to be concerned with how idmappings are created nor how "
"they are used outside of the filesystem context. This is best left to an "
"explanation of user namespaces."
msgstr ""

#: ../../../filesystems/idmappings.rst:160
msgid ""
"The initial user namespace is special. It always has an idmapping of the "
"following form::"
msgstr ""

#: ../../../filesystems/idmappings.rst:165
msgid ""
"which is an identity idmapping over the full range of ids available on this "
"system."
msgstr ""

#: ../../../filesystems/idmappings.rst:168
msgid "Other user namespaces usually have non-identity idmappings such as::"
msgstr ""

#: ../../../filesystems/idmappings.rst:172
msgid ""
"When a process creates or wants to change ownership of a file, or when the "
"ownership of a file is read from disk by a filesystem, the userspace id is "
"immediately translated into a kernel id according to the idmapping "
"associated with the relevant user namespace."
msgstr ""

#: ../../../filesystems/idmappings.rst:177
msgid ""
"For instance, consider a file that is stored on disk by a filesystem as "
"being owned by ``u1000``:"
msgstr ""

#: ../../../filesystems/idmappings.rst:180
msgid ""
"If a filesystem were to be mounted in the initial user namespaces (as most "
"filesystems are) then the initial idmapping will be used. As we saw this is "
"simply the identity idmapping. This would mean id ``u1000`` read from disk "
"would be mapped to id ``k1000``. So an inode's ``i_uid`` and ``i_gid`` field "
"would contain ``k1000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:186
msgid ""
"If a filesystem were to be mounted with an idmapping of ``u0:k10000:r10000`` "
"then ``u1000`` read from disk would be mapped to ``k11000``. So an inode's "
"``i_uid`` and ``i_gid`` would contain ``k11000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:191
msgid "Translation algorithms"
msgstr ""

#: ../../../filesystems/idmappings.rst:193
msgid ""
"We've already seen briefly that it is possible to translate between "
"different idmappings. We'll now take a closer look how that works."
msgstr ""

#: ../../../filesystems/idmappings.rst:197
msgid "Crossmapping"
msgstr ""

#: ../../../filesystems/idmappings.rst:199
msgid ""
"This translation algorithm is used by the kernel in quite a few places. For "
"example, it is used when reporting back the ownership of a file to userspace "
"via the ``stat()`` system call family."
msgstr ""

#: ../../../filesystems/idmappings.rst:203
msgid ""
"If we've been given ``k11000`` from one idmapping we can map that id up in "
"another idmapping. In order for this to work both idmappings need to contain "
"the same kernel id in their kernel idmapsets. For example, consider the "
"following idmappings::"
msgstr ""

#: ../../../filesystems/idmappings.rst:211
msgid ""
"and we are mapping ``u1000`` down to ``k11000`` in the first idmapping . We "
"can then translate ``k11000`` into a userspace id in the second idmapping "
"using the kernel idmapset of the second idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:218
msgid ""
"Note, how we can get back to the kernel id in the first idmapping by "
"inverting the algorithm::"
msgstr ""

#: ../../../filesystems/idmappings.rst:227
msgid ""
"This algorithm allows us to answer the question what userspace id a given "
"kernel id corresponds to in a given idmapping. In order to be able to answer "
"this question both idmappings need to contain the same kernel id in their "
"respective kernel idmapsets."
msgstr ""

#: ../../../filesystems/idmappings.rst:232
msgid ""
"For example, when the kernel reads a raw userspace id from disk it maps it "
"down into a kernel id according to the idmapping associated with the "
"filesystem. Let's assume the filesystem was mounted with an idmapping of "
"``u0:k20000:r10000`` and it reads a file owned by ``u1000`` from disk. This "
"means ``u1000`` will be mapped to ``k21000`` which is what will be stored in "
"the inode's ``i_uid`` and ``i_gid`` field."
msgstr ""

#: ../../../filesystems/idmappings.rst:239
msgid ""
"When someone in userspace calls ``stat()`` or a related function to get "
"ownership information about the file the kernel can't simply map the id back "
"up according to the filesystem's idmapping as this would give the wrong "
"owner if the caller is using an idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:244
msgid ""
"So the kernel will map the id back up in the idmapping of the caller. Let's "
"assume the caller has the somewhat unconventional idmapping ``u3000:k20000:"
"r10000`` then ``k21000`` would map back up to ``u4000``. Consequently the "
"user would see that this file is owned by ``u4000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:250
msgid "Remapping"
msgstr ""

#: ../../../filesystems/idmappings.rst:252
msgid ""
"It is possible to translate a kernel id from one idmapping to another one "
"via the userspace idmapset of the two idmappings. This is equivalent to "
"remapping a kernel id."
msgstr ""

#: ../../../filesystems/idmappings.rst:256
msgid "Let's look at an example. We are given the following two idmappings::"
msgstr ""

#: ../../../filesystems/idmappings.rst:261
msgid ""
"and we are given ``k11000`` in the first idmapping. In order to translate "
"this kernel id in the first idmapping into a kernel id in the second "
"idmapping we need to perform two steps:"
msgstr ""

#: ../../../filesystems/idmappings.rst:265
msgid "Map the kernel id up into a userspace id in the first idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:270
msgid "Map the userspace id down into a kernel id in the second idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:275
msgid ""
"As you can see we used the userspace idmapset in both idmappings to "
"translate the kernel id in one idmapping to a kernel id in another idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:278
msgid ""
"This allows us to answer the question what kernel id we would need to use to "
"get the same userspace id in another idmapping. In order to be able to "
"answer this question both idmappings need to contain the same userspace id "
"in their respective userspace idmapsets."
msgstr ""

#: ../../../filesystems/idmappings.rst:283
msgid ""
"Note, how we can easily get back to the kernel id in the first idmapping by "
"inverting the algorithm:"
msgstr ""

#: ../../../filesystems/idmappings.rst:286
msgid "Map the kernel id up into a userspace id in the second idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:291
msgid "Map the userspace id down into a kernel id in the first idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:296
msgid ""
"Another way to look at this translation is to treat it as inverting one "
"idmapping and applying another idmapping if both idmappings have the "
"relevant userspace id mapped. This will come in handy when working with "
"idmapped mounts."
msgstr ""

#: ../../../filesystems/idmappings.rst:301
msgid "Invalid translations"
msgstr ""

#: ../../../filesystems/idmappings.rst:303
msgid ""
"It is never valid to use an id in the kernel idmapset of one idmapping as "
"the id in the userspace idmapset of another or the same idmapping. While the "
"kernel idmapset always indicates an idmapset in the kernel id space the "
"userspace idmapset indicates a userspace id. So the following translations "
"are forbidden::"
msgstr ""

#: ../../../filesystems/idmappings.rst:315
msgid "and equally wrong::"
msgstr ""

#: ../../../filesystems/idmappings.rst:324
msgid ""
"Since userspace ids have type ``uid_t`` and ``gid_t`` and kernel ids have "
"type ``kuid_t`` and ``kgid_t`` the compiler will throw an error when they "
"are conflated. So the two examples above would cause a compilation failure."
msgstr ""

#: ../../../filesystems/idmappings.rst:329
msgid "Idmappings when creating filesystem objects"
msgstr ""

#: ../../../filesystems/idmappings.rst:331
msgid ""
"The concepts of mapping an id down or mapping an id up are expressed in the "
"two kernel functions filesystem developers are rather familiar with and "
"which we've already used in this document::"
msgstr ""

#: ../../../filesystems/idmappings.rst:341
msgid ""
"We will take an abbreviated look into how idmappings figure into creating "
"filesystem objects. For simplicity we will only look at what happens when "
"the VFS has already completed path lookup right before it calls into the "
"filesystem itself. So we're concerned with what happens when e.g. "
"``vfs_mkdir()`` is called. We will also assume that the directory we're "
"creating filesystem objects in is readable and writable for everyone."
msgstr ""

#: ../../../filesystems/idmappings.rst:348
msgid ""
"When creating a filesystem object the caller will look at the caller's "
"filesystem ids. These are just regular ``uid_t`` and ``gid_t`` userspace ids "
"but they are exclusively used when determining file ownership which is why "
"they are called \"filesystem ids\". They are usually identical to the uid "
"and gid of the caller but can differ. We will just assume they are always "
"identical to not get lost in too many details."
msgstr ""

#: ../../../filesystems/idmappings.rst:355
msgid "When the caller enters the kernel two things happen:"
msgstr ""

#: ../../../filesystems/idmappings.rst:357
msgid ""
"Map the caller's userspace ids down into kernel ids in the caller's "
"idmapping. (To be precise, the kernel will simply look at the kernel ids "
"stashed in the credentials of the current task but for our education we'll "
"pretend this translation happens just in time.)"
msgstr ""

#: ../../../filesystems/idmappings.rst:362
msgid ""
"Verify that the caller's kernel ids can be mapped up to userspace ids in the "
"filesystem's idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:365
msgid ""
"The second step is important as regular filesystem will ultimately need to "
"map the kernel id back up into a userspace id when writing to disk. So with "
"the second step the kernel guarantees that a valid userspace id can be "
"written to disk. If it can't the kernel will refuse the creation request to "
"not even remotely risk filesystem corruption."
msgstr ""

#: ../../../filesystems/idmappings.rst:371
msgid ""
"The astute reader will have realized that this is simply a variation of the "
"crossmapping algorithm we mentioned above in a previous section. First, the "
"kernel maps the caller's userspace id down into a kernel id according to the "
"caller's idmapping and then maps that kernel id up according to the "
"filesystem's idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:377
msgid ""
"From the implementation point it's worth mentioning how idmappings are "
"represented. All idmappings are taken from the corresponding user namespace."
msgstr ""

#: ../../../filesystems/idmappings.rst:380
msgid "caller's idmapping (usually taken from ``current_user_ns()``)"
msgstr ""

#: ../../../filesystems/idmappings.rst:381
msgid "filesystem's idmapping (``sb->s_user_ns``)"
msgstr ""

#: ../../../filesystems/idmappings.rst:382
msgid "mount's idmapping (``mnt_idmap(vfsmnt)``)"
msgstr ""

#: ../../../filesystems/idmappings.rst:384
msgid ""
"Let's see some examples with caller/filesystem idmapping but without mount "
"idmappings. This will exhibit some problems we can hit. After that we will "
"revisit/reconsider these examples, this time using mount idmappings, to see "
"how they can solve the problems we observed before."
msgstr ""

#: ../../../filesystems/idmappings.rst:390
msgid "Example 1"
msgstr ""

#: ../../../filesystems/idmappings.rst:398
msgid "Both the caller and the filesystem use the identity idmapping:"
msgstr ""

#: ../../../filesystems/idmappings.rst:400
#: ../../../filesystems/idmappings.rst:810
#: ../../../filesystems/idmappings.rst:843
#: ../../../filesystems/idmappings.rst:983
msgid ""
"Map the caller's userspace ids into kernel ids in the caller's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:404
msgid ""
"Verify that the caller's kernel ids can be mapped to userspace ids in the "
"filesystem's idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:407
msgid ""
"For this second step the kernel will call the function "
"``fsuidgid_has_mapping()`` which ultimately boils down to calling "
"``from_kuid()``::"
msgstr ""

#: ../../../filesystems/idmappings.rst:413
msgid ""
"In this example both idmappings are the same so there's nothing exciting "
"going on. Ultimately the userspace id that lands on disk will be ``u1000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:417
msgid "Example 2"
msgstr ""

#: ../../../filesystems/idmappings.rst:425
#: ../../../filesystems/idmappings.rst:453
msgid ""
"Map the caller's userspace ids down into kernel ids in the caller's "
"idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:430
#: ../../../filesystems/idmappings.rst:458
msgid ""
"Verify that the caller's kernel ids can be mapped up to userspace ids in the "
"filesystem's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:435
msgid ""
"It's immediately clear that while the caller's userspace id could be "
"successfully mapped down into kernel ids in the caller's idmapping the "
"kernel ids could not be mapped up according to the filesystem's idmapping. "
"So the kernel will deny this creation request."
msgstr ""

#: ../../../filesystems/idmappings.rst:440
msgid ""
"Note that while this example is less common, because most filesystem can't "
"be mounted with non-initial idmappings this is a general problem as we can "
"see in the next examples."
msgstr ""

#: ../../../filesystems/idmappings.rst:445
msgid "Example 3"
msgstr ""

#: ../../../filesystems/idmappings.rst:463
msgid ""
"We can see that the translation always succeeds. The userspace id that the "
"filesystem will ultimately put to disk will always be identical to the value "
"of the kernel id that was created in the caller's idmapping. This has mainly "
"two consequences."
msgstr ""

#: ../../../filesystems/idmappings.rst:468
msgid ""
"First, that we can't allow a caller to ultimately write to disk with another "
"userspace id. We could only do this if we were to mount the whole filesystem "
"with the caller's or another idmapping. But that solution is limited to a "
"few filesystems and not very flexible. But this is a use-case that is pretty "
"important in containerized workloads."
msgstr ""

#: ../../../filesystems/idmappings.rst:474
msgid ""
"Second, the caller will usually not be able to create any files or access "
"directories that have stricter permissions because none of the filesystem's "
"kernel ids map up into valid userspace ids in the caller's idmapping"
msgstr ""

#: ../../../filesystems/idmappings.rst:478
msgid ""
"Map raw userspace ids down to kernel ids in the filesystem's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:482
msgid "Map kernel ids up to userspace ids in the caller's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:487
msgid "Example 4"
msgstr ""

#: ../../../filesystems/idmappings.rst:495
#: ../../../filesystems/idmappings.rst:521
msgid ""
"In order to report ownership to userspace the kernel uses the crossmapping "
"algorithm introduced in a previous section:"
msgstr ""

#: ../../../filesystems/idmappings.rst:498
#: ../../../filesystems/idmappings.rst:524
#: ../../../filesystems/idmappings.rst:543
#: ../../../filesystems/idmappings.rst:877
#: ../../../filesystems/idmappings.rst:914
#: ../../../filesystems/idmappings.rst:1014
msgid ""
"Map the userspace id on disk down into a kernel id in the filesystem's "
"idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:503
#: ../../../filesystems/idmappings.rst:529
#: ../../../filesystems/idmappings.rst:548
msgid "Map the kernel id up into a userspace id in the caller's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:507
msgid ""
"The crossmapping algorithm fails in this case because the kernel id in the "
"filesystem idmapping cannot be mapped up to a userspace id in the caller's "
"idmapping. Thus, the kernel will report the ownership of this file as the "
"overflowid."
msgstr ""

#: ../../../filesystems/idmappings.rst:513
msgid "Example 5"
msgstr ""

#: ../../../filesystems/idmappings.rst:533
msgid ""
"Again, the crossmapping algorithm fails in this case because the kernel id "
"in the filesystem idmapping cannot be mapped to a userspace id in the "
"caller's idmapping. Thus, the kernel will report the ownership of this file "
"as the overflowid."
msgstr ""

#: ../../../filesystems/idmappings.rst:538
msgid ""
"Note how in the last two examples things would be simple if the caller would "
"be using the initial idmapping. For a filesystem mounted with the initial "
"idmapping it would be trivial. So we only consider a filesystem with an "
"idmapping of ``u0:k20000:r10000``:"
msgstr ""

#: ../../../filesystems/idmappings.rst:553
msgid "Idmappings on idmapped mounts"
msgstr ""

#: ../../../filesystems/idmappings.rst:555
msgid ""
"The examples we've seen in the previous section where the caller's idmapping "
"and the filesystem's idmapping are incompatible causes various issues for "
"workloads. For a more complex but common example, consider two containers "
"started on the host. To completely prevent the two containers from affecting "
"each other, an administrator may often use different non-overlapping "
"idmappings for the two containers::"
msgstr ""

#: ../../../filesystems/idmappings.rst:566
msgid ""
"An administrator wanting to provide easy read-write access to the following "
"set of files::"
msgstr ""

#: ../../../filesystems/idmappings.rst:573
msgid "to both containers currently can't."
msgstr ""

#: ../../../filesystems/idmappings.rst:575
msgid ""
"Of course the administrator has the option to recursively change ownership "
"via ``chown()``. For example, they could change ownership so that ``dir`` "
"and all files below it can be crossmapped from the filesystem's into the "
"container's idmapping. Let's assume they change ownership so it is "
"compatible with the first container's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:585
msgid ""
"This would still leave ``dir`` rather useless to the second container. In "
"fact, ``dir`` and all files below it would continue to appear owned by the "
"overflowid for the second container."
msgstr ""

#: ../../../filesystems/idmappings.rst:589
msgid ""
"Or consider another increasingly popular example. Some service managers such "
"as systemd implement a concept called \"portable home directories\". A user "
"may want to use their home directories on different machines where they are "
"assigned different login userspace ids. Most users will have ``u1000`` as "
"the login id on their machine at home and all files in their home directory "
"will usually be owned by ``u1000``. At uni or at work they may have another "
"login id such as ``u1125``. This makes it rather difficult to interact with "
"their home directory on their work machine."
msgstr ""

#: ../../../filesystems/idmappings.rst:598
msgid ""
"In both cases changing ownership recursively has grave implications. The "
"most obvious one is that ownership is changed globally and permanently. In "
"the home directory case this change in ownership would even need to happen "
"every time the user switches from their home to their work machine. For "
"really large sets of files this becomes increasingly costly."
msgstr ""

#: ../../../filesystems/idmappings.rst:604
msgid ""
"If the user is lucky, they are dealing with a filesystem that is mountable "
"inside user namespaces. But this would also change ownership globally and "
"the change in ownership is tied to the lifetime of the filesystem mount, i."
"e. the superblock. The only way to change ownership is to completely unmount "
"the filesystem and mount it again in another user namespace. This is usually "
"impossible because it would mean that all users currently accessing the "
"filesystem can't anymore. And it means that ``dir`` still can't be shared "
"between two containers with different idmappings. But usually the user "
"doesn't even have this option since most filesystems aren't mountable inside "
"containers. And not having them mountable might be desirable as it doesn't "
"require the filesystem to deal with malicious filesystem images."
msgstr ""

#: ../../../filesystems/idmappings.rst:617
msgid ""
"But the usecases mentioned above and more can be handled by idmapped mounts. "
"They allow to expose the same set of dentries with different ownership at "
"different mounts. This is achieved by marking the mounts with a user "
"namespace through the ``mount_setattr()`` system call. The idmapping "
"associated with it is then used to translate from the caller's idmapping to "
"the filesystem's idmapping and vica versa using the remapping algorithm we "
"introduced above."
msgstr ""

#: ../../../filesystems/idmappings.rst:624
msgid ""
"Idmapped mounts make it possible to change ownership in a temporary and "
"localized way. The ownership changes are restricted to a specific mount and "
"the ownership changes are tied to the lifetime of the mount. All other users "
"and locations where the filesystem is exposed are unaffected."
msgstr ""

#: ../../../filesystems/idmappings.rst:629
msgid ""
"Filesystems that support idmapped mounts don't have any real reason to "
"support being mountable inside user namespaces. A filesystem could be "
"exposed completely under an idmapped mount to get the same effect. This has "
"the advantage that filesystems can leave the creation of the superblock to "
"privileged users in the initial user namespace."
msgstr ""

#: ../../../filesystems/idmappings.rst:635
msgid ""
"However, it is perfectly possible to combine idmapped mounts with "
"filesystems mountable inside user namespaces. We will touch on this further "
"below."
msgstr ""

#: ../../../filesystems/idmappings.rst:639
msgid "Filesystem types vs idmapped mount types"
msgstr ""

#: ../../../filesystems/idmappings.rst:641
msgid ""
"With the introduction of idmapped mounts we need to distinguish between "
"filesystem ownership and mount ownership of a VFS object such as an inode. "
"The owner of a inode might be different when looked at from a filesystem "
"perspective than when looked at from an idmapped mount. Such fundamental "
"conceptual distinctions should almost always be clearly expressed in the "
"code. So, to distinguish idmapped mount ownership from filesystem ownership "
"separate types have been introduced."
msgstr ""

#: ../../../filesystems/idmappings.rst:649
msgid ""
"If a uid or gid has been generated using the filesystem or caller's "
"idmapping then we will use the ``kuid_t`` and ``kgid_t`` types. However, if "
"a uid or gid has been generated using a mount idmapping then we will be "
"using the dedicated ``vfsuid_t`` and ``vfsgid_t`` types."
msgstr ""

#: ../../../filesystems/idmappings.rst:654
msgid ""
"All VFS helpers that generate or take uids and gids as arguments use the "
"``vfsuid_t`` and ``vfsgid_t`` types and we will be able to rely on the "
"compiler to catch errors that originate from conflating filesystem and VFS "
"uids and gids."
msgstr ""

#: ../../../filesystems/idmappings.rst:658
msgid ""
"The ``vfsuid_t`` and ``vfsgid_t`` types are often mapped from and to "
"``kuid_t`` and ``kgid_t`` types similar how ``kuid_t`` and ``kgid_t`` types "
"are mapped from and to ``uid_t`` and ``gid_t`` types::"
msgstr ""

#: ../../../filesystems/idmappings.rst:665
msgid ""
"Whenever we report ownership based on a ``vfsuid_t`` or ``vfsgid_t`` type, e."
"g., during ``stat()``, or store ownership information in a shared VFS object "
"based on a ``vfsuid_t`` or ``vfsgid_t`` type, e.g., during ``chown()`` we "
"can use the ``vfsuid_into_kuid()`` and ``vfsgid_into_kgid()`` helpers."
msgstr ""

#: ../../../filesystems/idmappings.rst:670
msgid ""
"To illustrate why this helper currently exists, consider what happens when "
"we change ownership of an inode from an idmapped mount. After we generated a "
"``vfsuid_t`` or ``vfsgid_t`` based on the mount idmapping we later commit to "
"this ``vfsuid_t`` or ``vfsgid_t`` to become the new filesystem wide "
"ownership. Thus, we are turning the ``vfsuid_t`` or ``vfsgid_t`` into a "
"global ``kuid_t`` or ``kgid_t``. And this can be done by using "
"``vfsuid_into_kuid()`` and ``vfsgid_into_kgid()``."
msgstr ""

#: ../../../filesystems/idmappings.rst:678
msgid ""
"Note, whenever a shared VFS object, e.g., a cached ``struct inode`` or a "
"cached ``struct posix_acl``, stores ownership information a filesystem or "
"\"global\" ``kuid_t`` and ``kgid_t`` must be used. Ownership expressed via "
"``vfsuid_t`` and ``vfsgid_t`` is specific to an idmapped mount."
msgstr ""

#: ../../../filesystems/idmappings.rst:683
msgid ""
"We already noted that ``vfsuid_t`` and ``vfsgid_t`` types are generated "
"based on mount idmappings whereas ``kuid_t`` and ``kgid_t`` types are "
"generated based on filesystem idmappings. To prevent abusing filesystem "
"idmappings to generate ``vfsuid_t`` or ``vfsgid_t`` types or mount "
"idmappings to generate ``kuid_t`` or ``kgid_t`` types filesystem idmappings "
"and mount idmappings are different types as well."
msgstr ""

#: ../../../filesystems/idmappings.rst:690
msgid ""
"All helpers that map to or from ``vfsuid_t`` and ``vfsgid_t`` types require "
"a mount idmapping to be passed which is of type ``struct mnt_idmap``. "
"Passing a filesystem or caller idmapping will cause a compilation error."
msgstr ""

#: ../../../filesystems/idmappings.rst:694
msgid ""
"Similar to how we prefix all userspace ids in this document with ``u`` and "
"all kernel ids with ``k`` we will prefix all VFS ids with ``v``. So a mount "
"idmapping will be written as: ``u0:v10000:r10000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:699
msgid "Remapping helpers"
msgstr ""

#: ../../../filesystems/idmappings.rst:701
msgid ""
"Idmapping functions were added that translate between idmappings. They make "
"use of the remapping algorithm we've introduced earlier. We're going to look "
"at:"
msgstr ""

#: ../../../filesystems/idmappings.rst:704
msgid "``i_uid_into_vfsuid()`` and ``i_gid_into_vfsgid()``"
msgstr ""

#: ../../../filesystems/idmappings.rst:706
msgid ""
"The ``i_*id_into_vfs*id()`` functions translate filesystem's kernel ids into "
"VFS ids in the mount's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:715
msgid "``mapped_fsuid()`` and ``mapped_fsgid()``"
msgstr ""

#: ../../../filesystems/idmappings.rst:717
msgid ""
"The ``mapped_fs*id()`` functions translate the caller's kernel ids into "
"kernel ids in the filesystem's idmapping. This translation is achieved by "
"remapping the caller's VFS ids using the mount's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:727
msgid "``vfsuid_into_kuid()`` and ``vfsgid_into_kgid()``"
msgstr ""

#: ../../../filesystems/idmappings.rst:729
msgid "Whenever"
msgstr ""

#: ../../../filesystems/idmappings.rst:731
msgid ""
"Note that these two functions invert each other. Consider the following "
"idmappings::"
msgstr ""

#: ../../../filesystems/idmappings.rst:738
msgid ""
"Assume a file owned by ``u1000`` is read from disk. The filesystem maps this "
"id to ``k21000`` according to its idmapping. This is what is stored in the "
"inode's ``i_uid`` and ``i_gid`` fields."
msgstr ""

#: ../../../filesystems/idmappings.rst:742
msgid ""
"When the caller queries the ownership of this file via ``stat()`` the kernel "
"would usually simply use the crossmapping algorithm and map the filesystem's "
"kernel id up to a userspace id in the caller's idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:746
msgid ""
"But when the caller is accessing the file on an idmapped mount the kernel "
"will first call ``i_uid_into_vfsuid()`` thereby translating the filesystem's "
"kernel id into a VFS id in the mount's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:757
msgid ""
"Finally, when the kernel reports the owner to the caller it will turn the "
"VFS id in the mount's idmapping into a userspace id in the caller's "
"idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:764
msgid ""
"We can test whether this algorithm really works by verifying what happens "
"when we create a new file. Let's say the user is creating a file with "
"``u1000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:767
msgid ""
"The kernel maps this to ``k11000`` in the caller's idmapping. Usually the "
"kernel would now apply the crossmapping, verifying that ``k11000`` can be "
"mapped to a userspace id in the filesystem's idmapping. Since ``k11000`` "
"can't be mapped up in the filesystem's idmapping directly this creation "
"request fails."
msgstr ""

#: ../../../filesystems/idmappings.rst:773
msgid ""
"But when the caller is accessing the file on an idmapped mount the kernel "
"will first call ``mapped_fs*id()`` thereby translating the caller's kernel "
"id into a VFS id according to the mount's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:784
msgid ""
"When finally writing to disk the kernel will then map ``v21000`` up into a "
"userspace id in the filesystem's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:790
msgid ""
"As we can see, we end up with an invertible and therefore information "
"preserving algorithm. A file created from ``u1000`` on an idmapped mount "
"will also be reported as being owned by ``u1000`` and vica versa."
msgstr ""

#: ../../../filesystems/idmappings.rst:794
msgid ""
"Let's now briefly reconsider the failing examples from earlier in the "
"context of idmapped mounts."
msgstr ""

#: ../../../filesystems/idmappings.rst:798
msgid "Example 2 reconsidered"
msgstr ""

#: ../../../filesystems/idmappings.rst:807
msgid ""
"When the caller is using a non-initial idmapping the common case is to "
"attach the same idmapping to the mount. We now perform three steps:"
msgstr ""

#: ../../../filesystems/idmappings.rst:814
#: ../../../filesystems/idmappings.rst:847
#: ../../../filesystems/idmappings.rst:987
msgid ""
"Translate the caller's VFS id into a kernel id in the filesystem's "
"idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:824
#: ../../../filesystems/idmappings.rst:857
msgid ""
"Verify that the caller's kernel ids can be mapped to userspace ids in the "
"filesystem's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:829
#: ../../../filesystems/idmappings.rst:862
msgid "So the ownership that lands on disk will be ``u1000``."
msgstr ""

#: ../../../filesystems/idmappings.rst:832
msgid "Example 3 reconsidered"
msgstr ""

#: ../../../filesystems/idmappings.rst:841
msgid "The same translation algorithm works with the third example."
msgstr ""

#: ../../../filesystems/idmappings.rst:865
msgid "Example 4 reconsidered"
msgstr ""

#: ../../../filesystems/idmappings.rst:874
msgid ""
"In order to report ownership to userspace the kernel now does three steps "
"using the translation algorithm we introduced earlier:"
msgstr ""

#: ../../../filesystems/idmappings.rst:882
#: ../../../filesystems/idmappings.rst:919
#: ../../../filesystems/idmappings.rst:1019
msgid "Translate the kernel id into a VFS id in the mount's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:891
#: ../../../filesystems/idmappings.rst:928
#: ../../../filesystems/idmappings.rst:1028
msgid "Map the VFS id up into a userspace id in the caller's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:896
msgid ""
"Earlier, the caller's kernel id couldn't be crossmapped in the filesystems's "
"idmapping. With the idmapped mount in place it now can be crossmapped into "
"the filesystem's idmapping via the mount's idmapping. The file will now be "
"created with ``u1000`` according to the mount's idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:902
msgid "Example 5 reconsidered"
msgstr ""

#: ../../../filesystems/idmappings.rst:911
msgid ""
"Again, in order to report ownership to userspace the kernel now does three "
"steps using the translation algorithm we introduced earlier:"
msgstr ""

#: ../../../filesystems/idmappings.rst:933
msgid ""
"Earlier, the file's kernel id couldn't be crossmapped in the filesystems's "
"idmapping. With the idmapped mount in place it now can be crossmapped into "
"the filesystem's idmapping via the mount's idmapping. The file is now owned "
"by ``u1000`` according to the mount's idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:939
msgid "Changing ownership on a home directory"
msgstr ""

#: ../../../filesystems/idmappings.rst:941
msgid ""
"We've seen above how idmapped mounts can be used to translate between "
"idmappings when either the caller, the filesystem or both uses a non-initial "
"idmapping. A wide range of usecases exist when the caller is using a non-"
"initial idmapping. This mostly happens in the context of containerized "
"workloads. The consequence is as we have seen that for both, filesystem's "
"mounted with the initial idmapping and filesystems mounted with non-initial "
"idmappings, access to the filesystem isn't working because the kernel ids "
"can't be crossmapped between the caller's and the filesystem's idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:950
msgid ""
"As we've seen above idmapped mounts provide a solution to this by remapping "
"the caller's or filesystem's idmapping according to the mount's idmapping."
msgstr ""

#: ../../../filesystems/idmappings.rst:953
msgid ""
"Aside from containerized workloads, idmapped mounts have the advantage that "
"they also work when both the caller and the filesystem use the initial "
"idmapping which means users on the host can change the ownership of "
"directories and files on a per-mount basis."
msgstr ""

#: ../../../filesystems/idmappings.rst:958
msgid ""
"Consider our previous example where a user has their home directory on "
"portable storage. At home they have id ``u1000`` and all files in their home "
"directory are owned by ``u1000`` whereas at uni or work they have login id "
"``u1125``."
msgstr ""

#: ../../../filesystems/idmappings.rst:962
msgid ""
"Taking their home directory with them becomes problematic. They can't easily "
"access their files, they might not be able to write to disk without applying "
"lax permissions or ACLs and even if they can, they will end up with an "
"annoying mix of files and directories owned by ``u1000`` and ``u1125``."
msgstr ""

#: ../../../filesystems/idmappings.rst:967
msgid ""
"Idmapped mounts allow to solve this problem. A user can create an idmapped "
"mount for their home directory on their work computer or their computer at "
"home depending on what ownership they would prefer to end up on the portable "
"storage itself."
msgstr ""

#: ../../../filesystems/idmappings.rst:972
msgid ""
"Let's assume they want all files on disk to belong to ``u1000``. When the "
"user plugs in their portable storage at their work station they can setup a "
"job that creates an idmapped mount with the minimal idmapping ``u1000:k1125:"
"r1``. So now when they create a file the kernel performs the following steps "
"we already know from above:::"
msgstr ""

#: ../../../filesystems/idmappings.rst:997
msgid ""
"Verify that the caller's filesystem ids can be mapped to userspace ids in "
"the filesystem's idmapping::"
msgstr ""

#: ../../../filesystems/idmappings.rst:1002
msgid "So ultimately the file will be created with ``u1000`` on disk."
msgstr ""

#: ../../../filesystems/idmappings.rst:1004
msgid ""
"Now let's briefly look at what ownership the caller with id ``u1125`` will "
"see on their work computer:"
msgstr ""

#: ../../../filesystems/idmappings.rst:1033
msgid ""
"So ultimately the caller will be reported that the file belongs to ``u1125`` "
"which is the caller's userspace id on their workstation in our example."
msgstr ""

#: ../../../filesystems/idmappings.rst:1036
msgid ""
"The raw userspace id that is put on disk is ``u1000`` so when the user takes "
"their home directory back to their home computer where they are assigned "
"``u1000`` using the initial idmapping and mount the filesystem with the "
"initial idmapping they will see all those files owned by ``u1000``."
msgstr ""
