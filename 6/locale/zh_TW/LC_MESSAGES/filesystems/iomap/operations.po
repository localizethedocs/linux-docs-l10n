# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/iomap/operations.rst:12
msgid "Supported File Operations"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:15
msgid "Table of Contents"
msgstr "目次表"

#: ../../../filesystems/iomap/operations.rst:17
msgid ""
"Below are a discussion of the high level file operations that iomap "
"implements."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:21
msgid "Buffered I/O"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:23
msgid ""
"Buffered I/O is the default file I/O path in Linux. File contents are cached "
"in memory (\"pagecache\") to satisfy reads and writes. Dirty cache will be "
"written back to disk at some point that can be forced via ``fsync`` and "
"variants."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:29
msgid ""
"iomap implements nearly all the folio and pagecache management that "
"filesystems have to implement themselves under the legacy I/O model. This "
"means that the filesystem need not know the details of allocating, mapping, "
"managing uptodate and dirty state, or writeback of pagecache folios. Under "
"the legacy I/O model, this was managed very inefficiently with linked lists "
"of buffer heads instead of the per-folio bitmaps that iomap uses. Unless the "
"filesystem explicitly opts in to buffer heads, they will not be used, which "
"makes buffered I/O much more efficient, and the pagecache maintainer much "
"happier."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:42
msgid "``struct address_space_operations``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:44
msgid ""
"The following iomap functions can be referenced directly from the address "
"space operations structure:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:47
msgid "``iomap_dirty_folio``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:48
msgid "``iomap_release_folio``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:49
msgid "``iomap_invalidate_folio``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:50
msgid "``iomap_is_partially_uptodate``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:52
msgid "The following address space operations can be wrapped easily:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:54
msgid "``read_folio``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:55
msgid "``readahead``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:56
msgid "``writepages``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:57
msgid "``bmap``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:58
msgid "``swap_activate``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:61
msgid "``struct iomap_write_ops``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:75
msgid "iomap calls these functions:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:77
msgid ""
"``get_folio``: Called to allocate and return an active reference to a locked "
"folio prior to starting a write. If this function is not provided, iomap "
"will call ``iomap_get_folio``. This could be used to `set up per-folio "
"filesystem state <https://lore.kernel.org/all/20190429220934.10415-5-"
"agruenba@redhat.com/>`_ for a write."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:85
msgid ""
"``put_folio``: Called to unlock and put a folio after a pagecache operation "
"completes. If this function is not provided, iomap will ``folio_unlock`` and "
"``folio_put`` on its own. This could be used to `commit per-folio filesystem "
"state <https://lore.kernel.org/all/20180619164137.13720-6-hch@lst.de/>`_ "
"that was set up by ``->get_folio``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:93
msgid ""
"``iomap_valid``: The filesystem may not hold locks between ``->iomap_begin`` "
"and ``->iomap_end`` because pagecache operations can take folio locks, fault "
"on userspace pages, initiate writeback for memory reclamation, or engage in "
"other time-consuming actions. If a file's space mapping data are mutable, it "
"is possible that the mapping for a particular pagecache folio can `change in "
"the time it takes <https://lore.kernel.org/all/20221123055812.747923-8-"
"david@fromorbit.com/>`_ to allocate, install, and lock that folio."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:103
msgid ""
"For the pagecache, races can happen if writeback doesn't take ``i_rwsem`` or "
"``invalidate_lock`` and updates mapping information. Races can also happen "
"if the filesystem allows concurrent writes. For such files, the mapping "
"*must* be revalidated after the folio lock has been taken so that iomap can "
"manage the folio correctly."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:109
msgid ""
"fsdax does not need this revalidation because there's no writeback and no "
"support for unwritten extents."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:112
msgid ""
"Filesystems subject to this kind of race must provide a ``->iomap_valid`` "
"function to decide if the mapping is still valid. If the mapping is not "
"valid, the mapping will be sampled again."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:116
msgid ""
"To support making the validity decision, the filesystem's ``->iomap_begin`` "
"function may set ``struct iomap::validity_cookie`` at the same time that it "
"populates the other iomap fields. A simple validation cookie implementation "
"is a sequence counter. If the filesystem bumps the sequence counter every "
"time it modifies the inode's extent map, it can be placed in the ``struct "
"iomap::validity_cookie`` during ``->iomap_begin``. If the value in the "
"cookie is found to be different to the value the filesystem holds when the "
"mapping is passed back to ``->iomap_valid``, then the iomap should "
"considered stale and the validation failed."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:128
msgid ""
"``read_folio_range``: Called to synchronously read in the range that will be "
"written to. If this function is not provided, iomap will default to "
"submitting a bio read request."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:132
msgid ""
"These ``struct kiocb`` flags are significant for buffered I/O with iomap:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:134
#: ../../../filesystems/iomap/operations.rst:435
msgid "``IOCB_NOWAIT``: Turns on ``IOMAP_NOWAIT``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:136
msgid "``IOCB_DONTCACHE``: Turns on ``IOMAP_DONTCACHE``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:139
msgid "Internal per-Folio State"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:141
msgid ""
"If the fsblock size matches the size of a pagecache folio, it is assumed "
"that all disk I/O operations will operate on the entire folio. The uptodate "
"(memory contents are at least as new as what's on disk) and dirty (memory "
"contents are newer than what's on disk) status of the folio are all that's "
"needed for this case."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:147
msgid ""
"If the fsblock size is less than the size of a pagecache folio, iomap tracks "
"the per-fsblock uptodate and dirty state itself. This enables iomap to "
"handle both \"bs < ps\" `filesystems <https://lore.kernel.org/"
"all/20230725122932.144426-1-ritesh.list@gmail.com/>`_ and large folios in "
"the pagecache."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:153
msgid "iomap internally tracks two state bits per fsblock:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:155
msgid ""
"``uptodate``: iomap will try to keep folios fully up to date. If there are "
"read(ahead) errors, those fsblocks will not be marked uptodate. The folio "
"itself will be marked uptodate when all fsblocks within the folio are "
"uptodate."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:161
msgid ""
"``dirty``: iomap will set the per-block dirty state when programs write to "
"the file. The folio itself will be marked dirty when any fsblock within the "
"folio is dirty."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:166
msgid ""
"iomap also tracks the amount of read and write disk IOs that are in flight. "
"This structure is much lighter weight than ``struct buffer_head`` because "
"there is only one per folio, and the per-fsblock overhead is two bits vs. "
"104 bytes."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:172
msgid ""
"Filesystems wishing to turn on large folios in the pagecache should call "
"``mapping_set_large_folios`` when initializing the incore inode."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:176
msgid "Buffered Readahead and Reads"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:178
msgid ""
"The ``iomap_readahead`` function initiates readahead to the pagecache. The "
"``iomap_read_folio`` function reads one folio's worth of data into the "
"pagecache. The ``flags`` argument to ``->iomap_begin`` will be set to zero. "
"The pagecache takes whatever locks it needs before calling the filesystem."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:186
msgid "Buffered Writes"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:188
msgid ""
"The ``iomap_file_buffered_write`` function writes an ``iocb`` to the "
"pagecache. ``IOMAP_WRITE`` or ``IOMAP_WRITE`` | ``IOMAP_NOWAIT`` will be "
"passed as the ``flags`` argument to ``->iomap_begin``. Callers commonly take "
"``i_rwsem`` in either shared or exclusive mode before calling this function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:196
msgid "mmap Write Faults"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:198
msgid ""
"The ``iomap_page_mkwrite`` function handles a write fault to a folio in the "
"pagecache. ``IOMAP_WRITE | IOMAP_FAULT`` will be passed as the ``flags`` "
"argument to ``->iomap_begin``. Callers commonly take the mmap "
"``invalidate_lock`` in shared or exclusive mode before calling this function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:206
msgid "Buffered Write Failures"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:208
msgid ""
"After a short write to the pagecache, the areas not written will not become "
"marked dirty. The filesystem must arrange to `cancel <https://lore.kernel."
"org/all/20221123055812.747923-6-david@fromorbit.com/>`_ such `reservations "
"<https://lore.kernel.org/linux-xfs/20220817093627.GZ3600936@dread.disaster."
"area/>`_ because writeback will not consume the reservation. The "
"``iomap_write_delalloc_release`` can be called from a ``->iomap_end`` "
"function to find all the clean areas of the folios caching a fresh "
"(``IOMAP_F_NEW``) delalloc mapping. It takes the ``invalidate_lock``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:220
msgid ""
"The filesystem must supply a function ``punch`` to be called for each file "
"range in this state. This function must *only* remove delayed allocation "
"reservations, in case another thread racing with the current thread writes "
"successfully to the same region and triggers writeback to flush the dirty "
"data out to disk."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:228
msgid "Zeroing for File Operations"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:230
msgid ""
"Filesystems can call ``iomap_zero_range`` to perform zeroing of the "
"pagecache for non-truncation file operations that are not aligned to the "
"fsblock size. ``IOMAP_ZERO`` will be passed as the ``flags`` argument to ``-"
">iomap_begin``. Callers typically hold ``i_rwsem`` and ``invalidate_lock`` "
"in exclusive mode before calling this function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:239
msgid "Unsharing Reflinked File Data"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:241
msgid ""
"Filesystems can call ``iomap_file_unshare`` to force a file sharing storage "
"with another file to preemptively copy the shared data to newly allocate "
"storage. ``IOMAP_WRITE | IOMAP_UNSHARE`` will be passed as the ``flags`` "
"argument to ``->iomap_begin``. Callers typically hold ``i_rwsem`` and "
"``invalidate_lock`` in exclusive mode before calling this function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:250
msgid "Truncation"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:252
msgid ""
"Filesystems can call ``iomap_truncate_page`` to zero the bytes in the "
"pagecache from EOF to the end of the fsblock during a file truncation "
"operation. ``truncate_setsize`` or ``truncate_pagecache`` will take care of "
"everything after the EOF block. ``IOMAP_ZERO`` will be passed as the "
"``flags`` argument to ``->iomap_begin``. Callers typically hold ``i_rwsem`` "
"and ``invalidate_lock`` in exclusive mode before calling this function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:263
msgid "Pagecache Writeback"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:265
msgid ""
"Filesystems can call ``iomap_writepages`` to respond to a request to write "
"dirty pagecache folios to disk. The ``mapping`` and ``wbc`` parameters "
"should be passed unchanged. The ``wpc`` pointer should be allocated by the "
"filesystem and must be initialized to zero."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:271
msgid ""
"The pagecache will lock each folio before trying to schedule it for "
"writeback. It does not lock ``i_rwsem`` or ``invalidate_lock``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:275
msgid ""
"The dirty bit will be cleared for all folios run through the ``-"
">writeback_range`` machinery described below even if the writeback fails. "
"This is to prevent dirty folio clots when storage devices fail; an ``-EIO`` "
"is recorded for userspace to collect via ``fsync``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:280
msgid "The ``ops`` structure must be specified and is as follows:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:283
msgid "``struct iomap_writeback_ops``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:293
msgid "The fields are as follows:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:295
msgid ""
"``writeback_range``: Sets ``wpc->iomap`` to the space mapping of the file "
"range (in bytes) given by ``offset`` and ``len``. iomap calls this function "
"for each dirty fs block in each dirty folio, though it will `reuse mappings "
"<https://lore.kernel.org/all/20231207072710.176093-15-hch@lst.de/>`_ for "
"runs of contiguous dirty fsblocks within a folio. Do not return "
"``IOMAP_INLINE`` mappings here; the ``->iomap_end`` function must deal with "
"persisting written data. Do not return ``IOMAP_DELALLOC`` mappings here; "
"iomap currently requires mapping to allocated space. Filesystems can skip a "
"potentially expensive mapping lookup if the mappings have not changed. This "
"revalidation must be open-coded by the filesystem; it is unclear if ``iomap::"
"validity_cookie`` can be reused for this purpose."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:311
msgid ""
"If this methods fails to schedule I/O for any part of a dirty folio, it "
"should throw away any reservations that may have been made for the write. "
"The folio will be marked clean and an ``-EIO`` recorded in the pagecache. "
"Filesystems can use this callback to `remove <https://lore.kernel.org/"
"all/20201029163313.1766967-1-bfoster@redhat.com/>`_ delalloc reservations to "
"avoid having delalloc reservations for clean pagecache. This function must "
"be supplied by the filesystem."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:321
msgid ""
"``writeback_submit``: Submit the previous built writeback context. Block "
"based file systems should use the iomap_ioend_writeback_submit helper, other "
"file system can implement their own. File systems can optionall to hook into "
"writeback bio submission. This might include pre-write space accounting "
"updates, or installing a custom ``->bi_end_io`` function for internal "
"purposes, such as deferring the ioend completion to a workqueue to run "
"metadata update transactions from process context before submitting the bio. "
"This function must be supplied by the filesystem."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:332
msgid "Pagecache Writeback Completion"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:334
msgid ""
"To handle the bookkeeping that must happen after disk I/O for writeback "
"completes, iomap creates chains of ``struct iomap_ioend`` objects that wrap "
"the ``bio`` that is used to write pagecache data to disk. By default, iomap "
"finishes writeback ioends by clearing the writeback bit on the folios "
"attached to the ``ioend``. If the write failed, it will also set the error "
"bits on the folios and the address space. This can happen in interrupt or "
"process context, depending on the storage device. Filesystems that need to "
"update internal bookkeeping (e.g. unwritten extent conversions) should set "
"their own bi_end_io on the bios submitted by ``->submit_writeback`` This "
"function should call ``iomap_finish_ioends`` after finishing its own work (e."
"g. unwritten extent conversion)."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:349
msgid ""
"Some filesystems may wish to `amortize the cost of running metadata "
"transactions <https://lore.kernel.org/all/20220120034733.221737-1-"
"david@fromorbit.com/>`_ for post-writeback updates by batching them. They "
"may also require transactions to run from process context, which implies "
"punting batches to a workqueue. iomap ioends contain a ``list_head`` to "
"enable batching."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:357
msgid ""
"Given a batch of ioends, iomap has a few helpers to assist with amortization:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:360
msgid "``iomap_sort_ioends``: Sort all the ioends in the list by file offset."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:363
msgid ""
"``iomap_ioend_try_merge``: Given an ioend that is not in any list and a "
"separate list of sorted ioends, merge as many of the ioends from the head of "
"the list into the given ioend. ioends can only be merged if the file range "
"and storage addresses are contiguous; the unwritten and shared status are "
"the same; and the write I/O outcome is the same. The merged ioends become "
"their own list."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:371
msgid ""
"``iomap_finish_ioends``: Finish an ioend that possibly has other ioends "
"linked to it."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:375
msgid "Direct I/O"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:377
msgid ""
"In Linux, direct I/O is defined as file I/O that is issued directly to "
"storage, bypassing the pagecache. The ``iomap_dio_rw`` function implements "
"O_DIRECT (direct I/O) reads and writes for files."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:390
msgid ""
"The filesystem can provide the ``dops`` parameter if it needs to perform "
"extra work before or after the I/O is issued to storage. The ``done_before`` "
"parameter tells the how much of the request has already been transferred. It "
"is used to continue a request asynchronously when `part of the request "
"<https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?"
"id=c03098d4b9ad76bca2966a8769dcfe59f7f85103>`_ has already been completed "
"synchronously."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:399
msgid ""
"The ``done_before`` parameter should be set if writes for the ``iocb`` have "
"been initiated prior to the call. The direction of the I/O is determined "
"from the ``iocb`` passed in."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:403
msgid ""
"The ``dio_flags`` argument can be set to any combination of the following "
"values:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:406
msgid ""
"``IOMAP_DIO_FORCE_WAIT``: Wait for the I/O to complete even if the kiocb is "
"not synchronous."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:409
msgid ""
"``IOMAP_DIO_OVERWRITE_ONLY``: Perform a pure overwrite for this range or "
"fail with ``-EAGAIN``. This can be used by filesystems with complex "
"unaligned I/O write paths to provide an optimised fast path for unaligned "
"writes. If a pure overwrite can be performed, then serialisation against "
"other I/Os to the same filesystem block(s) is unnecessary as there is no "
"risk of stale data exposure or data loss. If a pure overwrite cannot be "
"performed, then the filesystem can perform the serialisation steps needed to "
"provide exclusive access to the unaligned I/O range so that it can perform "
"allocation and sub-block zeroing safely. Filesystems can use this flag to "
"try to reduce locking contention, but a lot of `detailed checking <https://"
"lore.kernel.org/linux-ext4/20230314130759.642710-1-bfoster@redhat.com/>`_ is "
"required to do it `correctly <https://lore.kernel.org/linux-"
"ext4/20230810165559.946222-1-bfoster@redhat.com/>`_."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:426
msgid ""
"``IOMAP_DIO_PARTIAL``: If a page fault occurs, return whatever progress has "
"already been made. The caller may deal with the page fault and retry the "
"operation. If the caller decides to retry the operation, it should pass the "
"accumulated return values of all previous calls as the ``done_before`` "
"parameter to the next call."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:433
msgid "These ``struct kiocb`` flags are significant for direct I/O with iomap:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:437
msgid ""
"``IOCB_SYNC``: Ensure that the device has persisted data to disk before "
"completing the call. In the case of pure overwrites, the I/O may be issued "
"with FUA enabled."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:442
msgid ""
"``IOCB_HIPRI``: Poll for I/O completion instead of waiting for an interrupt. "
"Only meaningful for asynchronous I/O, and only if the entire I/O can be "
"issued as a single ``struct bio``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:447
msgid ""
"``IOCB_DIO_CALLER_COMP``: Try to run I/O completion from the caller's "
"process context. See ``linux/fs.h`` for more details."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:451
msgid ""
"Filesystems should call ``iomap_dio_rw`` from ``->read_iter`` and ``-"
">write_iter``, and set ``FMODE_CAN_ODIRECT`` in the ``->open`` function for "
"the file. They should not set ``->direct_IO``, which is deprecated."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:456
msgid ""
"If a filesystem wishes to perform its own work before direct I/O completion, "
"it should call ``__iomap_dio_rw``. If its return value is not an error "
"pointer or a NULL pointer, the filesystem should pass the return value to "
"``iomap_dio_complete`` after finishing its internal work."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:463
msgid "Return Values"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:465
msgid "``iomap_dio_rw`` can return one of the following:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:467
msgid "A non-negative number of bytes transferred."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:469
msgid ""
"``-ENOTBLK``: Fall back to buffered I/O. iomap itself will return this value "
"if it cannot invalidate the page cache before issuing the I/O to storage. "
"The ``->iomap_begin`` or ``->iomap_end`` functions may also return this "
"value."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:475
msgid ""
"``-EIOCBQUEUED``: The asynchronous direct I/O request has been queued and "
"will be completed separately."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:478
msgid "Any of the other negative error codes."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:481
msgid "Direct Reads"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:483
msgid ""
"A direct I/O read initiates a read I/O from the storage device to the "
"caller's buffer. Dirty parts of the pagecache are flushed to storage before "
"initiating the read io. The ``flags`` value for ``->iomap_begin`` will be "
"``IOMAP_DIRECT`` with any combination of the following enhancements:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:490
#: ../../../filesystems/iomap/operations.rst:506
#: ../../../filesystems/iomap/operations.rst:608
#: ../../../filesystems/iomap/operations.rst:621
msgid "``IOMAP_NOWAIT``, as defined previously."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:492
#: ../../../filesystems/iomap/operations.rst:610
#: ../../../filesystems/iomap/operations.rst:687
#: ../../../filesystems/iomap/operations.rst:702
msgid ""
"Callers commonly hold ``i_rwsem`` in shared mode before calling this "
"function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:496
msgid "Direct Writes"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:498
msgid ""
"A direct I/O write initiates a write I/O to the storage device from the "
"caller's buffer. Dirty parts of the pagecache are flushed to storage before "
"initiating the write io. The pagecache is invalidated both before and after "
"the write io. The ``flags`` value for ``->iomap_begin`` will be "
"``IOMAP_DIRECT | IOMAP_WRITE`` with any combination of the following "
"enhancements:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:508
msgid ""
"``IOMAP_OVERWRITE_ONLY``: Allocating blocks and zeroing partial blocks is "
"not allowed. The entire file range must map to a single written or unwritten "
"extent. The file I/O range must be aligned to the filesystem block size if "
"the mapping is unwritten and the filesystem cannot handle zeroing the "
"unaligned regions without exposing stale contents."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:516
msgid ""
"``IOMAP_ATOMIC``: This write is being issued with torn-write protection. "
"Torn-write protection may be provided based on HW-offload or by a software "
"mechanism provided by the filesystem."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:521
msgid ""
"For HW-offload based support, only a single bio can be created for the "
"write, and the write must not be split into multiple I/O requests, i.e. flag "
"REQ_ATOMIC must be set. The file range to write must be aligned to satisfy "
"the requirements of both the filesystem and the underlying block device's "
"atomic commit capabilities. If filesystem metadata updates are required (e."
"g. unwritten extent conversion or copy-on-write), all updates for the entire "
"file range must be committed atomically as well. Untorn-writes may be longer "
"than a single file block. In all cases, the mapping start disk block must "
"have at least the same alignment as the write offset. The filesystems must "
"set IOMAP_F_ATOMIC_BIO to inform iomap core of an untorn-write based on HW-"
"offload."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:536
msgid ""
"For untorn-writes based on a software mechanism provided by the filesystem, "
"all the disk block alignment and single bio restrictions which apply for HW-"
"offload based untorn-writes do not apply. The mechanism would typically be "
"used as a fallback for when HW-offload based untorn-writes may not be "
"issued, e.g. the range of the write covers multiple extents, meaning that it "
"is not possible to issue a single bio. All filesystem metadata updates for "
"the entire file range must be committed atomically as well."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:546
msgid ""
"Callers commonly hold ``i_rwsem`` in shared or exclusive mode before calling "
"this function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:550
msgid "``struct iomap_dio_ops:``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:561
msgid "The fields of this structure are as follows:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:563
msgid ""
"``submit_io``: iomap calls this function when it has constructed a ``struct "
"bio`` object for the I/O requested, and wishes to submit it to the block "
"device. If no function is provided, ``submit_bio`` will be called directly. "
"Filesystems that would like to perform additional work before (e.g. data "
"replication for btrfs) should implement this function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:570
msgid ""
"``end_io``: This is called after the ``struct bio`` completes. This function "
"should perform post-write conversions of unwritten extent mappings, handle "
"write failures, etc. The ``flags`` argument may be set to a combination of "
"the following:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:575
msgid ""
"``IOMAP_DIO_UNWRITTEN``: The mapping was unwritten, so the ioend should mark "
"the extent as written."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:578
msgid ""
"``IOMAP_DIO_COW``: Writing to the space in the mapping required a copy on "
"write operation, so the ioend should switch mappings."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:581
msgid ""
"``bio_set``: This allows the filesystem to provide a custom bio_set for "
"allocating direct I/O bios. This enables filesystems to `stash additional "
"per-bio information <https://lore.kernel.org/all/20220505201115.937837-3-"
"hch@lst.de/>`_ for private use. If this field is NULL, generic ``struct "
"bio`` objects will be used."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:588
msgid ""
"Filesystems that want to perform extra work after an I/O completion should "
"set a custom ``->bi_end_io`` function via ``->submit_io``. Afterwards, the "
"custom endio function must call ``iomap_dio_bio_end_io`` to finish the "
"direct I/O."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:594
msgid "DAX I/O"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:596
msgid ""
"Some storage devices can be directly mapped as memory. These devices support "
"a new access mode known as \"fsdax\" that allows loads and stores through "
"the CPU and memory controller."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:601
msgid "fsdax Reads"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:603
msgid ""
"A fsdax read performs a memcpy from storage device to the caller's buffer. "
"The ``flags`` value for ``->iomap_begin`` will be ``IOMAP_DAX`` with any "
"combination of the following enhancements:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:614
msgid "fsdax Writes"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:616
msgid ""
"A fsdax write initiates a memcpy to the storage device from the caller's "
"buffer. The ``flags`` value for ``->iomap_begin`` will be ``IOMAP_DAX | "
"IOMAP_WRITE`` with any combination of the following enhancements:"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:623
msgid ""
"``IOMAP_OVERWRITE_ONLY``: The caller requires a pure overwrite to be "
"performed from this mapping. This requires the filesystem extent mapping to "
"already exist as an ``IOMAP_MAPPED`` type and span the entire range of the "
"write I/O request. If the filesystem cannot map this request in a way that "
"allows the iomap infrastructure to perform a pure overwrite, it must fail "
"the mapping operation with ``-EAGAIN``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:632
msgid ""
"Callers commonly hold ``i_rwsem`` in exclusive mode before calling this "
"function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:636
msgid "fsdax mmap Faults"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:638
msgid ""
"The ``dax_iomap_fault`` function handles read and write faults to fsdax "
"storage. For a read fault, ``IOMAP_DAX | IOMAP_FAULT`` will be passed as the "
"``flags`` argument to ``->iomap_begin``. For a write fault, ``IOMAP_DAX | "
"IOMAP_FAULT | IOMAP_WRITE`` will be passed as the ``flags`` argument to ``-"
">iomap_begin``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:645
#: ../../../filesystems/iomap/operations.rst:660
msgid ""
"Callers commonly hold the same locks as they do to call their iomap "
"pagecache counterparts."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:649
msgid "fsdax Truncation, fallocate, and Unsharing"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:651
msgid ""
"For fsdax files, the following functions are provided to replace their iomap "
"pagecache I/O counterparts. The ``flags`` argument to ``->iomap_begin`` are "
"the same as the pagecache counterparts, with ``IOMAP_DAX`` added."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:656
msgid "``dax_file_unshare``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:657
msgid "``dax_zero_range``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:658
msgid "``dax_truncate_page``"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:664
msgid "fsdax Deduplication"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:666
msgid ""
"Filesystems implementing the ``FIDEDUPERANGE`` ioctl must call the "
"``dax_remap_file_range_prep`` function with their own iomap read ops."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:670
msgid "Seeking Files"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:672
msgid ""
"iomap implements the two iterating whence modes of the ``llseek`` system "
"call."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:676
msgid "SEEK_DATA"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:678
msgid ""
"The ``iomap_seek_data`` function implements the SEEK_DATA \"whence\" value "
"for llseek. ``IOMAP_REPORT`` will be passed as the ``flags`` argument to ``-"
">iomap_begin``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:683
msgid ""
"For unwritten mappings, the pagecache will be searched. Regions of the "
"pagecache with a folio mapped and uptodate fsblocks within those folios will "
"be reported as data areas."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:691
msgid "SEEK_HOLE"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:693
msgid ""
"The ``iomap_seek_hole`` function implements the SEEK_HOLE \"whence\" value "
"for llseek. ``IOMAP_REPORT`` will be passed as the ``flags`` argument to ``-"
">iomap_begin``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:698
msgid ""
"For unwritten mappings, the pagecache will be searched. Regions of the "
"pagecache with no folio mapped, or a !uptodate fsblock within a folio will "
"be reported as sparse hole areas."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:706
msgid "Swap File Activation"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:708
msgid ""
"The ``iomap_swapfile_activate`` function finds all the base-page aligned "
"regions in a file and sets them up as swap space. The file will be "
"``fsync()``'d before activation. ``IOMAP_REPORT`` will be passed as the "
"``flags`` argument to ``->iomap_begin``. All mappings must be mapped or "
"unwritten; cannot be dirty or shared, and cannot span multiple block "
"devices. Callers must hold ``i_rwsem`` in exclusive mode; this is already "
"provided by ``swapon``."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:719
msgid "File Space Mapping Reporting"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:721
msgid "iomap implements two of the file space mapping system calls."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:724
msgid "FS_IOC_FIEMAP"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:726
msgid ""
"The ``iomap_fiemap`` function exports file extent mappings to userspace in "
"the format specified by the ``FS_IOC_FIEMAP`` ioctl. ``IOMAP_REPORT`` will "
"be passed as the ``flags`` argument to ``->iomap_begin``. Callers commonly "
"hold ``i_rwsem`` in shared mode before calling this function."
msgstr ""

#: ../../../filesystems/iomap/operations.rst:734
msgid "FIBMAP (deprecated)"
msgstr ""

#: ../../../filesystems/iomap/operations.rst:736
msgid ""
"``iomap_bmap`` implements FIBMAP. The calling conventions are the same as "
"for FIEMAP. This function is only provided to maintain compatibility for "
"filesystems that implemented FIBMAP prior to conversion. This ioctl is "
"deprecated; do **not** add a FIBMAP implementation to filesystems that do "
"not have it. Callers should probably hold ``i_rwsem`` in shared mode before "
"calling this function, but this is unclear."
msgstr ""
