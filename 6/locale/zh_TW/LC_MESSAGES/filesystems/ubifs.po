# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/ubifs.rst:5
msgid "UBI File System"
msgstr ""

#: ../../../filesystems/ubifs.rst:8
msgid "Introduction"
msgstr ""

#: ../../../filesystems/ubifs.rst:10
msgid ""
"UBIFS file-system stands for UBI File System. UBI stands for \"Unsorted "
"Block Images\". UBIFS is a flash file system, which means it is designed to "
"work with flash devices. It is important to understand, that UBIFS is "
"completely different to any traditional file-system in Linux, like Ext2, "
"XFS, JFS, etc. UBIFS represents a separate class of file-systems which work "
"with MTD devices, not block devices. The other Linux file-system of this "
"class is JFFS2."
msgstr ""

#: ../../../filesystems/ubifs.rst:18
msgid ""
"To make it more clear, here is a small comparison of MTD devices and block "
"devices."
msgstr ""

#: ../../../filesystems/ubifs.rst:21
msgid ""
"1 MTD devices represent flash devices and they consist of eraseblocks of"
msgstr ""

#: ../../../filesystems/ubifs.rst:22
msgid ""
"rather large size, typically about 128KiB. Block devices consist of small "
"blocks, typically 512 bytes."
msgstr ""

#: ../../../filesystems/ubifs.rst:24
msgid ""
"2 MTD devices support 3 main operations - read from some offset within an"
msgstr ""

#: ../../../filesystems/ubifs.rst:25
msgid ""
"eraseblock, write to some offset within an eraseblock, and erase a whole "
"eraseblock. Block  devices support 2 main operations - read a whole block "
"and write a whole block."
msgstr ""

#: ../../../filesystems/ubifs.rst:28
msgid "3 The whole eraseblock has to be erased before it becomes possible to"
msgstr ""

#: ../../../filesystems/ubifs.rst:29
msgid "re-write its contents. Blocks may be just re-written."
msgstr ""

#: ../../../filesystems/ubifs.rst:30
msgid "4 Eraseblocks become worn out after some number of erase cycles -"
msgstr ""

#: ../../../filesystems/ubifs.rst:31
msgid ""
"typically 100K-1G for SLC NAND and NOR flashes, and 1K-10K for MLC NAND "
"flashes. Blocks do not have the wear-out property."
msgstr ""

#: ../../../filesystems/ubifs.rst:33
msgid "5 Eraseblocks may become bad (only on NAND flashes) and software should"
msgstr ""

#: ../../../filesystems/ubifs.rst:34
msgid ""
"deal with this. Blocks on hard drives typically do not become bad, because "
"hardware has mechanisms to substitute bad blocks, at least in modern LBA "
"disks."
msgstr ""

#: ../../../filesystems/ubifs.rst:38
msgid ""
"It should be quite obvious why UBIFS is very different to traditional file-"
"systems."
msgstr ""

#: ../../../filesystems/ubifs.rst:41
msgid ""
"UBIFS works on top of UBI. UBI is a separate software layer which may be "
"found in drivers/mtd/ubi. UBI is basically a volume management and wear-"
"leveling layer. It provides so called UBI volumes which is a higher level "
"abstraction than a MTD device. The programming model of UBI devices is very "
"similar to MTD devices - they still consist of large eraseblocks, they have "
"read/write/erase operations, but UBI devices are devoid of limitations like "
"wear and bad blocks (items 4 and 5 in the above list)."
msgstr ""

#: ../../../filesystems/ubifs.rst:49
msgid ""
"In a sense, UBIFS is a next generation of JFFS2 file-system, but it is very "
"different and incompatible to JFFS2. The following are the main differences."
msgstr ""

#: ../../../filesystems/ubifs.rst:53
msgid ""
"JFFS2 works on top of MTD devices, UBIFS depends on UBI and works on top of "
"UBI volumes."
msgstr ""

#: ../../../filesystems/ubifs.rst:55
msgid ""
"JFFS2 does not have on-media index and has to build it while mounting, which "
"requires full media scan. UBIFS maintains the FS indexing information on the "
"flash media and does not require full media scan, so it mounts many times "
"faster than JFFS2."
msgstr ""

#: ../../../filesystems/ubifs.rst:59
msgid ""
"JFFS2 is a write-through file-system, while UBIFS supports write-back, which "
"makes UBIFS much faster on writes."
msgstr ""

#: ../../../filesystems/ubifs.rst:62
msgid ""
"Similarly to JFFS2, UBIFS supports on-the-fly compression which makes it "
"possible to fit quite a lot of data to the flash."
msgstr ""

#: ../../../filesystems/ubifs.rst:65
msgid ""
"Similarly to JFFS2, UBIFS is tolerant of unclean reboots and power-cuts. It "
"does not need stuff like fsck.ext2. UBIFS automatically replays its journal "
"and recovers from crashes, ensuring that the on-flash data structures are "
"consistent."
msgstr ""

#: ../../../filesystems/ubifs.rst:70
msgid ""
"UBIFS scales logarithmically (most of the data structures it uses are "
"trees), so the mount time and memory consumption do not linearly depend on "
"the flash size, like in case of JFFS2. This is because UBIFS maintains the "
"FS index on the flash media. However, UBIFS depends on UBI, which scales "
"linearly. So overall UBI/UBIFS stack scales linearly. Nevertheless, UBI/"
"UBIFS scales considerably better than JFFS2."
msgstr ""

#: ../../../filesystems/ubifs.rst:77
msgid ""
"The authors of UBIFS believe, that it is possible to develop UBI2 which "
"would scale logarithmically as well. UBI2 would support the same API as UBI, "
"but it would be binary incompatible to UBI. So UBIFS would not need to be "
"changed to use UBI2"
msgstr ""

#: ../../../filesystems/ubifs.rst:84
msgid "Mount options"
msgstr ""

#: ../../../filesystems/ubifs.rst:86
msgid "(*) == default."
msgstr ""

#: ../../../filesystems/ubifs.rst:89
msgid "bulk_read"
msgstr ""

#: ../../../filesystems/ubifs.rst:89
msgid ""
"read more in one go to take advantage of flash media that read faster "
"sequentially"
msgstr ""

#: ../../../filesystems/ubifs.rst:91
msgid "no_bulk_read (*)"
msgstr ""

#: ../../../filesystems/ubifs.rst:91
msgid "do not bulk-read"
msgstr ""

#: ../../../filesystems/ubifs.rst:92
msgid "no_chk_data_crc (*)"
msgstr ""

#: ../../../filesystems/ubifs.rst:92
msgid ""
"skip checking of CRCs on data nodes in order to improve read performance. "
"Use this option only if the flash media is highly reliable. The effect of "
"this option is that corruption of the contents of a file can go unnoticed."
msgstr ""

#: ../../../filesystems/ubifs.rst:97
msgid "chk_data_crc"
msgstr ""

#: ../../../filesystems/ubifs.rst:97
msgid "do not skip checking CRCs on data nodes"
msgstr ""

#: ../../../filesystems/ubifs.rst:98
msgid "compr=none"
msgstr ""

#: ../../../filesystems/ubifs.rst:98
msgid "override default compressor and set it to \"none\""
msgstr ""

#: ../../../filesystems/ubifs.rst:99
msgid "compr=lzo"
msgstr ""

#: ../../../filesystems/ubifs.rst:99
msgid "override default compressor and set it to \"lzo\""
msgstr ""

#: ../../../filesystems/ubifs.rst:100
msgid "compr=zlib"
msgstr ""

#: ../../../filesystems/ubifs.rst:100
msgid "override default compressor and set it to \"zlib\""
msgstr ""

#: ../../../filesystems/ubifs.rst:101
msgid "auth_key="
msgstr ""

#: ../../../filesystems/ubifs.rst:101
msgid ""
"specify the key used for authenticating the filesystem. Passing this option "
"makes authentication mandatory. The passed key must be present in the kernel "
"keyring and must be of type 'logon'"
msgstr ""

#: ../../../filesystems/ubifs.rst:105
msgid "auth_hash_name="
msgstr ""

#: ../../../filesystems/ubifs.rst:105
msgid ""
"The hash algorithm used for authentication. Used for both hashing and for "
"creating HMACs. Typical values include \"sha256\" or \"sha512\""
msgstr ""

#: ../../../filesystems/ubifs.rst:112
msgid "Quick usage instructions"
msgstr ""

#: ../../../filesystems/ubifs.rst:114
msgid ""
"The UBI volume to mount is specified using \"ubiX_Y\" or \"ubiX:NAME\" "
"syntax, where \"X\" is UBI device number, \"Y\" is UBI volume number, and "
"\"NAME\" is UBI volume name."
msgstr ""

#: ../../../filesystems/ubifs.rst:118
msgid "Mount volume 0 on UBI device 0 to /mnt/ubifs::"
msgstr ""

#: ../../../filesystems/ubifs.rst:122
msgid ""
"Mount \"rootfs\" volume of UBI device 0 to /mnt/ubifs (\"rootfs\" is volume "
"name)::"
msgstr ""

#: ../../../filesystems/ubifs.rst:127
msgid ""
"The following is an example of the kernel boot arguments to attach mtd0 to "
"UBI and mount volume \"rootfs\": ubi.mtd=0 root=ubi0:rootfs rootfstype=ubifs"
msgstr ""

#: ../../../filesystems/ubifs.rst:132
msgid "References"
msgstr ""

#: ../../../filesystems/ubifs.rst:134
msgid "UBIFS documentation and FAQ/HOWTO at the MTD web site:"
msgstr ""

#: ../../../filesystems/ubifs.rst:136
msgid "http://www.linux-mtd.infradead.org/doc/ubifs.html"
msgstr ""

#: ../../../filesystems/ubifs.rst:137
msgid "http://www.linux-mtd.infradead.org/faq/ubifs.html"
msgstr ""
