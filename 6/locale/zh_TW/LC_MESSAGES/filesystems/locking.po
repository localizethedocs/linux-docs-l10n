# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-13 10:19+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/locking.rst:3
msgid "Locking"
msgstr ""

#: ../../../filesystems/locking.rst:5
msgid ""
"The text below describes the locking rules for VFS-related methods. It is "
"(believed to be) up-to-date. *Please*, if you change anything in prototypes "
"or locking protocols - update this file. And update the relevant instances "
"in the tree, don't leave that to maintainers of filesystems/devices/ etc. At "
"the very least, put the list of dubious cases in the end of this file. Don't "
"turn it into log - maintainers of out-of-the-tree code are supposed to be "
"able to use diff(1)."
msgstr ""

#: ../../../filesystems/locking.rst:13
msgid "Thing currently missing here: socket operations. Alexey?"
msgstr ""

#: ../../../filesystems/locking.rst:16
msgid "dentry_operations"
msgstr ""

#: ../../../filesystems/locking.rst:18 ../../../filesystems/locking.rst:62
#: ../../../filesystems/locking.rst:141 ../../../filesystems/locking.rst:166
#: ../../../filesystems/locking.rst:227 ../../../filesystems/locking.rst:250
#: ../../../filesystems/locking.rst:374 ../../../filesystems/locking.rst:397
#: ../../../filesystems/locking.rst:425 ../../../filesystems/locking.rst:438
#: ../../../filesystems/locking.rst:472 ../../../filesystems/locking.rst:564
#: ../../../filesystems/locking.rst:595
msgid "prototypes::"
msgstr ""

#: ../../../filesystems/locking.rst:37 ../../../filesystems/locking.rst:95
#: ../../../filesystems/locking.rst:152 ../../../filesystems/locking.rst:186
#: ../../../filesystems/locking.rst:233 ../../../filesystems/locking.rst:276
#: ../../../filesystems/locking.rst:380 ../../../filesystems/locking.rst:407
#: ../../../filesystems/locking.rst:429 ../../../filesystems/locking.rst:450
#: ../../../filesystems/locking.rst:510 ../../../filesystems/locking.rst:606
msgid "locking rules:"
msgstr ""

#: ../../../filesystems/locking.rst:40 ../../../filesystems/locking.rst:99
#: ../../../filesystems/locking.rst:156 ../../../filesystems/locking.rst:190
#: ../../../filesystems/locking.rst:236 ../../../filesystems/locking.rst:280
#: ../../../filesystems/locking.rst:383 ../../../filesystems/locking.rst:410
#: ../../../filesystems/locking.rst:453 ../../../filesystems/locking.rst:578
#: ../../../filesystems/locking.rst:609
msgid "ops"
msgstr ""

#: ../../../filesystems/locking.rst:40
msgid "rename_lock"
msgstr ""

#: ../../../filesystems/locking.rst:40
msgid "->d_lock"
msgstr ""

#: ../../../filesystems/locking.rst:40 ../../../filesystems/locking.rst:236
#: ../../../filesystems/locking.rst:383 ../../../filesystems/locking.rst:410
msgid "may block"
msgstr ""

#: ../../../filesystems/locking.rst:40
msgid "rcu-walk"
msgstr ""

#: ../../../filesystems/locking.rst:42
msgid "d_revalidate:"
msgstr ""

#: ../../../filesystems/locking.rst:42 ../../../filesystems/locking.rst:43
#: ../../../filesystems/locking.rst:44 ../../../filesystems/locking.rst:45
#: ../../../filesystems/locking.rst:46 ../../../filesystems/locking.rst:47
#: ../../../filesystems/locking.rst:48 ../../../filesystems/locking.rst:49
#: ../../../filesystems/locking.rst:50 ../../../filesystems/locking.rst:51
#: ../../../filesystems/locking.rst:52 ../../../filesystems/locking.rst:53
#: ../../../filesystems/locking.rst:54 ../../../filesystems/locking.rst:55
#: ../../../filesystems/locking.rst:56 ../../../filesystems/locking.rst:110
#: ../../../filesystems/locking.rst:111 ../../../filesystems/locking.rst:114
#: ../../../filesystems/locking.rst:115 ../../../filesystems/locking.rst:116
#: ../../../filesystems/locking.rst:117 ../../../filesystems/locking.rst:118
#: ../../../filesystems/locking.rst:119 ../../../filesystems/locking.rst:121
#: ../../../filesystems/locking.rst:124 ../../../filesystems/locking.rst:158
#: ../../../filesystems/locking.rst:159 ../../../filesystems/locking.rst:205
#: ../../../filesystems/locking.rst:206 ../../../filesystems/locking.rst:207
#: ../../../filesystems/locking.rst:208 ../../../filesystems/locking.rst:297
#: ../../../filesystems/locking.rst:298 ../../../filesystems/locking.rst:385
#: ../../../filesystems/locking.rst:412 ../../../filesystems/locking.rst:413
#: ../../../filesystems/locking.rst:414 ../../../filesystems/locking.rst:415
#: ../../../filesystems/locking.rst:416 ../../../filesystems/locking.rst:417
#: ../../../filesystems/locking.rst:418 ../../../filesystems/locking.rst:419
#: ../../../filesystems/locking.rst:457 ../../../filesystems/locking.rst:458
#: ../../../filesystems/locking.rst:459 ../../../filesystems/locking.rst:460
#: ../../../filesystems/locking.rst:461 ../../../filesystems/locking.rst:583
msgid "no"
msgstr ""

#: ../../../filesystems/locking.rst:42 ../../../filesystems/locking.rst:53
msgid "yes (ref-walk)"
msgstr ""

#: ../../../filesystems/locking.rst:42 ../../../filesystems/locking.rst:44
#: ../../../filesystems/locking.rst:45 ../../../filesystems/locking.rst:53
#: ../../../filesystems/locking.rst:284 ../../../filesystems/locking.rst:386
msgid "maybe"
msgstr ""

#: ../../../filesystems/locking.rst:43
msgid "d_weak_revalidate:"
msgstr ""

#: ../../../filesystems/locking.rst:43 ../../../filesystems/locking.rst:45
#: ../../../filesystems/locking.rst:46 ../../../filesystems/locking.rst:47
#: ../../../filesystems/locking.rst:48 ../../../filesystems/locking.rst:49
#: ../../../filesystems/locking.rst:50 ../../../filesystems/locking.rst:52
#: ../../../filesystems/locking.rst:54 ../../../filesystems/locking.rst:55
#: ../../../filesystems/locking.rst:56 ../../../filesystems/locking.rst:238
#: ../../../filesystems/locking.rst:239 ../../../filesystems/locking.rst:289
#: ../../../filesystems/locking.rst:290 ../../../filesystems/locking.rst:291
#: ../../../filesystems/locking.rst:294 ../../../filesystems/locking.rst:295
#: ../../../filesystems/locking.rst:296 ../../../filesystems/locking.rst:385
#: ../../../filesystems/locking.rst:412 ../../../filesystems/locking.rst:414
#: ../../../filesystems/locking.rst:415 ../../../filesystems/locking.rst:416
#: ../../../filesystems/locking.rst:417 ../../../filesystems/locking.rst:418
#: ../../../filesystems/locking.rst:419 ../../../filesystems/locking.rst:455
#: ../../../filesystems/locking.rst:456 ../../../filesystems/locking.rst:580
#: ../../../filesystems/locking.rst:581 ../../../filesystems/locking.rst:582
#: ../../../filesystems/locking.rst:584
msgid "yes"
msgstr ""

#: ../../../filesystems/locking.rst:44
msgid "d_hash"
msgstr ""

#: ../../../filesystems/locking.rst:45
msgid "d_compare:"
msgstr ""

#: ../../../filesystems/locking.rst:46
msgid "d_delete:"
msgstr ""

#: ../../../filesystems/locking.rst:47
msgid "d_init:"
msgstr ""

#: ../../../filesystems/locking.rst:48
msgid "d_release:"
msgstr ""

#: ../../../filesystems/locking.rst:49
msgid "d_prune:"
msgstr ""

#: ../../../filesystems/locking.rst:50
msgid "d_iput:"
msgstr ""

#: ../../../filesystems/locking.rst:51
msgid "d_dname:"
msgstr ""

#: ../../../filesystems/locking.rst:52
msgid "d_automount:"
msgstr ""

#: ../../../filesystems/locking.rst:53
msgid "d_manage:"
msgstr ""

#: ../../../filesystems/locking.rst:54
msgid "d_real"
msgstr ""

#: ../../../filesystems/locking.rst:55
msgid "d_unalias_trylock"
msgstr ""

#: ../../../filesystems/locking.rst:56
msgid "d_unalias_unlock"
msgstr ""

#: ../../../filesystems/locking.rst:60
msgid "inode_operations"
msgstr ""

#: ../../../filesystems/locking.rst:96 ../../../filesystems/locking.rst:153
msgid "all may block"
msgstr ""

#: ../../../filesystems/locking.rst:99 ../../../filesystems/locking.rst:156
msgid "i_rwsem(inode)"
msgstr ""

#: ../../../filesystems/locking.rst:101
msgid "lookup:"
msgstr ""

#: ../../../filesystems/locking.rst:101 ../../../filesystems/locking.rst:282
#: ../../../filesystems/locking.rst:285
msgid "shared"
msgstr ""

#: ../../../filesystems/locking.rst:102
msgid "create:"
msgstr ""

#: ../../../filesystems/locking.rst:102 ../../../filesystems/locking.rst:104
#: ../../../filesystems/locking.rst:105 ../../../filesystems/locking.rst:106
#: ../../../filesystems/locking.rst:112 ../../../filesystems/locking.rst:123
#: ../../../filesystems/locking.rst:160 ../../../filesystems/locking.rst:286
#: ../../../filesystems/locking.rst:287 ../../../filesystems/locking.rst:289
msgid "exclusive"
msgstr ""

#: ../../../filesystems/locking.rst:103
msgid "link:"
msgstr ""

#: ../../../filesystems/locking.rst:103 ../../../filesystems/locking.rst:107
msgid "exclusive (both)"
msgstr ""

#: ../../../filesystems/locking.rst:104
msgid "mknod:"
msgstr ""

#: ../../../filesystems/locking.rst:105
msgid "symlink:"
msgstr ""

#: ../../../filesystems/locking.rst:106
msgid "mkdir:"
msgstr ""

#: ../../../filesystems/locking.rst:107
msgid "unlink:"
msgstr ""

#: ../../../filesystems/locking.rst:108
msgid "rmdir:"
msgstr ""

#: ../../../filesystems/locking.rst:108
msgid "exclusive (both)(see below)"
msgstr ""

#: ../../../filesystems/locking.rst:109
msgid "rename:"
msgstr ""

#: ../../../filesystems/locking.rst:109
msgid "exclusive (both parents, some children) (see below)"
msgstr ""

#: ../../../filesystems/locking.rst:110
msgid "readlink:"
msgstr ""

#: ../../../filesystems/locking.rst:111
msgid "get_link:"
msgstr ""

#: ../../../filesystems/locking.rst:112
msgid "setattr:"
msgstr ""

#: ../../../filesystems/locking.rst:113
msgid "permission:"
msgstr ""

#: ../../../filesystems/locking.rst:113
msgid "no (may not block if called in rcu-walk mode)"
msgstr ""

#: ../../../filesystems/locking.rst:114
msgid "get_inode_acl:"
msgstr ""

#: ../../../filesystems/locking.rst:115
msgid "get_acl:"
msgstr ""

#: ../../../filesystems/locking.rst:116
msgid "getattr:"
msgstr ""

#: ../../../filesystems/locking.rst:117
msgid "listxattr:"
msgstr ""

#: ../../../filesystems/locking.rst:118
msgid "fiemap:"
msgstr ""

#: ../../../filesystems/locking.rst:119
msgid "update_time:"
msgstr ""

#: ../../../filesystems/locking.rst:120
msgid "atomic_open:"
msgstr ""

#: ../../../filesystems/locking.rst:120
msgid "shared (exclusive if O_CREAT is set in open flags)"
msgstr ""

#: ../../../filesystems/locking.rst:121
msgid "tmpfile:"
msgstr ""

#: ../../../filesystems/locking.rst:122
msgid "fileattr_get:"
msgstr ""

#: ../../../filesystems/locking.rst:122
msgid "no or exclusive"
msgstr ""

#: ../../../filesystems/locking.rst:123
msgid "fileattr_set:"
msgstr ""

#: ../../../filesystems/locking.rst:124
msgid "get_offset_ctx"
msgstr ""

#: ../../../filesystems/locking.rst:128
msgid ""
"Additionally, ->rmdir(), ->unlink() and ->rename() have ->i_rwsem exclusive "
"on victim. cross-directory ->rename() has (per-superblock) -"
">s_vfs_rename_sem. ->unlink() and ->rename() have ->i_rwsem exclusive on all "
"non-directories involved. ->rename() has ->i_rwsem exclusive on any "
"subdirectory that changes parent."
msgstr ""

#: ../../../filesystems/locking.rst:135
msgid ""
"See Documentation/filesystems/directory-locking.rst for more detailed "
"discussion of the locking scheme for directory operations."
msgstr ""

#: ../../../filesystems/locking.rst:139
msgid "xattr_handler operations"
msgstr ""

#: ../../../filesystems/locking.rst:158
msgid "list:"
msgstr ""

#: ../../../filesystems/locking.rst:159
msgid "get:"
msgstr ""

#: ../../../filesystems/locking.rst:160
msgid "set:"
msgstr ""

#: ../../../filesystems/locking.rst:164
msgid "super_operations"
msgstr ""

#: ../../../filesystems/locking.rst:187
msgid "All may block [not true, see below]"
msgstr ""

#: ../../../filesystems/locking.rst:190
msgid "s_umount"
msgstr ""

#: ../../../filesystems/locking.rst:190
msgid "note"
msgstr ""

#: ../../../filesystems/locking.rst:192
msgid "alloc_inode:"
msgstr ""

#: ../../../filesystems/locking.rst:193
msgid "free_inode:"
msgstr ""

#: ../../../filesystems/locking.rst:193
msgid "called from RCU callback"
msgstr ""

#: ../../../filesystems/locking.rst:194
msgid "destroy_inode:"
msgstr ""

#: ../../../filesystems/locking.rst:195
msgid "dirty_inode:"
msgstr ""

#: ../../../filesystems/locking.rst:196
msgid "write_inode:"
msgstr ""

#: ../../../filesystems/locking.rst:197
msgid "drop_inode:"
msgstr ""

#: ../../../filesystems/locking.rst:197
msgid "!!!inode->i_lock!!!"
msgstr ""

#: ../../../filesystems/locking.rst:198
msgid "evict_inode:"
msgstr ""

#: ../../../filesystems/locking.rst:199
msgid "put_super:"
msgstr ""

#: ../../../filesystems/locking.rst:199 ../../../filesystems/locking.rst:201
#: ../../../filesystems/locking.rst:202 ../../../filesystems/locking.rst:204
#: ../../../filesystems/locking.rst:611
msgid "write"
msgstr ""

#: ../../../filesystems/locking.rst:200
msgid "sync_fs:"
msgstr ""

#: ../../../filesystems/locking.rst:200 ../../../filesystems/locking.rst:613
#: ../../../filesystems/locking.rst:616 ../../../filesystems/locking.rst:617
#: ../../../filesystems/locking.rst:618
msgid "read"
msgstr ""

#: ../../../filesystems/locking.rst:201
msgid "freeze_fs:"
msgstr ""

#: ../../../filesystems/locking.rst:202
msgid "unfreeze_fs:"
msgstr ""

#: ../../../filesystems/locking.rst:203
msgid "statfs:"
msgstr ""

#: ../../../filesystems/locking.rst:203
msgid "maybe(read)"
msgstr ""

#: ../../../filesystems/locking.rst:203 ../../../filesystems/locking.rst:207
#: ../../../filesystems/locking.rst:208
msgid "(see below)"
msgstr ""

#: ../../../filesystems/locking.rst:204
msgid "remount_fs:"
msgstr ""

#: ../../../filesystems/locking.rst:205
msgid "umount_begin:"
msgstr ""

#: ../../../filesystems/locking.rst:206
msgid "show_options:"
msgstr ""

#: ../../../filesystems/locking.rst:206
msgid "(namespace_sem)"
msgstr ""

#: ../../../filesystems/locking.rst:207
msgid "quota_read:"
msgstr ""

#: ../../../filesystems/locking.rst:208
msgid "quota_write:"
msgstr ""

#: ../../../filesystems/locking.rst:211
msgid ""
"->statfs() has s_umount (shared) when called by ustat(2) (native or compat), "
"but that's an accident of bad API; s_umount is used to pin the superblock "
"down when we only have dev_t given us by userland to identify the "
"superblock.  Everything else (statfs(), fstatfs(), etc.) doesn't hold it "
"when calling ->statfs() - superblock is pinned down by resolving the "
"pathname passed to syscall."
msgstr ""

#: ../../../filesystems/locking.rst:218
msgid ""
"->quota_read() and ->quota_write() functions are both guaranteed to be the "
"only ones operating on the quota file by the quota code (via dqio_sem) "
"(unless an admin really wants to screw up something and writes to quota "
"files with quotas on). For other details about locking see also "
"dquot_operations section."
msgstr ""

#: ../../../filesystems/locking.rst:225
msgid "file_system_type"
msgstr ""

#: ../../../filesystems/locking.rst:238
msgid "mount"
msgstr ""

#: ../../../filesystems/locking.rst:239
msgid "kill_sb"
msgstr ""

#: ../../../filesystems/locking.rst:242
msgid ""
"->mount() returns ERR_PTR or the root dentry; its superblock should be "
"locked on return."
msgstr ""

#: ../../../filesystems/locking.rst:245
msgid ""
"->kill_sb() takes a write-locked superblock, does all shutdown work on it, "
"unlocks and drops the reference."
msgstr ""

#: ../../../filesystems/locking.rst:249
msgid "address_space_operations"
msgstr ""

#: ../../../filesystems/locking.rst:277
msgid "All except dirty_folio and free_folio may block"
msgstr ""

#: ../../../filesystems/locking.rst:280
msgid "folio locked"
msgstr ""

#: ../../../filesystems/locking.rst:280
msgid "i_rwsem"
msgstr ""

#: ../../../filesystems/locking.rst:280
msgid "invalidate_lock"
msgstr ""

#: ../../../filesystems/locking.rst:282
msgid "read_folio:"
msgstr ""

#: ../../../filesystems/locking.rst:282 ../../../filesystems/locking.rst:285
#: ../../../filesystems/locking.rst:287 ../../../filesystems/locking.rst:299
msgid "yes, unlocks"
msgstr ""

#: ../../../filesystems/locking.rst:283
msgid "writepages:"
msgstr ""

#: ../../../filesystems/locking.rst:284
msgid "dirty_folio:"
msgstr ""

#: ../../../filesystems/locking.rst:285
msgid "readahead:"
msgstr ""

#: ../../../filesystems/locking.rst:286
msgid "write_begin:"
msgstr ""

#: ../../../filesystems/locking.rst:286
msgid "locks the folio"
msgstr ""

#: ../../../filesystems/locking.rst:287
msgid "write_end:"
msgstr ""

#: ../../../filesystems/locking.rst:288
msgid "bmap:"
msgstr ""

#: ../../../filesystems/locking.rst:289
msgid "invalidate_folio:"
msgstr ""

#: ../../../filesystems/locking.rst:290
msgid "release_folio:"
msgstr ""

#: ../../../filesystems/locking.rst:291
msgid "free_folio:"
msgstr ""

#: ../../../filesystems/locking.rst:292
msgid "direct_IO:"
msgstr ""

#: ../../../filesystems/locking.rst:293
msgid "migrate_folio:"
msgstr ""

#: ../../../filesystems/locking.rst:293
msgid "yes (both)"
msgstr ""

#: ../../../filesystems/locking.rst:294
msgid "launder_folio:"
msgstr ""

#: ../../../filesystems/locking.rst:295
msgid "is_partially_uptodate:"
msgstr ""

#: ../../../filesystems/locking.rst:296
msgid "error_remove_folio:"
msgstr ""

#: ../../../filesystems/locking.rst:297
msgid "swap_activate:"
msgstr ""

#: ../../../filesystems/locking.rst:298
msgid "swap_deactivate:"
msgstr ""

#: ../../../filesystems/locking.rst:299
msgid "swap_rw:"
msgstr ""

#: ../../../filesystems/locking.rst:302
msgid ""
"->write_begin(), ->write_end() and ->read_folio() may be called from the "
"request handler (/dev/loop)."
msgstr ""

#: ../../../filesystems/locking.rst:305
msgid ""
"->read_folio() unlocks the folio, either synchronously or via I/O completion."
msgstr ""

#: ../../../filesystems/locking.rst:308
msgid ""
"->readahead() unlocks the folios that I/O is attempted on like -"
">read_folio()."
msgstr ""

#: ../../../filesystems/locking.rst:310
msgid ""
"->writepages() is used for periodic writeback and for syscall-initiated sync "
"operations.  The address_space should start I/O against at least "
"``*nr_to_write`` pages.  ``*nr_to_write`` must be decremented for each page "
"which is written.  The address_space implementation may write more (or less) "
"pages than ``*nr_to_write`` asks for, but it should try to be reasonably "
"close. If nr_to_write is NULL, all dirty pages must be written."
msgstr ""

#: ../../../filesystems/locking.rst:317
msgid ""
"writepages should _only_ write pages which are present in mapping->i_pages."
msgstr ""

#: ../../../filesystems/locking.rst:320
msgid ""
"->dirty_folio() is called from various places in the kernel when the target "
"folio is marked as needing writeback.  The folio cannot be truncated because "
"either the caller holds the folio lock, or the caller has found the folio "
"while holding the page table lock which will block truncation."
msgstr ""

#: ../../../filesystems/locking.rst:326
msgid ""
"->bmap() is currently used by legacy ioctl() (FIBMAP) provided by some "
"filesystems and by the swapper. The latter will eventually go away.  Please, "
"keep it that way and don't breed new callers."
msgstr ""

#: ../../../filesystems/locking.rst:330
msgid ""
"->invalidate_folio() is called when the filesystem must attempt to drop some "
"or all of the buffers from the page when it is being truncated. It returns "
"zero on success.  The filesystem must exclusively acquire invalidate_lock "
"before invalidating page cache in truncate / hole punch path (and thus "
"calling into ->invalidate_folio) to block races between page cache "
"invalidation and page cache filling functions (fault, read, ...)."
msgstr ""

#: ../../../filesystems/locking.rst:337
msgid ""
"->release_folio() is called when the MM wants to make a change to the folio "
"that would invalidate the filesystem's private data.  For example, it may be "
"about to be removed from the address_space or split.  The folio is locked "
"and not under writeback.  It may be dirty.  The gfp parameter is not usually "
"used for allocation, but rather to indicate what the filesystem may do to "
"attempt to free the private data.  The filesystem may return false to "
"indicate that the folio's private data cannot be freed. If it returns true, "
"it should have already removed the private data from the folio.  If a "
"filesystem does not provide a ->release_folio method, the pagecache will "
"assume that private data is buffer_heads and call try_to_free_buffers()."
msgstr ""

#: ../../../filesystems/locking.rst:349
msgid ""
"->free_folio() is called when the kernel has dropped the folio from the page "
"cache."
msgstr ""

#: ../../../filesystems/locking.rst:352
msgid ""
"->launder_folio() may be called prior to releasing a folio if it is still "
"found to be dirty. It returns zero if the folio was successfully cleaned, or "
"an error value if not. Note that in order to prevent the folio getting "
"mapped back in and redirtied, it needs to be kept locked across the entire "
"operation."
msgstr ""

#: ../../../filesystems/locking.rst:358
msgid ""
"->swap_activate() will be called to prepare the given file for swap.  It "
"should perform any validation and preparation necessary to ensure that "
"writes can be performed with minimal memory allocation.  It should call "
"add_swap_extent(), or the helper iomap_swapfile_activate(), and return the "
"number of extents added.  If IO should be submitted through ->swap_rw(), it "
"should set SWP_FS_OPS, otherwise IO will be submitted directly to the block "
"device ``sis->bdev``."
msgstr ""

#: ../../../filesystems/locking.rst:366
msgid ""
"->swap_deactivate() will be called in the sys_swapoff() path after -"
">swap_activate() returned success."
msgstr ""

#: ../../../filesystems/locking.rst:369
msgid ""
"->swap_rw will be called for swap IO if SWP_FS_OPS was set by -"
">swap_activate()."
msgstr ""

#: ../../../filesystems/locking.rst:372
msgid "file_lock_operations"
msgstr ""

#: ../../../filesystems/locking.rst:383
msgid "inode->i_lock"
msgstr ""

#: ../../../filesystems/locking.rst:385
msgid "fl_copy_lock:"
msgstr ""

#: ../../../filesystems/locking.rst:386
msgid "fl_release_private:"
msgstr ""

#: ../../../filesystems/locking.rst:386
msgid "maybe[1]_"
msgstr ""

#: ../../../filesystems/locking.rst:395
msgid "lock_manager_operations"
msgstr ""

#: ../../../filesystems/locking.rst:410
msgid "flc_lock"
msgstr ""

#: ../../../filesystems/locking.rst:410
msgid "blocked_lock_lock"
msgstr ""

#: ../../../filesystems/locking.rst:412
msgid "lm_notify:"
msgstr ""

#: ../../../filesystems/locking.rst:413
msgid "lm_grant:"
msgstr ""

#: ../../../filesystems/locking.rst:414
msgid "lm_break:"
msgstr ""

#: ../../../filesystems/locking.rst:415
msgid "lm_change"
msgstr ""

#: ../../../filesystems/locking.rst:416
msgid "lm_breaker_owns_lease:"
msgstr ""

#: ../../../filesystems/locking.rst:417
msgid "lm_lock_expirable"
msgstr ""

#: ../../../filesystems/locking.rst:418
msgid "lm_expire_lock"
msgstr ""

#: ../../../filesystems/locking.rst:419
msgid "lm_open_conflict"
msgstr ""

#: ../../../filesystems/locking.rst:423
msgid "buffer_head"
msgstr ""

#: ../../../filesystems/locking.rst:431
msgid ""
"called from interrupts. In other words, extreme care is needed here. bh is "
"locked, but that's all warranties we have here. Currently only RAID1, "
"highmem, fs/buffer.c, and fs/ntfs/aops.c are providing these. Block devices "
"call this method upon the IO completion."
msgstr ""

#: ../../../filesystems/locking.rst:437
msgid "block_device_operations"
msgstr ""

#: ../../../filesystems/locking.rst:453
msgid "open_mutex"
msgstr ""

#: ../../../filesystems/locking.rst:455 ../../../filesystems/locking.rst:611
msgid "open:"
msgstr ""

#: ../../../filesystems/locking.rst:456
msgid "release:"
msgstr ""

#: ../../../filesystems/locking.rst:457
msgid "ioctl:"
msgstr ""

#: ../../../filesystems/locking.rst:458
msgid "compat_ioctl:"
msgstr ""

#: ../../../filesystems/locking.rst:459
msgid "direct_access:"
msgstr ""

#: ../../../filesystems/locking.rst:460
msgid "unlock_native_capacity:"
msgstr ""

#: ../../../filesystems/locking.rst:461
msgid "getgeo:"
msgstr ""

#: ../../../filesystems/locking.rst:462
msgid "swap_slot_free_notify:"
msgstr ""

#: ../../../filesystems/locking.rst:462
msgid "no      (see below)"
msgstr ""

#: ../../../filesystems/locking.rst:465
msgid ""
"swap_slot_free_notify is called with swap_lock and sometimes the page lock "
"held."
msgstr ""

#: ../../../filesystems/locking.rst:470
msgid "file_operations"
msgstr ""

#: ../../../filesystems/locking.rst:511
msgid "All may block."
msgstr ""

#: ../../../filesystems/locking.rst:513
msgid ""
"->llseek() locking has moved from llseek to the individual llseek "
"implementations.  If your fs is not using generic_file_llseek, you need to "
"acquire and release the appropriate locks in your ->llseek(). For many "
"filesystems, it is probably safe to acquire the inode mutex or just to use "
"i_size_read() instead. Note: this does not protect the file->f_pos against "
"concurrent modifications since this is something the userspace has to take "
"care about."
msgstr ""

#: ../../../filesystems/locking.rst:521
msgid ""
"->iterate_shared() is called with i_rwsem held for reading, and with the "
"file f_pos_lock held exclusively"
msgstr ""

#: ../../../filesystems/locking.rst:524
msgid ""
"->fasync() is responsible for maintaining the FASYNC bit in filp->f_flags. "
"Most instances call fasync_helper(), which does that maintenance, so it's "
"not normally something one needs to worry about.  Return values > 0 will be "
"mapped to zero in the VFS layer."
msgstr ""

#: ../../../filesystems/locking.rst:529
msgid ""
"->readdir() and ->ioctl() on directories must be changed. Ideally we would "
"move ->readdir() to inode_operations and use a separate method for directory "
"->ioctl() or kill the latter completely. One of the problems is that for "
"anything that resembles union-mount we won't have a struct file for all "
"components. And there are other reasons why the current interface is a "
"mess..."
msgstr ""

#: ../../../filesystems/locking.rst:535
msgid ""
"->read on directories probably must go away - we should just enforce -EISDIR "
"in sys_read() and friends."
msgstr ""

#: ../../../filesystems/locking.rst:538
msgid ""
"->setlease operations should call generic_setlease() before or after setting "
"the lease within the individual filesystem to record the result of the "
"operation"
msgstr ""

#: ../../../filesystems/locking.rst:542
msgid ""
"->fallocate implementation must be really careful to maintain page cache "
"consistency when punching holes or performing other operations that "
"invalidate page cache contents. Usually the filesystem needs to call "
"truncate_inode_pages_range() to invalidate relevant range of the page cache. "
"However the filesystem usually also needs to update its internal (and on "
"disk) view of file offset -> disk block mapping. Until this update is "
"finished, the filesystem needs to block page faults and reads from reloading "
"now-stale page cache contents from the disk. Since VFS acquires mapping-"
">invalidate_lock in shared mode when loading pages from disk "
"(filemap_fault(), filemap_read(), readahead paths), the fallocate "
"implementation must take the invalidate_lock to prevent reloading."
msgstr ""

#: ../../../filesystems/locking.rst:554
msgid ""
"->copy_file_range and ->remap_file_range implementations need to serialize "
"against modifications of file data while the operation is running. For "
"blocking changes through write(2) and similar operations inode->i_rwsem can "
"be used. To block changes to file contents via a memory mapping during the "
"operation, the filesystem must take mapping->invalidate_lock to coordinate "
"with ->page_mkwrite."
msgstr ""

#: ../../../filesystems/locking.rst:562
msgid "dquot_operations"
msgstr ""

#: ../../../filesystems/locking.rst:572
msgid ""
"These operations are intended to be more or less wrapping functions that "
"ensure a proper locking wrt the filesystem and call the generic quota "
"operations."
msgstr ""

#: ../../../filesystems/locking.rst:575
msgid "What filesystem should expect from the generic quota functions:"
msgstr ""

#: ../../../filesystems/locking.rst:578
msgid "FS recursion"
msgstr ""

#: ../../../filesystems/locking.rst:578
msgid "Held locks when called"
msgstr ""

#: ../../../filesystems/locking.rst:580
msgid "write_dquot:"
msgstr ""

#: ../../../filesystems/locking.rst:580 ../../../filesystems/locking.rst:581
#: ../../../filesystems/locking.rst:582
msgid "dqonoff_sem or dqptr_sem"
msgstr ""

#: ../../../filesystems/locking.rst:581
msgid "acquire_dquot:"
msgstr ""

#: ../../../filesystems/locking.rst:582
msgid "release_dquot:"
msgstr ""

#: ../../../filesystems/locking.rst:583
msgid "mark_dirty:"
msgstr ""

#: ../../../filesystems/locking.rst:584
msgid "write_info:"
msgstr ""

#: ../../../filesystems/locking.rst:584
msgid "dqonoff_sem"
msgstr ""

#: ../../../filesystems/locking.rst:587
msgid ""
"FS recursion means calling ->quota_read() and ->quota_write() from "
"superblock operations."
msgstr ""

#: ../../../filesystems/locking.rst:590
msgid "More details about quota locking can be found in fs/dquot.c."
msgstr ""

#: ../../../filesystems/locking.rst:593
msgid "vm_operations_struct"
msgstr ""

#: ../../../filesystems/locking.rst:609
msgid "mmap_lock"
msgstr ""

#: ../../../filesystems/locking.rst:609
msgid "PageLocked(page)"
msgstr ""

#: ../../../filesystems/locking.rst:612
msgid "close:"
msgstr ""

#: ../../../filesystems/locking.rst:612
msgid "read/write"
msgstr ""

#: ../../../filesystems/locking.rst:613
msgid "fault:"
msgstr ""

#: ../../../filesystems/locking.rst:613 ../../../filesystems/locking.rst:616
msgid "can return with page locked"
msgstr ""

#: ../../../filesystems/locking.rst:614
msgid "huge_fault:"
msgstr ""

#: ../../../filesystems/locking.rst:614 ../../../filesystems/locking.rst:615
msgid "maybe-read"
msgstr ""

#: ../../../filesystems/locking.rst:615
msgid "map_pages:"
msgstr ""

#: ../../../filesystems/locking.rst:616
msgid "page_mkwrite:"
msgstr ""

#: ../../../filesystems/locking.rst:617
msgid "pfn_mkwrite:"
msgstr ""

#: ../../../filesystems/locking.rst:618
msgid "access:"
msgstr ""

#: ../../../filesystems/locking.rst:621
msgid ""
"->fault() is called when a previously not present pte is about to be faulted "
"in. The filesystem must find and return the page associated with the passed "
"in \"pgoff\" in the vm_fault structure. If it is possible that the page may "
"be truncated and/or invalidated, then the filesystem must lock "
"invalidate_lock, then ensure the page is not already truncated "
"(invalidate_lock will block subsequent truncate), and then return with "
"VM_FAULT_LOCKED, and the page locked. The VM will unlock the page."
msgstr ""

#: ../../../filesystems/locking.rst:629
msgid ""
"->huge_fault() is called when there is no PUD or PMD entry present.  This "
"gives the filesystem the opportunity to install a PUD or PMD sized page. "
"Filesystems can also use the ->fault method to return a PMD sized page, so "
"implementing this function may not be necessary.  In particular, filesystems "
"should not call filemap_fault() from ->huge_fault(). The mmap_lock may not "
"be held when this method is called."
msgstr ""

#: ../../../filesystems/locking.rst:636
msgid ""
"->map_pages() is called when VM asks to map easy accessible pages. "
"Filesystem should find and map pages associated with offsets from "
"\"start_pgoff\" till \"end_pgoff\". ->map_pages() is called with the RCU "
"lock held and must not block.  If it's not possible to reach a page without "
"blocking, filesystem should skip it. Filesystem should use set_pte_range() "
"to setup page table entry. Pointer to entry associated with the page is "
"passed in \"pte\" field in vm_fault structure. Pointers to entries for other "
"offsets should be calculated relative to \"pte\"."
msgstr ""

#: ../../../filesystems/locking.rst:645
msgid ""
"->page_mkwrite() is called when a previously read-only pte is about to "
"become writeable. The filesystem again must ensure that there are no "
"truncate/invalidate races or races with operations such as -"
">remap_file_range or ->copy_file_range, and then return with the page "
"locked. Usually mapping->invalidate_lock is suitable for proper "
"serialization. If the page has been truncated, the filesystem should not "
"look up a new page like the ->fault() handler, but simply return with "
"VM_FAULT_NOPAGE, which will cause the VM to retry the fault."
msgstr ""

#: ../../../filesystems/locking.rst:654
msgid ""
"->pfn_mkwrite() is the same as page_mkwrite but when the pte is VM_PFNMAP or "
"VM_MIXEDMAP with a page-less entry. Expected return is VM_FAULT_NOPAGE. Or "
"one of the VM_FAULT_ERROR types. The default behavior after this call is to "
"make the pte read-write, unless pfn_mkwrite returns an error."
msgstr ""

#: ../../../filesystems/locking.rst:660
msgid ""
"->access() is called when get_user_pages() fails in access_process_vm(), "
"typically used to debug a process through /proc/pid/mem or ptrace.  This "
"function is needed only for VM_IO | VM_PFNMAP VMAs."
msgstr ""

#: ../../../filesystems/locking.rst:667
msgid "Dubious stuff"
msgstr ""

#: ../../../filesystems/locking.rst:669
msgid ""
"(if you break something or notice that it is broken and do not fix it "
"yourself - at least put it here)"
msgstr ""
