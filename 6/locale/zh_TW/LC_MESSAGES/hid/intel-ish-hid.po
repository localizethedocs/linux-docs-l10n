# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../hid/intel-ish-hid.rst:3
msgid "Intel Integrated Sensor Hub (ISH)"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:5
msgid ""
"A sensor hub enables the ability to offload sensor polling and algorithm "
"processing to a dedicated low power co-processor. This allows the core "
"processor to go into low power modes more often, resulting in increased "
"battery life."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:10
msgid ""
"There are many vendors providing external sensor hubs conforming to HID "
"Sensor usage tables. These may be found in tablets, 2-in-1 convertible "
"laptops and embedded products. Linux has had this support since Linux 3.9."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:14
msgid ""
"IntelÂ® introduced integrated sensor hubs as a part of the SoC starting from "
"Cherry Trail and now supported on multiple generations of CPU packages. "
"There are many commercial devices already shipped with Integrated Sensor "
"Hubs (ISH). These ISH also comply to HID sensor specification, but the "
"difference is the transport protocol used for communication. The current "
"external sensor hubs mainly use HID over I2C or USB. But ISH doesn't use "
"either I2C or USB."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:22
msgid "Overview"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:24
msgid ""
"Using a analogy with a usbhid implementation, the ISH follows a similar "
"model for a very high speed communication::"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:45
msgid ""
"Like USB protocol provides a method for device enumeration, link management "
"and user data encapsulation, the ISH also provides similar services. But it "
"is very light weight tailored to manage and communicate with ISH client "
"applications implemented in the firmware."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:50
msgid ""
"The ISH allows multiple sensor management applications executing in the "
"firmware. Like USB endpoints the messaging can be to/from a client. As part "
"of enumeration process, these clients are identified. These clients can be "
"simple HID sensor applications, sensor calibration applications or sensor "
"firmware update applications."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:56
msgid ""
"The implementation model is similar, like USB bus, ISH transport is also "
"implemented as a bus. Each client application executing in the ISH processor "
"is registered as a device on this bus. The driver, which binds each device "
"(ISH HID driver) identifies the device type and registers with the HID core."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:62
msgid "ISH Implementation: Block Diagram"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:100
msgid "High level processing in above blocks"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:103
msgid "Hardware Interface"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:105
msgid ""
"The ISH is exposed as \"Non-VGA unclassified PCI device\" to the host. The "
"PCI product and vendor IDs are changed from different generations of "
"processors. So the source code which enumerates drivers needs to update from "
"generation to generation."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:111
msgid "Inter Processor Communication (IPC) driver"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:113
msgid "Location: drivers/hid/intel-ish-hid/ipc"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:115
msgid ""
"The IPC message uses memory mapped I/O. The registers are defined in hw-ish-"
"regs.h."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:119
msgid "IPC/FW message types"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:121
msgid ""
"There are two types of messages, one for management of link and another for "
"messages to and from transport layers."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:125
msgid "TX and RX of Transport messages"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:127
msgid ""
"A set of memory mapped register offers support of multi-byte messages TX and "
"RX (e.g. IPC_REG_ISH2HOST_MSG, IPC_REG_HOST2ISH_MSG). The IPC layer "
"maintains internal queues to sequence messages and send them in order to the "
"firmware. Optionally the caller can register handler to get notification of "
"completion. A doorbell mechanism is used in messaging to trigger processing "
"in host and client firmware side. When ISH interrupt handler is called, the "
"ISH2HOST doorbell register is used by host drivers to determine that the "
"interrupt is for ISH."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:136
msgid ""
"Each side has 32 32-bit message registers and a 32-bit doorbell. Doorbell "
"register has the following format::"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:146
msgid "Transport layer interface"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:148
msgid ""
"To abstract HW level IPC communication, a set of callbacks is registered. "
"The transport layer uses them to send and receive messages. Refer to struct "
"ishtp_hw_ops for callbacks."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:153
msgid "ISH Transport layer"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:155
msgid "Location: drivers/hid/intel-ish-hid/ishtp/"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:158
msgid "A Generic Transport Layer"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:160
msgid ""
"The transport layer is a bi-directional protocol, which defines: - Set of "
"commands to start, stop, connect, disconnect and flow control (see ishtp/hbm."
"h for details) - A flow control mechanism to avoid buffer overflows"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:165
msgid ""
"This protocol resembles bus messages described in the following document: "
"http://www.intel.com/content/dam/www/public/us/en/documents/technical-\\ "
"specifications/dcmi-hi-1-0-spec.pdf \"Chapter 7: Bus Message Layer\""
msgstr ""

#: ../../../hid/intel-ish-hid.rst:170
msgid "Connection and Flow Control Mechanism"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:172
msgid ""
"Each FW client and a protocol is identified by a UUID. In order to "
"communicate to a FW client, a connection must be established using connect "
"request and response bus messages. If successful, a pair (host_client_id and "
"fw_client_id) will identify the connection."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:177
msgid ""
"Once connection is established, peers send each other flow control bus "
"messages independently. Every peer may send a message only if it has "
"received a flow-control credit before. Once it has sent a message, it may "
"not send another one before receiving the next flow control credit. Either "
"side can send disconnect request bus message to end communication. Also the "
"link will be dropped if major FW reset occurs."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:185
msgid "Peer to Peer data transfer"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:187
msgid ""
"Peer to Peer data transfer can happen with or without using DMA. Depending "
"on the sensor bandwidth requirement DMA can be enabled by using module "
"parameter ishtp_use_dma under intel_ishtp."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:191
msgid ""
"Each side (host and FW) manages its DMA transfer memory independently. When "
"an ISHTP client from either host or FW side wants to send something, it "
"decides whether to send over IPC or over DMA; for each transfer the decision "
"is independent. The sending side sends DMA_XFER message when the message is "
"in the respective host buffer (TX when host client sends, RX when FW client "
"sends). The recipient of DMA message responds with DMA_XFER_ACK, indicating "
"the sender that the memory region for that message may be reused."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:199
msgid ""
"DMA initialization is started with host sending DMA_ALLOC_NOTIFY bus message "
"(that includes RX buffer) and FW responds with DMA_ALLOC_NOTIFY_ACK. "
"Additionally to DMA address communication, this sequence checks "
"capabilities: if the host doesn't support DMA, then it won't send DMA "
"allocation, so FW can't send DMA; if FW doesn't support DMA then it won't "
"respond with DMA_ALLOC_NOTIFY_ACK, in which case host will not use DMA "
"transfers. Here ISH acts as busmaster DMA controller. Hence when host sends "
"DMA_XFER, it's request to do host->ISH DMA transfer; when FW sends DMA_XFER, "
"it means that it already did DMA and the message resides at host. Thus, "
"DMA_XFER and DMA_XFER_ACK act as ownership indicators."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:210
msgid ""
"At initial state all outgoing memory belongs to the sender (TX to host, RX "
"to FW), DMA_XFER transfers ownership on the region that contains ISHTP "
"message to the receiving side, DMA_XFER_ACK returns ownership to the sender. "
"A sender need not wait for previous DMA_XFER to be ack'ed, and may send "
"another message as long as remaining continuous memory in its ownership is "
"enough. In principle, multiple DMA_XFER and DMA_XFER_ACK messages may be "
"sent at once (up to IPC MTU), thus allowing for interrupt throttling. "
"Currently, ISH FW decides to send over DMA if ISHTP message is more than 3 "
"IPC fragments and via IPC otherwise."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:221
msgid "Ring Buffers"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:223
msgid ""
"When a client initiates a connection, a ring of RX and TX buffers is "
"allocated. The size of ring can be specified by the client. HID client sets "
"16 and 32 for TX and RX buffers respectively. On send request from client, "
"the data to be sent is copied to one of the send ring buffer and scheduled "
"to be sent using bus message protocol. These buffers are required because "
"the FW may have not have processed the last message and may not have enough "
"flow control credits to send. Same thing holds true on receive side and flow "
"control is required."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:232
msgid "Host Enumeration"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:234
msgid ""
"The host enumeration bus command allows discovery of clients present in the "
"FW. There can be multiple sensor clients and clients for calibration "
"function."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:237
msgid ""
"To ease implementation and allow independent drivers to handle each client, "
"this transport layer takes advantage of Linux Bus driver model. Each client "
"is registered as device on the transport bus (ishtp bus)."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:241
msgid "Enumeration sequence of messages:"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:243
msgid "Host sends HOST_START_REQ_CMD, indicating that host ISHTP layer is up."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:244
msgid "FW responds with HOST_START_RES_CMD"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:245
msgid "Host sends HOST_ENUM_REQ_CMD (enumerate FW clients)"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:246
msgid ""
"FW responds with HOST_ENUM_RES_CMD that includes bitmap of available FW "
"client IDs"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:248
msgid ""
"For each FW ID found in that bitmap host sends HOST_CLIENT_PROPERTIES_REQ_CMD"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:250
msgid ""
"FW responds with HOST_CLIENT_PROPERTIES_RES_CMD. Properties include UUID, "
"max ISHTP message size, etc."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:252
msgid ""
"Once host received properties for that last discovered client, it considers "
"ISHTP device fully functional (and allocates DMA buffers)"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:256
msgid "HID over ISH Client"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:258
msgid "Location: drivers/hid/intel-ish-hid"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:260
msgid "The ISHTP client driver is responsible for:"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:262
msgid "enumerate HID devices under FW ISH client"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:263
msgid "Get Report descriptor"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:264
msgid "Register with HID core as a LL driver"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:265
msgid "Process Get/Set feature request"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:266
msgid "Get input reports"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:269
msgid "HID Sensor Hub MFD and IIO sensor drivers"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:271
msgid ""
"The functionality in these drivers is the same as an external sensor hub. "
"Refer to Documentation/hid/hid-sensor.rst for HID sensor Documentation/ABI/"
"testing/sysfs-bus-iio for IIO ABIs to user space."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:277
msgid "End to End HID transport Sequence Diagram"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:343
msgid "ISH Firmware Loading from Host Flow"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:345
msgid ""
"Starting from the Lunar Lake generation, the ISH firmware has been divided "
"into two components for better space optimization and increased flexibility. "
"These components include a bootloader that is integrated into the BIOS, and "
"a main firmware that is stored within the operating system's file system."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:347
msgid "The process works as follows:"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:349
msgid ""
"Initially, the ISHTP driver sends a command, HOST_START_REQ_CMD, to the ISH "
"bootloader. In response, the bootloader sends back a HOST_START_RES_CMD. "
"This response includes the ISHTP_SUPPORT_CAP_LOADER bit. Subsequently, the "
"ISHTP driver checks if this bit is set. If it is, the firmware loading "
"process from the host begins."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:351
msgid ""
"During this process, the ISHTP driver first invokes the request_firmware() "
"function, followed by sending a LOADER_CMD_XFER_QUERY command. Upon "
"receiving a response from the bootloader, the ISHTP driver sends a "
"LOADER_CMD_XFER_FRAGMENT command. After receiving another response, the "
"ISHTP driver sends a LOADER_CMD_START command. The bootloader responds and "
"then proceeds to the Main Firmware."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:353
msgid ""
"After the process concludes, the ISHTP driver calls the release_firmware() "
"function."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:355
msgid ""
"For more detailed information, please refer to the flow descriptions "
"provided below:"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:408
msgid "Vendor Custom Firmware Loading"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:410
msgid ""
"The firmware running inside ISH can be provided by Intel or developed by "
"vendors using the Firmware Development Kit (FDK) provided by Intel. Intel "
"will upstream the Intel-built firmware to the ``linux-firmware.git`` "
"repository, located under the path ``intel/ish/``. For the Lunar Lake "
"platform, the Intel-built ISH firmware will be named ``ish_lnlm.bin``. "
"Vendors who wish to upstream their custom firmware should follow these "
"guidelines for naming their firmware files:"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:414
msgid "The firmware filename should use one of the following patterns:"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:416
msgid ""
"``ish_${intel_plat_gen}_${SYS_VENDOR_CRC32}_${PRODUCT_NAME_CRC32}"
"_${PRODUCT_SKU_CRC32}.bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:417
msgid "``ish_${intel_plat_gen}_${SYS_VENDOR_CRC32}_${PRODUCT_SKU_CRC32}.bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:418
msgid "``ish_${intel_plat_gen}_${SYS_VENDOR_CRC32}_${PRODUCT_NAME_CRC32}.bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:419
msgid "``ish_${intel_plat_gen}_${SYS_VENDOR_CRC32}.bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:421
msgid ""
"``${intel_plat_gen}`` indicates the Intel platform generation (e.g., "
"``lnlm`` for Lunar Lake) and must not exceed 8 characters in length."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:422
msgid ""
"``${SYS_VENDOR_CRC32}`` is the CRC32 checksum of the ``sys_vendor`` value "
"from the DMI field ``DMI_SYS_VENDOR``."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:423
msgid ""
"``${PRODUCT_NAME_CRC32}`` is the CRC32 checksum of the ``product_name`` "
"value from the DMI field ``DMI_PRODUCT_NAME``."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:424
msgid ""
"``${PRODUCT_SKU_CRC32}`` is the CRC32 checksum of the ``product_sku`` value "
"from the DMI field ``DMI_PRODUCT_SKU``."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:426
msgid ""
"During system boot, the ISH Linux driver will attempt to load the firmware "
"in the following order, prioritizing custom firmware with more precise "
"matching patterns:"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:428
msgid ""
"``intel/ish/ish_${intel_plat_gen}_${SYS_VENDOR_CRC32}_${PRODUCT_NAME_CRC32}"
"_${PRODUCT_SKU_CRC32}.bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:429
msgid ""
"``intel/ish/ish_${intel_plat_gen}_${SYS_VENDOR_CRC32}_${PRODUCT_SKU_CRC32}."
"bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:430
msgid ""
"``intel/ish/ish_${intel_plat_gen}_${SYS_VENDOR_CRC32}_${PRODUCT_NAME_CRC32}."
"bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:431
msgid "``intel/ish/ish_${intel_plat_gen}_${SYS_VENDOR_CRC32}.bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:432
msgid "``intel/ish/ish_${intel_plat_gen}.bin``"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:434
msgid ""
"The driver will load the first matching firmware and skip the rest. If no "
"matching firmware is found, it will proceed to the next pattern in the "
"specified order. If all searches fail, the default Intel firmware, listed "
"last in the order above, will be loaded."
msgstr ""

#: ../../../hid/intel-ish-hid.rst:437
msgid "ISH Debugging"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:439
msgid "To debug ISH, event tracing mechanism is used. To enable debug logs::"
msgstr ""

#: ../../../hid/intel-ish-hid.rst:445
msgid "ISH IIO sysfs Example on Lenovo thinkpad Yoga 260"
msgstr ""
