# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/timerlat-tracer.rst:3
msgid "Timerlat tracer"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:5
msgid ""
"The timerlat tracer aims to help the preemptive kernel developers to find "
"sources of wakeup latencies of real-time threads. Like cyclictest, the "
"tracer sets a periodic timer that wakes up a thread. The thread then "
"computes a *wakeup latency* value as the difference between the *current "
"time* and the *absolute time* that the timer was set to expire. The main "
"goal of timerlat is tracing in such a way to help kernel developers."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:13
msgid "Usage"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:15
msgid ""
"Write the ASCII text \"timerlat\" into the current_tracer file of the "
"tracing system (generally mounted at /sys/kernel/tracing)."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:18
msgid "For example::"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:23
msgid "It is possible to follow the trace by reading the trace file::"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:46
msgid ""
"The tracer creates a per-cpu kernel thread with real-time priority that "
"prints two lines at every activation. The first is the *timer latency* "
"observed at the *hardirq* context before the activation of the thread. The "
"second is the *timer latency* observed by the thread. The ACTIVATION ID "
"field serves to relate the *irq* execution to its respective *thread* "
"execution."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:53
msgid ""
"The *irq*/*thread* splitting is important to clarify in which context the "
"unexpected high value is coming from. The *irq* context can be delayed by "
"hardware-related actions, such as SMIs, NMIs, IRQs, or by thread masking "
"interrupts. Once the timer happens, the delay can also be influenced by "
"blocking caused by threads. For example, by postponing the scheduler "
"execution via preempt_disable(), scheduler execution, or masking interrupts. "
"Threads can also be delayed by the interference from other threads and IRQs."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:63
msgid "Tracer options"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:65
msgid ""
"The timerlat tracer is built on top of osnoise tracer. So its configuration "
"is also done in the osnoise/ config directory. The timerlat configs are:"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:69
msgid "cpus: CPUs at which a timerlat thread will execute."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:70
msgid "timerlat_period_us: the period of the timerlat thread."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:71
msgid ""
"stop_tracing_us: stop the system tracing if a timer latency at the *irq* "
"context higher than the configured value happens. Writing 0 disables this "
"option."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:74
msgid ""
"stop_tracing_total_us: stop the system tracing if a timer latency at the "
"*thread* context is higher than the configured value happens. Writing 0 "
"disables this option."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:77
msgid ""
"print_stack: save the stack of the IRQ occurrence. The stack is printed "
"after the *thread context* event, or at the IRQ handler if *stop_tracing_us* "
"is hit."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:82
msgid "timerlat and osnoise"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:84
msgid ""
"The timerlat can also take advantage of the osnoise: traceevents. For "
"example::"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:98
msgid ""
"In this case, the root cause of the timer latency does not point to a single "
"cause but to multiple ones. Firstly, the timer IRQ was delayed for 13 us, "
"which may point to a long IRQ disabled section (see IRQ stacktrace section). "
"Then the timer interrupt that wakes up the timerlat thread took 7597 ns, and "
"the qxl:21 device IRQ took 7139 ns. Finally, the cc1 thread noise took 9909 "
"ns of time before the context switch. Such pieces of evidence are useful for "
"the developer to use other tracing methods to figure out how to debug and "
"optimize the system."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:107
msgid ""
"It is worth mentioning that the *duration* values reported by the osnoise: "
"events are *net* values. For example, the thread_noise does not include the "
"duration of the overhead caused by the IRQ execution (which indeed accounted "
"for 12736 ns). But the values reported by the timerlat tracer "
"(timerlat_latency) are *gross* values."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:114
msgid ""
"The art below illustrates a CPU timeline and how the timerlat tracer "
"observes it at the top and the osnoise: events at the bottom. Each \"-\" in "
"the timelines means circa 1 us, and the time moves ==>::"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:138
msgid "IRQ stacktrace"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:140
msgid ""
"The osnoise/print_stack option is helpful for the cases in which a thread "
"noise causes the major factor for the timer latency, because of preempt or "
"irq disabled. For example::"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:170
msgid ""
"In this case, it is possible to see that the thread added the highest "
"contribution to the *timer latency* and the stack trace, saved during the "
"timerlat IRQ handler, points to a function named dummy_load_1ms_pd_init, "
"which had the following code (on purpose)::"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:185
msgid "User-space interface"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:187
msgid ""
"Timerlat allows user-space threads to use timerlat infra-structure to "
"measure scheduling latency. This interface is accessible via a per-CPU file "
"descriptor inside $tracing_dir/osnoise/per_cpu/cpu$ID/timerlat_fd."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:191
msgid "This interface is accessible under the following conditions:"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:193
msgid "timerlat tracer is enable"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:194
msgid "osnoise workload option is set to NO_OSNOISE_WORKLOAD"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:195
msgid "The user-space thread is affined to a single processor"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:196
msgid "The thread opens the file associated with its single processor"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:197
msgid "Only one thread can access the file at a time"
msgstr ""

#: ../../../trace/timerlat-tracer.rst:199
msgid ""
"The open() syscall will fail if any of these conditions are not met. After "
"opening the file descriptor, the user space can read from it."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:202
msgid ""
"The read() system call will run a timerlat code that will arm the timer in "
"the future and wait for it as the regular kernel thread does."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:205
msgid ""
"When the timer IRQ fires, the timerlat IRQ will execute, report the IRQ "
"latency and wake up the thread waiting in the read. The thread will be "
"scheduled and report the thread latency via tracer - as for the kernel "
"thread."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:210
msgid ""
"The difference from the in-kernel timerlat is that, instead of re-arming the "
"timer, timerlat will return to the read() system call. At this point, the "
"user can run any code."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:214
msgid ""
"If the application rereads the file timerlat file descriptor, the tracer "
"will report the return from user-space latency, which is the total latency. "
"If this is the end of the work, it can be interpreted as the response time "
"for the request."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:219
msgid ""
"After reporting the total latency, timerlat will restart the cycle, arm a "
"timer, and go to sleep for the following activation."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:222
msgid ""
"If at any time one of the conditions is broken, e.g., the thread migrates "
"while in user space, or the timerlat tracer is disabled, the SIG_KILL signal "
"will be sent to the user-space thread."
msgstr ""

#: ../../../trace/timerlat-tracer.rst:226
msgid "Here is an basic example of user-space code for timerlat::"
msgstr ""
