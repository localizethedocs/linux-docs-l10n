# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/user_events.rst:3
msgid "user_events: User-based Event Tracing"
msgstr ""

#: ../../../trace/user_events.rst:0
msgid "Author"
msgstr ""

#: ../../../trace/user_events.rst:5
msgid "Beau Belgrave"
msgstr ""

#: ../../../trace/user_events.rst:8
msgid "Overview"
msgstr ""

#: ../../../trace/user_events.rst:9
msgid ""
"User based trace events allow user processes to create events and trace data "
"that can be viewed via existing tools, such as ftrace and perf. To enable "
"this feature, build your kernel with CONFIG_USER_EVENTS=y."
msgstr ""

#: ../../../trace/user_events.rst:13
msgid ""
"Programs can view status of the events via /sys/kernel/tracing/"
"user_events_status and can both register and write data out via /sys/kernel/"
"tracing/user_events_data."
msgstr ""

#: ../../../trace/user_events.rst:17
msgid ""
"Programs can also use /sys/kernel/tracing/dynamic_events to register and "
"delete user based events via the u: prefix. The format of the command to "
"dynamic_events is the same as the ioctl with the u: prefix applied. This "
"requires CAP_PERFMON due to the event persisting, otherwise -EPERM is "
"returned."
msgstr ""

#: ../../../trace/user_events.rst:22
msgid ""
"Typically programs will register a set of events that they wish to expose to "
"tools that can read trace_events (such as ftrace and perf). The registration "
"process tells the kernel which address and bit to reflect if any tool has "
"enabled the event and data should be written. The registration will give "
"back a write index which describes the data when a write() or writev() is "
"called on the /sys/kernel/tracing/user_events_data file."
msgstr ""

#: ../../../trace/user_events.rst:29
msgid ""
"The structures referenced in this document are contained within the /include/"
"uapi/linux/user_events.h file in the source tree."
msgstr ""

#: ../../../trace/user_events.rst:32
msgid ""
"**NOTE:** *Both user_events_status and user_events_data are under the "
"tracefs filesystem and may be mounted at different paths than above.*"
msgstr ""

#: ../../../trace/user_events.rst:36
msgid "Registering"
msgstr ""

#: ../../../trace/user_events.rst:37
msgid ""
"Registering within a user process is done via ioctl() out to the /sys/kernel/"
"tracing/user_events_data file. The command to issue is DIAG_IOCSREG."
msgstr ""

#: ../../../trace/user_events.rst:41
msgid "This command takes a packed struct user_reg as an argument::"
msgstr ""

#: ../../../trace/user_events.rst:66
msgid ""
"The struct user_reg requires all the above inputs to be set appropriately."
msgstr ""

#: ../../../trace/user_events.rst:68
msgid "size: This must be set to sizeof(struct user_reg)."
msgstr ""

#: ../../../trace/user_events.rst:70
msgid ""
"enable_bit: The bit to reflect the event status at the address specified by "
"enable_addr."
msgstr ""

#: ../../../trace/user_events.rst:73
msgid ""
"enable_size: The size of the value specified by enable_addr. This must be 4 "
"(32-bit) or 8 (64-bit). 64-bit values are only allowed to be used on 64-bit "
"kernels, however, 32-bit can be used on all kernels."
msgstr ""

#: ../../../trace/user_events.rst:77
msgid ""
"flags: The flags to use, if any. Callers should first attempt to use flags "
"and retry without flags to ensure support for lower versions of the kernel. "
"If a flag is not supported -EINVAL is returned."
msgstr ""

#: ../../../trace/user_events.rst:82
msgid ""
"enable_addr: The address of the value to use to reflect event status. This "
"must be naturally aligned and write accessible within the user program."
msgstr ""

#: ../../../trace/user_events.rst:85
msgid ""
"name_args: The name and arguments to describe the event, see command format "
"for details."
msgstr ""

#: ../../../trace/user_events.rst:88
msgid "The following flags are currently supported."
msgstr ""

#: ../../../trace/user_events.rst:90
msgid ""
"USER_EVENT_REG_PERSIST: The event will not delete upon the last reference "
"closing. Callers may use this if an event should exist even after the "
"process closes or unregisters the event. Requires CAP_PERFMON otherwise -"
"EPERM is returned."
msgstr ""

#: ../../../trace/user_events.rst:95
msgid ""
"USER_EVENT_REG_MULTI_FORMAT: The event can contain multiple formats. This "
"allows programs to prevent themselves from being blocked when their event "
"format changes and they wish to use the same name. When this flag is used "
"the tracepoint name will be in the new format of \"name.unique_id\" vs the "
"older format of \"name\". A tracepoint will be created for each unique pair "
"of name and format. This means if several processes use the same name and "
"format, they will use the same tracepoint. If yet another process uses the "
"same name, but a different format than the other processes, it will use a "
"different tracepoint with a new unique id. Recording programs need to scan "
"tracefs for the various different formats of the event name they are "
"interested in recording. The system name of the tracepoint will also use "
"\"user_events_multi\" instead of \"user_events\". This prevents single-"
"format event names conflicting with any multi-format event names within "
"tracefs. The unique_id is output as a hex string. Recording programs should "
"ensure the tracepoint name starts with the event name they registered and "
"has a suffix that starts with . and only has hex characters. For example to "
"find all versions of the event \"test\" you can use the regex \"^test\\."
"[0-9a-fA-F]+$\"."
msgstr ""

#: ../../../trace/user_events.rst:113
msgid "Upon successful registration the following is set."
msgstr ""

#: ../../../trace/user_events.rst:115
msgid ""
"write_index: The index to use for this file descriptor that represents this "
"event when writing out data. The index is unique to this instance of the "
"file descriptor that was used for the registration. See writing data for "
"details."
msgstr ""

#: ../../../trace/user_events.rst:119
msgid ""
"User based events show up under tracefs like any other event under the "
"subsystem named \"user_events\". This means tools that wish to attach to the "
"events need to use /sys/kernel/tracing/events/user_events/[name]/enable or "
"perf record -e user_events:[name] when attaching/recording."
msgstr ""

#: ../../../trace/user_events.rst:124
msgid ""
"**NOTE:** The event subsystem name by default is \"user_events\". Callers "
"should not assume it will always be \"user_events\". Operators reserve the "
"right in the future to change the subsystem name per-process to accommodate "
"event isolation. In addition if the USER_EVENT_REG_MULTI_FORMAT flag is used "
"the tracepoint name will have a unique id appended to it and the system name "
"will be \"user_events_multi\" as described above."
msgstr ""

#: ../../../trace/user_events.rst:132
msgid "Command Format"
msgstr ""

#: ../../../trace/user_events.rst:133
msgid "The command string format is as follows::"
msgstr ""

#: ../../../trace/user_events.rst:138
msgid "Supported Flags"
msgstr ""

#: ../../../trace/user_events.rst:139
msgid "None yet"
msgstr ""

#: ../../../trace/user_events.rst:142
msgid "Field Format"
msgstr ""

#: ../../../trace/user_events.rst:147
msgid ""
"Basic types are supported (__data_loc, u32, u64, int, char, char[20], etc). "
"User programs are encouraged to use clearly sized types like u32."
msgstr ""

#: ../../../trace/user_events.rst:150
msgid ""
"**NOTE:** *Long is not supported since size can vary between user and kernel."
"*"
msgstr ""

#: ../../../trace/user_events.rst:152
msgid ""
"The size is only valid for types that start with a struct prefix. This "
"allows user programs to describe custom structs out to tools, if required."
msgstr ""

#: ../../../trace/user_events.rst:155
msgid "For example, a struct in C that looks like this::"
msgstr ""

#: ../../../trace/user_events.rst:161
msgid "Would be represented by the following field::"
msgstr ""

#: ../../../trace/user_events.rst:166
msgid "Deleting"
msgstr ""

#: ../../../trace/user_events.rst:167
msgid ""
"Deleting an event from within a user process is done via ioctl() out to the /"
"sys/kernel/tracing/user_events_data file. The command to issue is "
"DIAG_IOCSDEL."
msgstr ""

#: ../../../trace/user_events.rst:171
msgid ""
"This command only requires a single string specifying the event to delete by "
"its name. Delete will only succeed if there are no references left to the "
"event (in both user and kernel space). User programs should use a separate "
"file to request deletes than the one used for registration due to this."
msgstr ""

#: ../../../trace/user_events.rst:176
msgid ""
"**NOTE:** By default events will auto-delete when there are no references "
"left to the event. If programs do not want auto-delete, they must use the "
"USER_EVENT_REG_PERSIST flag when registering the event. Once that flag is "
"used the event exists until DIAG_IOCSDEL is invoked. Both register and "
"delete of an event that persists requires CAP_PERFMON, otherwise -EPERM is "
"returned. When there are multiple formats of the same event name, all events "
"with the same name will be attempted to be deleted. If only a specific "
"version is wanted to be deleted then the /sys/kernel/tracing/dynamic_events "
"file should be used for that specific format of the event."
msgstr ""

#: ../../../trace/user_events.rst:187
msgid "Unregistering"
msgstr ""

#: ../../../trace/user_events.rst:188
msgid ""
"If after registering an event it is no longer wanted to be updated then it "
"can be disabled via ioctl() out to the /sys/kernel/tracing/user_events_data "
"file. The command to issue is DIAG_IOCSUNREG. This is different than "
"deleting, where deleting actually removes the event from the system. "
"Unregistering simply tells the kernel your process is no longer interested "
"in updates to the event."
msgstr ""

#: ../../../trace/user_events.rst:194
msgid "This command takes a packed struct user_unreg as an argument::"
msgstr ""

#: ../../../trace/user_events.rst:213
msgid ""
"The struct user_unreg requires all the above inputs to be set appropriately."
msgstr ""

#: ../../../trace/user_events.rst:215
msgid "size: This must be set to sizeof(struct user_unreg)."
msgstr ""

#: ../../../trace/user_events.rst:217
msgid ""
"disable_bit: This must be set to the bit to disable (same bit that was "
"previously registered via enable_bit)."
msgstr ""

#: ../../../trace/user_events.rst:220
msgid ""
"disable_addr: This must be set to the address to disable (same address that "
"was previously registered via enable_addr)."
msgstr ""

#: ../../../trace/user_events.rst:223
msgid ""
"**NOTE:** Events are automatically unregistered when execve() is invoked. "
"During fork() the registered events will be retained and must be "
"unregistered manually in each process if wanted."
msgstr ""

#: ../../../trace/user_events.rst:228
msgid "Status"
msgstr ""

#: ../../../trace/user_events.rst:229
msgid ""
"When tools attach/record user based events the status of the event is "
"updated in realtime. This allows user programs to only incur the cost of the "
"write() or writev() calls when something is actively attached to the event."
msgstr ""

#: ../../../trace/user_events.rst:233
msgid ""
"The kernel will update the specified bit that was registered for the event "
"as tools attach/detach from the event. User programs simply check if the bit "
"is set to see if something is attached or not."
msgstr ""

#: ../../../trace/user_events.rst:237
msgid ""
"Administrators can easily check the status of all registered events by "
"reading the user_events_status file directly via a terminal. The output is "
"as follows::"
msgstr ""

#: ../../../trace/user_events.rst:246
msgid ""
"For example, on a system that has a single event the output looks like this::"
msgstr ""

#: ../../../trace/user_events.rst:253
msgid ""
"If a user enables the user event via ftrace, the output would change to "
"this::"
msgstr ""

#: ../../../trace/user_events.rst:261
msgid "Writing Data"
msgstr ""

#: ../../../trace/user_events.rst:262
msgid ""
"After registering an event the same fd that was used to register can be used "
"to write an entry for that event. The write_index returned must be at the "
"start of the data, then the remaining data is treated as the payload of the "
"event."
msgstr ""

#: ../../../trace/user_events.rst:266
msgid ""
"For example, if write_index returned was 1 and I wanted to write out an int "
"payload of the event. Then the data would have to be 8 bytes (2 ints) in "
"size, with the first 4 bytes being equal to 1 and the last 4 bytes being "
"equal to the value I want as the payload."
msgstr ""

#: ../../../trace/user_events.rst:271
msgid "In memory this would look like this::"
msgstr ""

#: ../../../trace/user_events.rst:276
msgid ""
"User programs might have well known structs that they wish to use to emit "
"out as payloads. In those cases writev() can be used, with the first vector "
"being the index and the following vector(s) being the actual event payload."
msgstr ""

#: ../../../trace/user_events.rst:280
msgid "For example, if I have a struct like this::"
msgstr ""

#: ../../../trace/user_events.rst:288
msgid "It's advised for user programs to do the following::"
msgstr ""

#: ../../../trace/user_events.rst:300
msgid ""
"**NOTE:** *The write_index is not emitted out into the trace being recorded.*"
msgstr ""

#: ../../../trace/user_events.rst:303
msgid "Example Code"
msgstr ""

#: ../../../trace/user_events.rst:304
msgid "See sample code in samples/user_events."
msgstr ""
