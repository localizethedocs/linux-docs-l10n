# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/events.rst:3
msgid "Event Tracing"
msgstr ""

#: ../../../trace/events.rst:0
msgid "Author"
msgstr ""

#: ../../../trace/events.rst:5
msgid "Theodore Ts'o"
msgstr ""

#: ../../../trace/events.rst:0
msgid "Updated"
msgstr ""

#: ../../../trace/events.rst:6
msgid "Li Zefan and Tom Zanussi"
msgstr ""

#: ../../../trace/events.rst:9
msgid "1. Introduction"
msgstr ""

#: ../../../trace/events.rst:11
msgid ""
"Tracepoints (see Documentation/trace/tracepoints.rst) can be used without "
"creating custom kernel modules to register probe functions using the event "
"tracing infrastructure."
msgstr ""

#: ../../../trace/events.rst:15
msgid ""
"Not all tracepoints can be traced using the event tracing system; the kernel "
"developer must provide code snippets which define how the tracing "
"information is saved into the tracing buffer, and how the tracing "
"information should be printed."
msgstr ""

#: ../../../trace/events.rst:21
msgid "2. Using Event Tracing"
msgstr ""

#: ../../../trace/events.rst:24
msgid "2.1 Via the 'set_event' interface"
msgstr ""

#: ../../../trace/events.rst:26
msgid ""
"The events which are available for tracing can be found in the file /sys/"
"kernel/tracing/available_events."
msgstr ""

#: ../../../trace/events.rst:29
msgid ""
"To enable a particular event, such as 'sched_wakeup', simply echo it to /sys/"
"kernel/tracing/set_event. For example::"
msgstr ""

#: ../../../trace/events.rst:34
msgid "'>>' is necessary, otherwise it will firstly disable all the events."
msgstr ""

#: ../../../trace/events.rst:36
msgid ""
"To disable an event, echo the event name to the set_event file prefixed with "
"an exclamation point::"
msgstr ""

#: ../../../trace/events.rst:41
msgid "To disable all events, echo an empty line to the set_event file::"
msgstr ""

#: ../../../trace/events.rst:45
msgid "To enable all events, echo ``*:*`` or ``*:`` to the set_event file::"
msgstr ""

#: ../../../trace/events.rst:49
msgid ""
"The events are organized into subsystems, such as ext4, irq, sched, etc., "
"and a full event name looks like this: <subsystem>:<event>.  The subsystem "
"name is optional, but it is displayed in the available_events file.  All of "
"the events in a subsystem can be specified via the syntax ``<subsystem>:*``; "
"for example, to enable all irq events, you can use the command::"
msgstr ""

#: ../../../trace/events.rst:58
msgid ""
"The set_event file may also be used to enable events associated to only a "
"specific module::"
msgstr ""

#: ../../../trace/events.rst:63
msgid ""
"Will enable all events in the module ``<module>``.  If the module is not yet "
"loaded, the string will be saved and when a module is that matches "
"``<module>`` is loaded, then it will apply the enabling of events then."
msgstr ""

#: ../../../trace/events.rst:67
msgid ""
"The text before ``:mod:`` will be parsed to specify specific events that the "
"module creates::"
msgstr ""

#: ../../../trace/events.rst:72
msgid ""
"The above will enable any system or event that ``<match>`` matches. If "
"``<match>`` is ``\"*\"`` then it will match all events."
msgstr ""

#: ../../../trace/events.rst:75
msgid "To enable only a specific event within a system::"
msgstr ""

#: ../../../trace/events.rst:79
msgid ""
"If ``<event>`` is ``\"*\"`` then it will match all events within the system "
"for a given module."
msgstr ""

#: ../../../trace/events.rst:83
msgid "2.2 Via the 'enable' toggle"
msgstr ""

#: ../../../trace/events.rst:85
msgid ""
"The events available are also listed in /sys/kernel/tracing/events/ "
"hierarchy of directories."
msgstr ""

#: ../../../trace/events.rst:88
msgid "To enable event 'sched_wakeup'::"
msgstr ""

#: ../../../trace/events.rst:92
msgid "To disable it::"
msgstr ""

#: ../../../trace/events.rst:96
msgid "To enable all events in sched subsystem::"
msgstr ""

#: ../../../trace/events.rst:100
msgid "To enable all events::"
msgstr ""

#: ../../../trace/events.rst:104
msgid "When reading one of these enable files, there are four results:"
msgstr ""

#: ../../../trace/events.rst:106
msgid "0 - all events this file affects are disabled"
msgstr ""

#: ../../../trace/events.rst:107
msgid "1 - all events this file affects are enabled"
msgstr ""

#: ../../../trace/events.rst:108
msgid "X - there is a mixture of events enabled and disabled"
msgstr ""

#: ../../../trace/events.rst:109
msgid "? - this file does not affect any event"
msgstr ""

#: ../../../trace/events.rst:112
msgid "2.3 Boot option"
msgstr ""

#: ../../../trace/events.rst:114
msgid "In order to facilitate early boot debugging, use boot option::"
msgstr ""

#: ../../../trace/events.rst:118
msgid ""
"event-list is a comma separated list of events. See section 2.1 for event "
"format."
msgstr ""

#: ../../../trace/events.rst:122
msgid "3. Defining an event-enabled tracepoint"
msgstr ""

#: ../../../trace/events.rst:124
msgid "See The example provided in samples/trace_events"
msgstr ""

#: ../../../trace/events.rst:127
msgid "4. Event formats"
msgstr ""

#: ../../../trace/events.rst:129
msgid ""
"Each trace event has a 'format' file associated with it that contains a "
"description of each field in a logged event.  This information can be used "
"to parse the binary trace stream, and is also the place to find the field "
"names that can be used in event filters (see section 5)."
msgstr ""

#: ../../../trace/events.rst:134
msgid ""
"It also displays the format string that will be used to print the event in "
"text mode, along with the event name and ID used for profiling."
msgstr ""

#: ../../../trace/events.rst:138
msgid ""
"Every event has a set of ``common`` fields associated with it; these are the "
"fields prefixed with ``common_``.  The other fields vary between events and "
"correspond to the fields defined in the TRACE_EVENT definition for that "
"event."
msgstr ""

#: ../../../trace/events.rst:143
msgid "Each field in the format has the form::"
msgstr ""

#: ../../../trace/events.rst:147
msgid ""
"where offset is the offset of the field in the trace record and size is the "
"size of the data item, in bytes."
msgstr ""

#: ../../../trace/events.rst:150
msgid ""
"For example, here's the information displayed for the 'sched_wakeup' event::"
msgstr ""

#: ../../../trace/events.rst:173
msgid ""
"This event contains 10 fields, the first 5 common and the remaining 5 event-"
"specific.  All the fields for this event are numeric, except for 'comm' "
"which is a string, a distinction important for event filtering."
msgstr ""

#: ../../../trace/events.rst:178
msgid "5. Event filtering"
msgstr ""

#: ../../../trace/events.rst:180
msgid ""
"Trace events can be filtered in the kernel by associating boolean 'filter "
"expressions' with them.  As soon as an event is logged into the trace "
"buffer, its fields are checked against the filter expression associated with "
"that event type.  An event with field values that 'match' the filter will "
"appear in the trace output, and an event whose values don't match will be "
"discarded.  An event with no filter associated with it matches everything, "
"and is the default when no filter has been set for an event."
msgstr ""

#: ../../../trace/events.rst:190
msgid "5.1 Expression syntax"
msgstr ""

#: ../../../trace/events.rst:192
msgid ""
"A filter expression consists of one or more 'predicates' that can be "
"combined using the logical operators '&&' and '||'.  A predicate is simply a "
"clause that compares the value of a field contained within a logged event "
"with a constant value and returns either 0 or 1 depending on whether the "
"field value matched (1) or didn't match (0)::"
msgstr ""

#: ../../../trace/events.rst:200
msgid ""
"Parentheses can be used to provide arbitrary logical groupings and double-"
"quotes can be used to prevent the shell from interpreting operators as shell "
"metacharacters."
msgstr ""

#: ../../../trace/events.rst:204
msgid ""
"The field-names available for use in filters can be found in the 'format' "
"files for trace events (see section 4)."
msgstr ""

#: ../../../trace/events.rst:207
msgid "The relational-operators depend on the type of the field being tested:"
msgstr ""

#: ../../../trace/events.rst:209
msgid "The operators available for numeric fields are:"
msgstr ""

#: ../../../trace/events.rst:211
msgid "==, !=, <, <=, >, >=, &"
msgstr ""

#: ../../../trace/events.rst:213
msgid "And for string fields they are:"
msgstr ""

#: ../../../trace/events.rst:215
msgid "==, !=, ~"
msgstr ""

#: ../../../trace/events.rst:217
msgid ""
"The glob (~) accepts a wild card character (\\*,?) and character classes "
"([). For example::"
msgstr ""

#: ../../../trace/events.rst:225
msgid ""
"If the field is a pointer that points into user space (for example "
"\"filename\" from sys_enter_openat), then you have to append \".ustring\" to "
"the field name::"
msgstr ""

#: ../../../trace/events.rst:231
msgid ""
"As the kernel will have to know how to retrieve the memory that the pointer "
"is at from user space."
msgstr ""

#: ../../../trace/events.rst:234
msgid ""
"You can convert any long type to a function address and search by function "
"name::"
msgstr ""

#: ../../../trace/events.rst:238
msgid ""
"The above will filter when the field \"call_site\" falls on the address "
"within \"security_prepare_creds\". That is, it will compare the value of "
"\"call_site\" and the filter will return true if it is greater than or equal "
"to the start of the function \"security_prepare_creds\" and less than the "
"end of that function."
msgstr ""

#: ../../../trace/events.rst:243
msgid ""
"The \".function\" postfix can only be attached to values of size long, and "
"can only be compared with \"==\" or \"!=\"."
msgstr ""

#: ../../../trace/events.rst:246
msgid ""
"Cpumask fields or scalar fields that encode a CPU number can be filtered "
"using a user-provided cpumask in cpulist format. The format is as follows::"
msgstr ""

#: ../../../trace/events.rst:251
msgid "Operators available to cpumask filtering are:"
msgstr ""

#: ../../../trace/events.rst:253
msgid "& (intersection), ==, !="
msgstr ""

#: ../../../trace/events.rst:255
msgid ""
"For example, this will filter events that have their .target_cpu field "
"present in the given cpumask::"
msgstr ""

#: ../../../trace/events.rst:261
msgid "5.2 Setting filters"
msgstr ""

#: ../../../trace/events.rst:263
msgid ""
"A filter for an individual event is set by writing a filter expression to "
"the 'filter' file for the given event."
msgstr ""

#: ../../../trace/events.rst:266
msgid "For example::"
msgstr ""

#: ../../../trace/events.rst:271
msgid "A slightly more involved example::"
msgstr ""

#: ../../../trace/events.rst:276
msgid ""
"If there is an error in the expression, you'll get an 'Invalid argument' "
"error when setting it, and the erroneous string along with an error message "
"can be seen by looking at the filter e.g.::"
msgstr ""

#: ../../../trace/events.rst:288
msgid ""
"Currently the caret ('^') for an error always appears at the beginning of "
"the filter string; the error message should still be useful though even "
"without more accurate position info."
msgstr ""

#: ../../../trace/events.rst:293
msgid "5.2.1 Filter limitations"
msgstr ""

#: ../../../trace/events.rst:295
msgid ""
"If a filter is placed on a string pointer ``(char *)`` that does not point "
"to a string on the ring buffer, but instead points to kernel or user space "
"memory, then, for safety reasons, at most 1024 bytes of the content is "
"copied onto a temporary buffer to do the compare. If the copy of the memory "
"faults (the pointer points to memory that should not be accessed), then the "
"string compare will be treated as not matching."
msgstr ""

#: ../../../trace/events.rst:303
msgid "5.3 Clearing filters"
msgstr ""

#: ../../../trace/events.rst:305
msgid ""
"To clear the filter for an event, write a '0' to the event's filter file."
msgstr ""

#: ../../../trace/events.rst:308
msgid ""
"To clear the filters for all events in a subsystem, write a '0' to the "
"subsystem's filter file."
msgstr ""

#: ../../../trace/events.rst:312
msgid "5.4 Subsystem filters"
msgstr ""

#: ../../../trace/events.rst:314
msgid ""
"For convenience, filters for every event in a subsystem can be set or "
"cleared as a group by writing a filter expression into the filter file at "
"the root of the subsystem.  Note however, that if a filter for any event "
"within the subsystem lacks a field specified in the subsystem filter, or if "
"the filter can't be applied for any other reason, the filter for that event "
"will retain its previous setting.  This can result in an unintended mixture "
"of filters which could lead to confusing (to the user who might think "
"different filters are in effect) trace output.  Only filters that reference "
"just the common fields can be guaranteed to propagate successfully to all "
"events."
msgstr ""

#: ../../../trace/events.rst:325
msgid ""
"Here are a few subsystem filter examples that also illustrate the above "
"points:"
msgstr ""

#: ../../../trace/events.rst:328
msgid "Clear the filters on all events in the sched subsystem::"
msgstr ""

#: ../../../trace/events.rst:337
msgid ""
"Set a filter using only common fields for all events in the sched subsystem "
"(all events end up with the same filter)::"
msgstr ""

#: ../../../trace/events.rst:347
msgid ""
"Attempt to set a filter using a non-common field for all events in the sched "
"subsystem (all events but those that have a prev_pid field retain their old "
"filters)::"
msgstr ""

#: ../../../trace/events.rst:359
msgid "5.5 PID filtering"
msgstr ""

#: ../../../trace/events.rst:361
msgid ""
"The set_event_pid file in the same directory as the top events directory "
"exists, will filter all events from tracing any task that does not have the "
"PID listed in the set_event_pid file. ::"
msgstr ""

#: ../../../trace/events.rst:370
msgid "Will only trace events for the current task."
msgstr ""

#: ../../../trace/events.rst:372
msgid "To add more PIDs without losing the PIDs already included, use '>>'. ::"
msgstr ""

#: ../../../trace/events.rst:379
msgid "6. Event triggers"
msgstr ""

#: ../../../trace/events.rst:381
msgid ""
"Trace events can be made to conditionally invoke trigger 'commands' which "
"can take various forms and are described in detail below; examples would be "
"enabling or disabling other trace events or invoking a stack trace whenever "
"the trace event is hit.  Whenever a trace event with attached triggers is "
"invoked, the set of trigger commands associated with that event is invoked.  "
"Any given trigger can additionally have an event filter of the same form as "
"described in section 5 (Event filtering) associated with it - the command "
"will only be invoked if the event being invoked passes the associated "
"filter. If no filter is associated with the trigger, it always passes."
msgstr ""

#: ../../../trace/events.rst:392
msgid ""
"Triggers are added to and removed from a particular event by writing trigger "
"expressions to the 'trigger' file for the given event."
msgstr ""

#: ../../../trace/events.rst:395
msgid ""
"A given event can have any number of triggers associated with it, subject to "
"any restrictions that individual commands may have in that regard."
msgstr ""

#: ../../../trace/events.rst:399
msgid ""
"Event triggers are implemented on top of \"soft\" mode, which means that "
"whenever a trace event has one or more triggers associated with it, the "
"event is activated even if it isn't actually enabled, but is disabled in a "
"\"soft\" mode.  That is, the tracepoint will be called, but just will not be "
"traced, unless of course it's actually enabled. This scheme allows triggers "
"to be invoked even for events that aren't enabled, and also allows the "
"current event filter implementation to be used for conditionally invoking "
"triggers."
msgstr ""

#: ../../../trace/events.rst:408
msgid ""
"The syntax for event triggers is roughly based on the syntax for "
"set_ftrace_filter 'ftrace filter commands' (see the 'Filter commands' "
"section of Documentation/trace/ftrace.rst), but there are major differences "
"and the implementation isn't currently tied to it in any way, so beware "
"about making generalizations between the two."
msgstr ""

#: ../../../trace/events.rst:415
msgid ""
"Writing into trace_marker (See Documentation/trace/ftrace.rst) can also "
"enable triggers that are written into /sys/kernel/tracing/events/ftrace/"
"print/trigger"
msgstr ""

#: ../../../trace/events.rst:420
msgid "6.1 Expression syntax"
msgstr ""

#: ../../../trace/events.rst:422
msgid "Triggers are added by echoing the command to the 'trigger' file::"
msgstr ""

#: ../../../trace/events.rst:426
msgid ""
"Triggers are removed by echoing the same command but starting with '!' to "
"the 'trigger' file::"
msgstr ""

#: ../../../trace/events.rst:431
msgid ""
"The [if filter] part isn't used in matching commands when removing, so "
"leaving that off in a '!' command will accomplish the same thing as having "
"it in."
msgstr ""

#: ../../../trace/events.rst:435
msgid ""
"The filter syntax is the same as that described in the 'Event filtering' "
"section above."
msgstr ""

#: ../../../trace/events.rst:438
msgid ""
"For ease of use, writing to the trigger file using '>' currently just adds "
"or removes a single trigger and there's no explicit '>>' support ('>' "
"actually behaves like '>>') or truncation support to remove all triggers "
"(you have to use '!' for each one added.)"
msgstr ""

#: ../../../trace/events.rst:444
msgid "6.2 Supported trigger commands"
msgstr ""

#: ../../../trace/events.rst:446
msgid "The following commands are supported:"
msgstr ""

#: ../../../trace/events.rst:448
msgid "enable_event/disable_event"
msgstr ""

#: ../../../trace/events.rst:450
msgid ""
"These commands can enable or disable another trace event whenever the "
"triggering event is hit.  When these commands are registered, the other "
"trace event is activated, but disabled in a \"soft\" mode. That is, the "
"tracepoint will be called, but just will not be traced. The event tracepoint "
"stays in this mode as long as there's a trigger in effect that can trigger "
"it."
msgstr ""

#: ../../../trace/events.rst:457
msgid ""
"For example, the following trigger causes kmalloc events to be traced when a "
"read system call is entered, and the :1 at the end specifies that this "
"enablement happens only once::"
msgstr ""

#: ../../../trace/events.rst:464
msgid ""
"The following trigger causes kmalloc events to stop being traced when a read "
"system call exits.  This disablement happens on every read system call exit::"
msgstr ""

#: ../../../trace/events.rst:471 ../../../trace/events.rst:509
msgid "The format is::"
msgstr ""

#: ../../../trace/events.rst:476 ../../../trace/events.rst:513
#: ../../../trace/events.rst:548 ../../../trace/events.rst:579
msgid "To remove the above commands::"
msgstr ""

#: ../../../trace/events.rst:484
msgid ""
"Note that there can be any number of enable/disable_event triggers per "
"triggering event, but there can only be one trigger per triggered event. e."
"g. sys_enter_read can have triggers enabling both kmem:kmalloc and sched:"
"sched_switch, but can't have two kmem:kmalloc versions such as kmem:kmalloc "
"and kmem:kmalloc:1 or 'kmem:kmalloc if bytes_req == 256' and 'kmem:kmalloc "
"if bytes_alloc == 256' (they could be combined into a single filter on kmem:"
"kmalloc though)."
msgstr ""

#: ../../../trace/events.rst:492
msgid "stacktrace"
msgstr ""

#: ../../../trace/events.rst:494
msgid ""
"This command dumps a stacktrace in the trace buffer whenever the triggering "
"event occurs."
msgstr ""

#: ../../../trace/events.rst:497
msgid ""
"For example, the following trigger dumps a stacktrace every time the kmalloc "
"tracepoint is hit::"
msgstr ""

#: ../../../trace/events.rst:503
msgid ""
"The following trigger dumps a stacktrace the first 5 times a kmalloc request "
"happens with a size >= 64K::"
msgstr ""

#: ../../../trace/events.rst:521
msgid ""
"The latter can also be removed more simply by the following (without the "
"filter)::"
msgstr ""

#: ../../../trace/events.rst:527
msgid ""
"Note that there can be only one stacktrace trigger per triggering event."
msgstr ""

#: ../../../trace/events.rst:530
msgid "snapshot"
msgstr ""

#: ../../../trace/events.rst:532
msgid ""
"This command causes a snapshot to be triggered whenever the triggering event "
"occurs."
msgstr ""

#: ../../../trace/events.rst:535
msgid ""
"The following command creates a snapshot every time a block request queue is "
"unplugged with a depth > 1.  If you were tracing a set of events or "
"functions at the time, the snapshot trace buffer would capture those events "
"when the trigger event occurred::"
msgstr ""

#: ../../../trace/events.rst:543
msgid "To only snapshot once::"
msgstr ""

#: ../../../trace/events.rst:556
msgid "Note that there can be only one snapshot trigger per triggering event."
msgstr ""

#: ../../../trace/events.rst:559
msgid "traceon/traceoff"
msgstr ""

#: ../../../trace/events.rst:561
msgid ""
"These commands turn tracing on and off when the specified events are hit. "
"The parameter determines how many times the tracing system is turned on and "
"off. If unspecified, there is no limit."
msgstr ""

#: ../../../trace/events.rst:565
msgid ""
"The following command turns tracing off the first time a block request queue "
"is unplugged with a depth > 1.  If you were tracing a set of events or "
"functions at the time, you could then examine the trace buffer to see the "
"sequence of events that led up to the trigger event::"
msgstr ""

#: ../../../trace/events.rst:574
msgid "To always disable tracing when nr_rq  > 1::"
msgstr ""

#: ../../../trace/events.rst:587
msgid ""
"Note that there can be only one traceon or traceoff trigger per triggering "
"event."
msgstr ""

#: ../../../trace/events.rst:590
msgid "hist"
msgstr ""

#: ../../../trace/events.rst:592
msgid ""
"This command aggregates event hits into a hash table keyed on one or more "
"trace event format fields (or stacktrace) and a set of running totals "
"derived from one or more trace event format fields and/or event counts "
"(hitcount)."
msgstr ""

#: ../../../trace/events.rst:597
msgid "See Documentation/trace/histogram.rst for details and examples."
msgstr ""

#: ../../../trace/events.rst:600
msgid "7. In-kernel trace event API"
msgstr ""

#: ../../../trace/events.rst:602
msgid ""
"In most cases, the command-line interface to trace events is more than "
"sufficient.  Sometimes, however, applications might find the need for more "
"complex relationships than can be expressed through a simple series of "
"linked command-line expressions, or putting together sets of commands may be "
"simply too cumbersome.  An example might be an application that needs to "
"'listen' to the trace stream in order to maintain an in-kernel state machine "
"detecting, for instance, when an illegal kernel state occurs in the "
"scheduler."
msgstr ""

#: ../../../trace/events.rst:611
msgid ""
"The trace event subsystem provides an in-kernel API allowing modules or "
"other kernel code to generate user-defined 'synthetic' events at will, which "
"can be used to either augment the existing trace stream and/or signal that a "
"particular important state has occurred."
msgstr ""

#: ../../../trace/events.rst:616
msgid ""
"A similar in-kernel API is also available for creating kprobe and kretprobe "
"events."
msgstr ""

#: ../../../trace/events.rst:619
msgid ""
"Both the synthetic event and k/ret/probe event APIs are built on top of a "
"lower-level \"dynevent_cmd\" event command API, which is also available for "
"more specialized applications, or as the basis of other higher-level trace "
"event APIs."
msgstr ""

#: ../../../trace/events.rst:624
msgid ""
"The API provided for these purposes is describe below and allows the "
"following:"
msgstr ""

#: ../../../trace/events.rst:627
msgid "dynamically creating synthetic event definitions"
msgstr ""

#: ../../../trace/events.rst:628
msgid "dynamically creating kprobe and kretprobe event definitions"
msgstr ""

#: ../../../trace/events.rst:629
msgid "tracing synthetic events from in-kernel code"
msgstr ""

#: ../../../trace/events.rst:630
msgid "the low-level \"dynevent_cmd\" API"
msgstr ""

#: ../../../trace/events.rst:633
msgid "7.1 Dynamically creating synthetic event definitions"
msgstr ""

#: ../../../trace/events.rst:635
msgid ""
"There are a couple ways to create a new synthetic event from a kernel module "
"or other kernel code."
msgstr ""

#: ../../../trace/events.rst:638
msgid ""
"The first creates the event in one step, using synth_event_create(). In this "
"method, the name of the event to create and an array defining the fields is "
"supplied to synth_event_create().  If successful, a synthetic event with "
"that name and fields will exist following that call.  For example, to create "
"a new \"schedtest\" synthetic event::"
msgstr ""

#: ../../../trace/events.rst:647
msgid ""
"The sched_fields param in this example points to an array of struct "
"synth_field_desc, each of which describes an event field by type and name::"
msgstr ""

#: ../../../trace/events.rst:661
msgid "See synth_field_size() for available types."
msgstr ""

#: ../../../trace/events.rst:663
msgid ""
"If field_name contains [n], the field is considered to be a static array."
msgstr ""

#: ../../../trace/events.rst:665
msgid ""
"If field_names contains[] (no subscript), the field is considered to be a "
"dynamic array, which will only take as much space in the event as is "
"required to hold the array."
msgstr ""

#: ../../../trace/events.rst:669
msgid ""
"Because space for an event is reserved before assigning field values to the "
"event, using dynamic arrays implies that the piecewise in-kernel API "
"described below can't be used with dynamic arrays.  The other non-piecewise "
"in-kernel APIs can, however, be used with dynamic arrays."
msgstr ""

#: ../../../trace/events.rst:675
msgid ""
"If the event is created from within a module, a pointer to the module must "
"be passed to synth_event_create().  This will ensure that the trace buffer "
"won't contain unreadable events when the module is removed."
msgstr ""

#: ../../../trace/events.rst:680
msgid ""
"At this point, the event object is ready to be used for generating new "
"events."
msgstr ""

#: ../../../trace/events.rst:683
msgid ""
"In the second method, the event is created in several steps.  This allows "
"events to be created dynamically and without the need to create and populate "
"an array of fields beforehand."
msgstr ""

#: ../../../trace/events.rst:687
msgid ""
"To use this method, an empty or partially empty synthetic event should first "
"be created using synth_event_gen_cmd_start() or "
"synth_event_gen_cmd_array_start().  For synth_event_gen_cmd_start(), the "
"name of the event along with one or more pairs of args each pair "
"representing a 'type field_name;' field specification should be supplied.  "
"For synth_event_gen_cmd_array_start(), the name of the event along with an "
"array of struct synth_field_desc should be supplied. Before calling "
"synth_event_gen_cmd_start() or synth_event_gen_cmd_array_start(), the user "
"should create and initialize a dynevent_cmd object using "
"synth_event_cmd_init()."
msgstr ""

#: ../../../trace/events.rst:698
msgid ""
"For example, to create a new \"schedtest\" synthetic event with two fields::"
msgstr ""

#: ../../../trace/events.rst:714
msgid ""
"Alternatively, using an array of struct synth_field_desc fields containing "
"the same information::"
msgstr ""

#: ../../../trace/events.rst:720
msgid ""
"Once the synthetic event object has been created, it can then be populated "
"with more fields.  Fields are added one by one using "
"synth_event_add_field(), supplying the dynevent_cmd object, a field type, "
"and a field name.  For example, to add a new int field named \"intfield\", "
"the following call should be made::"
msgstr ""

#: ../../../trace/events.rst:728
msgid ""
"See synth_field_size() for available types. If field_name contains [n] the "
"field is considered to be an array."
msgstr ""

#: ../../../trace/events.rst:731
msgid ""
"A group of fields can also be added all at once using an array of "
"synth_field_desc with add_synth_fields().  For example, this would add just "
"the first four sched_fields::"
msgstr ""

#: ../../../trace/events.rst:737
msgid ""
"If you already have a string of the form 'type field_name', "
"synth_event_add_field_str() can be used to add it as-is; it will also "
"automatically append a ';' to the string."
msgstr ""

#: ../../../trace/events.rst:741
msgid ""
"Once all the fields have been added, the event should be finalized and "
"registered by calling the synth_event_gen_cmd_end() function::"
msgstr ""

#: ../../../trace/events.rst:746 ../../../trace/events.rst:999
msgid ""
"At this point, the event object is ready to be used for tracing new events."
msgstr ""

#: ../../../trace/events.rst:750
msgid "7.2 Tracing synthetic events from in-kernel code"
msgstr ""

#: ../../../trace/events.rst:752
msgid ""
"To trace a synthetic event, there are several options.  The first option is "
"to trace the event in one call, using synth_event_trace() with a variable "
"number of values, or synth_event_trace_array() with an array of values to be "
"set.  A second option can be used to avoid the need for a pre-formed array "
"of values or list of arguments, via synth_event_trace_start() and "
"synth_event_trace_end() along with synth_event_add_next_val() or "
"synth_event_add_val() to add the values piecewise."
msgstr ""

#: ../../../trace/events.rst:762
msgid "7.2.1 Tracing a synthetic event all at once"
msgstr ""

#: ../../../trace/events.rst:764
msgid ""
"To trace a synthetic event all at once, the synth_event_trace() or "
"synth_event_trace_array() functions can be used."
msgstr ""

#: ../../../trace/events.rst:767
msgid ""
"The synth_event_trace() function is passed the trace_event_file representing "
"the synthetic event (which can be retrieved using trace_get_event_file() "
"using the synthetic event name, \"synthetic\" as the system name, and the "
"trace instance name (NULL if using the global trace array)), along with an "
"variable number of u64 args, one for each synthetic event field, and the "
"number of values being passed."
msgstr ""

#: ../../../trace/events.rst:774
msgid ""
"So, to trace an event corresponding to the synthetic event definition above, "
"code like the following could be used::"
msgstr ""

#: ../../../trace/events.rst:786 ../../../trace/events.rst:815
msgid ""
"All vals should be cast to u64, and string vals are just pointers to "
"strings, cast to u64.  Strings will be copied into space reserved in the "
"event for the string, using these pointers."
msgstr ""

#: ../../../trace/events.rst:790
msgid ""
"Alternatively, the synth_event_trace_array() function can be used to "
"accomplish the same thing.  It is passed the trace_event_file representing "
"the synthetic event (which can be retrieved using trace_get_event_file() "
"using the synthetic event name, \"synthetic\" as the system name, and the "
"trace instance name (NULL if using the global trace array)), along with an "
"array of u64, one for each synthetic event field."
msgstr ""

#: ../../../trace/events.rst:798
msgid ""
"To trace an event corresponding to the synthetic event definition above, "
"code like the following could be used::"
msgstr ""

#: ../../../trace/events.rst:811
msgid ""
"The 'vals' array is just an array of u64, the number of which must match the "
"number of field in the synthetic event, and which must be in the same order "
"as the synthetic event fields."
msgstr ""

#: ../../../trace/events.rst:819
msgid ""
"In order to trace a synthetic event, a pointer to the trace event file is "
"needed.  The trace_get_event_file() function can be used to get it - it will "
"find the file in the given trace instance (in this case NULL since the top "
"trace array is being used) while at the same time preventing the instance "
"containing it from going away::"
msgstr ""

#: ../../../trace/events.rst:828
msgid ""
"Before tracing the event, it should be enabled in some way, otherwise the "
"synthetic event won't actually show up in the trace buffer."
msgstr ""

#: ../../../trace/events.rst:831
msgid ""
"To enable a synthetic event from the kernel, trace_array_set_clr_event() can "
"be used (which is not specific to synthetic events, so does need the "
"\"synthetic\" system name to be specified explicitly)."
msgstr ""

#: ../../../trace/events.rst:835
msgid "To enable the event, pass 'true' to it::"
msgstr ""

#: ../../../trace/events.rst:840
msgid "To disable it pass false::"
msgstr ""

#: ../../../trace/events.rst:845
msgid ""
"Finally, synth_event_trace_array() can be used to actually trace the event, "
"which should be visible in the trace buffer afterwards::"
msgstr ""

#: ../../../trace/events.rst:851
msgid ""
"To remove the synthetic event, the event should be disabled, and the trace "
"instance should be 'put' back using trace_put_event_file()::"
msgstr ""

#: ../../../trace/events.rst:858
msgid ""
"If those have been successful, synth_event_delete() can be called to remove "
"the event::"
msgstr ""

#: ../../../trace/events.rst:864
msgid "7.2.2 Tracing a synthetic event piecewise"
msgstr ""

#: ../../../trace/events.rst:866
msgid ""
"To trace a synthetic using the piecewise method described above, the "
"synth_event_trace_start() function is used to 'open' the synthetic event "
"trace::"
msgstr ""

#: ../../../trace/events.rst:874
msgid ""
"It's passed the trace_event_file representing the synthetic event using the "
"same methods as described above, along with a pointer to a struct "
"synth_event_trace_state object, which will be zeroed before use and used to "
"maintain state between this and following calls."
msgstr ""

#: ../../../trace/events.rst:879
msgid ""
"Once the event has been opened, which means space for it has been reserved "
"in the trace buffer, the individual fields can be set.  There are two ways "
"to do that, either one after another for each field in the event, which "
"requires no lookups, or by name, which does.  The tradeoff is flexibility in "
"doing the assignments vs the cost of a lookup per field."
msgstr ""

#: ../../../trace/events.rst:886
msgid ""
"To assign the values one after the other without lookups, "
"synth_event_add_next_val() should be used.  Each call is passed the same "
"synth_event_trace_state object used in the synth_event_trace_start(), along "
"with the value to set the next field in the event.  After each field is set, "
"the 'cursor' points to the next field, which will be set by the subsequent "
"call, continuing until all the fields have been set in order.  The same "
"sequence of calls as in the above examples using this method would be "
"(without error-handling code)::"
msgstr ""

#: ../../../trace/events.rst:916
msgid ""
"To assign the values in any order, synth_event_add_val() should be used.  "
"Each call is passed the same synth_event_trace_state object used in the "
"synth_event_trace_start(), along with the field name of the field to set and "
"the value to set it to.  The same sequence of calls as in the above examples "
"using this method would be (without error-handling code)::"
msgstr ""

#: ../../../trace/events.rst:933
msgid ""
"Note that synth_event_add_next_val() and synth_event_add_val() are "
"incompatible if used within the same trace of an event - either one can be "
"used but not both at the same time."
msgstr ""

#: ../../../trace/events.rst:937
msgid ""
"Finally, the event won't be actually traced until it's 'closed', which is "
"done using synth_event_trace_end(), which takes only the struct "
"synth_event_trace_state object used in the previous calls::"
msgstr ""

#: ../../../trace/events.rst:943
msgid ""
"Note that synth_event_trace_end() must be called at the end regardless of "
"whether any of the add calls failed (say due to a bad field name being "
"passed in)."
msgstr ""

#: ../../../trace/events.rst:948
msgid "7.3 Dynamically creating kprobe and kretprobe event definitions"
msgstr ""

#: ../../../trace/events.rst:950
msgid ""
"To create a kprobe or kretprobe trace event from kernel code, the "
"kprobe_event_gen_cmd_start() or kretprobe_event_gen_cmd_start() functions "
"can be used."
msgstr ""

#: ../../../trace/events.rst:954
msgid ""
"To create a kprobe event, an empty or partially empty kprobe event should "
"first be created using kprobe_event_gen_cmd_start().  The name of the event "
"and the probe location should be specified along with one or args each "
"representing a probe field should be supplied to this function.  Before "
"calling kprobe_event_gen_cmd_start(), the user should create and initialize "
"a dynevent_cmd object using kprobe_event_cmd_init()."
msgstr ""

#: ../../../trace/events.rst:962
msgid ""
"For example, to create a new \"schedtest\" kprobe event with two fields::"
msgstr ""

#: ../../../trace/events.rst:980
msgid ""
"Once the kprobe event object has been created, it can then be populated with "
"more fields.  Fields can be added using kprobe_event_add_fields(), supplying "
"the dynevent_cmd object along with a variable arg list of probe fields.  For "
"example, to add a couple additional fields, the following call could be "
"made::"
msgstr ""

#: ../../../trace/events.rst:988
msgid ""
"Once all the fields have been added, the event should be finalized and "
"registered by calling the kprobe_event_gen_cmd_end() or "
"kretprobe_event_gen_cmd_end() functions, depending on whether a kprobe or "
"kretprobe command was started::"
msgstr ""

#: ../../../trace/events.rst:995
msgid "or::"
msgstr ""

#: ../../../trace/events.rst:1002
msgid ""
"Similarly, a kretprobe event can be created using "
"kretprobe_event_gen_cmd_start() with a probe name and location and "
"additional params such as $retval::"
msgstr ""

#: ../../../trace/events.rst:1009
msgid ""
"Similar to the synthetic event case, code like the following can be used to "
"enable the newly created kprobe event::"
msgstr ""

#: ../../../trace/events.rst:1017
msgid ""
"Finally, also similar to synthetic events, the following code can be used to "
"give the kprobe event file back and delete the event::"
msgstr ""

#: ../../../trace/events.rst:1025
msgid "7.4 The \"dynevent_cmd\" low-level API"
msgstr ""

#: ../../../trace/events.rst:1027
msgid ""
"Both the in-kernel synthetic event and kprobe interfaces are built on top of "
"a lower-level \"dynevent_cmd\" interface.  This interface is meant to "
"provide the basis for higher-level interfaces such as the synthetic and "
"kprobe interfaces, which can be used as examples."
msgstr ""

#: ../../../trace/events.rst:1032
msgid ""
"The basic idea is simple and amounts to providing a general-purpose layer "
"that can be used to generate trace event commands.  The generated command "
"strings can then be passed to the command-parsing and event creation code "
"that already exists in the trace event subsystem for creating the "
"corresponding trace events."
msgstr ""

#: ../../../trace/events.rst:1038
msgid ""
"In a nutshell, the way it works is that the higher-level interface code "
"creates a struct dynevent_cmd object, then uses a couple functions, "
"dynevent_arg_add() and dynevent_arg_pair_add() to build up a command string, "
"which finally causes the command to be executed using the dynevent_create() "
"function.  The details of the interface are described below."
msgstr ""

#: ../../../trace/events.rst:1045
msgid ""
"The first step in building a new command string is to create and initialize "
"an instance of a dynevent_cmd.  Here, for instance, we create a dynevent_cmd "
"on the stack and initialize it::"
msgstr ""

#: ../../../trace/events.rst:1058
msgid ""
"The dynevent_cmd initialization needs to be given a user-specified buffer "
"and the length of the buffer (MAX_DYNEVENT_CMD_LEN can be used for this "
"purpose - at 2k it's generally too big to be comfortably put on the stack, "
"so is dynamically allocated), a dynevent type id, which is meant to be used "
"to check that further API calls are for the correct command type, and a "
"pointer to an event-specific run_command() callback that will be called to "
"actually execute the event-specific command function."
msgstr ""

#: ../../../trace/events.rst:1067
msgid ""
"Once that's done, the command string can by built up by successive calls to "
"argument-adding functions."
msgstr ""

#: ../../../trace/events.rst:1070
msgid ""
"To add a single argument, define and initialize a struct dynevent_arg or "
"struct dynevent_arg_pair object.  Here's an example of the simplest possible "
"arg addition, which is simply to append the given string as a whitespace-"
"separated argument to the command::"
msgstr ""

#: ../../../trace/events.rst:1083
msgid ""
"The arg object is first initialized using dynevent_arg_init() and in this "
"case the parameters are NULL or 0, which means there's no optional sanity-"
"checking function or separator appended to the end of the arg."
msgstr ""

#: ../../../trace/events.rst:1088
msgid ""
"Here's another more complicated example using an 'arg pair', which is used "
"to create an argument that consists of a couple components added together as "
"a unit, for example, a 'type field_name;' arg or a simple expression arg e."
"g. 'flags=%cx'::"
msgstr ""

#: ../../../trace/events.rst:1102
msgid ""
"Again, the arg_pair is first initialized, in this case with a callback "
"function used to check the sanity of the args (for example, that neither "
"part of the pair is NULL), along with a character to be used to add an "
"operator between the pair (here none) and a separator to be appended onto "
"the end of the arg pair (here ';')."
msgstr ""

#: ../../../trace/events.rst:1108
msgid ""
"There's also a dynevent_str_add() function that can be used to simply add a "
"string as-is, with no spaces, delimiters, or arg check."
msgstr ""

#: ../../../trace/events.rst:1111
msgid ""
"Any number of dynevent_*_add() calls can be made to build up the string "
"(until its length surpasses cmd->maxlen).  When all the arguments have been "
"added and the command string is complete, the only thing left to do is run "
"the command, which happens by simply calling dynevent_create()::"
msgstr ""

#: ../../../trace/events.rst:1119
msgid ""
"At that point, if the return value is 0, the dynamic event has been created "
"and is ready to use."
msgstr ""

#: ../../../trace/events.rst:1122
msgid ""
"See the dynevent_cmd function definitions themselves for the details of the "
"API."
msgstr ""
