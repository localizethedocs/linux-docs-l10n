# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/classic_vs_extended.rst:4
msgid "Classic BPF vs eBPF"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:6
msgid ""
"eBPF is designed to be JITed with one to one mapping, which can also open up "
"the possibility for GCC/LLVM compilers to generate optimized eBPF code "
"through an eBPF backend that performs almost as fast as natively compiled "
"code."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:10
msgid "Some core changes of the eBPF format from classic BPF:"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:12
msgid "Number of registers increase from 2 to 10:"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:14
msgid ""
"The old format had two registers A and X, and a hidden frame pointer. The "
"new layout extends this to be 10 internal registers and a read-only frame "
"pointer. Since 64-bit CPUs are passing arguments to functions via registers "
"the number of args from eBPF program to in-kernel function is restricted to "
"5 and one register is used to accept return value from an in-kernel "
"function. Natively, x86_64 passes first 6 arguments in registers, aarch64/ "
"sparcv9/mips64 have 7 - 8 registers for arguments; x86_64 has 6 callee saved "
"registers, and aarch64/sparcv9/mips64 have 11 or more callee saved registers."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:23
msgid ""
"Thus, all eBPF registers map one to one to HW registers on x86_64, aarch64, "
"etc, and eBPF calling convention maps directly to ABIs used by the kernel on "
"64-bit architectures."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:27
msgid ""
"On 32-bit architectures JIT may map programs that use only 32-bit arithmetic "
"and may let more complex programs to be interpreted."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:30
msgid ""
"R0 - R5 are scratch registers and eBPF program needs spill/fill them if "
"necessary across calls. Note that there is only one eBPF program (== one "
"eBPF main routine) and it cannot call other eBPF functions, it can only call "
"predefined in-kernel functions, though."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:35
msgid "Register width increases from 32-bit to 64-bit:"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:37
msgid ""
"Still, the semantics of the original 32-bit ALU operations are preserved via "
"32-bit subregisters. All eBPF registers are 64-bit with 32-bit lower "
"subregisters that zero-extend into 64-bit if they are being written to. That "
"behavior maps directly to x86_64 and arm64 subregister definition, but makes "
"other JITs more difficult."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:43
msgid ""
"32-bit architectures run 64-bit eBPF programs via interpreter. Their JITs "
"may convert BPF programs that only use 32-bit subregisters into native "
"instruction set and let the rest being interpreted."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:47
msgid ""
"Operation is 64-bit, because on 64-bit architectures, pointers are also 64-"
"bit wide, and we want to pass 64-bit values in/out of kernel functions, so "
"32-bit eBPF registers would otherwise require to define register-pair ABI, "
"thus, there won't be able to use a direct eBPF register to HW register "
"mapping and JIT would need to do combine/split/move operations for every "
"register in and out of the function, which is complex, bug prone and slow. "
"Another reason is the use of atomic 64-bit counters."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:55
msgid "Conditional jt/jf targets replaced with jt/fall-through:"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:57
msgid ""
"While the original design has constructs such as ``if (cond) jump_true; else "
"jump_false;``, they are being replaced into alternative constructs like ``if "
"(cond) jump_true; /* else fall-through */``."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:61
msgid ""
"Introduces bpf_call insn and register passing convention for zero overhead "
"calls from/to other kernel functions:"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:64
msgid ""
"Before an in-kernel function call, the eBPF program needs to place function "
"arguments into R1 to R5 registers to satisfy calling convention, then the "
"interpreter will take them from registers and pass to in-kernel function. If "
"R1 - R5 registers are mapped to CPU registers that are used for argument "
"passing on given architecture, the JIT compiler doesn't need to emit extra "
"moves. Function arguments will be in the correct registers and BPF_CALL "
"instruction will be JITed as single 'call' HW instruction. This calling "
"convention was picked to cover common call situations without performance "
"penalty."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:74
msgid ""
"After an in-kernel function call, R1 - R5 are reset to unreadable and R0 has "
"a return value of the function. Since R6 - R9 are callee saved, their state "
"is preserved across the call."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:78
msgid "For example, consider three C functions::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:84
msgid "GCC can compile f1, f3 into x86_64::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:95
msgid "Function f2 in eBPF may look like::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:103
msgid ""
"If f2 is JITed and the pointer stored to ``_f2``. The calls f1 -> f2 -> f3 "
"and returns will be seamless. Without JIT, __bpf_prog_run() interpreter "
"needs to be used to call into f2."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:107
msgid ""
"For practical reasons all eBPF programs have only one argument 'ctx' which "
"is already placed into R1 (e.g. on __bpf_prog_run() startup) and the "
"programs can call kernel functions with up to 5 arguments. Calls with 6 or "
"more arguments are currently not supported, but these restrictions can be "
"lifted if necessary in the future."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:113
msgid ""
"On 64-bit architectures all register map to HW registers one to one. For "
"example, x86_64 JIT compiler can map them as ..."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:130
msgid ""
"... since x86_64 ABI mandates rdi, rsi, rdx, rcx, r8, r9 for argument "
"passing and rbx, r12 - r15 are callee saved."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:133
msgid "Then the following eBPF pseudo-program::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:151
msgid "After JIT to x86_64 may look like::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:177
msgid "Which is in this example equivalent in C to::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:184
msgid ""
"In-kernel functions foo() and bar() with prototype: u64 (*)(u64 arg1, u64 "
"arg2, u64 arg3, u64 arg4, u64 arg5); will receive arguments in proper "
"registers and place their return value into ``%rax`` which is R0 in eBPF. "
"Prologue and epilogue are emitted by JIT and are implicit in the "
"interpreter. R0-R5 are scratch registers, so eBPF program needs to preserve "
"them across the calls as defined by calling convention."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:191
msgid "For example the following program is invalid::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:198
msgid ""
"After the call the registers R1-R5 contain junk values and cannot be read. "
"An in-kernel verifier.rst is used to validate eBPF programs."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:201
msgid ""
"Also in the new design, eBPF is limited to 4096 insns, which means that any "
"program will terminate quickly and will only call a fixed number of kernel "
"functions. Original BPF and eBPF are two operand instructions, which helps "
"to do one-to-one mapping between eBPF insn and x86 insn during JIT."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:206
msgid ""
"The input context pointer for invoking the interpreter function is generic, "
"its content is defined by a specific use case. For seccomp register R1 "
"points to seccomp_data, for converted BPF filters R1 points to a skb."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:210
msgid ""
"A program, that is translated internally consists of the following elements::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:214
msgid ""
"So far 87 eBPF instructions were implemented. 8-bit 'op' opcode field has "
"room for new instructions. Some of them may use 16/24/32 byte encoding. New "
"instructions must be multiple of 8 bytes to preserve backward compatibility."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:218
msgid ""
"eBPF is a general purpose RISC instruction set. Not every register and every "
"instruction are used during translation from original BPF to eBPF. For "
"example, socket filters are not using ``exclusive add`` instruction, but "
"tracing filters may do to maintain counters of events, for example. Register "
"R9 is not used by socket filters either, but more complex filters may be "
"running out of registers and would have to resort to spill/fill to stack."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:225
msgid ""
"eBPF can be used as a generic assembler for last step performance "
"optimizations, socket filters and seccomp are using it as assembler. Tracing "
"filters may use it as assembler to generate code from kernel. In kernel "
"usage may not be bounded by security considerations, since generated eBPF "
"code may be optimizing internal code path and not being exposed to the user "
"space. Safety of eBPF can come from the verifier.rst. In such use cases as "
"described, it may be used as safe instruction set."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:233
msgid ""
"Just like the original BPF, eBPF runs within a controlled environment, is "
"deterministic and the kernel can easily prove that. The safety of the "
"program can be determined in two steps: first step does depth-first-search "
"to disallow loops and other CFG validation; second step starts from the "
"first insn and descends all possible paths. It simulates execution of every "
"insn and observes the state change of registers and stack."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:241
msgid "opcode encoding"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:243
msgid ""
"eBPF is reusing most of the opcode encoding from classic to simplify "
"conversion of classic BPF to eBPF."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:246
msgid ""
"For arithmetic and jump instructions the 8-bit 'code' field is divided into "
"three parts::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:255
msgid "Three LSB bits store instruction class which is one of:"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:258
msgid "Classic BPF classes"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:258
msgid "eBPF classes"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:260
msgid "BPF_LD    0x00"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:261
msgid "BPF_LDX   0x01"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:262
msgid "BPF_ST    0x02"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:263
msgid "BPF_STX   0x03"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:264
msgid "BPF_ALU   0x04"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:265
msgid "BPF_JMP   0x05"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:266
msgid "BPF_RET   0x06"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:266
msgid "BPF_JMP32 0x06"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:267
msgid "BPF_MISC  0x07"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:267
msgid "BPF_ALU64 0x07"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:270
msgid "The 4th bit encodes the source operand ..."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:277
msgid "in classic BPF, this means::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:282
msgid "in eBPF, this means::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:287
msgid "... and four MSB bits store operation code."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:289
msgid ""
"If BPF_CLASS(code) == BPF_ALU or BPF_ALU64 [ in eBPF ], BPF_OP(code) is one "
"of::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:306
msgid ""
"If BPF_CLASS(code) == BPF_JMP or BPF_JMP32 [ in eBPF ], BPF_OP(code) is one "
"of::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:323
msgid ""
"So BPF_ADD | BPF_X | BPF_ALU means 32-bit addition in both classic BPF and "
"eBPF. There are only two registers in classic BPF, so it means A += X. In "
"eBPF it means dst_reg = (u32) dst_reg + (u32) src_reg; similarly, BPF_XOR | "
"BPF_K | BPF_ALU means A ^= imm32 in classic BPF and analogous src_reg = "
"(u32) src_reg ^ (u32) imm32 in eBPF."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:329
msgid ""
"Classic BPF is using BPF_MISC class to represent A = X and X = A moves. eBPF "
"is using BPF_MOV | BPF_X | BPF_ALU code instead. Since there are no BPF_MISC "
"operations in eBPF, the class 7 is used as BPF_ALU64 to mean exactly the "
"same operations as BPF_ALU, but with 64-bit wide operands instead. So "
"BPF_ADD | BPF_X | BPF_ALU64 means 64-bit addition, i.e.: dst_reg = dst_reg + "
"src_reg"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:336
msgid ""
"Classic BPF wastes the whole BPF_RET class to represent a single ``ret`` "
"operation. Classic BPF_RET | BPF_K means copy imm32 into return register and "
"perform function exit. eBPF is modeled to match CPU, so BPF_JMP | BPF_EXIT "
"in eBPF means function exit only. The eBPF program needs to store return "
"value into register R0 before doing a BPF_EXIT. Class 6 in eBPF is used as "
"BPF_JMP32 to mean exactly the same operations as BPF_JMP, but with 32-bit "
"wide operands for the comparisons instead."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:344
msgid "For load and store instructions the 8-bit 'code' field is divided as::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:352
msgid "Size modifier is one of ..."
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:361
msgid "... which encodes size of load/store operation::"
msgstr ""

#: ../../../bpf/classic_vs_extended.rst:368
msgid "Mode modifier is one of::"
msgstr ""
