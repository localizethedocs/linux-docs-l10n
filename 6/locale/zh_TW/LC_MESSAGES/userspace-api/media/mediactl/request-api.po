# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/media/mediactl/request-api.rst:7
msgid "Request API"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:9
msgid ""
"The Request API has been designed to allow V4L2 to deal with requirements of "
"modern devices (stateless codecs, complex camera pipelines, ...) and APIs "
"(Android Codec v2). One such requirement is the ability for devices "
"belonging to the same pipeline to reconfigure and collaborate closely on a "
"per-frame basis. Another is support of stateless codecs, which require "
"controls to be applied to specific frames (aka 'per-frame controls') in "
"order to be used efficiently."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:16
msgid ""
"While the initial use-case was V4L2, it can be extended to other subsystems "
"as well, as long as they use the media controller."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:19
msgid ""
"Supporting these features without the Request API is not always possible and "
"if it is, it is terribly inefficient: user-space would have to flush all "
"activity on the media pipeline, reconfigure it for the next frame, queue the "
"buffers to be processed with that configuration, and wait until they are all "
"available for dequeuing before considering the next frame. This defeats the "
"purpose of having buffer queues since in practice only one buffer would be "
"queued at a time."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:26
msgid ""
"The Request API allows a specific configuration of the pipeline (media "
"controller topology + configuration for each media entity) to be associated "
"with specific buffers. This allows user-space to schedule several tasks "
"(\"requests\") with different configurations in advance, knowing that the "
"configuration will be applied when needed to get the expected result. "
"Configuration values at the time of request completion are also available "
"for reading."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:34
msgid "General Usage"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:36
msgid ""
"The Request API extends the Media Controller API and cooperates with "
"subsystem-specific APIs to support request usage. At the Media Controller "
"level, requests are allocated from the supporting Media Controller device "
"node. Their life cycle is then managed through the request file descriptors "
"in an opaque way. Configuration data, buffer handles and processing results "
"stored in requests are accessed through subsystem-specific APIs extended for "
"request support, such as V4L2 APIs that take an explicit ``request_fd`` "
"parameter."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:46
msgid "Request Allocation"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:48
msgid ""
"User-space allocates requests using :ref:`MEDIA_IOC_REQUEST_ALLOC` for the "
"media device node. This returns a file descriptor representing the request. "
"Typically, several such requests will be allocated."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:53
msgid "Request Preparation"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:55
msgid ""
"Standard V4L2 ioctls can then receive a request file descriptor to express "
"the fact that the ioctl is part of said request, and is not to be applied "
"immediately. See :ref:`MEDIA_IOC_REQUEST_ALLOC` for a list of ioctls that "
"support this. Configurations set with a ``request_fd`` parameter are stored "
"instead of being immediately applied, and buffers queued to a request do not "
"enter the regular buffer queue until the request itself is queued."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:63
msgid "Request Submission"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:65
msgid ""
"Once the configuration and buffers of the request are specified, it can be "
"queued by calling :ref:`MEDIA_REQUEST_IOC_QUEUE` on the request file "
"descriptor. A request must contain at least one buffer, otherwise ``ENOENT`` "
"is returned. A queued request cannot be modified anymore."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:71
msgid ""
"For :ref:`memory-to-memory devices <mem2mem>` you can use requests only for "
"output buffers, not for capture buffers. Attempting to add a capture buffer "
"to a request will result in an ``EBADR`` error."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:75
msgid ""
"If the request contains configurations for multiple entities, individual "
"drivers may synchronize so the requested pipeline's topology is applied "
"before the buffers are processed. Media controller drivers do a best effort "
"implementation since perfect atomicity may not be possible due to hardware "
"limitations."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:82
msgid ""
"It is not allowed to mix queuing requests with directly queuing buffers: "
"whichever method is used first locks this in place until :ref:"
"`VIDIOC_STREAMOFF <VIDIOC_STREAMON>` is called or the device is :ref:`closed "
"<func-close>`. Attempts to directly queue a buffer when earlier a buffer was "
"queued via a request or vice versa will result in an ``EBUSY`` error."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:89
msgid ""
"Controls can still be set without a request and are applied immediately, "
"regardless of whether a request is in use or not."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:94
msgid ""
"Setting the same control through a request and also directly can lead to "
"undefined behavior!"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:97
msgid ""
"User-space can :c:func:`poll()` a request file descriptor in order to wait "
"until the request completes. A request is considered complete once all its "
"associated buffers are available for dequeuing and all the associated "
"controls have been updated with the values at the time of completion. Note "
"that user-space does not need to wait for the request to complete to dequeue "
"its buffers: buffers that are available halfway through a request can be "
"dequeued independently of the request's state."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:105
msgid ""
"A completed request contains the state of the device after the request was "
"executed. User-space can query that state by calling :ref:`ioctl "
"VIDIOC_G_EXT_CTRLS <VIDIOC_G_EXT_CTRLS>` with the request file descriptor. "
"Calling :ref:`ioctl VIDIOC_G_EXT_CTRLS <VIDIOC_G_EXT_CTRLS>` for a request "
"that has been queued but not yet completed will return ``EBUSY`` since the "
"control values might be changed at any time by the driver while the request "
"is in flight."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:116
msgid "Recycling and Destruction"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:118
msgid ""
"Finally, a completed request can either be discarded or be reused. Calling :"
"c:func:`close()` on a request file descriptor will make that file descriptor "
"unusable and the request will be freed once it is no longer in use by the "
"kernel. That is, if the request is queued and then the file descriptor is "
"closed, then it won't be freed until the driver completed the request."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:125
msgid ""
"The :ref:`MEDIA_REQUEST_IOC_REINIT` will clear a request's state and make it "
"available again. No state is retained by this operation: the request is as "
"if it had just been allocated."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:130
msgid "Example for a Codec Device"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:132
msgid ""
"For use-cases such as :ref:`codecs <mem2mem>`, the request API can be used "
"to associate specific controls to be applied by the driver for the OUTPUT "
"buffer, allowing user-space to queue many such buffers in advance. It can "
"also take advantage of requests' ability to capture the state of controls "
"when the request completes to read back information that may be subject to "
"change."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:139
msgid ""
"Put into code, after obtaining a request, user-space can assign controls and "
"one OUTPUT buffer to it:"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:162
msgid ""
"Note that it is not allowed to use the Request API for CAPTURE buffers since "
"there are no per-frame settings to report there."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:165
#: ../../../userspace-api/media/mediactl/request-api.rst:245
msgid "Once the request is fully prepared, it can be queued to the driver:"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:172
msgid ""
"User-space can then either wait for the request to complete by calling "
"poll() on its file descriptor, or start dequeuing CAPTURE buffers. Most "
"likely, it will want to get CAPTURE buffers as soon as possible and this can "
"be done using a regular :ref:`VIDIOC_DQBUF <VIDIOC_QBUF>`:"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:186
msgid ""
"Note that this example assumes for simplicity that for every OUTPUT buffer "
"there will be one CAPTURE buffer, but this does not have to be the case."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:189
msgid ""
"We can then, after ensuring that the request is completed via polling the "
"request file descriptor, query control values at the time of its completion "
"via a call to :ref:`VIDIOC_G_EXT_CTRLS <VIDIOC_G_EXT_CTRLS>`. This is "
"particularly useful for volatile controls for which we want to query values "
"as soon as the capture buffer is produced."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:205
msgid ""
"Once we don't need the request anymore, we can either recycle it for reuse "
"with :ref:`MEDIA_REQUEST_IOC_REINIT`..."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:213
msgid "... or close its file descriptor to completely dispose of it."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:220
msgid "Example for a Simple Capture Device"
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:222
msgid ""
"With a simple capture device, requests can be used to specify controls to "
"apply for a given CAPTURE buffer."
msgstr ""

#: ../../../userspace-api/media/mediactl/request-api.rst:252
msgid ""
"User-space can then dequeue buffers, wait for the request completion, query "
"controls and recycle the request as in the M2M example above."
msgstr ""
