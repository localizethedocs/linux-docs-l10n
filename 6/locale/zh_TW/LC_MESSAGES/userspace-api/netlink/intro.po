# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/netlink/intro.rst:5
msgid "Introduction to Netlink"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:7
msgid ""
"Netlink is often described as an ioctl() replacement. It aims to replace "
"fixed-format C structures as supplied to ioctl() with a format which allows "
"an easy way to add or extended the arguments."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:12
msgid ""
"To achieve this Netlink uses a minimal fixed-format metadata header followed "
"by multiple attributes in the TLV (type, length, value) format."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:15
msgid ""
"Unfortunately the protocol has evolved over the years, in an organic and "
"undocumented fashion, making it hard to coherently explain. To make the most "
"practical sense this document starts by describing netlink as it is used "
"today and dives into more \"historical\" uses in later sections."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:22
msgid "Opening a socket"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:24
msgid ""
"Netlink communication happens over sockets, a socket needs to be opened "
"first:"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:31
msgid ""
"The use of sockets allows for a natural way of exchanging information in "
"both directions (to and from the kernel). The operations are still performed "
"synchronously when applications send() the request but a separate recv() "
"system call is needed to read the reply."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:36
msgid ""
"A very simplified flow of a Netlink \"call\" will therefore look something "
"like:"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:48
msgid ""
"Netlink also provides natural support for \"dumping\", i.e. communicating to "
"user space all objects of a certain type (e.g. dumping all network "
"interfaces)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:69
msgid ""
"The first two arguments of the socket() call require little explanation - it "
"is opening a Netlink socket, with all headers provided by the user (hence "
"NETLINK, RAW). The last argument is the protocol within Netlink. This field "
"used to identify the subsystem with which the socket will communicate."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:76
msgid "Classic vs Generic Netlink"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:78
msgid ""
"Initial implementation of Netlink depended on a static allocation of IDs to "
"subsystems and provided little supporting infrastructure. Let us refer to "
"those protocols collectively as **Classic Netlink**. The list of them is "
"defined on top of the ``include/uapi/linux/netlink.h`` file, they include "
"among others - general networking (NETLINK_ROUTE), iSCSI (NETLINK_ISCSI), "
"and audit (NETLINK_AUDIT)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:85
msgid ""
"**Generic Netlink** (introduced in 2005) allows for dynamic registration of "
"subsystems (and subsystem ID allocation), introspection and simplifies "
"implementing the kernel side of the interface."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:89
msgid ""
"The following section describes how to use Generic Netlink, as the number of "
"subsystems using Generic Netlink outnumbers the older protocols by an order "
"of magnitude. There are also no plans for adding more Classic Netlink "
"protocols to the kernel. Basic information on how communicating with core "
"networking parts of the Linux kernel (or another of the 20 subsystems using "
"Classic Netlink) differs from Generic Netlink is provided later in this "
"document."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:98
msgid "Generic Netlink"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:100
msgid ""
"In addition to the Netlink fixed metadata header each Netlink protocol "
"defines its own fixed metadata header. (Similarly to how network headers "
"stack - Ethernet > IP > TCP we have Netlink > Generic N. > Family.)"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:104
msgid ""
"A Netlink message always starts with struct nlmsghdr, which is followed by a "
"protocol-specific header. In case of Generic Netlink the protocol header is "
"struct genlmsghdr."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:108
msgid ""
"The practical meaning of the fields in case of Generic Netlink is as follows:"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:126
msgid ""
"In Classic Netlink :c:member:`nlmsghdr.nlmsg_type` used to identify which "
"operation within the subsystem the message was referring to (e.g. get "
"information about a netdev). Generic Netlink needs to mux multiple "
"subsystems in a single protocol so it uses this field to identify the "
"subsystem, and :c:member:`genlmsghdr.cmd` identifies the operation instead. "
"(See :ref:`res_fam` for information on how to find the Family ID of the "
"subsystem of interest.) Note that the first 16 values (0 - 15) of this field "
"are reserved for control messages both in Classic Netlink and Generic "
"Netlink. See :ref:`nl_msg_type` for more details."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:137
msgid "There are 3 usual types of message exchanges on a Netlink socket:"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:139
msgid "performing a single action (``do``);"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:140
msgid "dumping information (``dump``);"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:141
msgid "getting asynchronous notifications (``multicast``)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:143
msgid ""
"Classic Netlink is very flexible and presumably allows other types of "
"exchanges to happen, but in practice those are the three that get used."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:147
msgid ""
"Asynchronous notifications are sent by the kernel and received by the user "
"sockets which subscribed to them. ``do`` and ``dump`` requests are initiated "
"by the user. :c:member:`nlmsghdr.nlmsg_flags` should be set as follows:"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:152
msgid "for ``do``: ``NLM_F_REQUEST | NLM_F_ACK``"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:153
msgid "for ``dump``: ``NLM_F_REQUEST | NLM_F_ACK | NLM_F_DUMP``"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:155
msgid ""
":c:member:`nlmsghdr.nlmsg_seq` should be a set to a monotonically increasing "
"value. The value gets echoed back in responses and doesn't matter in "
"practice, but setting it to an increasing value for each message sent is "
"considered good hygiene. The purpose of the field is matching responses to "
"requests. Asynchronous notifications will have :c:member:`nlmsghdr."
"nlmsg_seq` of ``0``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:162
msgid ""
":c:member:`nlmsghdr.nlmsg_pid` is the Netlink equivalent of an address. This "
"field can be set to ``0`` when talking to the kernel. See :ref:`nlmsg_pid` "
"for the (uncommon) uses of the field."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:166
msgid ""
"The expected use for :c:member:`genlmsghdr.version` was to allow versioning "
"of the APIs provided by the subsystems. No subsystem to date made "
"significant use of this field, so setting it to ``1`` seems like a safe bet."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:174
msgid "Netlink message types"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:176
msgid ""
"As previously mentioned :c:member:`nlmsghdr.nlmsg_type` carries protocol "
"specific values but the first 16 identifiers are reserved (first subsystem "
"specific message type should be equal to ``NLMSG_MIN_TYPE`` which is "
"``0x10``)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:181
msgid "There are only 4 Netlink control messages defined:"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:183
msgid "``NLMSG_NOOP`` - ignore the message, not used in practice;"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:184
msgid "``NLMSG_ERROR`` - carries the return code of an operation;"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:185
msgid "``NLMSG_DONE`` - marks the end of a dump;"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:186
msgid "``NLMSG_OVERRUN`` - socket buffer has overflown, not used to date."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:188
msgid ""
"``NLMSG_ERROR`` and ``NLMSG_DONE`` are of practical importance. They carry "
"return codes for operations. Note that unless the ``NLM_F_ACK`` flag is set "
"on the request Netlink will not respond with ``NLMSG_ERROR`` if there is no "
"error. To avoid having to special-case this quirk it is recommended to "
"always set ``NLM_F_ACK``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:194
msgid "The format of ``NLMSG_ERROR`` is described by struct nlmsgerr::"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:208
msgid ""
"There are two instances of struct nlmsghdr here, first of the response and "
"second of the request. ``NLMSG_ERROR`` carries the information about the "
"request which led to the error. This could be useful when trying to match "
"requests to responses or re-parse the request to dump it into logs."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:214
msgid ""
"The payload of the request is not echoed in messages reporting success "
"(``error == 0``) or if ``NETLINK_CAP_ACK`` setsockopt() was set. The latter "
"is common and perhaps recommended as having to read a copy of every request "
"back from the kernel is rather wasteful. The absence of request payload is "
"indicated by ``NLM_F_CAPPED`` in :c:member:`nlmsghdr.nlmsg_flags`."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:221
msgid ""
"The second optional element of ``NLMSG_ERROR`` are the extended ACK "
"attributes. See :ref:`ext_ack` for more details. The presence of extended "
"ACK is indicated by ``NLM_F_ACK_TLVS`` in :c:member:`nlmsghdr.nlmsg_flags`."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:226
msgid ""
"``NLMSG_DONE`` is simpler, the request is never echoed but the extended ACK "
"attributes may be present::"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:237
msgid ""
"Note that some implementations may issue custom ``NLMSG_DONE`` messages in "
"reply to ``do`` action requests. In that case the payload is implementation-"
"specific and may also be absent."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:244
msgid "Resolving the Family ID"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:246
msgid ""
"This section explains how to find the Family ID of a subsystem. It also "
"serves as an example of Generic Netlink communication."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:249
msgid ""
"Generic Netlink is itself a subsystem exposed via the Generic Netlink API. "
"To avoid a circular dependency Generic Netlink has a statically allocated "
"Family ID (``GENL_ID_CTRL`` which is equal to ``NLMSG_MIN_TYPE``). The "
"Generic Netlink family implements a command used to find out information "
"about other families (``CTRL_CMD_GETFAMILY``)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:255
msgid ""
"To get information about the Generic Netlink family named for example "
"``\"test1\"`` we need to send a message on the previously opened Generic "
"Netlink socket. The message should target the Generic Netlink Family (1), be "
"a ``do`` (2) call to ``CTRL_CMD_GETFAMILY`` (3). A ``dump`` version of this "
"call would make the kernel respond with information about *all* the families "
"it knows about. Last but not least the name of the family in question has to "
"be specified (4) as an attribute with the appropriate type::"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:283
msgid ""
"The length fields in Netlink (:c:member:`nlmsghdr.nlmsg_len` and :c:member:"
"`nlattr.nla_len`) always *include* the header. Attribute headers in netlink "
"must be aligned to 4 bytes from the start of the message, hence the extra "
"``\\0\\0`` after ``CTRL_ATTR_FAMILY_NAME``. The attribute lengths *exclude* "
"the padding."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:289
msgid ""
"If the family is found kernel will reply with two messages, the response "
"with all the information about the family::"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:328
msgid ""
"And the error code (success) since ``NLM_F_ACK`` had been set on the "
"request::"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:347
msgid ""
"The order of attributes (struct nlattr) is not guaranteed so the user has to "
"walk the attributes and parse them."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:350
msgid ""
"Note that Generic Netlink sockets are not associated or bound to a single "
"family. A socket can be used to exchange messages with many different "
"families, selecting the recipient family on message-by-message basis using "
"the :c:member:`nlmsghdr.nlmsg_type` field."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:358
msgid "Extended ACK"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:360
msgid ""
"Extended ACK controls reporting of additional error/warning TLVs in "
"``NLMSG_ERROR`` and ``NLMSG_DONE`` messages. To maintain backward "
"compatibility this feature has to be explicitly enabled by setting the "
"``NETLINK_EXT_ACK`` setsockopt() to ``1``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:365
msgid ""
"Types of extended ack attributes are defined in enum nlmsgerr_attrs. The "
"most commonly used attributes are ``NLMSGERR_ATTR_MSG``, "
"``NLMSGERR_ATTR_OFFS`` and ``NLMSGERR_ATTR_MISS_*``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:369
msgid ""
"``NLMSGERR_ATTR_MSG`` carries a message in English describing the "
"encountered problem. These messages are far more detailed than what can be "
"expressed thru standard UNIX error codes."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:373
msgid ""
"``NLMSGERR_ATTR_OFFS`` points to the attribute which caused the problem."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:375
msgid ""
"``NLMSGERR_ATTR_MISS_TYPE`` and ``NLMSGERR_ATTR_MISS_NEST`` inform about a "
"missing attribute."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:378
msgid ""
"Extended ACKs can be reported on errors as well as in case of success. The "
"latter should be treated as a warning."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:381
msgid ""
"Extended ACKs greatly improve the usability of Netlink and should always be "
"enabled, appropriately parsed and reported to the user."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:385
msgid "Advanced topics"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:388
msgid "Dump consistency"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:390
msgid ""
"Some of the data structures kernel uses for storing objects make it hard to "
"provide an atomic snapshot of all the objects in a dump (without impacting "
"the fast-paths updating them)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:394
msgid ""
"Kernel may set the ``NLM_F_DUMP_INTR`` flag on any message in a dump "
"(including the ``NLMSG_DONE`` message) if the dump was interrupted and may "
"be inconsistent (e.g. missing objects). User space should retry the dump if "
"it sees the flag set."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:400
msgid "Introspection"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:402
msgid ""
"The basic introspection abilities are enabled by access to the Family object "
"as reported in :ref:`res_fam`. User can query information about the Generic "
"Netlink family, including which operations are supported by the kernel and "
"what attributes the kernel understands. Family information includes the "
"highest ID of an attribute kernel can parse, a separate command "
"(``CTRL_CMD_GETPOLICY``) provides detailed information about supported "
"attributes, including ranges of values the kernel accepts."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:410
msgid ""
"Querying family information is useful in cases when user space needs to make "
"sure that the kernel has support for a feature before issuing a request."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:417
msgid "nlmsg_pid"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:419
msgid ""
":c:member:`nlmsghdr.nlmsg_pid` is the Netlink equivalent of an address. It "
"is referred to as Port ID, sometimes Process ID because for historical "
"reasons if the application does not select (bind() to) an explicit Port ID "
"kernel will automatically assign it the ID equal to its Process ID (as "
"reported by the getpid() system call)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:425
msgid ""
"Similarly to the bind() semantics of the TCP/IP network protocols the value "
"of zero means \"assign automatically\", hence it is common for applications "
"to leave the :c:member:`nlmsghdr.nlmsg_pid` field initialized to ``0``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:429
msgid ""
"The field is still used today in rare cases when kernel needs to send a "
"unicast notification. User space application can use bind() to associate its "
"socket with a specific PID, it then communicates its PID to the kernel. This "
"way the kernel can reach the specific user space process."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:434
msgid ""
"This sort of communication is utilized in UMH (User Mode Helper)-like "
"scenarios when kernel needs to trigger user space processing or ask user "
"space for a policy decision."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:439
msgid "Multicast notifications"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:441
msgid ""
"One of the strengths of Netlink is the ability to send event notifications "
"to user space. This is a unidirectional form of communication (kernel -> "
"user) and does not involve any control messages like ``NLMSG_ERROR`` or "
"``NLMSG_DONE``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:446
msgid ""
"For example the Generic Netlink family itself defines a set of multicast "
"notifications about registered families. When a new family is added the "
"sockets subscribed to the notifications will get the following message::"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:485
msgid ""
"The notification contains the same information as the response to the "
"``CTRL_CMD_GETFAMILY`` request."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:488
msgid ""
"The Netlink headers of the notification are mostly 0 and irrelevant. The :c:"
"member:`nlmsghdr.nlmsg_seq` may be either zero or a monotonically increasing "
"notification sequence number maintained by the family."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:492
msgid ""
"To receive notifications the user socket must subscribe to the relevant "
"notification group. Much like the Family ID, the Group ID for a given "
"multicast group is dynamic and can be found inside the Family information. "
"The ``CTRL_ATTR_MCAST_GROUPS`` attribute contains nests with names "
"(``CTRL_ATTR_MCAST_GRP_NAME``) and IDs (``CTRL_ATTR_MCAST_GRP_ID``) of the "
"groups family."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:499
msgid ""
"Once the Group ID is known a setsockopt() call adds the socket to the group:"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:510
msgid "The socket will now receive notifications."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:512
msgid ""
"It is recommended to use separate sockets for receiving notifications and "
"sending requests to the kernel. The asynchronous nature of notifications "
"means that they may get mixed in with the responses making the message "
"handling much harder."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:518
msgid "Buffer sizing"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:520
msgid ""
"Netlink sockets are datagram sockets rather than stream sockets, meaning "
"that each message must be received in its entirety by a single recv()/"
"recvmsg() system call. If the buffer provided by the user is too short, the "
"message will be truncated and the ``MSG_TRUNC`` flag set in struct msghdr "
"(struct msghdr is the second argument of the recvmsg() system call, *not* a "
"Netlink header)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:527
msgid "Upon truncation the remaining part of the message is discarded."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:529
msgid ""
"Netlink expects that the user buffer will be at least 8kB or a page size of "
"the CPU architecture, whichever is bigger. Particular Netlink families may, "
"however, require a larger buffer. 32kB buffer is recommended for most "
"efficient handling of dumps (larger buffer fits more dumped objects and "
"therefore fewer recvmsg() calls are needed)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:538
msgid "Classic Netlink"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:540
msgid ""
"The main differences between Classic and Generic Netlink are the dynamic "
"allocation of subsystem identifiers and availability of introspection. In "
"theory the protocol does not differ significantly, however, in practice "
"Classic Netlink experimented with concepts which were abandoned in Generic "
"Netlink (really, they usually only found use in a small corner of a single "
"subsystem). This section is meant as an explainer of a few of such concepts, "
"with the explicit goal of giving the Generic Netlink users the confidence to "
"ignore them when reading the uAPI headers."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:549
msgid ""
"Most of the concepts and examples here refer to the ``NETLINK_ROUTE`` "
"family, which covers much of the configuration of the Linux networking "
"stack. Real documentation of that family, deserves a chapter (or a book) of "
"its own."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:554
msgid "Families"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:556
msgid ""
"Netlink refers to subsystems as families. This is a remnant of using sockets "
"and the concept of protocol families, which are part of message "
"demultiplexing in ``NETLINK_ROUTE``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:560
msgid ""
"Sadly every layer of encapsulation likes to refer to whatever it's carrying "
"as \"families\" making the term very confusing:"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:563
msgid "AF_NETLINK is a bona fide socket protocol family"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:564
msgid ""
"AF_NETLINK's documentation refers to what comes after its own header (struct "
"nlmsghdr) in a message as a \"Family Header\""
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:566
msgid ""
"Generic Netlink is a family for AF_NETLINK (struct genlmsghdr follows struct "
"nlmsghdr), yet it also calls its users \"Families\"."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:569
msgid ""
"Note that the Generic Netlink Family IDs are in a different \"ID space\" and "
"overlap with Classic Netlink protocol numbers (e.g. ``NETLINK_CRYPTO`` has "
"the Classic Netlink protocol ID of 21 which Generic Netlink will happily "
"allocate to one of its families as well)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:575
msgid "Strict checking"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:577
msgid ""
"The ``NETLINK_GET_STRICT_CHK`` socket option enables strict input checking "
"in ``NETLINK_ROUTE``. It was needed because historically kernel did not "
"validate the fields of structures it didn't process. This made it impossible "
"to start using those fields later without risking regressions in "
"applications which initialized them incorrectly or not at all."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:583
msgid ""
"``NETLINK_GET_STRICT_CHK`` declares that the application is initializing all "
"fields correctly. It also opts into validating that message does not contain "
"trailing data and requests that kernel rejects attributes with type higher "
"than largest attribute type known to the kernel."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:588
msgid "``NETLINK_GET_STRICT_CHK`` is not used outside of ``NETLINK_ROUTE``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:591
msgid "Unknown attributes"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:593
msgid ""
"Historically Netlink ignored all unknown attributes. The thinking was that "
"it would free the application from having to probe what kernel supports. The "
"application could make a request to change the state and check which parts "
"of the request \"stuck\"."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:598
msgid ""
"This is no longer the case for new Generic Netlink families and those opting "
"in to strict checking. See enum netlink_validation for validation types "
"performed."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:603
msgid "Fixed metadata and structures"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:605
msgid ""
"Classic Netlink made liberal use of fixed-format structures within the "
"messages. Messages would commonly have a structure with a considerable "
"number of fields after struct nlmsghdr. It was also common to put structures "
"with multiple members inside attributes, without breaking each member into "
"an attribute of its own."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:611
msgid ""
"This has caused problems with validation and extensibility and therefore "
"using binary structures is actively discouraged for new attributes."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:616
msgid "Request types"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:618
msgid ""
"``NETLINK_ROUTE`` categorized requests into 4 types ``NEW``, ``DEL``, "
"``GET``, and ``SET``. Each object can handle all or some of those requests "
"(objects being netdevs, routes, addresses, qdiscs etc.) Request type is "
"defined by the 2 lowest bits of the message type, so commands for new "
"objects would always be allocated with a stride of 4."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:624
msgid ""
"Each object would also have its own fixed metadata shared by all request "
"types (e.g. struct ifinfomsg for netdev requests, struct ifaddrmsg for "
"address requests, struct tcmsg for qdisc requests)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:628
msgid ""
"Even though other protocols and Generic Netlink commands often use the same "
"verbs in their message names (``GET``, ``SET``) the concept of request types "
"did not find wider adoption."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:633
msgid "Notification echo"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:635
msgid ""
"``NLM_F_ECHO`` requests for notifications resulting from the request to be "
"queued onto the requesting socket. This is useful to discover the impact of "
"the request."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:639
msgid "Note that this feature is not universally implemented."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:642
msgid "Other request-type-specific flags"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:644
msgid ""
"Classic Netlink defined various flags for its ``GET``, ``NEW`` and ``DEL`` "
"requests in the upper byte of nlmsg_flags in struct nlmsghdr. Since request "
"types have not been generalized the request type specific flags are rarely "
"used (and considered deprecated for new families)."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:649
msgid ""
"For ``GET`` - ``NLM_F_ROOT`` and ``NLM_F_MATCH`` are combined into "
"``NLM_F_DUMP``, and not used separately. ``NLM_F_ATOMIC`` is never used."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:652
msgid ""
"For ``DEL`` - ``NLM_F_NONREC`` is only used by nftables and ``NLM_F_BULK`` "
"only by FDB some operations."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:655
msgid ""
"The flags for ``NEW`` are used most commonly in classic Netlink. "
"Unfortunately, the meaning is not crystal clear. The following description "
"is based on the best guess of the intention of the authors, and in practice "
"all families stray from it in one way or another. ``NLM_F_REPLACE`` asks to "
"replace an existing object, if no matching object exists the operation "
"should fail. ``NLM_F_EXCL`` has the opposite semantics and only succeeds if "
"object already existed. ``NLM_F_CREATE`` asks for the object to be created "
"if it does not exist, it can be combined with ``NLM_F_REPLACE`` and "
"``NLM_F_EXCL``."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:665
msgid "A comment in the main Netlink uAPI header states::"
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:674
msgid ""
"which seems to indicate that those flags predate request types. "
"``NLM_F_REPLACE`` without ``NLM_F_CREATE`` was initially used instead of "
"``SET`` commands. ``NLM_F_EXCL`` without ``NLM_F_CREATE`` was used to check "
"if object exists without creating it, presumably predating ``GET`` commands."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:680
msgid ""
"``NLM_F_APPEND`` indicates that if one key can have multiple objects "
"associated with it (e.g. multiple next-hop objects for a route) the new "
"object should be added to the list rather than replacing the entire list."
msgstr ""

#: ../../../userspace-api/netlink/intro.rst:685
msgid "uAPI reference"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:45
msgid "fixed format metadata header of Netlink messages"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:49
msgid "**Definition**::"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:59
msgid "**Members**"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:46
msgid "``nlmsg_len``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:47
msgid "Length of message including header"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:47
msgid "``nlmsg_type``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:48
msgid "Message content type"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:48
msgid "``nlmsg_flags``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:49
msgid "Additional flags"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:49
msgid "``nlmsg_seq``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:50
msgid "Sequence number"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:50
msgid "``nlmsg_pid``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:51
msgid "Sending process port ID"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:134
msgid "nlmsgerr attributes"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:138
#: include/uapi/linux/netlink.h:281 include/uapi/linux/netlink.h:337
msgid "**Constants**"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:140
msgid "``NLMSGERR_ATTR_UNUSED``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:141
#: include/uapi/linux/netlink.h:284 include/uapi/linux/netlink.h:340
msgid "unused"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:143
msgid "``NLMSGERR_ATTR_MSG``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:144
msgid "error message string (string)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:146
msgid "``NLMSGERR_ATTR_OFFS``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:147
msgid ""
"offset of the invalid attribute in the original message, counting from the "
"beginning of the header (u32)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:150
msgid "``NLMSGERR_ATTR_COOKIE``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:151
msgid ""
"arbitrary subsystem specific cookie to be used - in the success case - to "
"identify a created object or operation or similar (binary)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:155
msgid "``NLMSGERR_ATTR_POLICY``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:156
msgid "policy for a rejected attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:158
msgid "``NLMSGERR_ATTR_MISS_TYPE``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:159
msgid ""
"type of a missing required attribute, ``NLMSGERR_ATTR_MISS_NEST`` will not "
"be present if the attribute was missing at the message level"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:163
msgid "``NLMSGERR_ATTR_MISS_NEST``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:164
msgid "offset of the nest where attribute was missing"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:166
msgid "``__NLMSGERR_ATTR_MAX``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:167
#: include/uapi/linux/netlink.h:391
msgid "number of attributes"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:169
msgid "``NLMSGERR_ATTR_MAX``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:170
#: include/uapi/linux/netlink.h:394
msgid "highest attribute number"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:277
msgid "type of an attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:283
msgid "``NL_ATTR_TYPE_INVALID``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:286
msgid "``NL_ATTR_TYPE_FLAG``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:287
msgid "flag attribute (present/not present)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:289
msgid "``NL_ATTR_TYPE_U8``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:290
msgid "8-bit unsigned attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:292
msgid "``NL_ATTR_TYPE_U16``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:293
msgid "16-bit unsigned attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:295
msgid "``NL_ATTR_TYPE_U32``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:296
msgid "32-bit unsigned attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:298
msgid "``NL_ATTR_TYPE_U64``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:299
msgid "64-bit unsigned attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:301
msgid "``NL_ATTR_TYPE_S8``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:302
msgid "8-bit signed attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:304
msgid "``NL_ATTR_TYPE_S16``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:305
msgid "16-bit signed attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:307
msgid "``NL_ATTR_TYPE_S32``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:308
msgid "32-bit signed attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:310
msgid "``NL_ATTR_TYPE_S64``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:311
msgid "64-bit signed attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:313
msgid "``NL_ATTR_TYPE_BINARY``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:314
msgid "binary data, min/max length may be specified"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:316
msgid "``NL_ATTR_TYPE_STRING``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:317
msgid "string, min/max length may be specified"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:319
msgid "``NL_ATTR_TYPE_NUL_STRING``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:320
msgid "NUL-terminated string, min/max length may be specified"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:323
msgid "``NL_ATTR_TYPE_NESTED``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:324
msgid ""
"nested, i.e. the content of this attribute consists of sub-attributes. The "
"nested policy and maxtype inside may be specified."
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:328
msgid "``NL_ATTR_TYPE_NESTED_ARRAY``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:329
msgid ""
"nested array, i.e. the content of this attribute contains sub-attributes "
"whose type is irrelevant (just used to separate the array entries) and each "
"such array entry has attributes again, the policy for those inner ones and "
"the corresponding maxtype may be specified."
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:335
msgid "``NL_ATTR_TYPE_BITFIELD32``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:336
msgid ":c:type:`struct nla_bitfield32 <nla_bitfield32>` attribute"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:338
msgid "``NL_ATTR_TYPE_SINT``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:339
msgid "32-bit or 64-bit signed attribute, aligned to 4B"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:341
msgid "``NL_ATTR_TYPE_UINT``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:342
msgid "32-bit or 64-bit unsigned attribute, aligned to 4B"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:333
msgid "policy type attributes"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:339
msgid "``NL_POLICY_TYPE_ATTR_UNSPEC``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:342
msgid "``NL_POLICY_TYPE_ATTR_TYPE``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:343
msgid ""
"type of the attribute, :c:type:`enum netlink_attribute_type "
"<netlink_attribute_type>` (U32)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:346
msgid "``NL_POLICY_TYPE_ATTR_MIN_VALUE_S``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:347
msgid "minimum value for signed integers (S64)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:350
msgid "``NL_POLICY_TYPE_ATTR_MAX_VALUE_S``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:351
msgid "maximum value for signed integers (S64)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:354
msgid "``NL_POLICY_TYPE_ATTR_MIN_VALUE_U``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:355
msgid "minimum value for unsigned integers (U64)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:358
msgid "``NL_POLICY_TYPE_ATTR_MAX_VALUE_U``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:359
msgid "maximum value for unsigned integers (U64)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:362
msgid "``NL_POLICY_TYPE_ATTR_MIN_LENGTH``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:363
msgid "minimum length for binary attributes, no minimum if not given (U32)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:366
msgid "``NL_POLICY_TYPE_ATTR_MAX_LENGTH``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:367
msgid "maximum length for binary attributes, no maximum if not given (U32)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:370
msgid "``NL_POLICY_TYPE_ATTR_POLICY_IDX``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:371
msgid "sub policy for nested and nested array types (U32)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:374
msgid "``NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:375
msgid ""
"maximum sub policy attribute for nested and nested array types, this can in "
"theory be < the size of the policy pointed to by the index, if limited "
"inside the nesting (U32)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:380
msgid "``NL_POLICY_TYPE_ATTR_BITFIELD32_MASK``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:381
msgid "valid mask for the bitfield32 type (U32)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:384
msgid "``NL_POLICY_TYPE_ATTR_PAD``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:385
msgid "pad attribute for 64-bit alignment"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:387
msgid "``NL_POLICY_TYPE_ATTR_MASK``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:388
msgid "mask of valid bits for unsigned integers (U64)"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:390
msgid "``__NL_POLICY_TYPE_ATTR_MAX``"
msgstr ""

#: ../../../userspace-api/netlink/intro:687: include/uapi/linux/netlink.h:393
msgid "``NL_POLICY_TYPE_ATTR_MAX``"
msgstr ""
