# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/j1939.rst:5
msgid "J1939 Documentation"
msgstr ""

#: ../../../networking/j1939.rst:8
msgid "Overview / What Is J1939"
msgstr ""

#: ../../../networking/j1939.rst:10
msgid ""
"SAE J1939 defines a higher layer protocol on CAN. It implements a more "
"sophisticated addressing scheme and extends the maximum packet size above 8 "
"bytes. Several derived specifications exist, which differ from the original "
"J1939 on the application level, like MilCAN A, NMEA2000, and especially "
"ISO-11783 (ISOBUS). This last one specifies the so-called ETP (Extended "
"Transport Protocol), which has been included in this implementation. This "
"results in a maximum packet size of ((2 ^ 24) - 1) * 7 bytes == 111 MiB."
msgstr ""

#: ../../../networking/j1939.rst:19
msgid "Specifications used"
msgstr ""

#: ../../../networking/j1939.rst:21
msgid "SAE J1939-21 : data link layer"
msgstr ""

#: ../../../networking/j1939.rst:22
msgid "SAE J1939-81 : network management"
msgstr ""

#: ../../../networking/j1939.rst:23
msgid "ISO 11783-6  : Virtual Terminal (Extended Transport Protocol)"
msgstr ""

#: ../../../networking/j1939.rst:28
msgid "Motivation"
msgstr ""

#: ../../../networking/j1939.rst:30
msgid ""
"Given the fact there's something like SocketCAN with an API similar to BSD "
"sockets, we found some reasons to justify a kernel implementation for the "
"addressing and transport methods used by J1939."
msgstr ""

#: ../../../networking/j1939.rst:34
msgid ""
"**Addressing:** when a process on an ECU communicates via J1939, it should "
"not necessarily know its source address. Although, at least one process per "
"ECU should know the source address. Other processes should be able to reuse "
"that address. This way, address parameters for different processes "
"cooperating for the same ECU, are not duplicated. This way of working is "
"closely related to the UNIX concept, where programs do just one thing and do "
"it well."
msgstr ""

#: ../../../networking/j1939.rst:42
msgid ""
"**Dynamic addressing:** Address Claiming in J1939 is time critical. "
"Furthermore, data transport should be handled properly during the address "
"negotiation. Putting this functionality in the kernel eliminates it as a "
"requirement for _every_ user space process that communicates via J1939. This "
"results in a consistent J1939 bus with proper addressing."
msgstr ""

#: ../../../networking/j1939.rst:48
msgid ""
"**Transport:** both TP & ETP reuse some PGNs to relay big packets over them. "
"Different processes may thus use the same TP & ETP PGNs without actually "
"knowing it. The individual TP & ETP sessions _must_ be serialized "
"(synchronized) between different processes. The kernel solves this problem "
"properly and eliminates the serialization (synchronization) as a requirement "
"for _every_ user space process that communicates via J1939."
msgstr ""

#: ../../../networking/j1939.rst:55
msgid ""
"J1939 defines some other features (relaying, gateway, fast packet "
"transport, ...). In-kernel code for these would not contribute to protocol "
"stability. Therefore, these parts are left to user space."
msgstr ""

#: ../../../networking/j1939.rst:59
msgid ""
"The J1939 sockets operate on CAN network devices (see SocketCAN). Any J1939 "
"user space library operating on CAN raw sockets will still operate properly. "
"Since such a library does not communicate with the in-kernel implementation, "
"care must be taken that these two do not interfere. In practice, this means "
"they cannot share ECU addresses. A single ECU (or virtual ECU) address is "
"used by the library exclusively, or by the in-kernel system exclusively."
msgstr ""

#: ../../../networking/j1939.rst:67
msgid "J1939 concepts"
msgstr ""

#: ../../../networking/j1939.rst:70
msgid "Data Sent to the J1939 Stack"
msgstr ""

#: ../../../networking/j1939.rst:72
msgid ""
"The data buffers sent to the J1939 stack from user space are not CAN frames "
"themselves. Instead, they are payloads that the J1939 stack converts into "
"proper CAN frames based on the size of the buffer and the type of transfer. "
"The size of the buffer influences how the stack processes the data and "
"determines the internal code path used for the transfer."
msgstr ""

#: ../../../networking/j1939.rst:78
msgid "**Handling of Different Buffer Sizes:**"
msgstr ""

#: ../../../networking/j1939.rst:80
msgid "**Buffers with a size of 8 bytes or less:**"
msgstr ""

#: ../../../networking/j1939.rst:82
msgid "These are handled as simple sessions internally within the stack."
msgstr ""

#: ../../../networking/j1939.rst:84
msgid ""
"The stack converts the buffer directly into a single CAN frame without "
"fragmentation."
msgstr ""

#: ../../../networking/j1939.rst:87
msgid ""
"This type of transfer does not require an actual client (receiver) on the "
"receiving side."
msgstr ""

#: ../../../networking/j1939.rst:90
msgid "**Buffers up to 1785 bytes:**"
msgstr ""

#: ../../../networking/j1939.rst:92
msgid ""
"These are automatically handled as J1939 Transport Protocol (TP) transfers."
msgstr ""

#: ../../../networking/j1939.rst:94
msgid ""
"Internally, the stack splits the buffer into multiple 8-byte CAN frames."
msgstr ""

#: ../../../networking/j1939.rst:96
msgid "TP transfers can be unicast or broadcast."
msgstr ""

#: ../../../networking/j1939.rst:98
msgid ""
"**Broadcast TP:** Does not require a receiver on the other side and can be "
"used in broadcast scenarios."
msgstr ""

#: ../../../networking/j1939.rst:101
msgid ""
"**Unicast TP:** Requires an active receiver (client) on the other side to "
"acknowledge the transfer."
msgstr ""

#: ../../../networking/j1939.rst:104
msgid "**Buffers from 1786 bytes up to 111 MiB:**"
msgstr ""

#: ../../../networking/j1939.rst:106
msgid ""
"These are handled as ISO 11783 Extended Transport Protocol (ETP) transfers."
msgstr ""

#: ../../../networking/j1939.rst:108
msgid ""
"ETP transfers are used for larger payloads and are split into multiple CAN "
"frames internally."
msgstr ""

#: ../../../networking/j1939.rst:111
msgid ""
"**ETP transfers (unicast):** Require a receiver on the other side to process "
"the incoming data and acknowledge each step of the transfer."
msgstr ""

#: ../../../networking/j1939.rst:114
msgid ""
"ETP transfers cannot be broadcast like TP transfers, and always require a "
"receiver for operation."
msgstr ""

#: ../../../networking/j1939.rst:117
msgid "**Non-Blocking Operation with `MSG_DONTWAIT`:**"
msgstr ""

#: ../../../networking/j1939.rst:119
msgid ""
"The J1939 stack supports non-blocking operation when used in combination "
"with the `MSG_DONTWAIT` flag. In this mode, the stack attempts to take as "
"much data as the available memory for the socket allows. It returns the "
"amount of data that was successfully taken, and it is the responsibility of "
"user space to monitor this value and handle partial transfers."
msgstr ""

#: ../../../networking/j1939.rst:125
msgid ""
"If the stack cannot take the entire buffer, it returns the number of bytes "
"successfully taken, and user space should handle the remainder."
msgstr ""

#: ../../../networking/j1939.rst:128
msgid ""
"**Error handling:** When using `MSG_DONTWAIT`, the user must rely on the "
"error queue to detect transfer errors. See the **SO_J1939_ERRQUEUE** section "
"for details on how to subscribe to error notifications. Without the error "
"queue, there is no other way for user space to be notified of transfer "
"errors during non-blocking operations."
msgstr ""

#: ../../../networking/j1939.rst:134
msgid "**Behavior and Requirements:**"
msgstr ""

#: ../../../networking/j1939.rst:136
msgid ""
"**Simple transfers (<= 8 bytes):** Do not require a receiver on the other "
"side, making them easy to send without needing address claiming or "
"coordination with a destination."
msgstr ""

#: ../../../networking/j1939.rst:140
msgid ""
"**Unicast TP/ETP:** Requires a receiver on the other side to complete the "
"transfer. The receiver must acknowledge the transfer for the session to "
"proceed successfully."
msgstr ""

#: ../../../networking/j1939.rst:144
msgid ""
"**Broadcast TP:** Allows sending data without a receiver, but only works for "
"TP transfers. ETP cannot be broadcast and always needs a receiving client."
msgstr ""

#: ../../../networking/j1939.rst:147
msgid ""
"These different behaviors depend heavily on the size of the buffer provided "
"to the stack, and the appropriate transport mechanism (TP or ETP) is "
"selected based on the payload size. The stack automatically manages the "
"fragmentation and reassembly of large payloads and ensures that the correct "
"CAN frames are generated and transmitted for each session."
msgstr ""

#: ../../../networking/j1939.rst:154 ../../../networking/j1939.rst:165
#: ../../../networking/j1939.rst:172 ../../../networking/j1939.rst:243
msgid "PGN"
msgstr ""

#: ../../../networking/j1939.rst:156
msgid ""
"The J1939 protocol uses the 29-bit CAN identifier with the following "
"structure:"
msgstr ""

#: ../../../networking/j1939.rst:159
msgid "29 bit CAN-ID"
msgstr ""

#: ../../../networking/j1939.rst:161 ../../../networking/j1939.rst:174
#: ../../../networking/j1939.rst:189 ../../../networking/j1939.rst:199
msgid "Bit positions within the CAN-ID"
msgstr ""

#: ../../../networking/j1939.rst:163
msgid "28 ... 26"
msgstr ""

#: ../../../networking/j1939.rst:163
msgid "25 ... 8"
msgstr ""

#: ../../../networking/j1939.rst:163
msgid "7 ... 0"
msgstr ""

#: ../../../networking/j1939.rst:165
msgid "Priority"
msgstr ""

#: ../../../networking/j1939.rst:165
msgid "SA (Source Address)"
msgstr ""

#: ../../../networking/j1939.rst:168
msgid ""
"The PGN (Parameter Group Number) is a number to identify a packet. The PGN "
"is composed as follows:"
msgstr ""

#: ../../../networking/j1939.rst:176
msgid "25"
msgstr ""

#: ../../../networking/j1939.rst:176
msgid "24"
msgstr ""

#: ../../../networking/j1939.rst:176 ../../../networking/j1939.rst:191
#: ../../../networking/j1939.rst:201
msgid "23 ... 16"
msgstr ""

#: ../../../networking/j1939.rst:176 ../../../networking/j1939.rst:191
#: ../../../networking/j1939.rst:201
msgid "15 ... 8"
msgstr ""

#: ../../../networking/j1939.rst:178
msgid "R (Reserved)"
msgstr ""

#: ../../../networking/j1939.rst:178
msgid "DP (Data Page)"
msgstr ""

#: ../../../networking/j1939.rst:178
msgid "PF (PDU Format)"
msgstr ""

#: ../../../networking/j1939.rst:178
msgid "PS (PDU Specific)"
msgstr ""

#: ../../../networking/j1939.rst:181
msgid ""
"In J1939-21 distinction is made between PDU1 format (where PF < 240) and "
"PDU2 format (where PF >= 240). Furthermore, when using the PDU2 format, the "
"PS-field contains a so-called Group Extension, which is part of the PGN. "
"When using PDU2 format, the Group Extension is set in the PS-field."
msgstr ""

#: ../../../networking/j1939.rst:187
msgid "PDU1 Format (specific) (peer to peer)"
msgstr ""

#: ../../../networking/j1939.rst:193
msgid "00h ... EFh"
msgstr ""

#: ../../../networking/j1939.rst:193
msgid "DA (Destination address)"
msgstr ""

#: ../../../networking/j1939.rst:197
msgid "PDU2 Format (global) (broadcast)"
msgstr ""

#: ../../../networking/j1939.rst:203
msgid "F0h ... FFh"
msgstr ""

#: ../../../networking/j1939.rst:203
msgid "GE (Group Extension)"
msgstr ""

#: ../../../networking/j1939.rst:206
msgid ""
"On the other hand, when using PDU1 format, the PS-field contains a so-called "
"Destination Address, which is _not_ part of the PGN. When communicating a "
"PGN from user space to kernel (or vice versa) and PDU1 format is used, the "
"PS-field of the PGN shall be set to zero. The Destination Address shall be "
"set elsewhere."
msgstr ""

#: ../../../networking/j1939.rst:212
msgid ""
"Regarding PGN mapping to 29-bit CAN identifier, the Destination Address "
"shall be get/set from/to the appropriate bits of the identifier by the "
"kernel."
msgstr ""

#: ../../../networking/j1939.rst:217
msgid "Addressing"
msgstr ""

#: ../../../networking/j1939.rst:219
msgid "Both static and dynamic addressing methods can be used."
msgstr ""

#: ../../../networking/j1939.rst:221
msgid ""
"For static addresses, no extra checks are made by the kernel and provided "
"addresses are considered right. This responsibility is for the OEM or system "
"integrator."
msgstr ""

#: ../../../networking/j1939.rst:225
msgid ""
"For dynamic addressing, so-called Address Claiming, extra support is "
"foreseen in the kernel. In J1939 any ECU is known by its 64-bit NAME. At the "
"moment of a successful address claim, the kernel keeps track of both NAME "
"and source address being claimed. This serves as a base for filter schemes. "
"By default, packets with a destination that is not locally will be rejected."
msgstr ""

#: ../../../networking/j1939.rst:231
msgid ""
"Mixed mode packets (from a static to a dynamic address or vice versa) are "
"allowed. The BSD sockets define separate API calls for getting/setting the "
"local & remote address and are applicable for J1939 sockets."
msgstr ""

#: ../../../networking/j1939.rst:236
msgid "Filtering"
msgstr ""

#: ../../../networking/j1939.rst:238
msgid ""
"J1939 defines white list filters per socket that a user can set in order to "
"receive a subset of the J1939 traffic. Filtering can be based on:"
msgstr ""

#: ../../../networking/j1939.rst:241
msgid "SA"
msgstr ""

#: ../../../networking/j1939.rst:242
msgid "SOURCE_NAME"
msgstr ""

#: ../../../networking/j1939.rst:245
msgid ""
"When multiple filters are in place for a single socket, and a packet comes "
"in that matches several of those filters, the packet is only received once "
"for that socket."
msgstr ""

#: ../../../networking/j1939.rst:250
msgid "How to Use J1939"
msgstr ""

#: ../../../networking/j1939.rst:253
msgid "API Calls"
msgstr ""

#: ../../../networking/j1939.rst:255
msgid ""
"On CAN, you first need to open a socket for communicating over a CAN "
"network. To use J1939, ``#include <linux/can/j1939.h>``. From there, "
"``<linux/can.h>`` will be included too. To open a socket, use:"
msgstr ""

#: ../../../networking/j1939.rst:263
msgid ""
"J1939 does use ``SOCK_DGRAM`` sockets. In the J1939 specification, "
"connections are mentioned in the context of transport protocol sessions. "
"These still deliver packets to the other end (using several CAN packets). "
"``SOCK_STREAM`` is not supported."
msgstr ""

#: ../../../networking/j1939.rst:268
msgid ""
"After the successful creation of the socket, you would normally use the "
"``bind(2)`` and/or ``connect(2)`` system call to bind the socket to a CAN "
"interface. After binding and/or connecting the socket, you can ``read(2)`` "
"and ``write(2)`` from/to the socket or use ``send(2)``, ``sendto(2)``, "
"``sendmsg(2)`` and the ``recv*()`` counterpart operations on the socket as "
"usual. There are also J1939 specific socket options described below."
msgstr ""

#: ../../../networking/j1939.rst:275
msgid ""
"In order to send data, a ``bind(2)`` must have been successful. ``bind(2)`` "
"assigns a local address to a socket."
msgstr ""

#: ../../../networking/j1939.rst:278
msgid ""
"Different from CAN is that the payload data is just the data that get sends, "
"without its header info. The header info is derived from the sockaddr "
"supplied to ``bind(2)``, ``connect(2)``, ``sendto(2)`` and ``recvfrom(2)``. "
"A ``write(2)`` with size 4 will result in a packet with 4 bytes."
msgstr ""

#: ../../../networking/j1939.rst:283
msgid ""
"The sockaddr structure has extensions for use with J1939 as specified below:"
msgstr ""

#: ../../../networking/j1939.rst:305
msgid ""
"``can_family`` & ``can_ifindex`` serve the same purpose as for other "
"SocketCAN sockets."
msgstr ""

#: ../../../networking/j1939.rst:307
msgid ""
"``can_addr.j1939.pgn`` specifies the PGN (max 0x3ffff). Individual bits are "
"specified above."
msgstr ""

#: ../../../networking/j1939.rst:310
msgid "``can_addr.j1939.name`` contains the 64-bit J1939 NAME."
msgstr ""

#: ../../../networking/j1939.rst:312
msgid "``can_addr.j1939.addr`` contains the address."
msgstr ""

#: ../../../networking/j1939.rst:314
msgid ""
"The ``bind(2)`` system call assigns the local address, i.e. the source "
"address when sending packages. If a PGN during ``bind(2)`` is set, it's used "
"as a RX filter. I.e. only packets with a matching PGN are received. If an "
"ADDR or NAME is set it is used as a receive filter, too. It will match the "
"destination NAME or ADDR of the incoming packet. The NAME filter will work "
"only if appropriate Address Claiming for this name was done on the CAN bus "
"and registered/cached by the kernel."
msgstr ""

#: ../../../networking/j1939.rst:322
msgid ""
"On the other hand ``connect(2)`` assigns the remote address, i.e. the "
"destination address. The PGN from ``connect(2)`` is used as the default PGN "
"when sending packets. If ADDR or NAME is set it will be used as the default "
"destination ADDR or NAME. Further a set ADDR or NAME during ``connect(2)`` "
"is used as a receive filter. It will match the source NAME or ADDR of the "
"incoming packet."
msgstr ""

#: ../../../networking/j1939.rst:328
msgid ""
"Both ``write(2)`` and ``send(2)`` will send a packet with local address from "
"``bind(2)`` and the remote address from ``connect(2)``. Use ``sendto(2)`` to "
"overwrite the destination address."
msgstr ""

#: ../../../networking/j1939.rst:332
msgid ""
"If ``can_addr.j1939.name`` is set (!= 0) the NAME is looked up by the kernel "
"and the corresponding ADDR is used. If ``can_addr.j1939.name`` is not set "
"(== 0), ``can_addr.j1939.addr`` is used."
msgstr ""

#: ../../../networking/j1939.rst:336
msgid ""
"When creating a socket, reasonable defaults are set. Some options can be "
"modified with ``setsockopt(2)`` & ``getsockopt(2)``."
msgstr ""

#: ../../../networking/j1939.rst:339
msgid "RX path related options:"
msgstr ""

#: ../../../networking/j1939.rst:341
msgid "``SO_J1939_FILTER`` - configure array of filters"
msgstr ""

#: ../../../networking/j1939.rst:342
msgid ""
"``SO_J1939_PROMISC`` - disable filters set by ``bind(2)`` and ``connect(2)``"
msgstr ""

#: ../../../networking/j1939.rst:344
msgid ""
"By default no broadcast packets can be send or received. To enable sending "
"or receiving broadcast packets use the socket option ``SO_BROADCAST``:"
msgstr ""

#: ../../../networking/j1939.rst:352
msgid "The following diagram illustrates the RX path:"
msgstr ""

#: ../../../networking/j1939.rst:385
msgid ""
"TX path related options: ``SO_J1939_SEND_PRIO`` - change default send "
"priority for the socket"
msgstr ""

#: ../../../networking/j1939.rst:389
msgid "Message Flags during send() and Related System Calls"
msgstr ""

#: ../../../networking/j1939.rst:391
msgid ""
"``send(2)``, ``sendto(2)`` and ``sendmsg(2)`` take a 'flags' argument. "
"Currently supported flags are:"
msgstr ""

#: ../../../networking/j1939.rst:394
msgid "``MSG_DONTWAIT``, i.e. non-blocking operation."
msgstr ""

#: ../../../networking/j1939.rst:397
msgid "recvmsg(2)"
msgstr ""

#: ../../../networking/j1939.rst:399
msgid ""
"In most cases ``recvmsg(2)`` is needed if you want to extract more "
"information than ``recvfrom(2)`` can provide. For example package priority "
"and timestamp. The Destination Address, name and packet priority (if "
"applicable) are attached to the msghdr in the ``recvmsg(2)`` call. They can "
"be extracted using ``cmsg(3)`` macros, with ``cmsg_level == SOL_J1939 && "
"cmsg_type == SCM_J1939_DEST_ADDR``, ``SCM_J1939_DEST_NAME`` or "
"``SCM_J1939_PRIO``. The returned data is a ``uint8_t`` for ``priority`` and "
"``dst_addr``, and ``uint64_t`` for ``dst_name``."
msgstr ""

#: ../../../networking/j1939.rst:426
msgid "setsockopt(2)"
msgstr ""

#: ../../../networking/j1939.rst:428
msgid ""
"The ``setsockopt(2)`` function is used to configure various socket-level "
"options for J1939 communication. The following options are supported:"
msgstr ""

#: ../../../networking/j1939.rst:432
msgid "``SO_J1939_FILTER``"
msgstr ""

#: ../../../networking/j1939.rst:434
msgid ""
"The ``SO_J1939_FILTER`` option is essential when the default behavior of "
"``bind(2)`` and ``connect(2)`` is insufficient for specific use cases. By "
"default, ``bind(2)`` and ``connect(2)`` allow a socket to be associated with "
"a single unicast or broadcast address. However, there are scenarios where "
"finer control over the incoming messages is required, such as filtering by "
"Parameter Group Number (PGN) rather than by addresses."
msgstr ""

#: ../../../networking/j1939.rst:441
msgid ""
"For example, in a system where multiple types of J1939 messages are being "
"transmitted, a process might only be interested in a subset of those "
"messages, such as specific PGNs, and not want to receive all messages "
"destined for its address or broadcast to the bus."
msgstr ""

#: ../../../networking/j1939.rst:446
msgid ""
"By applying the ``SO_J1939_FILTER`` option, you can filter messages based on:"
msgstr ""

#: ../../../networking/j1939.rst:448
msgid ""
"**Source Address (SA)**: Filter messages coming from specific source "
"addresses."
msgstr ""

#: ../../../networking/j1939.rst:451
msgid ""
"**Source Name**: Filter messages coming from ECUs with specific NAME "
"identifiers."
msgstr ""

#: ../../../networking/j1939.rst:454
msgid ""
"**Parameter Group Number (PGN)**: Focus on receiving messages with specific "
"PGNs, filtering out irrelevant ones."
msgstr ""

#: ../../../networking/j1939.rst:457
msgid "This filtering mechanism is particularly useful when:"
msgstr ""

#: ../../../networking/j1939.rst:459
msgid ""
"You want to receive a subset of messages based on their PGNs, even if the "
"address is the same."
msgstr ""

#: ../../../networking/j1939.rst:462
msgid ""
"You need to handle both broadcast and unicast messages but only care about "
"certain message types or parameters."
msgstr ""

#: ../../../networking/j1939.rst:465
msgid ""
"The ``bind(2)`` and ``connect(2)`` functions only allow binding to a single "
"address, which might not be sufficient if the process needs to handle "
"multiple PGNs but does not want to open multiple sockets."
msgstr ""

#: ../../../networking/j1939.rst:469
msgid ""
"To remove existing filters, you can pass ``optval == NULL`` or ``optlen == "
"0`` to ``setsockopt(2)``. This will clear all currently set filters. If you "
"want to **update** the set of filters, you must pass the updated filter set "
"to ``setsockopt(2)``, as the new filter set will **replace** the old one "
"entirely. This behavior ensures that any previous filter configuration is "
"discarded and only the new set is applied."
msgstr ""

#: ../../../networking/j1939.rst:476
msgid "Example of removing all filters:"
msgstr ""

#: ../../../networking/j1939.rst:482
msgid ""
"**Maximum number of filters:** The maximum amount of filters that can be "
"applied using ``SO_J1939_FILTER`` is defined by ``J1939_FILTER_MAX``, which "
"is set to 512. This means you can configure up to 512 individual filters to "
"match your specific filtering needs."
msgstr ""

#: ../../../networking/j1939.rst:487
msgid "Practical use case: **Monitoring Address Claiming**"
msgstr ""

#: ../../../networking/j1939.rst:489
msgid ""
"One practical use case is monitoring the J1939 address claiming process by "
"filtering for specific PGNs related to address claiming. This allows a "
"process to monitor and handle address claims without processing unrelated "
"messages."
msgstr ""

#: ../../../networking/j1939.rst:493 ../../../networking/j1939.rst:540
#: ../../../networking/j1939.rst:571 ../../../networking/j1939.rst:599
#: ../../../networking/j1939.rst:653 ../../../networking/j1939.rst:862
msgid "Example:"
msgstr ""

#: ../../../networking/j1939.rst:511
msgid ""
"In this example, the socket will only receive messages with the PGNs related "
"to address claiming: ``J1939_PGN_ADDRESS_CLAIMED``, ``J1939_PGN_REQUEST``, "
"and ``J1939_PGN_ADDRESS_COMMANDED``. This is particularly useful in "
"scenarios where you want to monitor and process address claims without being "
"overwhelmed by other traffic on the J1939 network."
msgstr ""

#: ../../../networking/j1939.rst:518
msgid "``SO_J1939_PROMISC``"
msgstr ""

#: ../../../networking/j1939.rst:520
msgid ""
"The ``SO_J1939_PROMISC`` option enables socket-level promiscuous mode. When "
"this option is enabled, the socket will receive all J1939 traffic, "
"regardless of any filters set by ``bind()`` or ``connect()``. This is "
"analogous to enabling promiscuous mode for an Ethernet interface, where all "
"traffic on the network segment is captured."
msgstr ""

#: ../../../networking/j1939.rst:526
msgid ""
"However, **`SO_J1939_FILTER` has a higher priority** compared to "
"``SO_J1939_PROMISC``. This means that even in promiscuous mode, you can "
"reduce the number of packets received by applying specific filters with "
"`SO_J1939_FILTER`. The filters will limit which packets are passed to the "
"socket, allowing for more refined traffic selection while promiscuous mode "
"is active."
msgstr ""

#: ../../../networking/j1939.rst:533
msgid ""
"The acceptable value size for this option is ``sizeof(int)``, and the value "
"is only differentiated between `0` and non-zero. A value of `0` disables "
"promiscuous mode, while any non-zero value enables it."
msgstr ""

#: ../../../networking/j1939.rst:537
msgid ""
"This combination can be useful for debugging or monitoring specific types of "
"traffic while still capturing a broad set of messages."
msgstr ""

#: ../../../networking/j1939.rst:547
msgid ""
"In this example, setting ``value`` to any non-zero value (e.g., `1`) enables "
"promiscuous mode, allowing the socket to receive all J1939 traffic on the "
"network."
msgstr ""

#: ../../../networking/j1939.rst:552
msgid "``SO_BROADCAST``"
msgstr ""

#: ../../../networking/j1939.rst:554
msgid ""
"The ``SO_BROADCAST`` option enables the sending and receiving of broadcast "
"messages. By default, broadcast messages are disabled for J1939 sockets. "
"When this option is enabled, the socket will be allowed to send and receive "
"broadcast packets on the J1939 network."
msgstr ""

#: ../../../networking/j1939.rst:559
msgid ""
"Due to the nature of the CAN bus as a shared medium, all messages "
"transmitted on the bus are visible to all participants. In the context of "
"J1939, broadcasting refers to using a specific destination address field, "
"where the destination address is set to a value that indicates the message "
"is intended for all participants (usually a global address such as 0xFF). "
"Enabling the broadcast option allows the socket to send and receive such "
"broadcast messages."
msgstr ""

#: ../../../networking/j1939.rst:566
msgid ""
"The acceptable value size for this option is ``sizeof(int)``, and the value "
"is only differentiated between `0` and non-zero. A value of `0` disables the "
"ability to send and receive broadcast messages, while any non-zero value "
"enables it."
msgstr ""

#: ../../../networking/j1939.rst:578
msgid ""
"In this example, setting ``value`` to any non-zero value (e.g., `1`) enables "
"the socket to send and receive broadcast messages."
msgstr ""

#: ../../../networking/j1939.rst:582
msgid "``SO_J1939_SEND_PRIO``"
msgstr ""

#: ../../../networking/j1939.rst:584
msgid ""
"The ``SO_J1939_SEND_PRIO`` option sets the priority of outgoing J1939 "
"messages for the socket. In J1939, messages can have different priorities, "
"and lower numerical values indicate higher priority. This option allows the "
"user to control the priority of messages sent from the socket by adjusting "
"the priority bits in the CAN identifier."
msgstr ""

#: ../../../networking/j1939.rst:590
msgid ""
"The acceptable value **size** for this option is ``sizeof(int)``, and the "
"value is expected to be in the range of 0 to 7, where `0` is the highest "
"priority, and `7` is the lowest. By default, the priority is set to `6` if "
"this option is not explicitly configured."
msgstr ""

#: ../../../networking/j1939.rst:595
msgid ""
"Note that the priority values `0` and `1` can only be set if the process has "
"the `CAP_NET_ADMIN` capability. These are reserved for high-priority traffic "
"and require administrative privileges."
msgstr ""

#: ../../../networking/j1939.rst:606
msgid ""
"In this example, the priority is set to `3`, meaning the outgoing messages "
"will be sent with a moderate priority level."
msgstr ""

#: ../../../networking/j1939.rst:610
msgid "``SO_J1939_ERRQUEUE``"
msgstr ""

#: ../../../networking/j1939.rst:612
msgid ""
"The ``SO_J1939_ERRQUEUE`` option enables the socket to receive error "
"messages from the error queue, providing diagnostic information about "
"transmission failures, protocol violations, or other issues that occur "
"during J1939 communication. Once this option is set, user space is required "
"to handle ``MSG_ERRQUEUE`` messages."
msgstr ""

#: ../../../networking/j1939.rst:618
msgid ""
"Setting ``SO_J1939_ERRQUEUE`` to ``0`` will purge any currently present "
"error messages in the error queue. When enabled, error messages can be "
"retrieved using the ``recvmsg(2)`` system call."
msgstr ""

#: ../../../networking/j1939.rst:622
msgid ""
"When subscribing to the error queue, the following error events can be "
"accessed:"
msgstr ""

#: ../../../networking/j1939.rst:625
msgid "**``J1939_EE_INFO_TX_ABORT``**: Transmission abort errors."
msgstr ""

#: ../../../networking/j1939.rst:626
msgid ""
"**``J1939_EE_INFO_RX_RTS``**: Reception of RTS (Request to Send) control "
"frames."
msgstr ""

#: ../../../networking/j1939.rst:628
msgid ""
"**``J1939_EE_INFO_RX_DPO``**: Reception of data packets with Data Page "
"Offset (DPO)."
msgstr ""

#: ../../../networking/j1939.rst:630
msgid "**``J1939_EE_INFO_RX_ABORT``**: Reception abort errors."
msgstr ""

#: ../../../networking/j1939.rst:632
msgid ""
"The error queue can be used to correlate errors with specific message "
"transfer sessions using the session ID (``tskey``). The session ID is "
"assigned via the ``SOF_TIMESTAMPING_OPT_ID`` flag, which is set by enabling "
"the ``SO_TIMESTAMPING`` option."
msgstr ""

#: ../../../networking/j1939.rst:637
msgid ""
"If ``SO_J1939_ERRQUEUE`` is activated, the user is required to pull messages "
"from the error queue, meaning that using plain ``recv(2)`` is not sufficient "
"anymore. The user must use ``recvmsg(2)`` with appropriate flags to handle "
"error messages. Failure to do so can result in the socket becoming blocked "
"with unprocessed error messages in the queue."
msgstr ""

#: ../../../networking/j1939.rst:643
msgid ""
"It is **recommended** that ``SO_J1939_ERRQUEUE`` be used in combination with "
"``SO_TIMESTAMPING`` in most cases. This enables proper error handling along "
"with session tracking and timestamping, providing a more detailed analysis "
"of message transfers and errors."
msgstr ""

#: ../../../networking/j1939.rst:648
msgid ""
"The acceptable value **size** for this option is ``sizeof(int)``, and the "
"value is only differentiated between ``0`` and non-zero. A value of ``0`` "
"disables error queue reception and purges any existing error messages, while "
"any non-zero value enables it."
msgstr ""

#: ../../../networking/j1939.rst:667
msgid ""
"When enabled, error messages can be retrieved using ``recvmsg(2)``. By "
"combining ``SO_J1939_ERRQUEUE`` with ``SO_TIMESTAMPING`` (with "
"``SOF_TIMESTAMPING_OPT_ID`` and ``SOF_TIMESTAMPING_OPT_CMSG`` enabled), the "
"user can track message transfers, retrieve precise timestamps, and correlate "
"errors with specific sessions."
msgstr ""

#: ../../../networking/j1939.rst:673
msgid ""
"For more information on enabling timestamps and session tracking, refer to "
"the `SO_TIMESTAMPING` section."
msgstr ""

#: ../../../networking/j1939.rst:677
msgid "``SO_TIMESTAMPING``"
msgstr ""

#: ../../../networking/j1939.rst:679
msgid ""
"The ``SO_TIMESTAMPING`` option allows the socket to receive timestamps for "
"various events related to message transmissions and receptions in J1939. "
"This option is often used in combination with ``SO_J1939_ERRQUEUE`` to "
"provide detailed diagnostic information, session tracking, and precise "
"timing data for message transfers."
msgstr ""

#: ../../../networking/j1939.rst:685
msgid ""
"In J1939, all payloads provided by user space, regardless of size, are "
"processed by the kernel as **sessions**. This includes both single-frame "
"messages (up to 8 bytes) and multi-frame protocols such as the Transport "
"Protocol (TP) and Extended Transport Protocol (ETP). Even for small, single-"
"frame messages, the kernel creates a session to manage the transmission and "
"reception. The concept of sessions allows the kernel to manage various "
"aspects of the protocol, such as reassembling multi-frame messages and "
"tracking the status of transmissions."
msgstr ""

#: ../../../networking/j1939.rst:694
msgid ""
"When receiving extended error messages from the error queue, the error "
"information is delivered through a `struct sock_extended_err`, accessible "
"via the control message (``cmsg``) retrieved using the ``recvmsg(2)`` system "
"call."
msgstr ""

#: ../../../networking/j1939.rst:698
msgid "There are two typical origins for the extended error messages in J1939:"
msgstr ""

#: ../../../networking/j1939.rst:700
msgid "``serr->ee_origin == SO_EE_ORIGIN_TIMESTAMPING``:"
msgstr ""

#: ../../../networking/j1939.rst:702
msgid ""
"In this case, the `serr->ee_info` field will contain one of the following "
"timestamp types:"
msgstr ""

#: ../../../networking/j1939.rst:705
msgid ""
"``SCM_TSTAMP_SCHED``: This timestamp is valid for Extended Transport "
"Protocol (ETP) transfers and simple transfers (8 bytes or less). It "
"indicates when a message or set of frames has been scheduled for "
"transmission."
msgstr ""

#: ../../../networking/j1939.rst:710
msgid ""
"For simple transfers (8 bytes or less), it marks the point when the message "
"is queued and ready to be sent onto the CAN bus."
msgstr ""

#: ../../../networking/j1939.rst:713
msgid ""
"For ETP transfers, it is sent after receiving a CTS (Clear to Send) frame on "
"the sender side, indicating that a new set of frames has been scheduled for "
"transmission."
msgstr ""

#: ../../../networking/j1939.rst:717
msgid ""
"The Transport Protocol (TP) case is currently not implemented for this "
"timestamp."
msgstr ""

#: ../../../networking/j1939.rst:720
msgid ""
"On the receiver side, the counterpart to this event for ETP is represented "
"by the ``J1939_EE_INFO_RX_DPO`` message, which indicates the reception of a "
"Data Page Offset (DPO) control frame."
msgstr ""

#: ../../../networking/j1939.rst:724
msgid ""
"``SCM_TSTAMP_ACK``: This timestamp indicates the acknowledgment of the "
"message or session."
msgstr ""

#: ../../../networking/j1939.rst:727
msgid ""
"For simple transfers (8 bytes or less), it marks when the message has been "
"sent and an echo confirmation has been received from the CAN controller, "
"indicating that the frame was transmitted onto the bus."
msgstr ""

#: ../../../networking/j1939.rst:731
msgid ""
"For multi-frame transfers (TP or ETP), it signifies that the entire session "
"has been acknowledged, typically after receiving the End of Message "
"Acknowledgment (EOMA) packet."
msgstr ""

#: ../../../networking/j1939.rst:735
msgid "``serr->ee_origin == SO_EE_ORIGIN_LOCAL``:"
msgstr ""

#: ../../../networking/j1939.rst:737
msgid ""
"In this case, the `serr->ee_info` field will contain one of the following "
"J1939 stack-specific message types:"
msgstr ""

#: ../../../networking/j1939.rst:740
msgid ""
"``J1939_EE_INFO_TX_ABORT``: This message indicates that the transmission of "
"a message or session was aborted. The cause of the abort can come from "
"various sources:"
msgstr ""

#: ../../../networking/j1939.rst:744
msgid ""
"**CAN stack failure**: The J1939 stack was unable to pass the frame to the "
"CAN framework for transmission."
msgstr ""

#: ../../../networking/j1939.rst:747
msgid ""
"**Echo failure**: The J1939 stack did not receive an echo confirmation from "
"the CAN controller, meaning the frame may not have been successfully "
"transmitted to the CAN bus."
msgstr ""

#: ../../../networking/j1939.rst:751
msgid ""
"**Protocol-level issues**: For multi-frame transfers (TP/ETP), this could "
"include protocol-related errors, such as an abort signaled by the receiver "
"or a timeout at the protocol level, which causes the session to terminate "
"prematurely."
msgstr ""

#: ../../../networking/j1939.rst:756
msgid ""
"The corresponding error code is stored in ``serr->ee_data`` (``session-"
">err`` on kernel side), providing additional details about the specific "
"reason for the abort."
msgstr ""

#: ../../../networking/j1939.rst:760
msgid ""
"``J1939_EE_INFO_RX_RTS``: This message indicates that the J1939 stack has "
"received a Request to Send (RTS) control frame, signaling the start of a "
"multi-frame transfer using the Transport Protocol (TP) or Extended Transport "
"Protocol (ETP)."
msgstr ""

#: ../../../networking/j1939.rst:765
msgid ""
"It informs the receiver that the sender is ready to transmit a multi-frame "
"message and includes details about the total message size and the number of "
"frames to be sent."
msgstr ""

#: ../../../networking/j1939.rst:769
msgid ""
"Statistics such as ``J1939_NLA_TOTAL_SIZE``, ``J1939_NLA_PGN``, "
"``J1939_NLA_SRC_NAME``, and ``J1939_NLA_DEST_NAME`` are provided along with "
"the ``J1939_EE_INFO_RX_RTS`` message, giving detailed information about the "
"incoming transfer."
msgstr ""

#: ../../../networking/j1939.rst:774
msgid ""
"``J1939_EE_INFO_RX_DPO``: This message indicates that the J1939 stack has "
"received a Data Page Offset (DPO) control frame, which is part of the "
"Extended Transport Protocol (ETP)."
msgstr ""

#: ../../../networking/j1939.rst:778
msgid ""
"The DPO frame signals the continuation of an ETP multi-frame message by "
"indicating the offset position in the data being transferred. It helps the "
"receiver manage large data sets by identifying which portion of the message "
"is being received."
msgstr ""

#: ../../../networking/j1939.rst:783
msgid ""
"It is typically paired with a corresponding ``SCM_TSTAMP_SCHED`` event on "
"the sender side, which indicates when the next set of frames is scheduled "
"for transmission."
msgstr ""

#: ../../../networking/j1939.rst:787
msgid ""
"This event includes statistics such as ``J1939_NLA_BYTES_ACKED``, which "
"tracks the number of bytes acknowledged up to that point in the session."
msgstr ""

#: ../../../networking/j1939.rst:790
msgid ""
"``J1939_EE_INFO_RX_ABORT``: This message indicates that the reception of a "
"multi-frame message (Transport Protocol or Extended Transport Protocol) has "
"been aborted."
msgstr ""

#: ../../../networking/j1939.rst:794
msgid ""
"The abort can be triggered by protocol-level errors such as timeouts, an "
"unexpected frame, or a specific abort request from the sender."
msgstr ""

#: ../../../networking/j1939.rst:797
msgid ""
"This message signals that the receiver cannot continue processing the "
"transfer, and the session is terminated."
msgstr ""

#: ../../../networking/j1939.rst:800
msgid ""
"The corresponding error code is stored in ``serr->ee_data`` (``session-"
">err`` on kernel side ), providing further details about the reason for the "
"abort, such as protocol violations or timeouts."
msgstr ""

#: ../../../networking/j1939.rst:804
msgid ""
"After receiving this message, the receiver discards the partially received "
"frames, and the multi-frame session is considered incomplete."
msgstr ""

#: ../../../networking/j1939.rst:807
msgid ""
"In both cases, if ``SOF_TIMESTAMPING_OPT_ID`` is enabled, ``serr->ee_data`` "
"will be set to the sessionâ€™s unique identifier (``session->tskey``). This "
"allows user space to track message transfers by their session identifier "
"across multiple frames or stages."
msgstr ""

#: ../../../networking/j1939.rst:812
msgid ""
"In all other cases, ``serr->ee_errno`` will be set to ``ENOMSG``, except for "
"the ``J1939_EE_INFO_TX_ABORT`` and ``J1939_EE_INFO_RX_ABORT`` cases, where "
"the kernel sets ``serr->ee_data`` to the error stored in ``session->err``.  "
"All protocol-specific errors are converted to standard kernel error values "
"and stored in ``session->err``. These error values are unified across system "
"calls and ``serr->ee_errno``.  Some of the known error values are described "
"in the `Error Codes in the J1939 Stack` section."
msgstr ""

#: ../../../networking/j1939.rst:820
msgid ""
"When the `J1939_EE_INFO_RX_RTS` message is provided, it will include the "
"following statistics for multi-frame messages (TP and ETP):"
msgstr ""

#: ../../../networking/j1939.rst:823
msgid "``J1939_NLA_TOTAL_SIZE``: Total size of the message in the session."
msgstr ""

#: ../../../networking/j1939.rst:824
msgid ""
"``J1939_NLA_PGN``: Parameter Group Number (PGN) identifying the message type."
msgstr ""

#: ../../../networking/j1939.rst:825
msgid "``J1939_NLA_SRC_NAME``: 64-bit name of the source ECU."
msgstr ""

#: ../../../networking/j1939.rst:826
msgid "``J1939_NLA_DEST_NAME``: 64-bit name of the destination ECU."
msgstr ""

#: ../../../networking/j1939.rst:827
msgid "``J1939_NLA_SRC_ADDR``: 8-bit source address of the sending ECU."
msgstr ""

#: ../../../networking/j1939.rst:828
msgid ""
"``J1939_NLA_DEST_ADDR``: 8-bit destination address of the receiving ECU."
msgstr ""

#: ../../../networking/j1939.rst:830
msgid ""
"For other messages (including single-frame messages), only the following "
"statistic is included:"
msgstr ""

#: ../../../networking/j1939.rst:833
msgid ""
"``J1939_NLA_BYTES_ACKED``: Number of bytes successfully acknowledged in the "
"session."
msgstr ""

#: ../../../networking/j1939.rst:836
msgid "The key flags for ``SO_TIMESTAMPING`` include:"
msgstr ""

#: ../../../networking/j1939.rst:838
msgid ""
"``SOF_TIMESTAMPING_OPT_ID``: Enables the use of a unique session identifier "
"(``tskey``) for each transfer. This identifier helps track message transfers "
"and errors as distinct sessions in user space. When this option is enabled, "
"``serr->ee_data`` will be set to ``session->tskey``."
msgstr ""

#: ../../../networking/j1939.rst:843
msgid ""
"``SOF_TIMESTAMPING_OPT_CMSG``: Sends timestamp information through control "
"messages (``struct scm_timestamping``), allowing the application to retrieve "
"timestamps alongside the data."
msgstr ""

#: ../../../networking/j1939.rst:847
msgid ""
"``SOF_TIMESTAMPING_TX_SCHED``: Provides the timestamp for when a message is "
"scheduled for transmission (``SCM_TSTAMP_SCHED``)."
msgstr ""

#: ../../../networking/j1939.rst:850
msgid ""
"``SOF_TIMESTAMPING_TX_ACK``: Provides the timestamp for when a message "
"transmission is fully acknowledged (``SCM_TSTAMP_ACK``)."
msgstr ""

#: ../../../networking/j1939.rst:853
msgid ""
"``SOF_TIMESTAMPING_RX_SOFTWARE``: Provides timestamps for reception-related "
"events (e.g., ``J1939_EE_INFO_RX_RTS``, ``J1939_EE_INFO_RX_DPO``, "
"``J1939_EE_INFO_RX_ABORT``)."
msgstr ""

#: ../../../networking/j1939.rst:857
msgid ""
"These flags enable detailed monitoring of message lifecycles, including "
"transmission scheduling, acknowledgments, reception timestamps, and "
"gathering detailed statistics about the communication session, especially "
"for multi-frame payloads like TP and ETP."
msgstr ""

#: ../../../networking/j1939.rst:879
msgid "Dynamic Addressing"
msgstr ""

#: ../../../networking/j1939.rst:881
msgid ""
"Distinction has to be made between using the claimed address and doing an "
"address claim. To use an already claimed address, one has to fill in the "
"``j1939.name`` member and provide it to ``bind(2)``. If the name had claimed "
"an address earlier, all further messages being sent will use that address. "
"And the ``j1939.addr`` member will be ignored."
msgstr ""

#: ../../../networking/j1939.rst:887
msgid ""
"An exception on this is PGN 0x0ee00. This is the \"Address Claim/Cannot "
"Claim Address\" message and the kernel will use the ``j1939.addr`` member "
"for that PGN if necessary."
msgstr ""

#: ../../../networking/j1939.rst:891
msgid "To claim an address following code example can be used:"
msgstr ""

#: ../../../networking/j1939.rst:942
msgid ""
"If no-one else contests the address claim within 250ms after transmission, "
"the kernel marks the NAME-SA assignment as valid. The valid assignment will "
"be kept among other valid NAME-SA assignments. From that point, any socket "
"bound to the NAME can send packets."
msgstr ""

#: ../../../networking/j1939.rst:947
msgid ""
"If another ECU claims the address, the kernel will mark the NAME-SA expired. "
"No socket bound to the NAME can send packets (other than address claims). To "
"claim another address, some socket bound to NAME, must ``bind(2)`` again, "
"but with only ``j1939.addr`` changed to the new SA, and must then send a "
"valid address claim packet. This restarts the state machine in the kernel "
"(and any other participant on the bus) for this NAME."
msgstr ""

#: ../../../networking/j1939.rst:954
msgid ""
"``can-utils`` also include the ``j1939acd`` tool, so it can be used as code "
"example or as default Address Claiming daemon."
msgstr ""

#: ../../../networking/j1939.rst:958
msgid "Send Examples"
msgstr ""

#: ../../../networking/j1939.rst:961
msgid "Static Addressing"
msgstr ""

#: ../../../networking/j1939.rst:963
msgid "This example will send a PGN (0x12300) from SA 0x20 to DA 0x30."
msgstr ""

#: ../../../networking/j1939.rst:965
msgid "Bind:"
msgstr ""

#: ../../../networking/j1939.rst:981
msgid ""
"Now, the socket 'sock' is bound to the SA 0x20. Since no ``connect(2)`` was "
"called, at this point we can use only ``sendto(2)`` or ``sendmsg(2)``."
msgstr ""

#: ../../../networking/j1939.rst:984
msgid "Send:"
msgstr ""

#: ../../../networking/j1939.rst:1001
msgid "Error Codes in the J1939 Stack"
msgstr ""

#: ../../../networking/j1939.rst:1003
msgid ""
"This section lists all potential kernel error codes that can be exposed to "
"user space when interacting with the J1939 stack. It includes both standard "
"error codes and those derived from protocol-specific abort codes."
msgstr ""

#: ../../../networking/j1939.rst:1007
msgid ""
"``EAGAIN``: Operation would block; retry may succeed. One common reason is "
"that an active TP or ETP session exists, and an attempt was made to start a "
"new overlapping TP or ETP session between the same peers."
msgstr ""

#: ../../../networking/j1939.rst:1011
msgid ""
"``ENETDOWN``: Network is down. This occurs when the CAN interface is "
"switched to the \"down\" state."
msgstr ""

#: ../../../networking/j1939.rst:1014
msgid ""
"``ENOBUFS``: No buffer space available. This error occurs when the CAN "
"interface's transmit (TX) queue is full, and no more messages can be queued."
msgstr ""

#: ../../../networking/j1939.rst:1017
msgid ""
"``EOVERFLOW``: Value too large for defined data type. In J1939, this can "
"happen if the requested data lies outside of the queued buffer. For example, "
"if a CTS (Clear to Send) requests an offset not available in the kernel "
"buffer because user space did not provide enough data."
msgstr ""

#: ../../../networking/j1939.rst:1022
msgid ""
"``EBUSY``: Device or resource is busy. For example, this occurs if an "
"identical session is already active and the stack is unable to recover from "
"the condition."
msgstr ""

#: ../../../networking/j1939.rst:1026
msgid ""
"``EACCES``: Permission denied. This error can occur, for example, when "
"attempting to send broadcast messages, but the socket is not configured with "
"``SO_BROADCAST``."
msgstr ""

#: ../../../networking/j1939.rst:1030
msgid ""
"``EADDRNOTAVAIL``: Address not available. This error occurs in cases such as:"
msgstr ""

#: ../../../networking/j1939.rst:1032
msgid ""
"When attempting to use ``getsockname(2)`` to retrieve the peer's address, "
"but the socket is not connected."
msgstr ""

#: ../../../networking/j1939.rst:1035
msgid ""
"When trying to send data to or from a NAME, but address claiming for the "
"NAME was not performed or detected by the stack."
msgstr ""

#: ../../../networking/j1939.rst:1038
msgid "``EBADFD``: File descriptor in bad state. This error can occur if:"
msgstr ""

#: ../../../networking/j1939.rst:1040
msgid "Attempting to send data to an unbound socket."
msgstr ""

#: ../../../networking/j1939.rst:1042
msgid ""
"The socket is bound but has no source name, and the source address is "
"``J1939_NO_ADDR``."
msgstr ""

#: ../../../networking/j1939.rst:1045
msgid "The ``can_ifindex`` is incorrect."
msgstr ""

#: ../../../networking/j1939.rst:1047
msgid ""
"``EFAULT``: Bad address. Occurs mostly when the stack can't copy from or to "
"a sockptr, when there is insufficient data from user space, or when the "
"buffer provided by user space is not large enough for the requested data."
msgstr ""

#: ../../../networking/j1939.rst:1051
msgid ""
"``EINTR``: A signal occurred before any data was transmitted; see "
"``signal(7)``."
msgstr ""

#: ../../../networking/j1939.rst:1053
msgid "``EINVAL``: Invalid argument passed. For example:"
msgstr ""

#: ../../../networking/j1939.rst:1055
msgid "``msg->msg_namelen`` is less than ``J1939_MIN_NAMELEN``."
msgstr ""

#: ../../../networking/j1939.rst:1057
msgid "``addr->can_family`` is not equal to ``AF_CAN``."
msgstr ""

#: ../../../networking/j1939.rst:1059
msgid "An incorrect PGN was provided."
msgstr ""

#: ../../../networking/j1939.rst:1061
msgid ""
"``ENODEV``: No such device. This happens when the CAN network device cannot "
"be found for the provided ``can_ifindex`` or if ``can_ifindex`` is 0."
msgstr ""

#: ../../../networking/j1939.rst:1064
msgid ""
"``ENOMEM``: Out of memory. Typically related to issues with memory "
"allocation in the stack."
msgstr ""

#: ../../../networking/j1939.rst:1067
msgid ""
"``ENOPROTOOPT``: Protocol not available. This can occur when using "
"``getsockopt(2)`` or ``setsockopt(2)`` if the requested socket option is not "
"available."
msgstr ""

#: ../../../networking/j1939.rst:1071
msgid "``EDESTADDRREQ``: Destination address required. This error occurs:"
msgstr ""

#: ../../../networking/j1939.rst:1073
msgid ""
"In the case of ``connect(2)``, if the ``struct sockaddr *uaddr`` is ``NULL``."
msgstr ""

#: ../../../networking/j1939.rst:1075
msgid ""
"In the case of ``send*(2)``, if there is an attempt to send an ETP message "
"to a broadcast address."
msgstr ""

#: ../../../networking/j1939.rst:1078
msgid ""
"``EDOM``: Argument out of domain. This error may happen if attempting to "
"send a TP or ETP message to a PGN that is reserved for control PGNs for TP "
"or ETP operations."
msgstr ""

#: ../../../networking/j1939.rst:1082
msgid ""
"``EIO``: I/O error. This can occur if the amount of data provided to the "
"socket for a TP or ETP session does not match the announced amount of data "
"for the session."
msgstr ""

#: ../../../networking/j1939.rst:1086
msgid ""
"``ENOENT``: No such file or directory. This can happen when the stack "
"attempts to transfer CTS or EOMA but cannot find a matching receiving socket "
"anymore."
msgstr ""

#: ../../../networking/j1939.rst:1090
msgid "``ENOIOCTLCMD``: No ioctls are available for the socket layer."
msgstr ""

#: ../../../networking/j1939.rst:1092
msgid ""
"``EPERM``: Operation not permitted. For example, this can occur if a "
"requested action requires ``CAP_NET_ADMIN`` privileges."
msgstr ""

#: ../../../networking/j1939.rst:1095
msgid ""
"``ENETUNREACH``: Network unreachable. Most likely, this occurs when frames "
"cannot be transmitted to the CAN bus."
msgstr ""

#: ../../../networking/j1939.rst:1098
msgid ""
"``ETIME``: Timer expired. This can happen if a timeout occurs while "
"attempting to send a simple message, for example, when an echo message from "
"the controller is not received."
msgstr ""

#: ../../../networking/j1939.rst:1102
msgid "``EPROTO``: Protocol error."
msgstr ""

#: ../../../networking/j1939.rst:1104
msgid "Used for various protocol-level errors in J1939, including:"
msgstr ""

#: ../../../networking/j1939.rst:1106
msgid "Duplicate sequence number."
msgstr ""

#: ../../../networking/j1939.rst:1108
msgid "Unexpected EDPO or ECTS packet."
msgstr ""

#: ../../../networking/j1939.rst:1110
msgid "Invalid PGN or offset in EDPO/ECTS."
msgstr ""

#: ../../../networking/j1939.rst:1112
msgid "Number of EDPO packets exceeded CTS allowance."
msgstr ""

#: ../../../networking/j1939.rst:1114
msgid "Any other protocol-level error."
msgstr ""

#: ../../../networking/j1939.rst:1116
msgid "``EMSGSIZE``: Message too long."
msgstr ""

#: ../../../networking/j1939.rst:1118
msgid "``ENOMSG``: No message available."
msgstr ""

#: ../../../networking/j1939.rst:1120
msgid ""
"``EALREADY``: The ECU is already engaged in one or more connection-managed "
"sessions and cannot support another."
msgstr ""

#: ../../../networking/j1939.rst:1123
msgid "``EHOSTUNREACH``: A timeout occurred, and the session was aborted."
msgstr ""

#: ../../../networking/j1939.rst:1125
msgid ""
"``EBADMSG``: CTS (Clear to Send) messages were received during an active "
"data transfer, causing an abort."
msgstr ""

#: ../../../networking/j1939.rst:1128
msgid ""
"``ENOTRECOVERABLE``: The maximum retransmission request limit was reached, "
"and the session cannot recover."
msgstr ""

#: ../../../networking/j1939.rst:1131
msgid "``ENOTCONN``: An unexpected data transfer packet was received."
msgstr ""

#: ../../../networking/j1939.rst:1133
msgid ""
"``EILSEQ``: A bad sequence number was received, and the software could not "
"recover."
msgstr ""
