# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/tcp_ao.rst:5
msgid "TCP Authentication Option Linux implementation (RFC5925)"
msgstr ""

#: ../../../networking/tcp_ao.rst:7
msgid ""
"TCP Authentication Option (TCP-AO) provides a TCP extension aimed at "
"verifying segments between trusted peers. It adds a new TCP header option "
"with a Message Authentication Code (MAC). MACs are produced from the content "
"of a TCP segment using a hashing function with a password known to both "
"peers. The intent of TCP-AO is to deprecate TCP-MD5 providing better "
"security, key rotation and support for a variety of hashing algorithms."
msgstr ""

#: ../../../networking/tcp_ao.rst:15
msgid "1. Introduction"
msgstr ""

#: ../../../networking/tcp_ao.rst:17
msgid "Short and Limited Comparison of TCP-AO and TCP-MD5"
msgstr ""

#: ../../../networking/tcp_ao.rst:20
msgid "TCP-MD5"
msgstr ""

#: ../../../networking/tcp_ao.rst:20
msgid "TCP-AO"
msgstr ""

#: ../../../networking/tcp_ao.rst:22
msgid "Supported hashing algorithms"
msgstr ""

#: ../../../networking/tcp_ao.rst:22
msgid "MD5 (cryptographically weak)"
msgstr ""

#: ../../../networking/tcp_ao.rst:22
msgid ""
"Must support HMAC-SHA1 (chosen-prefix attacks) and CMAC-AES-128 (only side-"
"channel attacks). May support any hashing algorithm."
msgstr ""

#: ../../../networking/tcp_ao.rst:29
msgid "Length of MACs (bytes)"
msgstr ""

#: ../../../networking/tcp_ao.rst:29
msgid "16"
msgstr ""

#: ../../../networking/tcp_ao.rst:29
msgid "Typically 12-16. Other variants that fit TCP header permitted."
msgstr ""

#: ../../../networking/tcp_ao.rst:33
msgid "Number of keys per TCP connection"
msgstr ""

#: ../../../networking/tcp_ao.rst:33
msgid "1"
msgstr ""

#: ../../../networking/tcp_ao.rst:33
msgid "Many"
msgstr ""

#: ../../../networking/tcp_ao.rst:36
msgid "Possibility to change an active key"
msgstr ""

#: ../../../networking/tcp_ao.rst:36
msgid "Non-practical (both peers have to change them during MSL)"
msgstr ""

#: ../../../networking/tcp_ao.rst:36
msgid "Supported by protocol"
msgstr ""

#: ../../../networking/tcp_ao.rst:40
msgid "Protection against ICMP 'hard errors'"
msgstr ""

#: ../../../networking/tcp_ao.rst:40 ../../../networking/tcp_ao.rst:44
#: ../../../networking/tcp_ao.rst:48
msgid "No"
msgstr ""

#: ../../../networking/tcp_ao.rst:40
msgid "Yes: ignoring them by default on established connections"
msgstr ""

#: ../../../networking/tcp_ao.rst:44
msgid "Protection against traffic-crossing attack"
msgstr ""

#: ../../../networking/tcp_ao.rst:44
msgid "Yes: pseudo-header includes TCP ports."
msgstr ""

#: ../../../networking/tcp_ao.rst:48
msgid "Protection against replayed TCP segments"
msgstr ""

#: ../../../networking/tcp_ao.rst:48
msgid "Sequence Number Extension (SNE) and Initial Sequence Numbers (ISNs)"
msgstr ""

#: ../../../networking/tcp_ao.rst:53
msgid "Supports Connectionless Resets"
msgstr ""

#: ../../../networking/tcp_ao.rst:53
msgid "Yes"
msgstr ""

#: ../../../networking/tcp_ao.rst:53
msgid "No. ISNs+SNE are needed to correctly sign RST."
msgstr ""

#: ../../../networking/tcp_ao.rst:56
msgid "Standards"
msgstr ""

#: ../../../networking/tcp_ao.rst:56
msgid "RFC 2385"
msgstr ""

#: ../../../networking/tcp_ao.rst:56
msgid "RFC 5925, RFC 5926"
msgstr ""

#: ../../../networking/tcp_ao.rst:61
msgid "1.1 Frequently Asked Questions (FAQ) with references to RFC 5925"
msgstr ""

#: ../../../networking/tcp_ao.rst:63
msgid ""
"Q: Can either SendID or RecvID be non-unique for the same 4-tuple (srcaddr, "
"srcport, dstaddr, dstport)?"
msgstr ""

#: ../../../networking/tcp_ao.rst:66
msgid "A: No [3.1]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:71
msgid "Q: Can Master Key Tuple (MKT) for an active connection be removed?"
msgstr ""

#: ../../../networking/tcp_ao.rst:73
msgid "A: No, unless it's copied to Transport Control Block (TCB) [3.1]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:80
msgid ""
"Q: If an old MKT needs to be deleted, how should it be done in order to not "
"remove it for an active connection? (As it can be still in use at any moment "
"later)"
msgstr ""

#: ../../../networking/tcp_ao.rst:84
msgid ""
"A: Not specified by RFC 5925, seems to be a problem for key management to "
"ensure that no one uses such MKT before trying to remove it."
msgstr ""

#: ../../../networking/tcp_ao.rst:87
msgid "Q: Can an old MKT exist forever and be used by another peer?"
msgstr ""

#: ../../../networking/tcp_ao.rst:89
msgid ""
"A: It can, it's a key management task to decide when to remove an old key "
"[6.1]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:96
msgid "also [6.1]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:101
msgid ""
"Linux TCP-AO will try its best to prevent you from removing a key that's "
"being used, considering it a key management failure. But since keeping an "
"outdated key may become a security issue and as a peer may unintentionally "
"prevent the removal of an old key by always setting it as RNextKeyID - a "
"forced key removal mechanism is provided, where userspace has to supply "
"KeyID to use instead of the one that's being removed and the kernel will "
"atomically delete the old key, even if the peer is still requesting it. "
"There are no guarantees for force-delete as the peer may yet not have the "
"new key - the TCP connection may just break. Alternatively, one may choose "
"to shut down the socket."
msgstr ""

#: ../../../networking/tcp_ao.rst:112
msgid ""
"Q: What happens when a packet is received on a new connection with no known "
"MKT's RecvID?"
msgstr ""

#: ../../../networking/tcp_ao.rst:115
msgid ""
"A: RFC 5925 specifies that by default it is accepted with a warning logged, "
"but the behaviour can be configured by the user [7.5.1.a]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:128
msgid "[7.3]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:138
msgid "[10.2.b]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:144
msgid ""
"Note that Linux TCP-AO implementation differs in this aspect. Currently, TCP-"
"AO segments with unknown key signatures are discarded with warnings logged."
msgstr ""

#: ../../../networking/tcp_ao.rst:147
msgid ""
"Q: Does the RFC imply centralized kernel key management in any way? (i.e. "
"that a key on all connections MUST be rotated at the same time?)"
msgstr ""

#: ../../../networking/tcp_ao.rst:150
msgid ""
"A: Not specified. MKTs can be managed in userspace, the only relevant part "
"to key changes is [7.3]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:156
msgid ""
"Q: What happens when RNextKeyID requested by a peer is unknown? Should the "
"connection be reset?"
msgstr ""

#: ../../../networking/tcp_ao.rst:159
msgid "A: It should not, no action needs to be performed [7.5.2.e]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:167
msgid ""
"Q: How is current_key set, and when does it change? Is it a user-triggered "
"change, or is it triggered by a request from the remote peer? Is it set by "
"the user explicitly, or by a matching rule?"
msgstr ""

#: ../../../networking/tcp_ao.rst:171
msgid "A: current_key is set by RNextKeyID [6.1]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:182
msgid "[7.5.2.e.ii]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:189
msgid ""
"Q: If both peers have multiple MKTs matching the connection's socket pair "
"(with different KeyIDs), how should the sender/receiver pick KeyID to use?"
msgstr ""

#: ../../../networking/tcp_ao.rst:192
msgid "A: Some mechanism should pick the \"desired\" MKT [3.3]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:205
msgid "Q: Can TCP-MD5 connection migrate to TCP-AO (and vice-versa):"
msgstr ""

#: ../../../networking/tcp_ao.rst:207
msgid "A: No [1]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:213
msgid ""
"Q: If all MKTs are removed on a connection, can it become a non-TCP-AO "
"signed connection?"
msgstr ""

#: ../../../networking/tcp_ao.rst:216
msgid ""
"A: [7.5.2] doesn't have the same choice as SYN packet handling in [7.5.1.i] "
"that would allow accepting segments without a sign (which would be "
"insecure). While switching to non-TCP-AO connection is not prohibited "
"directly, it seems what the RFC means. Also, there's a requirement for TCP-"
"AO connections to always have one current_key [3.3]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:224
msgid "[3.3]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:229
msgid "[4.4]::"
msgstr ""

#: ../../../networking/tcp_ao.rst:234
msgid "Q: Can a non-TCP-AO connection become a TCP-AO-enabled one?"
msgstr ""

#: ../../../networking/tcp_ao.rst:236
msgid ""
"A: No: for an already established non-TCP-AO connection it would be "
"impossible to switch to using TCP-AO, as the traffic key generation requires "
"the initial sequence numbers. Paraphrasing, starting using TCP-AO would "
"require re-establishing the TCP connection."
msgstr ""

#: ../../../networking/tcp_ao.rst:242
msgid "2. In-kernel MKTs database vs database in userspace"
msgstr ""

#: ../../../networking/tcp_ao.rst:244
msgid ""
"Linux TCP-AO support is implemented using ``setsockopt()s``, in a similar "
"way to TCP-MD5. It means that a userspace application that wants to use TCP-"
"AO should perform ``setsockopt()`` on a TCP socket when it wants to add, "
"remove or rotate MKTs. This approach moves the key management responsibility "
"to userspace as well as decisions on corner cases, i.e. what to do if the "
"peer doesn't respect RNextKeyID; moving more code to userspace, especially "
"responsible for the policy decisions. Besides, it's flexible and scales well "
"(with less locking needed than in the case of an in-kernel database). One "
"also should keep in mind that mainly intended users are BGP processes, not "
"any random applications, which means that compared to IPsec tunnels, no "
"transparency is really needed and modern BGP daemons already have "
"``setsockopt()s`` for TCP-MD5 support."
msgstr ""

#: ../../../networking/tcp_ao.rst:257
msgid "Considered pros and cons of the approaches"
msgstr ""

#: ../../../networking/tcp_ao.rst:260
msgid "``setsockopt()``"
msgstr ""

#: ../../../networking/tcp_ao.rst:260
msgid "in-kernel DB"
msgstr ""

#: ../../../networking/tcp_ao.rst:262
msgid "Extendability"
msgstr ""

#: ../../../networking/tcp_ao.rst:262
msgid "``setsockopt()`` commands should be extendable syscalls"
msgstr ""

#: ../../../networking/tcp_ao.rst:262
msgid "Netlink messages are simple and extendable"
msgstr ""

#: ../../../networking/tcp_ao.rst:266
msgid "Required userspace changes"
msgstr ""

#: ../../../networking/tcp_ao.rst:266
msgid ""
"BGP or any application that wants TCP-AO needs to perform ``setsockopt()s`` "
"and do key management"
msgstr ""

#: ../../../networking/tcp_ao.rst:266
msgid ""
"could be transparent as tunnels, providing something like ``ip tcpao add "
"key`` (delete/show/rotate)"
msgstr ""

#: ../../../networking/tcp_ao.rst:272
msgid "MKTs removal or adding"
msgstr ""

#: ../../../networking/tcp_ao.rst:272
msgid "harder for userspace"
msgstr ""

#: ../../../networking/tcp_ao.rst:272
msgid "harder for kernel"
msgstr ""

#: ../../../networking/tcp_ao.rst:274
msgid "Dump-ability"
msgstr ""

#: ../../../networking/tcp_ao.rst:274
msgid "``getsockopt()``"
msgstr ""

#: ../../../networking/tcp_ao.rst:274
msgid "Netlink .dump() callback"
msgstr ""

#: ../../../networking/tcp_ao.rst:277
msgid "Limits on kernel resources/memory"
msgstr ""

#: ../../../networking/tcp_ao.rst:277
msgid "equal"
msgstr ""

#: ../../../networking/tcp_ao.rst:280
msgid "Scalability"
msgstr ""

#: ../../../networking/tcp_ao.rst:280
msgid "contention on ``TCP_LISTEN`` sockets"
msgstr ""

#: ../../../networking/tcp_ao.rst:280
msgid "contention on the whole database"
msgstr ""

#: ../../../networking/tcp_ao.rst:283
msgid "Monitoring & warnings"
msgstr ""

#: ../../../networking/tcp_ao.rst:283
msgid "``TCP_DIAG``"
msgstr ""

#: ../../../networking/tcp_ao.rst:283
msgid "same Netlink socket"
msgstr ""

#: ../../../networking/tcp_ao.rst:285
msgid "Matching of MKTs"
msgstr ""

#: ../../../networking/tcp_ao.rst:285
msgid "half-problem: only listen sockets"
msgstr ""

#: ../../../networking/tcp_ao.rst:285
msgid "hard"
msgstr ""

#: ../../../networking/tcp_ao.rst:291
msgid "3. uAPI"
msgstr ""

#: ../../../networking/tcp_ao.rst:293
msgid ""
"Linux provides a set of ``setsockopt()s`` and ``getsockopt()s`` that let "
"userspace manage TCP-AO on a per-socket basis. In order to add/delete MKTs "
"``TCP_AO_ADD_KEY`` and ``TCP_AO_DEL_KEY`` TCP socket options must be used. "
"It is not allowed to add a key on an established non-TCP-AO connection as "
"well as to remove the last key from TCP-AO connection."
msgstr ""

#: ../../../networking/tcp_ao.rst:299
msgid ""
"``setsockopt(TCP_AO_DEL_KEY)`` command may specify ``tcp_ao_del::"
"current_key`` + ``tcp_ao_del::set_current`` and/or ``tcp_ao_del::rnext`` + "
"``tcp_ao_del::set_rnext`` which makes such delete \"forced\": it provides "
"userspace a way to delete a key that's being used and atomically set another "
"one instead. This is not intended for normal use and should be used only "
"when the peer ignores RNextKeyID and keeps requesting/using an old key. It "
"provides a way to force-delete a key that's not trusted but may break the "
"TCP-AO connection."
msgstr ""

#: ../../../networking/tcp_ao.rst:308
msgid ""
"The usual/normal key-rotation can be performed with "
"``setsockopt(TCP_AO_INFO)``. It also provides a uAPI to change per-socket "
"TCP-AO settings, such as ignoring ICMPs, as well as clear per-socket TCP-AO "
"packet counters. The corresponding ``getsockopt(TCP_AO_INFO)`` can be used "
"to get those per-socket TCP-AO settings."
msgstr ""

#: ../../../networking/tcp_ao.rst:314
msgid ""
"Another useful command is ``getsockopt(TCP_AO_GET_KEYS)``. One can use it to "
"list all MKTs on a TCP socket or use a filter to get keys for a specific "
"peer and/or sndid/rcvid, VRF L3 interface or get current_key/rnext_key."
msgstr ""

#: ../../../networking/tcp_ao.rst:318
msgid ""
"To repair TCP-AO connections ``setsockopt(TCP_AO_REPAIR)`` is available, "
"provided that the user previously has checkpointed/dumped the socket with "
"``getsockopt(TCP_AO_REPAIR)``."
msgstr ""

#: ../../../networking/tcp_ao.rst:322
msgid ""
"A tip here for scaled TCP_LISTEN sockets, that may have some thousands TCP-"
"AO keys, is: use filters in ``getsockopt(TCP_AO_GET_KEYS)`` and asynchronous "
"delete with ``setsockopt(TCP_AO_DEL_KEY)``."
msgstr ""

#: ../../../networking/tcp_ao.rst:326
msgid ""
"Linux TCP-AO also provides a bunch of segment counters that can be helpful "
"with troubleshooting/debugging issues. Every MKT has good/bad counters that "
"reflect how many packets passed/failed verification. Each TCP-AO socket has "
"the following counters: - for good segments (properly signed) - for bad "
"segments (failed TCP-AO verification) - for segments with unknown keys - for "
"segments where an AO signature was expected, but wasn't found - for the "
"number of ignored ICMPs"
msgstr ""

#: ../../../networking/tcp_ao.rst:336
msgid ""
"TCP-AO per-socket counters are also duplicated with per-netns counters, "
"exposed with SNMP. Those are ``TCPAOGood``, ``TCPAOBad``, "
"``TCPAOKeyNotFound``, ``TCPAORequired`` and ``TCPAODroppedIcmps``."
msgstr ""

#: ../../../networking/tcp_ao.rst:340
msgid ""
"For monitoring purposes, there are following TCP-AO trace events: "
"``tcp_hash_bad_header``, ``tcp_hash_ao_required``, "
"``tcp_ao_handshake_failure``, ``tcp_ao_wrong_maclen``, "
"``tcp_ao_wrong_maclen``, ``tcp_ao_key_not_found``, ``tcp_ao_rnext_request``, "
"``tcp_ao_synack_no_key``, ``tcp_ao_snd_sne_update``, "
"``tcp_ao_rcv_sne_update``. It's possible to separately enable any of them "
"and one can filter them by net-namespace, 4-tuple, family, L3 index, and TCP "
"header flags. If a segment has a TCP-AO header, the filters may also include "
"keyid, rnext, and maclen. SNE updates include the rolled-over numbers."
msgstr ""

#: ../../../networking/tcp_ao.rst:349
msgid ""
"RFC 5925 very permissively specifies how TCP port matching can be done for "
"MKTs::"
msgstr ""

#: ../../../networking/tcp_ao.rst:357
msgid ""
"Currently Linux TCP-AO implementation doesn't provide any TCP port matching. "
"Probably, port ranges are the most flexible for uAPI, but so far not "
"implemented."
msgstr ""

#: ../../../networking/tcp_ao.rst:362
msgid "4. ``setsockopt()`` vs ``accept()`` race"
msgstr ""

#: ../../../networking/tcp_ao.rst:364
msgid ""
"In contrast with an established TCP-MD5 connection which has just one key, "
"TCP-AO connections may have many keys, which means that accepted connections "
"on a listen socket may have any amount of keys as well. As copying all those "
"keys on a first properly signed SYN would make the request socket bigger, "
"that would be undesirable. Currently, the implementation doesn't copy keys "
"to request sockets, but rather look them up on the \"parent\" listener "
"socket."
msgstr ""

#: ../../../networking/tcp_ao.rst:371
msgid ""
"The result is that when userspace removes TCP-AO keys, that may break not-"
"yet-established connections on request sockets as well as not removing keys "
"from sockets that were already established, but not yet ``accept()``'ed, "
"hanging in the accept queue."
msgstr ""

#: ../../../networking/tcp_ao.rst:376
msgid ""
"The reverse is valid as well: if userspace adds a new key for a peer on a "
"listener socket, the established sockets in the accept queue won't have the "
"new keys."
msgstr ""

#: ../../../networking/tcp_ao.rst:380
msgid ""
"At this moment, the resolution for the two races: "
"``setsockopt(TCP_AO_ADD_KEY)`` vs ``accept()`` and "
"``setsockopt(TCP_AO_DEL_KEY)`` vs ``accept()`` is delegated to userspace. "
"This means that it's expected that userspace would check the MKTs on the "
"socket that was returned by ``accept()`` to verify that any key rotation "
"that happened on the listen socket is reflected on the newly established "
"connection."
msgstr ""

#: ../../../networking/tcp_ao.rst:387
msgid ""
"This is a similar \"do-nothing\" approach to TCP-MD5 from the kernel side "
"and may be changed later by introducing new flags to ``tcp_ao_add`` and "
"``tcp_ao_del``."
msgstr ""

#: ../../../networking/tcp_ao.rst:391
msgid ""
"Note that this race is rare for it needs TCP-AO key rotation to happen "
"during the 3-way handshake for the new TCP connection."
msgstr ""

#: ../../../networking/tcp_ao.rst:395
msgid "5. Interaction with TCP-MD5"
msgstr ""

#: ../../../networking/tcp_ao.rst:397
msgid ""
"A TCP connection can not migrate between TCP-AO and TCP-MD5 options. The "
"established sockets that have either AO or MD5 keys are restricted for "
"adding keys of the other option."
msgstr ""

#: ../../../networking/tcp_ao.rst:401
msgid ""
"For listening sockets the picture is different: BGP server may want to "
"receive both TCP-AO and (deprecated) TCP-MD5 clients. As a result, both "
"types of keys may be added to TCP_CLOSED or TCP_LISTEN sockets. It's not "
"allowed to add different types of keys for the same peer."
msgstr ""

#: ../../../networking/tcp_ao.rst:407
msgid "6. SNE Linux implementation"
msgstr ""

#: ../../../networking/tcp_ao.rst:409
msgid ""
"RFC 5925 [6.2] describes the algorithm of how to extend TCP sequence numbers "
"with SNE.  In short: TCP has to track the previous sequence numbers and set "
"sne_flag when the current SEQ number rolls over. The flag is cleared when "
"both current and previous SEQ numbers cross 0x7fff, which is 32Kb."
msgstr ""

#: ../../../networking/tcp_ao.rst:414
msgid ""
"In times when sne_flag is set, the algorithm compares SEQ for each packet "
"with 0x7fff and if it's higher than 32Kb, it assumes that the packet should "
"be verified with SNE before the increment. As a result, there's this [0; "
"32Kb] window, when packets with (SNE - 1) can be accepted."
msgstr ""

#: ../../../networking/tcp_ao.rst:419
msgid ""
"Linux implementation simplifies this a bit: as the network stack already "
"tracks the first SEQ byte that ACK is wanted for (snd_una) and the next SEQ "
"byte that is wanted (rcv_nxt) - that's enough information for a rough "
"estimation on where in the 4GB SEQ number space both sender and receiver "
"are. When they roll over to zero, the corresponding SNE gets incremented."
msgstr ""

#: ../../../networking/tcp_ao.rst:425
msgid ""
"tcp_ao_compute_sne() is called for each TCP-AO segment. It compares SEQ "
"numbers from the segment with snd_una or rcv_nxt and fits the result into a "
"2GB window around them, detecting SEQ numbers rolling over. That simplifies "
"the code a lot and only requires SNE numbers to be stored on every TCP-AO "
"socket."
msgstr ""

#: ../../../networking/tcp_ao.rst:430
msgid ""
"The 2GB window at first glance seems much more permissive compared to RFC "
"5926. But that is only used to pick the correct SNE before/after a rollover. "
"It allows more TCP segment replays, but yet all regular TCP checks in "
"tcp_sequence() are applied on the verified segment. So, it trades a bit more "
"permissive acceptance of replayed/retransmitted segments for the simplicity "
"of the algorithm and what seems better behaviour for large TCP windows."
msgstr ""

#: ../../../networking/tcp_ao.rst:439
msgid "7. Links"
msgstr ""

#: ../../../networking/tcp_ao.rst:441
msgid "RFC 5925 The TCP Authentication Option"
msgstr ""

#: ../../../networking/tcp_ao.rst:442
msgid "https://www.rfc-editor.org/rfc/pdfrfc/rfc5925.txt.pdf"
msgstr ""

#: ../../../networking/tcp_ao.rst:444
msgid ""
"RFC 5926 Cryptographic Algorithms for the TCP Authentication Option (TCP-AO)"
msgstr ""

#: ../../../networking/tcp_ao.rst:445
msgid "https://www.rfc-editor.org/rfc/pdfrfc/rfc5926.txt.pdf"
msgstr ""

#: ../../../networking/tcp_ao.rst:447
msgid "Draft \"SHA-2 Algorithm for the TCP Authentication Option (TCP-AO)\""
msgstr ""

#: ../../../networking/tcp_ao.rst:448
msgid "https://datatracker.ietf.org/doc/html/draft-nayak-tcp-sha2-03"
msgstr ""

#: ../../../networking/tcp_ao.rst:450
msgid "RFC 2385 Protection of BGP Sessions via the TCP MD5 Signature Option"
msgstr ""

#: ../../../networking/tcp_ao.rst:451
msgid "https://www.rfc-editor.org/rfc/pdfrfc/rfc2385.txt.pdf"
msgstr ""

#: ../../../networking/tcp_ao.rst:0
msgid "Author"
msgstr ""

#: ../../../networking/tcp_ao.rst:453
msgid "Dmitry Safonov <dima@arista.com>"
msgstr ""
