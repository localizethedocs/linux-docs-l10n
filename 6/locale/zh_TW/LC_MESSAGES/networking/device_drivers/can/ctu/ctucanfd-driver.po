# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-25 09:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:4
msgid "CTU CAN FD Driver"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:6
msgid "Author: Martin Jerabek <martin.jerabek01@gmail.com>"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:10
msgid "About CTU CAN FD IP Core"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:12
msgid ""
"`CTU CAN FD <https://gitlab.fel.cvut.cz/canbus/ctucanfd_ip_core>`_ is an "
"open source soft core written in VHDL. It originated in 2015 as Ondrej "
"Ille's project at the `Department of Measurement <https://meas.fel.cvut.cz/"
">`_ of `FEE <http://www.fel.cvut.cz/en/>`_ at `CTU <https://www.cvut.cz/"
"en>`_."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:18
msgid ""
"The SocketCAN driver for Xilinx Zynq SoC based MicroZed board `Vivado "
"integration <https://gitlab.fel.cvut.cz/canbus/zynq/zynq-can-sja1000-top>`_ "
"and Intel Cyclone V 5CSEMA4U23C6 based DE0-Nano-SoC Terasic board `QSys "
"integration <https://gitlab.fel.cvut.cz/canbus/intel-soc-ctucanfd>`_ has "
"been developed as well as support for `PCIe integration <https://gitlab.fel."
"cvut.cz/canbus/pcie-ctucanfd>`_ of the core."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:25
msgid ""
"In the case of Zynq, the core is connected via the APB system bus, which "
"does not have enumeration support, and the device must be specified in "
"Device Tree. This kind of devices is called platform device in the kernel "
"and is handled by a platform device driver."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:30
msgid ""
"The basic functional model of the CTU CAN FD peripheral has been accepted "
"into QEMU mainline. See QEMU `CAN emulation support <https://www.qemu.org/"
"docs/master/system/devices/can.html>`_ for CAN FD buses, host connection and "
"CTU CAN FD core emulation. The development version of emulation support can "
"be cloned from ctu-canfd branch of QEMU local development `repository "
"<https://gitlab.fel.cvut.cz/canbus/qemu-canbus>`_."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:38
msgid "About SocketCAN"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:40
msgid ""
"SocketCAN is a standard common interface for CAN devices in the Linux "
"kernel. As the name suggests, the bus is accessed via sockets, similarly to "
"common network devices. The reasoning behind this is in depth described in "
"`Linux SocketCAN <https://www.kernel.org/doc/html/latest/networking/can."
"html>`_. In short, it offers a natural way to implement and work with higher "
"layer protocols over CAN, in the same way as, e.g., UDP/IP over Ethernet."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:49
msgid "Device probe"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:51
msgid ""
"Before going into detail about the structure of a CAN bus device driver, "
"let's reiterate how the kernel gets to know about the device at all. Some "
"buses, like PCI or PCIe, support device enumeration. That is, when the "
"system boots, it discovers all the devices on the bus and reads their "
"configuration. The kernel identifies the device via its vendor ID and device "
"ID, and if there is a driver registered for this identifier combination, its "
"probe method is invoked to populate the driver's instance for the given "
"hardware. A similar situation goes with USB, only it allows for device hot-"
"plug."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:61
msgid ""
"The situation is different for peripherals which are directly embedded in "
"the SoC and connected to an internal system bus (AXI, APB, Avalon, and "
"others). These buses do not support enumeration, and thus the kernel has to "
"learn about the devices from elsewhere. This is exactly what the Device Tree "
"was made for."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:68
msgid "Device tree"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:70
msgid ""
"An entry in device tree states that a device exists in the system, how it is "
"reachable (on which bus it resides) and its configuration – registers "
"address, interrupts and so on. An example of such a device tree is given in ."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:98
msgid "Driver structure"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:100
msgid ""
"The driver can be divided into two parts – platform-dependent device "
"discovery and set up, and platform-independent CAN network device "
"implementation."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:107
msgid "Platform device driver"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:109
msgid ""
"In the case of Zynq, the core is connected via the AXI system bus, which "
"does not have enumeration support, and the device must be specified in "
"Device Tree. This kind of devices is called *platform device* in the kernel "
"and is handled by a *platform device driver*\\  [1]_."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:114
msgid "A platform device driver provides the following things:"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:116
msgid "A *probe* function"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:118
msgid "A *remove* function"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:120
msgid "A table of *compatible* devices that the driver can handle"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:122
msgid ""
"The *probe* function is called exactly once when the device appears (or the "
"driver is loaded, whichever happens later). If there are more devices "
"handled by the same driver, the *probe* function is called for each one of "
"them. Its role is to allocate and initialize resources required for handling "
"the device, as well as set up low-level functions for the platform-"
"independent layer, e.g., *read_reg* and *write_reg*. After that, the driver "
"registers the device to a higher layer, in our case as a *network device*."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:131
msgid ""
"The *remove* function is called when the device disappears, or the driver is "
"about to be unloaded. It serves to free the resources allocated in *probe* "
"and to unregister the device from higher layers."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:135
msgid ""
"Finally, the table of *compatible* devices states which devices the driver "
"can handle. The Device Tree entry ``compatible`` is matched against the "
"tables of all *platform drivers*."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:166
msgid "Network device driver"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:168
msgid "Each network device must support at least these operations:"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:170
msgid "Bring the device up: ``ndo_open``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:172
msgid "Bring the device down: ``ndo_close``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:174
msgid "Submit TX frames to the device: ``ndo_start_xmit``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:176
msgid "Signal TX completion and errors to the network subsystem: ISR"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:178
msgid "Submit RX frames to the network subsystem: ISR and NAPI"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:180
msgid ""
"There are two possible event sources: the device and the network subsystem. "
"Device events are usually signaled via an interrupt, handled in an Interrupt "
"Service Routine (ISR). Handlers for the events originating in the network "
"subsystem are then specified in ``struct net_device_ops``."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:186
msgid ""
"When the device is brought up, e.g., by calling ``ip link set can0 up``, the "
"driver’s function ``ndo_open`` is called. It should validate the interface "
"configuration and configure and enable the device. The analogous opposite is "
"``ndo_close``, called when the device is being brought down, be it "
"explicitly or implicitly."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:192
msgid ""
"When the system should transmit a frame, it does so by calling "
"``ndo_start_xmit``, which enqueues the frame into the device. If the device "
"HW queue (FIFO, mailboxes or whatever the implementation is) becomes full, "
"the ``ndo_start_xmit`` implementation informs the network subsystem that it "
"should stop the TX queue (via ``netif_stop_queue``). It is then re-enabled "
"later in ISR when the device has some space available again and is able to "
"enqueue another frame."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:200
msgid "All the device events are handled in ISR, namely:"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:202
msgid ""
"**TX completion**. When the device successfully finishes transmitting a "
"frame, the frame is echoed locally. On error, an informative error frame "
"[2]_ is sent to the network subsystem instead. In both cases, the software "
"TX queue is resumed so that more frames may be sent."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:207
msgid ""
"**Error condition**. If something goes wrong (e.g., the device goes bus-off "
"or RX overrun happens), error counters are updated, and informative error "
"frames are enqueued to SW RX queue."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:211
msgid ""
"**RX buffer not empty**. In this case, read the RX frames and enqueue them "
"to SW RX queue. Usually NAPI is used as a middle layer (see )."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:217
msgid "NAPI"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:219
msgid ""
"The frequency of incoming frames can be high and the overhead to invoke the "
"interrupt service routine for each frame can cause significant system load. "
"There are multiple mechanisms in the Linux kernel to deal with this "
"situation. They evolved over the years of Linux kernel development and "
"enhancements. For network devices, the current standard is NAPI – *the New "
"API*. It is similar to classical top-half/bottom-half interrupt handling in "
"that it only acknowledges the interrupt in the ISR and signals that the rest "
"of the processing should be done in softirq context. On top of that, it "
"offers the possibility to *poll* for new frames for a while. This has a "
"potential to avoid the costly round of enabling interrupts, handling an "
"incoming IRQ in ISR, re-enabling the softirq and switching context back to "
"softirq."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:232
msgid ""
"See :ref:`Documentation/networking/napi.rst <napi>` for more information."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:235
msgid "Integrating the core to Xilinx Zynq"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:237
msgid ""
"The core interfaces a simple subset of the Avalon (search for Intel **Avalon "
"Interface Specifications**) bus as it was originally used on Alterra FPGA "
"chips, yet Xilinx natively interfaces with AXI (search for ARM **AMBA AXI "
"and ACE Protocol Specification AXI3, AXI4, and AXI4-Lite, ACE and ACE-"
"Lite**). The most obvious solution would be to use an Avalon/AXI bridge or "
"implement some simple conversion entity. However, the core’s interface is "
"half-duplex with no handshake signaling, whereas AXI is full duplex with two-"
"way signaling. Moreover, even AXI-Lite slave interface is quite resource-"
"intensive, and the flexibility and speed of AXI are not required for a CAN "
"core."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:250
msgid ""
"Thus a much simpler bus was chosen – APB (Advanced Peripheral Bus) (search "
"for ARM **AMBA APB Protocol Specification**). APB-AXI bridge is directly "
"available in Xilinx Vivado, and the interface adaptor entity is just a few "
"simple combinatorial assignments."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:256
msgid ""
"Finally, to be able to include the core in a block diagram as a custom IP, "
"the core, together with the APB interface, has been packaged as a Vivado "
"component."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:261
msgid "CTU CAN FD Driver design"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:263
msgid ""
"The general structure of a CAN device driver has already been examined in . "
"The next paragraphs provide a more detailed description of the CTU CAN FD "
"core driver in particular."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:268
msgid "Low-level driver"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:270
msgid ""
"The core is not intended to be used solely with SocketCAN, and thus it is "
"desirable to have an OS-independent low-level driver. This low-level driver "
"can then be used in implementations of OS driver or directly either on bare "
"metal or in a user-space application. Another advantage is that if the "
"hardware slightly changes, only the low-level driver needs to be modified."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:277
msgid ""
"The code [3]_ is in part automatically generated and in part written "
"manually by the core author, with contributions of the thesis’ author. The "
"low-level driver supports operations such as: set bit timing, set controller "
"mode, enable/disable, read RX frame, write TX frame, and so on."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:284
msgid "Configuring bit timing"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:286
msgid ""
"On CAN, each bit is divided into four segments: SYNC, PROP, PHASE1, and "
"PHASE2. Their duration is expressed in multiples of a Time Quantum (details "
"in `CAN Specification, Version 2.0 <http://esd.cs.ucr.edu/webres/can20."
"pdf>`_, chapter 8). When configuring bitrate, the durations of all the "
"segments (and time quantum) must be computed from the bitrate and Sample "
"Point. This is performed independently for both the Nominal bitrate and Data "
"bitrate for CAN FD."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:294
msgid ""
"SocketCAN is fairly flexible and offers either highly customized "
"configuration by setting all the segment durations manually, or a convenient "
"configuration by setting just the bitrate and sample point (and even that is "
"chosen automatically per Bosch recommendation if not specified). However, "
"each CAN controller may have different base clock frequency and different "
"width of segment duration registers. The algorithm thus needs the minimum "
"and maximum values for the durations (and clock prescaler) and tries to "
"optimize the numbers to fit both the constraints and the requested "
"parameters."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:319
msgid "[lst:can_bittiming_const]"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:321
msgid ""
"A curious reader will notice that the durations of the segments PROP_SEG and "
"PHASE_SEG1 are not determined separately but rather combined and then, by "
"default, the resulting TSEG1 is evenly divided between PROP_SEG and "
"PHASE_SEG1. In practice, this has virtually no consequences as the sample "
"point is between PHASE_SEG1 and PHASE_SEG2. In CTU CAN FD, however, the "
"duration registers ``PROP`` and ``PH1`` have different widths (6 and 7 bits, "
"respectively), so the auto-computed values might overflow the shorter "
"register and must thus be redistributed among the two [4]_."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:332
msgid "Handling RX"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:334
msgid ""
"Frame reception is handled in NAPI queue, which is enabled from ISR when the "
"RXNE (RX FIFO Not Empty) bit is set. Frames are read one by one until either "
"no frame is left in the RX FIFO or the maximum work quota has been reached "
"for the NAPI poll run (see ). Each frame is then passed to the network "
"interface RX queue."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:340
msgid ""
"An incoming frame may be either a CAN 2.0 frame or a CAN FD frame. The way "
"to distinguish between these two in the kernel is to allocate either "
"``struct can_frame`` or ``struct canfd_frame``, the two having different "
"sizes. In the controller, the information about the frame type is stored in "
"the first word of RX FIFO."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:346
msgid ""
"This brings us a chicken-egg problem: we want to allocate the ``skb`` for "
"the frame, and only if it succeeds, fetch the frame from FIFO; otherwise "
"keep it there for later. But to be able to allocate the correct ``skb``, we "
"have to fetch the first work of FIFO. There are several possible solutions:"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:352
msgid ""
"Read the word, then allocate. If it fails, discard the rest of the frame. "
"When the system is low on memory, the situation is bad anyway."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:355
msgid ""
"Always allocate ``skb`` big enough for an FD frame beforehand. Then tweak "
"the ``skb`` internals to look like it has been allocated for the smaller CAN "
"2.0 frame."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:359
msgid "Add option to peek into the FIFO instead of consuming the word."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:361
msgid ""
"If the allocation fails, store the read word into driver’s data. On the next "
"try, use the stored word instead of reading it again."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:364
msgid ""
"Option 1 is simple enough, but not very satisfying if we could do better. "
"Option 2 is not acceptable, as it would require modifying the private state "
"of an integral kernel structure. The slightly higher memory consumption is "
"just a virtual cherry on top of the “cake”. Option 3 requires non-trivial HW "
"changes and is not ideal from the HW point of view."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:371
msgid ""
"Option 4 seems like a good compromise, with its disadvantage being that a "
"partial frame may stay in the FIFO for a prolonged time. Nonetheless, there "
"may be just one owner of the RX FIFO, and thus no one else should see the "
"partial frame (disregarding some exotic debugging scenarios). Basides, the "
"driver resets the core on its initialization, so the partial frame cannot be "
"“adopted” either. In the end, option 4 was selected [5]_."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:382
msgid "Timestamping RX frames"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:384
msgid ""
"The CTU CAN FD core reports the exact timestamp when the frame has been "
"received. The timestamp is by default captured at the sample point of the "
"last bit of EOF but is configurable to be captured at the SOF bit. The "
"timestamp source is external to the core and may be up to 64 bits wide. At "
"the time of writing, passing the timestamp from kernel to userspace is not "
"yet implemented, but is planned in the future."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:392
msgid "Handling TX"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:394
msgid ""
"The CTU CAN FD core has 4 independent TX buffers, each with its own state "
"and priority. When the core wants to transmit, a TX buffer in Ready state "
"with the highest priority is selected."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:398
msgid ""
"The priorities are 3bit numbers in register TX_PRIORITY (nibble-aligned). "
"This should be flexible enough for most use cases. SocketCAN, however, "
"supports only one FIFO queue for outgoing frames [6]_. The buffer priorities "
"may be used to simulate the FIFO behavior by assigning each buffer a "
"distinct priority and *rotating* the priorities after a frame transmission "
"is completed."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:405
msgid ""
"In addition to priority rotation, the SW must maintain head and tail "
"pointers into the FIFO formed by the TX buffers to be able to determine "
"which buffer should be used for next frame (``txb_head``) and which should "
"be the first completed one (``txb_tail``). The actual buffer indices are "
"(obviously) modulo 4 (number of TX buffers), but the pointers must be at "
"least one bit wider to be able to distinguish between FIFO full and FIFO "
"empty – in this situation, :math:`txb\\_head \\equiv txb\\_tail\\ "
"(\\textrm{mod}\\ 4)`. An example of how the FIFO is maintained, together "
"with priority rotation, is depicted in"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:418
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:430
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:442
msgid "TXB#"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:418
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:430
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:442
msgid "0"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:418
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:430
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:442
msgid "1"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:418
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:430
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:442
msgid "2"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:418
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:430
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:442
msgid "3"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:420
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:432
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:444
msgid "Seq"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:420
msgid "A"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:420
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:432
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:444
msgid "B"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:420
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:432
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:444
msgid "C"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:422
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:434
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:446
msgid "Prio"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:422
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:434
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:446
msgid "7"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:422
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:434
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:446
msgid "6"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:422
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:434
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:446
msgid "5"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:422
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:434
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:446
msgid "4"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:424
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:436
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:448
msgid "T"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:424
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:436
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:448
msgid "H"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:442
msgid "0’"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:444
msgid "E"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:444
msgid "D"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:455
msgid "TX Buffer states with possible transitions"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:460
msgid "Timestamping TX frames"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:462
msgid ""
"When submitting a frame to a TX buffer, one may specify the timestamp at "
"which the frame should be transmitted. The frame transmission may start "
"later, but not sooner. Note that the timestamp does not participate in "
"buffer prioritization – that is decided solely by the mechanism described "
"above."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:468
msgid ""
"Support for time-based packet transmission was recently merged to Linux "
"v4.19 `Time-based packet transmission <https://lwn.net/Articles/748879/>`_, "
"but it remains yet to be researched whether this functionality will be "
"practical for CAN."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:473
msgid ""
"Also similarly to retrieving the timestamp of RX frames, the core supports "
"retrieving the timestamp of TX frames – that is the time when the frame was "
"successfully delivered. The particulars are very similar to timestamping RX "
"frames and are described in ."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:479
msgid "Handling RX buffer overrun"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:481
msgid ""
"When a received frame does no more fit into the hardware RX FIFO in its "
"entirety, RX FIFO overrun flag (STATUS[DOR]) is set and Data Overrun "
"Interrupt (DOI) is triggered. When servicing the interrupt, care must be "
"taken first to clear the DOR flag (via COMMAND[CDO]) and after that clear "
"the DOI interrupt flag. Otherwise, the interrupt would be immediately [7]_ "
"rearmed."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:488
msgid ""
"**Note**: During development, it was discussed whether the internal HW "
"pipelining cannot disrupt this clear sequence and whether an additional "
"dummy cycle is necessary between clearing the flag and the interrupt. On the "
"Avalon interface, it indeed proved to be the case, but APB being safe "
"because it uses 2-cycle transactions. Essentially, the DOR flag would be "
"cleared, but DOI register’s Preset input would still be high the cycle when "
"the DOI clear request would also be applied (by setting the register’s Reset "
"input high). As Set had higher priority than Reset, the DOI flag would not "
"be reset. This has been already fixed by swapping the Set/Reset priority "
"(see issue #187)."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:500
msgid "Reporting Error Passive and Bus Off conditions"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:502
msgid ""
"It may be desirable to report when the node reaches *Error Passive*, *Error "
"Warning*, and *Bus Off* conditions. The driver is notified about error state "
"change by an interrupt (EPI, EWLI), and then proceeds to determine the "
"core’s error state by reading its error counters."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:507
msgid ""
"There is, however, a slight race condition here – there is a delay between "
"the time when the state transition occurs (and the interrupt is triggered) "
"and when the error counters are read. When EPI is received, the node may be "
"either *Error Passive* or *Bus Off*. If the node goes *Bus Off*, it "
"obviously remains in the state until it is reset. Otherwise, the node is *or "
"was* *Error Passive*. However, it may happen that the read state is *Error "
"Warning* or even *Error Active*. It may be unclear whether and what exactly "
"to report in that case, but I personally entertain the idea that the past "
"error condition should still be reported. Similarly, when EWLI is received "
"but the state is later detected to be *Error Passive*, *Error Passive* "
"should be reported."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:521
msgid "CTU CAN FD Driver Sources Reference"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:57
msgid "Device type independent registration call"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:61
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:159
#: drivers/net/can/ctucanfd/ctucanfd_base.c:174
#: drivers/net/can/ctucanfd/ctucanfd_base.c:202
#: drivers/net/can/ctucanfd/ctucanfd_base.c:259
#: drivers/net/can/ctucanfd/ctucanfd_base.c:274
#: drivers/net/can/ctucanfd/ctucanfd_base.c:289
#: drivers/net/can/ctucanfd/ctucanfd_base.c:326
#: drivers/net/can/ctucanfd/ctucanfd_base.c:369
#: drivers/net/can/ctucanfd/ctucanfd_base.c:440
#: drivers/net/can/ctucanfd/ctucanfd_base.c:473
#: drivers/net/can/ctucanfd/ctucanfd_base.c:488
#: drivers/net/can/ctucanfd/ctucanfd_base.c:507
#: drivers/net/can/ctucanfd/ctucanfd_base.c:576
#: drivers/net/can/ctucanfd/ctucanfd_base.c:590
#: drivers/net/can/ctucanfd/ctucanfd_base.c:644
#: drivers/net/can/ctucanfd/ctucanfd_base.c:705
#: drivers/net/can/ctucanfd/ctucanfd_base.c:753
#: drivers/net/can/ctucanfd/ctucanfd_base.c:785
#: drivers/net/can/ctucanfd/ctucanfd_base.c:798
#: drivers/net/can/ctucanfd/ctucanfd_base.c:920
#: drivers/net/can/ctucanfd/ctucanfd_base.c:981
#: drivers/net/can/ctucanfd/ctucanfd_base.c:996
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1096
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1175
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1198
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1258
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1279
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:77
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:223
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:44
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:87
msgid "**Parameters**"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:63
msgid "``struct device *dev``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:62
msgid "Handle to the generic device structure"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:64
msgid "``void __iomem *addr``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:63
msgid "Base address of CTU CAN FD core address"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:65
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1098
msgid "``int irq``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:64
msgid "Interrupt number"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:66
msgid "``unsigned int ntxbufs``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:65
msgid "Number of implemented Tx buffers"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:67
msgid "``unsigned long can_clk_rate``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:66
msgid "Clock rate, if 0 then clock are taken from device node"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:68
msgid "``int pm_enable_call``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:67
msgid "Whether pm_runtime_enable should be called"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:69
msgid ""
"``void (*set_drvdata_fnc)(struct device *dev, struct net_device *ndev)``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:68
msgid "Function to set network driver data for physical device"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:70
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:368
#: drivers/net/can/ctucanfd/ctucanfd_base.c:440
#: drivers/net/can/ctucanfd/ctucanfd_base.c:590
#: drivers/net/can/ctucanfd/ctucanfd_base.c:704
#: drivers/net/can/ctucanfd/ctucanfd_base.c:798
#: drivers/net/can/ctucanfd/ctucanfd_base.c:920
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1096
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1174
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1197
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1279
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:77
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:222
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:43
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:86
msgid "**Description**"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:58
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:76
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:42
msgid ""
"This function does all the memory allocation and registration for the CAN "
"device."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:61
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:158
#: drivers/net/can/ctucanfd/ctucanfd_base.c:173
#: drivers/net/can/ctucanfd/ctucanfd_base.c:203
#: drivers/net/can/ctucanfd/ctucanfd_base.c:258
#: drivers/net/can/ctucanfd/ctucanfd_base.c:273
#: drivers/net/can/ctucanfd/ctucanfd_base.c:288
#: drivers/net/can/ctucanfd/ctucanfd_base.c:372
#: drivers/net/can/ctucanfd/ctucanfd_base.c:441
#: drivers/net/can/ctucanfd/ctucanfd_base.c:473
#: drivers/net/can/ctucanfd/ctucanfd_base.c:488
#: drivers/net/can/ctucanfd/ctucanfd_base.c:509
#: drivers/net/can/ctucanfd/ctucanfd_base.c:592
#: drivers/net/can/ctucanfd/ctucanfd_base.c:706
#: drivers/net/can/ctucanfd/ctucanfd_base.c:752
#: drivers/net/can/ctucanfd/ctucanfd_base.c:921
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1098
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1198
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1257
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1280
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:79
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:223
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:45
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:87
msgid "**Return**"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:523:
#: drivers/net/can/ctucanfd/ctucanfd.h:70
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:373
#: drivers/net/can/ctucanfd/ctucanfd_base.c:442
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1198
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1280
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:80
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:46
msgid "0 on success and failure value on error"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:155
msgid "Converts CAN controller state code to corresponding text"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:161
msgid "``enum can_state state``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:156
msgid "CAN controller state code"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:158
msgid "Pointer to string representation of the error state"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:170
msgid "Issues software reset request to CTU CAN FD"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:176
#: drivers/net/can/ctucanfd/ctucanfd_base.c:204
#: drivers/net/can/ctucanfd/ctucanfd_base.c:261
#: drivers/net/can/ctucanfd/ctucanfd_base.c:276
#: drivers/net/can/ctucanfd/ctucanfd_base.c:291
#: drivers/net/can/ctucanfd/ctucanfd_base.c:371
#: drivers/net/can/ctucanfd/ctucanfd_base.c:442
#: drivers/net/can/ctucanfd/ctucanfd_base.c:589
#: drivers/net/can/ctucanfd/ctucanfd_base.c:707
#: drivers/net/can/ctucanfd/ctucanfd_base.c:800
#: drivers/net/can/ctucanfd/ctucanfd_base.c:983
#: drivers/net/can/ctucanfd/ctucanfd_base.c:998
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1177
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1200
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1260
msgid "``struct net_device *ndev``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:171
#: drivers/net/can/ctucanfd/ctucanfd_base.c:199
#: drivers/net/can/ctucanfd/ctucanfd_base.c:256
#: drivers/net/can/ctucanfd/ctucanfd_base.c:271
#: drivers/net/can/ctucanfd/ctucanfd_base.c:286
#: drivers/net/can/ctucanfd/ctucanfd_base.c:366
#: drivers/net/can/ctucanfd/ctucanfd_base.c:437
#: drivers/net/can/ctucanfd/ctucanfd_base.c:588
#: drivers/net/can/ctucanfd/ctucanfd_base.c:702
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1172
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1195
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1255
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1276
msgid "Pointer to net_device structure"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:173
msgid "0 for success, -``ETIMEDOUT`` if CAN controller does not leave reset"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:198
msgid "Sets CAN bus bit timing in CTU CAN FD"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:201
msgid "``struct can_bittiming *bt``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:200
msgid "Pointer to Bit timing structure"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:202
msgid "``bool nominal``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:201
msgid "True - Nominal bit timing, False - Data bit timing"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:203
msgid "0 - OK, -``EPERM`` if controller is enabled"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:255
msgid "CAN set nominal bit timing routine"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:258
#: drivers/net/can/ctucanfd/ctucanfd_base.c:273
msgid "0 on success, -``EPERM`` on error"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:270
msgid "CAN set data bit timing routine"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:285
msgid "Sets secondary sample point in CTU CAN FD"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:288
msgid "0 on success, -``EPERM`` if controller is enabled"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:322
msgid "Sets CTU CAN FDs mode"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:328
#: drivers/net/can/ctucanfd/ctucanfd_base.c:475
#: drivers/net/can/ctucanfd/ctucanfd_base.c:490
#: drivers/net/can/ctucanfd/ctucanfd_base.c:509
#: drivers/net/can/ctucanfd/ctucanfd_base.c:578
#: drivers/net/can/ctucanfd/ctucanfd_base.c:646
#: drivers/net/can/ctucanfd/ctucanfd_base.c:755
#: drivers/net/can/ctucanfd/ctucanfd_base.c:787
msgid "``struct ctucan_priv *priv``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:323
#: drivers/net/can/ctucanfd/ctucanfd_base.c:470
#: drivers/net/can/ctucanfd/ctucanfd_base.c:485
#: drivers/net/can/ctucanfd/ctucanfd_base.c:504
#: drivers/net/can/ctucanfd/ctucanfd_base.c:573
#: drivers/net/can/ctucanfd/ctucanfd_base.c:750
#: drivers/net/can/ctucanfd/ctucanfd_base.c:782
msgid "Pointer to private data"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:325
msgid "``const struct can_ctrlmode *mode``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:324
msgid "Pointer to controller modes to be set"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:365
msgid "This routine starts the driver"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:367
msgid ""
"Routine expects that chip is in reset state. It setups initial Tx buffers "
"for FIFO priorities, sets bittiming, enables interrupts, switches core to "
"operational mode and changes controller state to ``CAN_STATE_STOPPED``."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:436
msgid "Sets mode of the driver"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:439
msgid "``enum can_mode mode``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:438
msgid "Tells the mode of the driver"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:439
msgid "This check the drivers state and calls the corresponding modes to set."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:469
msgid "Gets status of TXT buffer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:472
#: drivers/net/can/ctucanfd/ctucanfd_base.c:487
#: drivers/net/can/ctucanfd/ctucanfd_base.c:507
#: drivers/net/can/ctucanfd/ctucanfd_base.c:576
msgid "``u8 buf``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:471
#: drivers/net/can/ctucanfd/ctucanfd_base.c:486
#: drivers/net/can/ctucanfd/ctucanfd_base.c:575
msgid "Buffer index (0-based)"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:473
msgid "Status of TXT buffer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:484
msgid "Checks if frame can be inserted to TXT Buffer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:488
msgid ""
"True - Frame can be inserted to TXT Buffer, False - If attempted, frame will "
"not be inserted to TXT Buffer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:503
msgid "Inserts frame to TXT buffer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:506
msgid "``const struct canfd_frame *cf``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:505
msgid "Pointer to CAN frame to be inserted"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:506
msgid "TXT Buffer index to which frame is inserted (0-based)"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:508
msgid "``bool isfdf``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:507
msgid "True - CAN FD Frame, False - CAN 2.0 Frame"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:509
msgid "True - Frame inserted successfully"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:510
msgid "False - Frame was not inserted due to one of:"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:511
msgid "TXT Buffer is not writable (it is in wrong state)"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:512
msgid "Invalid TXT buffer index"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:513
msgid "Invalid frame length"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:572
msgid "Applies command on TXT buffer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:575
msgid "``enum ctucan_txtb_command cmd``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:574
msgid "Command to give"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:586
msgid "Starts the transmission"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:592
msgid "``struct sk_buff *skb``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:587
msgid "sk_buff pointer that contains data to be Txed"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:589
msgid ""
"Invoked from upper layers to initiate transmission. Uses the next available "
"free TXT Buffer and populates its fields to start the transmission."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:593
msgid ""
"``NETDEV_TX_OK`` on success, ``NETDEV_TX_BUSY`` when no free TXT buffer is "
"available, negative return values reserved for error cases"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:640
msgid "Reads frame from RX FIFO"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:641
msgid "Pointer to CTU CAN FD's private data"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:643
msgid "``struct canfd_frame *cf``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:642
msgid "Pointer to CAN frame struct"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:644
msgid "``u32 ffw``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:643
msgid "Previously read frame format word"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:645
msgid "**Note**"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:645
msgid "Frame format word must be read separately and provided in 'ffw'."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:701
msgid "Called from CAN ISR to complete the received frame processing"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:703
msgid ""
"This function is invoked from the CAN isr(poll) to process the Rx frames. It "
"does minimal processing and invokes \"netif_receive_skb\" to complete "
"further processing."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:706
msgid ""
"1 when frame is passed to the network layer, 0 when the first frame word is "
"read but system is out of free SKBs temporally and left code to resolve SKB "
"allocation later, -``EAGAIN`` in a case of empty Rx FIFO."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:749
msgid "Reads CTU CAN FDs fault confinement state."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:752
msgid "Fault confinement state of controller"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:781
msgid "Reads REC/TEC counter values from controller"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:784
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1278
msgid "``struct can_berr_counter *bec``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:783
msgid "Pointer to Error counter structure"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:794
msgid "Error frame ISR"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:795
#: drivers/net/can/ctucanfd/ctucanfd_base.c:978
#: drivers/net/can/ctucanfd/ctucanfd_base.c:993
msgid "net_device pointer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:797
msgid "``u32 isr``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:796
msgid "interrupt status register value"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:797
msgid ""
"This is the CAN error interrupt and it will check the type of error and "
"forward the error frame to upper layers."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:916
msgid "Poll routine for rx packets (NAPI)"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:922
msgid "``struct napi_struct *napi``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:917
msgid "NAPI structure pointer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:919
msgid "``int quota``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:918
msgid "Max number of rx packets to be processed."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:919
msgid ""
"This is the poll routine for rx part. It will process the packets maximux "
"quota value."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:922
msgid "Number of packets received"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:977
msgid "Rotates priorities of TXT Buffers"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:992
msgid "Tx done Isr"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1092
msgid "CAN Isr"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1093
msgid "irq number"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1095
msgid "``void *dev_id``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1094
msgid "device id pointer"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1095
msgid ""
"This is the CTU CAN FD ISR. It checks for the type of interrupt and invokes "
"the corresponding ISR."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1099
msgid "IRQ_NONE - If CAN device is in sleep mode, IRQ_HANDLED otherwise"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1171
msgid "Driver stop routine"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1173
msgid ""
"This is the drivers stop routine. It will disable the interrupts and disable "
"the controller."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1194
msgid "Driver open routine"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1196
msgid "This is the driver open routine."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1254
msgid "Driver close routine"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1257
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:223
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:87
msgid "0 always"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1275
msgid "error counter routine"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1281
msgid "``const struct net_device *ndev``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1277
msgid "Pointer to can_berr_counter structure"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:526:
#: drivers/net/can/ctucanfd/ctucanfd_base.c:1278
msgid "This is the driver error counter routine."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:73
msgid "PCI registration call"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:79
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:225
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:74
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:220
msgid "Handle to the pci device structure"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:76
msgid "``const struct pci_device_id *ent``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:75
msgid "Pointer to the entry from ctucan_pci_tbl"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:219
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:83
msgid "Unregister the device after releasing the resources"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:529:
#: drivers/net/can/ctucanfd/ctucanfd_pci.c:221
#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:85
msgid "This function frees all the resources allocated to the device."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:40
msgid "Platform registration call"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:46
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:89
msgid "``struct platform_device *pdev``"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver:532:
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:41
#: drivers/net/can/ctucanfd/ctucanfd_platform.c:84
msgid "Handle to the platform device structure"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:536
msgid "CTU CAN FD IP Core and Driver Development Acknowledgment"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:538
msgid "Odrej Ille <ondrej.ille@gmail.com>"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:540
msgid "started the project as student at Department of Measurement, FEE, CTU"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:541
msgid ""
"invested great amount of personal time and enthusiasm to the project over "
"years"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:542
msgid "worked on more funded tasks"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:544
msgid ""
"`Department of Measurement <https://meas.fel.cvut.cz/>`_, `Faculty of "
"Electrical Engineering <http://www.fel.cvut.cz/en/>`_, `Czech Technical "
"University <https://www.cvut.cz/en>`_"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:548
msgid "is the main investor into the project over many years"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:549
msgid ""
"uses project in their CAN/CAN FD diagnostics framework for `Skoda Auto "
"<https://www.skoda-auto.cz/>`_"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:551
msgid "`Digiteq Automotive <https://www.digiteqautomotive.com/en>`_"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:553
msgid ""
"funding of the project CAN FD Open Cores Support Linux Kernel Based Systems"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:554
msgid "negotiated and paid CTU to allow public access to the project"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:555
msgid "provided additional funding of the work"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:557
msgid ""
"`Department of Control Engineering <https://control.fel.cvut.cz/en>`_, "
"`Faculty of Electrical Engineering <http://www.fel.cvut.cz/en/>`_, `Czech "
"Technical University <https://www.cvut.cz/en>`_"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:561
msgid ""
"solving the project CAN FD Open Cores Support Linux Kernel Based Systems"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:562
msgid "providing GitLab management"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:563
msgid "virtual servers and computational power for continuous integration"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:564
msgid "providing hardware for HIL continuous integration tests"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:566
msgid "`PiKRON Ltd. <http://pikron.com/>`_"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:568
msgid "minor funding to initiate preparation of the project open-sourcing"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:570
msgid "Petr Porazil <porazil@pikron.com>"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:572
msgid "design of PCIe transceiver addon board and assembly of boards"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:573
msgid "design and assembly of MZ_APO baseboard for MicroZed/Zynq based system"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:575
msgid "Martin Jerabek <martin.jerabek01@gmail.com>"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:577
msgid "Linux driver development"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:578
msgid "continuous integration platform architect and GHDL updates"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:579
msgid ""
"thesis `Open-source and Open-hardware CAN FD Protocol Support <https://"
"dspace.cvut.cz/bitstream/handle/10467/80366/F3-DP-2019-Jerabek-Martin-"
"Jerabek-thesis-2019-canfd.pdf>`_"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:581
msgid "Jiri Novak <jnovak@fel.cvut.cz>"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:583
msgid ""
"project initiation, management and use at Department of Measurement, FEE, CTU"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:585
msgid "Pavel Pisa <pisa@cmp.felk.cvut.cz>"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:587
msgid ""
"initiate open-sourcing, project coordination, management at Department of "
"Control Engineering, FEE, CTU"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:589
msgid "Jaroslav Beran<jara.beran@gmail.com>"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:591
msgid "system integration for Intel SoC, core and driver testing and updates"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:593
msgid "Carsten Emde (`OSADL <https://www.osadl.org/>`_)"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:595
msgid "provided OSADL expertise to discuss IP core licensing"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:596
msgid ""
"pointed to possible deadlock for LGPL and CAN bus possible patent case which "
"lead to relicense IP core design to BSD like license"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:598
msgid ""
"Reiner Zitzmann and Holger Zeltwanger (`CAN in Automation <https://www.can-"
"cia.org/>`_)"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:600
msgid ""
"provided suggestions and help to inform community about the project and "
"invited us to events focused on CAN bus future development directions"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:602
msgid "Jan Charvat"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:604
msgid ""
"implemented CTU CAN FD functional model for QEMU which has been integrated "
"into QEMU mainline (`docs/system/devices/can.rst <https://www.qemu.org/docs/"
"master/system/devices/can.html>`_)"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:605
msgid ""
"Bachelor thesis Model of CAN FD Communication Controller for QEMU Emulator"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:608
msgid "Notes"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:612
msgid ""
"Other buses have their own specific driver interface to set up the device."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:616
msgid ""
"Not to be mistaken with CAN Error Frame. This is a ``can_frame`` with "
"``CAN_ERR_FLAG`` set and some error info in its ``data`` field."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:620
msgid ""
"Available in CTU CAN FD repository `<https://gitlab.fel.cvut.cz/canbus/"
"ctucanfd_ip_core>`_"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:624
msgid ""
"As is done in the low-level driver functions ``ctucan_hw_set_nom_bittiming`` "
"and ``ctucan_hw_set_data_bittiming``."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:629
msgid ""
"At the time of writing this thesis, option 1 is still being used and the "
"modification is queued in gitlab issue #222"
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:633
msgid ""
"Strictly speaking, multiple CAN TX queues are supported since v4.19 `can: "
"enable multi-queue for SocketCAN devices <https://lore.kernel.org/patchwork/"
"patch/913526/>`_ but no mainline driver is using them yet."
msgstr ""

#: ../../../networking/device_drivers/can/ctu/ctucanfd-driver.rst:638
msgid "Or rather in the next clock cycle"
msgstr ""
