# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-28 09:03+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/rxrpc.rst:5
msgid "RxRPC Network Protocol"
msgstr ""

#: ../../../networking/rxrpc.rst:7
msgid ""
"The RxRPC protocol driver provides a reliable two-phase transport on top of "
"UDP that can be used to perform RxRPC remote operations.  This is done over "
"sockets of AF_RXRPC family, using sendmsg() and recvmsg() with control data "
"to send and receive data, aborts and errors."
msgstr ""

#: ../../../networking/rxrpc.rst:12
msgid "Contents of this document:"
msgstr ""

#: ../../../networking/rxrpc.rst:14
msgid "Overview."
msgstr ""

#: ../../../networking/rxrpc.rst:16
msgid "RxRPC protocol summary."
msgstr ""

#: ../../../networking/rxrpc.rst:18
msgid "AF_RXRPC driver model."
msgstr ""

#: ../../../networking/rxrpc.rst:20
msgid "Control messages."
msgstr ""

#: ../../../networking/rxrpc.rst:22
msgid "Socket options."
msgstr ""

#: ../../../networking/rxrpc.rst:24
msgid "Security."
msgstr ""

#: ../../../networking/rxrpc.rst:26
msgid "Example client usage."
msgstr ""

#: ../../../networking/rxrpc.rst:28
msgid "Example server usage."
msgstr ""

#: ../../../networking/rxrpc.rst:30
msgid "AF_RXRPC kernel interface."
msgstr ""

#: ../../../networking/rxrpc.rst:32
msgid "Configurable parameters."
msgstr ""

#: ../../../networking/rxrpc.rst:36
msgid "Overview"
msgstr ""

#: ../../../networking/rxrpc.rst:38
msgid ""
"RxRPC is a two-layer protocol.  There is a session layer which provides "
"reliable virtual connections using UDP over IPv4 (or IPv6) as the transport "
"layer, but implements a real network protocol; and there's the presentation "
"layer which renders structured data to binary blobs and back again using XDR "
"(as does SunRPC)::"
msgstr ""

#: ../../../networking/rxrpc.rst:55
msgid "AF_RXRPC provides:"
msgstr ""

#: ../../../networking/rxrpc.rst:57
msgid ""
"Part of an RxRPC facility for both kernel and userspace applications by "
"making the session part of it a Linux network protocol (AF_RXRPC)."
msgstr ""

#: ../../../networking/rxrpc.rst:60
msgid ""
"A two-phase protocol.  The client transmits a blob (the request) and then "
"receives a blob (the reply), and the server receives the request and then "
"transmits the reply."
msgstr ""

#: ../../../networking/rxrpc.rst:64
msgid ""
"Retention of the reusable bits of the transport system set up for one call "
"to speed up subsequent calls."
msgstr ""

#: ../../../networking/rxrpc.rst:67
msgid ""
"A secure protocol, using the Linux kernel's key retention facility to manage "
"security on the client end.  The server end must of necessity be more active "
"in security negotiations."
msgstr ""

#: ../../../networking/rxrpc.rst:71
msgid ""
"AF_RXRPC does not provide XDR marshalling/presentation facilities.  That is "
"left to the application.  AF_RXRPC only deals in blobs.  Even the operation "
"ID is just the first four bytes of the request blob, and as such is beyond "
"the kernel's interest."
msgstr ""

#: ../../../networking/rxrpc.rst:77
msgid "Sockets of AF_RXRPC family are:"
msgstr ""

#: ../../../networking/rxrpc.rst:79
msgid "created as type SOCK_DGRAM;"
msgstr ""

#: ../../../networking/rxrpc.rst:81
msgid ""
"provided with a protocol of the type of underlying transport they're going "
"to use - currently only PF_INET is supported."
msgstr ""

#: ../../../networking/rxrpc.rst:85
msgid ""
"The Andrew File System (AFS) is an example of an application that uses this "
"and that has both kernel (filesystem) and userspace (utility) components."
msgstr ""

#: ../../../networking/rxrpc.rst:90
msgid "RxRPC Protocol Summary"
msgstr ""

#: ../../../networking/rxrpc.rst:92
msgid "An overview of the RxRPC protocol:"
msgstr ""

#: ../../../networking/rxrpc.rst:94
msgid ""
"RxRPC sits on top of another networking protocol (UDP is the only option "
"currently), and uses this to provide network transport.  UDP ports, for "
"example, provide transport endpoints."
msgstr ""

#: ../../../networking/rxrpc.rst:98
msgid ""
"RxRPC supports multiple virtual \"connections\" from any given transport "
"endpoint, thus allowing the endpoints to be shared, even to the same remote "
"endpoint."
msgstr ""

#: ../../../networking/rxrpc.rst:102
msgid ""
"Each connection goes to a particular \"service\".  A connection may not go "
"to multiple services.  A service may be considered the RxRPC equivalent of a "
"port number.  AF_RXRPC permits multiple services to share an endpoint."
msgstr ""

#: ../../../networking/rxrpc.rst:106
msgid ""
"Client-originating packets are marked, thus a transport endpoint can be "
"shared between client and server connections (connections have a direction)."
msgstr ""

#: ../../../networking/rxrpc.rst:110
msgid ""
"Up to a billion connections may be supported concurrently between one local "
"transport endpoint and one service on one remote endpoint.  An RxRPC "
"connection is described by seven numbers::"
msgstr ""

#: ../../../networking/rxrpc.rst:122
msgid ""
"Each RxRPC operation is a \"call\".  A connection may make up to four "
"billion calls, but only up to four calls may be in progress on a connection "
"at any one time."
msgstr ""

#: ../../../networking/rxrpc.rst:126
msgid ""
"Calls are two-phase and asymmetric: the client sends its request data, which "
"the service receives; then the service transmits the reply data which the "
"client receives."
msgstr ""

#: ../../../networking/rxrpc.rst:130
msgid ""
"The data blobs are of indefinite size, the end of a phase is marked with a "
"flag in the packet.  The number of packets of data making up one blob may "
"not exceed 4 billion, however, as this would cause the sequence number to "
"wrap."
msgstr ""

#: ../../../networking/rxrpc.rst:135
msgid "The first four bytes of the request data are the service operation ID."
msgstr ""

#: ../../../networking/rxrpc.rst:137
msgid ""
"Security is negotiated on a per-connection basis.  The connection is "
"initiated by the first data packet on it arriving.  If security is "
"requested, the server then issues a \"challenge\" and then the client "
"replies with a \"response\".  If the response is successful, the security is "
"set for the lifetime of that connection, and all subsequent calls made upon "
"it use that same security.  In the event that the server lets a connection "
"lapse before the client, the security will be renegotiated if the client "
"uses the connection again."
msgstr ""

#: ../../../networking/rxrpc.rst:146
msgid ""
"Calls use ACK packets to handle reliability.  Data packets are also "
"explicitly sequenced per call."
msgstr ""

#: ../../../networking/rxrpc.rst:149
msgid ""
"There are two types of positive acknowledgment: hard-ACKs and soft-ACKs. A "
"hard-ACK indicates to the far side that all the data received to a point has "
"been received and processed; a soft-ACK indicates that the data has been "
"received but may yet be discarded and re-requested.  The sender may not "
"discard any transmittable packets until they've been hard-ACK'd."
msgstr ""

#: ../../../networking/rxrpc.rst:155
msgid ""
"Reception of a reply data packet implicitly hard-ACK's all the data packets "
"that make up the request."
msgstr ""

#: ../../../networking/rxrpc.rst:158
msgid ""
"An call is complete when the request has been sent, the reply has been "
"received and the final hard-ACK on the last packet of the reply has reached "
"the server."
msgstr ""

#: ../../../networking/rxrpc.rst:162
msgid "An call may be aborted by either end at any time up to its completion."
msgstr ""

#: ../../../networking/rxrpc.rst:166
msgid "AF_RXRPC Driver Model"
msgstr ""

#: ../../../networking/rxrpc.rst:168
msgid "About the AF_RXRPC driver:"
msgstr ""

#: ../../../networking/rxrpc.rst:170
msgid ""
"The AF_RXRPC protocol transparently uses internal sockets of the transport "
"protocol to represent transport endpoints."
msgstr ""

#: ../../../networking/rxrpc.rst:173
msgid ""
"AF_RXRPC sockets map onto RxRPC connection bundles.  Actual RxRPC "
"connections are handled transparently.  One client socket may be used to "
"make multiple simultaneous calls to the same service.  One server socket may "
"handle calls from many clients."
msgstr ""

#: ../../../networking/rxrpc.rst:178
msgid ""
"Additional parallel client connections will be initiated to support extra "
"concurrent calls, up to a tunable limit."
msgstr ""

#: ../../../networking/rxrpc.rst:181
msgid ""
"Each connection is retained for a certain amount of time [tunable] after the "
"last call currently using it has completed in case a new call is made that "
"could reuse it."
msgstr ""

#: ../../../networking/rxrpc.rst:185
msgid ""
"Each internal UDP socket is retained [tunable] for a certain amount of time "
"[tunable] after the last connection using it discarded, in case a new "
"connection is made that could use it."
msgstr ""

#: ../../../networking/rxrpc.rst:189
msgid ""
"A client-side connection is only shared between calls if they have the same "
"key struct describing their security (and assuming the calls would otherwise "
"share the connection).  Non-secured calls would also be able to share "
"connections with each other."
msgstr ""

#: ../../../networking/rxrpc.rst:194
msgid "A server-side connection is shared if the client says it is."
msgstr ""

#: ../../../networking/rxrpc.rst:196
msgid ""
"ACK'ing is handled by the protocol driver automatically, including ping "
"replying."
msgstr ""

#: ../../../networking/rxrpc.rst:199
msgid ""
"SO_KEEPALIVE automatically pings the other side to keep the connection alive "
"[TODO]."
msgstr ""

#: ../../../networking/rxrpc.rst:202
msgid ""
"If an ICMP error is received, all calls affected by that error will be "
"aborted with an appropriate network error passed through recvmsg()."
msgstr ""

#: ../../../networking/rxrpc.rst:206
msgid "Interaction with the user of the RxRPC socket:"
msgstr ""

#: ../../../networking/rxrpc.rst:208
msgid ""
"A socket is made into a server socket by binding an address with a non-zero "
"service ID."
msgstr ""

#: ../../../networking/rxrpc.rst:211
msgid ""
"In the client, sending a request is achieved with one or more sendmsgs, "
"followed by the reply being received with one or more recvmsgs."
msgstr ""

#: ../../../networking/rxrpc.rst:214
msgid ""
"The first sendmsg for a request to be sent from a client contains a tag to "
"be used in all other sendmsgs or recvmsgs associated with that call.  The "
"tag is carried in the control data."
msgstr ""

#: ../../../networking/rxrpc.rst:218
msgid ""
"connect() is used to supply a default destination address for a client "
"socket.  This may be overridden by supplying an alternate address to the "
"first sendmsg() of a call (struct msghdr::msg_name)."
msgstr ""

#: ../../../networking/rxrpc.rst:222
msgid ""
"If connect() is called on an unbound client, a random local port will bound "
"before the operation takes place."
msgstr ""

#: ../../../networking/rxrpc.rst:225
msgid ""
"A server socket may also be used to make client calls.  To do this, the "
"first sendmsg() of the call must specify the target address.  The server's "
"transport endpoint is used to send the packets."
msgstr ""

#: ../../../networking/rxrpc.rst:229
msgid ""
"Once the application has received the last message associated with a call, "
"the tag is guaranteed not to be seen again, and so it can be used to pin "
"client resources.  A new call can then be initiated with the same tag "
"without fear of interference."
msgstr ""

#: ../../../networking/rxrpc.rst:234
msgid ""
"In the server, a request is received with one or more recvmsgs, then the the "
"reply is transmitted with one or more sendmsgs, and then the final ACK is "
"received with a last recvmsg."
msgstr ""

#: ../../../networking/rxrpc.rst:238
msgid ""
"When sending data for a call, sendmsg is given MSG_MORE if there's more data "
"to come on that call."
msgstr ""

#: ../../../networking/rxrpc.rst:241
msgid ""
"When receiving data for a call, recvmsg flags MSG_MORE if there's more data "
"to come for that call."
msgstr ""

#: ../../../networking/rxrpc.rst:244
msgid ""
"When receiving data or messages for a call, MSG_EOR is flagged by recvmsg to "
"indicate the terminal message for that call."
msgstr ""

#: ../../../networking/rxrpc.rst:247
msgid ""
"A call may be aborted by adding an abort control message to the control "
"data.  Issuing an abort terminates the kernel's use of that call's tag. Any "
"messages waiting in the receive queue for that call will be discarded."
msgstr ""

#: ../../../networking/rxrpc.rst:251
msgid ""
"Aborts, busy notifications and challenge packets are delivered by recvmsg, "
"and control data messages will be set to indicate the context.  Receiving an "
"abort or a busy message terminates the kernel's use of that call's tag."
msgstr ""

#: ../../../networking/rxrpc.rst:255
msgid ""
"The control data part of the msghdr struct is used for a number of things:"
msgstr ""

#: ../../../networking/rxrpc.rst:257
msgid "The tag of the intended or affected call."
msgstr ""

#: ../../../networking/rxrpc.rst:259
msgid "Sending or receiving errors, aborts and busy notifications."
msgstr ""

#: ../../../networking/rxrpc.rst:261
msgid "Notifications of incoming calls."
msgstr ""

#: ../../../networking/rxrpc.rst:263
msgid "Sending debug requests and receiving debug replies [TODO]."
msgstr ""

#: ../../../networking/rxrpc.rst:265
msgid ""
"When the kernel has received and set up an incoming call, it sends a message "
"to server application to let it know there's a new call awaiting its "
"acceptance [recvmsg reports a special control message].  The server "
"application then uses sendmsg to assign a tag to the new call.  Once that is "
"done, the first part of the request data will be delivered by recvmsg."
msgstr ""

#: ../../../networking/rxrpc.rst:271
msgid ""
"The server application has to provide the server socket with a keyring of "
"secret keys corresponding to the security types it permits.  When a secure "
"connection is being set up, the kernel looks up the appropriate secret key "
"in the keyring and then sends a challenge packet to the client and receives "
"a response packet.  The kernel then checks the authorisation of the packet "
"and either aborts the connection or sets up the security."
msgstr ""

#: ../../../networking/rxrpc.rst:278
msgid ""
"The name of the key a client will use to secure its communications is "
"nominated by a socket option."
msgstr ""

#: ../../../networking/rxrpc.rst:282
msgid "Notes on sendmsg:"
msgstr ""

#: ../../../networking/rxrpc.rst:284
msgid ""
"MSG_WAITALL can be set to tell sendmsg to ignore signals if the peer is "
"making progress at accepting packets within a reasonable time such that we "
"manage to queue up all the data for transmission.  This requires the client "
"to accept at least one packet per 2*RTT time period."
msgstr ""

#: ../../../networking/rxrpc.rst:289
msgid ""
"If this isn't set, sendmsg() will return immediately, either returning EINTR/"
"ERESTARTSYS if nothing was consumed or returning the amount of data consumed."
msgstr ""

#: ../../../networking/rxrpc.rst:294
msgid "Notes on recvmsg:"
msgstr ""

#: ../../../networking/rxrpc.rst:296
msgid ""
"If there's a sequence of data messages belonging to a particular call on the "
"receive queue, then recvmsg will keep working through them until:"
msgstr ""

#: ../../../networking/rxrpc.rst:299
msgid "it meets the end of that call's received data,"
msgstr ""

#: ../../../networking/rxrpc.rst:301
msgid "it meets a non-data message,"
msgstr ""

#: ../../../networking/rxrpc.rst:303
msgid "it meets a message belonging to a different call, or"
msgstr ""

#: ../../../networking/rxrpc.rst:305
msgid "it fills the user buffer."
msgstr ""

#: ../../../networking/rxrpc.rst:307
msgid ""
"If recvmsg is called in blocking mode, it will keep sleeping, awaiting the "
"reception of further data, until one of the above four conditions is met."
msgstr ""

#: ../../../networking/rxrpc.rst:310
msgid ""
"MSG_PEEK operates similarly, but will return immediately if it has put any "
"data in the buffer rather than sleeping until it can fill the buffer."
msgstr ""

#: ../../../networking/rxrpc.rst:313
msgid ""
"If a data message is only partially consumed in filling a user buffer, then "
"the remainder of that message will be left on the front of the queue for the "
"next taker.  MSG_TRUNC will never be flagged."
msgstr ""

#: ../../../networking/rxrpc.rst:317
msgid ""
"If there is more data to be had on a call (it hasn't copied the last byte of "
"the last data message in that phase yet), then MSG_MORE will be flagged."
msgstr ""

#: ../../../networking/rxrpc.rst:323
msgid "Control Messages"
msgstr ""

#: ../../../networking/rxrpc.rst:325
msgid ""
"AF_RXRPC makes use of control messages in sendmsg() and recvmsg() to "
"multiplex calls, to invoke certain actions and to report certain "
"conditions.  These are:"
msgstr ""

#: ../../../networking/rxrpc.rst:329
msgid "MESSAGE ID"
msgstr ""

#: ../../../networking/rxrpc.rst:329
msgid "SRT"
msgstr ""

#: ../../../networking/rxrpc.rst:329
msgid "DATA"
msgstr ""

#: ../../../networking/rxrpc.rst:329
msgid "MEANING"
msgstr ""

#: ../../../networking/rxrpc.rst:331 ../../../networking/rxrpc.rst:346
#: ../../../networking/rxrpc.rst:599 ../../../networking/rxrpc.rst:712
#: ../../../networking/rxrpc.rst:727 ../../../networking/rxrpc.rst:734
#: ../../../networking/rxrpc.rst:745 ../../../networking/rxrpc.rst:757
msgid "RXRPC_USER_CALL_ID"
msgstr ""

#: ../../../networking/rxrpc.rst:331
msgid "sr-"
msgstr ""

#: ../../../networking/rxrpc.rst:331
msgid "User ID"
msgstr ""

#: ../../../networking/rxrpc.rst:331
msgid "App's call specifier"
msgstr ""

#: ../../../networking/rxrpc.rst:332 ../../../networking/rxrpc.rst:354
#: ../../../networking/rxrpc.rst:758
msgid "RXRPC_ABORT"
msgstr ""

#: ../../../networking/rxrpc.rst:332
msgid "srt"
msgstr ""

#: ../../../networking/rxrpc.rst:332
msgid "Abort code"
msgstr ""

#: ../../../networking/rxrpc.rst:332
msgid "Abort code to issue/received"
msgstr ""

#: ../../../networking/rxrpc.rst:333 ../../../networking/rxrpc.rst:362
#: ../../../networking/rxrpc.rst:746
msgid "RXRPC_ACK"
msgstr ""

#: ../../../networking/rxrpc.rst:333 ../../../networking/rxrpc.rst:334
#: ../../../networking/rxrpc.rst:335 ../../../networking/rxrpc.rst:336
msgid "-rt"
msgstr ""

#: ../../../networking/rxrpc.rst:333 ../../../networking/rxrpc.rst:335
#: ../../../networking/rxrpc.rst:337 ../../../networking/rxrpc.rst:338
#: ../../../networking/rxrpc.rst:339 ../../../networking/rxrpc.rst:340
msgid "n/a"
msgstr ""

#: ../../../networking/rxrpc.rst:333
msgid "Final ACK received"
msgstr ""

#: ../../../networking/rxrpc.rst:334 ../../../networking/rxrpc.rst:368
msgid "RXRPC_NET_ERROR"
msgstr ""

#: ../../../networking/rxrpc.rst:334 ../../../networking/rxrpc.rst:336
msgid "error num"
msgstr ""

#: ../../../networking/rxrpc.rst:334
msgid "Network error on call"
msgstr ""

#: ../../../networking/rxrpc.rst:335 ../../../networking/rxrpc.rst:376
msgid "RXRPC_BUSY"
msgstr ""

#: ../../../networking/rxrpc.rst:335
msgid "Call rejected (server busy)"
msgstr ""

#: ../../../networking/rxrpc.rst:336 ../../../networking/rxrpc.rst:382
msgid "RXRPC_LOCAL_ERROR"
msgstr ""

#: ../../../networking/rxrpc.rst:336 ../../../networking/rxrpc.rst:965
msgid "Local error encountered"
msgstr ""

#: ../../../networking/rxrpc.rst:337 ../../../networking/rxrpc.rst:390
msgid "RXRPC_NEW_CALL"
msgstr ""

#: ../../../networking/rxrpc.rst:337
msgid "-r-"
msgstr ""

#: ../../../networking/rxrpc.rst:337
msgid "New call received"
msgstr ""

#: ../../../networking/rxrpc.rst:338 ../../../networking/rxrpc.rst:396
#: ../../../networking/rxrpc.rst:711
msgid "RXRPC_ACCEPT"
msgstr ""

#: ../../../networking/rxrpc.rst:338 ../../../networking/rxrpc.rst:339
#: ../../../networking/rxrpc.rst:340 ../../../networking/rxrpc.rst:341
msgid "s--"
msgstr ""

#: ../../../networking/rxrpc.rst:338
msgid "Accept new call"
msgstr ""

#: ../../../networking/rxrpc.rst:339 ../../../networking/rxrpc.rst:405
msgid "RXRPC_EXCLUSIVE_CALL"
msgstr ""

#: ../../../networking/rxrpc.rst:339
msgid "Make an exclusive client call"
msgstr ""

#: ../../../networking/rxrpc.rst:340 ../../../networking/rxrpc.rst:410
msgid "RXRPC_UPGRADE_SERVICE"
msgstr ""

#: ../../../networking/rxrpc.rst:340
msgid "Client call can be upgraded"
msgstr ""

#: ../../../networking/rxrpc.rst:341 ../../../networking/rxrpc.rst:422
msgid "RXRPC_TX_LENGTH"
msgstr ""

#: ../../../networking/rxrpc.rst:341
msgid "data len"
msgstr ""

#: ../../../networking/rxrpc.rst:341
msgid "Total length of Tx data"
msgstr ""

#: ../../../networking/rxrpc.rst:344
msgid "(SRT = usable in Sendmsg / delivered by Recvmsg / Terminal message)"
msgstr ""

#: ../../../networking/rxrpc.rst:348
msgid ""
"This is used to indicate the application's call ID.  It's an unsigned long "
"that the app specifies in the client by attaching it to the first data "
"message or in the server by passing it in association with an RXRPC_ACCEPT "
"message.  recvmsg() passes it in conjunction with all messages except those "
"of the RXRPC_NEW_CALL message."
msgstr ""

#: ../../../networking/rxrpc.rst:356
msgid ""
"This is can be used by an application to abort a call by passing it to "
"sendmsg, or it can be delivered by recvmsg to indicate a remote abort was "
"received.  Either way, it must be associated with an RXRPC_USER_CALL_ID to "
"specify the call affected.  If an abort is being sent, then error EBADSLT "
"will be returned if there is no call with that user ID."
msgstr ""

#: ../../../networking/rxrpc.rst:364
msgid ""
"This is delivered to a server application to indicate that the final ACK of "
"a call was received from the client.  It will be associated with an "
"RXRPC_USER_CALL_ID to indicate the call that's now complete."
msgstr ""

#: ../../../networking/rxrpc.rst:370
msgid ""
"This is delivered to an application to indicate that an ICMP error message "
"was encountered in the process of trying to talk to the peer.  An errno-"
"class integer value will be included in the control message data indicating "
"the problem, and an RXRPC_USER_CALL_ID will indicate the call affected."
msgstr ""

#: ../../../networking/rxrpc.rst:378
msgid ""
"This is delivered to a client application to indicate that a call was "
"rejected by the server due to the server being busy.  It will be associated "
"with an RXRPC_USER_CALL_ID to indicate the rejected call."
msgstr ""

#: ../../../networking/rxrpc.rst:384
msgid ""
"This is delivered to an application to indicate that a local error was "
"encountered and that a call has been aborted because of it.  An errno-class "
"integer value will be included in the control message data indicating the "
"problem, and an RXRPC_USER_CALL_ID will indicate the call affected."
msgstr ""

#: ../../../networking/rxrpc.rst:392
msgid ""
"This is delivered to indicate to a server application that a new call has "
"arrived and is awaiting acceptance.  No user ID is associated with this, as "
"a user ID must subsequently be assigned by doing an RXRPC_ACCEPT."
msgstr ""

#: ../../../networking/rxrpc.rst:398
msgid ""
"This is used by a server application to attempt to accept a call and assign "
"it a user ID.  It should be associated with an RXRPC_USER_CALL_ID to "
"indicate the user ID to be assigned.  If there is no call to be accepted (it "
"may have timed out, been aborted, etc.), then sendmsg will return error "
"ENODATA.  If the user ID is already in use by another call, then error "
"EBADSLT will be returned."
msgstr ""

#: ../../../networking/rxrpc.rst:407
msgid ""
"This is used to indicate that a client call should be made on a one-off "
"connection.  The connection is discarded once the call has terminated."
msgstr ""

#: ../../../networking/rxrpc.rst:412
msgid ""
"This is used to make a client call to probe if the specified service ID may "
"be upgraded by the server.  The caller must check msg_name returned to "
"recvmsg() for the service ID actually in use.  The operation probed must be "
"one that takes the same arguments in both services."
msgstr ""

#: ../../../networking/rxrpc.rst:417
msgid ""
"Once this has been used to establish the upgrade capability (or lack "
"thereof) of the server, the service ID returned should be used for all "
"future communication to that server and RXRPC_UPGRADE_SERVICE should no "
"longer be set."
msgstr ""

#: ../../../networking/rxrpc.rst:424
msgid ""
"This is used to inform the kernel of the total amount of data that is going "
"to be transmitted by a call (whether in a client request or a service "
"response).  If given, it allows the kernel to encrypt from the userspace "
"buffer directly to the packet buffers, rather than copying into the buffer "
"and then encrypting in place.  This may only be given with the first "
"sendmsg() providing data for a call.  EMSGSIZE will be generated if the "
"amount of data actually given is different."
msgstr ""

#: ../../../networking/rxrpc.rst:432
msgid ""
"This takes a parameter of __s64 type that indicates how much will be "
"transmitted.  This may not be less than zero."
msgstr ""

#: ../../../networking/rxrpc.rst:435
msgid ""
"The symbol RXRPC__SUPPORTED is defined as one more than the highest control "
"message type supported.  At run time this can be queried by means of the "
"RXRPC_SUPPORTED_CMSG socket option (see below)."
msgstr ""

#: ../../../networking/rxrpc.rst:441
msgid "Socket Options"
msgstr ""

#: ../../../networking/rxrpc.rst:443
msgid "AF_RXRPC sockets support a few socket options at the SOL_RXRPC level:"
msgstr ""

#: ../../../networking/rxrpc.rst:445
msgid "RXRPC_SECURITY_KEY"
msgstr ""

#: ../../../networking/rxrpc.rst:447
msgid ""
"This is used to specify the description of the key to be used.  The key is "
"extracted from the calling process's keyrings with request_key() and should "
"be of \"rxrpc\" type."
msgstr ""

#: ../../../networking/rxrpc.rst:451
msgid ""
"The optval pointer points to the description string, and optlen indicates "
"how long the string is, without the NUL terminator."
msgstr ""

#: ../../../networking/rxrpc.rst:454
msgid "RXRPC_SECURITY_KEYRING"
msgstr ""

#: ../../../networking/rxrpc.rst:456
msgid ""
"Similar to above but specifies a keyring of server secret keys to use (key "
"type \"keyring\").  See the \"Security\" section."
msgstr ""

#: ../../../networking/rxrpc.rst:459
msgid "RXRPC_EXCLUSIVE_CONNECTION"
msgstr ""

#: ../../../networking/rxrpc.rst:461
msgid ""
"This is used to request that new connections should be used for each call "
"made subsequently on this socket.  optval should be NULL and optlen 0."
msgstr ""

#: ../../../networking/rxrpc.rst:464
msgid "RXRPC_MIN_SECURITY_LEVEL"
msgstr ""

#: ../../../networking/rxrpc.rst:466
msgid ""
"This is used to specify the minimum security level required for calls on "
"this socket.  optval must point to an int containing one of the following "
"values:"
msgstr ""

#: ../../../networking/rxrpc.rst:470
msgid "RXRPC_SECURITY_PLAIN"
msgstr ""

#: ../../../networking/rxrpc.rst:472
msgid "Encrypted checksum only."
msgstr ""

#: ../../../networking/rxrpc.rst:474
msgid "RXRPC_SECURITY_AUTH"
msgstr ""

#: ../../../networking/rxrpc.rst:476
msgid ""
"Encrypted checksum plus packet padded and first eight bytes of packet "
"encrypted - which includes the actual packet length."
msgstr ""

#: ../../../networking/rxrpc.rst:479
msgid "RXRPC_SECURITY_ENCRYPT"
msgstr ""

#: ../../../networking/rxrpc.rst:481
msgid ""
"Encrypted checksum plus entire packet padded and encrypted, including actual "
"packet length."
msgstr ""

#: ../../../networking/rxrpc.rst:484
msgid "RXRPC_UPGRADEABLE_SERVICE"
msgstr ""

#: ../../../networking/rxrpc.rst:486
msgid ""
"This is used to indicate that a service socket with two bindings may upgrade "
"one bound service to the other if requested by the client.  optval must "
"point to an array of two unsigned short ints.  The first is the service ID "
"to upgrade from and the second the service ID to upgrade to."
msgstr ""

#: ../../../networking/rxrpc.rst:491
msgid "RXRPC_SUPPORTED_CMSG"
msgstr ""

#: ../../../networking/rxrpc.rst:493
msgid ""
"This is a read-only option that writes an int into the buffer indicating the "
"highest control message type supported."
msgstr ""

#: ../../../networking/rxrpc.rst:498
msgid "Security"
msgstr ""

#: ../../../networking/rxrpc.rst:500
msgid ""
"Currently, only the kerberos 4 equivalent protocol has been implemented "
"(security index 2 - rxkad).  This requires the rxkad module to be loaded "
"and, on the client, tickets of the appropriate type to be obtained from the "
"AFS kaserver or the kerberos server and installed as \"rxrpc\" type keys.  "
"This is normally done using the klog program.  An example simple klog "
"program can be found at:"
msgstr ""

#: ../../../networking/rxrpc.rst:507
msgid "http://people.redhat.com/~dhowells/rxrpc/klog.c"
msgstr ""

#: ../../../networking/rxrpc.rst:509
msgid ""
"The payload provided to add_key() on the client should be of the following "
"form::"
msgstr ""

#: ../../../networking/rxrpc.rst:522
msgid "Where the ticket blob is just appended to the above structure."
msgstr ""

#: ../../../networking/rxrpc.rst:525
msgid ""
"For the server, keys of type \"rxrpc_s\" must be made available to the "
"server. They have a description of \"<serviceID>:<securityIndex>\" (eg: "
"\"52:2\" for an rxkad key for the AFS VL service).  When such a key is "
"created, it should be given the server's secret key as the instantiation "
"data (see the example below)."
msgstr ""

#: ../../../networking/rxrpc.rst:531
msgid "add_key(\"rxrpc_s\", \"52:2\", secret_key, 8, keyring);"
msgstr ""

#: ../../../networking/rxrpc.rst:533
msgid ""
"A keyring is passed to the server socket by naming it in a sockopt.  The "
"server socket then looks the server secret keys up in this keyring when "
"secure incoming connections are made.  This can be seen in an example "
"program that can be found at:"
msgstr ""

#: ../../../networking/rxrpc.rst:538
msgid "http://people.redhat.com/~dhowells/rxrpc/listen.c"
msgstr ""

#: ../../../networking/rxrpc.rst:542
msgid "Example Client Usage"
msgstr ""

#: ../../../networking/rxrpc.rst:544
msgid "A client would issue an operation by:"
msgstr ""

#: ../../../networking/rxrpc.rst:546
msgid "An RxRPC socket is set up by::"
msgstr ""

#: ../../../networking/rxrpc.rst:550
msgid ""
"Where the third parameter indicates the protocol family of the transport "
"socket used - usually IPv4 but it can also be IPv6 [TODO]."
msgstr ""

#: ../../../networking/rxrpc.rst:553
msgid "A local address can optionally be bound::"
msgstr ""

#: ../../../networking/rxrpc.rst:565
msgid ""
"This specifies the local UDP port to be used.  If not given, a random non-"
"privileged port will be used.  A UDP port may be shared between several "
"unrelated RxRPC sockets.  Security is handled on a basis of per-RxRPC "
"virtual connection."
msgstr ""

#: ../../../networking/rxrpc.rst:570
msgid "The security is set::"
msgstr ""

#: ../../../networking/rxrpc.rst:575
msgid ""
"This issues a request_key() to get the key representing the security "
"context.  The minimum security level can be set::"
msgstr ""

#: ../../../networking/rxrpc.rst:582
msgid ""
"The server to be contacted can then be specified (alternatively this can be "
"done through sendmsg)::"
msgstr ""

#: ../../../networking/rxrpc.rst:595
msgid ""
"The request data should then be posted to the server socket using a series "
"of sendmsg() calls, each with the following control message attached:"
msgstr ""

#: ../../../networking/rxrpc.rst:599 ../../../networking/rxrpc.rst:727
#: ../../../networking/rxrpc.rst:734 ../../../networking/rxrpc.rst:745
#: ../../../networking/rxrpc.rst:757
msgid "specifies the user ID for this call"
msgstr ""

#: ../../../networking/rxrpc.rst:602
msgid ""
"MSG_MORE should be set in msghdr::msg_flags on all but the last part of the "
"request.  Multiple requests may be made simultaneously."
msgstr ""

#: ../../../networking/rxrpc.rst:605
msgid ""
"An RXRPC_TX_LENGTH control message can also be specified on the first "
"sendmsg() call."
msgstr ""

#: ../../../networking/rxrpc.rst:608
msgid ""
"If a call is intended to go to a destination other than the default "
"specified through connect(), then msghdr::msg_name should be set on the "
"first request message of that call."
msgstr ""

#: ../../../networking/rxrpc.rst:612
msgid ""
"The reply data will then be posted to the server socket for recvmsg() to "
"pick up.  MSG_MORE will be flagged by recvmsg() if there's more reply data "
"for a particular call to be read.  MSG_EOR will be set on the terminal read "
"for a call."
msgstr ""

#: ../../../networking/rxrpc.rst:617 ../../../networking/rxrpc.rst:723
msgid "All data will be delivered with the following control message attached:"
msgstr ""

#: ../../../networking/rxrpc.rst:619
msgid "RXRPC_USER_CALL_ID      - specifies the user ID for this call"
msgstr ""

#: ../../../networking/rxrpc.rst:621
msgid ""
"If an abort or error occurred, this will be returned in the control data "
"buffer instead, and MSG_EOR will be flagged to indicate the end of that call."
msgstr ""

#: ../../../networking/rxrpc.rst:625
msgid ""
"A client may ask for a service ID it knows and ask that this be upgraded to "
"a better service if one is available by supplying RXRPC_UPGRADE_SERVICE on "
"the first sendmsg() of a call.  The client should then check srx_service in "
"the msg_name filled in by recvmsg() when collecting the result.  srx_service "
"will hold the same value as given to sendmsg() if the upgrade request was "
"ignored by the service - otherwise it will be altered to indicate the "
"service ID the server upgraded to.  Note that the upgraded service ID is "
"chosen by the server. The caller has to wait until it sees the service ID in "
"the reply before sending any more calls (further calls to the same "
"destination will be blocked until the probe is concluded)."
msgstr ""

#: ../../../networking/rxrpc.rst:638
msgid "Example Server Usage"
msgstr ""

#: ../../../networking/rxrpc.rst:640
msgid "A server would be set up to accept operations in the following manner:"
msgstr ""

#: ../../../networking/rxrpc.rst:642
msgid "An RxRPC socket is created by::"
msgstr ""

#: ../../../networking/rxrpc.rst:646
msgid ""
"Where the third parameter indicates the address type of the transport socket "
"used - usually IPv4."
msgstr ""

#: ../../../networking/rxrpc.rst:649
msgid ""
"Security is set up if desired by giving the socket a keyring with server "
"secret keys in it::"
msgstr ""

#: ../../../networking/rxrpc.rst:661
msgid ""
"The keyring can be manipulated after it has been given to the socket. This "
"permits the server to add more keys, replace keys, etc. while it is live."
msgstr ""

#: ../../../networking/rxrpc.rst:664
msgid "A local address must then be bound::"
msgstr ""

#: ../../../networking/rxrpc.rst:676
msgid ""
"More than one service ID may be bound to a socket, provided the transport "
"parameters are the same.  The limit is currently two.  To do this, bind() "
"should be called twice."
msgstr ""

#: ../../../networking/rxrpc.rst:680
msgid ""
"If service upgrading is required, first two service IDs must have been bound "
"and then the following option must be set::"
msgstr ""

#: ../../../networking/rxrpc.rst:687
msgid ""
"This will automatically upgrade connections on service from_ID to service "
"to_ID if they request it.  This will be reflected in msg_name obtained "
"through recvmsg() when the request data is delivered to userspace."
msgstr ""

#: ../../../networking/rxrpc.rst:691
msgid "The server is then set to listen out for incoming calls::"
msgstr ""

#: ../../../networking/rxrpc.rst:695
msgid ""
"The kernel notifies the server of pending incoming connections by sending it "
"a message for each.  This is received with recvmsg() on the server socket.  "
"It has no data, and has a single dataless control message attached::"
msgstr ""

#: ../../../networking/rxrpc.rst:702
msgid ""
"The address that can be passed back by recvmsg() at this point should be "
"ignored since the call for which the message was posted may have gone by the "
"time it is accepted - in which case the first call still on the queue will "
"be accepted."
msgstr ""

#: ../../../networking/rxrpc.rst:707
msgid ""
"The server then accepts the new call by issuing a sendmsg() with two pieces "
"of control data and no actual data:"
msgstr ""

#: ../../../networking/rxrpc.rst:711
msgid "indicate connection acceptance"
msgstr ""

#: ../../../networking/rxrpc.rst:712
msgid "specify user ID for this call"
msgstr ""

#: ../../../networking/rxrpc.rst:715
msgid ""
"The first request data packet will then be posted to the server socket for "
"recvmsg() to pick up.  At that point, the RxRPC address for the call can be "
"read from the address fields in the msghdr struct."
msgstr ""

#: ../../../networking/rxrpc.rst:719
msgid ""
"Subsequent request data will be posted to the server socket for recvmsg() to "
"collect as it arrives.  All but the last piece of the request data will be "
"delivered with MSG_MORE flagged."
msgstr ""

#: ../../../networking/rxrpc.rst:730
msgid ""
"The reply data should then be posted to the server socket using a series of "
"sendmsg() calls, each with the following control messages attached:"
msgstr ""

#: ../../../networking/rxrpc.rst:737
msgid ""
"MSG_MORE should be set in msghdr::msg_flags on all but the last message for "
"a particular call."
msgstr ""

#: ../../../networking/rxrpc.rst:740
msgid ""
"The final ACK from the client will be posted for retrieval by recvmsg() when "
"it is received.  It will take the form of a dataless message with two "
"control messages attached:"
msgstr ""

#: ../../../networking/rxrpc.rst:746
msgid "indicates final ACK (no data)"
msgstr ""

#: ../../../networking/rxrpc.rst:749
msgid ""
"MSG_EOR will be flagged to indicate that this is the final message for this "
"call."
msgstr ""

#: ../../../networking/rxrpc.rst:752
msgid ""
"Up to the point the final packet of reply data is sent, the call can be "
"aborted by calling sendmsg() with a dataless message with the following "
"control messages attached:"
msgstr ""

#: ../../../networking/rxrpc.rst:758
msgid "indicates abort code (4 byte data)"
msgstr ""

#: ../../../networking/rxrpc.rst:761
msgid ""
"Any packets waiting in the socket's receive queue will be discarded if this "
"is issued."
msgstr ""

#: ../../../networking/rxrpc.rst:764
msgid ""
"Note that all the communications for a particular service take place through "
"the one server socket, using control messages on sendmsg() and recvmsg() to "
"determine the call affected."
msgstr ""

#: ../../../networking/rxrpc.rst:770
msgid "AF_RXRPC Kernel Interface"
msgstr ""

#: ../../../networking/rxrpc.rst:772
msgid ""
"The AF_RXRPC module also provides an interface for use by in-kernel "
"utilities such as the AFS filesystem.  This permits such a utility to:"
msgstr ""

#: ../../../networking/rxrpc.rst:775
msgid ""
"Use different keys directly on individual client calls on one socket rather "
"than having to open a whole slew of sockets, one for each key it might want "
"to use."
msgstr ""

#: ../../../networking/rxrpc.rst:779
msgid ""
"Avoid having RxRPC call request_key() at the point of issue of a call or "
"opening of a socket.  Instead the utility is responsible for requesting a "
"key at the appropriate point.  AFS, for instance, would do this during VFS "
"operations such as open() or unlink().  The key is then handed through when "
"the call is initiated."
msgstr ""

#: ../../../networking/rxrpc.rst:785
msgid "Request the use of something other than GFP_KERNEL to allocate memory."
msgstr ""

#: ../../../networking/rxrpc.rst:787
msgid ""
"Avoid the overhead of using the recvmsg() call.  RxRPC messages can be "
"intercepted before they get put into the socket Rx queue and the socket "
"buffers manipulated directly."
msgstr ""

#: ../../../networking/rxrpc.rst:791
msgid ""
"To use the RxRPC facility, a kernel utility must still open an AF_RXRPC "
"socket, bind an address as appropriate and listen if it's to be a server "
"socket, but then it passes this to the kernel interface functions."
msgstr ""

#: ../../../networking/rxrpc.rst:795
msgid "The kernel interface functions are as follows:"
msgstr ""

#: ../../../networking/rxrpc.rst:797
msgid "Begin a new client call::"
msgstr ""

#: ../../../networking/rxrpc.rst:811
msgid ""
"This allocates the infrastructure to make a new RxRPC call and assigns call "
"and connection numbers.  The call will be made on the UDP port that the "
"socket is bound to.  The call will go to the destination address of a "
"connected client socket unless an alternative is supplied (srx is non-NULL)."
msgstr ""

#: ../../../networking/rxrpc.rst:817
msgid ""
"If a key is supplied then this will be used to secure the call instead of "
"the key bound to the socket with the RXRPC_SECURITY_KEY sockopt.  Calls "
"secured in this way will still share connections if at all possible."
msgstr ""

#: ../../../networking/rxrpc.rst:821
msgid ""
"The user_call_ID is equivalent to that supplied to sendmsg() in the control "
"data buffer.  It is entirely feasible to use this to point to a kernel data "
"structure."
msgstr ""

#: ../../../networking/rxrpc.rst:825
msgid ""
"tx_total_len is the amount of data the caller is intending to transmit with "
"this call (or -1 if unknown at this point).  Setting the data size allows "
"the kernel to encrypt directly to the packet buffers, thereby saving a "
"copy.  The value may not be less than -1."
msgstr ""

#: ../../../networking/rxrpc.rst:830
msgid ""
"notify_rx is a pointer to a function to be called when events such as "
"incoming data packets or remote aborts happen."
msgstr ""

#: ../../../networking/rxrpc.rst:833
msgid ""
"upgrade should be set to true if a client operation should request that the "
"server upgrade the service to a better one.  The resultant service ID is "
"returned by rxrpc_kernel_recv_data()."
msgstr ""

#: ../../../networking/rxrpc.rst:837
msgid ""
"intr should be set to true if the call should be interruptible.  If this is "
"not set, this function may not return until a channel has been allocated; if "
"it is set, the function may return -ERESTARTSYS."
msgstr ""

#: ../../../networking/rxrpc.rst:841
msgid ""
"debug_id is the call debugging ID to be used for tracing.  This can be "
"obtained by atomically incrementing rxrpc_debug_id."
msgstr ""

#: ../../../networking/rxrpc.rst:844 ../../../networking/rxrpc.rst:993
msgid ""
"If this function is successful, an opaque reference to the RxRPC call is "
"returned.  The caller now holds a reference on this and it must be properly "
"ended."
msgstr ""

#: ../../../networking/rxrpc.rst:848
msgid "Shut down a client call::"
msgstr ""

#: ../../../networking/rxrpc.rst:853
msgid ""
"This is used to shut down a previously begun call.  The user_call_ID is "
"expunged from AF_RXRPC's knowledge and will not be seen again in association "
"with the specified call."
msgstr ""

#: ../../../networking/rxrpc.rst:857
msgid "Release the ref on a client call::"
msgstr ""

#: ../../../networking/rxrpc.rst:862
msgid "This is used to release the caller's ref on an rxrpc call."
msgstr ""

#: ../../../networking/rxrpc.rst:864
msgid "Send data through a call::"
msgstr ""

#: ../../../networking/rxrpc.rst:876
msgid ""
"This is used to supply either the request part of a client call or the reply "
"part of a server call.  msg.msg_iovlen and msg.msg_iov specify the data "
"buffers to be used.  msg_iov may not be NULL and must point exclusively to "
"in-kernel virtual addresses.  msg.msg_flags may be given MSG_MORE if there "
"will be subsequent data sends for this call."
msgstr ""

#: ../../../networking/rxrpc.rst:882
msgid ""
"The msg must not specify a destination address, control data or any flags "
"other than MSG_MORE.  len is the total amount of data to transmit."
msgstr ""

#: ../../../networking/rxrpc.rst:885
msgid ""
"notify_end_rx can be NULL or it can be used to specify a function to be "
"called when the call changes state to end the Tx phase.  This function is "
"called with a spinlock held to prevent the last DATA packet from being "
"transmitted until the function returns."
msgstr ""

#: ../../../networking/rxrpc.rst:890
msgid "Receive data from a call::"
msgstr ""

#: ../../../networking/rxrpc.rst:925
msgid "Abort a call??"
msgstr ""

#: ../../../networking/rxrpc.rst:933
msgid ""
"This is used to abort a call if it's still in an abortable state.  The abort "
"code specified will be placed in the ABORT message sent."
msgstr ""

#: ../../../networking/rxrpc.rst:936
msgid "Intercept received RxRPC messages::"
msgstr ""

#: ../../../networking/rxrpc.rst:946
msgid ""
"This installs an interceptor function on the specified AF_RXRPC socket. All "
"messages that would otherwise wind up in the socket's Rx queue are then "
"diverted to this function.  Note that care must be taken to process the "
"messages in the right order to maintain DATA message sequentiality."
msgstr ""

#: ../../../networking/rxrpc.rst:951
msgid ""
"The interceptor function itself is provided with the address of the socket "
"and handling the incoming message, the ID assigned by the kernel utility to "
"the call and the socket buffer containing the message."
msgstr ""

#: ../../../networking/rxrpc.rst:955
msgid "The skb->mark field indicates the type of message:"
msgstr ""

#: ../../../networking/rxrpc.rst:958
msgid "Mark"
msgstr ""

#: ../../../networking/rxrpc.rst:958
msgid "Meaning"
msgstr ""

#: ../../../networking/rxrpc.rst:960
msgid "RXRPC_SKB_MARK_DATA"
msgstr ""

#: ../../../networking/rxrpc.rst:960
msgid "Data message"
msgstr ""

#: ../../../networking/rxrpc.rst:961
msgid "RXRPC_SKB_MARK_FINAL_ACK"
msgstr ""

#: ../../../networking/rxrpc.rst:961
msgid "Final ACK received for an incoming call"
msgstr ""

#: ../../../networking/rxrpc.rst:962
msgid "RXRPC_SKB_MARK_BUSY"
msgstr ""

#: ../../../networking/rxrpc.rst:962
msgid "Client call rejected as server busy"
msgstr ""

#: ../../../networking/rxrpc.rst:963
msgid "RXRPC_SKB_MARK_REMOTE_ABORT"
msgstr ""

#: ../../../networking/rxrpc.rst:963
msgid "Call aborted by peer"
msgstr ""

#: ../../../networking/rxrpc.rst:964
msgid "RXRPC_SKB_MARK_NET_ERROR"
msgstr ""

#: ../../../networking/rxrpc.rst:964
msgid "Network error detected"
msgstr ""

#: ../../../networking/rxrpc.rst:965
msgid "RXRPC_SKB_MARK_LOCAL_ERROR"
msgstr ""

#: ../../../networking/rxrpc.rst:966
msgid "RXRPC_SKB_MARK_NEW_CALL"
msgstr ""

#: ../../../networking/rxrpc.rst:966
msgid "New incoming call awaiting acceptance"
msgstr ""

#: ../../../networking/rxrpc.rst:969
msgid ""
"The remote abort message can be probed with rxrpc_kernel_get_abort_code(). "
"The two error messages can be probed with rxrpc_kernel_get_error_number(). A "
"new call can be accepted with rxrpc_kernel_accept_call()."
msgstr ""

#: ../../../networking/rxrpc.rst:973
msgid ""
"Data messages can have their contents extracted with the usual bunch of "
"socket buffer manipulation functions.  A data message can be determined to "
"be the last one in a sequence with rxrpc_kernel_is_data_last().  When a data "
"message has been used up, rxrpc_kernel_data_consumed() should be called on "
"it."
msgstr ""

#: ../../../networking/rxrpc.rst:979
msgid ""
"Messages should be handled to rxrpc_kernel_free_skb() to dispose of.  It is "
"possible to get extra refs on all types of message for later freeing, but "
"this may pin the state of a call until the message is finally freed."
msgstr ""

#: ../../../networking/rxrpc.rst:983
msgid "Accept an incoming call::"
msgstr ""

#: ../../../networking/rxrpc.rst:989
msgid ""
"This is used to accept an incoming call and to assign it a call ID.  This "
"function is similar to rxrpc_kernel_begin_call() and calls accepted must be "
"ended in the same way."
msgstr ""

#: ../../../networking/rxrpc.rst:997
msgid "Reject an incoming call::"
msgstr ""

#: ../../../networking/rxrpc.rst:1001
msgid ""
"This is used to reject the first incoming call on the socket's queue with a "
"BUSY message.  -ENODATA is returned if there were no incoming calls. Other "
"errors may be returned if the call had been aborted (-ECONNABORTED) or had "
"timed out (-ETIME)."
msgstr ""

#: ../../../networking/rxrpc.rst:1006
msgid "Allocate a null key for doing anonymous security::"
msgstr ""

#: ../../../networking/rxrpc.rst:1010
msgid ""
"This is used to allocate a null RxRPC key that can be used to indicate "
"anonymous security for a particular domain."
msgstr ""

#: ../../../networking/rxrpc.rst:1013
msgid "Get the peer address of a call::"
msgstr ""

#: ../../../networking/rxrpc.rst:1018
msgid "This is used to find the remote peer address of a call."
msgstr ""

#: ../../../networking/rxrpc.rst:1020
msgid "Set the total transmit data size on a call::"
msgstr ""

#: ../../../networking/rxrpc.rst:1026
msgid ""
"This sets the amount of data that the caller is intending to transmit on a "
"call.  It's intended to be used for setting the reply size as the request "
"size should be set when the call is begun.  tx_total_len may not be less "
"than zero."
msgstr ""

#: ../../../networking/rxrpc.rst:1031
msgid "Get call RTT::"
msgstr ""

#: ../../../networking/rxrpc.rst:1035
msgid ""
"Get the RTT time to the peer in use by a call.  The value returned is in "
"nanoseconds."
msgstr ""

#: ../../../networking/rxrpc.rst:1038
msgid "Check call still alive::"
msgstr ""

#: ../../../networking/rxrpc.rst:1046
msgid ""
"The first function passes back in ``*_life`` a number that is updated when "
"ACKs are received from the peer (notably including PING RESPONSE ACKs which "
"we can elicit by sending PING ACKs to see if the call still exists on the "
"server).  The caller should compare the numbers of two calls to see if the "
"call is still alive after waiting for a suitable interval.  It also returns "
"true as long as the call hasn't yet reached the completed state."
msgstr ""

#: ../../../networking/rxrpc.rst:1053
msgid ""
"This allows the caller to work out if the server is still contactable and if "
"the call is still alive on the server while waiting for the server to "
"process a client operation."
msgstr ""

#: ../../../networking/rxrpc.rst:1057
msgid ""
"The second function causes a ping ACK to be transmitted to try to provoke "
"the peer into responding, which would then cause the value returned by the "
"first function to change.  Note that this must be called in TASK_RUNNING "
"state."
msgstr ""

#: ../../../networking/rxrpc.rst:1062
msgid ""
"Apply the RXRPC_MIN_SECURITY_LEVEL sockopt to a socket from within in the "
"kernel::"
msgstr ""

#: ../../../networking/rxrpc.rst:1068
msgid ""
"This specifies the minimum security level required for calls on this socket."
msgstr ""

#: ../../../networking/rxrpc.rst:1073
msgid "Configurable Parameters"
msgstr ""

#: ../../../networking/rxrpc.rst:1075
msgid ""
"The RxRPC protocol driver has a number of configurable parameters that can "
"be adjusted through sysctls in /proc/net/rxrpc/:"
msgstr ""

#: ../../../networking/rxrpc.rst:1078
msgid "req_ack_delay"
msgstr ""

#: ../../../networking/rxrpc.rst:1080
msgid ""
"The amount of time in milliseconds after receiving a packet with the request-"
"ack flag set before we honour the flag and actually send the requested ack."
msgstr ""

#: ../../../networking/rxrpc.rst:1084
msgid ""
"Usually the other side won't stop sending packets until the advertised "
"reception window is full (to a maximum of 255 packets), so delaying the ACK "
"permits several packets to be ACK'd in one go."
msgstr ""

#: ../../../networking/rxrpc.rst:1088
msgid "soft_ack_delay"
msgstr ""

#: ../../../networking/rxrpc.rst:1090
msgid ""
"The amount of time in milliseconds after receiving a new packet before we "
"generate a soft-ACK to tell the sender that it doesn't need to resend."
msgstr ""

#: ../../../networking/rxrpc.rst:1093
msgid "idle_ack_delay"
msgstr ""

#: ../../../networking/rxrpc.rst:1095
msgid ""
"The amount of time in milliseconds after all the packets currently in the "
"received queue have been consumed before we generate a hard-ACK to tell the "
"sender it can free its buffers, assuming no other reason occurs that we "
"would send an ACK."
msgstr ""

#: ../../../networking/rxrpc.rst:1100
msgid "resend_timeout"
msgstr ""

#: ../../../networking/rxrpc.rst:1102
msgid ""
"The amount of time in milliseconds after transmitting a packet before we "
"transmit it again, assuming no ACK is received from the receiver telling us "
"they got it."
msgstr ""

#: ../../../networking/rxrpc.rst:1106
msgid "max_call_lifetime"
msgstr ""

#: ../../../networking/rxrpc.rst:1108
msgid ""
"The maximum amount of time in seconds that a call may be in progress before "
"we preemptively kill it."
msgstr ""

#: ../../../networking/rxrpc.rst:1111
msgid "dead_call_expiry"
msgstr ""

#: ../../../networking/rxrpc.rst:1113
msgid ""
"The amount of time in seconds before we remove a dead call from the call "
"list.  Dead calls are kept around for a little while for the purpose of "
"repeating ACK and ABORT packets."
msgstr ""

#: ../../../networking/rxrpc.rst:1117
msgid "connection_expiry"
msgstr ""

#: ../../../networking/rxrpc.rst:1119
msgid ""
"The amount of time in seconds after a connection was last used before we "
"remove it from the connection list.  While a connection is in existence, it "
"serves as a placeholder for negotiated security; when it is deleted, the "
"security must be renegotiated."
msgstr ""

#: ../../../networking/rxrpc.rst:1124
msgid "transport_expiry"
msgstr ""

#: ../../../networking/rxrpc.rst:1126
msgid ""
"The amount of time in seconds after a transport was last used before we "
"remove it from the transport list.  While a transport is in existence, it "
"serves to anchor the peer data and keeps the connection ID counter."
msgstr ""

#: ../../../networking/rxrpc.rst:1130
msgid "rxrpc_rx_window_size"
msgstr ""

#: ../../../networking/rxrpc.rst:1132
msgid ""
"The size of the receive window in packets.  This is the maximum number of "
"unconsumed received packets we're willing to hold in memory for any "
"particular call."
msgstr ""

#: ../../../networking/rxrpc.rst:1136
msgid "rxrpc_rx_mtu"
msgstr ""

#: ../../../networking/rxrpc.rst:1138
msgid ""
"The maximum packet MTU size that we're willing to receive in bytes.  This "
"indicates to the peer whether we're willing to accept jumbo packets."
msgstr ""

#: ../../../networking/rxrpc.rst:1141
msgid "rxrpc_rx_jumbo_max"
msgstr ""

#: ../../../networking/rxrpc.rst:1143
msgid ""
"The maximum number of packets that we're willing to accept in a jumbo "
"packet.  Non-terminal packets in a jumbo packet must contain a four byte "
"header plus exactly 1412 bytes of data.  The terminal packet must contain a "
"four byte header plus any amount of data.  In any event, a jumbo packet may "
"not exceed rxrpc_rx_mtu in size."
msgstr ""

#: ../../../networking/rxrpc.rst:1151
msgid "API Function Reference"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:262
msgid "Obtain remote transport endpoint for an address"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:266
#: net/rxrpc/af_rxrpc.c:292 net/rxrpc/af_rxrpc.c:306 net/rxrpc/af_rxrpc.c:318
#: net/rxrpc/af_rxrpc.c:407 net/rxrpc/af_rxrpc.c:434 net/rxrpc/af_rxrpc.c:447
#: net/rxrpc/af_rxrpc.c:468 ../../../networking/rxrpc:1154:
#: net/rxrpc/call_object.c:765 ../../../networking/rxrpc:1155:
#: net/rxrpc/key.c:697 ../../../networking/rxrpc:1156: net/rxrpc/oob.c:257
#: net/rxrpc/oob.c:293 net/rxrpc/oob.c:317 net/rxrpc/oob.c:337
#: net/rxrpc/oob.c:361 ../../../networking/rxrpc:1157:
#: net/rxrpc/peer_object.c:475 net/rxrpc/peer_object.c:490
#: net/rxrpc/peer_object.c:504 net/rxrpc/peer_object.c:520
#: net/rxrpc/peer_object.c:537 net/rxrpc/peer_object.c:553
#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:577
#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:733 net/rxrpc/rxgk.c:1030
#: ../../../networking/rxrpc:1160: net/rxrpc/rxkad.c:934
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:796
#: net/rxrpc/sendmsg.c:837 net/rxrpc/sendmsg.c:863
#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:153
#: net/rxrpc/server_key.c:180
msgid "**Parameters**"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:268
#: net/rxrpc/af_rxrpc.c:320 net/rxrpc/af_rxrpc.c:409 net/rxrpc/af_rxrpc.c:436
#: net/rxrpc/af_rxrpc.c:470 ../../../networking/rxrpc:1156: net/rxrpc/oob.c:295
#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:477
#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:579
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:798
#: net/rxrpc/sendmsg.c:839 net/rxrpc/sendmsg.c:865
msgid "``struct socket *sock``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:263
msgid "The socket through which it will be accessed"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:265
msgid "``struct sockaddr_rxrpc *srx``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:264
msgid "The network address"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:266
#: net/rxrpc/af_rxrpc.c:322
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:265
msgid "Allocation flags"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:267
#: net/rxrpc/af_rxrpc.c:291 net/rxrpc/af_rxrpc.c:305 net/rxrpc/af_rxrpc.c:328
#: net/rxrpc/af_rxrpc.c:407 net/rxrpc/af_rxrpc.c:434 net/rxrpc/af_rxrpc.c:447
#: net/rxrpc/af_rxrpc.c:468 ../../../networking/rxrpc:1154:
#: net/rxrpc/call_object.c:766 ../../../networking/rxrpc:1155:
#: net/rxrpc/key.c:696 ../../../networking/rxrpc:1156: net/rxrpc/oob.c:258
#: net/rxrpc/oob.c:293 net/rxrpc/oob.c:316 net/rxrpc/oob.c:340
#: net/rxrpc/oob.c:363 ../../../networking/rxrpc:1157:
#: net/rxrpc/peer_object.c:475 net/rxrpc/peer_object.c:489
#: net/rxrpc/peer_object.c:503 net/rxrpc/peer_object.c:519
#: net/rxrpc/peer_object.c:537 net/rxrpc/peer_object.c:552
#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:582
#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:1030
#: ../../../networking/rxrpc:1160: net/rxrpc/rxkad.c:933
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:799
#: net/rxrpc/sendmsg.c:840 net/rxrpc/sendmsg.c:864
#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:153
#: net/rxrpc/server_key.c:180
msgid "**Description**"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:266
msgid ""
"Lookup or create a remote transport endpoint record for the specified "
"address."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:269
#: net/rxrpc/af_rxrpc.c:292 net/rxrpc/af_rxrpc.c:334 net/rxrpc/af_rxrpc.c:449
#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:768
#: ../../../networking/rxrpc:1155: net/rxrpc/key.c:698
#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:261 net/rxrpc/oob.c:295
#: net/rxrpc/oob.c:366 ../../../networking/rxrpc:1157:
#: net/rxrpc/peer_object.c:476 net/rxrpc/peer_object.c:490
#: net/rxrpc/peer_object.c:506 net/rxrpc/peer_object.c:522
#: net/rxrpc/peer_object.c:539 net/rxrpc/peer_object.c:553
#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:587
#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:732 net/rxrpc/rxgk.c:1032
#: ../../../networking/rxrpc:1160: net/rxrpc/rxkad.c:934
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:803
#: net/rxrpc/sendmsg.c:841 ../../../networking/rxrpc:1162:
#: net/rxrpc/server_key.c:155 net/rxrpc/server_key.c:196
msgid "**Return**"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:270
msgid ""
"The peer record found with a reference, ``NULL`` if no record is found or a "
"negative error code if the address is invalid or unsupported."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:288
msgid "Get a reference on a peer"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:294
#: net/rxrpc/af_rxrpc.c:308 net/rxrpc/af_rxrpc.c:317
#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:539
msgid "``struct rxrpc_peer *peer``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:289
msgid "The peer to get a reference on (may be NULL)."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:290
msgid "Get a reference for a remote peer record (if not NULL)."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:293
msgid "The **peer** argument."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:302
msgid "Allow a kernel app to drop a peer reference"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:303
msgid "The peer to drop a ref on"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:304
msgid "Drop a reference on a peer record."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:314
msgid "Allow a kernel service to begin a call"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:315
msgid "The socket on which to make the call"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:316
msgid "The peer to contact"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:318
msgid "``struct key *key``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:317
msgid "The security context to use (defaults to socket setting)"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:319
msgid "``unsigned long user_call_ID``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:318
msgid "The ID to use"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:320
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:863
msgid "``s64 tx_total_len``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:319
msgid "Total length of data to transmit during the call (or -1)"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:321
msgid "``u32 hard_timeout``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:320
msgid "The maximum lifespan of the call in sec"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:321
msgid "The allocation constraints"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:323
msgid "``rxrpc_notify_rx_t notify_rx``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:322
msgid "Where to send notifications instead of socket queue"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:324
msgid "``u16 service_id``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:323
msgid "The ID of the service to contact"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:325
msgid "``bool upgrade``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:324
msgid "Request service upgrade for call"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:326
msgid "``enum rxrpc_interruptibility interruptibility``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:325
msgid "The call is interruptible, or can be canceled."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:327
msgid "``unsigned int debug_id``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:326
msgid "The debug ID for tracing to be assigned to the call"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:327
msgid ""
"Allow a kernel service to begin a call on the nominated socket.  This just "
"sets up all the internal tracking structures and allocates connection and "
"call IDs as appropriate."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:331
msgid ""
"The default socket destination address and security may be overridden by "
"supplying **srx** and **key**."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:335
msgid "The new call or an error code."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:403
msgid "Allow a kernel service to shut down a call it was using"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:404
#: net/rxrpc/af_rxrpc.c:431 net/rxrpc/af_rxrpc.c:444
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:793
#: net/rxrpc/sendmsg.c:834 net/rxrpc/sendmsg.c:860
msgid "The socket the call is on"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:406
#: net/rxrpc/af_rxrpc.c:433 ../../../networking/rxrpc:1154:
#: net/rxrpc/call_object.c:767 ../../../networking/rxrpc:1157:
#: net/rxrpc/peer_object.c:474 ../../../networking/rxrpc:1158:
#: net/rxrpc/recvmsg.c:576 ../../../networking/rxrpc:1161:
#: net/rxrpc/sendmsg.c:795 net/rxrpc/sendmsg.c:836 net/rxrpc/sendmsg.c:862
msgid "``struct rxrpc_call *call``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:405
msgid "The call to end"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:406
msgid ""
"Allow a kernel service to shut down a call it was using.  The call must be "
"complete before this is called (the call should be aborted if necessary)."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:430
msgid "Release a reference to a call"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:432
msgid "The call to put"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:433
msgid "Drop the application's ref on an rxrpc call."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:443
msgid "Check to see whether a call is still alive"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:449
msgid "``const struct socket *sock``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:446
msgid "``const struct rxrpc_call *call``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:445
msgid "The call to check"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:446
msgid ""
"Allow a kernel service to find out whether a call is still alive - whether "
"it has completed successfully and all received data has been consumed."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:450
msgid ""
"``true`` if the call is still ongoing and ``false`` if it has completed."
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:464
msgid "Set table of callback operations"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:465
msgid "The socket to install table upon"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:467
msgid "``const struct rxrpc_kernel_ops *app_ops``"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:466
msgid "Callback operation table to set"
msgstr ""

#: ../../../networking/rxrpc:1153: net/rxrpc/af_rxrpc.c:467
msgid ""
"Allow a kernel service to set a table of event notifications on a socket."
msgstr ""

#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:761
msgid "Query call's security parameters"
msgstr ""

#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:762
#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:473
msgid "The call to query"
msgstr ""

#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:764
#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:338
msgid "``u16 *_service_id``"
msgstr ""

#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:763
msgid "Where to return the service ID"
msgstr ""

#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:765
msgid "``u32 *_enctype``"
msgstr ""

#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:764
msgid "Where to return the \"encoding type\""
msgstr ""

#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:765
msgid ""
"This queries the security parameters of a call, setting ***_service_id** and "
"***_enctype** and returning the security class."
msgstr ""

#: ../../../networking/rxrpc:1154: net/rxrpc/call_object.c:769
msgid "The security class protocol number."
msgstr ""

#: ../../../networking/rxrpc:1155: net/rxrpc/key.c:693
msgid "Generate a null RxRPC key"
msgstr ""

#: ../../../networking/rxrpc:1155: net/rxrpc/key.c:699
msgid "``const char *keyname``"
msgstr ""

#: ../../../networking/rxrpc:1155: net/rxrpc/key.c:694
msgid "The name to give the key."
msgstr ""

#: ../../../networking/rxrpc:1155: net/rxrpc/key.c:695
msgid ""
"Generate a null RxRPC key that can be used to indicate anonymous security is "
"required for a particular domain."
msgstr ""

#: ../../../networking/rxrpc:1155: net/rxrpc/key.c:699
msgid "The new key or a negative error code."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:253
msgid "Query the parameters of an out-of-band message"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:259 net/rxrpc/oob.c:319
msgid "``struct sk_buff *oob``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:254
msgid "The message to query"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:256 net/rxrpc/oob.c:336
msgid "``struct rxrpc_peer **_peer``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:255 net/rxrpc/oob.c:335
msgid "Where to return the peer record"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:257 net/rxrpc/oob.c:337
msgid "``unsigned long *_peer_appdata``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:256 net/rxrpc/oob.c:336
msgid "The application data attached to a peer record"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:257
msgid ""
"Extract useful parameters from an out-of-band message.  The source peer "
"parameters are returned through the argument list and the message type is "
"returned."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:262
msgid "``RXRPC_OOB_CHALLENGE`` - Challenge wanting a response."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:289
msgid "Dequeue and return the front OOB message"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:290
msgid "The socket to query"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:292
msgid "``enum rxrpc_oob_type *_type``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:291
msgid "Where to return the message type"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:292
msgid ""
"Dequeue the front OOB message, if there is one, and return it and its type."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:296
msgid ""
"The sk_buff representing the OOB message or ``NULL`` if the queue was empty."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:313
msgid "Free an out-of-band message"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:314
msgid "The OOB message to free"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:315
msgid "Free an OOB message along with any resources it holds."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:333
msgid "Query the parameters of a challenge"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:339 net/rxrpc/oob.c:363
#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:735 net/rxrpc/rxgk.c:1032
#: ../../../networking/rxrpc:1160: net/rxrpc/rxkad.c:936
msgid "``struct sk_buff *challenge``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:334
msgid "The challenge to query"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:337
msgid "Where to return the connection service ID"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:339
msgid "``u8 *_security_index``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:338
msgid "Where to return the connection security index"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:339
msgid "Extract useful parameters from a CHALLENGE message."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:357
msgid "Allow a kernel service to reject a challenge"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:358
msgid "The challenge to be rejected"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:360
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:837
msgid "``u32 abort_code``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:359
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:836
msgid "The abort code to stick into the ABORT packet"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:361
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:838
msgid "``int error``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:360
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:837
msgid "Local error value"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:362
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:839
msgid "``enum rxrpc_abort_reason why``"
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:361
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:838
msgid "Indication as to why."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:362
msgid ""
"Allow a kernel service to reject a challenge by aborting the connection if "
"it's still in an abortable state.  The error is returned so this function "
"can be used with a return statement."
msgstr ""

#: ../../../networking/rxrpc:1156: net/rxrpc/oob.c:367
msgid "The ``error`` parameter."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:471
msgid "Get the peer address of a call"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:472
msgid "The socket on which the call is in progress."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:474
msgid "Get a record for the remote peer in a call."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:477
msgid "The call's peer record."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:486
msgid "Get a call's peer smoothed RTT"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:492
#: net/rxrpc/peer_object.c:506 net/rxrpc/peer_object.c:522
#: net/rxrpc/peer_object.c:555
msgid "``const struct rxrpc_peer *peer``"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:487
#: net/rxrpc/peer_object.c:501 net/rxrpc/peer_object.c:517
#: net/rxrpc/peer_object.c:550
msgid "The peer to query"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:488
msgid "Get the call's peer smoothed RTT."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:491
msgid "The RTT in uS or ``UINT_MAX`` if we have no samples."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:500
msgid "Get the address of a peer"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:502
msgid ""
"Get a pointer to the address from a peer record.  The caller is responsible "
"for making sure that the address is not deallocated.  A fake address will be "
"substituted if ``peer`` in NULL."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:507
msgid "The rxrpc address record or a fake record."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:516
msgid "Get the peer transport address of a call"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:518
msgid ""
"Get a pointer to the transport address from a peer record.  The caller is "
"responsible for making sure that the address is not deallocated.  A fake "
"address will be substituted if ``peer`` in NULL."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:523
msgid "The transport address record or a fake record."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:533
msgid "Set app-specific data on a peer."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:534
msgid "The peer to alter"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:536
msgid "``unsigned long app_data``"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:535
msgid "The data to set"
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:536
msgid ""
"Set the app-specific data on a peer.  AF_RXRPC makes no effort to retain "
"anything the data might refer to."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:540
msgid "The previous app_data."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:549
msgid "Get app-specific data from a peer."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:551
msgid "Retrieve the app-specific data from a peer."
msgstr ""

#: ../../../networking/rxrpc:1157: net/rxrpc/peer_object.c:554
msgid "The peer's app data."
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:573
msgid "Allow a kernel service to receive data/info"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:574
msgid "The socket that the call exists on"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:575
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:794
msgid "The call to send data through"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:577
msgid "``struct iov_iter *iter``"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:576
msgid "The buffer to receive into"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:578
msgid "``size_t *_len``"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:577
msgid "The amount of data we want to receive (decreased on return)"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:579
msgid "``bool want_more``"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:578
msgid "True if more data is expected to be read"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:580
msgid "``u32 *_abort``"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:579
msgid "Where the abort code is stored if -ECONNABORTED is returned"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:581
msgid "``u16 *_service``"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:580
msgid "Where to store the actual service ID (may be upgraded)"
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:581
msgid ""
"Allow a kernel service to receive data and pick up information about the "
"state of a call.  Note that ***_abort** should also be initialised to ``0``."
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:584
msgid ""
"Note that we may return ``-EAGAIN`` to drain empty packets at the end of the "
"data, even if we've already copied over the requested data."
msgstr ""

#: ../../../networking/rxrpc:1158: net/rxrpc/recvmsg.c:588
msgid ""
"``0`` if got what was asked for and there's more available, ``1`` if we got "
"what was asked for and we're at the end of the data and ``-EAGAIN`` if we "
"need more data."
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:729
msgid "Query RxGK-specific challenge parameters"
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:730
msgid "The challenge packet to query"
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:732
msgid "The Kerberos 5 encoding type for the challenged connection."
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:1026
#: ../../../networking/rxrpc:1160: net/rxrpc/rxkad.c:930
msgid "Respond to a challenge with appdata"
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:1027
#: ../../../networking/rxrpc:1160: net/rxrpc/rxkad.c:931
msgid "The challenge to respond to"
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:1029
msgid "``struct krb5_buffer *appdata``"
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:1028
msgid "The application data to include in the RESPONSE authenticator"
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:1029
msgid ""
"Allow a kernel application to respond to a CHALLENGE with application data "
"to be included in the RxGK RESPONSE Authenticator."
msgstr ""

#: ../../../networking/rxrpc:1159: net/rxrpc/rxgk.c:1033
#: ../../../networking/rxrpc:1160: net/rxrpc/rxkad.c:935
#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:804
#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:156
msgid "``0`` if successful and a negative error code otherwise."
msgstr ""

#: ../../../networking/rxrpc:1160: net/rxrpc/rxkad.c:932
msgid "Allow a kernel application to respond to a CHALLENGE."
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:792
msgid "Allow a kernel service to send data on a call"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:796
msgid "``struct msghdr *msg``"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:795
msgid "The data to send"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:797
msgid "``size_t len``"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:796
msgid "The amount of data to send"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:798
msgid "``rxrpc_notify_end_tx_t notify_end_tx``"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:797
msgid "Notification that the last packet is queued."
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:798
msgid ""
"Allow a kernel service to send data on a call.  The call must be in an state "
"appropriate to sending data.  No control data should be supplied in **msg**, "
"nor should an address be supplied.  MSG_MORE should be flagged if there's "
"more data to come, otherwise this data will end the transmission phase."
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:833
msgid "Allow a kernel service to abort a call"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:835
msgid "The call to be aborted"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:839
msgid ""
"Allow a kernel service to abort a call if it's still in an abortable state."
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:842
msgid "``true`` if the call was aborted, ``false`` if it was already complete."
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:859
msgid "Set the total Tx length on a call"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:861
msgid "The call to be informed"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:862
msgid "The amount of data to be transmitted for this call"
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:863
msgid ""
"Allow a kernel service to set the total transmit length on a call.  This "
"allows buffer-to-packet encrypt-and-copy to be performed."
msgstr ""

#: ../../../networking/rxrpc:1161: net/rxrpc/sendmsg.c:866
msgid ""
"This function is primarily for use for setting the reply length since the "
"request length can be set when beginning the call."
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:149
msgid "Set the security keyring for a kernel service"
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:155
#: net/rxrpc/server_key.c:182
msgid "``struct sock *sk``"
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:150
#: net/rxrpc/server_key.c:177
msgid "The socket to set the keyring on"
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:152
msgid "``struct key *keyring``"
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:151
msgid "The keyring to set"
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:152
msgid ""
"Set the server security keyring on an rxrpc socket.  This is used to provide "
"the encryption keys for a kernel service."
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:176
msgid "Set the manage-response flag for a kernel service"
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:179
msgid "``bool set``"
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:178
msgid "True to set, false to clear the flag"
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:179
msgid ""
"Set the flag on an rxrpc socket to say that the caller wants to manage the "
"RESPONSE packet and the user-defined data it may contain.  Setting this "
"means that recvmsg() will return messages with RXRPC_CHALLENGED in the "
"control message buffer containing information about the challenge."
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:184
msgid ""
"The user should respond to the challenge by passing RXRPC_RESPOND or "
"RXRPC_RESPOND_ABORT control messages with sendmsg() to the same call. "
"Supplementary control messages, such as RXRPC_RESP_RXGK_APPDATA, may be "
"included to indicate the parts the user wants to supply."
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:189
msgid ""
"The server will be passed the response data with a RXRPC_RESPONDED control "
"message when it gets the first data from each call."
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:192
msgid ""
"Note that this is only honoured by security classes that need auxiliary data "
"(e.g. RxGK).  Those that don't offer the facility (e.g. RxKAD) respond "
"without consulting userspace."
msgstr ""

#: ../../../networking/rxrpc:1162: net/rxrpc/server_key.c:197
msgid "The previous setting."
msgstr ""
