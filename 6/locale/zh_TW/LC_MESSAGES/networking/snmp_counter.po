# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/snmp_counter.rst:3
msgid "SNMP counter"
msgstr ""

#: ../../../networking/snmp_counter.rst:5
msgid "This document explains the meaning of SNMP counters."
msgstr ""

#: ../../../networking/snmp_counter.rst:8
msgid "General IPv4 counters"
msgstr ""

#: ../../../networking/snmp_counter.rst:9
msgid ""
"All layer 4 packets and ICMP packets will change these counters, but these "
"counters won't be changed by layer 2 packets (such as STP) or ARP packets."
msgstr ""

#: ../../../networking/snmp_counter.rst:13
msgid "IpInReceives"
msgstr ""

#: ../../../networking/snmp_counter.rst:15
msgid "Defined in `RFC1213 ipInReceives`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:19
msgid ""
"The number of packets received by the IP layer. It gets increasing at the "
"beginning of ip_rcv function, always be updated together with IpExtInOctets. "
"It will be increased even if the packet is dropped later (e.g. due to the IP "
"header is invalid or the checksum is wrong and so on).  It indicates the "
"number of aggregated segments after GRO/LRO."
msgstr ""

#: ../../../networking/snmp_counter.rst:26
msgid "IpInDelivers"
msgstr ""

#: ../../../networking/snmp_counter.rst:28
msgid "Defined in `RFC1213 ipInDelivers`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:32
msgid ""
"The number of packets delivers to the upper layer protocols. E.g. TCP, UDP, "
"ICMP and so on. If no one listens on a raw socket, only kernel supported "
"protocols will be delivered, if someone listens on the raw socket, all valid "
"IP packets will be delivered."
msgstr ""

#: ../../../networking/snmp_counter.rst:37
msgid "IpOutRequests"
msgstr ""

#: ../../../networking/snmp_counter.rst:39
msgid "Defined in `RFC1213 ipOutRequests`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:43
msgid ""
"The number of packets sent via IP layer, for both single cast and multicast "
"packets, and would always be updated together with IpExtOutOctets."
msgstr ""

#: ../../../networking/snmp_counter.rst:47
msgid "IpExtInOctets and IpExtOutOctets"
msgstr ""

#: ../../../networking/snmp_counter.rst:49
msgid ""
"They are Linux kernel extensions, no RFC definitions. Please note, RFC1213 "
"indeed defines ifInOctets  and ifOutOctets, but they are different things. "
"The ifInOctets and ifOutOctets include the MAC layer header size but "
"IpExtInOctets and IpExtOutOctets don't, they only include the IP layer "
"header and the IP layer data."
msgstr ""

#: ../../../networking/snmp_counter.rst:55
msgid "IpExtInNoECTPkts, IpExtInECT1Pkts, IpExtInECT0Pkts, IpExtInCEPkts"
msgstr ""

#: ../../../networking/snmp_counter.rst:57
msgid ""
"They indicate the number of four kinds of ECN IP packets, please refer "
"`Explicit Congestion Notification`_ for more details."
msgstr ""

#: ../../../networking/snmp_counter.rst:62
msgid ""
"These 4 counters calculate how many packets received per ECN status. They "
"count the real frame number regardless the LRO/GRO. So for the same packet, "
"you might find that IpInReceives count 1, but IpExtInNoECTPkts counts 2 or "
"more."
msgstr ""

#: ../../../networking/snmp_counter.rst:67
msgid "IpInHdrErrors"
msgstr ""

#: ../../../networking/snmp_counter.rst:69
msgid ""
"Defined in `RFC1213 ipInHdrErrors`_. It indicates the packet is dropped due "
"to the IP header error. It might happen in both IP input and IP forward "
"paths."
msgstr ""

#: ../../../networking/snmp_counter.rst:75
msgid "IpInAddrErrors"
msgstr ""

#: ../../../networking/snmp_counter.rst:77
msgid ""
"Defined in `RFC1213 ipInAddrErrors`_. It will be increased in two scenarios: "
"(1) The IP address is invalid. (2) The destination IP address is not a local "
"address and IP forwarding is not enabled"
msgstr ""

#: ../../../networking/snmp_counter.rst:83
msgid "IpExtInNoRoutes"
msgstr ""

#: ../../../networking/snmp_counter.rst:85
msgid ""
"This counter means the packet is dropped when the IP stack receives a packet "
"and can't find a route for it from the route table. It might happen when IP "
"forwarding is enabled and the destination IP address is not a local address "
"and there is no route for the destination IP address."
msgstr ""

#: ../../../networking/snmp_counter.rst:91
msgid "IpInUnknownProtos"
msgstr ""

#: ../../../networking/snmp_counter.rst:93
msgid ""
"Defined in `RFC1213 ipInUnknownProtos`_. It will be increased if the layer 4 "
"protocol is unsupported by kernel. If an application is using raw socket, "
"kernel will always deliver the packet to the raw socket and this counter "
"won't be increased."
msgstr ""

#: ../../../networking/snmp_counter.rst:100
msgid "IpExtInTruncatedPkts"
msgstr ""

#: ../../../networking/snmp_counter.rst:102
msgid ""
"For IPv4 packet, it means the actual data size is smaller than the \"Total "
"Length\" field in the IPv4 header."
msgstr ""

#: ../../../networking/snmp_counter.rst:105
msgid "IpInDiscards"
msgstr ""

#: ../../../networking/snmp_counter.rst:107
msgid ""
"Defined in `RFC1213 ipInDiscards`_. It indicates the packet is dropped in "
"the IP receiving path and due to kernel internal reasons (e.g. no enough "
"memory)."
msgstr ""

#: ../../../networking/snmp_counter.rst:113
msgid "IpOutDiscards"
msgstr ""

#: ../../../networking/snmp_counter.rst:115
msgid ""
"Defined in `RFC1213 ipOutDiscards`_. It indicates the packet is dropped in "
"the IP sending path and due to kernel internal reasons."
msgstr ""

#: ../../../networking/snmp_counter.rst:120
msgid "IpOutNoRoutes"
msgstr ""

#: ../../../networking/snmp_counter.rst:122
msgid ""
"Defined in `RFC1213 ipOutNoRoutes`_. It indicates the packet is dropped in "
"the IP sending path and no route is found for it."
msgstr ""

#: ../../../networking/snmp_counter.rst:128
msgid "ICMP counters"
msgstr ""

#: ../../../networking/snmp_counter.rst:129
msgid "IcmpInMsgs and IcmpOutMsgs"
msgstr ""

#: ../../../networking/snmp_counter.rst:131
msgid "Defined by `RFC1213 icmpInMsgs`_ and `RFC1213 icmpOutMsgs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:136
msgid ""
"As mentioned in the RFC1213, these two counters include errors, they would "
"be increased even if the ICMP packet has an invalid type. The ICMP output "
"path will check the header of a raw socket, so the IcmpOutMsgs would still "
"be updated if the IP header is constructed by a userspace program."
msgstr ""

#: ../../../networking/snmp_counter.rst:142
msgid "ICMP named types"
msgstr ""

#: ../../../networking/snmp_counter.rst:144
msgid "These counters include most of common ICMP types, they are:"
msgstr ""

#: ../../../networking/snmp_counter.rst:145
msgid "IcmpInDestUnreachs: `RFC1213 icmpInDestUnreachs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:146
msgid "IcmpInTimeExcds: `RFC1213 icmpInTimeExcds`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:147
msgid "IcmpInParmProbs: `RFC1213 icmpInParmProbs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:148
msgid "IcmpInSrcQuenchs: `RFC1213 icmpInSrcQuenchs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:149
msgid "IcmpInRedirects: `RFC1213 icmpInRedirects`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:150
msgid "IcmpInEchos: `RFC1213 icmpInEchos`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:151
msgid "IcmpInEchoReps: `RFC1213 icmpInEchoReps`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:152
msgid "IcmpInTimestamps: `RFC1213 icmpInTimestamps`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:153
msgid "IcmpInTimestampReps: `RFC1213 icmpInTimestampReps`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:154
msgid "IcmpInAddrMasks: `RFC1213 icmpInAddrMasks`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:155
msgid "IcmpInAddrMaskReps: `RFC1213 icmpInAddrMaskReps`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:156
msgid "IcmpOutDestUnreachs: `RFC1213 icmpOutDestUnreachs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:157
msgid "IcmpOutTimeExcds: `RFC1213 icmpOutTimeExcds`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:158
msgid "IcmpOutParmProbs: `RFC1213 icmpOutParmProbs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:159
msgid "IcmpOutSrcQuenchs: `RFC1213 icmpOutSrcQuenchs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:160
msgid "IcmpOutRedirects: `RFC1213 icmpOutRedirects`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:161
msgid "IcmpOutEchos: `RFC1213 icmpOutEchos`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:162
msgid "IcmpOutEchoReps: `RFC1213 icmpOutEchoReps`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:163
msgid "IcmpOutTimestamps: `RFC1213 icmpOutTimestamps`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:164
msgid "IcmpOutTimestampReps: `RFC1213 icmpOutTimestampReps`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:165
msgid "IcmpOutAddrMasks: `RFC1213 icmpOutAddrMasks`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:166
msgid "IcmpOutAddrMaskReps: `RFC1213 icmpOutAddrMaskReps`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:192
msgid ""
"Every ICMP type has two counters: 'In' and 'Out'. E.g., for the ICMP Echo "
"packet, they are IcmpInEchos and IcmpOutEchos. Their meanings are "
"straightforward. The 'In' counter means kernel receives such a packet and "
"the 'Out' counter means kernel sends such a packet."
msgstr ""

#: ../../../networking/snmp_counter.rst:197
msgid "ICMP numeric types"
msgstr ""

#: ../../../networking/snmp_counter.rst:199
msgid ""
"They are IcmpMsgInType[N] and IcmpMsgOutType[N], the [N] indicates the ICMP "
"type number. These counters track all kinds of ICMP packets. The ICMP type "
"number definition could be found in the `ICMP parameters`_ document."
msgstr ""

#: ../../../networking/snmp_counter.rst:206
msgid ""
"For example, if the Linux kernel sends an ICMP Echo packet, the "
"IcmpMsgOutType8 would increase 1. And if kernel gets an ICMP Echo Reply "
"packet, IcmpMsgInType0 would increase 1."
msgstr ""

#: ../../../networking/snmp_counter.rst:210
msgid "IcmpInCsumErrors"
msgstr ""

#: ../../../networking/snmp_counter.rst:212
msgid ""
"This counter indicates the checksum of the ICMP packet is wrong. Kernel "
"verifies the checksum after updating the IcmpInMsgs and before updating "
"IcmpMsgInType[N]. If a packet has bad checksum, the IcmpInMsgs would be "
"updated but none of IcmpMsgInType[N] would be updated."
msgstr ""

#: ../../../networking/snmp_counter.rst:217
msgid "IcmpInErrors and IcmpOutErrors"
msgstr ""

#: ../../../networking/snmp_counter.rst:219
msgid "Defined by `RFC1213 icmpInErrors`_ and `RFC1213 icmpOutErrors`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:224
msgid ""
"When an error occurs in the ICMP packet handler path, these two counters "
"would be updated. The receiving packet path use IcmpInErrors and the sending "
"packet path use IcmpOutErrors. When IcmpInCsumErrors is increased, "
"IcmpInErrors would always be increased too."
msgstr ""

#: ../../../networking/snmp_counter.rst:230
msgid "relationship of the ICMP counters"
msgstr ""

#: ../../../networking/snmp_counter.rst:231
msgid ""
"The sum of IcmpMsgOutType[N] is always equal to IcmpOutMsgs, as they are "
"updated at the same time. The sum of IcmpMsgInType[N] plus IcmpInErrors "
"should be equal or larger than IcmpInMsgs. When kernel receives an ICMP "
"packet, kernel follows below logic:"
msgstr ""

#: ../../../networking/snmp_counter.rst:236
msgid "increase IcmpInMsgs"
msgstr ""

#: ../../../networking/snmp_counter.rst:237
msgid "if has any error, update IcmpInErrors and finish the process"
msgstr ""

#: ../../../networking/snmp_counter.rst:238
msgid "update IcmpMsgOutType[N]"
msgstr ""

#: ../../../networking/snmp_counter.rst:239
msgid ""
"handle the packet depending on the type, if has any error, update "
"IcmpInErrors and finish the process"
msgstr ""

#: ../../../networking/snmp_counter.rst:242
msgid ""
"So if all errors occur in step (2), IcmpInMsgs should be equal to the sum of "
"IcmpMsgOutType[N] plus IcmpInErrors. If all errors occur in step (4), "
"IcmpInMsgs should be equal to the sum of IcmpMsgOutType[N]. If the errors "
"occur in both step (2) and step (4), IcmpInMsgs should be less than the sum "
"of IcmpMsgOutType[N] plus IcmpInErrors."
msgstr ""

#: ../../../networking/snmp_counter.rst:250
msgid "General TCP counters"
msgstr ""

#: ../../../networking/snmp_counter.rst:251
msgid "TcpInSegs"
msgstr ""

#: ../../../networking/snmp_counter.rst:253
msgid "Defined in `RFC1213 tcpInSegs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:257
msgid ""
"The number of packets received by the TCP layer. As mentioned in RFC1213, it "
"includes the packets received in error, such as checksum error, invalid TCP "
"header and so on. Only one error won't be included: if the layer 2 "
"destination address is not the NIC's layer 2 address. It might happen if the "
"packet is a multicast or broadcast packet, or the NIC is in promiscuous "
"mode. In these situations, the packets would be delivered to the TCP layer, "
"but the TCP layer will discard these packets before increasing TcpInSegs. "
"The TcpInSegs counter isn't aware of GRO. So if two packets are merged by "
"GRO, the TcpInSegs counter would only increase 1."
msgstr ""

#: ../../../networking/snmp_counter.rst:268
msgid "TcpOutSegs"
msgstr ""

#: ../../../networking/snmp_counter.rst:270
msgid "Defined in `RFC1213 tcpOutSegs`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:274
msgid ""
"The number of packets sent by the TCP layer. As mentioned in RFC1213, it "
"excludes the retransmitted packets. But it includes the SYN, ACK and RST "
"packets. Doesn't like TcpInSegs, the TcpOutSegs is aware of GSO, so if a "
"packet would be split to 2 by GSO, TcpOutSegs will increase 2."
msgstr ""

#: ../../../networking/snmp_counter.rst:280
msgid "TcpActiveOpens"
msgstr ""

#: ../../../networking/snmp_counter.rst:282
msgid "Defined in `RFC1213 tcpActiveOpens`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:286
msgid ""
"It means the TCP layer sends a SYN, and come into the SYN-SENT state. Every "
"time TcpActiveOpens increases 1, TcpOutSegs should always increase 1."
msgstr ""

#: ../../../networking/snmp_counter.rst:290
msgid "TcpPassiveOpens"
msgstr ""

#: ../../../networking/snmp_counter.rst:292
msgid "Defined in `RFC1213 tcpPassiveOpens`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:296
msgid ""
"It means the TCP layer receives a SYN, replies a SYN+ACK, come into the SYN-"
"RCVD state."
msgstr ""

#: ../../../networking/snmp_counter.rst:299
#: ../../../networking/snmp_counter.rst:1441
msgid "TcpExtTCPRcvCoalesce"
msgstr ""

#: ../../../networking/snmp_counter.rst:301
msgid ""
"When packets are received by the TCP layer and are not be read by the "
"application, the TCP layer will try to merge them. This counter indicate how "
"many packets are merged in such situation. If GRO is enabled, lots of "
"packets would be merged by GRO, these packets wouldn't be counted to "
"TcpExtTCPRcvCoalesce."
msgstr ""

#: ../../../networking/snmp_counter.rst:307
msgid "TcpExtTCPAutoCorking"
msgstr ""

#: ../../../networking/snmp_counter.rst:309
msgid ""
"When sending packets, the TCP layer will try to merge small packets to a "
"bigger one. This counter increase 1 for every packet merged in such "
"situation. Please refer to the LWN article for more details: https://lwn.net/"
"Articles/576263/"
msgstr ""

#: ../../../networking/snmp_counter.rst:314
msgid "TcpExtTCPOrigDataSent"
msgstr ""

#: ../../../networking/snmp_counter.rst:316
#: ../../../networking/snmp_counter.rst:326
#: ../../../networking/snmp_counter.rst:334
msgid ""
"This counter is explained by kernel commit f19c29e3e391, I pasted the "
"explanation below::"
msgstr ""

#: ../../../networking/snmp_counter.rst:324
msgid "TCPSynRetrans"
msgstr ""

#: ../../../networking/snmp_counter.rst:332
msgid "TCPFastOpenActiveFail"
msgstr ""

#: ../../../networking/snmp_counter.rst:340
#: ../../../networking/snmp_counter.rst:1501
msgid "TcpExtListenOverflows and TcpExtListenDrops"
msgstr ""

#: ../../../networking/snmp_counter.rst:342
msgid ""
"When kernel receives a SYN from a client, and if the TCP accept queue is "
"full, kernel will drop the SYN and add 1 to TcpExtListenOverflows. At the "
"same time kernel will also add 1 to TcpExtListenDrops. When a TCP socket is "
"in LISTEN state, and kernel need to drop a packet, kernel would always add 1 "
"to TcpExtListenDrops. So increase TcpExtListenOverflows would let "
"TcpExtListenDrops increasing at the same time, but TcpExtListenDrops would "
"also increase without TcpExtListenOverflows increasing, e.g. a memory "
"allocation fail would also let TcpExtListenDrops increase."
msgstr ""

#: ../../../networking/snmp_counter.rst:352
msgid ""
"Note: The above explanation is based on kernel 4.10 or above version, on an "
"old kernel, the TCP stack has different behavior when TCP accept queue is "
"full. On the old kernel, TCP stack won't drop the SYN, it would complete the "
"3-way handshake. As the accept queue is full, TCP stack will keep the socket "
"in the TCP half-open queue. As it is in the half open queue, TCP stack will "
"send SYN+ACK on an exponential backoff timer, after client replies ACK, TCP "
"stack checks whether the accept queue is still full, if it is not full, "
"moves the socket to the accept queue, if it is full, keeps the socket in the "
"half-open queue, at next time client replies ACK, this socket will get "
"another chance to move to the accept queue."
msgstr ""

#: ../../../networking/snmp_counter.rst:366
msgid "TCP Fast Open"
msgstr ""

#: ../../../networking/snmp_counter.rst:367
#: ../../../networking/snmp_counter.rst:396
msgid "TcpEstabResets"
msgstr ""

#: ../../../networking/snmp_counter.rst:369
msgid "Defined in `RFC1213 tcpEstabResets`_."
msgstr ""

#: ../../../networking/snmp_counter.rst:373
msgid "TcpAttemptFails"
msgstr ""

#: ../../../networking/snmp_counter.rst:375
msgid "Defined in `RFC1213 tcpAttemptFails`_."
msgstr ""

#: ../../../networking/snmp_counter.rst:379
msgid "TcpOutRsts"
msgstr ""

#: ../../../networking/snmp_counter.rst:381
msgid ""
"Defined in `RFC1213 tcpOutRsts`_. The RFC says this counter indicates the "
"'segments sent containing the RST flag', but in linux kernel, this counter "
"indicates the segments kernel tried to send. The sending process might be "
"failed due to some errors (e.g. memory alloc failed)."
msgstr ""

#: ../../../networking/snmp_counter.rst:388
msgid "TcpExtTCPSpuriousRtxHostQueues"
msgstr ""

#: ../../../networking/snmp_counter.rst:390
msgid ""
"When the TCP stack wants to retransmit a packet, and finds that packet is "
"not lost in the network, but the packet is not sent yet, the TCP stack would "
"give up the retransmission and update this counter. It might happen if a "
"packet stays too long time in a qdisc or driver queue."
msgstr ""

#: ../../../networking/snmp_counter.rst:398
msgid "The socket receives a RST packet in Establish or CloseWait state."
msgstr ""

#: ../../../networking/snmp_counter.rst:400
msgid "TcpExtTCPKeepAlive"
msgstr ""

#: ../../../networking/snmp_counter.rst:402
msgid ""
"This counter indicates many keepalive packets were sent. The keepalive won't "
"be enabled by default. A userspace program could enable it by setting the "
"SO_KEEPALIVE socket option."
msgstr ""

#: ../../../networking/snmp_counter.rst:406
msgid "TcpExtTCPSpuriousRTOs"
msgstr ""

#: ../../../networking/snmp_counter.rst:408
msgid "The spurious retransmission timeout detected by the `F-RTO`_ algorithm."
msgstr ""

#: ../../../networking/snmp_counter.rst:414
msgid "TCP Fast Path"
msgstr ""

#: ../../../networking/snmp_counter.rst:415
msgid ""
"When kernel receives a TCP packet, it has two paths to handler the packet, "
"one is fast path, another is slow path. The comment in kernel code provides "
"a good explanation of them, I pasted them below::"
msgstr ""

#: ../../../networking/snmp_counter.rst:435
msgid ""
"Kernel will try to use fast path unless any of the above conditions are "
"satisfied. If the packets are out of order, kernel will handle them in slow "
"path, which means the performance might be not very good. Kernel would also "
"come into slow path if the \"Delayed ack\" is used, because when using "
"\"Delayed ack\", the data is sent in both directions. When the TCP window "
"scale option is not used, kernel will try to enable fast path immediately "
"when the connection comes into the established state, but if the TCP window "
"scale option is used, kernel will disable the fast path at first, and try to "
"enable it after kernel receives packets."
msgstr ""

#: ../../../networking/snmp_counter.rst:446
msgid "TcpExtTCPPureAcks and TcpExtTCPHPAcks"
msgstr ""

#: ../../../networking/snmp_counter.rst:448
msgid ""
"If a packet set ACK flag and has no data, it is a pure ACK packet, if kernel "
"handles it in the fast path, TcpExtTCPHPAcks will increase 1, if kernel "
"handles it in the slow path, TcpExtTCPPureAcks will increase 1."
msgstr ""

#: ../../../networking/snmp_counter.rst:453
msgid "TcpExtTCPHPHits"
msgstr ""

#: ../../../networking/snmp_counter.rst:455
msgid ""
"If a TCP packet has data (which means it is not a pure ACK packet), and this "
"packet is handled in the fast path, TcpExtTCPHPHits will increase 1."
msgstr ""

#: ../../../networking/snmp_counter.rst:461
msgid "TCP abort"
msgstr ""

#: ../../../networking/snmp_counter.rst:462
msgid "TcpExtTCPAbortOnData"
msgstr ""

#: ../../../networking/snmp_counter.rst:464
msgid ""
"It means TCP layer has data in flight, but need to close the connection. So "
"TCP layer sends a RST to the other side, indicate the connection is not "
"closed very graceful. An easy way to increase this counter is using the "
"SO_LINGER option. Please refer to the SO_LINGER section of the `socket man "
"page`_:"
msgstr ""

#: ../../../networking/snmp_counter.rst:472
msgid ""
"By default, when an application closes a connection, the close function will "
"return immediately and kernel will try to send the in-flight data async. If "
"you use the SO_LINGER option, set l_onoff to 1, and l_linger to a positive "
"number, the close function won't return immediately, but wait for the in-"
"flight data are acked by the other side, the max wait time is l_linger "
"seconds. If set l_onoff to 1 and set l_linger to 0, when the application "
"closes a connection, kernel will send a RST immediately and increase the "
"TcpExtTCPAbortOnData counter."
msgstr ""

#: ../../../networking/snmp_counter.rst:481
#: ../../../networking/snmp_counter.rst:1240
msgid "TcpExtTCPAbortOnClose"
msgstr ""

#: ../../../networking/snmp_counter.rst:483
msgid ""
"This counter means the application has unread data in the TCP layer when the "
"application wants to close the TCP connection. In such a situation, kernel "
"will send a RST to the other side of the TCP connection."
msgstr ""

#: ../../../networking/snmp_counter.rst:487
msgid "TcpExtTCPAbortOnMemory"
msgstr ""

#: ../../../networking/snmp_counter.rst:489
msgid ""
"When an application closes a TCP connection, kernel still need to track the "
"connection, let it complete the TCP disconnect process. E.g. an app calls "
"the close method of a socket, kernel sends fin to the other side of the "
"connection, then the app has no relationship with the socket any more, but "
"kernel need to keep the socket, this socket becomes an orphan socket, kernel "
"waits for the reply of the other side, and would come to the TIME_WAIT state "
"finally. When kernel has no enough memory to keep the orphan socket, kernel "
"would send an RST to the other side, and delete the socket, in such "
"situation, kernel will increase 1 to the TcpExtTCPAbortOnMemory. Two "
"conditions would trigger TcpExtTCPAbortOnMemory:"
msgstr ""

#: ../../../networking/snmp_counter.rst:501
msgid ""
"1. the memory used by the TCP protocol is higher than the third value of the "
"tcp_mem. Please refer the tcp_mem section in the `TCP man page`_:"
msgstr ""

#: ../../../networking/snmp_counter.rst:506
msgid "the orphan socket count is higher than net.ipv4.tcp_max_orphans"
msgstr ""

#: ../../../networking/snmp_counter.rst:509
msgid "TcpExtTCPAbortOnTimeout"
msgstr ""

#: ../../../networking/snmp_counter.rst:511
msgid ""
"This counter will increase when any of the TCP timers expire. In such "
"situation, kernel won't send RST, just give up the connection."
msgstr ""

#: ../../../networking/snmp_counter.rst:514
#: ../../../networking/snmp_counter.rst:1396
msgid "TcpExtTCPAbortOnLinger"
msgstr ""

#: ../../../networking/snmp_counter.rst:516
msgid ""
"When a TCP connection comes into FIN_WAIT_2 state, instead of waiting for "
"the fin packet from the other side, kernel could send a RST and delete the "
"socket immediately. This is not the default behavior of Linux kernel TCP "
"stack. By configuring the TCP_LINGER2 socket option, you could let kernel "
"follow this behavior."
msgstr ""

#: ../../../networking/snmp_counter.rst:522
msgid "TcpExtTCPAbortFailed"
msgstr ""

#: ../../../networking/snmp_counter.rst:524
msgid ""
"The kernel TCP layer will send RST if the `RFC2525 2.17 section`_ is "
"satisfied. If an internal error occurs during this process, "
"TcpExtTCPAbortFailed will be increased."
msgstr ""

#: ../../../networking/snmp_counter.rst:531
msgid "TCP Hybrid Slow Start"
msgstr ""

#: ../../../networking/snmp_counter.rst:532
msgid ""
"The Hybrid Slow Start algorithm is an enhancement of the traditional TCP "
"congestion window Slow Start algorithm. It uses two pieces of information to "
"detect whether the max bandwidth of the TCP path is approached. The two "
"pieces of information are ACK train length and increase in packet delay. For "
"detail information, please refer the `Hybrid Slow Start paper`_. Either ACK "
"train length or packet delay hits a specific threshold, the congestion "
"control algorithm will come into the Congestion Avoidance state. Until "
"v4.20, two congestion control algorithms are using Hybrid Slow Start, they "
"are cubic (the default congestion control algorithm) and cdg. Four snmp "
"counters relate with the Hybrid Slow Start algorithm."
msgstr ""

#: ../../../networking/snmp_counter.rst:546
msgid "TcpExtTCPHystartTrainDetect"
msgstr ""

#: ../../../networking/snmp_counter.rst:548
msgid "How many times the ACK train length threshold is detected"
msgstr ""

#: ../../../networking/snmp_counter.rst:550
msgid "TcpExtTCPHystartTrainCwnd"
msgstr ""

#: ../../../networking/snmp_counter.rst:552
msgid ""
"The sum of CWND detected by ACK train length. Dividing this value by "
"TcpExtTCPHystartTrainDetect is the average CWND which detected by the ACK "
"train length."
msgstr ""

#: ../../../networking/snmp_counter.rst:556
msgid "TcpExtTCPHystartDelayDetect"
msgstr ""

#: ../../../networking/snmp_counter.rst:558
msgid "How many times the packet delay threshold is detected."
msgstr ""

#: ../../../networking/snmp_counter.rst:560
msgid "TcpExtTCPHystartDelayCwnd"
msgstr ""

#: ../../../networking/snmp_counter.rst:562
msgid ""
"The sum of CWND detected by packet delay. Dividing this value by "
"TcpExtTCPHystartDelayDetect is the average CWND which detected by the packet "
"delay."
msgstr ""

#: ../../../networking/snmp_counter.rst:567
msgid "TCP retransmission and congestion control"
msgstr ""

#: ../../../networking/snmp_counter.rst:568
msgid ""
"The TCP protocol has two retransmission mechanisms: SACK and fast recovery. "
"They are exclusive with each other. When SACK is enabled, the kernel TCP "
"stack would use SACK, or kernel would use fast recovery. The SACK is a TCP "
"option, which is defined in `RFC2018`_, the fast recovery is defined in "
"`RFC6582`_, which is also called 'Reno'."
msgstr ""

#: ../../../networking/snmp_counter.rst:575
msgid ""
"The TCP congestion control is a big and complex topic. To understand the "
"related snmp counter, we need to know the states of the congestion control "
"state machine. There are 5 states: Open, Disorder, CWR, Recovery and Loss. "
"For details about these states, please refer page 5 and page 6 of this "
"document: https://pdfs.semanticscholar."
"org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf"
msgstr ""

#: ../../../networking/snmp_counter.rst:585
msgid "TcpExtTCPRenoRecovery and TcpExtTCPSackRecovery"
msgstr ""

#: ../../../networking/snmp_counter.rst:587
msgid ""
"When the congestion control comes into Recovery state, if sack is used, "
"TcpExtTCPSackRecovery increases 1, if sack is not used, "
"TcpExtTCPRenoRecovery increases 1. These two counters mean the TCP stack "
"begins to retransmit the lost packets."
msgstr ""

#: ../../../networking/snmp_counter.rst:592
msgid "TcpExtTCPSACKReneging"
msgstr ""

#: ../../../networking/snmp_counter.rst:594
msgid ""
"A packet was acknowledged by SACK, but the receiver has dropped this packet, "
"so the sender needs to retransmit this packet. In this situation, the sender "
"adds 1 to TcpExtTCPSACKReneging. A receiver could drop a packet which has "
"been acknowledged by SACK, although it is unusual, it is allowed by the TCP "
"protocol. The sender doesn't really know what happened on the receiver side. "
"The sender just waits until the RTO expires for this packet, then the sender "
"assumes this packet has been dropped by the receiver."
msgstr ""

#: ../../../networking/snmp_counter.rst:603
msgid "TcpExtTCPRenoReorder"
msgstr ""

#: ../../../networking/snmp_counter.rst:605
msgid ""
"The reorder packet is detected by fast recovery. It would only be used if "
"SACK is disabled. The fast recovery algorithm detects recorder by the "
"duplicate ACK number. E.g., if retransmission is triggered, and the original "
"retransmitted packet is not lost, it is just out of order, the receiver "
"would acknowledge multiple times, one for the retransmitted packet, another "
"for the arriving of the original out of order packet. Thus the sender would "
"find more ACks than its expectation, and the sender knows out of order "
"occurs."
msgstr ""

#: ../../../networking/snmp_counter.rst:614
msgid "TcpExtTCPTSReorder"
msgstr ""

#: ../../../networking/snmp_counter.rst:616
msgid ""
"The reorder packet is detected when a hole is filled. E.g., assume the "
"sender sends packet 1,2,3,4,5, and the receiving order is 1,2,4,5,3. When "
"the sender receives the ACK of packet 3 (which will fill the hole), two "
"conditions will let TcpExtTCPTSReorder increase 1: (1) if the packet 3 is "
"not re-retransmitted yet. (2) if the packet 3 is retransmitted but the "
"timestamp of the packet 3's ACK is earlier than the retransmission timestamp."
msgstr ""

#: ../../../networking/snmp_counter.rst:624
msgid "TcpExtTCPSACKReorder"
msgstr ""

#: ../../../networking/snmp_counter.rst:626
msgid ""
"The reorder packet detected by SACK. The SACK has two methods to detect "
"reorder: (1) DSACK is received by the sender. It means the sender sends the "
"same packet more than one times. And the only reason is the sender believes "
"an out of order packet is lost so it sends the packet again. (2) Assume "
"packet 1,2,3,4,5 are sent by the sender, and the sender has received SACKs "
"for packet 2 and 5, now the sender receives SACK for packet 4 and the sender "
"doesn't retransmit the packet yet, the sender would know packet 4 is out of "
"order. The TCP stack of kernel will increase TcpExtTCPSACKReorder for both "
"of the above scenarios."
msgstr ""

#: ../../../networking/snmp_counter.rst:637
msgid "TcpExtTCPSlowStartRetrans"
msgstr ""

#: ../../../networking/snmp_counter.rst:639
msgid ""
"The TCP stack wants to retransmit a packet and the congestion control state "
"is 'Loss'."
msgstr ""

#: ../../../networking/snmp_counter.rst:642
msgid "TcpExtTCPFastRetrans"
msgstr ""

#: ../../../networking/snmp_counter.rst:644
msgid ""
"The TCP stack wants to retransmit a packet and the congestion control state "
"is not 'Loss'."
msgstr ""

#: ../../../networking/snmp_counter.rst:647
msgid "TcpExtTCPLostRetransmit"
msgstr ""

#: ../../../networking/snmp_counter.rst:649
msgid "A SACK points out that a retransmission packet is lost again."
msgstr ""

#: ../../../networking/snmp_counter.rst:651
msgid "TcpExtTCPRetransFail"
msgstr ""

#: ../../../networking/snmp_counter.rst:653
msgid ""
"The TCP stack tries to deliver a retransmission packet to lower layers but "
"the lower layers return an error."
msgstr ""

#: ../../../networking/snmp_counter.rst:656
msgid "TcpExtTCPSynRetrans"
msgstr ""

#: ../../../networking/snmp_counter.rst:658
msgid "The TCP stack retransmits a SYN packet."
msgstr ""

#: ../../../networking/snmp_counter.rst:661
msgid "DSACK"
msgstr ""

#: ../../../networking/snmp_counter.rst:662
msgid ""
"The DSACK is defined in `RFC2883`_. The receiver uses DSACK to report "
"duplicate packets to the sender. There are two kinds of duplications: (1) a "
"packet which has been acknowledged is duplicate. (2) an out of order packet "
"is duplicate. The TCP stack counts these two kinds of duplications on both "
"receiver side and sender side."
msgstr ""

#: ../../../networking/snmp_counter.rst:671
msgid "TcpExtTCPDSACKOldSent"
msgstr ""

#: ../../../networking/snmp_counter.rst:673
msgid ""
"The TCP stack receives a duplicate packet which has been acked, so it sends "
"a DSACK to the sender."
msgstr ""

#: ../../../networking/snmp_counter.rst:676
msgid "TcpExtTCPDSACKOfoSent"
msgstr ""

#: ../../../networking/snmp_counter.rst:678
msgid ""
"The TCP stack receives an out of order duplicate packet, so it sends a DSACK "
"to the sender."
msgstr ""

#: ../../../networking/snmp_counter.rst:681
msgid "TcpExtTCPDSACKRecv"
msgstr ""

#: ../../../networking/snmp_counter.rst:683
msgid ""
"The TCP stack receives a DSACK, which indicates an acknowledged duplicate "
"packet is received."
msgstr ""

#: ../../../networking/snmp_counter.rst:686
msgid "TcpExtTCPDSACKOfoRecv"
msgstr ""

#: ../../../networking/snmp_counter.rst:688
msgid ""
"The TCP stack receives a DSACK, which indicate an out of order duplicate "
"packet is received."
msgstr ""

#: ../../../networking/snmp_counter.rst:692
msgid "invalid SACK and DSACK"
msgstr ""

#: ../../../networking/snmp_counter.rst:693
msgid ""
"When a SACK (or DSACK) block is invalid, a corresponding counter would be "
"updated. The validation method is base on the start/end sequence number of "
"the SACK block. For more details, please refer the comment of the function "
"tcp_is_sackblock_valid in the kernel source code. A SACK option could have "
"up to 4 blocks, they are checked individually. E.g., if 3 blocks of a SACk "
"is invalid, the corresponding counter would be updated 3 times. The comment "
"of commit 18f02545a9a1 (\"[TCP] MIB: Add counters for discarded SACK "
"blocks\") has additional explanation:"
msgstr ""

#: ../../../networking/snmp_counter.rst:703
msgid "TcpExtTCPSACKDiscard"
msgstr ""

#: ../../../networking/snmp_counter.rst:705
msgid ""
"This counter indicates how many SACK blocks are invalid. If the invalid SACK "
"block is caused by ACK recording, the TCP stack will only ignore it and "
"won't update this counter."
msgstr ""

#: ../../../networking/snmp_counter.rst:709
msgid "TcpExtTCPDSACKIgnoredOld and TcpExtTCPDSACKIgnoredNoUndo"
msgstr ""

#: ../../../networking/snmp_counter.rst:711
msgid ""
"When a DSACK block is invalid, one of these two counters would be updated. "
"Which counter will be updated depends on the undo_marker flag of the TCP "
"socket. If the undo_marker is not set, the TCP stack isn't likely to re-"
"transmit any packets, and we still receive an invalid DSACK block, the "
"reason might be that the packet is duplicated in the middle of the network. "
"In such scenario, TcpExtTCPDSACKIgnoredNoUndo will be updated. If the "
"undo_marker is set, TcpExtTCPDSACKIgnoredOld will be updated. As implied in "
"its name, it might be an old packet."
msgstr ""

#: ../../../networking/snmp_counter.rst:721
msgid "SACK shift"
msgstr ""

#: ../../../networking/snmp_counter.rst:722
msgid ""
"The linux networking stack stores data in sk_buff struct (skb for short). If "
"a SACK block acrosses multiple skb, the TCP stack will try to re-arrange "
"data in these skb. E.g. if a SACK block acknowledges seq 10 to 15, skb1 has "
"seq 10 to 13, skb2 has seq 14 to 20. The seq 14 and 15 in skb2 would be "
"moved to skb1. This operation is 'shift'. If a SACK block acknowledges seq "
"10 to 20, skb1 has seq 10 to 13, skb2 has seq 14 to 20. All data in skb2 "
"will be moved to skb1, and skb2 will be discard, this operation is 'merge'."
msgstr ""

#: ../../../networking/snmp_counter.rst:731
msgid "TcpExtTCPSackShifted"
msgstr ""

#: ../../../networking/snmp_counter.rst:733
msgid "A skb is shifted"
msgstr ""

#: ../../../networking/snmp_counter.rst:735
msgid "TcpExtTCPSackMerged"
msgstr ""

#: ../../../networking/snmp_counter.rst:737
msgid "A skb is merged"
msgstr ""

#: ../../../networking/snmp_counter.rst:739
msgid "TcpExtTCPSackShiftFallback"
msgstr ""

#: ../../../networking/snmp_counter.rst:741
msgid ""
"A skb should be shifted or merged, but the TCP stack doesn't do it for some "
"reasons."
msgstr ""

#: ../../../networking/snmp_counter.rst:745
msgid "TCP out of order"
msgstr ""

#: ../../../networking/snmp_counter.rst:746
msgid "TcpExtTCPOFOQueue"
msgstr ""

#: ../../../networking/snmp_counter.rst:748
msgid ""
"The TCP layer receives an out of order packet and has enough memory to queue "
"it."
msgstr ""

#: ../../../networking/snmp_counter.rst:751
msgid "TcpExtTCPOFODrop"
msgstr ""

#: ../../../networking/snmp_counter.rst:753
msgid ""
"The TCP layer receives an out of order packet but doesn't have enough "
"memory, so drops it. Such packets won't be counted into TcpExtTCPOFOQueue."
msgstr ""

#: ../../../networking/snmp_counter.rst:757
msgid "TcpExtTCPOFOMerge"
msgstr ""

#: ../../../networking/snmp_counter.rst:759
msgid ""
"The received out of order packet has an overlay with the previous packet. "
"the overlay part will be dropped. All of TcpExtTCPOFOMerge packets will also "
"be counted into TcpExtTCPOFOQueue."
msgstr ""

#: ../../../networking/snmp_counter.rst:764
msgid "TCP PAWS"
msgstr ""

#: ../../../networking/snmp_counter.rst:765
msgid ""
"PAWS (Protection Against Wrapped Sequence numbers) is an algorithm which is "
"used to drop old packets. It depends on the TCP timestamps. For detail "
"information, please refer the `timestamp wiki`_ and the `RFC of PAWS`_."
msgstr ""

#: ../../../networking/snmp_counter.rst:773
msgid "TcpExtPAWSActive"
msgstr ""

#: ../../../networking/snmp_counter.rst:775
msgid "Packets are dropped by PAWS in Syn-Sent status."
msgstr ""

#: ../../../networking/snmp_counter.rst:777
msgid "TcpExtPAWSEstab"
msgstr ""

#: ../../../networking/snmp_counter.rst:779
msgid "Packets are dropped by PAWS in any status other than Syn-Sent."
msgstr ""

#: ../../../networking/snmp_counter.rst:782
msgid "TCP ACK skip"
msgstr ""

#: ../../../networking/snmp_counter.rst:783
msgid ""
"In some scenarios, kernel would avoid sending duplicate ACKs too frequently. "
"Please find more details in the tcp_invalid_ratelimit section of the `sysctl "
"document`_. When kernel decides to skip an ACK due to tcp_invalid_ratelimit, "
"kernel would update one of below counters to indicate the ACK is skipped in "
"which scenario. The ACK would only be skipped if the received packet is "
"either a SYN packet or it has no data."
msgstr ""

#: ../../../networking/snmp_counter.rst:793
#: ../../../networking/snmp_counter.rst:1644
msgid "TcpExtTCPACKSkippedSynRecv"
msgstr ""

#: ../../../networking/snmp_counter.rst:795
msgid ""
"The ACK is skipped in Syn-Recv status. The Syn-Recv status means the TCP "
"stack receives a SYN and replies SYN+ACK. Now the TCP stack is waiting for "
"an ACK. Generally, the TCP stack doesn't need to send ACK in the Syn-Recv "
"status. But in several scenarios, the TCP stack need to send an ACK. E.g., "
"the TCP stack receives the same SYN packet repeately, the received packet "
"does not pass the PAWS check, or the received packet sequence number is out "
"of window. In these scenarios, the TCP stack needs to send ACK. If the ACk "
"sending frequency is higher than tcp_invalid_ratelimit allows, the TCP stack "
"will skip sending ACK and increase TcpExtTCPACKSkippedSynRecv."
msgstr ""

#: ../../../networking/snmp_counter.rst:807
#: ../../../networking/snmp_counter.rst:1692
msgid "TcpExtTCPACKSkippedPAWS"
msgstr ""

#: ../../../networking/snmp_counter.rst:809
msgid ""
"The ACK is skipped due to PAWS (Protect Against Wrapped Sequence numbers) "
"check fails. If the PAWS check fails in Syn-Recv, Fin-Wait-2 or Time-Wait "
"statuses, the skipped ACK would be counted to TcpExtTCPACKSkippedSynRecv, "
"TcpExtTCPACKSkippedFinWait2 or TcpExtTCPACKSkippedTimeWait. In all other "
"statuses, the skipped ACK would be counted to TcpExtTCPACKSkippedPAWS."
msgstr ""

#: ../../../networking/snmp_counter.rst:816
#: ../../../networking/snmp_counter.rst:1729
msgid "TcpExtTCPACKSkippedSeq"
msgstr ""

#: ../../../networking/snmp_counter.rst:818
msgid ""
"The sequence number is out of window and the timestamp passes the PAWS check "
"and the TCP status is not Syn-Recv, Fin-Wait-2, and Time-Wait."
msgstr ""

#: ../../../networking/snmp_counter.rst:821
msgid "TcpExtTCPACKSkippedFinWait2"
msgstr ""

#: ../../../networking/snmp_counter.rst:823
msgid ""
"The ACK is skipped in Fin-Wait-2 status, the reason would be either PAWS "
"check fails or the received sequence number is out of window."
msgstr ""

#: ../../../networking/snmp_counter.rst:826
msgid "TcpExtTCPACKSkippedTimeWait"
msgstr ""

#: ../../../networking/snmp_counter.rst:828
msgid ""
"The ACK is skipped in Time-Wait status, the reason would be either PAWS "
"check failed or the received sequence number is out of window."
msgstr ""

#: ../../../networking/snmp_counter.rst:831
msgid "TcpExtTCPACKSkippedChallenge"
msgstr ""

#: ../../../networking/snmp_counter.rst:833
msgid ""
"The ACK is skipped if the ACK is a challenge ACK. The RFC 5961 defines 3 "
"kind of challenge ACK, please refer `RFC 5961 section 3.2`_, `RFC 5961 "
"section 4.2`_ and `RFC 5961 section 5.2`_. Besides these three scenarios, In "
"some TCP status, the linux TCP stack would also send challenge ACKs if the "
"ACK number is before the first unacknowledged number (more strict than `RFC "
"5961 section 5.2`_)."
msgstr ""

#: ../../../networking/snmp_counter.rst:845
msgid "TCP receive window"
msgstr ""

#: ../../../networking/snmp_counter.rst:846
msgid "TcpExtTCPWantZeroWindowAdv"
msgstr ""

#: ../../../networking/snmp_counter.rst:848
msgid ""
"Depending on current memory usage, the TCP stack tries to set receive window "
"to zero. But the receive window might still be a no-zero value. For example, "
"if the previous window size is 10, and the TCP stack receives 3 bytes, the "
"current window size would be 7 even if the window size calculated by the "
"memory usage is zero."
msgstr ""

#: ../../../networking/snmp_counter.rst:854
msgid "TcpExtTCPToZeroWindowAdv"
msgstr ""

#: ../../../networking/snmp_counter.rst:856
msgid "The TCP receive window is set to zero from a no-zero value."
msgstr ""

#: ../../../networking/snmp_counter.rst:858
msgid "TcpExtTCPFromZeroWindowAdv"
msgstr ""

#: ../../../networking/snmp_counter.rst:860
msgid "The TCP receive window is set to no-zero value from zero."
msgstr ""

#: ../../../networking/snmp_counter.rst:864
msgid "Delayed ACK"
msgstr ""

#: ../../../networking/snmp_counter.rst:865
msgid ""
"The TCP Delayed ACK is a technique which is used for reducing the packet "
"count in the network. For more details, please refer the `Delayed ACK wiki`_"
msgstr ""

#: ../../../networking/snmp_counter.rst:871
msgid "TcpExtDelayedACKs"
msgstr ""

#: ../../../networking/snmp_counter.rst:873
msgid ""
"A delayed ACK timer expires. The TCP stack will send a pure ACK packet and "
"exit the delayed ACK mode."
msgstr ""

#: ../../../networking/snmp_counter.rst:876
msgid "TcpExtDelayedACKLocked"
msgstr ""

#: ../../../networking/snmp_counter.rst:878
msgid ""
"A delayed ACK timer expires, but the TCP stack can't send an ACK immediately "
"due to the socket is locked by a userspace program. The TCP stack will send "
"a pure ACK later (after the userspace program unlock the socket). When the "
"TCP stack sends the pure ACK later, the TCP stack will also update "
"TcpExtDelayedACKs and exit the delayed ACK mode."
msgstr ""

#: ../../../networking/snmp_counter.rst:885
msgid "TcpExtDelayedACKLost"
msgstr ""

#: ../../../networking/snmp_counter.rst:887
msgid ""
"It will be updated when the TCP stack receives a packet which has been "
"ACKed. A Delayed ACK loss might cause this issue, but it would also be "
"triggered by other reasons, such as a packet is duplicated in the network."
msgstr ""

#: ../../../networking/snmp_counter.rst:893
msgid "Tail Loss Probe (TLP)"
msgstr ""

#: ../../../networking/snmp_counter.rst:894
msgid ""
"TLP is an algorithm which is used to detect TCP packet loss. For more "
"details, please refer the `TLP paper`_."
msgstr ""

#: ../../../networking/snmp_counter.rst:899
msgid "TcpExtTCPLossProbes"
msgstr ""

#: ../../../networking/snmp_counter.rst:901
msgid "A TLP probe packet is sent."
msgstr ""

#: ../../../networking/snmp_counter.rst:903
msgid "TcpExtTCPLossProbeRecovery"
msgstr ""

#: ../../../networking/snmp_counter.rst:905
msgid "A packet loss is detected and recovered by TLP."
msgstr ""

#: ../../../networking/snmp_counter.rst:908
msgid "TCP Fast Open description"
msgstr ""

#: ../../../networking/snmp_counter.rst:909
msgid ""
"TCP Fast Open is a technology which allows data transfer before the 3-way "
"handshake complete. Please refer the `TCP Fast Open wiki`_ for a general "
"description."
msgstr ""

#: ../../../networking/snmp_counter.rst:915
msgid "TcpExtTCPFastOpenActive"
msgstr ""

#: ../../../networking/snmp_counter.rst:917
msgid ""
"When the TCP stack receives an ACK packet in the SYN-SENT status, and the "
"ACK packet acknowledges the data in the SYN packet, the TCP stack understand "
"the TFO cookie is accepted by the other side, then it updates this counter."
msgstr ""

#: ../../../networking/snmp_counter.rst:922
msgid "TcpExtTCPFastOpenActiveFail"
msgstr ""

#: ../../../networking/snmp_counter.rst:924
msgid ""
"This counter indicates that the TCP stack initiated a TCP Fast Open, but it "
"failed. This counter would be updated in three scenarios: (1) the other side "
"doesn't acknowledge the data in the SYN packet. (2) The SYN packet which has "
"the TFO cookie is timeout at least once. (3) after the 3-way handshake, the "
"retransmission timeout happens net.ipv4.tcp_retries1 times, because some "
"middle-boxes may black-hole fast open after the handshake."
msgstr ""

#: ../../../networking/snmp_counter.rst:932
msgid "TcpExtTCPFastOpenPassive"
msgstr ""

#: ../../../networking/snmp_counter.rst:934
msgid ""
"This counter indicates how many times the TCP stack accepts the fast open "
"request."
msgstr ""

#: ../../../networking/snmp_counter.rst:937
msgid "TcpExtTCPFastOpenPassiveFail"
msgstr ""

#: ../../../networking/snmp_counter.rst:939
msgid ""
"This counter indicates how many times the TCP stack rejects the fast open "
"request. It is caused by either the TFO cookie is invalid or the TCP stack "
"finds an error during the socket creating process."
msgstr ""

#: ../../../networking/snmp_counter.rst:943
msgid "TcpExtTCPFastOpenListenOverflow"
msgstr ""

#: ../../../networking/snmp_counter.rst:945
msgid ""
"When the pending fast open request number is larger than fastopenq-"
">max_qlen, the TCP stack will reject the fast open request and update this "
"counter. When this counter is updated, the TCP stack won't update "
"TcpExtTCPFastOpenPassive or TcpExtTCPFastOpenPassiveFail. The fastopenq-"
">max_qlen is set by the TCP_FASTOPEN socket operation and it could not be "
"larger than net.core.somaxconn. For example:"
msgstr ""

#: ../../../networking/snmp_counter.rst:953
msgid "setsockopt(sfd, SOL_TCP, TCP_FASTOPEN, &qlen, sizeof(qlen));"
msgstr ""

#: ../../../networking/snmp_counter.rst:955
msgid "TcpExtTCPFastOpenCookieReqd"
msgstr ""

#: ../../../networking/snmp_counter.rst:957
msgid ""
"This counter indicates how many times a client wants to request a TFO cookie."
msgstr ""

#: ../../../networking/snmp_counter.rst:961
msgid "SYN cookies"
msgstr ""

#: ../../../networking/snmp_counter.rst:962
msgid ""
"SYN cookies are used to mitigate SYN flood, for details, please refer the "
"`SYN cookies wiki`_."
msgstr ""

#: ../../../networking/snmp_counter.rst:967
msgid "TcpExtSyncookiesSent"
msgstr ""

#: ../../../networking/snmp_counter.rst:969
msgid "It indicates how many SYN cookies are sent."
msgstr ""

#: ../../../networking/snmp_counter.rst:971
msgid "TcpExtSyncookiesRecv"
msgstr ""

#: ../../../networking/snmp_counter.rst:973
msgid "How many reply packets of the SYN cookies the TCP stack receives."
msgstr ""

#: ../../../networking/snmp_counter.rst:975
msgid "TcpExtSyncookiesFailed"
msgstr ""

#: ../../../networking/snmp_counter.rst:977
msgid ""
"The MSS decoded from the SYN cookie is invalid. When this counter is "
"updated, the received packet won't be treated as a SYN cookie and the "
"TcpExtSyncookiesRecv counter won't be updated."
msgstr ""

#: ../../../networking/snmp_counter.rst:982
msgid "Challenge ACK"
msgstr ""

#: ../../../networking/snmp_counter.rst:983
msgid ""
"For details of challenge ACK, please refer the explanation of "
"TcpExtTCPACKSkippedChallenge."
msgstr ""

#: ../../../networking/snmp_counter.rst:986
msgid "TcpExtTCPChallengeACK"
msgstr ""

#: ../../../networking/snmp_counter.rst:988
msgid "The number of challenge acks sent."
msgstr ""

#: ../../../networking/snmp_counter.rst:990
msgid "TcpExtTCPSYNChallenge"
msgstr ""

#: ../../../networking/snmp_counter.rst:992
msgid ""
"The number of challenge acks sent in response to SYN packets. After updates "
"this counter, the TCP stack might send a challenge ACK and update the "
"TcpExtTCPChallengeACK counter, or it might also skip to send the challenge "
"and update the TcpExtTCPACKSkippedChallenge."
msgstr ""

#: ../../../networking/snmp_counter.rst:998
msgid "prune"
msgstr ""

#: ../../../networking/snmp_counter.rst:999
msgid ""
"When a socket is under memory pressure, the TCP stack will try to reclaim "
"memory from the receiving queue and out of order queue. One of the "
"reclaiming method is 'collapse', which means allocate a big skb, copy the "
"contiguous skbs to the single big skb, and free these contiguous skbs."
msgstr ""

#: ../../../networking/snmp_counter.rst:1005
msgid "TcpExtPruneCalled"
msgstr ""

#: ../../../networking/snmp_counter.rst:1007
msgid ""
"The TCP stack tries to reclaim memory for a socket. After updates this "
"counter, the TCP stack will try to collapse the out of order queue and the "
"receiving queue. If the memory is still not enough, the TCP stack will try "
"to discard packets from the out of order queue (and update the "
"TcpExtOfoPruned counter)"
msgstr ""

#: ../../../networking/snmp_counter.rst:1013
msgid "TcpExtOfoPruned"
msgstr ""

#: ../../../networking/snmp_counter.rst:1015
msgid "The TCP stack tries to discard packet on the out of order queue."
msgstr ""

#: ../../../networking/snmp_counter.rst:1017
msgid "TcpExtRcvPruned"
msgstr ""

#: ../../../networking/snmp_counter.rst:1019
msgid ""
"After 'collapse' and discard packets from the out of order queue, if the "
"actually used memory is still larger than the max allowed memory, this "
"counter will be updated. It means the 'prune' fails."
msgstr ""

#: ../../../networking/snmp_counter.rst:1023
msgid "TcpExtTCPRcvCollapsed"
msgstr ""

#: ../../../networking/snmp_counter.rst:1025
msgid "This counter indicates how many skbs are freed during 'collapse'."
msgstr ""

#: ../../../networking/snmp_counter.rst:1028
msgid "examples"
msgstr ""

#: ../../../networking/snmp_counter.rst:1031
msgid "ping test"
msgstr ""

#: ../../../networking/snmp_counter.rst:1032
msgid "Run the ping command against the public dns server 8.8.8.8::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1042
msgid "The nstayt result::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1059
msgid ""
"The Linux server sent an ICMP Echo packet, so IpOutRequests, IcmpOutMsgs, "
"IcmpOutEchos and IcmpMsgOutType8 were increased 1. The server got ICMP Echo "
"Reply from 8.8.8.8, so IpInReceives, IcmpInMsgs, IcmpInEchoReps and "
"IcmpMsgInType0 were increased 1. The ICMP Echo Reply was passed to the ICMP "
"layer via IP layer, so IpInDelivers was increased 1. The default ping data "
"size is 48, so an ICMP Echo packet and its corresponding Echo Reply packet "
"are constructed by:"
msgstr ""

#: ../../../networking/snmp_counter.rst:1067
msgid "14 bytes MAC header"
msgstr ""

#: ../../../networking/snmp_counter.rst:1068
msgid "20 bytes IP header"
msgstr ""

#: ../../../networking/snmp_counter.rst:1069
msgid "16 bytes ICMP header"
msgstr ""

#: ../../../networking/snmp_counter.rst:1070
msgid "48 bytes data (default value of the ping command)"
msgstr ""

#: ../../../networking/snmp_counter.rst:1072
msgid "So the IpExtInOctets and IpExtOutOctets are 20+16+48=84."
msgstr ""

#: ../../../networking/snmp_counter.rst:1075
msgid "tcp 3-way handshake"
msgstr ""

#: ../../../networking/snmp_counter.rst:1076
msgid "On server side, we run::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1081
msgid "On client side, we run::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1086
msgid ""
"The server listened on tcp 9000 port, the client connected to it, they "
"completed the 3-way handshake."
msgstr ""

#: ../../../networking/snmp_counter.rst:1089
msgid "On server side, we can find below nstat output::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1097
msgid "On client side, we can find below nstat output::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1104
msgid ""
"When the server received the first SYN, it replied a SYN+ACK, and came into "
"SYN-RCVD state, so TcpPassiveOpens increased 1. The server received SYN, "
"sent SYN+ACK, received ACK, so server sent 1 packet, received 2 packets, "
"TcpInSegs increased 2, TcpOutSegs increased 1. The last ACK of the 3-way "
"handshake is a pure ACK without data, so TcpExtTCPPureAcks increased 1."
msgstr ""

#: ../../../networking/snmp_counter.rst:1111
msgid ""
"When the client sent SYN, the client came into the SYN-SENT state, so "
"TcpActiveOpens increased 1, the client sent SYN, received SYN+ACK, sent ACK, "
"so client sent 2 packets, received 1 packet, TcpInSegs increased 1, "
"TcpOutSegs increased 2."
msgstr ""

#: ../../../networking/snmp_counter.rst:1117
msgid "TCP normal traffic"
msgstr ""

#: ../../../networking/snmp_counter.rst:1118
msgid "Run nc on server::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1123
msgid "Run nc on client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1128
msgid "Input a string in the nc client ('hello' in our example)::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1134
msgid "The client side nstat output::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1149
msgid "The server side nstat output::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1162
msgid "Input a string in nc client side again ('world' in our example)::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1169
msgid "Client side nstat output::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1185
msgid "Server side nstat output::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1199
msgid ""
"Compare the first client-side nstat and the second client-side nstat, we "
"could find one difference: the first one had a 'TcpExtTCPPureAcks', but the "
"second one had a 'TcpExtTCPHPAcks'. The first server-side nstat and the "
"second server-side nstat had a difference too: the second server-side nstat "
"had a TcpExtTCPHPHits, but the first server-side nstat didn't have it. The "
"network traffic patterns were exactly the same: the client sent a packet to "
"the server, the server replied an ACK. But kernel handled them in different "
"ways. When the TCP window scale option is not used, kernel will try to "
"enable fast path immediately when the connection comes into the established "
"state, but if the TCP window scale option is used, kernel will disable the "
"fast path at first, and try to enable it after kernel receives packets. We "
"could use the 'ss' command to verify whether the window scale option is "
"used. e.g. run below command on either server or client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1220
msgid ""
"The 'wscale:7,7' means both server and client set the window scale option to "
"7. Now we could explain the nstat output in our test:"
msgstr ""

#: ../../../networking/snmp_counter.rst:1223
msgid ""
"In the first nstat output of client side, the client sent a packet, server "
"reply an ACK, when kernel handled this ACK, the fast path was not enabled, "
"so the ACK was counted into 'TcpExtTCPPureAcks'."
msgstr ""

#: ../../../networking/snmp_counter.rst:1227
msgid ""
"In the second nstat output of client side, the client sent a packet again, "
"and received another ACK from the server, in this time, the fast path is "
"enabled, and the ACK was qualified for fast path, so it was handled by the "
"fast path, so this ACK was counted into TcpExtTCPHPAcks."
msgstr ""

#: ../../../networking/snmp_counter.rst:1232
msgid ""
"In the first nstat output of server side, fast path was not enabled, so "
"there was no 'TcpExtTCPHPHits'."
msgstr ""

#: ../../../networking/snmp_counter.rst:1235
msgid ""
"In the second nstat output of server side, the fast path was enabled, and "
"the packet received from client qualified for fast path, so it was counted "
"into 'TcpExtTCPHPHits'."
msgstr ""

#: ../../../networking/snmp_counter.rst:1241
msgid "On the server side, we run below python script::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1255
msgid ""
"This python script listen on 9000 port, but doesn't read anything from the "
"connection."
msgstr ""

#: ../../../networking/snmp_counter.rst:1258
msgid "On the client side, we send the string \"hello\" by nc::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1262
msgid ""
"Then, we come back to the server side, the server has received the \"hello\" "
"packet, and the TCP layer has acked this packet, but the application didn't "
"read it yet. We type Ctrl-C to terminate the server script. Then we could "
"find TcpExtTCPAbortOnClose increased 1 on the server side::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1270
msgid ""
"If we run tcpdump on the server side, we could find the server sent a RST "
"after we type Ctrl-C."
msgstr ""

#: ../../../networking/snmp_counter.rst:1274
msgid "TcpExtTCPAbortOnMemory and TcpExtTCPAbortOnTimeout"
msgstr ""

#: ../../../networking/snmp_counter.rst:1275
msgid ""
"Below is an example which let the orphan socket count be higher than net."
"ipv4.tcp_max_orphans. Change tcp_max_orphans to a smaller value on client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1281
msgid "Client code (create 64 connection to server)::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1303
msgid "Server code (accept 64 connection from client)::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1321
msgid "Run the python scripts on server and client."
msgstr ""

#: ../../../networking/snmp_counter.rst:1323
msgid "On server::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1327
msgid "On client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1331
msgid "Run iptables on server::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1335
msgid "Type Ctrl-C on client, stop client_orphan.py."
msgstr ""

#: ../../../networking/snmp_counter.rst:1337
msgid "Check TcpExtTCPAbortOnMemory on client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1342
msgid "Check orphaned socket count on client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1356
msgid ""
"The explanation of the test: after run server_orphan.py and client_orphan."
"py, we set up 64 connections between server and client. Run the iptables "
"command, the server will drop all packets from the client, type Ctrl-C on "
"client_orphan.py, the system of the client would try to close these "
"connections, and before they are closed gracefully, these connections became "
"orphan sockets. As the iptables of the server blocked packets from the "
"client, the server won't receive fin from the client, so all connection on "
"clients would be stuck on FIN_WAIT_1 stage, so they will keep as orphan "
"sockets until timeout. We have echo 10 to /proc/sys/net/ipv4/"
"tcp_max_orphans, so the client system would only keep 10 orphan sockets, for "
"all other orphan sockets, the client system sent RST for them and delete "
"them. We have 64 connections, so the 'ss -s' command shows the system has 10 "
"orphan sockets, and the value of TcpExtTCPAbortOnMemory was 54."
msgstr ""

#: ../../../networking/snmp_counter.rst:1371
msgid ""
"An additional explanation about orphan socket count: You could find the "
"exactly orphan socket count by the 'ss -s' command, but when kernel decide "
"whither increases TcpExtTCPAbortOnMemory and sends RST, kernel doesn't "
"always check the exactly orphan socket count. For increasing performance, "
"kernel checks an approximate count firstly, if the approximate count is more "
"than tcp_max_orphans, kernel checks the exact count again. So if the "
"approximate count is less than tcp_max_orphans, but exactly count is more "
"than tcp_max_orphans, you would find TcpExtTCPAbortOnMemory is not increased "
"at all. If tcp_max_orphans is large enough, it won't occur, but if you "
"decrease tcp_max_orphans to a small value like our test, you might find this "
"issue. So in our test, the client set up 64 connections although the "
"tcp_max_orphans is 10. If the client only set up 11 connections, we can't "
"find the change of TcpExtTCPAbortOnMemory."
msgstr ""

#: ../../../networking/snmp_counter.rst:1386
msgid ""
"Continue the previous test, we wait for several minutes. Because of the "
"iptables on the server blocked the traffic, the server wouldn't receive fin, "
"and all the client's orphan sockets would timeout on the FIN_WAIT_1 state "
"finally. So we wait for a few minutes, we could find 10 timeout on the "
"client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1397
msgid "The server side code::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1412
msgid "The client side code::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1427
msgid "Run server_linger.py on server::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1431
msgid "Run client_linger.py on client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1435
msgid "After run client_linger.py, check the output of nstat::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1442
msgid ""
"On the server, we run a program which listen on TCP port 9000, but doesn't "
"read any data::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1455
msgid "Save the above code as server_coalesce.py, and run::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1459
msgid "On the client, save below code as client_coalesce.py::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1467
msgid "Run::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1471
msgid "We use '-i' to come into the interactive mode, then a packet::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1476
msgid "Send a packet again::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1481
msgid "On the server, run nstat::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1495
msgid ""
"The client sent two packets, server didn't read any data. When the second "
"packet arrived at server, the first packet was still in the receiving queue. "
"So the TCP layer merged the two packets, and we could find the "
"TcpExtTCPRcvCoalesce increased 1."
msgstr ""

#: ../../../networking/snmp_counter.rst:1502
msgid "On server, run the nc command, listen on port 9000::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1507
msgid "On client, run 3 nc commands in different terminals::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1512
msgid ""
"The nc command only accepts 1 connection, and the accept queue length is 1. "
"On current linux implementation, set queue length to n means the actual "
"queue length is n+1. Now we create 3 connections, 1 is accepted by nc, 2 in "
"accepted queue, so the accept queue is full."
msgstr ""

#: ../../../networking/snmp_counter.rst:1517
msgid "Before running the 4th nc, we clean the nstat history on the server::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1521
msgid "Run the 4th nc on the client::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1525
msgid ""
"If the nc server is running on kernel 4.10 or higher version, you won't see "
"the \"Connection to ... succeeded!\" string, because kernel will drop the "
"SYN if the accept queue is full. If the nc client is running on an old "
"kernel, you would see that the connection is succeeded, because kernel would "
"complete the 3 way handshake and keep the socket on half open queue. I did "
"the test on kernel 4.15. Below is the nstat on the server::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1543
msgid ""
"Both TcpExtListenOverflows and TcpExtListenDrops were 4. If the time between "
"the 4th nc and the nstat was longer, the value of TcpExtListenOverflows and "
"TcpExtListenDrops would be larger, because the SYN of the 4th nc was "
"dropped, the client was retrying."
msgstr ""

#: ../../../networking/snmp_counter.rst:1549
msgid "IpInAddrErrors, IpExtInNoRoutes and IpOutNoRoutes"
msgstr ""

#: ../../../networking/snmp_counter.rst:1550
msgid ""
"server A IP address: 192.168.122.250 server B IP address: 192.168.122.251 "
"Prepare on server A, add a route to server B::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1556
msgid "Prepare on server B, disable send_redirects for all interfaces::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1563
msgid ""
"We want to let sever A send a packet to 8.8.8.8, and route the packet to "
"server B. When server B receives such packet, it might send a ICMP Redirect "
"message to server A, set send_redirects to 0 will disable this behavior."
msgstr ""

#: ../../../networking/snmp_counter.rst:1568
msgid "First, generate InAddrErrors. On server B, we disable IP forwarding::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1572
msgid "On server A, we send packets to 8.8.8.8::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1576
msgid "On server B, we check the output of nstat::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1585
msgid ""
"As we have let server A route 8.8.8.8 to server B, and we disabled IP "
"forwarding on server B, Server A sent packets to server B, then server B "
"dropped packets and increased IpInAddrErrors. As the nc command would re-"
"send the SYN packet if it didn't receive a SYN+ACK, we could find multiple "
"IpInAddrErrors."
msgstr ""

#: ../../../networking/snmp_counter.rst:1591
msgid ""
"Second, generate IpExtInNoRoutes. On server B, we enable IP forwarding::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1596
msgid "Check the route table of server B and remove the default route::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1603
msgid "On server A, we contact 8.8.8.8 again::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1608
msgid "On server B, run nstat::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1622
msgid ""
"We enabled IP forwarding on server B, when server B received a packet which "
"destination IP address is 8.8.8.8, server B will try to forward this packet. "
"We have deleted the default route, there was no route for 8.8.8.8, so server "
"B increase IpExtInNoRoutes and sent the \"ICMP Destination Unreachable\" "
"message to server A."
msgstr ""

#: ../../../networking/snmp_counter.rst:1628
msgid "Third, generate IpOutNoRoutes. Run ping command on server B::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1633
msgid "Run nstat on server B::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1639
msgid ""
"We have deleted the default route on server B. Server B couldn't find a "
"route for the 8.8.8.8 IP address, so server B increased IpOutNoRoutes."
msgstr ""

#: ../../../networking/snmp_counter.rst:1645
msgid ""
"In this test, we send 3 same SYN packets from client to server. The first "
"SYN will let server create a socket, set it to Syn-Recv status, and reply a "
"SYN/ACK. The second SYN will let server reply the SYN/ACK again, and record "
"the reply time (the duplicate ACK reply time). The third SYN will let server "
"check the previous duplicate ACK reply time, and decide to skip the "
"duplicate ACK, then increase the TcpExtTCPACKSkippedSynRecv counter."
msgstr ""

#: ../../../networking/snmp_counter.rst:1653
msgid "Run tcpdump to capture a SYN packet::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1658
msgid "Open another terminal, run nc command::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1662
msgid ""
"As the nstat-b didn't listen on port 9000, it should reply a RST, and the nc "
"command exited immediately. It was enough for the tcpdump command to capture "
"a SYN packet. A linux server might use hardware offload for the TCP "
"checksum, so the checksum in the /tmp/syn.pcap might be not correct. We call "
"tcprewrite to fix it::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1670
msgid "On nstat-b, we run nc to listen on port 9000::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1675
msgid ""
"On nstat-a, we blocked the packet from port 9000, or nstat-a would send RST "
"to nstat-b::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1680
msgid "Send 3 SYN repeatedly to nstat-b::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1684
msgid "Check snmp counter on nstat-b::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1689
msgid "As we expected, TcpExtTCPACKSkippedSynRecv is 1."
msgstr ""

#: ../../../networking/snmp_counter.rst:1693
msgid "To trigger PAWS, we could send an old SYN."
msgstr ""

#: ../../../networking/snmp_counter.rst:1695
msgid "On nstat-b, let nc listen on port 9000::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1700
msgid "On nstat-a, run tcpdump to capture a SYN::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1705
msgid "On nstat-a, run nc as a client to connect nstat-b::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1710
msgid ""
"Now the tcpdump has captured the SYN and exit. We should fix the checksum::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1715
msgid "Send the SYN packet twice::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1719
msgid "On nstat-b, check the snmp counter::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1724
msgid ""
"We sent two SYN via tcpreplay, both of them would let PAWS check failed, the "
"nstat-b replied an ACK for the first SYN, skipped the ACK for the second "
"SYN, and updated TcpExtTCPACKSkippedPAWS."
msgstr ""

#: ../../../networking/snmp_counter.rst:1730
msgid ""
"To trigger TcpExtTCPACKSkippedSeq, we send packets which have valid "
"timestamp (to pass PAWS check) but the sequence number is out of window. The "
"linux TCP stack would avoid to skip if the packet has data, so we need a "
"pure ACK packet. To generate such a packet, we could create two sockets: one "
"on port 9000, another on port 9001. Then we capture an ACK on port 9001, "
"change the source/destination port numbers to match the port 9000 socket. "
"Then we could trigger TcpExtTCPACKSkippedSeq via this packet."
msgstr ""

#: ../../../networking/snmp_counter.rst:1739
msgid ""
"On nstat-b, open two terminals, run two nc commands to listen on both port "
"9000 and port 9001::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1748
msgid "On nstat-a, run two nc clients::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1756
msgid "On nstat-a, run tcpdump to capture an ACK::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1761
msgid ""
"On nstat-b, send a packet via the port 9001 socket. E.g. we sent a string "
"'foo' in our example::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1769
msgid ""
"On nstat-a, the tcpdump should have captured the ACK. We should check the "
"source port numbers of the two nc clients::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1777
msgid ""
"Run tcprewrite, change port 9001 to port 9000, change port 42132 to port "
"50208::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1782
msgid "Now the /tmp/seq.pcap is the packet we need. Send it to nstat-b::"
msgstr ""

#: ../../../networking/snmp_counter.rst:1786
msgid "Check TcpExtTCPACKSkippedSeq on nstat-b::"
msgstr ""
