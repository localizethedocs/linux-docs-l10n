# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/xfrm_device.rst:6
msgid "XFRM device - offloading the IPsec computations"
msgstr ""

#: ../../../networking/xfrm_device.rst:8
msgid ""
"Shannon Nelson <shannon.nelson@oracle.com> Leon Romanovsky <leonro@nvidia."
"com>"
msgstr ""

#: ../../../networking/xfrm_device.rst:13
msgid "Overview"
msgstr ""

#: ../../../networking/xfrm_device.rst:15
msgid ""
"IPsec is a useful feature for securing network traffic, but the "
"computational cost is high: a 10Gbps link can easily be brought down to "
"under 1Gbps, depending on the traffic and link configuration. Luckily, there "
"are NICs that offer a hardware based IPsec offload which can radically "
"increase throughput and decrease CPU utilization.  The XFRM Device interface "
"allows NIC drivers to offer to the stack access to the hardware offload."
msgstr ""

#: ../../../networking/xfrm_device.rst:23
msgid ""
"Right now, there are two types of hardware offload that kernel supports."
msgstr ""

#: ../../../networking/xfrm_device.rst:24
msgid ""
"IPsec crypto offload: * NIC performs encrypt/decrypt * Kernel does "
"everything else"
msgstr ""

#: ../../../networking/xfrm_device.rst:27
msgid ""
"IPsec packet offload: * NIC performs encrypt/decrypt * NIC does "
"encapsulation * Kernel and NIC have SA and policy in-sync * NIC handles the "
"SA and policies states * The Kernel talks to the keymanager"
msgstr ""

#: ../../../networking/xfrm_device.rst:34
msgid ""
"Userland access to the offload is typically through a system such as "
"libreswan or KAME/raccoon, but the iproute2 'ip xfrm' command set can be "
"handy when experimenting.  An example command might look something like this "
"for crypto offload:"
msgstr ""

#: ../../../networking/xfrm_device.rst:39
#: ../../../networking/xfrm_device.rst:47
msgid ""
"ip x s add proto esp dst 14.0.0.70 src 14.0.0.52 spi 0x07 mode transport \\"
msgstr ""

#: ../../../networking/xfrm_device.rst:40
msgid ""
"reqid 0x07 replay-window 32 \\ aead 'rfc4106(gcm(aes))' "
"0x44434241343332312423222114131211f4f3f2f1 128 \\ sel src 14.0.0.52/24 dst "
"14.0.0.70/24 proto tcp \\ offload dev eth4 dir in"
msgstr ""

#: ../../../networking/xfrm_device.rst:45
msgid "and for packet offload"
msgstr ""

#: ../../../networking/xfrm_device.rst:48
msgid ""
"reqid 0x07 replay-window 32 \\ aead 'rfc4106(gcm(aes))' "
"0x44434241343332312423222114131211f4f3f2f1 128 \\ sel src 14.0.0.52/24 dst "
"14.0.0.70/24 proto tcp \\ offload packet dev eth4 dir in"
msgstr ""

#: ../../../networking/xfrm_device.rst:53
msgid ""
"ip x p add src 14.0.0.70 dst 14.0.0.52 offload packet dev eth4 dir in tmpl "
"src 14.0.0.70 dst 14.0.0.52 proto esp reqid 10000 mode transport"
msgstr ""

#: ../../../networking/xfrm_device.rst:56
msgid ""
"Yes, that's ugly, but that's what shell scripts and/or libreswan are for."
msgstr ""

#: ../../../networking/xfrm_device.rst:61
msgid "Callbacks to implement"
msgstr ""

#: ../../../networking/xfrm_device.rst:86
msgid ""
"The NIC driver offering ipsec offload will need to implement callbacks "
"relevant to supported offload to make the offload available to the network "
"stack's XFRM subsystem. Additionally, the feature bits NETIF_F_HW_ESP and "
"NETIF_F_HW_ESP_TX_CSUM will signal the availability of the offload."
msgstr ""

#: ../../../networking/xfrm_device.rst:94
msgid "Flow"
msgstr ""

#: ../../../networking/xfrm_device.rst:96
msgid ""
"At probe time and before the call to register_netdev(), the driver should "
"set up local data structures and XFRM callbacks, and set the feature bits. "
"The XFRM code's listener will finish the setup on NETDEV_REGISTER."
msgstr ""

#: ../../../networking/xfrm_device.rst:106
msgid ""
"When new SAs are set up with a request for \"offload\" feature, the driver's "
"xdo_dev_state_add() will be given the new SA to be offloaded and an "
"indication of whether it is for Rx or Tx.  The driver should"
msgstr ""

#: ../../../networking/xfrm_device.rst:110
msgid "verify the algorithm is supported for offloads"
msgstr ""

#: ../../../networking/xfrm_device.rst:111
msgid "store the SA information (key, salt, target-ip, protocol, etc)"
msgstr ""

#: ../../../networking/xfrm_device.rst:112
msgid "enable the HW offload of the SA"
msgstr ""

#: ../../../networking/xfrm_device.rst:113
msgid "return status value:"
msgstr ""

#: ../../../networking/xfrm_device.rst:116
msgid "0"
msgstr ""

#: ../../../networking/xfrm_device.rst:116
msgid "success"
msgstr ""

#: ../../../networking/xfrm_device.rst:117
msgid "-EOPNETSUPP"
msgstr ""

#: ../../../networking/xfrm_device.rst:117
msgid ""
"offload not supported, try SW IPsec, not applicable for packet offload mode"
msgstr ""

#: ../../../networking/xfrm_device.rst:119
msgid "other"
msgstr ""

#: ../../../networking/xfrm_device.rst:119
msgid "fail the request"
msgstr ""

#: ../../../networking/xfrm_device.rst:122
msgid ""
"The driver can also set an offload_handle in the SA, an opaque void pointer "
"that can be used to convey context into the fast-path offload requests::"
msgstr ""

#: ../../../networking/xfrm_device.rst:128
msgid ""
"When the network stack is preparing an IPsec packet for an SA that has been "
"setup for offload, it first calls into xdo_dev_offload_ok() with the skb and "
"the intended offload state to ask the driver if the offload will "
"serviceable.  This can check the packet information to be sure the offload "
"can be supported (e.g. IPv4 or IPv6, no IPv4 options, etc) and return true "
"or false to signify its support. In case driver doesn't implement this "
"callback, the stack provides reasonable defaults."
msgstr ""

#: ../../../networking/xfrm_device.rst:136
msgid ""
"Crypto offload mode: When ready to send, the driver needs to inspect the Tx "
"packet for the offload information, including the opaque context, and set up "
"the packet send accordingly::"
msgstr ""

#: ../../../networking/xfrm_device.rst:145
msgid ""
"The stack has already inserted the appropriate IPsec headers in the packet "
"data, the offload just needs to do the encryption and fix up the header "
"values."
msgstr ""

#: ../../../networking/xfrm_device.rst:150
msgid ""
"When a packet is received and the HW has indicated that it offloaded a "
"decryption, the driver needs to add a reference to the decoded SA into the "
"packet's skb.  At this point the data should be decrypted but the IPsec "
"headers are still in the packet data; they are removed later up the stack in "
"xfrm_input()."
msgstr ""

#: ../../../networking/xfrm_device.rst:156
msgid "find and hold the SA that was used to the Rx skb::"
msgstr ""

#: ../../../networking/xfrm_device.rst:162
msgid "store the state information into the skb::"
msgstr ""

#: ../../../networking/xfrm_device.rst:169
msgid "indicate the success and/or error status of the offload::"
msgstr ""

#: ../../../networking/xfrm_device.rst:175
msgid "hand the packet to napi_gro_receive() as usual"
msgstr ""

#: ../../../networking/xfrm_device.rst:177
msgid ""
"In ESN mode, xdo_dev_state_advance_esn() is called from "
"xfrm_replay_advance_esn() for RX, and xfrm_replay_overflow_offload_esn for "
"TX. Driver will check packet seq number and update HW ESN state machine if "
"needed."
msgstr ""

#: ../../../networking/xfrm_device.rst:181
msgid ""
"Packet offload mode: HW adds and deletes XFRM headers. So in RX path, XFRM "
"stack is bypassed if HW reported success. In TX path, the packet lefts "
"kernel without extra header and not encrypted, the HW is responsible to "
"perform it."
msgstr ""

#: ../../../networking/xfrm_device.rst:186
msgid ""
"When the SA is removed by the user, the driver's xdo_dev_state_delete() and "
"xdo_dev_policy_delete() are asked to disable the offload.  Later, "
"xdo_dev_state_free() and xdo_dev_policy_free() are called from a garbage "
"collection routine after all reference counts to the state and policy have "
"been removed and any remaining resources can be cleared for the offload "
"state.  How these are used by the driver will depend on specific hardware "
"needs."
msgstr ""

#: ../../../networking/xfrm_device.rst:194
msgid ""
"As a netdev is set to DOWN the XFRM stack's netdev listener will call "
"xdo_dev_state_delete(), xdo_dev_policy_delete(), xdo_dev_state_free() and "
"xdo_dev_policy_free() on any remaining offloaded states."
msgstr ""

#: ../../../networking/xfrm_device.rst:198
msgid ""
"Outcome of HW handling packets, the XFRM core can't count hard, soft limits. "
"The HW/driver are responsible to perform it and provide accurate data when "
"xdo_dev_state_update_stats() is called. In case of one of these limits "
"occuried, the driver needs to call to xfrm_state_check_expire() to make sure "
"that XFRM performs rekeying sequence."
msgstr ""
