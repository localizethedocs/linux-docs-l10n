# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/checksum-offloads.rst:5
msgid "Checksum Offloads"
msgstr ""

#: ../../../networking/checksum-offloads.rst:9
msgid "Introduction"
msgstr ""

#: ../../../networking/checksum-offloads.rst:11
msgid ""
"This document describes a set of techniques in the Linux networking stack to "
"take advantage of checksum offload capabilities of various NICs."
msgstr ""

#: ../../../networking/checksum-offloads.rst:14
msgid "The following technologies are described:"
msgstr ""

#: ../../../networking/checksum-offloads.rst:16
#: ../../../networking/checksum-offloads.rst:27
msgid "TX Checksum Offload"
msgstr ""

#: ../../../networking/checksum-offloads.rst:17
#: ../../../networking/checksum-offloads.rst:82
msgid "LCO: Local Checksum Offload"
msgstr ""

#: ../../../networking/checksum-offloads.rst:18
#: ../../../networking/checksum-offloads.rst:128
msgid "RCO: Remote Checksum Offload"
msgstr ""

#: ../../../networking/checksum-offloads.rst:20
msgid "Things that should be documented here but aren't yet:"
msgstr ""

#: ../../../networking/checksum-offloads.rst:22
msgid "RX Checksum Offload"
msgstr ""

#: ../../../networking/checksum-offloads.rst:23
msgid "CHECKSUM_UNNECESSARY conversion"
msgstr ""

#: ../../../networking/checksum-offloads.rst:29
msgid ""
"The interface for offloading a transmit checksum to a device is explained in "
"detail in comments near the top of include/linux/skbuff.h."
msgstr ""

#: ../../../networking/checksum-offloads.rst:32
msgid ""
"In brief, it allows to request the device fill in a single ones-complement "
"checksum defined by the sk_buff fields skb->csum_start and skb->csum_offset. "
"The device should compute the 16-bit ones-complement checksum (i.e. the 'IP-"
"style' checksum) from csum_start to the end of the packet, and fill in the "
"result at (csum_start + csum_offset)."
msgstr ""

#: ../../../networking/checksum-offloads.rst:38
msgid ""
"Because csum_offset cannot be negative, this ensures that the previous value "
"of the checksum field is included in the checksum computation, thus it can "
"be used to supply any needed corrections to the checksum (such as the sum of "
"the pseudo-header for UDP or TCP)."
msgstr ""

#: ../../../networking/checksum-offloads.rst:43
msgid ""
"This interface only allows a single checksum to be offloaded.  Where "
"encapsulation is used, the packet may have multiple checksum fields in "
"different header layers, and the rest will have to be handled by another "
"mechanism such as LCO or RCO."
msgstr ""

#: ../../../networking/checksum-offloads.rst:48
msgid ""
"CRC32c can also be offloaded using this interface, by means of filling skb-"
">csum_start and skb->csum_offset as described above, and setting skb-"
">csum_not_inet: see skbuff.h comment (section 'D') for more details."
msgstr ""

#: ../../../networking/checksum-offloads.rst:52
msgid ""
"No offloading of the IP header checksum is performed; it is always done in "
"software.  This is OK because when we build the IP header, we obviously have "
"it in cache, so summing it isn't expensive.  It's also rather short."
msgstr ""

#: ../../../networking/checksum-offloads.rst:56
msgid ""
"The requirements for GSO are more complicated, because when segmenting an "
"encapsulated packet both the inner and outer checksums may need to be edited "
"or recomputed for each resulting segment.  See the skbuff.h comment (section "
"'E') for more details."
msgstr ""

#: ../../../networking/checksum-offloads.rst:61
msgid ""
"A driver declares its offload capabilities in netdev->hw_features; see "
"Documentation/networking/netdev-features.rst for more.  Note that a device "
"which only advertises NETIF_F_IP[V6]_CSUM must still obey the csum_start and "
"csum_offset given in the SKB; if it tries to deduce these itself in hardware "
"(as some NICs do) the driver should check that the values in the SKB match "
"those which the hardware will deduce, and if not, fall back to checksumming "
"in software instead (with skb_csum_hwoffload_help() or one of the "
"skb_checksum_help() / skb_crc32c_csum_help functions, as mentioned in "
"include/linux/skbuff.h)."
msgstr ""

#: ../../../networking/checksum-offloads.rst:71
msgid ""
"The stack should, for the most part, assume that checksum offload is "
"supported by the underlying device.  The only place that should check is "
"validate_xmit_skb(), and the functions it calls directly or indirectly.  "
"That function compares the offload features requested by the SKB (which may "
"include other offloads besides TX Checksum Offload) and, if they are not "
"supported or enabled on the device (determined by netdev->features), "
"performs the corresponding offload in software.  In the case of TX Checksum "
"Offload, that means calling skb_csum_hwoffload_help(skb, features)."
msgstr ""

#: ../../../networking/checksum-offloads.rst:84
msgid ""
"LCO is a technique for efficiently computing the outer checksum of an "
"encapsulated datagram when the inner checksum is due to be offloaded."
msgstr ""

#: ../../../networking/checksum-offloads.rst:87
msgid ""
"The ones-complement sum of a correctly checksummed TCP or UDP packet is "
"equal to the complement of the sum of the pseudo header, because everything "
"else gets 'cancelled out' by the checksum field.  This is because the sum "
"was complemented before being written to the checksum field."
msgstr ""

#: ../../../networking/checksum-offloads.rst:92
msgid ""
"More generally, this holds in any case where the 'IP-style' ones complement "
"checksum is used, and thus any checksum that TX Checksum Offload supports."
msgstr ""

#: ../../../networking/checksum-offloads.rst:95
msgid ""
"That is, if we have set up TX Checksum Offload with a start/offset pair, we "
"know that after the device has filled in that checksum, the ones complement "
"sum from csum_start to the end of the packet will be equal to the complement "
"of whatever value we put in the checksum field beforehand.  This allows us "
"to compute the outer checksum without looking at the payload: we simply stop "
"summing when we get to csum_start, then add the complement of the 16-bit "
"word at (csum_start + csum_offset)."
msgstr ""

#: ../../../networking/checksum-offloads.rst:103
msgid ""
"Then, when the true inner checksum is filled in (either by hardware or by "
"skb_checksum_help()), the outer checksum will become correct by virtue of "
"the arithmetic."
msgstr ""

#: ../../../networking/checksum-offloads.rst:107
msgid ""
"LCO is performed by the stack when constructing an outer UDP header for an "
"encapsulation such as VXLAN or GENEVE, in udp_set_csum().  Similarly for the "
"IPv6 equivalents, in udp6_set_csum()."
msgstr ""

#: ../../../networking/checksum-offloads.rst:111
msgid ""
"It is also performed when constructing an IPv4 GRE header, in net/ipv4/"
"ip_gre.c:build_header().  It is *not* currently performed when constructing "
"an IPv6 GRE header; the GRE checksum is computed over the whole packet in "
"net/ipv6/ip6_gre.c:ip6gre_xmit2(), but it should be possible to use LCO here "
"as IPv6 GRE still uses an IP-style checksum."
msgstr ""

#: ../../../networking/checksum-offloads.rst:117
msgid ""
"All of the LCO implementations use a helper function lco_csum(), in include/"
"linux/skbuff.h."
msgstr ""

#: ../../../networking/checksum-offloads.rst:120
msgid ""
"LCO can safely be used for nested encapsulations; in this case, the outer "
"encapsulation layer will sum over both its own header and the 'middle' "
"header. This does mean that the 'middle' header will get summed multiple "
"times, but there doesn't seem to be a way to avoid that without incurring "
"bigger costs (e.g. in SKB bloat)."
msgstr ""

#: ../../../networking/checksum-offloads.rst:130
msgid ""
"RCO is a technique for eliding the inner checksum of an encapsulated "
"datagram, allowing the outer checksum to be offloaded.  It does, however, "
"involve a change to the encapsulation protocols, which the receiver must "
"also support. For this reason, it is disabled by default."
msgstr ""

#: ../../../networking/checksum-offloads.rst:135
msgid "RCO is detailed in the following Internet-Drafts:"
msgstr ""

#: ../../../networking/checksum-offloads.rst:137
msgid "https://tools.ietf.org/html/draft-herbert-remotecsumoffload-00"
msgstr ""

#: ../../../networking/checksum-offloads.rst:138
msgid "https://tools.ietf.org/html/draft-herbert-vxlan-rco-00"
msgstr ""

#: ../../../networking/checksum-offloads.rst:140
msgid ""
"In Linux, RCO is implemented individually in each encapsulation protocol, "
"and most tunnel types have flags controlling its use.  For instance, VXLAN "
"has the flag VXLAN_F_REMCSUM_TX (per struct vxlan_rdst) to indicate that RCO "
"should be used when transmitting to a given remote destination."
msgstr ""
