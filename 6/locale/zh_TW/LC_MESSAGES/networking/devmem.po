# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/devmem.rst:5
msgid "Device Memory TCP"
msgstr ""

#: ../../../networking/devmem.rst:9
msgid "Intro"
msgstr ""

#: ../../../networking/devmem.rst:11
msgid ""
"Device memory TCP (devmem TCP) enables receiving data directly into device "
"memory (dmabuf). The feature is currently implemented for TCP sockets."
msgstr ""

#: ../../../networking/devmem.rst:16
msgid "Opportunity"
msgstr ""

#: ../../../networking/devmem.rst:18
msgid ""
"A large number of data transfers have device memory as the source and/or "
"destination. Accelerators drastically increased the prevalence of such "
"transfers.  Some examples include:"
msgstr ""

#: ../../../networking/devmem.rst:22
msgid ""
"Distributed training, where ML accelerators, such as GPUs on different "
"hosts, exchange data."
msgstr ""

#: ../../../networking/devmem.rst:25
msgid ""
"Distributed raw block storage applications transfer large amounts of data "
"with remote SSDs. Much of this data does not require host processing."
msgstr ""

#: ../../../networking/devmem.rst:28
msgid ""
"Typically the Device-to-Device data transfers in the network are implemented "
"as the following low-level operations: Device-to-Host copy, Host-to-Host "
"network transfer, and Host-to-Device copy."
msgstr ""

#: ../../../networking/devmem.rst:32
msgid ""
"The flow involving host copies is suboptimal, especially for bulk data "
"transfers, and can put significant strains on system resources such as host "
"memory bandwidth and PCIe bandwidth."
msgstr ""

#: ../../../networking/devmem.rst:36
msgid ""
"Devmem TCP optimizes this use case by implementing socket APIs that enable "
"the user to receive incoming network packets directly into device memory."
msgstr ""

#: ../../../networking/devmem.rst:39
msgid "Packet payloads go directly from the NIC to device memory."
msgstr ""

#: ../../../networking/devmem.rst:41
msgid ""
"Packet headers go to host memory and are processed by the TCP/IP stack "
"normally. The NIC must support header split to achieve this."
msgstr ""

#: ../../../networking/devmem.rst:44
msgid "Advantages:"
msgstr ""

#: ../../../networking/devmem.rst:46
msgid ""
"Alleviate host memory bandwidth pressure, compared to existing network-"
"transfer + device-copy semantics."
msgstr ""

#: ../../../networking/devmem.rst:49
msgid ""
"Alleviate PCIe bandwidth pressure, by limiting data transfer to the lowest "
"level of the PCIe tree, compared to the traditional path which sends data "
"through the root complex."
msgstr ""

#: ../../../networking/devmem.rst:55
msgid "More Info"
msgstr ""

#: ../../../networking/devmem.rst:57
msgid "slides, video"
msgstr ""

#: ../../../networking/devmem.rst:58
msgid "https://netdevconf.org/0x17/sessions/talk/device-memory-tcp.html"
msgstr ""

#: ../../../networking/devmem.rst:60
msgid "patchset"
msgstr ""

#: ../../../networking/devmem.rst:61
msgid ""
"[PATCH net-next v24 00/13] Device Memory TCP https://lore.kernel.org/"
"netdev/20240831004313.3713467-1-almasrymina@google.com/"
msgstr ""

#: ../../../networking/devmem.rst:66
msgid "RX Interface"
msgstr ""

#: ../../../networking/devmem.rst:70 ../../../networking/devmem.rst:243
msgid "Example"
msgstr ""

#: ../../../networking/devmem.rst:72
msgid ""
"./tools/testing/selftests/drivers/net/hw/ncdevmem:do_server shows an example "
"of setting up the RX path of this API."
msgstr ""

#: ../../../networking/devmem.rst:77 ../../../networking/devmem.rst:250
msgid "NIC Setup"
msgstr ""

#: ../../../networking/devmem.rst:79
msgid ""
"Header split, flow steering, & RSS are required features for devmem TCP."
msgstr ""

#: ../../../networking/devmem.rst:81
msgid ""
"Header split is used to split incoming packets into a header buffer in host "
"memory, and a payload buffer in device memory."
msgstr ""

#: ../../../networking/devmem.rst:84
msgid ""
"Flow steering & RSS are used to ensure that only flows targeting devmem land "
"on an RX queue bound to devmem."
msgstr ""

#: ../../../networking/devmem.rst:87
msgid "Enable header split & flow steering::"
msgstr ""

#: ../../../networking/devmem.rst:96
msgid ""
"Configure RSS to steer all traffic away from the target RX queue (queue 15 "
"in this example)::"
msgstr ""

#: ../../../networking/devmem.rst:102
msgid ""
"The user must bind a dmabuf to any number of RX queues on a given NIC using "
"the netlink API::"
msgstr ""

#: ../../../networking/devmem.rst:126 ../../../networking/devmem.rst:269
msgid ""
"The netlink API returns a dmabuf_id: a unique ID that refers to this dmabuf "
"that has been bound."
msgstr ""

#: ../../../networking/devmem.rst:129 ../../../networking/devmem.rst:272
msgid ""
"The user can unbind the dmabuf from the netdevice by closing the netlink "
"socket that established the binding. We do this so that the binding is "
"automatically unbound even if the userspace process crashes."
msgstr ""

#: ../../../networking/devmem.rst:133 ../../../networking/devmem.rst:276
msgid ""
"Note that any reasonably well-behaved dmabuf from any exporter should work "
"with devmem TCP, even if the dmabuf is not actually backed by devmem. An "
"example of this is udmabuf, which wraps user memory (non-devmem) in a dmabuf."
msgstr ""

#: ../../../networking/devmem.rst:139 ../../../networking/devmem.rst:281
msgid "Socket Setup"
msgstr ""

#: ../../../networking/devmem.rst:141
msgid "The socket must be flow steered to the dmabuf bound RX queue::"
msgstr ""

#: ../../../networking/devmem.rst:147
msgid "Receiving data"
msgstr ""

#: ../../../networking/devmem.rst:149
msgid ""
"The user application must signal to the kernel that it is capable of "
"receiving devmem data by passing the MSG_SOCK_DEVMEM flag to recvmsg::"
msgstr ""

#: ../../../networking/devmem.rst:154
msgid ""
"Applications that do not specify the MSG_SOCK_DEVMEM flag will receive an "
"EFAULT on devmem data."
msgstr ""

#: ../../../networking/devmem.rst:157
msgid ""
"Devmem data is received directly into the dmabuf bound to the NIC in 'NIC "
"Setup', and the kernel signals such to the user via the SCM_DEVMEM_* cmsgs::"
msgstr ""

#: ../../../networking/devmem.rst:200
msgid "Applications may receive 2 cmsgs:"
msgstr ""

#: ../../../networking/devmem.rst:202
msgid ""
"SCM_DEVMEM_DMABUF: this indicates the fragment landed in the dmabuf "
"indicated by dmabuf_id."
msgstr ""

#: ../../../networking/devmem.rst:205
msgid ""
"SCM_DEVMEM_LINEAR: this indicates the fragment landed in the linear buffer. "
"This typically happens when the NIC is unable to split the packet at the "
"header boundary, such that part (or all) of the payload landed in host "
"memory."
msgstr ""

#: ../../../networking/devmem.rst:210
msgid ""
"Applications may receive no SO_DEVMEM_* cmsgs. That indicates non-devmem, "
"regular TCP data that landed on an RX queue not bound to a dmabuf."
msgstr ""

#: ../../../networking/devmem.rst:215
msgid "Freeing frags"
msgstr ""

#: ../../../networking/devmem.rst:217
msgid ""
"Frags received via SCM_DEVMEM_DMABUF are pinned by the kernel while the user "
"processes the frag. The user must return the frag to the kernel via "
"SO_DEVMEM_DONTNEED::"
msgstr ""

#: ../../../networking/devmem.rst:224
msgid ""
"The user must ensure the tokens are returned to the kernel in a timely "
"manner. Failure to do so will exhaust the limited dmabuf that is bound to "
"the RX queue and will lead to packet drops."
msgstr ""

#: ../../../networking/devmem.rst:228
msgid ""
"The user must pass no more than 128 tokens, with no more than 1024 total "
"frags among the token->token_count across all the tokens. If the user "
"provides more than 1024 frags, the kernel will free up to 1024 frags and "
"return early."
msgstr ""

#: ../../../networking/devmem.rst:232
msgid ""
"The kernel returns the number of actual frags freed. The number of frags "
"freed can be less than the tokens provided by the user in case of:"
msgstr ""

#: ../../../networking/devmem.rst:235
msgid "an internal kernel leak bug."
msgstr ""

#: ../../../networking/devmem.rst:236
msgid "the user passed more than 1024 frags."
msgstr ""

#: ../../../networking/devmem.rst:239
msgid "TX Interface"
msgstr ""

#: ../../../networking/devmem.rst:245
msgid ""
"./tools/testing/selftests/drivers/net/hw/ncdevmem:do_client shows an example "
"of setting up the TX path of this API."
msgstr ""

#: ../../../networking/devmem.rst:252
msgid "The user must bind a TX dmabuf to a given NIC using the netlink API::"
msgstr ""

#: ../../../networking/devmem.rst:283
msgid ""
"The user application must use MSG_ZEROCOPY flag when sending devmem TCP. "
"Devmem cannot be copied by the kernel, so the semantics of the devmem TX are "
"similar to the semantics of MSG_ZEROCOPY::"
msgstr ""

#: ../../../networking/devmem.rst:289
msgid ""
"It is also recommended that the user binds the TX socket to the same "
"interface the dma-buf has been bound to via SO_BINDTODEVICE::"
msgstr ""

#: ../../../networking/devmem.rst:296
msgid "Sending data"
msgstr ""

#: ../../../networking/devmem.rst:298
msgid "Devmem data is sent using the SCM_DEVMEM_DMABUF cmsg."
msgstr ""

#: ../../../networking/devmem.rst:300
msgid "The user should create a msghdr where,"
msgstr ""

#: ../../../networking/devmem.rst:302
msgid "iov_base is set to the offset into the dmabuf to start sending from"
msgstr ""

#: ../../../networking/devmem.rst:303
msgid "iov_len is set to the number of bytes to be sent from the dmabuf"
msgstr ""

#: ../../../networking/devmem.rst:305
msgid ""
"The user passes the dma-buf id to send from via the dmabuf_tx_cmsg.dmabuf_id."
msgstr ""

#: ../../../networking/devmem.rst:307
msgid ""
"The example below sends 1024 bytes from offset 100 into the dmabuf, and 2048 "
"from offset 2000 into the dmabuf. The dmabuf to send from is tx_dmabuf_id::"
msgstr ""

#: ../../../networking/devmem.rst:340
msgid "Reusing TX dmabufs"
msgstr ""

#: ../../../networking/devmem.rst:342
msgid ""
"Similar to MSG_ZEROCOPY with regular memory, the user should not modify the "
"contents of the dma-buf while a send operation is in progress. This is "
"because the kernel does not keep a copy of the dmabuf contents. Instead, the "
"kernel will pin and send data from the buffer available to the userspace."
msgstr ""

#: ../../../networking/devmem.rst:347
msgid ""
"Just as in MSG_ZEROCOPY, the kernel notifies the userspace of send "
"completions using MSG_ERRQUEUE::"
msgstr ""

#: ../../../networking/devmem.rst:376
msgid ""
"After the associated sendmsg has been completed, the dmabuf can be reused by "
"the userspace."
msgstr ""

#: ../../../networking/devmem.rst:381
msgid "Implementation & Caveats"
msgstr ""

#: ../../../networking/devmem.rst:384
msgid "Unreadable skbs"
msgstr ""

#: ../../../networking/devmem.rst:386
msgid ""
"Devmem payloads are inaccessible to the kernel processing the packets. This "
"results in a few quirks for payloads of devmem skbs:"
msgstr ""

#: ../../../networking/devmem.rst:389
msgid ""
"Loopback is not functional. Loopback relies on copying the payload, which is "
"not possible with devmem skbs."
msgstr ""

#: ../../../networking/devmem.rst:392
msgid "Software checksum calculation fails."
msgstr ""

#: ../../../networking/devmem.rst:394
msgid "TCP Dump and bpf can't access devmem packet payloads."
msgstr ""

#: ../../../networking/devmem.rst:398
msgid "Testing"
msgstr ""

#: ../../../networking/devmem.rst:400
msgid ""
"More realistic example code can be found in the kernel source under ``tools/"
"testing/selftests/drivers/net/hw/ncdevmem.c``"
msgstr ""

#: ../../../networking/devmem.rst:403
msgid ""
"ncdevmem is a devmem TCP netcat. It works very similarly to netcat, but "
"receives data directly into a udmabuf."
msgstr ""

#: ../../../networking/devmem.rst:406
msgid ""
"To run ncdevmem, you need to run it on a server on the machine under test, "
"and you need to run netcat on a peer to provide the TX data."
msgstr ""

#: ../../../networking/devmem.rst:409
msgid ""
"ncdevmem has a validation mode as well that expects a repeating pattern of "
"incoming data and validates it as such. For example, you can launch ncdevmem "
"on the server by::"
msgstr ""

#: ../../../networking/devmem.rst:415
msgid ""
"On client side, use regular netcat to send TX data to ncdevmem process on "
"the server::"
msgstr ""
