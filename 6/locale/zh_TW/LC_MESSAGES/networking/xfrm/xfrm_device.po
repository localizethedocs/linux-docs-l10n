# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-13 10:19+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/xfrm/xfrm_device.rst:6
msgid "XFRM device - offloading the IPsec computations"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:8
msgid ""
"Shannon Nelson <shannon.nelson@oracle.com> Leon Romanovsky <leonro@nvidia."
"com>"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:13
msgid "Overview"
msgstr "概覽"

#: ../../../networking/xfrm/xfrm_device.rst:15
msgid ""
"IPsec is a useful feature for securing network traffic, but the "
"computational cost is high: a 10Gbps link can easily be brought down to "
"under 1Gbps, depending on the traffic and link configuration. Luckily, there "
"are NICs that offer a hardware based IPsec offload which can radically "
"increase throughput and decrease CPU utilization.  The XFRM Device interface "
"allows NIC drivers to offer to the stack access to the hardware offload."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:23
msgid ""
"Right now, there are two types of hardware offload that kernel supports:"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:25
msgid "IPsec crypto offload:"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:27
#: ../../../networking/xfrm/xfrm_device.rst:32
msgid "NIC performs encrypt/decrypt"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:28
msgid "Kernel does everything else"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:30
msgid "IPsec packet offload:"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:33
msgid "NIC does encapsulation"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:34
msgid "Kernel and NIC have SA and policy in-sync"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:35
msgid "NIC handles the SA and policies states"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:36
msgid "The Kernel talks to the keymanager"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:38
msgid ""
"Userland access to the offload is typically through a system such as "
"libreswan or KAME/raccoon, but the iproute2 'ip xfrm' command set can be "
"handy when experimenting.  An example command might look something like this "
"for crypto offload::"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:49
msgid "and for packet offload::"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:60
msgid ""
"Yes, that's ugly, but that's what shell scripts and/or libreswan are for."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:65
msgid "Callbacks to implement"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:90
msgid ""
"The NIC driver offering ipsec offload will need to implement callbacks "
"relevant to supported offload to make the offload available to the network "
"stack's XFRM subsystem. Additionally, the feature bits NETIF_F_HW_ESP and "
"NETIF_F_HW_ESP_TX_CSUM will signal the availability of the offload."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:98
msgid "Flow"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:100
msgid ""
"At probe time and before the call to register_netdev(), the driver should "
"set up local data structures and XFRM callbacks, and set the feature bits. "
"The XFRM code's listener will finish the setup on NETDEV_REGISTER."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:110
msgid ""
"When new SAs are set up with a request for \"offload\" feature, the driver's "
"xdo_dev_state_add() will be given the new SA to be offloaded and an "
"indication of whether it is for Rx or Tx.  The driver should"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:114
msgid "verify the algorithm is supported for offloads"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:115
msgid "store the SA information (key, salt, target-ip, protocol, etc)"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:116
msgid "enable the HW offload of the SA"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:117
msgid "return status value:"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:120
msgid "0"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:120
msgid "success"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:121
msgid "-EOPNETSUPP"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:121
msgid ""
"offload not supported, try SW IPsec, not applicable for packet offload mode"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:123
msgid "other"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:123
msgid "fail the request"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:126
msgid ""
"The driver can also set an offload_handle in the SA, an opaque void pointer "
"that can be used to convey context into the fast-path offload requests::"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:132
msgid ""
"When the network stack is preparing an IPsec packet for an SA that has been "
"setup for offload, it first calls into xdo_dev_offload_ok() with the skb and "
"the intended offload state to ask the driver if the offload will "
"serviceable.  This can check the packet information to be sure the offload "
"can be supported (e.g. IPv4 or IPv6, no IPv4 options, etc) and return true "
"or false to signify its support. In case driver doesn't implement this "
"callback, the stack provides reasonable defaults."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:140
msgid ""
"Crypto offload mode: When ready to send, the driver needs to inspect the Tx "
"packet for the offload information, including the opaque context, and set up "
"the packet send accordingly::"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:149
msgid ""
"The stack has already inserted the appropriate IPsec headers in the packet "
"data, the offload just needs to do the encryption and fix up the header "
"values."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:154
msgid ""
"When a packet is received and the HW has indicated that it offloaded a "
"decryption, the driver needs to add a reference to the decoded SA into the "
"packet's skb.  At this point the data should be decrypted but the IPsec "
"headers are still in the packet data; they are removed later up the stack in "
"xfrm_input()."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:160
msgid "Find and hold the SA that was used to the Rx skb::"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:166
msgid "Store the state information into the skb::"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:173
msgid "Indicate the success and/or error status of the offload::"
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:179
msgid "Hand the packet to napi_gro_receive() as usual."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:181
msgid ""
"In ESN mode, xdo_dev_state_advance_esn() is called from "
"xfrm_replay_advance_esn() for RX, and xfrm_replay_overflow_offload_esn for "
"TX. Driver will check packet seq number and update HW ESN state machine if "
"needed."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:185
msgid ""
"Packet offload mode: HW adds and deletes XFRM headers. So in RX path, XFRM "
"stack is bypassed if HW reported success. In TX path, the packet lefts "
"kernel without extra header and not encrypted, the HW is responsible to "
"perform it."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:190
msgid ""
"When the SA is removed by the user, the driver's xdo_dev_state_delete() and "
"xdo_dev_policy_delete() are asked to disable the offload.  Later, "
"xdo_dev_state_free() and xdo_dev_policy_free() are called from a garbage "
"collection routine after all reference counts to the state and policy have "
"been removed and any remaining resources can be cleared for the offload "
"state.  How these are used by the driver will depend on specific hardware "
"needs."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:198
msgid ""
"As a netdev is set to DOWN the XFRM stack's netdev listener will call "
"xdo_dev_state_delete(), xdo_dev_policy_delete(), xdo_dev_state_free() and "
"xdo_dev_policy_free() on any remaining offloaded states."
msgstr ""

#: ../../../networking/xfrm/xfrm_device.rst:202
msgid ""
"Outcome of HW handling packets, the XFRM core can't count hard, soft limits. "
"The HW/driver are responsible to perform it and provide accurate data when "
"xdo_dev_state_update_stats() is called. In case of one of these limits "
"occuried, the driver needs to call to xfrm_state_check_expire() to make sure "
"that XFRM performs rekeying sequence."
msgstr ""
