# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-13 10:19+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../wmi/devices/uniwill-laptop.rst:5
msgid "Uniwill Notebook driver (uniwill-laptop)"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:8
msgid "Introduction"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:10
msgid ""
"Many notebooks manufactured by Uniwill (either directly or as ODM) provide a "
"EC interface for controlling various platform settings like sensors and fan "
"control. This interface is used by the ``uniwill-laptop`` driver to map "
"those features onto standard kernel interfaces."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:15
msgid "EC WMI interface description"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:17
msgid ""
"The EC WMI interface description can be decoded from the embedded binary MOF "
"(bmof) data using the `bmfdec <https://github.com/pali/bmfdec>`_ utility:"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:49
msgid ""
"Most of the WMI-related code was copied from the Windows driver samples, "
"which unfortunately means that the WMI-GUID is not unique. This makes the "
"WMI-GUID unusable for autoloading."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:53
msgid "WMI method GetULong()"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:55
#: ../../../wmi/devices/uniwill-laptop.rst:60
msgid ""
"This WMI method was copied from the Windows driver samples and has no "
"function."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:58
msgid "WMI method SetULong()"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:63
msgid "WMI method FireULong()"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:65
msgid ""
"This WMI method allows to inject a WMI event with a 32-bit payload. Its "
"primary purpose seems to be debugging."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:69
msgid "WMI method GetSetULong()"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:71
msgid ""
"This WMI method is used to communicate with the EC. The ``Data`` argument "
"holds the following information (starting with the least significant byte):"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:74
msgid "16-bit address"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:75
msgid "16-bit data (set to ``0x0000`` when reading)"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:76
msgid "16-bit operation (``0x0100`` for reading and ``0x0000`` for writing)"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:77
msgid "16-bit reserved (set to ``0x0000``)"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:79
msgid ""
"The first 8 bits of the ``Return`` value contain the data returned by the EC "
"when reading. The special value ``0xFEFEFEFE`` is used to indicate a "
"communication failure with the EC."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:83
msgid "WMI method GetButton()"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:85
msgid ""
"This WMI method is not implemented on all machines and has an unknown "
"purpose."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:88
msgid "Reverse-Engineering the EC WMI interface"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:90
msgid ""
"Randomly poking the EC can potentially cause damage to the machine and other "
"unwanted side effects, please be careful."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:93
msgid ""
"The EC behind the ``GetSetULong`` method is used by the OEM software "
"supplied by the manufacturer. Reverse-engineering of this software is "
"difficult since it uses an obfuscator, however some parts are not "
"obfuscated. In this case `dnSpy <https://github.com/dnSpy/dnSpy>`_ could "
"also be helpful."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:97
msgid ""
"The EC can be accessed under Windows using powershell (requires admin "
"privileges):"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:105
msgid "WMI event interface description"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:107
msgid ""
"The WMI interface description can also be decoded from the embedded binary "
"MOF (bmof) data:"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:122
msgid ""
"Most of the WMI-related code was again copied from the Windows driver "
"samples, causing this WMI interface to suffer from the same restrictions as "
"the EC WMI interface described above."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:126
msgid "WMI event data"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:128
msgid ""
"The WMI event data contains a single 32-bit value which is used to indicate "
"various platform events."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:131
msgid "Reverse-Engineering the Uniwill WMI event interface"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:133
msgid ""
"The driver logs debug messages when receiving a WMI event. Thus enabling "
"debug messages will be useful for finding unknown event codes."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:137
msgid "EC ACPI interface description"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:139
msgid ""
"The ``INOU0000`` ACPI device is a virtual device used to access various "
"hardware registers available on notebooks manufactured by Uniwill. Reading "
"and writing those registers happens by calling ACPI control methods. The "
"``uniwill-laptop`` driver uses this device to communicate with the EC "
"because the ACPI control methods are faster than the WMI methods described "
"above."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:144
msgid ""
"ACPI control methods used for reading registers take a single ACPI integer "
"containing the address of the register to read and return a ACPI integer "
"containing the data inside said register. ACPI control methods used for "
"writing registers however take two ACPI integers, with the additional ACPI "
"integer containing the data to be written into the register. Such ACPI "
"control methods return nothing."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:151
msgid "System memory"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:153
msgid ""
"System memory can be accessed with a granularity of either a single byte "
"(``MMRB`` for reading and ``MMWB`` for writing) or four bytes (``MMRD`` for "
"reading and ``MMWD`` for writing). Those ACPI control methods are unused "
"because they provide no benefit when compared to the native memory access "
"functions provided by the kernel."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:159
msgid "EC RAM"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:161
msgid ""
"The internal RAM of the EC can be accessed with a granularity of a single "
"byte using the ``ECRR`` (read) and ``ECRW`` (write) ACPI control methods, "
"with the maximum register address being ``0xFFF``. The OEM software waits 6 "
"ms after calling one of those ACPI control methods, likely to avoid "
"overwhelming the EC when being connected over LPC."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:167
msgid "PCI config space"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:169
msgid ""
"The PCI config space can be accessed with a granularity of four bytes using "
"the ``PCRD`` (read) and ``PCWD`` (write) ACPI control methods. The exact "
"address format is unknown, and poking random PCI devices might confuse the "
"PCI subsystem. Because of this those ACPI control methods are not used."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:174
msgid "IO ports"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:176
msgid ""
"IO ports can be accessed with a granularity of four bytes using the ``IORD`` "
"(read) and ``IOWD`` (write) ACPI control methods. Those ACPI control methods "
"are unused because they provide no benefit when compared to the native IO "
"port access functions provided by the kernel."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:181
msgid "CMOS RAM"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:183
msgid ""
"The CMOS RAM can be accessed with a granularity of a single byte using the "
"``RCMS`` (read) and ``WCMS`` ACPI control methods. Using those ACPI methods "
"might interfere with the native CMOS RAM access functions provided by the "
"kernel due to the usage of indexed IO, so they are unused."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:188
msgid "Indexed IO"
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:190
msgid ""
"Indexed IO with IO ports with a granularity of a single byte can be "
"performed using the ``RIOP`` (read) and ``WIOP`` (write) ACPI control "
"methods. Those ACPI methods are unused because they provide no benifit when "
"compared to the native IO port access functions provided by the kernel."
msgstr ""

#: ../../../wmi/devices/uniwill-laptop.rst:194
msgid ""
"Special thanks go to github user `pobrn` which developed the `qc71_laptop "
"<https://github.com/pobrn/qc71_laptop>`_ driver on which this driver is "
"partly based. The same is true for Tuxedo Computers, which developed the "
"`tuxedo-drivers <https://gitlab.com/tuxedocomputers/development/packages/"
"tuxedo-drivers>`_ package which also served as a foundation for this driver."
msgstr ""
