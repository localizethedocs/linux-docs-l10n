# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../locking/hwspinlock.rst:3
msgid "Hardware Spinlock Framework"
msgstr ""

#: ../../../locking/hwspinlock.rst:6
msgid "Introduction"
msgstr "介紹"

#: ../../../locking/hwspinlock.rst:8
msgid ""
"Hardware spinlock modules provide hardware assistance for synchronization "
"and mutual exclusion between heterogeneous processors and those not "
"operating under a single, shared operating system."
msgstr ""

#: ../../../locking/hwspinlock.rst:12
msgid ""
"For example, OMAP4 has dual Cortex-A9, dual Cortex-M3 and a C64x+ DSP, each "
"of which is running a different Operating System (the master, A9, is usually "
"running Linux and the slave processors, the M3 and the DSP, are running some "
"flavor of RTOS)."
msgstr ""

#: ../../../locking/hwspinlock.rst:17
msgid ""
"A generic hwspinlock framework allows platform-independent drivers to use "
"the hwspinlock device in order to access data structures that are shared "
"between remote processors, that otherwise have no alternative mechanism to "
"accomplish synchronization and mutual exclusion operations."
msgstr ""

#: ../../../locking/hwspinlock.rst:22
msgid ""
"This is necessary, for example, for Inter-processor communications: on "
"OMAP4, cpu-intensive multimedia tasks are offloaded by the host to the "
"remote M3 and/or C64x+ slave processors (by an IPC subsystem called Syslink)."
msgstr ""

#: ../../../locking/hwspinlock.rst:26
msgid ""
"To achieve fast message-based communications, a minimal kernel support is "
"needed to deliver messages arriving from a remote processor to the "
"appropriate user process."
msgstr ""

#: ../../../locking/hwspinlock.rst:30
msgid ""
"This communication is based on simple data structures that is shared between "
"the remote processors, and access to it is synchronized using the hwspinlock "
"module (remote processor directly places new messages in this shared data "
"structure)."
msgstr ""

#: ../../../locking/hwspinlock.rst:35
msgid ""
"A common hwspinlock interface makes it possible to have generic, platform- "
"independent, drivers."
msgstr ""

#: ../../../locking/hwspinlock.rst:39
msgid "User API"
msgstr "使用者 API"

#: ../../../locking/hwspinlock.rst:45
msgid ""
"Assign a specific hwspinlock id and return its address, or NULL if that "
"hwspinlock is already in use. Usually board code will be calling this "
"function in order to reserve specific hwspinlock ids for predefined purposes."
msgstr ""

#: ../../../locking/hwspinlock.rst:50 ../../../locking/hwspinlock.rst:65
#: ../../../locking/hwspinlock.rst:75 ../../../locking/hwspinlock.rst:86
msgid "Should be called from a process context (might sleep)."
msgstr ""

#: ../../../locking/hwspinlock.rst:56
msgid ""
"Retrieve the global lock id for an OF phandle-based specific lock. This "
"function provides a means for DT users of a hwspinlock module to get the "
"global lock id of a specific hwspinlock, so that it can be requested using "
"the normal hwspin_lock_request_specific() API."
msgstr ""

#: ../../../locking/hwspinlock.rst:61
msgid ""
"The function returns a lock id number on success, -EPROBE_DEFER if the "
"hwspinlock device is not yet registered with the core, or other error values."
msgstr ""

#: ../../../locking/hwspinlock.rst:71
msgid ""
"Free a previously-assigned hwspinlock; returns 0 on success, or an "
"appropriate error code on failure (e.g. -EINVAL if the hwspinlock is already "
"free)."
msgstr ""

#: ../../../locking/hwspinlock.rst:81
msgid ""
"After verifying the owner of the hwspinlock, release a previously acquired "
"hwspinlock; returns 0 on success, or an appropriate error code on failure (e."
"g. -EOPNOTSUPP if the bust operation is not defined for the specific "
"hwspinlock)."
msgstr ""

#: ../../../locking/hwspinlock.rst:92
msgid ""
"Lock a previously-assigned hwspinlock with a timeout limit (specified in "
"msecs). If the hwspinlock is already taken, the function will busy loop "
"waiting for it to be released, but give up when the timeout elapses. Upon a "
"successful return from this function, preemption is disabled so the caller "
"must not sleep, and is advised to release the hwspinlock as soon as "
"possible, in order to minimize remote cores polling on the hardware "
"interconnect."
msgstr ""

#: ../../../locking/hwspinlock.rst:100 ../../../locking/hwspinlock.rst:115
msgid ""
"Returns 0 when successful and an appropriate error code otherwise (most "
"notably -ETIMEDOUT if the hwspinlock is still busy after timeout msecs). The "
"function will never sleep."
msgstr ""

#: ../../../locking/hwspinlock.rst:108
msgid ""
"Lock a previously-assigned hwspinlock with a timeout limit (specified in "
"msecs). If the hwspinlock is already taken, the function will busy loop "
"waiting for it to be released, but give up when the timeout elapses. Upon a "
"successful return from this function, preemption and the local interrupts "
"are disabled, so the caller must not sleep, and is advised to release the "
"hwspinlock as soon as possible."
msgstr ""

#: ../../../locking/hwspinlock.rst:124
msgid ""
"Lock a previously-assigned hwspinlock with a timeout limit (specified in "
"msecs). If the hwspinlock is already taken, the function will busy loop "
"waiting for it to be released, but give up when the timeout elapses. Upon a "
"successful return from this function, preemption is disabled, local "
"interrupts are disabled and their previous state is saved at the given flags "
"placeholder. The caller must not sleep, and is advised to release the "
"hwspinlock as soon as possible."
msgstr ""

#: ../../../locking/hwspinlock.rst:132 ../../../locking/hwspinlock.rst:149
#: ../../../locking/hwspinlock.rst:165
msgid ""
"Returns 0 when successful and an appropriate error code otherwise (most "
"notably -ETIMEDOUT if the hwspinlock is still busy after timeout msecs)."
msgstr ""

#: ../../../locking/hwspinlock.rst:135 ../../../locking/hwspinlock.rst:152
#: ../../../locking/hwspinlock.rst:168 ../../../locking/hwspinlock.rst:202
msgid "The function will never sleep."
msgstr ""

#: ../../../locking/hwspinlock.rst:141 ../../../locking/hwspinlock.rst:158
msgid ""
"Lock a previously-assigned hwspinlock with a timeout limit (specified in "
"msecs). If the hwspinlock is already taken, the function will busy loop "
"waiting for it to be released, but give up when the timeout elapses."
msgstr ""

#: ../../../locking/hwspinlock.rst:145 ../../../locking/hwspinlock.rst:227
msgid ""
"Caution: User must protect the routine of getting hardware lock with mutex "
"or spinlock to avoid dead-lock, that will let user can do some time-"
"consuming or sleepable operations under the hardware lock."
msgstr ""

#: ../../../locking/hwspinlock.rst:162
msgid ""
"This function shall be called only from an atomic context and the timeout "
"value shall not exceed a few msecs."
msgstr ""

#: ../../../locking/hwspinlock.rst:175 ../../../locking/hwspinlock.rst:192
#: ../../../locking/hwspinlock.rst:208 ../../../locking/hwspinlock.rst:224
#: ../../../locking/hwspinlock.rst:239
msgid ""
"Attempt to lock a previously-assigned hwspinlock, but immediately fail if it "
"is already taken."
msgstr ""

#: ../../../locking/hwspinlock.rst:178
msgid ""
"Upon a successful return from this function, preemption is disabled so "
"caller must not sleep, and is advised to release the hwspinlock as soon as "
"possible, in order to minimize remote cores polling on the hardware "
"interconnect."
msgstr ""

#: ../../../locking/hwspinlock.rst:183 ../../../locking/hwspinlock.rst:216
#: ../../../locking/hwspinlock.rst:231 ../../../locking/hwspinlock.rst:244
msgid ""
"Returns 0 on success and an appropriate error code otherwise (most notably -"
"EBUSY if the hwspinlock was already taken). The function will never sleep."
msgstr ""

#: ../../../locking/hwspinlock.rst:195
msgid ""
"Upon a successful return from this function, preemption and the local "
"interrupts are disabled so caller must not sleep, and is advised to release "
"the hwspinlock as soon as possible."
msgstr ""

#: ../../../locking/hwspinlock.rst:199
msgid ""
"Returns 0 on success and an appropriate error code otherwise (most notably -"
"EBUSY if the hwspinlock was already taken)."
msgstr ""

#: ../../../locking/hwspinlock.rst:211
msgid ""
"Upon a successful return from this function, preemption is disabled, the "
"local interrupts are disabled and their previous state is saved at the given "
"flags placeholder. The caller must not sleep, and is advised to release the "
"hwspinlock as soon as possible."
msgstr ""

#: ../../../locking/hwspinlock.rst:242
msgid "This function shall be called only from an atomic context."
msgstr ""

#: ../../../locking/hwspinlock.rst:252
msgid ""
"Unlock a previously-locked hwspinlock. Always succeed, and can be called "
"from any context (the function never sleeps)."
msgstr ""

#: ../../../locking/hwspinlock.rst:257
msgid ""
"code should **never** unlock an hwspinlock which is already unlocked (there "
"is no protection against this)."
msgstr ""

#: ../../../locking/hwspinlock.rst:264
msgid ""
"Unlock a previously-locked hwspinlock and enable local interrupts. The "
"caller should **never** unlock an hwspinlock which is already unlocked."
msgstr ""

#: ../../../locking/hwspinlock.rst:267
msgid ""
"Doing so is considered a bug (there is no protection against this). Upon a "
"successful return from this function, preemption and local interrupts are "
"enabled. This function will never sleep."
msgstr ""

#: ../../../locking/hwspinlock.rst:276 ../../../locking/hwspinlock.rst:288
#: ../../../locking/hwspinlock.rst:298
msgid "Unlock a previously-locked hwspinlock."
msgstr ""

#: ../../../locking/hwspinlock.rst:278
msgid ""
"The caller should **never** unlock an hwspinlock which is already unlocked. "
"Doing so is considered a bug (there is no protection against this). Upon a "
"successful return from this function, preemption is reenabled, and the state "
"of the local interrupts is restored to the state saved at the given flags. "
"This function will never sleep."
msgstr ""

#: ../../../locking/hwspinlock.rst:290 ../../../locking/hwspinlock.rst:300
msgid ""
"The caller should **never** unlock an hwspinlock which is already unlocked. "
"Doing so is considered a bug (there is no protection against this). This "
"function will never sleep."
msgstr ""

#: ../../../locking/hwspinlock.rst:305
msgid "Typical usage"
msgstr ""

#: ../../../locking/hwspinlock.rst:349
msgid "API for implementors"
msgstr ""

#: ../../../locking/hwspinlock.rst:356
msgid ""
"To be called from the underlying platform-specific implementation, in order "
"to register a new hwspinlock device (which is usually a bank of numerous "
"locks). Should be called from a process context (this function might sleep)."
msgstr ""

#: ../../../locking/hwspinlock.rst:361
msgid "Returns 0 on success, or appropriate error code on failure."
msgstr ""

#: ../../../locking/hwspinlock.rst:367
msgid ""
"To be called from the underlying vendor-specific implementation, in order to "
"unregister an hwspinlock device (which is usually a bank of numerous locks)."
msgstr ""

#: ../../../locking/hwspinlock.rst:371
msgid "Should be called from a process context (this function might sleep)."
msgstr ""

#: ../../../locking/hwspinlock.rst:373
msgid ""
"Returns the address of hwspinlock on success, or NULL on error (e.g. if the "
"hwspinlock is still in use)."
msgstr ""

#: ../../../locking/hwspinlock.rst:377
msgid "Important structs"
msgstr ""

#: ../../../locking/hwspinlock.rst:379
msgid ""
"struct hwspinlock_device is a device which usually contains a bank of "
"hardware locks. It is registered by the underlying hwspinlock implementation "
"using the hwspin_lock_register() API."
msgstr ""

#: ../../../locking/hwspinlock.rst:401
msgid ""
"struct hwspinlock_device contains an array of hwspinlock structs, each of "
"which represents a single hardware lock::"
msgstr ""

#: ../../../locking/hwspinlock.rst:416
msgid ""
"When registering a bank of locks, the hwspinlock driver only needs to set "
"the priv members of the locks. The rest of the members are set and "
"initialized by the hwspinlock core itself."
msgstr ""

#: ../../../locking/hwspinlock.rst:421
msgid "Implementation callbacks"
msgstr ""

#: ../../../locking/hwspinlock.rst:423
msgid "There are three possible callbacks defined in 'struct hwspinlock_ops'::"
msgstr ""

#: ../../../locking/hwspinlock.rst:431
msgid "The first two callbacks are mandatory:"
msgstr ""

#: ../../../locking/hwspinlock.rst:433
msgid ""
"The ->trylock() callback should make a single attempt to take the lock, and "
"return 0 on failure and 1 on success. This callback may **not** sleep."
msgstr ""

#: ../../../locking/hwspinlock.rst:436
msgid ""
"The ->unlock() callback releases the lock. It always succeed, and it, too, "
"may **not** sleep."
msgstr ""

#: ../../../locking/hwspinlock.rst:439
msgid ""
"The ->relax() callback is optional. It is called by hwspinlock core while "
"spinning on a lock, and can be used by the underlying implementation to "
"force a delay between two successive invocations of ->trylock(). It may "
"**not** sleep."
msgstr ""
