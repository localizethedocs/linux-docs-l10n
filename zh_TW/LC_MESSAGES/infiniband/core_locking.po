# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../infiniband/core_locking.rst:3
msgid "InfiniBand Midlayer Locking"
msgstr ""

#: ../../../infiniband/core_locking.rst:5
msgid ""
"This guide is an attempt to make explicit the locking assumptions made by "
"the InfiniBand midlayer.  It describes the requirements on both low-level "
"drivers that sit below the midlayer and upper level protocols that use the "
"midlayer."
msgstr ""

#: ../../../infiniband/core_locking.rst:11
msgid "Sleeping and interrupt context"
msgstr ""

#: ../../../infiniband/core_locking.rst:13
msgid ""
"With the following exceptions, a low-level driver implementation of all of "
"the methods in struct ib_device may sleep.  The exceptions are any methods "
"from the list:"
msgstr ""

#: ../../../infiniband/core_locking.rst:17
msgid "create_ah"
msgstr ""

#: ../../../infiniband/core_locking.rst:18
msgid "modify_ah"
msgstr ""

#: ../../../infiniband/core_locking.rst:19
msgid "query_ah"
msgstr ""

#: ../../../infiniband/core_locking.rst:20
msgid "destroy_ah"
msgstr ""

#: ../../../infiniband/core_locking.rst:21
msgid "post_send"
msgstr ""

#: ../../../infiniband/core_locking.rst:22
msgid "post_recv"
msgstr ""

#: ../../../infiniband/core_locking.rst:23
msgid "poll_cq"
msgstr ""

#: ../../../infiniband/core_locking.rst:24
msgid "req_notify_cq"
msgstr ""

#: ../../../infiniband/core_locking.rst:26
msgid "which may not sleep and must be callable from any context."
msgstr ""

#: ../../../infiniband/core_locking.rst:28
msgid "The corresponding functions exported to upper level protocol consumers:"
msgstr ""

#: ../../../infiniband/core_locking.rst:31
msgid "rdma_create_ah"
msgstr ""

#: ../../../infiniband/core_locking.rst:32
msgid "rdma_modify_ah"
msgstr ""

#: ../../../infiniband/core_locking.rst:33
msgid "rdma_query_ah"
msgstr ""

#: ../../../infiniband/core_locking.rst:34
msgid "rdma_destroy_ah"
msgstr ""

#: ../../../infiniband/core_locking.rst:35
msgid "ib_post_send"
msgstr ""

#: ../../../infiniband/core_locking.rst:36
msgid "ib_post_recv"
msgstr ""

#: ../../../infiniband/core_locking.rst:37
msgid "ib_req_notify_cq"
msgstr ""

#: ../../../infiniband/core_locking.rst:39
msgid "are therefore safe to call from any context."
msgstr ""

#: ../../../infiniband/core_locking.rst:41
msgid "In addition, the function"
msgstr ""

#: ../../../infiniband/core_locking.rst:43
msgid "ib_dispatch_event"
msgstr ""

#: ../../../infiniband/core_locking.rst:45
msgid ""
"used by low-level drivers to dispatch asynchronous events through the "
"midlayer is also safe to call from any context."
msgstr ""

#: ../../../infiniband/core_locking.rst:49
msgid "Reentrancy"
msgstr ""

#: ../../../infiniband/core_locking.rst:51
msgid ""
"All of the methods in struct ib_device exported by a low-level driver must "
"be fully reentrant.  The low-level driver is required to perform all "
"synchronization necessary to maintain consistency, even if multiple function "
"calls using the same object are run simultaneously."
msgstr ""

#: ../../../infiniband/core_locking.rst:57
msgid "The IB midlayer does not perform any serialization of function calls."
msgstr ""

#: ../../../infiniband/core_locking.rst:59
msgid ""
"Because low-level drivers are reentrant, upper level protocol consumers are "
"not required to perform any serialization.  However, some serialization may "
"be required to get sensible results.  For example, a consumer may safely "
"call ib_poll_cq() on multiple CPUs simultaneously.  However, the ordering of "
"the work completion information between different calls of ib_poll_cq() is "
"not defined."
msgstr ""

#: ../../../infiniband/core_locking.rst:67
msgid "Callbacks"
msgstr ""

#: ../../../infiniband/core_locking.rst:69
msgid ""
"A low-level driver must not perform a callback directly from the same "
"callchain as an ib_device method call.  For example, it is not allowed for a "
"low-level driver to call a consumer's completion event handler directly from "
"its post_send method.  Instead, the low-level driver should defer this "
"callback by, for example, scheduling a tasklet to perform the callback."
msgstr ""

#: ../../../infiniband/core_locking.rst:76
msgid ""
"The low-level driver is responsible for ensuring that multiple completion "
"event handlers for the same CQ are not called simultaneously.  The driver "
"must guarantee that only one CQ event handler for a given CQ is running at a "
"time.  In other words, the following situation is not allowed::"
msgstr ""

#: ../../../infiniband/core_locking.rst:93
msgid ""
"The context in which completion event and asynchronous event callbacks run "
"is not defined.  Depending on the low-level driver, it may be process "
"context, softirq context, or interrupt context. Upper level protocol "
"consumers may not sleep in a callback."
msgstr ""

#: ../../../infiniband/core_locking.rst:99
msgid "Hot-plug"
msgstr ""

#: ../../../infiniband/core_locking.rst:101
msgid ""
"A low-level driver announces that a device is ready for use by consumers "
"when it calls ib_register_device(), all initialization must be complete "
"before this call.  The device must remain usable until the driver's call to "
"ib_unregister_device() has returned."
msgstr ""

#: ../../../infiniband/core_locking.rst:106
msgid ""
"A low-level driver must call ib_register_device() and ib_unregister_device() "
"from process context.  It must not hold any semaphores that could cause "
"deadlock if a consumer calls back into the driver across these calls."
msgstr ""

#: ../../../infiniband/core_locking.rst:111
msgid ""
"An upper level protocol consumer may begin using an IB device as soon as the "
"add method of its struct ib_client is called for that device.  A consumer "
"must finish all cleanup and free all resources relating to a device before "
"returning from the remove method."
msgstr ""

#: ../../../infiniband/core_locking.rst:116
msgid "A consumer is permitted to sleep in its add and remove methods."
msgstr ""
