# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm/kernel_mode_neon.rst:3
msgid "Kernel mode NEON"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:6
msgid "TL;DR summary"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:7
msgid ""
"Use only NEON instructions, or VFP instructions that don't rely on support "
"code"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:9
msgid ""
"Isolate your NEON code in a separate compilation unit, and compile it with '-"
"march=armv7-a -mfpu=neon -mfloat-abi=softfp'"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:11
msgid ""
"Put kernel_neon_begin() and kernel_neon_end() calls around the calls into "
"your NEON code"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:13
msgid ""
"Don't sleep in your NEON code, and be aware that it will be executed with "
"preemption disabled"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:18
msgid "Introduction"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:19
msgid ""
"It is possible to use NEON instructions (and in some cases, VFP "
"instructions) in code that runs in kernel mode. However, for performance "
"reasons, the NEON/VFP register file is not preserved and restored at every "
"context switch or taken exception like the normal register file is, so some "
"manual intervention is required. Furthermore, special care is required for "
"code that may sleep [i.e., may call schedule()], as NEON or VFP instructions "
"will be executed in a non-preemptible section for reasons outlined below."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:29
msgid "Lazy preserve and restore"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:30
msgid ""
"The NEON/VFP register file is managed using lazy preserve (on UP systems) "
"and lazy restore (on both SMP and UP systems). This means that the register "
"file is kept 'live', and is only preserved and restored when multiple tasks "
"are contending for the NEON/VFP unit (or, in the SMP case, when a task "
"migrates to another core). Lazy restore is implemented by disabling the NEON/"
"VFP unit after every context switch, resulting in a trap when subsequently a "
"NEON/VFP instruction is issued, allowing the kernel to step in and perform "
"the restore if necessary."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:39
msgid ""
"Any use of the NEON/VFP unit in kernel mode should not interfere with this, "
"so it is required to do an 'eager' preserve of the NEON/VFP register file, "
"and enable the NEON/VFP unit explicitly so no exceptions are generated on "
"first subsequent use. This is handled by the function kernel_neon_begin(), "
"which should be called before any kernel mode NEON or VFP instructions are "
"issued. Likewise, the NEON/VFP unit should be disabled again after use to "
"make sure user mode will hit the lazy restore trap upon next use. This is "
"handled by the function kernel_neon_end()."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:50
msgid "Interruptions in kernel mode"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:51
msgid ""
"For reasons of performance and simplicity, it was decided that there shall "
"be no preserve/restore mechanism for the kernel mode NEON/VFP register "
"contents. This implies that interruptions of a kernel mode NEON section can "
"only be allowed if they are guaranteed not to touch the NEON/VFP registers. "
"For this reason, the following rules and restrictions apply in the kernel: * "
"NEON/VFP code is not allowed in interrupt context; * NEON/VFP code is not "
"allowed to sleep; * NEON/VFP code is executed with preemption disabled."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:60
msgid ""
"If latency is a concern, it is possible to put back to back calls to "
"kernel_neon_end() and kernel_neon_begin() in places in your code where none "
"of the NEON registers are live. (Additional calls to kernel_neon_begin() "
"should be reasonably cheap if no context switch occurred in the meantime)"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:67
msgid "VFP and support code"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:68
msgid ""
"Earlier versions of VFP (prior to version 3) rely on software support for "
"things like IEEE-754 compliant underflow handling etc. When the VFP unit "
"needs such software assistance, it signals the kernel by raising an "
"undefined instruction exception. The kernel responds by inspecting the VFP "
"control registers and the current instruction and arguments, and emulates "
"the instruction in software."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:74
msgid ""
"Such software assistance is currently not implemented for VFP instructions "
"executed in kernel mode. If such a condition is encountered, the kernel will "
"fail and generate an OOPS."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:80
msgid "Separating NEON code from ordinary code"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:81
msgid ""
"The compiler is not aware of the special significance of kernel_neon_begin() "
"and kernel_neon_end(), i.e., that it is only allowed to issue NEON/VFP "
"instructions between calls to these respective functions. Furthermore, GCC "
"may generate NEON instructions of its own at -O3 level if -mfpu=neon is "
"selected, and even if the kernel is currently compiled at -O2, future "
"changes may result in NEON/VFP instructions appearing in unexpected places "
"if no special care is taken."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:88
msgid ""
"Therefore, the recommended and only supported way of using NEON/VFP in the "
"kernel is by adhering to the following rules:"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:91
msgid ""
"isolate the NEON code in a separate compilation unit and compile it with '-"
"march=armv7-a -mfpu=neon -mfloat-abi=softfp';"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:93
msgid ""
"issue the calls to kernel_neon_begin(), kernel_neon_end() as well as the "
"calls into the unit containing the NEON code from a compilation unit which "
"is *not* built with the GCC flag '-mfpu=neon' set."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:97
msgid ""
"As the kernel is compiled with '-msoft-float', the above will guarantee that "
"both NEON and VFP instructions will only ever appear in designated "
"compilation units at any optimization level."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:103
msgid "NEON assembler"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:104
msgid ""
"NEON assembler is supported with no additional caveats as long as the rules "
"above are followed."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:109
msgid "NEON code generated by GCC"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:110
msgid ""
"The GCC option -ftree-vectorize (implied by -O3) tries to exploit implicit "
"parallelism, and generates NEON code from ordinary C source code. This is "
"fully supported as long as the rules above are followed."
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:116
msgid "NEON intrinsics"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:117
msgid ""
"NEON intrinsics are also supported. However, as code using NEON intrinsics "
"relies on the GCC header <arm_neon.h>, (which #includes <stdint.h>), you "
"should observe the following in addition to the rules above:"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:121
msgid ""
"Compile the unit containing the NEON intrinsics with '-ffreestanding' so GCC "
"uses its builtin version of <stdint.h> (this is a C99 header which the "
"kernel does not supply);"
msgstr ""

#: ../../../arch/arm/kernel_mode_neon.rst:124
msgid "Include <arm_neon.h> last, or at least after <linux/types.h>"
msgstr ""
