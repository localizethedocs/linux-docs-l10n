# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm/interrupts.rst:3
msgid "Interrupts"
msgstr "中斷"

#: ../../../arch/arm/interrupts.rst:5
msgid "2.5.2-rmk5:"
msgstr ""

#: ../../../arch/arm/interrupts.rst:6
msgid ""
"This is the first kernel that contains a major shake up of some of the major "
"architecture-specific subsystems."
msgstr ""

#: ../../../arch/arm/interrupts.rst:9
msgid ""
"Firstly, it contains some pretty major changes to the way we handle the MMU "
"TLB.  Each MMU TLB variant is now handled completely separately - we have "
"TLB v3, TLB v4 (without write buffer), TLB v4 (with write buffer), and "
"finally TLB v4 (with write buffer, with I TLB invalidate entry). There is "
"more assembly code inside each of these functions, mainly to allow more "
"flexible TLB handling for the future."
msgstr ""

#: ../../../arch/arm/interrupts.rst:16
msgid "Secondly, the IRQ subsystem."
msgstr ""

#: ../../../arch/arm/interrupts.rst:18
msgid ""
"The 2.5 kernels will be having major changes to the way IRQs are handled. "
"Unfortunately, this means that machine types that touch the irq_desc[] array "
"(basically all machine types) will break, and this means every machine type "
"that we currently have."
msgstr ""

#: ../../../arch/arm/interrupts.rst:23
msgid "Lets take an example.  On the Assabet with Neponset, we have::"
msgstr ""

#: ../../../arch/arm/interrupts.rst:32
msgid ""
"The way stuff currently works, all SA1111 interrupts are mutually exclusive "
"of each other - if you're processing one interrupt from the SA1111 and "
"another comes in, you have to wait for that interrupt to finish processing "
"before you can service the new interrupt.  Eg, an IDE PIO-based interrupt on "
"the SA1111 excludes all other SA1111 and SMC9196 interrupts until it has "
"finished transferring its multi-sector data, which can be a long time.  Note "
"also that since we loop in the SA1111 IRQ handler, SA1111 IRQs can hold off "
"SMC9196 IRQs indefinitely."
msgstr ""

#: ../../../arch/arm/interrupts.rst:42
msgid "The new approach brings several new ideas..."
msgstr ""

#: ../../../arch/arm/interrupts.rst:44
msgid ""
"We introduce the concept of a \"parent\" and a \"child\".  For example, to "
"the Neponset handler, the \"parent\" is GPIO25, and the \"children\"d are "
"SA1111, SMC9196 and USAR."
msgstr ""

#: ../../../arch/arm/interrupts.rst:48
msgid ""
"We also bring the idea of an IRQ \"chip\" (mainly to reduce the size of the "
"irqdesc array).  This doesn't have to be a real \"IC\"; indeed the SA11x0 "
"IRQs are handled by two separate \"chip\" structures, one for GPIO0-10, and "
"another for all the rest.  It is just a container for the various operations "
"(maybe this'll change to a better name). This structure has the following "
"operations::"
msgstr ""

#: ../../../arch/arm/interrupts.rst:80
msgid "ack"
msgstr ""

#: ../../../arch/arm/interrupts.rst:81
msgid ""
"required.  May be the same function as mask for IRQs handled by do_level_IRQ."
msgstr ""

#: ../../../arch/arm/interrupts.rst:83
msgid "mask"
msgstr ""

#: ../../../arch/arm/interrupts.rst:84 ../../../arch/arm/interrupts.rst:86
msgid "required."
msgstr ""

#: ../../../arch/arm/interrupts.rst:85
msgid "unmask"
msgstr ""

#: ../../../arch/arm/interrupts.rst:87
msgid "rerun"
msgstr ""

#: ../../../arch/arm/interrupts.rst:88
msgid ""
"optional.  Not required if you're using do_level_IRQ for all IRQs that use "
"this 'irqchip'.  Generally expected to re-trigger the hardware IRQ if "
"possible.  If not, may call the handler directly."
msgstr ""

#: ../../../arch/arm/interrupts.rst:92
msgid "type"
msgstr ""

#: ../../../arch/arm/interrupts.rst:93
msgid ""
"optional.  If you don't support changing the type of an IRQ, it should be "
"null so people can detect if they are unable to set the IRQ type."
msgstr ""

#: ../../../arch/arm/interrupts.rst:97
msgid "For each IRQ, we keep the following information:"
msgstr ""

#: ../../../arch/arm/interrupts.rst:99
msgid "\"disable\" depth (number of disable_irq()s without enable_irq()s)"
msgstr ""

#: ../../../arch/arm/interrupts.rst:100
msgid ""
"flags indicating what we can do with this IRQ (valid, probe, noautounmask) "
"as before"
msgstr ""

#: ../../../arch/arm/interrupts.rst:102
msgid "status of the IRQ (probing, enable, etc)"
msgstr ""

#: ../../../arch/arm/interrupts.rst:103
msgid "chip"
msgstr ""

#: ../../../arch/arm/interrupts.rst:104
msgid "per-IRQ handler"
msgstr ""

#: ../../../arch/arm/interrupts.rst:105
msgid "irqaction structure list"
msgstr ""

#: ../../../arch/arm/interrupts.rst:107
msgid ""
"The handler can be one of the 3 standard handlers - \"level\", \"edge\" and "
"\"simple\", or your own specific handler if you need to do something special."
msgstr ""

#: ../../../arch/arm/interrupts.rst:110
msgid ""
"The \"level\" handler is what we currently have - its pretty simple. "
"\"edge\" knows about the brokenness of such IRQ implementations - that you "
"need to leave the hardware IRQ enabled while processing it, and queueing "
"further IRQ events should the IRQ happen again while processing.  The "
"\"simple\" handler is very basic, and does not perform any hardware "
"manipulation, nor state tracking.  This is useful for things like the "
"SMC9196 and USAR above."
msgstr ""

#: ../../../arch/arm/interrupts.rst:119
msgid "So, what's changed?"
msgstr ""

#: ../../../arch/arm/interrupts.rst:121
msgid "Machine implementations must not write to the irqdesc array."
msgstr ""

#: ../../../arch/arm/interrupts.rst:123
msgid ""
"New functions to manipulate the irqdesc array.  The first 4 are expected to "
"be useful only to machine specific code.  The last is recommended to only be "
"used by machine specific code, but may be used in drivers if absolutely "
"necessary."
msgstr ""

#: ../../../arch/arm/interrupts.rst:128
msgid "set_irq_chip(irq,chip)"
msgstr ""

#: ../../../arch/arm/interrupts.rst:129
msgid "Set the mask/unmask methods for handling this IRQ"
msgstr ""

#: ../../../arch/arm/interrupts.rst:131
msgid "set_irq_handler(irq,handler)"
msgstr ""

#: ../../../arch/arm/interrupts.rst:132
msgid "Set the handler for this IRQ (level, edge, simple)"
msgstr ""

#: ../../../arch/arm/interrupts.rst:134
msgid "set_irq_chained_handler(irq,handler)"
msgstr ""

#: ../../../arch/arm/interrupts.rst:135
msgid ""
"Set a \"chained\" handler for this IRQ - automatically enables this IRQ (eg, "
"Neponset and SA1111 handlers)."
msgstr ""

#: ../../../arch/arm/interrupts.rst:138
msgid "set_irq_flags(irq,flags)"
msgstr ""

#: ../../../arch/arm/interrupts.rst:139
msgid "Set the valid/probe/noautoenable flags."
msgstr ""

#: ../../../arch/arm/interrupts.rst:141
msgid "set_irq_type(irq,type)"
msgstr ""

#: ../../../arch/arm/interrupts.rst:142
msgid ""
"Set active the IRQ edge(s)/level.  This replaces the SA1111 INTPOL "
"manipulation, and the set_GPIO_IRQ_edge() function.  Type should be one of "
"IRQ_TYPE_xxx defined in <linux/irq.h>"
msgstr ""

#: ../../../arch/arm/interrupts.rst:147
msgid ""
"set_GPIO_IRQ_edge() is obsolete, and should be replaced by set_irq_type."
msgstr ""

#: ../../../arch/arm/interrupts.rst:149
msgid ""
"Direct access to SA1111 INTPOL is deprecated.  Use set_irq_type instead."
msgstr ""

#: ../../../arch/arm/interrupts.rst:151
msgid ""
"A handler is expected to perform any necessary acknowledgement of the parent "
"IRQ via the correct chip specific function.  For instance, if the SA1111 is "
"directly connected to a SA1110 GPIO, then you should acknowledge the SA1110 "
"IRQ each time you re-read the SA1111 IRQ status."
msgstr ""

#: ../../../arch/arm/interrupts.rst:156
msgid ""
"For any child which doesn't have its own IRQ enable/disable controls (eg, "
"SMC9196), the handler must mask or acknowledge the parent IRQ while the "
"child handler is called, and the child handler should be the \"simple\" "
"handler (not \"edge\" nor \"level\").  After the handler completes, the "
"parent IRQ should be unmasked, and the status of all children must be re-"
"checked for pending events.  (see the Neponset IRQ handler for details)."
msgstr ""

#: ../../../arch/arm/interrupts.rst:164
msgid "fixup_irq() is gone, as is `arch/arm/mach-*/include/mach/irq.h`"
msgstr ""

#: ../../../arch/arm/interrupts.rst:166
msgid ""
"Please note that this will not solve all problems - some of them are "
"hardware based.  Mixing level-based and edge-based IRQs on the same parent "
"signal (eg neponset) is one such area where a software based solution can't "
"provide the full answer to low IRQ latency."
msgstr ""
