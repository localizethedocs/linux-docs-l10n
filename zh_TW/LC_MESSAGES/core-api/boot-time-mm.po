# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 07:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/boot-time-mm.rst:3
msgid "Boot time memory management"
msgstr ""

#: ../../../core-api/boot-time-mm.rst:5
msgid ""
"Early system initialization cannot use \"normal\" memory management simply "
"because it is not set up yet. But there is still need to allocate memory for "
"various data structures, for instance for the physical page allocator."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:10
msgid ""
"A specialized allocator called ``memblock`` performs the boot time memory "
"management. The architecture specific initialization must set it up in :c:"
"func:`setup_arch` and tear it down in :c:func:`mem_init` functions."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:15
msgid ""
"Once the early memory management is available it offers a variety of "
"functions and macros for memory allocations. The allocation request may be "
"directed to the first (and probably the only) node or to a particular node "
"in a NUMA system. There are API variants that panic when an allocation fails "
"and those that don't."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:21
msgid "Memblock also offers a variety of APIs that control its own behaviour."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:24
msgid "Memblock Overview"
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:43
msgid ""
"Memblock is a method of managing memory regions during the early boot period "
"when the usual kernel memory allocators are not up and running."
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:47
msgid ""
"Memblock views the system memory as collections of contiguous regions. There "
"are several types of these collections:"
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:50
msgid ""
"``memory`` - describes the physical memory available to the kernel; this may "
"differ from the actual physical memory installed in the system, for instance "
"when the memory is restricted with ``mem=`` command line parameter"
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:54
msgid "``reserved`` - describes the regions that were allocated"
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:55
msgid ""
"``physmem`` - describes the actual physical memory available during boot "
"regardless of the possible restrictions and memory hot(un)plug; the "
"``physmem`` type is only available on some architectures."
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:59
msgid ""
"Each region is represented by struct memblock_region that defines the region "
"extents, its attributes and NUMA node id on NUMA systems. Every memory type "
"is described by the struct memblock_type which contains an array of memory "
"regions along with the allocator metadata. The \"memory\" and \"reserved\" "
"types are nicely wrapped with struct memblock. This structure is statically "
"initialized at build time. The region arrays are initially sized to "
"``INIT_MEMBLOCK_MEMORY_REGIONS`` for \"memory\" and "
"``INIT_MEMBLOCK_RESERVED_REGIONS`` for \"reserved\". The region array for "
"\"physmem\" is initially sized to ``INIT_PHYSMEM_REGIONS``. The "
"memblock_allow_resize() enables automatic resizing of the region arrays "
"during addition of new regions. This feature should be used with care so "
"that memory allocated for the region array will not overlap with areas that "
"should be reserved, for example initrd."
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:74
msgid ""
"The early architecture setup should tell memblock what the physical memory "
"layout is by using memblock_add() or memblock_add_node() functions. The "
"first function does not assign the region to a NUMA node and it is "
"appropriate for UMA systems. Yet, it is possible to use it on NUMA systems "
"as well and assign the region to a NUMA node later in the setup process "
"using memblock_set_node(). The memblock_add_node() performs such an "
"assignment directly."
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:82
msgid ""
"Once memblock is setup the memory can be allocated using one of the API "
"variants:"
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:85
msgid ""
"memblock_phys_alloc*() - these functions return the **physical** address of "
"the allocated memory"
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:87
msgid ""
"memblock_alloc*() - these functions return the **virtual** address of the "
"allocated memory."
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:90
msgid ""
"Note, that both API variants use implicit assumptions about allowed memory "
"ranges and the fallback methods. Consult the documentation of "
"memblock_alloc_internal() and memblock_alloc_range_nid() functions for more "
"elaborate description."
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:95
msgid ""
"As the system boot progresses, the architecture specific mem_init() function "
"frees all the memory to the buddy page allocator."
msgstr ""

#: ../../../core-api/boot-time-mm:26: ../mm/memblock.c:98
msgid ""
"Unless an architecture enables ``CONFIG_ARCH_KEEP_MEMBLOCK``, the memblock "
"data structures (except \"physmem\") will be discarded after the system "
"initialization completes."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:31
msgid "Functions and structures"
msgstr ""

#: ../../../core-api/boot-time-mm.rst:33
msgid ""
"Here is the description of memblock data structures, functions and macros. "
"Some of them are actually internal, but since they are documented it would "
"be silly to omit them. Besides, reading the descriptions for the internal "
"functions can help to understand what really happens under the hood."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:28
msgid "definition of memory region attributes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:32
msgid "**Constants**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:34
msgid "``MEMBLOCK_NONE``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:35
msgid "no special request"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:37
msgid "``MEMBLOCK_HOTPLUG``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:38
msgid ""
"memory region indicated in the firmware-provided memory map during early "
"boot as hot(un)pluggable system RAM (e.g., memory range that might get "
"hotunplugged later). With \"movable_node\" set on the kernel commandline, "
"try keeping this memory region hotunpluggable. Does not apply to memblocks "
"added (\"hotplugged\") after early boot."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:44
msgid "``MEMBLOCK_MIRROR``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:45
msgid "mirrored region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:47
msgid "``MEMBLOCK_NOMAP``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:48
msgid ""
"don't add to kernel direct mapping and treat as reserved in the memory map; "
"refer to memblock_mark_nomap() description for further details"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:52
msgid "``MEMBLOCK_DRIVER_MANAGED``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:53
msgid ""
"memory region that is always detected and added via a driver, and never "
"indicated in the firmware-provided memory map as system RAM. This "
"corresponds to IORESOURCE_SYSRAM_DRIVER_MANAGED in the kernel resource tree."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:58
msgid "``MEMBLOCK_RSRV_NOINIT``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:59
msgid ""
"reserved memory region for which struct pages are not fully initialized. "
"Users of this flag are responsible to properly initialize struct pages of "
"this region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:63
msgid "``MEMBLOCK_RSRV_KERN``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:64
msgid ""
"memory region that is reserved for kernel use, either explictitly with "
"memblock_reserve_kern() or via memblock allocation APIs. All memblock "
"allocations set this flag."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:68
msgid "``MEMBLOCK_KHO_SCRATCH``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:69
msgid ""
"memory region that kexec can pass to the next kernel in handover mode. "
"During early boot, we do not know about all memory reservations yet, so we "
"get scratch memory from the previous kernel that we know is good to use. It "
"is the only memory that allocations may happen from in this phase."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:67
msgid "represents a memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:71
#: ../include/linux/memblock.h:87 ../include/linux/memblock.h:103
msgid "**Definition**::"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:82
#: ../include/linux/memblock.h:97 ../include/linux/memblock.h:112
msgid "**Members**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:68
msgid "``base``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:69
#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:988
msgid "base address of the region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:69
msgid "``size``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:70
#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:989
msgid "size of the region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:70
#: ../include/linux/memblock.h:209 ../include/linux/memblock.h:229
#: ../include/linux/memblock.h:333 ../include/linux/memblock.h:349
msgid "``flags``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:71
msgid "memory region attributes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:71
#: ../include/linux/memblock.h:208 ../include/linux/memblock.h:228
#: ../include/linux/memblock.h:317 ../include/linux/memblock.h:332
#: ../include/linux/memblock.h:348
msgid "``nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:72
msgid "NUMA node id"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:83
msgid "collection of memory regions of certain type"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:84
msgid "``cnt``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:85
msgid "number of regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:85
msgid "``max``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:86
msgid "size of the allocated array"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:86
msgid "``total_size``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:87
msgid "size of all regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:87
msgid "``regions``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:88
msgid "array of regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:88
msgid "``name``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:89
msgid "the memory type symbolic name"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:99
msgid "memblock allocator metadata"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:100
msgid "``bottom_up``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:101
msgid "is bottom up direction?"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:101
msgid "``current_limit``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:102
msgid "physical address of the current allocation limit"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:102
msgid "``memory``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:103
msgid "usable memory regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:103
msgid "``reserved``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:104
msgid "reserved memory regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:191
msgid "``for_each_physmem_range (i, type, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:189
msgid "iterate through physmem areas not included in type."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:193
#: ../include/linux/memblock.h:206 ../include/linux/memblock.h:226
#: ../include/linux/memblock.h:247 ../include/linux/memblock.h:258
#: ../include/linux/memblock.h:270 ../include/linux/memblock.h:318
#: ../include/linux/memblock.h:333 ../include/linux/memblock.h:349
#: ../include/linux/memblock.h:507 ../include/linux/memblock.h:526
#: ../include/linux/memblock.h:537 ../include/linux/memblock.h:548
#: ../include/linux/memblock.h:559 ../include/linux/memblock.h:570
#: ../include/linux/memblock.h:579 ../../../core-api/boot-time-mm:40:
#: ../mm/memblock.c:223 ../mm/memblock.c:258 ../mm/memblock.c:297
#: ../mm/memblock.c:334 ../mm/memblock.c:386 ../mm/memblock.c:417
#: ../mm/memblock.c:531 ../mm/memblock.c:567 ../mm/memblock.c:597
#: ../mm/memblock.c:719 ../mm/memblock.c:743 ../mm/memblock.c:764
#: ../mm/memblock.c:798 ../mm/memblock.c:900 ../mm/memblock.c:914
#: ../mm/memblock.c:990 ../mm/memblock.c:1024 ../mm/memblock.c:1036
#: ../mm/memblock.c:1048 ../mm/memblock.c:1065 ../mm/memblock.c:1085
#: ../mm/memblock.c:1097 ../mm/memblock.c:1122 ../mm/memblock.c:1138
#: ../mm/memblock.c:1193 ../mm/memblock.c:1293 ../mm/memblock.c:1421
#: ../mm/memblock.c:1453 ../mm/memblock.c:1552 ../mm/memblock.c:1576
#: ../mm/memblock.c:1595 ../mm/memblock.c:1640 ../mm/memblock.c:1671
#: ../mm/memblock.c:1703 ../mm/memblock.c:1738 ../mm/memblock.c:1758
#: ../mm/memblock.c:1820 ../mm/memblock.c:1993 ../mm/memblock.c:2014
#: ../mm/memblock.c:2341 ../mm/memblock.c:2395 ../mm/memblock.c:2420
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:195
#: ../include/linux/memblock.h:208 ../include/linux/memblock.h:228
#: ../include/linux/memblock.h:249 ../include/linux/memblock.h:260
#: ../include/linux/memblock.h:272 ../include/linux/memblock.h:320
#: ../include/linux/memblock.h:335 ../include/linux/memblock.h:351
msgid "``i``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:190
#: ../include/linux/memblock.h:204 ../include/linux/memblock.h:224
#: ../include/linux/memblock.h:244 ../include/linux/memblock.h:256
#: ../include/linux/memblock.h:267 ../include/linux/memblock.h:330
#: ../include/linux/memblock.h:346
msgid "u64 used as loop variable"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:192
msgid "``type``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:191
msgid "ptr to memblock_type which excludes from the iteration, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:193
#: ../include/linux/memblock.h:210 ../include/linux/memblock.h:230
#: ../include/linux/memblock.h:246 ../include/linux/memblock.h:258
#: ../include/linux/memblock.h:269 ../include/linux/memblock.h:318
#: ../include/linux/memblock.h:334 ../include/linux/memblock.h:350
msgid "``p_start``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:192
#: ../include/linux/memblock.h:209 ../include/linux/memblock.h:229
#: ../include/linux/memblock.h:245 ../include/linux/memblock.h:257
#: ../include/linux/memblock.h:268 ../include/linux/memblock.h:333
#: ../include/linux/memblock.h:349 ../../../core-api/boot-time-mm:40:
#: ../mm/memblock.c:1195 ../mm/memblock.c:1296
msgid "ptr to phys_addr_t for start address of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:194
#: ../include/linux/memblock.h:211 ../include/linux/memblock.h:231
#: ../include/linux/memblock.h:247 ../include/linux/memblock.h:259
#: ../include/linux/memblock.h:270 ../include/linux/memblock.h:319
#: ../include/linux/memblock.h:335 ../include/linux/memblock.h:351
msgid "``p_end``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:193
#: ../include/linux/memblock.h:210 ../include/linux/memblock.h:230
#: ../include/linux/memblock.h:246 ../include/linux/memblock.h:258
#: ../include/linux/memblock.h:269 ../include/linux/memblock.h:334
#: ../include/linux/memblock.h:350 ../../../core-api/boot-time-mm:40:
#: ../mm/memblock.c:1196 ../mm/memblock.c:1297
msgid "ptr to phys_addr_t for end address of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:204
msgid ""
"``__for_each_mem_range (i, type_a, type_b, nid, flags, p_start, p_end, "
"p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:202
msgid ""
"iterate through memblock areas from type_a and not included in type_b. Or "
"just type_a if type_b is NULL."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:206
#: ../include/linux/memblock.h:226
msgid "``type_a``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:205
#: ../include/linux/memblock.h:225
msgid "ptr to memblock_type to iterate"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:207
#: ../include/linux/memblock.h:227
msgid "``type_b``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:206
#: ../include/linux/memblock.h:226
msgid "ptr to memblock_type which excludes from the iteration"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:207
#: ../include/linux/memblock.h:227 ../include/linux/memblock.h:331
#: ../include/linux/memblock.h:347 ../../../core-api/boot-time-mm:40:
#: ../mm/memblock.c:1191 ../mm/memblock.c:1292
msgid "node selector, ``NUMA_NO_NODE`` for all nodes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:208
#: ../include/linux/memblock.h:228 ../include/linux/memblock.h:332
#: ../include/linux/memblock.h:348 ../../../core-api/boot-time-mm:40:
#: ../mm/memblock.c:226 ../mm/memblock.c:261 ../mm/memblock.c:300
#: ../mm/memblock.c:1192 ../mm/memblock.c:1293
msgid "pick from blocks based on memory attributes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:212
#: ../include/linux/memblock.h:232 ../include/linux/memblock.h:320
#: ../include/linux/memblock.h:336 ../include/linux/memblock.h:352
msgid "``p_nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:211
#: ../include/linux/memblock.h:231 ../include/linux/memblock.h:319
#: ../include/linux/memblock.h:335 ../include/linux/memblock.h:351
#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1197
#: ../mm/memblock.c:1298
msgid "ptr to int for nid of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:224
msgid ""
"``__for_each_mem_range_rev (i, type_a, type_b, nid, flags, p_start, p_end, "
"p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:222
#: ../include/linux/memblock.h:254
msgid ""
"reverse iterate through memblock areas from type_a and not included in "
"type_b. Or just type_a if type_b is NULL."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:245
msgid "``for_each_mem_range (i, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:243
msgid "iterate through memory areas."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:256
msgid "``for_each_mem_range_rev (i, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:268
msgid "``for_each_reserved_mem_range (i, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:266
msgid "iterate over all reserved memblock areas"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:271
#: ../include/linux/memblock.h:321 ../include/linux/memblock.h:337
#: ../include/linux/memblock.h:353 ../../../core-api/boot-time-mm:40:
#: ../mm/memblock.c:3 ../mm/memblock.c:228 ../mm/memblock.c:263
#: ../mm/memblock.c:302 ../mm/memblock.c:337 ../mm/memblock.c:418
#: ../mm/memblock.c:571 ../mm/memblock.c:600 ../mm/memblock.c:721
#: ../mm/memblock.c:743 ../mm/memblock.c:765 ../mm/memblock.c:801
#: ../mm/memblock.c:900 ../mm/memblock.c:914 ../mm/memblock.c:993
#: ../mm/memblock.c:1065 ../mm/memblock.c:1099 ../mm/memblock.c:1122
#: ../mm/memblock.c:1199 ../mm/memblock.c:1300 ../mm/memblock.c:1423
#: ../mm/memblock.c:1457 ../mm/memblock.c:1554 ../mm/memblock.c:1577
#: ../mm/memblock.c:1599 ../mm/memblock.c:1647 ../mm/memblock.c:1678
#: ../mm/memblock.c:1709 ../mm/memblock.c:1739 ../mm/memblock.c:1758
#: ../mm/memblock.c:1993 ../mm/memblock.c:2014 ../mm/memblock.c:2396
#: ../mm/memblock.c:2419
msgid "**Description**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:270
msgid ""
"Walks over reserved areas of memblock. Available as soon as memblock is "
"initialized."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:316
msgid "``for_each_mem_pfn_range (i, nid, p_start, p_end, p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:314
msgid "early memory pfn range iterator"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:315
msgid "an integer used as loop variable"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:316
msgid "node selector, ``MAX_NUMNODES`` for all nodes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:317
msgid "ptr to ulong for start pfn of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:318
msgid "ptr to ulong for end pfn of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:320
msgid "Walks over configured memory ranges."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:331
msgid "``for_each_free_mem_range (i, nid, flags, p_start, p_end, p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:329
msgid "iterate through free memblock areas"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:336
msgid ""
"Walks over free (memory && !reserved) areas of memblock.  Available as soon "
"as memblock is initialized."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:347
msgid ""
"``for_each_free_mem_range_reverse (i, nid, flags, p_start, p_end, p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:345
msgid "rev-iterate through free memblock areas"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:352
msgid ""
"Walks over free (memory && !reserved) areas of memblock in reverse order.  "
"Available as soon as memblock is initialized."
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:503
msgid ""
"Set the current allocation limit to allow limiting allocations to what is "
"currently accessible during boot"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:509
msgid "``phys_addr_t limit``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:506
msgid "New limit value (physical address)"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:522
msgid "get the lowest pfn of the memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:528
#: ../include/linux/memblock.h:539 ../include/linux/memblock.h:550
#: ../include/linux/memblock.h:561
msgid "``const struct memblock_region *reg``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:523
#: ../include/linux/memblock.h:534 ../include/linux/memblock.h:545
#: ../include/linux/memblock.h:556
msgid "memblock_region structure"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:525
#: ../include/linux/memblock.h:536 ../include/linux/memblock.h:547
#: ../include/linux/memblock.h:558 ../../../core-api/boot-time-mm:40:
#: ../mm/memblock.c:229 ../mm/memblock.c:264 ../mm/memblock.c:303
#: ../mm/memblock.c:338 ../mm/memblock.c:423 ../mm/memblock.c:604
#: ../mm/memblock.c:723 ../mm/memblock.c:745 ../mm/memblock.c:767
#: ../mm/memblock.c:806 ../mm/memblock.c:994 ../mm/memblock.c:1024
#: ../mm/memblock.c:1036 ../mm/memblock.c:1048 ../mm/memblock.c:1073
#: ../mm/memblock.c:1085 ../mm/memblock.c:1108 ../mm/memblock.c:1124
#: ../mm/memblock.c:1139 ../mm/memblock.c:1425 ../mm/memblock.c:1469
#: ../mm/memblock.c:1555 ../mm/memblock.c:1580 ../mm/memblock.c:1606
#: ../mm/memblock.c:1649 ../mm/memblock.c:1681 ../mm/memblock.c:1711
#: ../mm/memblock.c:1822 ../mm/memblock.c:1994 ../mm/memblock.c:2016
#: ../mm/memblock.c:2397 ../mm/memblock.c:2421
msgid "**Return**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:525
msgid "the lowest pfn intersecting with the memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:533
msgid "get the end pfn of the memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:536
#: ../include/linux/memblock.h:558
msgid "the end_pfn of the reserved region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:544
msgid "get the lowest pfn of the reserved region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:547
msgid "the lowest pfn intersecting with the reserved region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:555
msgid "get the end pfn of the reserved region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:568
msgid "``for_each_mem_region (region)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:566
msgid "iterate over memory regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:572
#: ../include/linux/memblock.h:581
msgid "``region``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:567
#: ../include/linux/memblock.h:576
msgid "loop variable"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:577
msgid "``for_each_reserved_mem_region (region)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: ../include/linux/memblock.h:575
msgid "itereate over reserved memory regions"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:219
msgid "find free area utility in bottom-up"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:225 ../mm/memblock.c:260
#: ../mm/memblock.c:297 ../mm/memblock.c:336 ../mm/memblock.c:1453
#: ../mm/memblock.c:1552
msgid "``phys_addr_t start``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:220 ../mm/memblock.c:255
#: ../mm/memblock.c:296 ../mm/memblock.c:331
msgid "start of candidate range"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:222 ../mm/memblock.c:257
#: ../mm/memblock.c:298 ../mm/memblock.c:333 ../mm/memblock.c:1454
#: ../mm/memblock.c:1553
msgid "``phys_addr_t end``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:221 ../mm/memblock.c:256
#: ../mm/memblock.c:297 ../mm/memblock.c:332
msgid ""
"end of candidate range, can be ``MEMBLOCK_ALLOC_ANYWHERE`` or "
"``MEMBLOCK_ALLOC_ACCESSIBLE``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:224 ../mm/memblock.c:259
#: ../mm/memblock.c:299 ../mm/memblock.c:335 ../mm/memblock.c:568
#: ../mm/memblock.c:597 ../mm/memblock.c:718 ../mm/memblock.c:742
#: ../mm/memblock.c:798 ../mm/memblock.c:913 ../mm/memblock.c:990
#: ../mm/memblock.c:1023 ../mm/memblock.c:1035 ../mm/memblock.c:1047
#: ../mm/memblock.c:1064 ../mm/memblock.c:1084 ../mm/memblock.c:1098
#: ../mm/memblock.c:1121 ../mm/memblock.c:1138 ../mm/memblock.c:1420
#: ../mm/memblock.c:1455 ../mm/memblock.c:1554 ../mm/memblock.c:1578
#: ../mm/memblock.c:1597 ../mm/memblock.c:1642 ../mm/memblock.c:1673
#: ../mm/memblock.c:1705 ../mm/memblock.c:1740 ../mm/memblock.c:1757
#: ../mm/memblock.c:1992 ../mm/memblock.c:2013
msgid "``phys_addr_t size``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:223 ../mm/memblock.c:258
#: ../mm/memblock.c:294 ../mm/memblock.c:334
msgid "size of free area to find"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:225 ../mm/memblock.c:260
#: ../mm/memblock.c:296 ../mm/memblock.c:336 ../mm/memblock.c:1452
#: ../mm/memblock.c:1551 ../mm/memblock.c:1575 ../mm/memblock.c:1594
#: ../mm/memblock.c:1640 ../mm/memblock.c:1671 ../mm/memblock.c:1702
#: ../mm/memblock.c:1737
msgid "``phys_addr_t align``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:224 ../mm/memblock.c:259
#: ../mm/memblock.c:295 ../mm/memblock.c:335
msgid "alignment of free area to find"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:226 ../mm/memblock.c:261
#: ../mm/memblock.c:300 ../mm/memblock.c:569 ../mm/memblock.c:598
#: ../mm/memblock.c:719 ../mm/memblock.c:1192 ../mm/memblock.c:1293
#: ../mm/memblock.c:1422 ../mm/memblock.c:1455 ../mm/memblock.c:1576
#: ../mm/memblock.c:1597 ../mm/memblock.c:1646 ../mm/memblock.c:1677
#: ../mm/memblock.c:1708
msgid "``int nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:225 ../mm/memblock.c:260
#: ../mm/memblock.c:299 ../mm/memblock.c:1454 ../mm/memblock.c:1575
#: ../mm/memblock.c:1596 ../mm/memblock.c:1645 ../mm/memblock.c:1676
#: ../mm/memblock.c:1707
msgid "nid of the free area to find, ``NUMA_NO_NODE`` for any node"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:227 ../mm/memblock.c:262
#: ../mm/memblock.c:301 ../mm/memblock.c:570 ../mm/memblock.c:599
#: ../mm/memblock.c:720 ../mm/memblock.c:1193 ../mm/memblock.c:1294
msgid "``enum memblock_flags flags``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:227
msgid ""
"Utility called from memblock_find_in_range_node(), find free area bottom-up."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:230 ../mm/memblock.c:265
#: ../mm/memblock.c:304 ../mm/memblock.c:339
msgid "Found address on success, 0 on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:254
msgid "find free area utility, in top-down"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:262
msgid ""
"Utility called from memblock_find_in_range_node(), find free area top-down."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:293
msgid "find free area in given range and node"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:301
msgid ""
"Find **size** free area aligned to **align** in the specified range and node."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:330
msgid "find free area in given range"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:336
msgid "Find **size** free area aligned to **align** in the specified range."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:382
msgid "discard memory and reserved arrays if they were allocated"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:388
#: ../mm/memblock.c:1822 ../mm/memblock.c:2343
msgid "``void``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1
msgid "no arguments"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:413
msgid "double the size of the memblock regions array"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:419 ../mm/memblock.c:533
#: ../mm/memblock.c:569 ../mm/memblock.c:599 ../mm/memblock.c:800
#: ../mm/memblock.c:992 ../mm/memblock.c:1421
msgid "``struct memblock_type *type``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:414
msgid "memblock type of the regions array being doubled"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:416
msgid "``phys_addr_t new_area_start``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:415
msgid "starting address of memory range to avoid overlap with"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:417
msgid "``phys_addr_t new_area_size``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:416
msgid "size of memory range to avoid overlap with"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:417
msgid ""
"Double the size of the **type** regions array. If memblock is being used to "
"allocate memory for a new reserved regions array and there is a previously "
"allocated memory range [**new_area_start**, **new_area_start** + "
"**new_area_size**] waiting to be reserved, ensure the memory used by the new "
"array does not overlap."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:424
msgid "0 on success, -1 on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:527
msgid "merge neighboring compatible regions"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:528
msgid "memblock type to scan"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:530
msgid "``unsigned long start_rgn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:529
msgid "start scanning from (**start_rgn** - 1)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:531
msgid "``unsigned long end_rgn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:530
msgid ""
"end scanning at (**end_rgn** - 1) Scan **type** and merge neighboring "
"compatible regions in [**start_rgn** - 1, **end_rgn**)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:563
msgid "insert new memblock region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:564
msgid "memblock type to insert into"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:566
msgid "``int idx``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:565
msgid "index for the insertion point"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:567 ../mm/memblock.c:596
#: ../mm/memblock.c:721 ../mm/memblock.c:745 ../mm/memblock.c:797
#: ../mm/memblock.c:916 ../mm/memblock.c:989 ../mm/memblock.c:1026
#: ../mm/memblock.c:1038 ../mm/memblock.c:1050 ../mm/memblock.c:1067
#: ../mm/memblock.c:1087 ../mm/memblock.c:1099 ../mm/memblock.c:1124
#: ../mm/memblock.c:1140 ../mm/memblock.c:1423 ../mm/memblock.c:1760
#: ../mm/memblock.c:1995 ../mm/memblock.c:2016
msgid "``phys_addr_t base``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:566 ../mm/memblock.c:595
#: ../mm/memblock.c:716 ../mm/memblock.c:740
msgid "base address of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:567 ../mm/memblock.c:596
#: ../mm/memblock.c:717 ../mm/memblock.c:741
msgid "size of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:568
msgid "node id of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:569 ../mm/memblock.c:598
#: ../mm/memblock.c:719
msgid "flags of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:570
msgid ""
"Insert new memblock region [**base**, **base** + **size**) into **type** at "
"**idx**. **type** must already have extra room to accommodate the new region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:593 ../mm/memblock.c:739
msgid "add new memblock region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:594
msgid "memblock type to add new region into"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:597 ../mm/memblock.c:718
msgid "nid of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:599
msgid ""
"Add new memblock region [**base**, **base** + **size**) into **type**.  The "
"new region is allowed to overlap with existing ones - overlaps don't affect "
"already existing regions.  **type** is guaranteed to be minimal (all "
"neighbouring compatible regions are merged) after the addition."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:605 ../mm/memblock.c:724
#: ../mm/memblock.c:746 ../mm/memblock.c:807 ../mm/memblock.c:995
#: ../mm/memblock.c:1024 ../mm/memblock.c:1036 ../mm/memblock.c:1048
#: ../mm/memblock.c:1073 ../mm/memblock.c:1085 ../mm/memblock.c:1109
#: ../mm/memblock.c:1125 ../mm/memblock.c:1139 ../mm/memblock.c:1426
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:715
msgid "add new memblock region within a NUMA node"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:720 ../mm/memblock.c:742
msgid ""
"Add new memblock region [**base**, **base** + **size**) to the \"memory\" "
"type. See memblock_add_range() description for mode details"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:760
msgid ""
"check if amount of memory with no node ID assigned is less than a threshold"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:766
msgid "``unsigned long threshold_bytes``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:762
msgid "maximal memory size that can have unassigned node ID (in bytes)."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:764
msgid ""
"A buggy firmware may report memory that does not belong to any node. Check "
"if amount of such memory is below **threshold_bytes**."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:768
msgid "true on success, false on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:794
msgid "isolate given range into disjoint memblocks"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:795
msgid "memblock type to isolate range for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:796
msgid "base of range to isolate"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:797
msgid "size of range to isolate"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:799
msgid "``int *start_rgn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:798
msgid "out parameter for the start of isolated region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:800
msgid "``int *end_rgn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:799
msgid "out parameter for the end of isolated region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:800
msgid ""
"Walk **type** and ensure that regions don't cross the boundaries defined by "
"[**base**, **base** + **size**).  Crossing regions are split at the "
"boundaries, which may create at most two more regions.  The index of the "
"first region inside the range is returned in ***start_rgn** and the index of "
"the first region after the range is returned in ***end_rgn**."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:896
msgid "free boot memory allocation"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:902
msgid "``void *ptr``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:897
msgid "starting address of the  boot memory allocation"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:899
msgid "``size_t size``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:898 ../mm/memblock.c:912
#: ../mm/memblock.c:1756
msgid "size of the boot memory block in bytes"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:899
msgid ""
"Free boot memory block previously allocated by memblock_alloc_xx() API. The "
"freeing memory will not be released to the buddy allocator."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:910
msgid "free boot memory block"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:911
#: ../mm/memblock.c:1755
msgid "phys starting address of the  boot memory block"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:913
msgid ""
"Free boot memory block previously allocated by memblock_phys_alloc_xx() API. "
"The freeing memory will not be released to the buddy allocator."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:986
msgid "set or clear flag for a memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:987
msgid "memblock type to set/clear flag for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:991
msgid "``int set``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:990
msgid "set or clear the flag"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:992
msgid "``int flag``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:991
msgid "the flag to update"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:992
msgid ""
"This function isolates region [**base**, **base** + **size**), and sets/"
"clears flag"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1020
msgid "Mark hotpluggable memory with flag MEMBLOCK_HOTPLUG."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1021
#: ../mm/memblock.c:1033 ../mm/memblock.c:1045 ../mm/memblock.c:1062
#: ../mm/memblock.c:1082 ../mm/memblock.c:1096 ../mm/memblock.c:1119
#: ../mm/memblock.c:1136
msgid "the base phys addr of the region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1022
#: ../mm/memblock.c:1034 ../mm/memblock.c:1046 ../mm/memblock.c:1063
#: ../mm/memblock.c:1083 ../mm/memblock.c:1097 ../mm/memblock.c:1120
#: ../mm/memblock.c:1137
msgid "the size of the region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1032
msgid "Clear flag MEMBLOCK_HOTPLUG for a specified region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1044
msgid "Mark mirrored memory with flag MEMBLOCK_MIRROR."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1061
msgid "Mark a memory region with flag MEMBLOCK_NOMAP."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1064
msgid ""
"The memory regions marked with ``MEMBLOCK_NOMAP`` will not be added to the "
"direct mapping of the physical memory. These regions will still be covered "
"by the memory map. The struct page representing NOMAP memory frames in the "
"memory map will be PageReserved()"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1069
msgid "**Note**"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1070
msgid ""
"if the memory being marked ``MEMBLOCK_NOMAP`` was allocated from memblock, "
"the caller must inform kmemleak to ignore that memory"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1081
msgid "Clear flag MEMBLOCK_NOMAP for a specified region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1093
msgid "Mark a reserved memory region with flag MEMBLOCK_RSRV_NOINIT"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1098
msgid ""
"The struct pages for the reserved regions marked ``MEMBLOCK_RSRV_NOINIT`` "
"will not be fully initialized to allow the caller optimize their "
"initialization."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1101
msgid ""
"When ``CONFIG_DEFERRED_STRUCT_PAGE_INIT`` is enabled, setting this flag "
"completely bypasses the initialization of struct pages for such region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1104
msgid ""
"When ``CONFIG_DEFERRED_STRUCT_PAGE_INIT`` is disabled, struct pages in this "
"region will be initialized with default values but won't be marked as "
"reserved."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1118
msgid "Mark a memory region as MEMBLOCK_KHO_SCRATCH."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1121
msgid ""
"Only memory regions marked with ``MEMBLOCK_KHO_SCRATCH`` will be considered "
"for allocations during early boot with kexec handover."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1134
msgid "Clear MEMBLOCK_KHO_SCRATCH flag for a specified region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1189
msgid "next function for for_each_free_mem_range() etc."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1195
#: ../mm/memblock.c:1295
msgid "``u64 *idx``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1190
#: ../mm/memblock.c:1291
msgid "pointer to u64 loop variable"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1194
#: ../mm/memblock.c:1295
msgid "``struct memblock_type *type_a``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1193
#: ../mm/memblock.c:1294
msgid "pointer to memblock_type from where the range is taken"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1195
#: ../mm/memblock.c:1296
msgid "``struct memblock_type *type_b``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1194
#: ../mm/memblock.c:1295
msgid "pointer to memblock_type which excludes memory from being taken"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1196
#: ../mm/memblock.c:1297
msgid "``phys_addr_t *out_start``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1197
#: ../mm/memblock.c:1298
msgid "``phys_addr_t *out_end``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1198
#: ../mm/memblock.c:1299
msgid "``int *out_nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1198
msgid ""
"Find the first area from ***idx** which matches **nid**, fill the out "
"parameters, and update ***idx** for the next iteration.  The lower 32bit of "
"***idx** contains index into type_a and the upper 32bit indexes the areas "
"before each region in type_b.  For example, if type_b regions look like the "
"following,"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1204
msgid "0:[0-16), 1:[32-48), 2:[128-130)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1206
msgid "The upper 32bit indexes the following regions."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1208
msgid "0:[0-0), 1:[16-32), 2:[48-128), 3:[130-MAX)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1210
msgid ""
"As both region arrays are sorted, the function advances the two indices in "
"lockstep and returns each intersection."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1289
msgid "generic next function for for_each_*_range_rev()"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1299
msgid ""
"Finds the next range from type_a which is not marked as unsuitable in type_b."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1302
msgid "Reverse of __next_mem_range()."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1417
msgid "set node ID on memblock regions"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1418
msgid "base of area to set node ID for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1419
msgid "size of area to set node ID for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1420
msgid "memblock type to set node ID for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1421
msgid "node ID to set"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1422
msgid ""
"Set the nid of memblock **type** regions in [**base**, **base** + **size**) "
"to **nid**. Regions which cross the area boundaries are split as necessary."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1449
#: ../mm/memblock.c:1591 ../mm/memblock.c:1699
msgid "allocate boot memory block"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1450
#: ../mm/memblock.c:1549 ../mm/memblock.c:1573 ../mm/memblock.c:1592
#: ../mm/memblock.c:1638 ../mm/memblock.c:1669 ../mm/memblock.c:1700
#: ../mm/memblock.c:1735
msgid "size of memory block to be allocated in bytes"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1451
#: ../mm/memblock.c:1550 ../mm/memblock.c:1574 ../mm/memblock.c:1593
#: ../mm/memblock.c:1639 ../mm/memblock.c:1670 ../mm/memblock.c:1701
#: ../mm/memblock.c:1736
msgid "alignment of the region and block's size"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1452
#: ../mm/memblock.c:1594
msgid "the lower bound of the memory region to allocate (phys address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1453
#: ../mm/memblock.c:1595
msgid "the upper bound of the memory region to allocate (phys address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1456
#: ../mm/memblock.c:1598
msgid "``bool exact_nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1455
#: ../mm/memblock.c:1597
msgid "control the allocation fall back to other nodes"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1456
msgid ""
"The allocation is performed from memory region limited by memblock."
"current_limit if **end** == ``MEMBLOCK_ALLOC_ACCESSIBLE``."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1459
msgid ""
"If the specified node can not hold the requested memory and **exact_nid** is "
"false, the allocation falls back to any node in the system."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1462
msgid ""
"For systems with memory mirroring, the allocation is attempted first from "
"the regions with mirroring enabled and then retried from any memory region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1466
msgid ""
"In addition, function using kmemleak_alloc_phys for allocated boot memory "
"block, it is never reported as leaks."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1470
msgid ""
"Physical address of allocated memory block on success, ``0`` on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1548
msgid "allocate a memory block inside specified range"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1551
msgid "the lower bound of the memory region to allocate (physical address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1552
msgid "the upper bound of the memory region to allocate (physical address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1553
msgid "Allocate **size** bytes in the between **start** and **end**."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1556
#: ../mm/memblock.c:1581
msgid ""
"physical address of the allocated memory block on success, ``0`` on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1572
msgid "allocate a memory block from specified NUMA node"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1576
msgid ""
"Allocates memory block from the specified NUMA node. If the node has no "
"available memory, attempts to allocated from any node in the system."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1595
#: ../mm/memblock.c:1641 ../mm/memblock.c:1672 ../mm/memblock.c:1703
msgid "``phys_addr_t min_addr``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1596
#: ../mm/memblock.c:1643 ../mm/memblock.c:1674 ../mm/memblock.c:1705
msgid "``phys_addr_t max_addr``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1598
msgid ""
"Allocates memory block using memblock_alloc_range_nid() and converts the "
"returned physical address to virtual."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1601
msgid ""
"The **min_addr** limit is dropped if it can not be satisfied and the "
"allocation will fall back to memory below **min_addr**. Other constraints, "
"such as node and mirrored memory will be handled again in "
"memblock_alloc_range_nid()."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1607
#: ../mm/memblock.c:1650 ../mm/memblock.c:1682 ../mm/memblock.c:1712
msgid "Virtual address of allocated memory block on success, NULL on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1636
msgid "allocate boot memory block on the exact node without zeroing memory"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1640
#: ../mm/memblock.c:1671 ../mm/memblock.c:1702
msgid ""
"the lower bound of the memory region from where the allocation is preferred "
"(phys address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1642
#: ../mm/memblock.c:1673 ../mm/memblock.c:1704
msgid ""
"the upper bound of the memory region from where the allocation is preferred "
"(phys address), or ``MEMBLOCK_ALLOC_ACCESSIBLE`` to allocate only from "
"memory limited by memblock.current_limit value"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1646
msgid ""
"Public function, provides additional debug information (including caller "
"info), if enabled. Does not zero allocated memory."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1667
msgid "allocate boot memory block without zeroing memory and without panicking"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1677
msgid ""
"Public function, provides additional debug information (including caller "
"info), if enabled. Does not zero allocated memory, does not panic if request "
"cannot be satisfied."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1708
msgid ""
"Public function, provides additional debug information (including caller "
"info), if enabled. This function zeroes the allocated memory."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1734
msgid "Try to allocate memory and panic on failure"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1738
msgid "``const char *func``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1737
msgid "caller func name"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1738
msgid ""
"This function attempts to allocate memory using memblock_alloc, and in case "
"of failure, it calls panic with the formatted message. This function should "
"not be used directly, please use the macro memblock_alloc_or_panic."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1754
msgid "free pages directly to buddy allocator"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1757
msgid ""
"This is only useful when the memblock allocator has already been torn down, "
"but we are still initializing the system.  Pages are released directly to "
"the buddy allocator."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1816
msgid "return estimated number of free pages from memblock point of view"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1817
msgid ""
"During bootup, subsystems might need a rough estimate of the number of free "
"pages in the whole system, before precise numbers are available from the "
"buddy. Especially with CONFIG_DEFERRED_STRUCT_PAGE_INIT, the numbers "
"obtained from the buddy might be very imprecise during bootup."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1824
msgid "An estimated number of free pages from memblock point of view."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1989
msgid "check if a region is a subset of memory"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1990
#: ../mm/memblock.c:2011
msgid "base of region to check"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1991
#: ../mm/memblock.c:2012
msgid "size of region to check"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1992
msgid ""
"Check if the region [**base**, **base** + **size**) is a subset of a memory "
"block."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:1995
msgid "0 if false, non-zero if true"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2010
msgid "check if a region intersects reserved memory"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2013
msgid ""
"Check if the region [**base**, **base** + **size**) intersects a reserved "
"memory block."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2017
msgid "True if they intersect, false if not."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2337
msgid "release free pages to the buddy allocator"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2391
msgid "Find reserved memory region with a given name"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2397
#: ../mm/memblock.c:2422
msgid "``const char *name``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2392
msgid "The name that is attached to a reserved memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2394
msgid "``phys_addr_t *start``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2393
msgid "If found, holds the start address"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2395
msgid "``phys_addr_t *size``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2394
msgid "If found, holds the size of the address."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2395
msgid "**start** and **size** are only updated if **name** is found."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2398
msgid "1 if found or 0 if not found."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2416
msgid "Release reserved memory region with a given name"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2417
msgid "The name that is attatched to a reserved memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2418
msgid ""
"Forcibly release the pages in the reserved memory region so that those "
"memory can be used as free memory. After released the reserved region size "
"becomes 0."
msgstr ""

#: ../../../core-api/boot-time-mm:40: ../mm/memblock.c:2422
msgid "1 if released or 0 if not found."
msgstr ""
