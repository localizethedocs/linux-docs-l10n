# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/memory-hotplug.rst:5
msgid "Memory hotplug"
msgstr "記憶體熱插拔"

#: ../../../core-api/memory-hotplug.rst:8
msgid "Memory hotplug event notifier"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:10
msgid "Hotplugging events are sent to a notification queue."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:13
msgid "Memory notifier"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:15
msgid ""
"There are six types of notification defined in ``include/linux/memory.h``:"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:17
msgid "MEM_GOING_ONLINE"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:18
msgid ""
"Generated before new memory becomes available in order to be able to prepare "
"subsystems to handle memory. The page allocator is still unable to allocate "
"from the new memory."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:22
msgid "MEM_CANCEL_ONLINE"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:23
msgid "Generated if MEM_GOING_ONLINE fails."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:25
msgid "MEM_ONLINE"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:26
msgid ""
"Generated when memory has successfully brought online. The callback may "
"allocate pages from the new memory."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:29
msgid "MEM_GOING_OFFLINE"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:30
msgid ""
"Generated to begin the process of offlining memory. Allocations are no "
"longer possible from the memory but some of the memory to be offlined is "
"still in use. The callback can be used to free memory known to a subsystem "
"from the indicated memory block."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:35
msgid "MEM_CANCEL_OFFLINE"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:36
msgid ""
"Generated if MEM_GOING_OFFLINE fails. Memory is available again from the "
"memory block that we attempted to offline."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:39
msgid "MEM_OFFLINE"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:40
msgid "Generated after offlining memory is complete."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:42
#: ../../../core-api/memory-hotplug.rst:110
msgid "A callback routine can be registered by calling::"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:46
#: ../../../core-api/memory-hotplug.rst:114
msgid ""
"Callback functions with higher values of priority are called before callback "
"functions with lower values."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:49
#: ../../../core-api/memory-hotplug.rst:117
msgid "A callback function must have the following prototype::"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:54
msgid ""
"The first argument of the callback function (self) is a pointer to the block "
"of the notifier chain that points to the callback function itself. The "
"second argument (action) is one of the event types described above. The "
"third argument (arg) passes a pointer of struct memory_notify::"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:64
msgid "start_pfn is start_pfn of online/offline memory."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:65
msgid "nr_pages is # of pages of online/offline memory."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:67
msgid ""
"It is possible to get notified for MEM_CANCEL_ONLINE without having been "
"notified for MEM_GOING_ONLINE, and the same applies to MEM_CANCEL_OFFLINE "
"and MEM_GOING_OFFLINE. This can happen when a consumer fails, meaning we "
"break the callchain and we stop calling the remaining consumers of the "
"notifier. It is then important that users of memory_notify make no "
"assumptions and get prepared to handle such cases."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:75
#: ../../../core-api/memory-hotplug.rst:142
msgid ""
"The callback routine shall return one of the values NOTIFY_DONE, NOTIFY_OK, "
"NOTIFY_BAD, NOTIFY_STOP defined in ``include/linux/notifier.h``"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:79
#: ../../../core-api/memory-hotplug.rst:146
msgid "NOTIFY_DONE and NOTIFY_OK have no effect on the further processing."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:81
msgid ""
"NOTIFY_BAD is used as response to the MEM_GOING_ONLINE, MEM_GOING_OFFLINE, "
"MEM_ONLINE, or MEM_OFFLINE action to cancel hotplugging. It stops further "
"processing of the notification queue."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:85
#: ../../../core-api/memory-hotplug.rst:153
msgid "NOTIFY_STOP stops further processing of the notification queue."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:88
msgid "Numa node notifier"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:90
msgid ""
"There are six types of notification defined in ``include/linux/node.h``:"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:92
msgid "NODE_ADDING_FIRST_MEMORY"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:93
msgid ""
"Generated before memory becomes available to this node for the first time."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:95
msgid "NODE_CANCEL_ADDING_FIRST_MEMORY"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:96
msgid "Generated if NODE_ADDING_FIRST_MEMORY fails."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:98
msgid "NODE_ADDED_FIRST_MEMORY"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:99
msgid ""
"Generated when memory has become available fo this node for the first time."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:101
msgid "NODE_REMOVING_LAST_MEMORY"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:102
msgid ""
"Generated when the last memory available to this node is about to be "
"offlined."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:104
msgid "NODE_CANCEL_REMOVING_LAST_MEMORY"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:105
msgid "Generated when NODE_CANCEL_REMOVING_LAST_MEMORY fails."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:107
msgid "NODE_REMOVED_LAST_MEMORY"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:108
msgid ""
"Generated when the last memory available to this node has been offlined."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:123
msgid ""
"The first argument of the callback function (self) is a pointer to the block "
"of the notifier chain that points to the callback function itself. The "
"second argument (action) is one of the event types described above. The "
"third argument (arg) passes a pointer of struct node_notify::"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:132
msgid "nid is the node we are adding or removing memory to."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:134
msgid ""
"It is possible to get notified for NODE_CANCEL_ADDING_FIRST_MEMORY without "
"having been notified for NODE_ADDING_FIRST_MEMORY, and the same applies to "
"NODE_CANCEL_REMOVING_LAST_MEMORY and NODE_REMOVING_LAST_MEMORY. This can "
"happen when a consumer fails, meaning we break the callchain and we stop "
"calling the remaining consumers of the notifier. It is then important that "
"users of node_notify make no assumptions and get prepared to handle such "
"cases."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:148
msgid ""
"NOTIFY_BAD is used as response to the NODE_ADDING_FIRST_MEMORY, "
"NODE_REMOVING_LAST_MEMORY, NODE_ADDED_FIRST_MEMORY or "
"NODE_REMOVED_LAST_MEMORY action to cancel hotplugging. It stops further "
"processing of the notification queue."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:155
msgid ""
"Please note that we should not fail for NODE_ADDED_FIRST_MEMORY / "
"NODE_REMOVED_FIRST_MEMORY, as memory_hotplug code cannot rollback at that "
"point anymore."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:160
msgid "Locking Internals"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:162
msgid ""
"When adding/removing memory that uses memory block devices (i.e. ordinary "
"RAM), the device_hotplug_lock should be held to:"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:165
msgid ""
"synchronize against online/offline requests (e.g. via sysfs). This way, "
"memory block devices can only be accessed (.online/.state attributes) by "
"user space once memory has been fully added. And when removing memory, we "
"know nobody is in critical sections."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:169
msgid ""
"synchronize against CPU hotplug and similar (e.g. relevant for ACPI and PPC)"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:171
msgid ""
"Especially, there is a possible lock inversion that is avoided using "
"device_hotplug_lock when adding memory and user space tries to online that "
"memory faster than expected:"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:175
msgid ""
"device_online() will first take the device_lock(), followed by "
"mem_hotplug_lock"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:177
msgid ""
"add_memory_resource() will first take the mem_hotplug_lock, followed by the "
"device_lock() (while creating the devices, during bus_add_device())."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:180
msgid ""
"As the device is visible to user space before taking the device_lock(), this "
"can result in a lock inversion."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:183
msgid ""
"onlining/offlining of memory should be done via device_online()/ "
"device_offline() - to make sure it is properly synchronized to actions via "
"sysfs. Holding device_hotplug_lock is advised (to e.g. protect online_type)"
msgstr ""

#: ../../../core-api/memory-hotplug.rst:187
msgid ""
"When adding/removing/onlining/offlining memory or adding/removing "
"heterogeneous/device memory, we should always hold the mem_hotplug_lock in "
"write mode to serialise memory hotplug (e.g. access to global/zone "
"variables)."
msgstr ""

#: ../../../core-api/memory-hotplug.rst:192
msgid ""
"In addition, mem_hotplug_lock (in contrast to device_hotplug_lock) in read "
"mode allows for a quite efficient get_online_mems/put_online_mems "
"implementation, so code accessing memory can protect from that memory "
"vanishing."
msgstr ""
