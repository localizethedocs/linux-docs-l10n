# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/ext4/attributes.rst:4
msgid "Extended Attributes"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:6
msgid ""
"Extended attributes (xattrs) are typically stored in a separate data block "
"on the disk and referenced from inodes via ``inode.i_file_acl*``. The first "
"use of extended attributes seems to have been for storing file ACLs and "
"other security data (selinux). With the ``user_xattr`` mount option it is "
"possible for users to store extended attributes so long as all attribute "
"names begin with “user”; this restriction seems to have disappeared as of "
"Linux 3.0."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:14
msgid ""
"There are two places where extended attributes can be found. The first place "
"is between the end of each inode entry and the beginning of the next inode "
"entry. For example, if inode.i_extra_isize = 28 and sb.inode_size = 256, "
"then there are 256 - (128 + 28) = 100 bytes available for in-inode extended "
"attribute storage. The second place where extended attributes can be found "
"is in the block pointed to by ``inode.i_file_acl``. As of Linux 3.11, it is "
"not possible for this block to contain a pointer to a second extended "
"attribute block (or even the remaining blocks of a cluster). In theory it is "
"possible for each attribute's value to be stored in a separate data block, "
"though as of Linux 3.11 the code does not permit this."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:26
msgid ""
"Keys are generally assumed to be ASCIIZ strings, whereas values can be "
"strings or binary data."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:29
msgid ""
"Extended attributes, when stored after the inode, have a header "
"``ext4_xattr_ibody_header`` that is 4 bytes long:"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:36
#: ../../../filesystems/ext4/attributes.rst:53
#: ../../../filesystems/ext4/attributes.rst:98
msgid "Offset"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:37
#: ../../../filesystems/ext4/attributes.rst:54
#: ../../../filesystems/ext4/attributes.rst:99
msgid "Type"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:38
#: ../../../filesystems/ext4/attributes.rst:55
#: ../../../filesystems/ext4/attributes.rst:100
msgid "Name"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:39
#: ../../../filesystems/ext4/attributes.rst:56
#: ../../../filesystems/ext4/attributes.rst:101
msgid "Description"
msgstr "描述"

#: ../../../filesystems/ext4/attributes.rst:40
#: ../../../filesystems/ext4/attributes.rst:57
#: ../../../filesystems/ext4/attributes.rst:102
msgid "0x0"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:41
#: ../../../filesystems/ext4/attributes.rst:58
#: ../../../filesystems/ext4/attributes.rst:62
#: ../../../filesystems/ext4/attributes.rst:66
#: ../../../filesystems/ext4/attributes.rst:70
#: ../../../filesystems/ext4/attributes.rst:74
#: ../../../filesystems/ext4/attributes.rst:118
#: ../../../filesystems/ext4/attributes.rst:124
#: ../../../filesystems/ext4/attributes.rst:128
msgid "__le32"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:42
#: ../../../filesystems/ext4/attributes.rst:59
msgid "h_magic"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:43
msgid ""
"Magic number for identification, 0xEA020000. This value is set by the Linux "
"driver, though e2fsprogs doesn't seem to check it(?)"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:46
msgid ""
"The beginning of an extended attribute block is in ``struct "
"ext4_xattr_header``, which is 32 bytes long:"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:60
msgid "Magic number for identification, 0xEA020000."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:61
#: ../../../filesystems/ext4/attributes.rst:117
msgid "0x4"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:63
msgid "h_refcount"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:64
msgid "Reference count."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:65
#: ../../../filesystems/ext4/attributes.rst:123
msgid "0x8"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:67
msgid "h_blocks"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:68
msgid "Number of disk blocks used."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:69
#: ../../../filesystems/ext4/attributes.rst:127
msgid "0xC"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:71
msgid "h_hash"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:72
msgid "Hash value of all attributes."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:73
#: ../../../filesystems/ext4/attributes.rst:134
msgid "0x10"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:75
msgid "h_checksum"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:76
msgid "Checksum of the extended attribute block."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:77
msgid "0x14"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:78
msgid "__u32"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:79
msgid "h_reserved[3]"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:80
msgid "Zero."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:82
msgid ""
"The checksum is calculated against the FS UUID, the 64-bit block number of "
"the extended attribute block, and the entire block (header + entries)."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:86
msgid ""
"Following the ``struct ext4_xattr_header`` or ``struct "
"ext4_xattr_ibody_header`` is an array of ``struct ext4_xattr_entry``; each "
"of these entries is at least 16 bytes long. When stored in an external "
"block, the ``struct ext4_xattr_entry`` entries must be stored in sorted "
"order. The sort order is ``e_name_index``, then ``e_name_len``, and finally "
"``e_name``. Attributes stored inside an inode do not need be stored in "
"sorted order."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:103
#: ../../../filesystems/ext4/attributes.rst:107
msgid "__u8"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:104
msgid "e_name_len"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:105
msgid "Length of name."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:106
msgid "0x1"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:108
msgid "e_name_index"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:109
msgid "Attribute name index. There is a discussion of this below."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:110
msgid "0x2"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:111
msgid "__le16"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:112
msgid "e_value_offs"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:113
msgid ""
"Location of this attribute's value on the disk block where it is stored. "
"Multiple attributes can share the same value. For an inode attribute this "
"value is relative to the start of the first entry; for a block this value is "
"relative to the start of the block (i.e. the header)."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:119
msgid "e_value_inum"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:120
msgid ""
"The inode where the value is stored. Zero indicates the value is in the same "
"block as this entry. This field is only used if the INCOMPAT_EA_INODE "
"feature is enabled."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:125
msgid "e_value_size"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:126
msgid "Length of attribute value."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:129
msgid "e_hash"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:130
msgid ""
"Hash value of attribute name and attribute value. The kernel doesn't update "
"the hash for in-inode attributes, so for that case this value must be zero, "
"because e2fsck validates any non-zero hash regardless of where the xattr "
"lives."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:135
msgid "char"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:136
msgid "e_name[e_name_len]"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:137
msgid "Attribute name. Does not include trailing NULL."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:139
msgid ""
"Attribute values can follow the end of the entry table. There appears to be "
"a requirement that they be aligned to 4-byte boundaries. The values are "
"stored starting at the end of the block and grow towards the xattr_header/"
"xattr_entry table. When the two collide, the overflow is put into a separate "
"disk block. If the disk block fills up, the filesystem returns -ENOSPC."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:146
msgid ""
"The first four fields of the ``ext4_xattr_entry`` are set to zero to mark "
"the end of the key list."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:150
msgid "Attribute Name Indices"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:152
msgid ""
"Logically speaking, extended attributes are a series of key=value pairs. The "
"keys are assumed to be NULL-terminated strings. To reduce the amount of on-"
"disk space that the keys consume, the beginning of the key string is matched "
"against the attribute name index. If a match is found, the attribute name "
"index field is set, and matching string is removed from the key name. Here "
"is a map of name index values to key prefixes:"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:163
msgid "Name Index"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:164
msgid "Key Prefix"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:165
msgid "0"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:166
msgid "(no prefix)"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:167
msgid "1"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:168
msgid "“user.”"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:169
msgid "2"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:170
msgid "“system.posix_acl_access”"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:171
msgid "3"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:172
msgid "“system.posix_acl_default”"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:173
msgid "4"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:174
msgid "“trusted.”"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:175
msgid "6"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:176
msgid "“security.”"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:177
msgid "7"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:178
msgid "“system.” (inline_data only?)"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:179
msgid "8"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:180
msgid "“system.richacl” (SuSE kernels only?)"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:182
msgid ""
"For example, if the attribute key is “user.fubar”, the attribute name index "
"is set to 1 and the “fubar” name is recorded on disk."
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:186
msgid "POSIX ACLs"
msgstr ""

#: ../../../filesystems/ext4/attributes.rst:188
msgid ""
"POSIX ACLs are stored in a reduced version of the Linux kernel (and "
"libacl's) internal ACL format. The key difference is that the version number "
"is different (1) and the ``e_id`` field is only stored for named user and "
"group ACLs."
msgstr ""
