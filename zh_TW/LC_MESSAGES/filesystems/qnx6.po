# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/qnx6.rst:5
msgid "The QNX6 Filesystem"
msgstr ""

#: ../../../filesystems/qnx6.rst:7
msgid ""
"The qnx6fs is used by newer QNX operating system versions. (e.g. Neutrino) "
"It got introduced in QNX 6.4.0 and is used default since 6.4.1."
msgstr ""

#: ../../../filesystems/qnx6.rst:11
msgid "Option"
msgstr ""

#: ../../../filesystems/qnx6.rst:13
msgid ""
"mmi_fs          Mount filesystem as used for example by Audi MMI 3G system"
msgstr ""

#: ../../../filesystems/qnx6.rst:16
msgid "Specification"
msgstr ""

#: ../../../filesystems/qnx6.rst:18
msgid ""
"qnx6fs shares many properties with traditional Unix filesystems. It has the "
"concepts of blocks, inodes and directories."
msgstr ""

#: ../../../filesystems/qnx6.rst:21
msgid ""
"On QNX it is possible to create little endian and big endian qnx6 "
"filesystems. This feature makes it possible to create and use a different "
"endianness fs for the target (QNX is used on quite a range of embedded "
"systems) platform running on a different endianness."
msgstr ""

#: ../../../filesystems/qnx6.rst:26
msgid "The Linux driver handles endianness transparently. (LE and BE)"
msgstr ""

#: ../../../filesystems/qnx6.rst:29
msgid "Blocks"
msgstr ""

#: ../../../filesystems/qnx6.rst:31
msgid ""
"The space in the device or file is split up into blocks. These are a fixed "
"size of 512, 1024, 2048 or 4096, which is decided when the filesystem is "
"created."
msgstr ""

#: ../../../filesystems/qnx6.rst:35
msgid ""
"Blockpointers are 32bit, so the maximum space that can be addressed is 2^32 "
"* 4096 bytes or 16TB"
msgstr ""

#: ../../../filesystems/qnx6.rst:39
msgid "The superblocks"
msgstr ""

#: ../../../filesystems/qnx6.rst:41
msgid ""
"The superblock contains all global information about the filesystem. Each "
"qnx6fs got two superblocks, each one having a 64bit serial number. That "
"serial number is used to identify the \"active\" superblock. In write mode "
"with reach new snapshot (after each synchronous write), the serial of the "
"new master superblock is increased (old superblock serial + 1)"
msgstr ""

#: ../../../filesystems/qnx6.rst:47
msgid ""
"So basically the snapshot functionality is realized by an atomic final "
"update of the serial number. Before updating that serial, all modifications "
"are done by copying all modified blocks during that specific write request "
"(or period) and building up a new (stable) filesystem structure under the "
"inactive superblock."
msgstr ""

#: ../../../filesystems/qnx6.rst:53
msgid ""
"Each superblock holds a set of root inodes for the different filesystem "
"parts. (Inode, Bitmap and Longfilenames) Each of these root nodes holds "
"information like total size of the stored data and the addressing levels in "
"that specific tree. If the level value is 0, up to 16 direct blocks can be "
"addressed by each node."
msgstr ""

#: ../../../filesystems/qnx6.rst:60
msgid ""
"Level 1 adds an additional indirect addressing level where each indirect "
"addressing block holds up to blocksize / 4 bytes pointers to data blocks. "
"Level 2 adds an additional indirect addressing block level (so, already up "
"to 16 * 256 * 256 = 1048576 blocks that can be addressed by such a tree)."
msgstr ""

#: ../../../filesystems/qnx6.rst:65
msgid ""
"Unused block pointers are always set to ~0 - regardless of root node, "
"indirect addressing blocks or inodes."
msgstr ""

#: ../../../filesystems/qnx6.rst:68
msgid ""
"Data leaves are always on the lowest level. So no data is stored on upper "
"tree levels."
msgstr ""

#: ../../../filesystems/qnx6.rst:71
msgid ""
"The first Superblock is located at 0x2000. (0x2000 is the bootblock size) "
"The Audi MMI 3G first superblock directly starts at byte 0."
msgstr ""

#: ../../../filesystems/qnx6.rst:74
msgid ""
"Second superblock position can either be calculated from the superblock "
"information (total number of filesystem blocks) or by taking the highest "
"device address, zeroing the last 3 bytes and then subtracting 0x1000 from "
"that address."
msgstr ""

#: ../../../filesystems/qnx6.rst:79
msgid ""
"0x1000 is the size reserved for each superblock - regardless of the "
"blocksize of the filesystem."
msgstr ""

#: ../../../filesystems/qnx6.rst:83
msgid "Inodes"
msgstr ""

#: ../../../filesystems/qnx6.rst:85
msgid ""
"Each object in the filesystem is represented by an inode. (index node) The "
"inode structure contains pointers to the filesystem blocks which contain the "
"data held in the object and all of the metadata about an object except its "
"longname. (filenames longer than 27 characters) The metadata about an object "
"includes the permissions, owner, group, flags, size, number of blocks used, "
"access time, change time and modification time."
msgstr ""

#: ../../../filesystems/qnx6.rst:92
msgid "Object mode field is POSIX format. (which makes things easier)"
msgstr ""

#: ../../../filesystems/qnx6.rst:94
msgid ""
"There are also pointers to the first 16 blocks, if the object data can be "
"addressed with 16 direct blocks."
msgstr ""

#: ../../../filesystems/qnx6.rst:97
msgid ""
"For more than 16 blocks an indirect addressing in form of another tree is "
"used. (scheme is the same as the one used for the superblock root nodes)"
msgstr ""

#: ../../../filesystems/qnx6.rst:100
msgid ""
"The filesize is stored 64bit. Inode counting starts with 1. (while long "
"filename inodes start with 0)"
msgstr ""

#: ../../../filesystems/qnx6.rst:104
msgid "Directories"
msgstr ""

#: ../../../filesystems/qnx6.rst:106
msgid ""
"A directory is a filesystem object and has an inode just like a file. It is "
"a specially formatted file containing records which associate each name with "
"an inode number."
msgstr ""

#: ../../../filesystems/qnx6.rst:110
msgid "'.' inode number points to the directory inode"
msgstr ""

#: ../../../filesystems/qnx6.rst:112
msgid "'..' inode number points to the parent directory inode"
msgstr ""

#: ../../../filesystems/qnx6.rst:114
msgid "Eeach filename record additionally got a filename length field."
msgstr ""

#: ../../../filesystems/qnx6.rst:116
msgid "One special case are long filenames or subdirectory names."
msgstr ""

#: ../../../filesystems/qnx6.rst:118
msgid ""
"These got set a filename length field of 0xff in the corresponding directory "
"record plus the longfile inode number also stored in that record."
msgstr ""

#: ../../../filesystems/qnx6.rst:121
msgid ""
"With that longfilename inode number, the longfilename tree can be walked "
"starting with the superblock longfilename root node pointers."
msgstr ""

#: ../../../filesystems/qnx6.rst:125
msgid "Special files"
msgstr ""

#: ../../../filesystems/qnx6.rst:127
msgid ""
"Symbolic links are also filesystem objects with inodes. They got a specific "
"bit in the inode mode field identifying them as symbolic link."
msgstr ""

#: ../../../filesystems/qnx6.rst:130
msgid "The directory entry file inode pointer points to the target file inode."
msgstr ""

#: ../../../filesystems/qnx6.rst:132
msgid ""
"Hard links got an inode, a directory entry, but a specific mode bit set, no "
"block pointers and the directory file record pointing to the target file "
"inode."
msgstr ""

#: ../../../filesystems/qnx6.rst:136
msgid ""
"Character and block special devices do not exist in QNX as those files are "
"handled by the QNX kernel/drivers and created in /dev independent of the "
"underlying filesystem."
msgstr ""

#: ../../../filesystems/qnx6.rst:141
msgid "Long filenames"
msgstr ""

#: ../../../filesystems/qnx6.rst:143
msgid ""
"Long filenames are stored in a separate addressing tree. The staring point "
"is the longfilename root node in the active superblock."
msgstr ""

#: ../../../filesystems/qnx6.rst:146
msgid ""
"Each data block (tree leaves) holds one long filename. That filename is "
"limited to 510 bytes. The first two starting bytes are used as length field "
"for the actual filename."
msgstr ""

#: ../../../filesystems/qnx6.rst:150
msgid ""
"If that structure shall fit for all allowed blocksizes, it is clear why "
"there is a limit of 510 bytes for the actual filename stored."
msgstr ""

#: ../../../filesystems/qnx6.rst:154
msgid "Bitmap"
msgstr ""

#: ../../../filesystems/qnx6.rst:156
msgid ""
"The qnx6fs filesystem allocation bitmap is stored in a tree under bitmap "
"root node in the superblock and each bit in the bitmap represents one "
"filesystem block."
msgstr ""

#: ../../../filesystems/qnx6.rst:160
msgid ""
"The first block is block 0, which starts 0x1000 after superblock start. So "
"for a normal qnx6fs 0x3000 (bootblock + superblock) is the physical address "
"at which block 0 is located."
msgstr ""

#: ../../../filesystems/qnx6.rst:164
msgid ""
"Bits at the end of the last bitmap block are set to 1, if the device is "
"smaller than addressing space in the bitmap."
msgstr ""

#: ../../../filesystems/qnx6.rst:168
msgid "Bitmap system area"
msgstr ""

#: ../../../filesystems/qnx6.rst:170
msgid "The bitmap itself is divided into three parts."
msgstr ""

#: ../../../filesystems/qnx6.rst:172
msgid "First the system area, that is split into two halves."
msgstr ""

#: ../../../filesystems/qnx6.rst:174
msgid "Then userspace."
msgstr ""

#: ../../../filesystems/qnx6.rst:176
msgid ""
"The requirement for a static, fixed preallocated system area comes from how "
"qnx6fs deals with writes."
msgstr ""

#: ../../../filesystems/qnx6.rst:179
msgid ""
"Each superblock got its own half of the system area. So superblock #1 always "
"uses blocks from the lower half while superblock #2 just writes to blocks "
"represented by the upper half bitmap system area bits."
msgstr ""

#: ../../../filesystems/qnx6.rst:183
msgid ""
"Bitmap blocks, Inode blocks and indirect addressing blocks for those two "
"tree structures are treated as system blocks."
msgstr ""

#: ../../../filesystems/qnx6.rst:186
msgid ""
"The rational behind that is that a write request can work on a new snapshot "
"(system area of the inactive - resp. lower serial numbered superblock) while "
"at the same time there is still a complete stable filesystem structure in "
"the other half of the system area."
msgstr ""

#: ../../../filesystems/qnx6.rst:191
msgid ""
"When finished with writing (a sync write is completed, the maximum sync leap "
"time or a filesystem sync is requested), serial of the previously inactive "
"superblock atomically is increased and the fs switches over to that - then "
"stable declared - superblock."
msgstr ""

#: ../../../filesystems/qnx6.rst:196
msgid ""
"For all data outside the system area, blocks are just copied while writing."
msgstr ""
