# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../hid/hiddev.rst:3
msgid "Care and feeding of your Human Interface Devices"
msgstr ""

#: ../../../hid/hiddev.rst:6
msgid "Introduction"
msgstr ""

#: ../../../hid/hiddev.rst:8
msgid ""
"In addition to the normal input type HID devices, USB also uses the human "
"interface device protocols for things that are not really human interfaces, "
"but have similar sorts of communication needs. The two big examples for this "
"are power devices (especially uninterruptible power supplies) and monitor "
"control on higher end monitors."
msgstr ""

#: ../../../hid/hiddev.rst:14
msgid ""
"To support these disparate requirements, the Linux USB system provides HID "
"events to two separate interfaces: * the input subsystem, which converts HID "
"events into normal input device interfaces (such as keyboard, mouse and "
"joystick) and a normalised event interface - see Documentation/input/input."
"rst * the hiddev interface, which provides fairly raw HID events"
msgstr ""

#: ../../../hid/hiddev.rst:21
msgid ""
"The data flow for a HID event produced by a device is something like the "
"following::"
msgstr ""

#: ../../../hid/hiddev.rst:29
msgid ""
"In addition, other subsystems (apart from USB) can potentially feed events "
"into the input subsystem, but these have no effect on the HID device "
"interface."
msgstr ""

#: ../../../hid/hiddev.rst:34
msgid "Using the HID Device Interface"
msgstr ""

#: ../../../hid/hiddev.rst:36
msgid ""
"The hiddev interface is a char interface using the normal USB major, with "
"the minor numbers starting at 96 and finishing at 111. Therefore, you need "
"the following commands::"
msgstr ""

#: ../../../hid/hiddev.rst:57
msgid ""
"So you point your hiddev compliant user-space program at the correct "
"interface for your device, and it all just works."
msgstr ""

#: ../../../hid/hiddev.rst:60
msgid ""
"Assuming that you have a hiddev compliant user-space program, of course. If "
"you need to write one, read on."
msgstr ""

#: ../../../hid/hiddev.rst:65
msgid "The HIDDEV API"
msgstr ""

#: ../../../hid/hiddev.rst:67
msgid ""
"This description should be read in conjunction with the HID specification, "
"freely available from https://www.usb.org, and conveniently linked of http://"
"www.linux-usb.org."
msgstr ""

#: ../../../hid/hiddev.rst:71
msgid "The hiddev API uses a read() interface, and a set of ioctl() calls."
msgstr ""

#: ../../../hid/hiddev.rst:73
msgid ""
"HID devices exchange data with the host computer using data bundles called "
"\"reports\".  Each report is divided into \"fields\", each of which can have "
"one or more \"usages\".  In the hid-core, each one of these usages has a "
"single signed 32-bit value."
msgstr ""

#: ../../../hid/hiddev.rst:79
msgid "read():"
msgstr ""

#: ../../../hid/hiddev.rst:81
msgid ""
"This is the event interface.  When the HID device's state changes, it "
"performs an interrupt transfer containing a report which contains the "
"changed value.  The hid-core.c module parses the report, and returns to "
"hiddev.c the individual usages that have changed within the report.  In its "
"basic mode, the hiddev will make these individual usage changes available to "
"the reader using a struct hiddev_event::"
msgstr ""

#: ../../../hid/hiddev.rst:93
msgid ""
"containing the HID usage identifier for the status that changed, and the "
"value that it was changed to. Note that the structure is defined within "
"<linux/hiddev.h>, along with some other useful #defines and structures.  The "
"HID usage identifier is a composite of the HID usage page shifted to the 16 "
"high order bits ORed with the usage code.  The behavior of the read() "
"function can be modified using the HIDIOCSFLAG ioctl() described below."
msgstr ""

#: ../../../hid/hiddev.rst:103
msgid "ioctl():"
msgstr ""

#: ../../../hid/hiddev.rst:105
msgid "This is the control interface. There are a number of controls:"
msgstr ""

#: ../../../hid/hiddev.rst:107
msgid "HIDIOCGVERSION"
msgstr ""

#: ../../../hid/hiddev.rst:108 ../../../hid/hiddev.rst:230
msgid "int (read)"
msgstr ""

#: ../../../hid/hiddev.rst:110
msgid "Gets the version code out of the hiddev driver."
msgstr ""

#: ../../../hid/hiddev.rst:112
msgid "HIDIOCAPPLICATION"
msgstr ""

#: ../../../hid/hiddev.rst:113 ../../../hid/hiddev.rst:147
msgid "(none)"
msgstr ""

#: ../../../hid/hiddev.rst:115
msgid ""
"This ioctl call returns the HID application usage associated with the HID "
"device. The third argument to ioctl() specifies which application index to "
"get. This is useful when the device has more than one application "
"collection. If the index is invalid (greater or equal to the number of "
"application collections this device has) the ioctl returns -1. You can find "
"out beforehand how many application collections the device has from the "
"num_applications field from the hiddev_devinfo structure."
msgstr ""

#: ../../../hid/hiddev.rst:124
msgid "HIDIOCGCOLLECTIONINFO"
msgstr ""

#: ../../../hid/hiddev.rst:125
msgid "struct hiddev_collection_info (read/write)"
msgstr ""

#: ../../../hid/hiddev.rst:127
msgid ""
"This returns a superset of the information above, providing not only "
"application collections, but all the collections the device has.  It also "
"returns the level the collection lives in the hierarchy. The user passes in "
"a hiddev_collection_info struct with the index field set to the index that "
"should be returned.  The ioctl fills in the other fields.  If the index is "
"larger than the last collection index, the ioctl returns -1 and sets errno "
"to -EINVAL."
msgstr ""

#: ../../../hid/hiddev.rst:135
msgid "HIDIOCGDEVINFO"
msgstr ""

#: ../../../hid/hiddev.rst:136
msgid "struct hiddev_devinfo (read)"
msgstr ""

#: ../../../hid/hiddev.rst:138
msgid "Gets a hiddev_devinfo structure which describes the device."
msgstr ""

#: ../../../hid/hiddev.rst:140
msgid "HIDIOCGSTRING"
msgstr ""

#: ../../../hid/hiddev.rst:141
msgid "struct hiddev_string_descriptor (read/write)"
msgstr ""

#: ../../../hid/hiddev.rst:143
msgid ""
"Gets a string descriptor from the device. The caller must fill in the "
"\"index\" field to indicate which descriptor should be returned."
msgstr ""

#: ../../../hid/hiddev.rst:146
msgid "HIDIOCINITREPORT"
msgstr ""

#: ../../../hid/hiddev.rst:149
msgid ""
"Instructs the kernel to retrieve all input and feature report values from "
"the device. At this point, all the usage structures will contain current "
"values for the device, and will maintain it as the device changes.  Note "
"that the use of this ioctl is unnecessary in general, since later kernels "
"automatically initialize the reports from the device at attach time."
msgstr ""

#: ../../../hid/hiddev.rst:156
msgid "HIDIOCGNAME"
msgstr ""

#: ../../../hid/hiddev.rst:157
msgid "string (variable length)"
msgstr ""

#: ../../../hid/hiddev.rst:159
msgid "Gets the device name"
msgstr ""

#: ../../../hid/hiddev.rst:161
msgid "HIDIOCGREPORT"
msgstr ""

#: ../../../hid/hiddev.rst:162 ../../../hid/hiddev.rst:169
msgid "struct hiddev_report_info (write)"
msgstr ""

#: ../../../hid/hiddev.rst:164
msgid ""
"Instructs the kernel to get a feature or input report from the device, in "
"order to selectively update the usage structures (in contrast to INITREPORT)."
msgstr ""

#: ../../../hid/hiddev.rst:168
msgid "HIDIOCSREPORT"
msgstr ""

#: ../../../hid/hiddev.rst:171
msgid ""
"Instructs the kernel to send a report to the device. This report can be "
"filled in by the user through HIDIOCSUSAGE calls (below) to fill in "
"individual usage values in the report before sending the report in full to "
"the device."
msgstr ""

#: ../../../hid/hiddev.rst:176
msgid "HIDIOCGREPORTINFO"
msgstr ""

#: ../../../hid/hiddev.rst:177
msgid "struct hiddev_report_info (read/write)"
msgstr ""

#: ../../../hid/hiddev.rst:179
msgid ""
"Fills in a hiddev_report_info structure for the user. The report is looked "
"up by type (input, output or feature) and id, so these fields must be filled "
"in by the user. The ID can be absolute -- the actual report id as reported "
"by the device -- or relative -- HID_REPORT_ID_FIRST for the first report, "
"and (HID_REPORT_ID_NEXT | report_id) for the next report after report_id. "
"Without a priori information about report ids, the right way to use this "
"ioctl is to use the relative IDs above to enumerate the valid IDs. The ioctl "
"returns non-zero when there is no more next ID. The real report ID is filled "
"into the returned hiddev_report_info structure."
msgstr ""

#: ../../../hid/hiddev.rst:190
msgid "HIDIOCGFIELDINFO"
msgstr ""

#: ../../../hid/hiddev.rst:191
msgid "struct hiddev_field_info (read/write)"
msgstr ""

#: ../../../hid/hiddev.rst:193
msgid ""
"Returns the field information associated with a report in a "
"hiddev_field_info structure. The user must fill in report_id and report_type "
"in this structure, as above. The field_index should also be filled in, which "
"should be a number from 0 and maxfield-1, as returned from a previous "
"HIDIOCGREPORTINFO call."
msgstr ""

#: ../../../hid/hiddev.rst:199
msgid "HIDIOCGUCODE"
msgstr ""

#: ../../../hid/hiddev.rst:200 ../../../hid/hiddev.rst:207
msgid "struct hiddev_usage_ref (read/write)"
msgstr ""

#: ../../../hid/hiddev.rst:202
msgid ""
"Returns the usage_code in a hiddev_usage_ref structure, given that its "
"report type, report id, field index, and index within the field have already "
"been filled into the structure."
msgstr ""

#: ../../../hid/hiddev.rst:206
msgid "HIDIOCGUSAGE"
msgstr ""

#: ../../../hid/hiddev.rst:209
msgid ""
"Returns the value of a usage in a hiddev_usage_ref structure. The usage to "
"be retrieved can be specified as above, or the user can choose to fill in "
"the report_type field and specify the report_id as HID_REPORT_ID_UNKNOWN. In "
"this case, the hiddev_usage_ref will be filled in with the report and field "
"information associated with this usage if it is found."
msgstr ""

#: ../../../hid/hiddev.rst:216
msgid "HIDIOCSUSAGE"
msgstr ""

#: ../../../hid/hiddev.rst:217 ../../../hid/hiddev.rst:224
msgid "struct hiddev_usage_ref (write)"
msgstr ""

#: ../../../hid/hiddev.rst:219
msgid ""
"Sets the value of a usage in an output report.  The user fills in the "
"hiddev_usage_ref structure as above, but additionally fills in the value "
"field."
msgstr ""

#: ../../../hid/hiddev.rst:223
msgid "HIDIOGCOLLECTIONINDEX"
msgstr ""

#: ../../../hid/hiddev.rst:226
msgid ""
"Returns the collection index associated with this usage.  This indicates "
"where in the collection hierarchy this usage sits."
msgstr ""

#: ../../../hid/hiddev.rst:229
msgid "HIDIOCGFLAG"
msgstr ""

#: ../../../hid/hiddev.rst:231
msgid "HIDIOCSFLAG"
msgstr ""

#: ../../../hid/hiddev.rst:232
msgid "int (write)"
msgstr ""

#: ../../../hid/hiddev.rst:234
msgid ""
"These operations respectively inspect and replace the mode flags that "
"influence the read() call above.  The flags are as follows:"
msgstr ""

#: ../../../hid/hiddev.rst:237
msgid "HIDDEV_FLAG_UREF"
msgstr ""

#: ../../../hid/hiddev.rst:238
msgid ""
"read() calls will now return struct hiddev_usage_ref instead of struct "
"hiddev_event. This is a larger structure, but in situations where the device "
"has more than one usage in its reports with the same usage code, this mode "
"serves to resolve such ambiguity."
msgstr ""

#: ../../../hid/hiddev.rst:245
msgid "HIDDEV_FLAG_REPORT"
msgstr ""

#: ../../../hid/hiddev.rst:246
msgid ""
"This flag can only be used in conjunction with HIDDEV_FLAG_UREF.  With this "
"flag set, when the device sends a report, a struct hiddev_usage_ref will be "
"returned to read() filled in with the report_type and report_id, but with "
"field_index set to FIELD_INDEX_NONE.  This serves as additional notification "
"when the device has sent a report."
msgstr ""
