# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../virt/kvm/ppc-pv.rst:5
msgid "The PPC KVM paravirtual interface"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:7
msgid ""
"The basic execution principle by which KVM on PowerPC works is to run all "
"kernel space code in PR=1 which is user space. This way we trap all "
"privileged instructions and can emulate them accordingly."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:11
msgid ""
"Unfortunately that is also the downfall. There are quite some privileged "
"instructions that needlessly return us to the hypervisor even though they "
"could be handled differently."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:15
msgid ""
"This is what the PPC PV interface helps with. It takes privileged "
"instructions and transforms them into unprivileged ones with some help from "
"the hypervisor. This cuts down virtualization costs by about 50% on some of "
"my benchmarks."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:19
msgid "The code for that interface can be found in arch/powerpc/kernel/kvm*"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:22
msgid "Querying for existence"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:24
msgid ""
"To find out if we're running on KVM or not, we leverage the device tree. "
"When Linux is running on KVM, a node /hypervisor exists. That node contains "
"a compatible property with the value \"linux,kvm\"."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:28
msgid ""
"Once you determined you're running under a PV capable KVM, you can now use "
"hypercalls as described below."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:32
msgid "KVM hypercalls"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:34
msgid ""
"Inside the device tree's /hypervisor node there's a property called "
"'hypercall-instructions'. This property contains at most 4 opcodes that make "
"up the hypercall. To call a hypercall, just call these instructions."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:38
msgid "The parameters are as follows:"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:41
msgid "Register"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:41
msgid "IN"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:41
msgid "OUT"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:43
msgid "r0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:43 ../../../virt/kvm/ppc-pv.rst:53
msgid "volatile"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:44
msgid "r3"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:44
msgid "1st parameter"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:44
msgid "Return code"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:45
msgid "r4"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:45
msgid "2nd parameter"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:45
msgid "1st output value"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:46
msgid "r5"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:46
msgid "3rd parameter"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:46
msgid "2nd output value"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:47
msgid "r6"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:47
msgid "4th parameter"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:47
msgid "3rd output value"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:48
msgid "r7"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:48
msgid "5th parameter"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:48
msgid "4th output value"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:49
msgid "r8"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:49
msgid "6th parameter"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:49
msgid "5th output value"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:50
msgid "r9"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:50
msgid "7th parameter"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:50
msgid "6th output value"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:51
msgid "r10"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:51
msgid "8th parameter"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:51
msgid "7th output value"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:52
msgid "r11"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:52
msgid "hypercall number"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:52
msgid "8th output value"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:53
msgid "r12"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:56
msgid ""
"Hypercall definitions are shared in generic code, so the same hypercall "
"numbers apply for x86 and powerpc alike with the exception that each KVM "
"hypercall also needs to be ORed with the KVM vendor code which is (42 << 16)."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:60
msgid "Return codes can be as follows:"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:63
msgid "Code"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:63
msgid "Meaning"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:65
msgid "0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:65
msgid "Success"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:66
msgid "12"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:66
msgid "Hypercall not implemented"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:67
msgid "<0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:67
msgid "Error"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:71
msgid "The magic page"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:73
msgid ""
"To enable communication between the hypervisor and guest there is a new "
"shared page that contains parts of supervisor visible register state. The "
"guest can map this shared page using the KVM hypercall "
"KVM_HC_PPC_MAP_MAGIC_PAGE."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:77
msgid ""
"With this hypercall issued the guest always gets the magic page mapped at "
"the desired location. The first parameter indicates the effective address "
"when the MMU is enabled. The second parameter indicates the address in real "
"mode, if applicable to the target. For now, we always map the page to -4096. "
"This way we can access it using absolute load and store functions. The "
"following instruction reads the first field of the magic page::"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:86
msgid ""
"The interface is designed to be extensible should there be need later to add "
"additional registers to the magic page. If you add fields to the magic page, "
"also define a new hypercall feature to indicate that the host can give you "
"more registers. Only if the host supports the additional features, make use "
"of them."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:91
msgid ""
"The magic page layout is described by struct kvm_vcpu_arch_shared in arch/"
"powerpc/include/uapi/asm/kvm_para.h."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:95
msgid "Magic page features"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:97
msgid ""
"When mapping the magic page using the KVM hypercall "
"KVM_HC_PPC_MAP_MAGIC_PAGE, a second return value is passed to the guest. "
"This second return value contains a bitmap of available features inside the "
"magic page."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:101
msgid "The following enhancements to the magic page are currently available:"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:104
msgid "KVM_MAGIC_FEAT_SR"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:104
msgid "Maps SR registers r/w in the magic page"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:105
msgid "KVM_MAGIC_FEAT_MAS0_TO_SPRG7"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:105
msgid "Maps MASn, ESR, PIR and high SPRGs"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:108
msgid ""
"For enhanced features in the magic page, please check for the existence of "
"the feature before using them!"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:112
msgid "Magic page flags"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:114
msgid ""
"In addition to features that indicate whether a host is capable of a "
"particular feature we also have a channel for a guest to tell the host "
"whether it's capable of something. This is what we call \"flags\"."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:118
msgid ""
"Flags are passed to the host in the low 12 bits of the Effective Address."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:120
msgid "The following flags are currently available for a guest to expose:"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:122
msgid ""
"MAGIC_PAGE_FLAG_NOT_MAPPED_NX Guest handles NX bits correctly wrt magic page"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:125
msgid "MSR bits"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:127
msgid ""
"The MSR contains bits that require hypervisor intervention and bits that do "
"not require direct hypervisor intervention because they only get interpreted "
"when entering the guest or don't have any impact on the hypervisor's "
"behavior."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:131
msgid "The following bits are safe to be set inside the guest:"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:133
msgid "MSR_EE"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:134
msgid "MSR_RI"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:136
msgid "If any other bit changes in the MSR, please still use mtmsr(d)."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:139
msgid "Patched instructions"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:141
msgid ""
"The \"ld\" and \"std\" instructions are transformed to \"lwz\" and \"stw\" "
"instructions respectively on 32-bit systems with an added offset of 4 to "
"accommodate for big endianness."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:145
msgid ""
"The following is a list of mapping the Linux kernel performs when running as "
"guest. Implementing any of those mappings is optional, as the instruction "
"traps also act on the shared page. So calling privileged instructions still "
"works as before."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:151
msgid "From"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:151
msgid "To"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:153
msgid "mfmsr   rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:153
msgid "ld      rX, magic_page->msr"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:154
msgid "mfsprg  rX, 0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:154
msgid "ld      rX, magic_page->sprg0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:155
msgid "mfsprg  rX, 1"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:155
msgid "ld      rX, magic_page->sprg1"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:156
msgid "mfsprg  rX, 2"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:156
msgid "ld      rX, magic_page->sprg2"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:157
msgid "mfsprg  rX, 3"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:157
msgid "ld      rX, magic_page->sprg3"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:158
msgid "mfsrr0  rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:158
msgid "ld      rX, magic_page->srr0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:159
msgid "mfsrr1  rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:159
msgid "ld      rX, magic_page->srr1"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:160
msgid "mfdar   rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:160
msgid "ld      rX, magic_page->dar"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:161
msgid "mfdsisr rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:161
msgid "lwz     rX, magic_page->dsisr"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:163 ../../../virt/kvm/ppc-pv.rst:176
msgid "mtmsr   rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:163
msgid "std     rX, magic_page->msr"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:164
msgid "mtsprg  0, rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:164
msgid "std     rX, magic_page->sprg0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:165
msgid "mtsprg  1, rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:165
msgid "std     rX, magic_page->sprg1"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:166
msgid "mtsprg  2, rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:166
msgid "std     rX, magic_page->sprg2"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:167
msgid "mtsprg  3, rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:167
msgid "std     rX, magic_page->sprg3"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:168
msgid "mtsrr0  rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:168
msgid "std     rX, magic_page->srr0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:169
msgid "mtsrr1  rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:169
msgid "std     rX, magic_page->srr1"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:170
msgid "mtdar   rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:170
msgid "std     rX, magic_page->dar"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:171
msgid "mtdsisr rX"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:171
msgid "stw     rX, magic_page->dsisr"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:173
msgid "tlbsync"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:173
msgid "nop"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:175
msgid "mtmsrd  rX, 0"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:175 ../../../virt/kvm/ppc-pv.rst:176
msgid "b       <special mtmsr section>"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:178
msgid "mtmsrd  rX, 1"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:178
msgid "b       <special mtmsrd section>"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:180
msgid "[Book3S only]"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:181
msgid "mtsrin  rX, rY"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:181
msgid "b       <special mtsrin section>"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:183
msgid "[BookE only]"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:184
msgid "wrteei  [0|1]"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:184
msgid "b       <special wrteei section>"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:187
msgid ""
"Some instructions require more logic to determine what's going on than a "
"load or store instruction can deliver. To enable patching of those, we keep "
"some RAM around where we can live translate instructions to. What happens is "
"the following:"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:192
msgid "copy emulation code to memory"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:193
msgid "patch that code to fit the emulated instruction"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:194
msgid "patch that code to return to the original pc + 4"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:195
msgid "patch the original instruction to branch to the new code"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:197
msgid ""
"That way we can inject an arbitrary amount of code as replacement for a "
"single instruction. This allows us to check for pending interrupts when "
"setting EE=1 for example."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:202
msgid "Hypercall ABIs in KVM on PowerPC"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:204
msgid "KVM hypercalls (ePAPR)"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:206
msgid ""
"These are ePAPR compliant hypercall implementation (mentioned above). Even "
"generic hypercalls are implemented here, like the ePAPR idle hcall. These "
"are available on all targets."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:210
msgid "PAPR hypercalls"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:212
msgid ""
"PAPR hypercalls are needed to run server PowerPC PAPR guests (-M pseries in "
"QEMU). These are the same hypercalls that pHyp, the POWER hypervisor, "
"implements. Some of them are handled in the kernel, some are handled in user "
"space. This is only available on book3s_64."
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:217
msgid "OSI hypercalls"
msgstr ""

#: ../../../virt/kvm/ppc-pv.rst:219
msgid ""
"Mac-on-Linux is another user of KVM on PowerPC, which has its own hypercall "
"(long before KVM). This is supported to maintain compatibility. All these "
"hypercalls get forwarded to user space. This is only useful on book3s_32, "
"but can be used with book3s_64 as well."
msgstr ""
