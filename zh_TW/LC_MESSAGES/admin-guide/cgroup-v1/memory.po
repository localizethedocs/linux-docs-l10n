# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/cgroup-v1/memory.rst:3
msgid "Memory Resource Controller"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:6
msgid ""
"This document is hopelessly outdated and it asks for a complete rewrite. It "
"still contains a useful information so we are keeping it here but make sure "
"to check the current code if you need a deeper understanding."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:12
msgid ""
"The Memory Resource Controller has generically been referred to as the "
"memory controller in this document. Do not confuse memory controller used "
"here with the memory controller that is used in hardware."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:17
msgid ""
"When we mention a cgroup (cgroupfs's directory) with memory controller, we "
"call it \"memory cgroup\". When you see git-log and source code, you'll see "
"patch's title and function names tend to use \"memcg\". In this document, we "
"avoid using it."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:23
msgid "Benefits and Purpose of the memory controller"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:25
msgid ""
"The memory controller isolates the memory behaviour of a group of tasks from "
"the rest of the system. The article on LWN [12]_ mentions some probable uses "
"of the memory controller. The memory controller can be used to"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:29
msgid ""
"Isolate an application or a group of applications Memory-hungry applications "
"can be isolated and limited to a smaller amount of memory."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:32
msgid ""
"Create a cgroup with a limited amount of memory; this can be used as a good "
"alternative to booting with mem=XXXX."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:34
msgid ""
"Virtualization solutions can control the amount of memory they want to "
"assign to a virtual machine instance."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:36
msgid ""
"A CD/DVD burner could control the amount of memory used by the rest of the "
"system to ensure that burning does not fail due to lack of available memory."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:39
msgid ""
"There are several other use cases; find one or use the controller just for "
"fun (to learn and hack on the VM subsystem)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:42
msgid "Current Status: linux-2.6.34-mmotm(development version of 2010/April)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:44
msgid "Features:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:46
msgid ""
"accounting anonymous pages, file caches, swap caches usage and limiting them."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:47
msgid ""
"pages are linked to per-memcg LRU exclusively, and there is no global LRU."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:48
msgid "optionally, memory+swap usage can be accounted and limited."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:49
msgid "hierarchical accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:50
msgid "soft limit"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:51
msgid "moving (recharging) account at moving a task is selectable."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:52
msgid "usage threshold notifier"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:53
msgid "memory pressure notifier"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:54
msgid "oom-killer disable knob and oom-notifier"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:55
msgid "Root cgroup has no limit controls."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:57
msgid ""
"Kernel memory support is a work in progress, and the current version "
"provides basically functionality. (See :ref:`section 2.7 <cgroup-v1-memory-"
"kernel-extension>`)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:61
msgid "Brief summary of control files."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:64
msgid "tasks"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:64
msgid "attach a task(thread) and show list of threads"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:66
msgid "cgroup.procs"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:66
msgid "show list of processes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:67
msgid "cgroup.event_control"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:67
msgid ""
"an interface for event_fd() This knob is not available on CONFIG_PREEMPT_RT "
"systems."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:69
msgid "memory.usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:69
msgid "show current usage for memory (See 5.5 for details)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:71
msgid "memory.memsw.usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:71
msgid "show current usage for memory+Swap (See 5.5 for details)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:73
msgid "memory.limit_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:73
msgid "set/show limit of memory usage"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:74
msgid "memory.memsw.limit_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:74
msgid "set/show limit of memory+Swap usage"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:75
msgid "memory.failcnt"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:75
msgid "show the number of memory usage hits limits"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:76
msgid "memory.memsw.failcnt"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:76
msgid "show the number of memory+Swap hits limits"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:77
msgid "memory.max_usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:77
msgid "show max memory usage recorded"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:78
msgid "memory.memsw.max_usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:78
msgid "show max memory+Swap usage recorded"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:79
msgid "memory.soft_limit_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:79
msgid ""
"set/show soft limit of memory usage This knob is not available on "
"CONFIG_PREEMPT_RT systems. This knob is deprecated and shouldn't be used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:83
msgid "memory.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:83
msgid "show various statistics"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:84
msgid "memory.use_hierarchy"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:84
msgid ""
"set/show hierarchical account enabled This knob is deprecated and shouldn't "
"be used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:87
msgid "memory.force_empty"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:87
msgid "trigger forced page reclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:88
msgid "memory.pressure_level"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:88
msgid ""
"set memory pressure notifications This knob is deprecated and shouldn't be "
"used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:91
msgid "memory.swappiness"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:91
msgid ""
"set/show swappiness parameter of vmscan (See sysctl's vm.swappiness) Per "
"memcg knob does not exist in cgroup v2."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:94
msgid "memory.move_charge_at_immigrate"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:94
msgid "This knob is deprecated."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:95
msgid "memory.oom_control"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:95
msgid "set/show oom controls. This knob is deprecated and shouldn't be used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:98
msgid "memory.numa_stat"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:98
msgid "show the number of memory usage per numa node"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:100
msgid "memory.kmem.limit_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:100
msgid ""
"Deprecated knob to set and read the kernel memory hard limit. Kernel hard "
"limit is not supported since 5.16. Writing any value to do file will not "
"have any effect same as if nokmem kernel parameter was specified. Kernel "
"memory is still charged and reported by memory.kmem.usage_in_bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:107
msgid "memory.kmem.usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:107
msgid "show current kernel memory allocation"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:108
msgid "memory.kmem.failcnt"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:108
msgid "show the number of kernel memory usage hits limits"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:110
msgid "memory.kmem.max_usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:110
msgid "show max kernel memory usage recorded"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:112
msgid "memory.kmem.tcp.limit_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:112
msgid ""
"set/show hard limit for tcp buf memory This knob is deprecated and shouldn't "
"be used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:115
msgid "memory.kmem.tcp.usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:115
msgid ""
"show current tcp buf memory allocation This knob is deprecated and shouldn't "
"be used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:118
msgid "memory.kmem.tcp.failcnt"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:118
msgid ""
"show the number of tcp buf memory usage hits limits This knob is deprecated "
"and shouldn't be used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:122
msgid "memory.kmem.tcp.max_usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:122
msgid ""
"show max tcp buf memory usage recorded This knob is deprecated and shouldn't "
"be used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:128
msgid "1. History"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:130
msgid ""
"The memory controller has a long history. A request for comments for the "
"memory controller was posted by Balbir Singh [1]_. At the time the RFC was "
"posted there were several implementations for memory control. The goal of "
"the RFC was to build consensus and agreement for the minimal features "
"required for memory control. The first RSS controller was posted by Balbir "
"Singh [2]_ in Feb 2007. Pavel Emelianov [3]_ [4]_ [5]_ has since posted "
"three versions of the RSS controller. At OLS, at the resource management "
"BoF, everyone suggested that we handle both page cache and RSS together. "
"Another request was raised to allow user space handling of OOM. The current "
"memory controller is at version 6; it combines both mapped (RSS) and "
"unmapped Page Cache Control [11]_."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:143
msgid "2. Memory Control"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:145
msgid ""
"Memory is a unique resource in the sense that it is present in a limited "
"amount. If a task requires a lot of CPU processing, the task can spread its "
"processing over a period of hours, days, months or years, but with memory, "
"the same physical memory needs to be reused to accomplish the task."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:150
msgid ""
"The memory controller implementation has been divided into phases. These are:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:153
msgid "Memory controller"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:154
msgid "mlock(2) controller"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:155
msgid "Kernel user memory accounting and slab control"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:156
msgid "user mappings length controller"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:158
msgid "The memory controller is the first controller developed."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:161
msgid "2.1. Design"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:163
msgid ""
"The core of the design is a counter called the page_counter. The "
"page_counter tracks the current memory usage and limit of the group of "
"processes associated with the controller. Each cgroup has a memory "
"controller specific data structure (mem_cgroup) associated with it."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:169
msgid "2.2. Accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:171
msgid "Figure 1: Hierarchy of Accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:194
msgid "Figure 1 shows the important aspects of the controller"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:196
msgid "Accounting happens per cgroup"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:197
msgid "Each mm_struct knows about which cgroup it belongs to"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:198
msgid ""
"Each page has a pointer to the page_cgroup, which in turn knows the cgroup "
"it belongs to"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:201
msgid ""
"The accounting is done as follows: mem_cgroup_charge_common() is invoked to "
"set up the necessary data structures and check if the cgroup that is being "
"charged is over its limit. If it is, then reclaim is invoked on the cgroup. "
"More details can be found in the reclaim section of this document. If "
"everything goes well, a page meta-data-structure called page_cgroup is "
"updated. page_cgroup has its own LRU on cgroup. (*) page_cgroup structure is "
"allocated at boot/memory-hotplug time."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:210
msgid "2.2.1 Accounting details"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:212
msgid ""
"All mapped anon pages (RSS) and cache pages (Page Cache) are accounted. Some "
"pages which are never reclaimable and will not be on the LRU are not "
"accounted. We just account pages under usual VM management."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:216
msgid ""
"RSS pages are accounted at page_fault unless they've already been accounted "
"for earlier. A file page will be accounted for as Page Cache when it's "
"inserted into inode (xarray). While it's mapped into the page tables of "
"processes, duplicate accounting is carefully avoided."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:221
msgid ""
"An RSS page is unaccounted when it's fully unmapped. A PageCache page is "
"unaccounted when it's removed from xarray. Even if RSS pages are fully "
"unmapped (by kswapd), they may exist as SwapCache in the system until they "
"are really freed. Such SwapCaches are also accounted. A swapped-in page is "
"accounted after adding into swapcache."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:227
msgid ""
"Note: The kernel does swapin-readahead and reads multiple swaps at once. "
"Since page's memcg recorded into swap whatever memsw enabled, the page will "
"be accounted after swapin."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:231
msgid "At page migration, accounting information is kept."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:233
msgid ""
"Note: we just account pages-on-LRU because our purpose is to control amount "
"of used pages; not-on-LRU pages tend to be out-of-control from VM view."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:237
msgid "2.3 Shared Page Accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:239
msgid ""
"Shared pages are accounted on the basis of the first touch approach. The "
"cgroup that first touches a page is accounted for the page. The principle "
"behind this approach is that a cgroup that aggressively uses a shared page "
"will eventually get charged for it (once it is uncharged from the cgroup "
"that brought it in -- this will happen on memory pressure)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:246
msgid "2.4 Swap Extension"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:248
msgid ""
"Swap usage is always recorded for each of cgroup. Swap Extension allows you "
"to read and limit it."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:251
msgid "When CONFIG_SWAP is enabled, following files are added."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:253
msgid "memory.memsw.usage_in_bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:254
msgid "memory.memsw.limit_in_bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:256
msgid ""
"memsw means memory+swap. Usage of memory+swap is limited by memsw."
"limit_in_bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:259
msgid ""
"Example: Assume a system with 4G of swap. A task which allocates 6G of "
"memory (by mistake) under 2G memory limitation will use all swap. In this "
"case, setting memsw.limit_in_bytes=3G will prevent bad use of swap. By using "
"the memsw limit, you can avoid system OOM which can be caused by swap "
"shortage."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:266
msgid "2.4.1 why 'memory+swap' rather than swap"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:268
msgid ""
"The global LRU(kswapd) can swap out arbitrary pages. Swap-out means to move "
"account from memory to swap...there is no change in usage of memory+swap. In "
"other words, when we want to limit the usage of swap without affecting "
"global LRU, memory+swap limit is better than just limiting swap from an OS "
"point of view."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:275
msgid "2.4.2. What happens when a cgroup hits memory.memsw.limit_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:277
msgid ""
"When a cgroup hits memory.memsw.limit_in_bytes, it's useless to do swap-out "
"in this cgroup. Then, swap-out will not be done by cgroup routine and file "
"caches are dropped. But as mentioned above, global LRU can do swapout memory "
"from it for sanity of the system's memory management state. You can't forbid "
"it by cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:284
msgid "2.5 Reclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:286
msgid ""
"Each cgroup maintains a per cgroup LRU which has the same structure as "
"global VM. When a cgroup goes over its limit, we first try to reclaim memory "
"from the cgroup so as to make space for the new pages that the cgroup has "
"touched. If the reclaim is unsuccessful, an OOM routine is invoked to select "
"and kill the bulkiest task in the cgroup. (See :ref:`10. OOM Control <cgroup-"
"v1-memory-oom-control>` below.)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:293
msgid ""
"The reclaim algorithm has not been modified for cgroups, except that pages "
"that are selected for reclaiming come from the per-cgroup LRU list."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:298
msgid ""
"Reclaim does not work for the root cgroup, since we cannot set any limits on "
"the root cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:302
msgid "When panic_on_oom is set to \"2\", the whole system will panic."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:304
msgid ""
"When oom event notifier is registered, event will be delivered. (See :ref:"
"`oom_control <cgroup-v1-memory-oom-control>` section)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:308
msgid "2.6 Locking"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:310
msgid "Lock order is as follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:318
msgid ""
"Per-node-per-memcgroup LRU (cgroup's private LRU) is guarded by lruvec-"
">lru_lock; the folio LRU flag is cleared before isolating a page from its "
"LRU under lruvec->lru_lock."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:325
msgid "2.7 Kernel Memory Extension"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:327
msgid ""
"With the Kernel memory extension, the Memory Controller is able to limit the "
"amount of kernel memory used by the system. Kernel memory is fundamentally "
"different than user memory, since it can't be swapped out, which makes it "
"possible to DoS the system by consuming too much of this precious resource."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:332
msgid ""
"Kernel memory accounting is enabled for all memory cgroups by default. But "
"it can be disabled system-wide by passing cgroup.memory=nokmem to the kernel "
"at boot time. In this case, kernel memory will not be accounted at all."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:336
msgid ""
"Kernel memory limits are not imposed for the root cgroup. Usage for the root "
"cgroup may or may not be accounted. The memory used is accumulated into "
"memory.kmem.usage_in_bytes, or in a separate counter when it makes sense. "
"(currently only for tcp)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:341
msgid ""
"The main \"kmem\" counter is fed into the main counter, so kmem charges will "
"also be visible from the user counter."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:344
msgid ""
"Currently no soft limit is implemented for kernel memory. It is future work "
"to trigger slab reclaim when those limits are reached."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:348
msgid "2.7.1 Current Kernel Memory resources accounted"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:350
msgid "stack pages:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:351
msgid ""
"every process consumes some stack pages. By accounting into kernel memory, "
"we prevent new processes from being created when the kernel memory usage is "
"too high."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:355
msgid "slab pages:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:356
msgid ""
"pages allocated by the SLAB or SLUB allocator are tracked. A copy of each "
"kmem_cache is created every time the cache is touched by the first time from "
"inside the memcg. The creation is done lazily, so some objects can still be "
"skipped while the cache is being created. All objects in a slab page should "
"belong to the same memcg. This only fails to hold when a task is migrated to "
"a different memcg during the page allocation by the cache."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:363
msgid "sockets memory pressure:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:364
msgid ""
"some sockets protocols have memory pressure thresholds. The Memory "
"Controller allows them to be controlled individually per cgroup, instead of "
"globally."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:368
msgid "tcp memory pressure:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:369
msgid "sockets memory pressure for the tcp protocol."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:372
msgid "2.7.2 Common use cases"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:374
msgid ""
"Because the \"kmem\" counter is fed to the main user counter, kernel memory "
"can never be limited completely independently of user memory. Say \"U\" is "
"the user limit, and \"K\" the kernel limit. There are three possible ways "
"limits can be set:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:379
msgid "U != 0, K = unlimited:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:380
msgid ""
"This is the standard memcg limitation mechanism already present before kmem "
"accounting. Kernel memory is completely ignored."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:383
msgid "U != 0, K < U:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:384
msgid ""
"Kernel memory is a subset of the user memory. This setup is useful in "
"deployments where the total amount of memory per-cgroup is overcommitted. "
"Overcommitting kernel memory limits is definitely not recommended, since the "
"box can still run out of non-reclaimable memory. In this case, the admin "
"could set up K so that the sum of all groups is never greater than the total "
"memory, and freely set U at the cost of his QoS."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:393
msgid ""
"In the current implementation, memory reclaim will NOT be triggered for a "
"cgroup when it hits K while staying below U, which makes this setup "
"impractical."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:397
msgid "U != 0, K >= U:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:398
msgid ""
"Since kmem charges will also be fed to the user counter and reclaim will be "
"triggered for the cgroup for both kinds of memory. This setup gives the "
"admin a unified view of memory, and it is also useful for people who just "
"want to track kernel memory usage."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:404
msgid "3. User Interface"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:406
msgid "To use the user interface:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:408
msgid "Enable CONFIG_CGROUPS and CONFIG_MEMCG options"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:409
msgid ""
"Prepare the cgroups (see :ref:`Why are cgroups needed? <cgroups-why-needed>` "
"for the background information)::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:416
msgid "Make the new group and move bash into it::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:421
msgid "Since now we're in the 0 cgroup, we can alter the memory limit::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:425
msgid "The limit can now be queried::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:431
msgid ""
"We can use a suffix (k, K, m, M, g or G) to indicate values in kilo, mega or "
"gigabytes. (Here, Kilo, Mega, Giga are Kibibytes, Mebibytes, Gibibytes.)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:436
msgid "We can write \"-1\" to reset the ``*.limit_in_bytes(unlimited)``."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:439
msgid "We cannot set limits on the root cgroup any more."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:442
msgid "We can check the usage::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:447
msgid ""
"A successful write to this file does not guarantee a successful setting of "
"this limit to the value written into the file. This can be due to a number "
"of factors, such as rounding up to page boundaries or the total availability "
"of memory on the system. The user is required to re-read this file after a "
"write to guarantee the value committed by the kernel::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:457
msgid ""
"The memory.failcnt field gives the number of times that the cgroup limit was "
"exceeded."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:460
msgid ""
"The memory.stat file gives accounting information. Now, the number of "
"caches, RSS and Active pages/Inactive pages are shown."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:464
msgid "4. Testing"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:466
msgid "For testing features and implementation, see memcg_test.txt."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:468
msgid ""
"Performance test is also important. To see pure memory controller's "
"overhead, testing on tmpfs will give you good numbers of small overheads. "
"Example: do kernel make on tmpfs."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:472
msgid ""
"Page-fault scalability is also important. At measuring parallel page fault "
"test, multi-process test may be better than multi-thread test because it has "
"noise of shared objects/status."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:476
msgid ""
"But the above two are testing extreme situations. Trying usual test under "
"memory controller is always helpful."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:482
msgid "4.1 Troubleshooting"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:484
msgid ""
"Sometimes a user might find that the application under a cgroup is "
"terminated by the OOM killer. There are several causes for this:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:487
msgid "The cgroup limit is too low (just too low to do anything useful)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:488
msgid "The user is using anonymous memory and swap is turned off or too low"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:490
msgid ""
"A sync followed by echo 1 > /proc/sys/vm/drop_caches will help get rid of "
"some of the pages cached in the cgroup (page cache pages)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:493
msgid ""
"To know what happens, disabling OOM_Kill as per :ref:`\"10. OOM Control\" "
"<cgroup-v1-memory-oom-control>` (below) and seeing what happens will be "
"helpful."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:500
msgid "4.2 Task migration"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:502
msgid ""
"When a task migrates from one cgroup to another, its charge is not carried "
"forward by default. The pages allocated from the original cgroup still "
"remain charged to it, the charge is dropped when the page is freed or "
"reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:507
msgid ""
"You can move charges of a task along with task migration. See :ref:`8. "
"\"Move charges at task migration\" <cgroup-v1-memory-move-charges>`"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:511
msgid "4.3 Removing a cgroup"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:513
msgid ""
"A cgroup can be removed by rmdir, but as discussed in :ref:`sections 4.1 "
"<cgroup-v1-memory-test-troubleshoot>` and :ref:`4.2 <cgroup-v1-memory-test-"
"task-migration>`, a cgroup might have some charge associated with it, even "
"though all tasks have migrated away from it. (because we charge against "
"pages, not against tasks.)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:519
msgid ""
"We move the stats to parent, and no change on the charge except uncharging "
"from the child."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:522
msgid ""
"Charges recorded in swap information is not updated at removal of cgroup. "
"Recorded information is discarded and a cgroup which uses swap (swapcache) "
"will be charged as a new owner of it."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:527
msgid "5. Misc. interfaces"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:530
msgid "5.1 force_empty"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:531
msgid ""
"memory.force_empty interface is provided to make cgroup's memory usage "
"empty. When writing anything to this::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:536
msgid "the cgroup will be reclaimed and as many pages reclaimed as possible."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:538
msgid ""
"The typical use case for this interface is before calling rmdir(). Though "
"rmdir() offlines memcg, but the memcg may still stay there due to charged "
"file caches. Some out-of-use page caches may keep charged until memory "
"pressure happens. If you want to avoid that, force_empty will be useful."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:544
msgid "5.2 stat file"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:546
msgid "memory.stat file includes following statistics:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:548
msgid "per-memory cgroup local status"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:551
msgid "cache"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:551
msgid "# of bytes of page cache memory."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:552
msgid "rss"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:552
msgid ""
"# of bytes of anonymous and swap cache memory (includes transparent "
"hugepages)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:554
msgid "rss_huge"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:554
msgid "# of bytes of anonymous transparent hugepages."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:555
msgid "mapped_file"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:555
msgid "# of bytes of mapped file (includes tmpfs/shmem)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:556
msgid "pgpgin"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:556
msgid ""
"# of charging events to the memory cgroup. The charging event happens each "
"time a page is accounted as either mapped anon page(RSS) or cache page(Page "
"Cache) to the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:559
msgid "pgpgout"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:559
msgid ""
"# of uncharging events to the memory cgroup. The uncharging event happens "
"each time a page is unaccounted from the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:562
msgid "swap"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:562
msgid "# of bytes of swap usage"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:563
msgid "swapcached"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:563
msgid "# of bytes of swap cached in memory"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:564
msgid "dirty"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:564
msgid "# of bytes that are waiting to get written back to the disk."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:565
msgid "writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:565
msgid "# of bytes of file/anon cache that are queued for syncing to disk."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:567
msgid "inactive_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:567
msgid "# of bytes of anonymous and swap cache memory on inactive LRU list."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:569
msgid "active_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:569
msgid "# of bytes of anonymous and swap cache memory on active LRU list."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:571
msgid "inactive_file"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:571
msgid ""
"# of bytes of file-backed memory and MADV_FREE anonymous memory (LazyFree "
"pages) on inactive LRU list."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:573
msgid "active_file"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:573
msgid "# of bytes of file-backed memory on active LRU list."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:574
msgid "unevictable"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:574
msgid "# of bytes of memory that cannot be reclaimed (mlocked etc)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:577
msgid "status considering hierarchy (see memory.use_hierarchy settings):"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:580
msgid "hierarchical_memory_limit"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:580
msgid ""
"# of bytes of memory limit with regard to hierarchy under which the memory "
"cgroup is"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:583
msgid "hierarchical_memsw_limit"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:583
msgid ""
"# of bytes of memory+swap limit with regard to hierarchy under which memory "
"cgroup is."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:586
msgid "total_<counter>"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:586
msgid ""
"# hierarchical version of <counter>, which in addition to the cgroup's own "
"value includes the sum of all hierarchical children's values of <counter>, i."
"e. total_cache"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:592
msgid "additional vm parameters (depends on CONFIG_DEBUG_VM):"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:595
msgid "recent_rotated_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:595
#: ../../../admin-guide/cgroup-v1/memory.rst:596
#: ../../../admin-guide/cgroup-v1/memory.rst:597
#: ../../../admin-guide/cgroup-v1/memory.rst:598
msgid "VM internal parameter. (see mm/vmscan.c)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:596
msgid "recent_rotated_file"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:597
msgid "recent_scanned_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:598
msgid "recent_scanned_file"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:602
msgid ""
"recent_rotated means recent frequency of LRU rotation. recent_scanned means "
"recent # of scans to LRU. showing for better debug please see the code for "
"meanings."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:607
msgid ""
"Only anonymous and swap cache memory is listed as part of 'rss' stat. This "
"should not be confused with the true 'resident set size' or the amount of "
"physical memory used by the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:611
msgid "'rss + mapped_file\" will give you resident set size of cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:613
msgid ""
"Note that some kernel configurations might account complete larger "
"allocations (e.g., THP) towards 'rss' and 'mapped_file', even if only some, "
"but not all that memory is mapped."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:617
msgid ""
"(Note: file and shmem may be shared among other cgroups. In that case, "
"mapped_file is accounted only when the memory cgroup is owner of page cache.)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:622
msgid "5.3 swappiness"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:624
msgid ""
"Overrides /proc/sys/vm/swappiness for the particular group. The tunable in "
"the root cgroup corresponds to the global swappiness setting."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:627
msgid ""
"Please note that unlike during the global reclaim, limit reclaim enforces "
"that 0 swappiness really prevents from any swapping even if there is a swap "
"storage available. This might lead to memcg OOM killer if there are no file "
"pages to reclaim."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:633
msgid "5.4 failcnt"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:635
msgid ""
"A memory cgroup provides memory.failcnt and memory.memsw.failcnt files. This "
"failcnt(== failure count) shows the number of times that a usage counter hit "
"its limit. When a memory cgroup hits a limit, failcnt increases and memory "
"under it will be reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:640
msgid "You can reset failcnt by writing 0 to failcnt file::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:645
msgid "5.5 usage_in_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:647
msgid ""
"For efficiency, as other kernel components, memory cgroup uses some "
"optimization to avoid unnecessary cacheline false sharing. usage_in_bytes is "
"affected by the method and doesn't show 'exact' value of memory (and swap) "
"usage, it's a fuzz value for efficient access. (Of course, when necessary, "
"it's synchronized.) If you want to know more exact memory usage, you should "
"use RSS+CACHE(+SWAP) value in memory.stat(see 5.2)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:655
msgid "5.6 numa_stat"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:657
msgid ""
"This is similar to numa_maps but operates on a per-memcg basis.  This is "
"useful for providing visibility into the numa locality information within an "
"memcg since the pages are allowed to be allocated from any physical node.  "
"One of the use cases is evaluating application performance by combining this "
"information with the application's CPU allocation."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:663
msgid ""
"Each memcg's numa_stat file includes \"total\", \"file\", \"anon\" and "
"\"unevictable\" per-node page counts including \"hierarchical_<counter>\" "
"which sums up all hierarchical children's values in addition to the memcg's "
"own value."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:667
msgid "The output format of memory.numa_stat is::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:675
msgid "The \"total\" count is sum of file + anon + unevictable."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:678
msgid "6. Hierarchy support"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:680
msgid ""
"The memory controller supports a deep hierarchy and hierarchical accounting. "
"The hierarchy is created by creating the appropriate cgroups in the cgroup "
"filesystem. Consider for example, the following cgroup filesystem hierarchy::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:693
msgid ""
"In the diagram above, with hierarchical accounting enabled, all memory usage "
"of e, is accounted to its ancestors up until the root (i.e, c and root). If "
"one of the ancestors goes over its limit, the reclaim algorithm reclaims "
"from the tasks in the ancestor and the children of the ancestor."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:699
msgid "6.1 Hierarchical accounting and reclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:701
msgid ""
"Hierarchical accounting is enabled by default. Disabling the hierarchical "
"accounting is deprecated. An attempt to do it will result in a failure and a "
"warning printed to dmesg."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:705
msgid ""
"For compatibility reasons writing 1 to memory.use_hierarchy will always "
"pass::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:710
msgid "7. Soft limits (DEPRECATED)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:712
#: ../../../admin-guide/cgroup-v1/memory.rst:756
#: ../../../admin-guide/cgroup-v1/memory.rst:785
#: ../../../admin-guide/cgroup-v1/memory.rst:835
msgid "THIS IS DEPRECATED!"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:714
msgid ""
"Soft limits allow for greater sharing of memory. The idea behind soft limits "
"is to allow control groups to use as much of the memory as needed, provided"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:717
msgid "There is no memory contention"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:718
msgid "They do not exceed their hard limit"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:720
msgid ""
"When the system detects memory contention or low memory, control groups are "
"pushed back to their soft limits. If the soft limit of each control group is "
"very high, they are pushed back as much as possible to make sure that one "
"control group does not starve the others of memory."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:725
msgid ""
"Please note that soft limits is a best-effort feature; it comes with no "
"guarantees, but it does its best to make sure that when memory is heavily "
"contended for, memory is allocated based on the soft limit hints/setup. "
"Currently soft limit based reclaim is set up such that it gets invoked from "
"balance_pgdat (kswapd)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:732
msgid "7.1 Interface"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:734
msgid ""
"Soft limits can be setup by using the following commands (in this example we "
"assume a soft limit of 256 MiB)::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:739
msgid "If we want to change this to 1G, we can at any time use::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:744
msgid ""
"Soft limits take effect over a long period of time, since they involve "
"reclaiming memory for balancing between memory cgroups"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:748
msgid ""
"It is recommended to set the soft limit always below the hard limit, "
"otherwise the hard limit will take precedence."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:754
msgid "8. Move charges at task migration (DEPRECATED!)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:758
msgid ""
"Reading memory.move_charge_at_immigrate will always return 0 and writing to "
"it will always return -EINVAL."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:762
msgid "9. Memory thresholds"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:764
msgid ""
"Memory cgroup implements memory thresholds using the cgroups notification "
"API (see cgroups.txt). It allows to register multiple memory and memsw "
"thresholds and gets notifications when it crosses."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:768
msgid "To register a threshold, an application must:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:770
#: ../../../admin-guide/cgroup-v1/memory.rst:897
msgid "create an eventfd using eventfd(2);"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:771
msgid "open memory.usage_in_bytes or memory.memsw.usage_in_bytes;"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:772
msgid ""
"write string like \"<event_fd> <fd of memory.usage_in_bytes> <threshold>\" "
"to cgroup.event_control."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:775
msgid ""
"Application will be notified through eventfd when memory usage crosses "
"threshold in any direction."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:778
msgid "It's applicable for root and non-root cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:783
msgid "10. OOM Control (DEPRECATED)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:787
msgid "memory.oom_control file is for OOM notification and other controls."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:789
msgid ""
"Memory cgroup implements OOM notifier using the cgroup notification API (See "
"cgroups.txt). It allows to register multiple OOM notification delivery and "
"gets notification when OOM happens."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:793
msgid "To register a notifier, an application must:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:795
msgid "create an eventfd using eventfd(2)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:796
msgid "open memory.oom_control file"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:797
msgid ""
"write string like \"<event_fd> <fd of memory.oom_control>\" to cgroup."
"event_control"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:800
msgid ""
"The application will be notified through eventfd when OOM happens. OOM "
"notification doesn't work for the root cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:803
msgid ""
"You can disable the OOM-killer by writing \"1\" to memory.oom_control file, "
"as:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:805
msgid "#echo 1 > memory.oom_control"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:807
msgid ""
"If OOM-killer is disabled, tasks under cgroup will hang/sleep in memory "
"cgroup's OOM-waitqueue when they request accountable memory."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:810
msgid "For running them, you have to relax the memory cgroup's OOM status by"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:812
msgid "enlarge limit or reduce usage."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:814
msgid "To reduce usage,"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:816
msgid "kill some tasks."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:817
msgid "move some tasks to other group with account migration."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:818
msgid "remove some files (on tmpfs?)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:820
msgid "Then, stopped tasks will work again."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:822
msgid "At reading, current status of OOM is shown."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:824
msgid "oom_kill_disable 0 or 1 (if 1, oom-killer is disabled)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:826
msgid ""
"under_oom        0 or 1 (if 1, the memory cgroup is under OOM, tasks may be "
"stopped.)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:828
msgid ""
"oom_kill         integer counter The number of processes belonging to this "
"cgroup killed by any kind of OOM killer."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:833
msgid "11. Memory Pressure (DEPRECATED)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:837
msgid ""
"The pressure level notifications can be used to monitor the memory "
"allocation cost; based on the pressure, applications can implement different "
"strategies of managing their memory resources. The pressure levels are "
"defined as following:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:842
msgid ""
"The \"low\" level means that the system is reclaiming memory for new "
"allocations. Monitoring this reclaiming activity might be useful for "
"maintaining cache level. Upon notification, the program (typically "
"\"Activity Manager\") might analyze vmstat and act in advance (i.e. "
"prematurely shutdown unimportant services)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:848
msgid ""
"The \"medium\" level means that the system is experiencing medium memory "
"pressure, the system might be making swap, paging out active file caches, "
"etc. Upon this event applications may decide to further analyze vmstat/"
"zoneinfo/memcg or internal memory usage statistics and free any resources "
"that can be easily reconstructed or re-read from a disk."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:854
msgid ""
"The \"critical\" level means that the system is actively thrashing, it is "
"about to out of memory (OOM) or even the in-kernel OOM killer is on its way "
"to trigger. Applications should do whatever they can to help the system. It "
"might be too late to consult with vmstat or any other statistics, so it's "
"advisable to take an immediate action."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:860
msgid ""
"By default, events are propagated upward until the event is handled, i.e. "
"the events are not pass-through. For example, you have three cgroups: A->B-"
">C. Now you set up an event listener on cgroups A, B and C, and suppose "
"group C experiences some pressure. In this situation, only group C will "
"receive the notification, i.e. groups A and B will not receive it. This is "
"done to avoid excessive \"broadcasting\" of messages, which disturbs the "
"system and which is especially bad if we are low on memory or thrashing. "
"Group B, will receive notification only if there are no event listeners for "
"group C."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:869
msgid ""
"There are three optional modes that specify different propagation behavior:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:871
msgid ""
"\"default\": this is the default behavior specified above. This mode is the "
"same as omitting the optional mode parameter, preserved by backwards "
"compatibility."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:875
msgid ""
"\"hierarchy\": events always propagate up to the root, similar to the "
"default behavior, except that propagation continues regardless of whether "
"there are event listeners at each level, with the \"hierarchy\" mode. In the "
"above example, groups A, B, and C will receive notification of memory "
"pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:880
msgid ""
"\"local\": events are pass-through, i.e. they only receive notifications "
"when memory pressure is experienced in the memcg for which the notification "
"is registered. In the above example, group C will receive notification if "
"registered for \"local\" notification and the group experiences memory "
"pressure. However, group B will never receive notification, regardless if "
"there is an event listener for group C or not, if group B is registered for "
"local notification."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:888
msgid ""
"The level and event notification mode (\"hierarchy\" or \"local\", if "
"necessary) are specified by a comma-delimited string, i.e. \"low,hierarchy\" "
"specifies hierarchical, pass-through, notification for all ancestor memcgs. "
"Notification that is the default, non pass-through behavior, does not "
"specify a mode. \"medium,local\" specifies pass-through notification for the "
"medium level."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:894
msgid ""
"The file memory.pressure_level is only used to setup an eventfd. To register "
"a notification, an application must:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:898
msgid "open memory.pressure_level;"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:899
msgid ""
"write string as \"<event_fd> <fd of memory.pressure_level> <level[,mode]>\" "
"to cgroup.event_control."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:902
msgid ""
"Application will be notified through eventfd when memory pressure is at the "
"specific level (or higher). Read/write operations to memory.pressure_level "
"are no implemented."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:906
msgid "Test:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:908
msgid ""
"Here is a small script example that makes a new cgroup, sets up a memory "
"limit, sets up a notification in the cgroup and then makes child cgroup "
"experience a critical pressure::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:921
msgid ""
"(Expect a bunch of notifications, and eventually, the oom-killer will "
"trigger.)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:925
msgid "12. TODO"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:927
msgid "Make per-cgroup scanner reclaim not-shared pages first"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:928
msgid "Teach controller to account for shared-pages"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:929
msgid ""
"Start reclamation in the background when the limit is not yet hit but the "
"usage is getting closer"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:933
msgid "Summary"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:935
msgid ""
"Overall, the memory controller has been a stable controller and has been "
"commented and discussed quite extensively in the community."
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:939
msgid "References"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:941
msgid "Singh, Balbir. RFC: Memory Controller, http://lwn.net/Articles/206697/"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:942
msgid ""
"Singh, Balbir. Memory Controller (RSS Control), http://lwn.net/"
"Articles/222762/"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:944
msgid ""
"Emelianov, Pavel. Resource controllers based on process cgroups https://lore."
"kernel.org/r/45ED7DEC.7010403@sw.ru"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:946
msgid ""
"Emelianov, Pavel. RSS controller based on process cgroups (v2) https://lore."
"kernel.org/r/461A3010.90403@sw.ru"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:948
msgid ""
"Emelianov, Pavel. RSS controller based on process cgroups (v3) https://lore."
"kernel.org/r/465D9739.8070209@openvz.org"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:951
msgid "Menage, Paul. Control Groups v10, http://lwn.net/Articles/236032/"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:952
msgid ""
"Vaidyanathan, Srinivasan, Control Groups: Pagecache accounting and control "
"subsystem (v3), http://lwn.net/Articles/235534/"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:954
msgid ""
"Singh, Balbir. RSS controller v2 test results (lmbench), https://lore.kernel."
"org/r/464C95D4.7070806@linux.vnet.ibm.com"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:956
msgid ""
"Singh, Balbir. RSS controller v2 AIM9 results https://lore.kernel.org/"
"r/464D267A.50107@linux.vnet.ibm.com"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:958
msgid ""
"Singh, Balbir. Memory controller v6 test results, https://lore.kernel.org/"
"r/20070819094658.654.84837.sendpatchset@balbir-laptop"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:961
msgid ""
"Singh, Balbir. Memory controller introduction (v6), https://lore.kernel.org/"
"r/20070817084228.26003.12568.sendpatchset@balbir-laptop"
msgstr ""

#: ../../../admin-guide/cgroup-v1/memory.rst:963
msgid ""
"Corbet, Jonathan, Controlling memory use in cgroups, http://lwn.net/"
"Articles/243795/"
msgstr ""
