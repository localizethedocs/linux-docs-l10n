# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../security/keys/core.rst:3
msgid "Kernel Key Retention Service"
msgstr ""

#: ../../../security/keys/core.rst:5
msgid ""
"This service allows cryptographic keys, authentication tokens, cross-domain "
"user mappings, and similar to be cached in the kernel for the use of "
"filesystems and other kernel services."
msgstr ""

#: ../../../security/keys/core.rst:9
msgid ""
"Keyrings are permitted; these are a special type of key that can hold links "
"to other keys. Processes each have three standard keyring subscriptions that "
"a kernel service can search for relevant keys."
msgstr ""

#: ../../../security/keys/core.rst:13
msgid "The key service can be configured on by enabling:"
msgstr ""

#: ../../../security/keys/core.rst:15
msgid ""
"\"Security options\"/\"Enable access key retention support\" (CONFIG_KEYS)"
msgstr ""

#: ../../../security/keys/core.rst:17
msgid "This document has the following sections:"
msgstr ""

#: ../../../security/keys/core.rst:23
msgid "Key Overview"
msgstr ""

#: ../../../security/keys/core.rst:25
msgid ""
"In this context, keys represent units of cryptographic data, authentication "
"tokens, keyrings, etc.. These are represented in the kernel by struct key."
msgstr ""

#: ../../../security/keys/core.rst:28
msgid "Each key has a number of attributes:"
msgstr ""

#: ../../../security/keys/core.rst:30
msgid "A serial number."
msgstr ""

#: ../../../security/keys/core.rst:31
msgid "A type."
msgstr ""

#: ../../../security/keys/core.rst:32
msgid "A description (for matching a key in a search)."
msgstr ""

#: ../../../security/keys/core.rst:33
msgid "Access control information."
msgstr ""

#: ../../../security/keys/core.rst:34
msgid "An expiry time."
msgstr ""

#: ../../../security/keys/core.rst:35
msgid "A payload."
msgstr ""

#: ../../../security/keys/core.rst:36
msgid "State."
msgstr ""

#: ../../../security/keys/core.rst:39
msgid ""
"Each key is issued a serial number of type key_serial_t that is unique for "
"the lifetime of that key. All serial numbers are positive non-zero 32-bit "
"integers."
msgstr ""

#: ../../../security/keys/core.rst:43
msgid ""
"Userspace programs can use a key's serial numbers as a way to gain access to "
"it, subject to permission checking."
msgstr ""

#: ../../../security/keys/core.rst:46
msgid ""
"Each key is of a defined \"type\". Types must be registered inside the "
"kernel by a kernel service (such as a filesystem) before keys of that type "
"can be added or used. Userspace programs cannot define new types directly."
msgstr ""

#: ../../../security/keys/core.rst:50
msgid ""
"Key types are represented in the kernel by struct key_type. This defines a "
"number of operations that can be performed on a key of that type."
msgstr ""

#: ../../../security/keys/core.rst:53
msgid ""
"Should a type be removed from the system, all the keys of that type will be "
"invalidated."
msgstr ""

#: ../../../security/keys/core.rst:56
msgid ""
"Each key has a description. This should be a printable string. The key type "
"provides an operation to perform a match between the description on a key "
"and a criterion string."
msgstr ""

#: ../../../security/keys/core.rst:60
msgid ""
"Each key has an owner user ID, a group ID and a permissions mask. These are "
"used to control what a process may do to a key from userspace, and whether a "
"kernel service will be able to find the key."
msgstr ""

#: ../../../security/keys/core.rst:64
msgid ""
"Each key can be set to expire at a specific time by the key type's "
"instantiation function. Keys can also be immortal."
msgstr ""

#: ../../../security/keys/core.rst:67
msgid ""
"Each key can have a payload. This is a quantity of data that represent the "
"actual \"key\". In the case of a keyring, this is a list of keys to which "
"the keyring links; in the case of a user-defined key, it's an arbitrary blob "
"of data."
msgstr ""

#: ../../../security/keys/core.rst:72
msgid ""
"Having a payload is not required; and the payload can, in fact, just be a "
"value stored in the struct key itself."
msgstr ""

#: ../../../security/keys/core.rst:75
msgid ""
"When a key is instantiated, the key type's instantiation function is called "
"with a blob of data, and that then creates the key's payload in some way."
msgstr ""

#: ../../../security/keys/core.rst:79
msgid ""
"Similarly, when userspace wants to read back the contents of the key, if "
"permitted, another key type operation will be called to convert the key's "
"attached payload back into a blob of data."
msgstr ""

#: ../../../security/keys/core.rst:83
msgid "Each key can be in one of a number of basic states:"
msgstr ""

#: ../../../security/keys/core.rst:85
msgid ""
"Uninstantiated. The key exists, but does not have any data attached. Keys "
"being requested from userspace will be in this state."
msgstr ""

#: ../../../security/keys/core.rst:88
msgid ""
"Instantiated. This is the normal state. The key is fully formed, and has "
"data attached."
msgstr ""

#: ../../../security/keys/core.rst:91
msgid ""
"Negative. This is a relatively short-lived state. The key acts as a note "
"saying that a previous call out to userspace failed, and acts as a throttle "
"on key lookups. A negative key can be updated to a normal state."
msgstr ""

#: ../../../security/keys/core.rst:96
msgid ""
"Expired. Keys can have lifetimes set. If their lifetime is exceeded, they "
"traverse to this state. An expired key can be updated back to a normal state."
msgstr ""

#: ../../../security/keys/core.rst:100
msgid ""
"Revoked. A key is put in this state by userspace action. It can't be found "
"or operated upon (apart from by unlinking it)."
msgstr ""

#: ../../../security/keys/core.rst:103
msgid "Dead. The key's type was unregistered, and so the key is now useless."
msgstr ""

#: ../../../security/keys/core.rst:105
msgid ""
"Keys in the last three states are subject to garbage collection.  See the "
"section on \"Garbage collection\"."
msgstr ""

#: ../../../security/keys/core.rst:110
msgid "Key Service Overview"
msgstr ""

#: ../../../security/keys/core.rst:112
msgid "The key service provides a number of features besides keys:"
msgstr ""

#: ../../../security/keys/core.rst:114
msgid "The key service defines three special key types:"
msgstr ""

#: ../../../security/keys/core.rst:116
msgid "(+) \"keyring\""
msgstr ""

#: ../../../security/keys/core.rst:118
msgid ""
"Keyrings are special keys that contain a list of other keys. Keyring lists "
"can be modified using various system calls. Keyrings should not be given a "
"payload when created."
msgstr ""

#: ../../../security/keys/core.rst:122
msgid "(+) \"user\""
msgstr ""

#: ../../../security/keys/core.rst:124
msgid ""
"A key of this type has a description and a payload that are arbitrary blobs "
"of data. These can be created, updated and read by userspace, and aren't "
"intended for use by kernel services."
msgstr ""

#: ../../../security/keys/core.rst:128
msgid "(+) \"logon\""
msgstr ""

#: ../../../security/keys/core.rst:130
msgid ""
"Like a \"user\" key, a \"logon\" key has a payload that is an arbitrary blob "
"of data. It is intended as a place to store secrets which are accessible to "
"the kernel but not to userspace programs."
msgstr ""

#: ../../../security/keys/core.rst:134
msgid ""
"The description can be arbitrary, but must be prefixed with a non-zero "
"length string that describes the key \"subclass\". The subclass is separated "
"from the rest of the description by a ':'. \"logon\" keys can be created and "
"updated from userspace, but the payload is only readable from kernel space."
msgstr ""

#: ../../../security/keys/core.rst:140
msgid ""
"Each process subscribes to three keyrings: a thread-specific keyring, a "
"process-specific keyring, and a session-specific keyring."
msgstr ""

#: ../../../security/keys/core.rst:143
msgid ""
"The thread-specific keyring is discarded from the child when any sort of "
"clone, fork, vfork or execve occurs. A new keyring is created only when "
"required."
msgstr ""

#: ../../../security/keys/core.rst:147
msgid ""
"The process-specific keyring is replaced with an empty one in the child on "
"clone, fork, vfork unless CLONE_THREAD is supplied, in which case it is "
"shared. execve also discards the process's process keyring and creates a new "
"one."
msgstr ""

#: ../../../security/keys/core.rst:152
msgid ""
"The session-specific keyring is persistent across clone, fork, vfork and "
"execve, even when the latter executes a set-UID or set-GID binary. A process "
"can, however, replace its current session keyring with a new one by using "
"PR_JOIN_SESSION_KEYRING. It is permitted to request an anonymous new one, or "
"to attempt to create or join one of a specific name."
msgstr ""

#: ../../../security/keys/core.rst:158
msgid ""
"The ownership of the thread keyring changes when the real UID and GID of the "
"thread changes."
msgstr ""

#: ../../../security/keys/core.rst:161
msgid ""
"Each user ID resident in the system holds two special keyrings: a user "
"specific keyring and a default user session keyring. The default session "
"keyring is initialised with a link to the user-specific keyring."
msgstr ""

#: ../../../security/keys/core.rst:165
msgid ""
"When a process changes its real UID, if it used to have no session key, it "
"will be subscribed to the default session key for the new UID."
msgstr ""

#: ../../../security/keys/core.rst:168
msgid ""
"If a process attempts to access its session key when it doesn't have one, it "
"will be subscribed to the default for its current UID."
msgstr ""

#: ../../../security/keys/core.rst:171
msgid ""
"Each user has two quotas against which the keys they own are tracked. One "
"limits the total number of keys and keyrings, the other limits the total "
"amount of description and payload space that can be consumed."
msgstr ""

#: ../../../security/keys/core.rst:175
msgid ""
"The user can view information on this and other statistics through procfs "
"files.  The root user may also alter the quota limits through sysctl files "
"(see the section \"New procfs files\")."
msgstr ""

#: ../../../security/keys/core.rst:179
msgid ""
"Process-specific and thread-specific keyrings are not counted towards a "
"user's quota."
msgstr ""

#: ../../../security/keys/core.rst:182
msgid ""
"If a system call that modifies a key or keyring in some way would put the "
"user over quota, the operation is refused and error EDQUOT is returned."
msgstr ""

#: ../../../security/keys/core.rst:185
msgid ""
"There's a system call interface by which userspace programs can create and "
"manipulate keys and keyrings."
msgstr ""

#: ../../../security/keys/core.rst:188
msgid ""
"There's a kernel interface by which services can register types and search "
"for keys."
msgstr ""

#: ../../../security/keys/core.rst:191
msgid ""
"There's a way for the a search done from the kernel to call back to "
"userspace to request a key that can't be found in a process's keyrings."
msgstr ""

#: ../../../security/keys/core.rst:194
msgid ""
"An optional filesystem is available through which the key database can be "
"viewed and manipulated."
msgstr ""

#: ../../../security/keys/core.rst:199
msgid "Key Access Permissions"
msgstr ""

#: ../../../security/keys/core.rst:201
msgid ""
"Keys have an owner user ID, a group access ID, and a permissions mask. The "
"mask has up to eight bits each for possessor, user, group and other access. "
"Only six of each set of eight bits are defined. These permissions granted "
"are:"
msgstr ""

#: ../../../security/keys/core.rst:205
msgid "View"
msgstr ""

#: ../../../security/keys/core.rst:207
msgid ""
"This permits a key or keyring's attributes to be viewed - including key type "
"and description."
msgstr ""

#: ../../../security/keys/core.rst:210
msgid "Read"
msgstr ""

#: ../../../security/keys/core.rst:212
msgid ""
"This permits a key's payload to be viewed or a keyring's list of linked keys."
msgstr ""

#: ../../../security/keys/core.rst:215
msgid "Write"
msgstr ""

#: ../../../security/keys/core.rst:217
msgid ""
"This permits a key's payload to be instantiated or updated, or it allows a "
"link to be added to or removed from a keyring."
msgstr ""

#: ../../../security/keys/core.rst:220
msgid "Search"
msgstr ""

#: ../../../security/keys/core.rst:222
msgid ""
"This permits keyrings to be searched and keys to be found. Searches can only "
"recurse into nested keyrings that have search permission set."
msgstr ""

#: ../../../security/keys/core.rst:225
msgid "Link"
msgstr ""

#: ../../../security/keys/core.rst:227
msgid ""
"This permits a key or keyring to be linked to. To create a link from a "
"keyring to a key, a process must have Write permission on the keyring and "
"Link permission on the key."
msgstr ""

#: ../../../security/keys/core.rst:231
msgid "Set Attribute"
msgstr ""

#: ../../../security/keys/core.rst:233
msgid "This permits a key's UID, GID and permissions mask to be changed."
msgstr ""

#: ../../../security/keys/core.rst:235
msgid ""
"For changing the ownership, group ID or permissions mask, being the owner of "
"the key or having the sysadmin capability is sufficient."
msgstr ""

#: ../../../security/keys/core.rst:240
msgid "SELinux Support"
msgstr ""

#: ../../../security/keys/core.rst:242
msgid ""
"The security class \"key\" has been added to SELinux so that mandatory "
"access controls can be applied to keys created within various contexts.  "
"This support is preliminary, and is likely to change quite significantly in "
"the near future. Currently, all of the basic permissions explained above are "
"provided in SELinux as well; SELinux is simply invoked after all basic "
"permission checks have been performed."
msgstr ""

#: ../../../security/keys/core.rst:249
msgid ""
"The value of the file /proc/self/attr/keycreate influences the labeling of "
"newly-created keys.  If the contents of that file correspond to an SELinux "
"security context, then the key will be assigned that context.  Otherwise, "
"the key will be assigned the current context of the task that invoked the "
"key creation request.  Tasks must be granted explicit permission to assign a "
"particular context to newly-created keys, using the \"create\" permission in "
"the key security class."
msgstr ""

#: ../../../security/keys/core.rst:257
msgid ""
"The default keyrings associated with users will be labeled with the default "
"context of the user if and only if the login programs have been instrumented "
"to properly initialize keycreate during the login process.  Otherwise, they "
"will be labeled with the context of the login program itself."
msgstr ""

#: ../../../security/keys/core.rst:262
msgid ""
"Note, however, that the default keyrings associated with the root user are "
"labeled with the default kernel context, since they are created early in the "
"boot process, before root has a chance to log in."
msgstr ""

#: ../../../security/keys/core.rst:266
msgid ""
"The keyrings associated with new threads are each labeled with the context "
"of their associated thread, and both session and process keyrings are "
"handled similarly."
msgstr ""

#: ../../../security/keys/core.rst:272
msgid "New ProcFS Files"
msgstr ""

#: ../../../security/keys/core.rst:274
msgid ""
"Two files have been added to procfs by which an administrator can find out "
"about the status of the key service:"
msgstr ""

#: ../../../security/keys/core.rst:277
msgid "/proc/keys"
msgstr ""

#: ../../../security/keys/core.rst:279
msgid ""
"This lists the keys that are currently viewable by the task reading the "
"file, giving information about their type, description and permissions. It "
"is not possible to view the payload of the key this way, though some "
"information about it may be given."
msgstr ""

#: ../../../security/keys/core.rst:284
msgid ""
"The only keys included in the list are those that grant View permission to "
"the reading process whether or not it possesses them.  Note that LSM "
"security checks are still performed, and may further filter out keys that "
"the current process is not authorised to view."
msgstr ""

#: ../../../security/keys/core.rst:289
msgid "The contents of the file look like this::"
msgstr ""

#: ../../../security/keys/core.rst:302
msgid "The flags are::"
msgstr ""

#: ../../../security/keys/core.rst:312
msgid "/proc/key-users"
msgstr ""

#: ../../../security/keys/core.rst:314
msgid ""
"This file lists the tracking data for each user that has at least one key on "
"the system.  Such data includes quota information and statistics::"
msgstr ""

#: ../../../security/keys/core.rst:323
msgid "The format of each line is::"
msgstr ""

#: ../../../security/keys/core.rst:332
msgid ""
"Four new sysctl files have been added also for the purpose of controlling "
"the quota limits on keys:"
msgstr ""

#: ../../../security/keys/core.rst:335
msgid "/proc/sys/kernel/keys/root_maxkeys /proc/sys/kernel/keys/root_maxbytes"
msgstr ""

#: ../../../security/keys/core.rst:338
msgid ""
"These files hold the maximum number of keys that root may have and the "
"maximum total number of bytes of data that root may have stored in those "
"keys."
msgstr ""

#: ../../../security/keys/core.rst:342
msgid "/proc/sys/kernel/keys/maxkeys /proc/sys/kernel/keys/maxbytes"
msgstr ""

#: ../../../security/keys/core.rst:345
msgid ""
"These files hold the maximum number of keys that each non-root user may have "
"and the maximum total number of bytes of data that each of those users may "
"have stored in their keys."
msgstr ""

#: ../../../security/keys/core.rst:349
msgid ""
"Root may alter these by writing each new limit as a decimal number string to "
"the appropriate file."
msgstr ""

#: ../../../security/keys/core.rst:354
msgid "Userspace System Call Interface"
msgstr ""

#: ../../../security/keys/core.rst:356
msgid ""
"Userspace can manipulate keys directly through three new syscalls: add_key, "
"request_key and keyctl. The latter provides a number of functions for "
"manipulating keys."
msgstr ""

#: ../../../security/keys/core.rst:360
msgid ""
"When referring to a key directly, userspace programs should use the key's "
"serial number (a positive 32-bit integer). However, there are some special "
"values available for referring to special keys and keyrings that relate to "
"the process making the call::"
msgstr ""

#: ../../../security/keys/core.rst:377
msgid "The main syscalls are:"
msgstr ""

#: ../../../security/keys/core.rst:379
msgid ""
"Create a new key of given type, description and payload and add it to the "
"nominated keyring::"
msgstr ""

#: ../../../security/keys/core.rst:386
msgid ""
"If a key of the same type and description as that proposed already exists in "
"the keyring, this will try to update it with the given payload, or it will "
"return error EEXIST if that function is not supported by the key type. The "
"process must also have permission to write to the key to be able to update "
"it. The new key will have all user permissions granted and no group or third "
"party permissions."
msgstr ""

#: ../../../security/keys/core.rst:393
msgid ""
"Otherwise, this will attempt to create a new key of the specified type and "
"description, and to instantiate it with the supplied payload and attach it "
"to the keyring. In this case, an error will be generated if the process does "
"not have permission to write to the keyring."
msgstr ""

#: ../../../security/keys/core.rst:398
msgid ""
"If the key type supports it, if the description is NULL or an empty string, "
"the key type will try and generate a description from the content of the "
"payload."
msgstr ""

#: ../../../security/keys/core.rst:402
msgid ""
"The payload is optional, and the pointer can be NULL if not required by the "
"type. The payload is plen in size, and plen can be zero for an empty payload."
msgstr ""

#: ../../../security/keys/core.rst:406
msgid ""
"A new keyring can be generated by setting type \"keyring\", the keyring name "
"as the description (or NULL) and setting the payload to NULL."
msgstr ""

#: ../../../security/keys/core.rst:409
msgid ""
"User defined keys can be created by specifying type \"user\". It is "
"recommended that a user defined key's description by prefixed with a type ID "
"and a colon, such as \"krb5tgt:\" for a Kerberos 5 ticket granting ticket."
msgstr ""

#: ../../../security/keys/core.rst:414
msgid ""
"Any other type must have been registered with the kernel in advance by a "
"kernel service such as a filesystem."
msgstr ""

#: ../../../security/keys/core.rst:417
msgid "The ID of the new or updated key is returned if successful."
msgstr ""

#: ../../../security/keys/core.rst:420
msgid ""
"Search the process's keyrings for a key, potentially calling out to "
"userspace to create it::"
msgstr ""

#: ../../../security/keys/core.rst:427
msgid ""
"This function searches all the process's keyrings in the order thread, "
"process, session for a matching key. This works very much like "
"KEYCTL_SEARCH, including the optional attachment of the discovered key to a "
"keyring."
msgstr ""

#: ../../../security/keys/core.rst:432
msgid ""
"If a key cannot be found, and if callout_info is not NULL, then /sbin/"
"request-key will be invoked in an attempt to obtain a key. The callout_info "
"string will be passed as an argument to the program."
msgstr ""

#: ../../../security/keys/core.rst:436
msgid ""
"To link a key into the destination keyring the key must grant link "
"permission on the key to the caller and the keyring must grant write "
"permission."
msgstr ""

#: ../../../security/keys/core.rst:440 ../../../security/keys/core.rst:1163
msgid "See also Documentation/security/keys/request-key.rst."
msgstr ""

#: ../../../security/keys/core.rst:443
msgid "The keyctl syscall functions are:"
msgstr ""

#: ../../../security/keys/core.rst:445
msgid "Map a special key ID to a real key ID for this process::"
msgstr ""

#: ../../../security/keys/core.rst:450
msgid ""
"The special key specified by \"id\" is looked up (with the key being created "
"if necessary) and the ID of the key or keyring thus found is returned if it "
"exists."
msgstr ""

#: ../../../security/keys/core.rst:454
msgid ""
"If the key does not yet exist, the key will be created if \"create\" is non-"
"zero; and the error ENOKEY will be returned if \"create\" is zero."
msgstr ""

#: ../../../security/keys/core.rst:458
msgid "Replace the session keyring this process subscribes to with a new one::"
msgstr ""

#: ../../../security/keys/core.rst:462
msgid ""
"If name is NULL, an anonymous keyring is created attached to the process as "
"its session keyring, displacing the old session keyring."
msgstr ""

#: ../../../security/keys/core.rst:465
msgid ""
"If name is not NULL, if a keyring of that name exists, the process attempts "
"to attach it as the session keyring, returning an error if that is not "
"permitted; otherwise a new keyring of that name is created and attached as "
"the session keyring."
msgstr ""

#: ../../../security/keys/core.rst:470
msgid ""
"To attach to a named keyring, the keyring must have search permission for "
"the process's ownership."
msgstr ""

#: ../../../security/keys/core.rst:473
msgid "The ID of the new session keyring is returned if successful."
msgstr ""

#: ../../../security/keys/core.rst:476
msgid "Update the specified key::"
msgstr ""

#: ../../../security/keys/core.rst:481
msgid ""
"This will try to update the specified key with the given payload, or it will "
"return error EOPNOTSUPP if that function is not supported by the key type. "
"The process must also have permission to write to the key to be able to "
"update it."
msgstr ""

#: ../../../security/keys/core.rst:486
msgid ""
"The payload is of length plen, and may be absent or empty as for add_key()."
msgstr ""

#: ../../../security/keys/core.rst:490
msgid "Revoke a key::"
msgstr ""

#: ../../../security/keys/core.rst:494
msgid ""
"This makes a key unavailable for further operations. Further attempts to use "
"the key will be met with error EKEYREVOKED, and the key will no longer be "
"findable."
msgstr ""

#: ../../../security/keys/core.rst:499
msgid "Change the ownership of a key::"
msgstr ""

#: ../../../security/keys/core.rst:503
msgid ""
"This function permits a key's owner and group ID to be changed. Either one "
"of uid or gid can be set to -1 to suppress that change."
msgstr ""

#: ../../../security/keys/core.rst:506
msgid ""
"Only the superuser can change a key's owner to something other than the "
"key's current owner. Similarly, only the superuser can change a key's group "
"ID to something other than the calling process's group ID or one of its "
"group list members."
msgstr ""

#: ../../../security/keys/core.rst:512
msgid "Change the permissions mask on a key::"
msgstr ""

#: ../../../security/keys/core.rst:516
msgid ""
"This function permits the owner of a key or the superuser to change the "
"permissions mask on a key."
msgstr ""

#: ../../../security/keys/core.rst:519
msgid ""
"Only bits the available bits are permitted; if any other bits are set, error "
"EINVAL will be returned."
msgstr ""

#: ../../../security/keys/core.rst:523
msgid "Describe a key::"
msgstr ""

#: ../../../security/keys/core.rst:528
msgid ""
"This function returns a summary of the key's attributes (but not its payload "
"data) as a string in the buffer provided."
msgstr ""

#: ../../../security/keys/core.rst:531 ../../../security/keys/core.rst:787
msgid ""
"Unless there's an error, it always returns the amount of data it could "
"produce, even if that's too big for the buffer, but it won't copy more than "
"requested to userspace. If the buffer pointer is NULL then no copy will take "
"place."
msgstr ""

#: ../../../security/keys/core.rst:536 ../../../security/keys/core.rst:796
msgid ""
"A process must have view permission on the key for this function to be "
"successful."
msgstr ""

#: ../../../security/keys/core.rst:539
msgid ""
"If successful, a string is placed in the buffer in the following format::"
msgstr ""

#: ../../../security/keys/core.rst:543
msgid ""
"Where type and description are strings, uid and gid are decimal, and perm is "
"hexadecimal. A NUL character is included at the end of the string if the "
"buffer is sufficiently big."
msgstr ""

#: ../../../security/keys/core.rst:547
msgid "This can be parsed with::"
msgstr ""

#: ../../../security/keys/core.rst:552
msgid "Clear out a keyring::"
msgstr ""

#: ../../../security/keys/core.rst:556
msgid ""
"This function clears the list of keys attached to a keyring. The calling "
"process must have write permission on the keyring, and it must be a keyring "
"(or else error ENOTDIR will result)."
msgstr ""

#: ../../../security/keys/core.rst:560
msgid ""
"This function can also be used to clear special kernel keyrings if they are "
"appropriately marked if the user has CAP_SYS_ADMIN capability.  The DNS "
"resolver cache keyring is an example of this."
msgstr ""

#: ../../../security/keys/core.rst:565
msgid "Link a key into a keyring::"
msgstr ""

#: ../../../security/keys/core.rst:569
msgid ""
"This function creates a link from the keyring to the key. The process must "
"have write permission on the keyring and must have link permission on the "
"key."
msgstr ""

#: ../../../security/keys/core.rst:573
msgid ""
"Should the keyring not be a keyring, error ENOTDIR will result; and if the "
"keyring is full, error ENFILE will result."
msgstr ""

#: ../../../security/keys/core.rst:576
msgid ""
"The link procedure checks the nesting of the keyrings, returning ELOOP if it "
"appears too deep or EDEADLK if the link would introduce a cycle."
msgstr ""

#: ../../../security/keys/core.rst:579
msgid ""
"Any links within the keyring to keys that match the new key in terms of type "
"and description will be discarded from the keyring as the new one is added."
msgstr ""

#: ../../../security/keys/core.rst:584
msgid "Move a key from one keyring to another::"
msgstr ""

#: ../../../security/keys/core.rst:592
msgid ""
"Move the key specified by \"id\" from the keyring specified by "
"\"from_ring_id\" to the keyring specified by \"to_ring_id\".  If the two "
"keyrings are the same, nothing is done."
msgstr ""

#: ../../../security/keys/core.rst:596
msgid ""
"\"flags\" can have KEYCTL_MOVE_EXCL set in it to cause the operation to fail "
"with EEXIST if a matching key exists in the destination keyring, otherwise "
"such a key will be replaced."
msgstr ""

#: ../../../security/keys/core.rst:600
msgid ""
"A process must have link permission on the key for this function to be "
"successful and write permission on both keyrings.  Any errors that can occur "
"from KEYCTL_LINK also apply on the destination keyring here."
msgstr ""

#: ../../../security/keys/core.rst:605
msgid "Unlink a key or keyring from another keyring::"
msgstr ""

#: ../../../security/keys/core.rst:609
msgid ""
"This function looks through the keyring for the first link to the specified "
"key, and removes it if found. Subsequent links to that key are ignored. The "
"process must have write permission on the keyring."
msgstr ""

#: ../../../security/keys/core.rst:613
msgid ""
"If the keyring is not a keyring, error ENOTDIR will result; and if the key "
"is not present, error ENOENT will be the result."
msgstr ""

#: ../../../security/keys/core.rst:617
msgid "Search a keyring tree for a key::"
msgstr ""

#: ../../../security/keys/core.rst:623
msgid ""
"This searches the keyring tree headed by the specified keyring until a key "
"is found that matches the type and description criteria. Each keyring is "
"checked for keys before recursion into its children occurs."
msgstr ""

#: ../../../security/keys/core.rst:627
msgid ""
"The process must have search permission on the top level keyring, or else "
"error EACCES will result. Only keyrings that the process has search "
"permission on will be recursed into, and only keys and keyrings for which a "
"process has search permission can be matched. If the specified keyring is "
"not a keyring, ENOTDIR will result."
msgstr ""

#: ../../../security/keys/core.rst:633
msgid ""
"If the search succeeds, the function will attempt to link the found key into "
"the destination keyring if one is supplied (non-zero ID). All the "
"constraints applicable to KEYCTL_LINK apply in this case too."
msgstr ""

#: ../../../security/keys/core.rst:637
msgid ""
"Error ENOKEY, EKEYREVOKED or EKEYEXPIRED will be returned if the search "
"fails. On success, the resulting key ID will be returned."
msgstr ""

#: ../../../security/keys/core.rst:641
msgid "Read the payload data from a key::"
msgstr ""

#: ../../../security/keys/core.rst:646
msgid ""
"This function attempts to read the payload data from the specified key into "
"the buffer. The process must have read permission on the key to succeed."
msgstr ""

#: ../../../security/keys/core.rst:650
msgid ""
"The returned data will be processed for presentation by the key type. For "
"instance, a keyring will return an array of key_serial_t entries "
"representing the IDs of all the keys to which it is subscribed. The user "
"defined key type will return its data as is. If a key type does not "
"implement this function, error EOPNOTSUPP will result."
msgstr ""

#: ../../../security/keys/core.rst:656
msgid ""
"If the specified buffer is too small, then the size of the buffer required "
"will be returned.  Note that in this case, the contents of the buffer may "
"have been overwritten in some undefined way."
msgstr ""

#: ../../../security/keys/core.rst:660
msgid ""
"Otherwise, on success, the function will return the amount of data copied "
"into the buffer."
msgstr ""

#: ../../../security/keys/core.rst:663
msgid "Instantiate a partially constructed key::"
msgstr ""

#: ../../../security/keys/core.rst:672
msgid ""
"If the kernel calls back to userspace to complete the instantiation of a "
"key, userspace should use this call to supply data for the key before the "
"invoked process returns, or else the key will be marked negative "
"automatically."
msgstr ""

#: ../../../security/keys/core.rst:677 ../../../security/keys/core.rst:701
msgid ""
"The process must have write access on the key to be able to instantiate it, "
"and the key must be uninstantiated."
msgstr ""

#: ../../../security/keys/core.rst:680 ../../../security/keys/core.rst:704
msgid ""
"If a keyring is specified (non-zero), the key will also be linked into that "
"keyring, however all the constraints applying in KEYCTL_LINK apply in this "
"case too."
msgstr ""

#: ../../../security/keys/core.rst:684
msgid ""
"The payload and plen arguments describe the payload data as for add_key()."
msgstr ""

#: ../../../security/keys/core.rst:686
msgid ""
"The payload_iov and ioc arguments describe the payload data in an iovec "
"array instead of a single buffer."
msgstr ""

#: ../../../security/keys/core.rst:690
msgid "Negatively instantiate a partially constructed key::"
msgstr ""

#: ../../../security/keys/core.rst:697
msgid ""
"If the kernel calls back to userspace to complete the instantiation of a "
"key, userspace should use this call mark the key as negative before the "
"invoked process returns if it is unable to fulfill the request."
msgstr ""

#: ../../../security/keys/core.rst:708
msgid ""
"If the key is rejected, future searches for it will return the specified "
"error code until the rejected key expires.  Negating the key is the same as "
"rejecting the key with ENOKEY as the error code."
msgstr ""

#: ../../../security/keys/core.rst:713
msgid "Set the default request-key destination keyring::"
msgstr ""

#: ../../../security/keys/core.rst:717
msgid ""
"This sets the default keyring to which implicitly requested keys will be "
"attached for this thread. reqkey_defl should be one of these constants::"
msgstr ""

#: ../../../security/keys/core.rst:731
msgid ""
"The old default will be returned if successful and error EINVAL will be "
"returned if reqkey_defl is not one of the above values."
msgstr ""

#: ../../../security/keys/core.rst:734
msgid ""
"The default keyring can be overridden by the keyring indicated to the "
"request_key() system call."
msgstr ""

#: ../../../security/keys/core.rst:737
msgid "Note that this setting is inherited across fork/exec."
msgstr ""

#: ../../../security/keys/core.rst:739
msgid ""
"[1] The default is: the thread keyring if there is one, otherwise the "
"process keyring if there is one, otherwise the session keyring if there is "
"one, otherwise the user default session keyring."
msgstr ""

#: ../../../security/keys/core.rst:744
msgid "Set the timeout on a key::"
msgstr ""

#: ../../../security/keys/core.rst:748
msgid ""
"This sets or clears the timeout on a key. The timeout can be 0 to clear the "
"timeout or a number of seconds to set the expiry time that far into the "
"future."
msgstr ""

#: ../../../security/keys/core.rst:752
msgid ""
"The process must have attribute modification access on a key to set its "
"timeout. Timeouts may not be set with this function on negative, revoked or "
"expired keys."
msgstr ""

#: ../../../security/keys/core.rst:757
msgid "Assume the authority granted to instantiate a key::"
msgstr ""

#: ../../../security/keys/core.rst:761
msgid ""
"This assumes or divests the authority required to instantiate the specified "
"key. Authority can only be assumed if the thread has the authorisation key "
"associated with the specified key in its keyrings somewhere."
msgstr ""

#: ../../../security/keys/core.rst:766
msgid ""
"Once authority is assumed, searches for keys will also search the "
"requester's keyrings using the requester's security label, UID, GID and "
"groups."
msgstr ""

#: ../../../security/keys/core.rst:770
msgid ""
"If the requested authority is unavailable, error EPERM will be returned, "
"likewise if the authority has been revoked because the target key is already "
"instantiated."
msgstr ""

#: ../../../security/keys/core.rst:774
msgid "If the specified key is 0, then any assumed authority will be divested."
msgstr ""

#: ../../../security/keys/core.rst:776
msgid "The assumed authoritative key is inherited across fork and exec."
msgstr ""

#: ../../../security/keys/core.rst:779
msgid "Get the LSM security context attached to a key::"
msgstr ""

#: ../../../security/keys/core.rst:784
msgid ""
"This function returns a string that represents the LSM security context "
"attached to a key in the buffer provided."
msgstr ""

#: ../../../security/keys/core.rst:792
msgid ""
"A NUL character is included at the end of the string if the buffer is "
"sufficiently big.  This is included in the returned count.  If no LSM is in "
"force then an empty string will be returned."
msgstr ""

#: ../../../security/keys/core.rst:800
msgid "Install the calling process's session keyring on its parent::"
msgstr ""

#: ../../../security/keys/core.rst:804
msgid ""
"This functions attempts to install the calling process's session keyring on "
"to the calling process's parent, replacing the parent's current session "
"keyring."
msgstr ""

#: ../../../security/keys/core.rst:808
msgid ""
"The calling process must have the same ownership as its parent, the keyring "
"must have the same ownership as the calling process, the calling process "
"must have LINK permission on the keyring and the active LSM module mustn't "
"deny permission, otherwise error EPERM will be returned."
msgstr ""

#: ../../../security/keys/core.rst:813
msgid ""
"Error ENOMEM will be returned if there was insufficient memory to complete "
"the operation, otherwise 0 will be returned to indicate success."
msgstr ""

#: ../../../security/keys/core.rst:816
msgid ""
"The keyring will be replaced next time the parent process leaves the kernel "
"and resumes executing userspace."
msgstr ""

#: ../../../security/keys/core.rst:820
msgid "Invalidate a key::"
msgstr ""

#: ../../../security/keys/core.rst:824
msgid ""
"This function marks a key as being invalidated and then wakes up the garbage "
"collector.  The garbage collector immediately removes invalidated keys from "
"all keyrings and deletes the key when its reference count reaches zero."
msgstr ""

#: ../../../security/keys/core.rst:829
msgid ""
"Keys that are marked invalidated become invisible to normal key operations "
"immediately, though they are still visible in /proc/keys until deleted "
"(they're marked with an 'i' flag)."
msgstr ""

#: ../../../security/keys/core.rst:833
msgid ""
"A process must have search permission on the key for this function to be "
"successful."
msgstr ""

#: ../../../security/keys/core.rst:836
msgid "Compute a Diffie-Hellman shared secret or public key::"
msgstr ""

#: ../../../security/keys/core.rst:841
msgid "The params struct contains serial numbers for three keys::"
msgstr ""

#: ../../../security/keys/core.rst:848
msgid "The value computed is::"
msgstr ""

#: ../../../security/keys/core.rst:852
msgid ""
"If the base is the shared generator, the result is the local public key.  If "
"the base is the remote public key, the result is the shared secret."
msgstr ""

#: ../../../security/keys/core.rst:856
msgid "If the parameter kdf is NULL, the following applies:"
msgstr ""

#: ../../../security/keys/core.rst:858
msgid "The buffer length must be at least the length of the prime, or zero."
msgstr ""

#: ../../../security/keys/core.rst:860
msgid ""
"If the buffer length is nonzero, the length of the result is returned when "
"it is successfully calculated and copied in to the buffer. When the buffer "
"length is zero, the minimum required buffer length is returned."
msgstr ""

#: ../../../security/keys/core.rst:865
msgid ""
"The kdf parameter allows the caller to apply a key derivation function (KDF) "
"on the Diffie-Hellman computation where only the result of the KDF is "
"returned to the caller. The KDF is characterized with struct "
"keyctl_kdf_params as follows:"
msgstr ""

#: ../../../security/keys/core.rst:870
msgid ""
"``char *hashname`` specifies the NUL terminated string identifying the hash "
"used from the kernel crypto API and applied for the KDF operation. The KDF "
"implementation complies with SP800-56A as well as with SP800-108 (the "
"counter KDF)."
msgstr ""

#: ../../../security/keys/core.rst:875
msgid ""
"``char *otherinfo`` specifies the OtherInfo data as documented in SP800-56A "
"section 5.8.1.2. The length of the buffer is given with otherinfolen. The "
"format of OtherInfo is defined by the caller. The otherinfo pointer may be "
"NULL if no OtherInfo shall be used."
msgstr ""

#: ../../../security/keys/core.rst:880
msgid ""
"This function will return error EOPNOTSUPP if the key type is not supported, "
"error ENOKEY if the key could not be found, or error EACCES if the key is "
"not readable by the caller. In addition, the function will return EMSGSIZE "
"when the parameter kdf is non-NULL and either the buffer length or the "
"OtherInfo length exceeds the allowed length."
msgstr ""

#: ../../../security/keys/core.rst:888
msgid "Restrict keyring linkage::"
msgstr ""

#: ../../../security/keys/core.rst:893
msgid ""
"An existing keyring can restrict linkage of additional keys by evaluating "
"the contents of the key according to a restriction scheme."
msgstr ""

#: ../../../security/keys/core.rst:896
msgid ""
"\"keyring\" is the key ID for an existing keyring to apply a restriction to. "
"It may be empty or may already have keys linked. Existing linked keys will "
"remain in the keyring even if the new restriction would reject them."
msgstr ""

#: ../../../security/keys/core.rst:900
msgid "\"type\" is a registered key type."
msgstr ""

#: ../../../security/keys/core.rst:902
msgid ""
"\"restriction\" is a string describing how key linkage is to be restricted. "
"The format varies depending on the key type, and the string is passed to the "
"lookup_restriction() function for the requested type.  It may specify a "
"method and relevant data for the restriction such as signature verification "
"or constraints on key payload. If the requested key type is later "
"unregistered, no keys may be added to the keyring after the key type is "
"removed."
msgstr ""

#: ../../../security/keys/core.rst:910
msgid ""
"To apply a keyring restriction the process must have Set Attribute "
"permission and the keyring must not be previously restricted."
msgstr ""

#: ../../../security/keys/core.rst:913
msgid ""
"One application of restricted keyrings is to verify X.509 certificate chains "
"or individual certificate signatures using the asymmetric key type. See "
"Documentation/crypto/asymmetric-keys.rst for specific restrictions "
"applicable to the asymmetric key type."
msgstr ""

#: ../../../security/keys/core.rst:919
msgid "Query an asymmetric key::"
msgstr ""

#: ../../../security/keys/core.rst:926
msgid ""
"Get information about an asymmetric key.  Specific algorithms and encodings "
"may be queried by using the ``params`` argument.  This is a string "
"containing a space- or tab-separated string of key-value pairs. Currently "
"supported keys include ``enc`` and ``hash``.  The information is returned in "
"the keyctl_pkey_query struct::"
msgstr ""

#: ../../../security/keys/core.rst:940
msgid ""
"``supported_ops`` contains a bit mask of flags indicating which ops are "
"supported.  This is constructed from a bitwise-OR of::"
msgstr ""

#: ../../../security/keys/core.rst:945
msgid "``key_size`` indicated the size of the key in bits."
msgstr ""

#: ../../../security/keys/core.rst:947
msgid ""
"``max_*_size`` indicate the maximum sizes in bytes of a blob of data to be "
"signed, a signature blob, a blob to be encrypted and a blob to be decrypted."
msgstr ""

#: ../../../security/keys/core.rst:951
msgid ""
"``__spare[]`` must be set to 0.  This is intended for future use to hand "
"over one or more passphrases needed unlock a key."
msgstr ""

#: ../../../security/keys/core.rst:954
msgid ""
"If successful, 0 is returned.  If the key is not an asymmetric key, "
"EOPNOTSUPP is returned."
msgstr ""

#: ../../../security/keys/core.rst:958
msgid "Encrypt, decrypt, sign or verify a blob using an asymmetric key::"
msgstr ""

#: ../../../security/keys/core.rst:984
msgid ""
"Use an asymmetric key to perform a public-key cryptographic operation a blob "
"of data.  For encryption and verification, the asymmetric key may only need "
"the public parts to be available, but for decryption and signing the private "
"parts are required also."
msgstr ""

#: ../../../security/keys/core.rst:989
msgid ""
"The parameter block pointed to by params contains a number of integer "
"values::"
msgstr ""

#: ../../../security/keys/core.rst:997
msgid ""
"``key_id`` is the ID of the asymmetric key to be used.  ``in_len`` and "
"``in2_len`` indicate the amount of data in the in and in2 buffers and "
"``out_len`` indicates the size of the out buffer as appropriate for the "
"above operations."
msgstr ""

#: ../../../security/keys/core.rst:1002
msgid "For a given operation, the in and out buffers are used as follows::"
msgstr ""

#: ../../../security/keys/core.rst:1011
msgid ""
"``info`` is a string of key=value pairs that supply supplementary "
"information.  These include:"
msgstr ""

#: ../../../security/keys/core.rst:1014
msgid "``enc=<encoding>`` The encoding of the encrypted/signature blob.  This"
msgstr ""

#: ../../../security/keys/core.rst:1015
msgid ""
"can be \"pkcs1\" for RSASSA-PKCS1-v1.5 or RSAES-PKCS1-v1.5; \"pss\" for "
"\"RSASSA-PSS\"; \"oaep\" for \"RSAES-OAEP\".  If omitted or is \"raw\", the "
"raw output of the encryption function is specified."
msgstr ""

#: ../../../security/keys/core.rst:1020
msgid "``hash=<algo>`` If the data buffer contains the output of a hash"
msgstr ""

#: ../../../security/keys/core.rst:1021
msgid ""
"function and the encoding includes some indication of which hash function "
"was used, the hash function can be specified with this, eg. \"hash=sha256\"."
msgstr ""

#: ../../../security/keys/core.rst:1025
msgid ""
"The ``__spare[]`` space in the parameter block must be set to 0.  This is "
"intended, amongst other things, to allow the passing of passphrases required "
"to unlock a key."
msgstr ""

#: ../../../security/keys/core.rst:1029
msgid ""
"If successful, encrypt, decrypt and sign all return the amount of data "
"written into the output buffer.  Verification returns 0 on success."
msgstr ""

#: ../../../security/keys/core.rst:1033
msgid "Watch a key or keyring for changes::"
msgstr ""

#: ../../../security/keys/core.rst:1038
msgid ""
"This will set or remove a watch for changes on the specified key or keyring."
msgstr ""

#: ../../../security/keys/core.rst:1041
msgid "\"key\" is the ID of the key to be watched."
msgstr ""

#: ../../../security/keys/core.rst:1043
msgid ""
"\"queue_fd\" is a file descriptor referring to an open pipe which manages "
"the buffer into which notifications will be delivered."
msgstr ""

#: ../../../security/keys/core.rst:1046
msgid ""
"\"filter\" is either NULL to remove a watch or a filter specification to "
"indicate what events are required from the key."
msgstr ""

#: ../../../security/keys/core.rst:1049
msgid "See Documentation/core-api/watch_queue.rst for more information."
msgstr ""

#: ../../../security/keys/core.rst:1051
msgid ""
"Note that only one watch may be emplaced for any particular { key, "
"queue_fd } combination."
msgstr ""

#: ../../../security/keys/core.rst:1054
msgid "Notification records look like::"
msgstr ""

#: ../../../security/keys/core.rst:1062
msgid ""
"In this, watch::type will be \"WATCH_TYPE_KEY_NOTIFY\" and subtype will be "
"one of::"
msgstr ""

#: ../../../security/keys/core.rst:1074
msgid ""
"Where these indicate a key being instantiated/rejected, updated, a link "
"being made in a keyring, a link being removed from a keyring, a keyring "
"being cleared, a key being revoked, a key being invalidated or a key having "
"one of its attributes changed (user, group, perm, timeout, restriction)."
msgstr ""

#: ../../../security/keys/core.rst:1080
msgid ""
"If a watched key is deleted, a basic watch_notification will be issued with "
"\"type\" set to WATCH_TYPE_META and \"subtype\" set to "
"watch_meta_removal_notification.  The watchpoint ID will be set in the "
"\"info\" field."
msgstr ""

#: ../../../security/keys/core.rst:1085
msgid "This needs to be configured by enabling:"
msgstr ""

#: ../../../security/keys/core.rst:1087
msgid "\"Provide key/keyring change notifications\" (KEY_NOTIFICATIONS)"
msgstr ""

#: ../../../security/keys/core.rst:1091
msgid "Kernel Services"
msgstr ""

#: ../../../security/keys/core.rst:1093
msgid ""
"The kernel services for key management are fairly simple to deal with. They "
"can be broken down into two areas: keys and key types."
msgstr ""

#: ../../../security/keys/core.rst:1096
msgid ""
"Dealing with keys is fairly straightforward. Firstly, the kernel service "
"registers its type, then it searches for a key of that type. It should "
"retain the key as long as it has need of it, and then it should release it. "
"For a filesystem or device file, a search would probably be performed during "
"the open call, and the key released upon close. How to deal with conflicting "
"keys due to two different users opening the same file is left to the "
"filesystem author to solve."
msgstr ""

#: ../../../security/keys/core.rst:1104
msgid "To access the key manager, the following header must be #included::"
msgstr ""

#: ../../../security/keys/core.rst:1108
msgid ""
"Specific key types should have a header file under include/keys/ that should "
"be used to access that type.  For keys of type \"user\", for example, that "
"would be::"
msgstr ""

#: ../../../security/keys/core.rst:1113
msgid ""
"Note that there are two different types of pointers to keys that may be "
"encountered:"
msgstr ""

#: ../../../security/keys/core.rst:1116
msgid "struct key *"
msgstr ""

#: ../../../security/keys/core.rst:1118
msgid ""
"This simply points to the key structure itself. Key structures will be at "
"least four-byte aligned."
msgstr ""

#: ../../../security/keys/core.rst:1121
msgid "key_ref_t"
msgstr ""

#: ../../../security/keys/core.rst:1123
msgid ""
"This is equivalent to a ``struct key *``, but the least significant bit is "
"set if the caller \"possesses\" the key. By \"possession\" it is meant that "
"the calling processes has a searchable link to the key from one of its "
"keyrings. There are three functions for dealing with these::"
msgstr ""

#: ../../../security/keys/core.rst:1134
msgid ""
"The first function constructs a key reference from a key pointer and "
"possession information (which must be true or false)."
msgstr ""

#: ../../../security/keys/core.rst:1137
msgid ""
"The second function retrieves the key pointer from a reference and the third "
"retrieves the possession flag."
msgstr ""

#: ../../../security/keys/core.rst:1140
msgid ""
"When accessing a key's payload contents, certain precautions must be taken "
"to prevent access vs modification races. See the section \"Notes on "
"accessing payload contents\" for more information."
msgstr ""

#: ../../../security/keys/core.rst:1144
msgid "To search for a key, call::"
msgstr ""

#: ../../../security/keys/core.rst:1150
msgid ""
"This is used to request a key or keyring with a description that matches the "
"description specified according to the key type's match_preparse() method. "
"This permits approximate matching to occur. If callout_string is not NULL, "
"then /sbin/request-key will be invoked in an attempt to obtain the key from "
"userspace. In that case, callout_string will be passed as an argument to the "
"program."
msgstr ""

#: ../../../security/keys/core.rst:1157
msgid ""
"Should the function fail error ENOKEY, EKEYEXPIRED or EKEYREVOKED will be "
"returned."
msgstr ""

#: ../../../security/keys/core.rst:1160
msgid ""
"If successful, the key will have been attached to the default keyring for "
"implicitly obtained request-key keys, as set by KEYCTL_SET_REQKEY_KEYRING."
msgstr ""

#: ../../../security/keys/core.rst:1166
msgid "To search for a key in a specific domain, call::"
msgstr ""

#: ../../../security/keys/core.rst:1173
msgid ""
"This is identical to request_key(), except that a domain tag may be "
"specifies that causes search algorithm to only match keys matching that "
"tag.  The domain_tag may be NULL, specifying a global domain that is "
"separate from any nominated domain."
msgstr ""

#: ../../../security/keys/core.rst:1179
msgid "To search for a key, passing auxiliary data to the upcaller, call::"
msgstr ""

#: ../../../security/keys/core.rst:1188
msgid ""
"This is identical to request_key_tag(), except that the auxiliary data is "
"passed to the key_type->request_key() op if it exists, and the callout_info "
"is a blob of length callout_len, if given (the length may be 0)."
msgstr ""

#: ../../../security/keys/core.rst:1194
msgid "To search for a key under RCU conditions, call::"
msgstr ""

#: ../../../security/keys/core.rst:1200
msgid ""
"which is similar to request_key_tag() except that it does not check for keys "
"that are under construction and it will not call out to userspace to "
"construct a key if it can't find a match."
msgstr ""

#: ../../../security/keys/core.rst:1205
msgid "When it is no longer required, the key should be released using::"
msgstr ""

#: ../../../security/keys/core.rst:1209
msgid "Or::"
msgstr ""

#: ../../../security/keys/core.rst:1213
msgid ""
"These can be called from interrupt context. If CONFIG_KEYS is not set then "
"the argument will not be parsed."
msgstr ""

#: ../../../security/keys/core.rst:1217
msgid ""
"Extra references can be made to a key by calling one of the following "
"functions::"
msgstr ""

#: ../../../security/keys/core.rst:1223
msgid ""
"Keys so references will need to be disposed of by calling key_put() when "
"they've been finished with.  The key pointer passed in will be returned."
msgstr ""

#: ../../../security/keys/core.rst:1226
msgid ""
"In the case of key_get(), if the pointer is NULL or CONFIG_KEYS is not set "
"then the key will not be dereferenced and no increment will take place."
msgstr ""

#: ../../../security/keys/core.rst:1230
msgid "A key's serial number can be obtained by calling::"
msgstr ""

#: ../../../security/keys/core.rst:1234
msgid ""
"If key is NULL or if CONFIG_KEYS is not set then 0 will be returned (in the "
"latter case without parsing the argument)."
msgstr ""

#: ../../../security/keys/core.rst:1238
msgid "If a keyring was found in the search, this can be further searched by::"
msgstr ""

#: ../../../security/keys/core.rst:1245
msgid ""
"This searches the specified keyring only (recurse == false) or keyring tree "
"(recurse == true) specified for a matching key. Error ENOKEY is returned "
"upon failure (use IS_ERR/PTR_ERR to determine). If successful, the returned "
"key will need to be released."
msgstr ""

#: ../../../security/keys/core.rst:1250
msgid ""
"The possession attribute from the keyring reference is used to control "
"access through the permissions mask and is propagated to the returned key "
"reference pointer if successful."
msgstr ""

#: ../../../security/keys/core.rst:1255
msgid "A keyring can be created by::"
msgstr ""

#: ../../../security/keys/core.rst:1264
msgid ""
"This creates a keyring with the given attributes and returns it.  If dest is "
"not NULL, the new keyring will be linked into the keyring to which it "
"points.  No permission checks are made upon the destination keyring."
msgstr ""

#: ../../../security/keys/core.rst:1268
msgid ""
"Error EDQUOT can be returned if the keyring would overload the quota (pass "
"KEY_ALLOC_NOT_IN_QUOTA in flags if the keyring shouldn't be accounted "
"towards the user's quota).  Error ENOMEM can also be returned."
msgstr ""

#: ../../../security/keys/core.rst:1272
msgid ""
"If restrict_link is not NULL, it should point to a structure that contains "
"the function that will be called each time an attempt is made to link a key "
"into the new keyring.  The structure may also contain a key pointer and an "
"associated key type.  The function is called to check whether a key may be "
"added into the keyring or not.  The key type is used by the garbage "
"collector to clean up function or data pointers in this structure if the "
"given key type is unregistered.  Callers of key_create_or_update() within "
"the kernel can pass KEY_ALLOC_BYPASS_RESTRICTION to suppress the check. An "
"example of using this is to manage rings of cryptographic keys that are set "
"up when the kernel boots where userspace is also permitted to add keys - "
"provided they can be verified by a key the kernel already has."
msgstr ""

#: ../../../security/keys/core.rst:1284
msgid ""
"When called, the restriction function will be passed the keyring being added "
"to, the key type, the payload of the key being added, and data to be used in "
"the restriction check.  Note that when a new key is being created, this is "
"called between payload preparsing and actual key creation.  The function "
"should return 0 to allow the link or an error to reject it."
msgstr ""

#: ../../../security/keys/core.rst:1290
msgid ""
"A convenience function, restrict_link_reject, exists to always return -EPERM "
"to in this case."
msgstr ""

#: ../../../security/keys/core.rst:1294
msgid "To check the validity of a key, this function can be called::"
msgstr ""

#: ../../../security/keys/core.rst:1298
msgid ""
"This checks that the key in question hasn't expired or and hasn't been "
"revoked. Should the key be invalid, error EKEYEXPIRED or EKEYREVOKED will be "
"returned. If the key is NULL or if CONFIG_KEYS is not set then 0 will be "
"returned (in the latter case without parsing the argument)."
msgstr ""

#: ../../../security/keys/core.rst:1304
msgid "To register a key type, the following function should be called::"
msgstr ""

#: ../../../security/keys/core.rst:1308
msgid ""
"This will return error EEXIST if a type of the same name is already present."
msgstr ""

#: ../../../security/keys/core.rst:1312
msgid "To unregister a key type, call::"
msgstr ""

#: ../../../security/keys/core.rst:1317
msgid ""
"Under some circumstances, it may be desirable to deal with a bundle of keys. "
"The facility provides access to the keyring type for managing such a bundle::"
msgstr ""

#: ../../../security/keys/core.rst:1322
msgid ""
"This can be used with a function such as request_key() to find a specific "
"keyring in a process's keyrings.  A keyring thus found can then be searched "
"with keyring_search().  Note that it is not possible to use request_key() to "
"search a specific keyring, so using keyrings in this way is of limited "
"utility."
msgstr ""

#: ../../../security/keys/core.rst:1329
msgid "Notes On Accessing Payload Contents"
msgstr ""

#: ../../../security/keys/core.rst:1331
msgid ""
"The simplest payload is just data stored in key->payload directly.  In this "
"case, there's no need to indulge in RCU or locking when accessing the "
"payload."
msgstr ""

#: ../../../security/keys/core.rst:1334
msgid ""
"More complex payload contents must be allocated and pointers to them set in "
"the key->payload.data[] array.  One of the following ways must be selected "
"to access the data:"
msgstr ""

#: ../../../security/keys/core.rst:1338
msgid "Unmodifiable key type."
msgstr ""

#: ../../../security/keys/core.rst:1340
msgid ""
"If the key type does not have a modify method, then the key's payload can be "
"accessed without any form of locking, provided that it's known to be "
"instantiated (uninstantiated keys cannot be \"found\")."
msgstr ""

#: ../../../security/keys/core.rst:1344
msgid "The key's semaphore."
msgstr ""

#: ../../../security/keys/core.rst:1346
msgid ""
"The semaphore could be used to govern access to the payload and to control "
"the payload pointer. It must be write-locked for modifications and would "
"have to be read-locked for general access. The disadvantage of doing this is "
"that the accessor may be required to sleep."
msgstr ""

#: ../../../security/keys/core.rst:1351
msgid "RCU."
msgstr ""

#: ../../../security/keys/core.rst:1353
msgid ""
"RCU must be used when the semaphore isn't already held; if the semaphore is "
"held then the contents can't change under you unexpectedly as the semaphore "
"must still be used to serialise modifications to the key. The key management "
"code takes care of this for the key type."
msgstr ""

#: ../../../security/keys/core.rst:1358
msgid "However, this means using::"
msgstr ""

#: ../../../security/keys/core.rst:1362
msgid "to read the pointer, and::"
msgstr ""

#: ../../../security/keys/core.rst:1366
msgid ""
"to set the pointer and dispose of the old contents after a grace period. "
"Note that only the key type should ever modify a key's payload."
msgstr ""

#: ../../../security/keys/core.rst:1369
msgid ""
"Furthermore, an RCU controlled payload must hold a struct rcu_head for the "
"use of call_rcu() and, if the payload is of variable size, the length of the "
"payload. key->datalen cannot be relied upon to be consistent with the "
"payload just dereferenced if the key's semaphore is not held."
msgstr ""

#: ../../../security/keys/core.rst:1374
msgid ""
"Note that key->payload.data[0] has a shadow that is marked for __rcu usage.  "
"This is called key->payload.rcu_data0.  The following accessors wrap the RCU "
"calls to this element:"
msgstr ""

#: ../../../security/keys/core.rst:1378
msgid "Set or change the first payload pointer::"
msgstr ""

#: ../../../security/keys/core.rst:1382
msgid "Read the first payload pointer with the key semaphore held::"
msgstr ""

#: ../../../security/keys/core.rst:1390
msgid "Read the first payload pointer with the RCU read lock held::"
msgstr ""

#: ../../../security/keys/core.rst:1396
msgid "Defining a Key Type"
msgstr ""

#: ../../../security/keys/core.rst:1398
msgid ""
"A kernel service may want to define its own key type. For instance, an AFS "
"filesystem might want to define a Kerberos 5 ticket key type. To do this, it "
"author fills in a key_type struct and registers it with the system."
msgstr ""

#: ../../../security/keys/core.rst:1402
msgid ""
"Source files that implement key types should include the following header "
"file::"
msgstr ""

#: ../../../security/keys/core.rst:1406
msgid "The structure has a number of fields, some of which are mandatory:"
msgstr ""

#: ../../../security/keys/core.rst:1408
msgid "``const char *name``"
msgstr ""

#: ../../../security/keys/core.rst:1410
msgid ""
"The name of the key type. This is used to translate a key type name supplied "
"by userspace into a pointer to the structure."
msgstr ""

#: ../../../security/keys/core.rst:1414
msgid "``size_t def_datalen``"
msgstr ""

#: ../../../security/keys/core.rst:1416
msgid ""
"This is optional - it supplies the default payload data length as "
"contributed to the quota. If the key type's payload is always or almost "
"always the same size, then this is a more efficient way to do things."
msgstr ""

#: ../../../security/keys/core.rst:1420
msgid ""
"The data length (and quota) on a particular key can always be changed during "
"instantiation or update by calling::"
msgstr ""

#: ../../../security/keys/core.rst:1425
msgid ""
"With the revised data length. Error EDQUOT will be returned if this is not "
"viable."
msgstr ""

#: ../../../security/keys/core.rst:1429
msgid "``int (*vet_description)(const char *description);``"
msgstr ""

#: ../../../security/keys/core.rst:1431
msgid ""
"This optional method is called to vet a key description.  If the key type "
"doesn't approve of the key description, it may return an error, otherwise it "
"should return 0."
msgstr ""

#: ../../../security/keys/core.rst:1436
msgid "``int (*preparse)(struct key_preparsed_payload *prep);``"
msgstr ""

#: ../../../security/keys/core.rst:1438
msgid ""
"This optional method permits the key type to attempt to parse payload before "
"a key is created (add key) or the key semaphore is taken (update or "
"instantiate key).  The structure pointed to by prep looks like::"
msgstr ""

#: ../../../security/keys/core.rst:1451
msgid ""
"Before calling the method, the caller will fill in data and datalen with the "
"payload blob parameters; quotalen will be filled in with the default quota "
"size from the key type; expiry will be set to TIME_T_MAX and the rest will "
"be cleared."
msgstr ""

#: ../../../security/keys/core.rst:1456
msgid ""
"If a description can be proposed from the payload contents, that should be "
"attached as a string to the description field.  This will be used for the "
"key description if the caller of add_key() passes NULL or \"\"."
msgstr ""

#: ../../../security/keys/core.rst:1460
msgid ""
"The method can attach anything it likes to payload.  This is merely passed "
"along to the instantiate() or update() operations.  If set, the expiry time "
"will be applied to the key if it is instantiated from this data."
msgstr ""

#: ../../../security/keys/core.rst:1464 ../../../security/keys/core.rst:1561
msgid ""
"The method should return 0 if successful or a negative error code otherwise."
msgstr ""

#: ../../../security/keys/core.rst:1468
msgid "``void (*free_preparse)(struct key_preparsed_payload *prep);``"
msgstr ""

#: ../../../security/keys/core.rst:1470
msgid ""
"This method is only required if the preparse() method is provided, otherwise "
"it is unused.  It cleans up anything attached to the description and payload "
"fields of the key_preparsed_payload struct as filled in by the preparse() "
"method.  It will always be called after preparse() returns successfully, "
"even if instantiate() or update() succeed."
msgstr ""

#: ../../../security/keys/core.rst:1477
msgid ""
"``int (*instantiate)(struct key *key, struct key_preparsed_payload *prep);``"
msgstr ""

#: ../../../security/keys/core.rst:1479
msgid ""
"This method is called to attach a payload to a key during construction. The "
"payload attached need not bear any relation to the data passed to this "
"function."
msgstr ""

#: ../../../security/keys/core.rst:1483 ../../../security/keys/core.rst:1506
msgid ""
"The prep->data and prep->datalen fields will define the original payload "
"blob.  If preparse() was supplied then other fields may be filled in also."
msgstr ""

#: ../../../security/keys/core.rst:1486
msgid ""
"If the amount of data attached to the key differs from the size in keytype-"
">def_datalen, then key_payload_reserve() should be called."
msgstr ""

#: ../../../security/keys/core.rst:1489
msgid ""
"This method does not have to lock the key in order to attach a payload. The "
"fact that KEY_FLAG_INSTANTIATED is not set in key->flags prevents anything "
"else from gaining access to the key."
msgstr ""

#: ../../../security/keys/core.rst:1493 ../../../security/keys/core.rst:1523
msgid "It is safe to sleep in this method."
msgstr ""

#: ../../../security/keys/core.rst:1495
msgid ""
"generic_key_instantiate() is provided to simply copy the data from prep-"
">payload.data[] to key->payload.data[], with RCU-safe assignment on the "
"first element.  It will then clear prep->payload.data[] so that the "
"free_preparse method doesn't release the data."
msgstr ""

#: ../../../security/keys/core.rst:1501
msgid "``int (*update)(struct key *key, const void *data, size_t datalen);``"
msgstr ""

#: ../../../security/keys/core.rst:1503
msgid ""
"If this type of key can be updated, then this method should be provided. It "
"is called to update a key's payload from the blob of data provided."
msgstr ""

#: ../../../security/keys/core.rst:1509
msgid ""
"key_payload_reserve() should be called if the data length might change "
"before any changes are actually made. Note that if this succeeds, the type "
"is committed to changing the key because it's already been altered, so all "
"memory allocation must be done first."
msgstr ""

#: ../../../security/keys/core.rst:1514
msgid ""
"The key will have its semaphore write-locked before this method is called, "
"but this only deters other writers; any changes to the key's payload must be "
"made under RCU conditions, and call_rcu() must be used to dispose of the old "
"payload."
msgstr ""

#: ../../../security/keys/core.rst:1519
msgid ""
"key_payload_reserve() should be called before the changes are made, but "
"after all allocations and other potentially failing function calls are made."
msgstr ""

#: ../../../security/keys/core.rst:1526
msgid "``int (*match_preparse)(struct key_match_data *match_data);``"
msgstr ""

#: ../../../security/keys/core.rst:1528
msgid ""
"This method is optional.  It is called when a key search is about to be "
"performed.  It is given the following structure::"
msgstr ""

#: ../../../security/keys/core.rst:1539
msgid ""
"On entry, raw_data will be pointing to the criteria to be used in matching a "
"key by the caller and should not be modified.  ``(*cmp)()`` will be pointing "
"to the default matcher function (which does an exact description match "
"against raw_data) and lookup_type will be set to indicate a direct lookup."
msgstr ""

#: ../../../security/keys/core.rst:1544
msgid "The following lookup_type values are available:"
msgstr ""

#: ../../../security/keys/core.rst:1546
msgid ""
"KEYRING_SEARCH_LOOKUP_DIRECT - A direct lookup hashes the type and "
"description to narrow down the search to a small number of keys."
msgstr ""

#: ../../../security/keys/core.rst:1549
msgid ""
"KEYRING_SEARCH_LOOKUP_ITERATE - An iterative lookup walks all the keys in "
"the keyring until one is matched.  This must be used for any search that's "
"not doing a simple direct match on the key description."
msgstr ""

#: ../../../security/keys/core.rst:1553
msgid ""
"The method may set cmp to point to a function of its choice that does some "
"other form of match, may set lookup_type to KEYRING_SEARCH_LOOKUP_ITERATE "
"and may attach something to the preparsed pointer for use by ``(*cmp)()``. "
"``(*cmp)()`` should return true if a key matches and false otherwise."
msgstr ""

#: ../../../security/keys/core.rst:1558
msgid ""
"If preparsed is set, it may be necessary to use the match_free() method to "
"clean it up."
msgstr ""

#: ../../../security/keys/core.rst:1564
msgid ""
"It is permitted to sleep in this method, but ``(*cmp)()`` may not sleep as "
"locks will be held over it."
msgstr ""

#: ../../../security/keys/core.rst:1567
msgid ""
"If match_preparse() is not provided, keys of this type will be matched "
"exactly by their description."
msgstr ""

#: ../../../security/keys/core.rst:1571
msgid "``void (*match_free)(struct key_match_data *match_data);``"
msgstr ""

#: ../../../security/keys/core.rst:1573
msgid ""
"This method is optional.  If given, it called to clean up match_data-"
">preparsed after a successful call to match_preparse()."
msgstr ""

#: ../../../security/keys/core.rst:1577
msgid "``void (*revoke)(struct key *key);``"
msgstr ""

#: ../../../security/keys/core.rst:1579
msgid ""
"This method is optional.  It is called to discard part of the payload data "
"upon a key being revoked.  The caller will have the key semaphore write-"
"locked."
msgstr ""

#: ../../../security/keys/core.rst:1583
msgid ""
"It is safe to sleep in this method, though care should be taken to avoid a "
"deadlock against the key semaphore."
msgstr ""

#: ../../../security/keys/core.rst:1587
msgid "``void (*destroy)(struct key *key);``"
msgstr ""

#: ../../../security/keys/core.rst:1589
msgid ""
"This method is optional. It is called to discard the payload data on a key "
"when it is being destroyed."
msgstr ""

#: ../../../security/keys/core.rst:1592
msgid ""
"This method does not need to lock the key to access the payload; it can "
"consider the key as being inaccessible at this time. Note that the key's "
"type may have been changed before this function is called."
msgstr ""

#: ../../../security/keys/core.rst:1596
msgid "It is not safe to sleep in this method; the caller may hold spinlocks."
msgstr ""

#: ../../../security/keys/core.rst:1599
msgid "``void (*describe)(const struct key *key, struct seq_file *p);``"
msgstr ""

#: ../../../security/keys/core.rst:1601
msgid ""
"This method is optional. It is called during /proc/keys reading to summarise "
"a key's description and payload in text form."
msgstr ""

#: ../../../security/keys/core.rst:1604
msgid ""
"This method will be called with the RCU read lock held. rcu_dereference() "
"should be used to read the payload pointer if the payload is to be accessed. "
"key->datalen cannot be trusted to stay consistent with the contents of the "
"payload."
msgstr ""

#: ../../../security/keys/core.rst:1609
msgid "The description will not change, though the key's state may."
msgstr ""

#: ../../../security/keys/core.rst:1611
msgid ""
"It is not safe to sleep in this method; the RCU read lock is held by the "
"caller."
msgstr ""

#: ../../../security/keys/core.rst:1615
msgid ""
"``long (*read)(const struct key *key, char __user *buffer, size_t buflen);``"
msgstr ""

#: ../../../security/keys/core.rst:1617
msgid ""
"This method is optional. It is called by KEYCTL_READ to translate the key's "
"payload into something a blob of data for userspace to deal with. Ideally, "
"the blob should be in the same format as that passed in to the instantiate "
"and update methods."
msgstr ""

#: ../../../security/keys/core.rst:1622
msgid ""
"If successful, the blob size that could be produced should be returned "
"rather than the size copied."
msgstr ""

#: ../../../security/keys/core.rst:1625
msgid ""
"This method will be called with the key's semaphore read-locked. This will "
"prevent the key's payload changing. It is not necessary to use RCU locking "
"when accessing the key's payload. It is safe to sleep in this method, such "
"as might happen when the userspace buffer is accessed."
msgstr ""

#: ../../../security/keys/core.rst:1631
msgid ""
"``int (*request_key)(struct key_construction *cons, const char *op, void "
"*aux);``"
msgstr ""

#: ../../../security/keys/core.rst:1633
msgid ""
"This method is optional.  If provided, request_key() and friends will invoke "
"this function rather than upcalling to /sbin/request-key to operate upon a "
"key of this type."
msgstr ""

#: ../../../security/keys/core.rst:1637
msgid ""
"The aux parameter is as passed to request_key_async_with_auxdata() and "
"similar or is NULL otherwise.  Also passed are the construction record for "
"the key to be operated upon and the operation type (currently only "
"\"create\")."
msgstr ""

#: ../../../security/keys/core.rst:1642
msgid ""
"This method is permitted to return before the upcall is complete, but the "
"following function must be called under all circumstances to complete the "
"instantiation process, whether or not it succeeds, whether or not there's an "
"error::"
msgstr ""

#: ../../../security/keys/core.rst:1649
msgid ""
"The error parameter should be 0 on success, -ve on error.  The construction "
"record is destroyed by this action and the authorisation key will be "
"revoked.  If an error is indicated, the key under construction will be "
"negatively instantiated if it wasn't already instantiated."
msgstr ""

#: ../../../security/keys/core.rst:1654
msgid ""
"If this method returns an error, that error will be returned to the caller "
"of request_key*().  complete_request_key() must be called prior to returning."
msgstr ""

#: ../../../security/keys/core.rst:1658
msgid ""
"The key under construction and the authorisation key can be found in the "
"key_construction struct pointed to by cons:"
msgstr ""

#: ../../../security/keys/core.rst:1661
msgid "``struct key *key;``"
msgstr ""

#: ../../../security/keys/core.rst:1663
msgid "The key under construction."
msgstr ""

#: ../../../security/keys/core.rst:1665
msgid "``struct key *authkey;``"
msgstr ""

#: ../../../security/keys/core.rst:1667
msgid "The authorisation key."
msgstr ""

#: ../../../security/keys/core.rst:1670
msgid "``struct key_restriction *(*lookup_restriction)(const char *params);``"
msgstr ""

#: ../../../security/keys/core.rst:1672
msgid ""
"This optional method is used to enable userspace configuration of keyring "
"restrictions. The restriction parameter string (not including the key type "
"name) is passed in, and this method returns a pointer to a key_restriction "
"structure containing the relevant functions and data to evaluate each "
"attempted key link operation. If there is no match, -EINVAL is returned."
msgstr ""

#: ../../../security/keys/core.rst:1679
msgid "``asym_eds_op`` and ``asym_verify_signature``::"
msgstr ""

#: ../../../security/keys/core.rst:1686
msgid ""
"These methods are optional.  If provided the first allows a key to be used "
"to encrypt, decrypt or sign a blob of data, and the second allows a key to "
"verify a signature."
msgstr ""

#: ../../../security/keys/core.rst:1690
msgid ""
"In all cases, the following information is provided in the params block::"
msgstr ""

#: ../../../security/keys/core.rst:1705
msgid ""
"This includes the key to be used; a string indicating the encoding to use "
"(for instance, \"pkcs1\" may be used with an RSA key to indicate RSASSA-"
"PKCS1-v1.5 or RSAES-PKCS1-v1.5 encoding or \"raw\" if no encoding); the name "
"of the hash algorithm used to generate the data for a signature (if "
"appropriate); the sizes of the input and output (or second input) buffers; "
"and the ID of the operation to be performed."
msgstr ""

#: ../../../security/keys/core.rst:1712
msgid ""
"For a given operation ID, the input and output buffers are used as follows::"
msgstr ""

#: ../../../security/keys/core.rst:1722
msgid ""
"asym_eds_op() deals with encryption, decryption and signature creation as "
"specified by params->op.  Note that params->op is also set for "
"asym_verify_signature()."
msgstr ""

#: ../../../security/keys/core.rst:1726
msgid ""
"Encrypting and signature creation both take raw data in the input buffer and "
"return the encrypted result in the output buffer.  Padding may have been "
"added if an encoding was set.  In the case of signature creation, depending "
"on the encoding, the padding created may need to indicate the digest "
"algorithm - the name of which should be supplied in hash_algo."
msgstr ""

#: ../../../security/keys/core.rst:1732
msgid ""
"Decryption takes encrypted data in the input buffer and returns the raw data "
"in the output buffer.  Padding will get checked and stripped off if an "
"encoding was set."
msgstr ""

#: ../../../security/keys/core.rst:1736
msgid ""
"Verification takes raw data in the input buffer and the signature in the "
"second input buffer and checks that the one matches the other.  Padding will "
"be validated.  Depending on the encoding, the digest algorithm used to "
"generate the raw data may need to be indicated in hash_algo."
msgstr ""

#: ../../../security/keys/core.rst:1741
msgid ""
"If successful, asym_eds_op() should return the number of bytes written into "
"the output buffer.  asym_verify_signature() should return 0."
msgstr ""

#: ../../../security/keys/core.rst:1744
msgid ""
"A variety of errors may be returned, including EOPNOTSUPP if the operation "
"is not supported; EKEYREJECTED if verification fails; ENOPKG if the required "
"crypto isn't available."
msgstr ""

#: ../../../security/keys/core.rst:1749
msgid "``asym_query``::"
msgstr ""

#: ../../../security/keys/core.rst:1754
msgid ""
"This method is optional.  If provided it allows information about the public "
"or asymmetric key held in the key to be determined."
msgstr ""

#: ../../../security/keys/core.rst:1757
msgid ""
"The parameter block is as for asym_eds_op() and co. but in_len and out_len "
"are unused.  The encoding and hash_algo fields should be used to reduce the "
"returned buffer/data sizes as appropriate."
msgstr ""

#: ../../../security/keys/core.rst:1761
msgid "If successful, the following information is filled in::"
msgstr ""

#: ../../../security/keys/core.rst:1772
msgid ""
"The supported_ops field will contain a bitmask indicating what operations "
"are supported by the key, including encryption of a blob, decryption of a "
"blob, signing a blob and verifying the signature on a blob.  The following "
"constants are defined for this::"
msgstr ""

#: ../../../security/keys/core.rst:1779
msgid ""
"The key_size field is the size of the key in bits.  max_data_size and "
"max_sig_size are the maximum raw data and signature sizes for creation and "
"verification of a signature; max_enc_size and max_dec_size are the maximum "
"raw data and signature sizes for encryption and decryption.  The max_*_size "
"fields are measured in bytes."
msgstr ""

#: ../../../security/keys/core.rst:1785
msgid ""
"If successful, 0 will be returned.  If the key doesn't support this, "
"EOPNOTSUPP will be returned."
msgstr ""

#: ../../../security/keys/core.rst:1790
msgid "Request-Key Callback Service"
msgstr ""

#: ../../../security/keys/core.rst:1792
msgid ""
"To create a new key, the kernel will attempt to execute the following "
"command line::"
msgstr ""

#: ../../../security/keys/core.rst:1798
msgid ""
"<key> is the key being constructed, and the three keyrings are the process "
"keyrings from the process that caused the search to be issued. These are "
"included for two reasons:"
msgstr ""

#: ../../../security/keys/core.rst:1802
msgid "1  There may be an authentication token in one of the keyrings that is"
msgstr ""

#: ../../../security/keys/core.rst:1803
msgid "required to obtain the key, eg: a Kerberos Ticket-Granting Ticket."
msgstr ""

#: ../../../security/keys/core.rst:1805
msgid "2  The new key should probably be cached in one of these rings."
msgstr ""

#: ../../../security/keys/core.rst:1807
msgid ""
"This program should set it UID and GID to those specified before attempting "
"to access any more keys. It may then look around for a user specific process "
"to hand the request off to (perhaps a path held in placed in another key by, "
"for example, the KDE desktop manager)."
msgstr ""

#: ../../../security/keys/core.rst:1812
msgid ""
"The program (or whatever it calls) should finish construction of the key by "
"calling KEYCTL_INSTANTIATE or KEYCTL_INSTANTIATE_IOV, which also permits it "
"to cache the key in one of the keyrings (probably the session ring) before "
"returning.  Alternatively, the key can be marked as negative with "
"KEYCTL_NEGATE or KEYCTL_REJECT; this also permits the key to be cached in "
"one of the keyrings."
msgstr ""

#: ../../../security/keys/core.rst:1819
msgid ""
"If it returns with the key remaining in the unconstructed state, the key "
"will be marked as being negative, it will be added to the session keyring, "
"and an error will be returned to the key requestor."
msgstr ""

#: ../../../security/keys/core.rst:1823
msgid ""
"Supplementary information may be provided from whoever or whatever invoked "
"this service. This will be passed as the <callout_info> parameter. If no "
"such information was made available, then \"-\" will be passed as this "
"parameter instead."
msgstr ""

#: ../../../security/keys/core.rst:1829
msgid ""
"Similarly, the kernel may attempt to update an expired or a soon to expire "
"key by executing::"
msgstr ""

#: ../../../security/keys/core.rst:1835
msgid ""
"In this case, the program isn't required to actually attach the key to a "
"ring; the rings are provided for reference."
msgstr ""

#: ../../../security/keys/core.rst:1840
msgid "Garbage Collection"
msgstr ""

#: ../../../security/keys/core.rst:1842
msgid ""
"Dead keys (for which the type has been removed) will be automatically "
"unlinked from those keyrings that point to them and deleted as soon as "
"possible by a background garbage collector."
msgstr ""

#: ../../../security/keys/core.rst:1846
msgid ""
"Similarly, revoked and expired keys will be garbage collected, but only "
"after a certain amount of time has passed.  This time is set as a number of "
"seconds in::"
msgstr ""
