# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/ftrace-uses.rst:3
msgid "Using ftrace to hook to functions"
msgstr ""

#: ../../../trace/ftrace-uses.rst:10
msgid "Written for: 4.14"
msgstr ""

#: ../../../trace/ftrace-uses.rst:13
msgid "Introduction"
msgstr ""

#: ../../../trace/ftrace-uses.rst:15
msgid ""
"The ftrace infrastructure was originally created to attach callbacks to the "
"beginning of functions in order to record and trace the flow of the kernel. "
"But callbacks to the start of a function can have other use cases. Either "
"for live kernel patching, or for security monitoring. This document "
"describes how to use ftrace to implement your own function callbacks."
msgstr ""

#: ../../../trace/ftrace-uses.rst:23
msgid "The ftrace context"
msgstr ""

#: ../../../trace/ftrace-uses.rst:26
msgid ""
"The ability to add a callback to almost any function within the kernel comes "
"with risks. A callback can be called from any context (normal, softirq, irq, "
"and NMI). Callbacks can also be called just before going to idle, during CPU "
"bring up and takedown, or going to user space. This requires extra care to "
"what can be done inside a callback. A callback can be called outside the "
"protective scope of RCU."
msgstr ""

#: ../../../trace/ftrace-uses.rst:33
msgid ""
"There are helper functions to help against recursion, and making sure RCU is "
"watching. These are explained below."
msgstr ""

#: ../../../trace/ftrace-uses.rst:38
msgid "The ftrace_ops structure"
msgstr ""

#: ../../../trace/ftrace-uses.rst:40
msgid ""
"To register a function callback, a ftrace_ops is required. This structure is "
"used to tell ftrace what function should be called as the callback as well "
"as what protections the callback will perform and not require ftrace to "
"handle."
msgstr ""

#: ../../../trace/ftrace-uses.rst:45
msgid ""
"There is only one field that is needed to be set when registering an "
"ftrace_ops with ftrace:"
msgstr ""

#: ../../../trace/ftrace-uses.rst:56
msgid "Both .flags and .private are optional. Only .func is required."
msgstr ""

#: ../../../trace/ftrace-uses.rst:58
msgid "To enable tracing call::"
msgstr ""

#: ../../../trace/ftrace-uses.rst:62
msgid "To disable tracing call::"
msgstr ""

#: ../../../trace/ftrace-uses.rst:66
msgid "The above is defined by including the header::"
msgstr ""

#: ../../../trace/ftrace-uses.rst:70
msgid ""
"The registered callback will start being called some time after the "
"register_ftrace_function() is called and before it returns. The exact time "
"that callbacks start being called is dependent upon architecture and "
"scheduling of services. The callback itself will have to handle any "
"synchronization if it must begin at an exact moment."
msgstr ""

#: ../../../trace/ftrace-uses.rst:76
msgid ""
"The unregister_ftrace_function() will guarantee that the callback is no "
"longer being called by functions after the unregister_ftrace_function() "
"returns. Note that to perform this guarantee, the "
"unregister_ftrace_function() may take some time to finish."
msgstr ""

#: ../../../trace/ftrace-uses.rst:83
msgid "The callback function"
msgstr ""

#: ../../../trace/ftrace-uses.rst:85
msgid "The prototype of the callback function is as follows (as of v4.14):"
msgstr ""

#: ../../../trace/ftrace-uses.rst:92
msgid "@ip"
msgstr ""

#: ../../../trace/ftrace-uses.rst:93
msgid ""
"This is the instruction pointer of the function that is being traced. (where "
"the fentry or mcount is within the function)"
msgstr ""

#: ../../../trace/ftrace-uses.rst:96
msgid "@parent_ip"
msgstr ""

#: ../../../trace/ftrace-uses.rst:97
msgid ""
"This is the instruction pointer of the function that called the the function "
"being traced (where the call of the function occurred)."
msgstr ""

#: ../../../trace/ftrace-uses.rst:100
msgid "@op"
msgstr ""

#: ../../../trace/ftrace-uses.rst:101
msgid ""
"This is a pointer to ftrace_ops that was used to register the callback. This "
"can be used to pass data to the callback via the private pointer."
msgstr ""

#: ../../../trace/ftrace-uses.rst:104
msgid "@regs"
msgstr ""

#: ../../../trace/ftrace-uses.rst:105
msgid ""
"If the FTRACE_OPS_FL_SAVE_REGS or FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED flags "
"are set in the ftrace_ops structure, then this will be pointing to the "
"pt_regs structure like it would be if an breakpoint was placed at the start "
"of the function where ftrace was tracing. Otherwise it either contains "
"garbage, or NULL."
msgstr ""

#: ../../../trace/ftrace-uses.rst:112
msgid "Protect your callback"
msgstr ""

#: ../../../trace/ftrace-uses.rst:114
msgid ""
"As functions can be called from anywhere, and it is possible that a function "
"called by a callback may also be traced, and call that same callback, "
"recursion protection must be used. There are two helper functions that can "
"help in this regard. If you start your code with:"
msgstr ""

#: ../../../trace/ftrace-uses.rst:127
msgid "and end it with:"
msgstr ""

#: ../../../trace/ftrace-uses.rst:133
msgid ""
"The code in between will be safe to use, even if it ends up calling a "
"function that the callback is tracing. Note, on success, "
"ftrace_test_recursion_trylock() will disable preemption, and the "
"ftrace_test_recursion_unlock() will enable it again (if it was previously "
"enabled). The instruction pointer (ip) and its parent (parent_ip) is passed "
"to ftrace_test_recursion_trylock() to record where the recursion happened "
"(if CONFIG_FTRACE_RECORD_RECURSION is set)."
msgstr ""

#: ../../../trace/ftrace-uses.rst:141
msgid ""
"Alternatively, if the FTRACE_OPS_FL_RECURSION flag is set on the ftrace_ops "
"(as explained below), then a helper trampoline will be used to test for "
"recursion for the callback and no recursion test needs to be done. But this "
"is at the expense of a slightly more overhead from an extra function call."
msgstr ""

#: ../../../trace/ftrace-uses.rst:147
msgid ""
"If your callback accesses any data or critical section that requires RCU "
"protection, it is best to make sure that RCU is \"watching\", otherwise that "
"data or critical section will not be protected as expected. In this case add:"
msgstr ""

#: ../../../trace/ftrace-uses.rst:157
msgid ""
"Alternatively, if the FTRACE_OPS_FL_RCU flag is set on the ftrace_ops (as "
"explained below), then a helper trampoline will be used to test for "
"rcu_is_watching for the callback and no other test needs to be done. But "
"this is at the expense of a slightly more overhead from an extra function "
"call."
msgstr ""

#: ../../../trace/ftrace-uses.rst:165
msgid "The ftrace FLAGS"
msgstr ""

#: ../../../trace/ftrace-uses.rst:167
msgid ""
"The ftrace_ops flags are all defined and documented in include/linux/ftrace."
"h. Some of the flags are used for internal infrastructure of ftrace, but the "
"ones that users should be aware of are the following:"
msgstr ""

#: ../../../trace/ftrace-uses.rst:171
msgid "FTRACE_OPS_FL_SAVE_REGS"
msgstr ""

#: ../../../trace/ftrace-uses.rst:172
msgid ""
"If the callback requires reading or modifying the pt_regs passed to the "
"callback, then it must set this flag. Registering a ftrace_ops with this "
"flag set on an architecture that does not support passing of pt_regs to the "
"callback will fail."
msgstr ""

#: ../../../trace/ftrace-uses.rst:177
msgid "FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED"
msgstr ""

#: ../../../trace/ftrace-uses.rst:178
msgid ""
"Similar to SAVE_REGS but the registering of a ftrace_ops on an architecture "
"that does not support passing of regs will not fail with this flag set. But "
"the callback must check if regs is NULL or not to determine if the "
"architecture supports it."
msgstr ""

#: ../../../trace/ftrace-uses.rst:183
msgid "FTRACE_OPS_FL_RECURSION"
msgstr ""

#: ../../../trace/ftrace-uses.rst:184
msgid ""
"By default, it is expected that the callback can handle recursion. But if "
"the callback is not that worried about overhead, then setting this bit will "
"add the recursion protection around the callback by calling a helper "
"function that will do the recursion protection and only call the callback if "
"it did not recurse."
msgstr ""

#: ../../../trace/ftrace-uses.rst:190
msgid ""
"Note, if this flag is not set, and recursion does occur, it could cause the "
"system to crash, and possibly reboot via a triple fault."
msgstr ""

#: ../../../trace/ftrace-uses.rst:193
msgid ""
"Note, if this flag is set, then the callback will always be called with "
"preemption disabled. If it is not set, then it is possible (but not "
"guaranteed) that the callback will be called in preemptible context."
msgstr ""

#: ../../../trace/ftrace-uses.rst:198
msgid "FTRACE_OPS_FL_IPMODIFY"
msgstr ""

#: ../../../trace/ftrace-uses.rst:199
msgid ""
"Requires FTRACE_OPS_FL_SAVE_REGS set. If the callback is to \"hijack\" the "
"traced function (have another function called instead of the traced "
"function), it requires setting this flag. This is what live kernel patches "
"uses. Without this flag the pt_regs->ip can not be modified."
msgstr ""

#: ../../../trace/ftrace-uses.rst:205
msgid ""
"Note, only one ftrace_ops with FTRACE_OPS_FL_IPMODIFY set may be registered "
"to any given function at a time."
msgstr ""

#: ../../../trace/ftrace-uses.rst:208
msgid "FTRACE_OPS_FL_RCU"
msgstr ""

#: ../../../trace/ftrace-uses.rst:209
msgid ""
"If this is set, then the callback will only be called by functions where RCU "
"is \"watching\". This is required if the callback function performs any "
"rcu_read_lock() operation."
msgstr ""

#: ../../../trace/ftrace-uses.rst:213
msgid ""
"RCU stops watching when the system goes idle, the time when a CPU is taken "
"down and comes back online, and when entering from kernel to user space and "
"back to kernel space. During these transitions, a callback may be executed "
"and RCU synchronization will not protect it."
msgstr ""

#: ../../../trace/ftrace-uses.rst:219
msgid "FTRACE_OPS_FL_PERMANENT"
msgstr ""

#: ../../../trace/ftrace-uses.rst:220
msgid ""
"If this is set on any ftrace ops, then the tracing cannot disabled by "
"writing 0 to the proc sysctl ftrace_enabled. Equally, a callback with the "
"flag set cannot be registered if ftrace_enabled is 0."
msgstr ""

#: ../../../trace/ftrace-uses.rst:224
msgid ""
"Livepatch uses it not to lose the function redirection, so the system stays "
"protected."
msgstr ""

#: ../../../trace/ftrace-uses.rst:229
msgid "Filtering which functions to trace"
msgstr ""

#: ../../../trace/ftrace-uses.rst:231
msgid ""
"If a callback is only to be called from specific functions, a filter must be "
"set up. The filters are added by name, or ip if it is known."
msgstr ""

#: ../../../trace/ftrace-uses.rst:239
msgid "@ops"
msgstr ""

#: ../../../trace/ftrace-uses.rst:240
msgid "The ops to set the filter with"
msgstr ""

#: ../../../trace/ftrace-uses.rst:242
msgid "@buf"
msgstr ""

#: ../../../trace/ftrace-uses.rst:243
msgid "The string that holds the function filter text."
msgstr ""

#: ../../../trace/ftrace-uses.rst:244
msgid "@len"
msgstr ""

#: ../../../trace/ftrace-uses.rst:245
msgid "The length of the string."
msgstr ""

#: ../../../trace/ftrace-uses.rst:247
msgid "@reset"
msgstr ""

#: ../../../trace/ftrace-uses.rst:248
msgid "Non-zero to reset all filters before applying this filter."
msgstr ""

#: ../../../trace/ftrace-uses.rst:250
msgid ""
"Filters denote which functions should be enabled when tracing is enabled. If "
"@buf is NULL and reset is set, all functions will be enabled for tracing."
msgstr ""

#: ../../../trace/ftrace-uses.rst:253
msgid ""
"The @buf can also be a glob expression to enable all functions that match a "
"specific pattern."
msgstr ""

#: ../../../trace/ftrace-uses.rst:256
msgid "See Filter Commands in :file:`Documentation/trace/ftrace.rst`."
msgstr ""

#: ../../../trace/ftrace-uses.rst:258
msgid "To just trace the schedule function:"
msgstr ""

#: ../../../trace/ftrace-uses.rst:264
msgid ""
"To add more functions, call the ftrace_set_filter() more than once with the "
"@reset parameter set to zero. To remove the current filter set and replace "
"it with new functions defined by @buf, have @reset be non-zero."
msgstr ""

#: ../../../trace/ftrace-uses.rst:268
msgid "To remove all the filtered functions and trace all functions:"
msgstr ""

#: ../../../trace/ftrace-uses.rst:275
msgid ""
"Sometimes more than one function has the same name. To trace just a specific "
"function in this case, ftrace_set_filter_ip() can be used."
msgstr ""

#: ../../../trace/ftrace-uses.rst:282
msgid ""
"Although the ip must be the address where the call to fentry or mcount is "
"located in the function. This function is used by perf and kprobes that gets "
"the ip address from the user (usually using debug info from the kernel)."
msgstr ""

#: ../../../trace/ftrace-uses.rst:286
msgid ""
"If a glob is used to set the filter, functions can be added to a \"notrace\" "
"list that will prevent those functions from calling the callback. The "
"\"notrace\" list takes precedence over the \"filter\" list. If the two lists "
"are non-empty and contain the same functions, the callback will not be "
"called by any function."
msgstr ""

#: ../../../trace/ftrace-uses.rst:292
msgid ""
"An empty \"notrace\" list means to allow all functions defined by the filter "
"to be traced."
msgstr ""

#: ../../../trace/ftrace-uses.rst:300
msgid ""
"This takes the same parameters as ftrace_set_filter() but will add the "
"functions it finds to not be traced. This is a separate list from the filter "
"list, and this function does not modify the filter list."
msgstr ""

#: ../../../trace/ftrace-uses.rst:304
msgid ""
"A non-zero @reset will clear the \"notrace\" list before adding functions "
"that match @buf to it."
msgstr ""

#: ../../../trace/ftrace-uses.rst:307
msgid "Clearing the \"notrace\" list is the same as clearing the filter list"
msgstr ""

#: ../../../trace/ftrace-uses.rst:313
msgid ""
"The filter and notrace lists may be changed at any time. If only a set of "
"functions should call the callback, it is best to set the filters before "
"registering the callback. But the changes may also happen after the callback "
"has been registered."
msgstr ""

#: ../../../trace/ftrace-uses.rst:318
msgid ""
"If a filter is in place, and the @reset is non-zero, and @buf contains a "
"matching glob to functions, the switch will happen during the time of the "
"ftrace_set_filter() call. At no time will all functions call the callback."
msgstr ""

#: ../../../trace/ftrace-uses.rst:332
msgid "is not the same as:"
msgstr ""

#: ../../../trace/ftrace-uses.rst:346
msgid ""
"As the latter will have a short time where all functions will call the "
"callback, between the time of the reset, and the time of the new setting of "
"the filter."
msgstr ""
