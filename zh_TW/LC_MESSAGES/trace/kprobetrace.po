# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/kprobetrace.rst:3
msgid "Kprobe-based Event Tracing"
msgstr ""

#: ../../../trace/kprobetrace.rst:0
msgid "Author"
msgstr "作者"

#: ../../../trace/kprobetrace.rst:5
msgid "Masami Hiramatsu"
msgstr ""

#: ../../../trace/kprobetrace.rst:8
msgid "Overview"
msgstr "概覽"

#: ../../../trace/kprobetrace.rst:9
msgid ""
"These events are similar to tracepoint-based events. Instead of tracepoints, "
"this is based on kprobes (kprobe and kretprobe). So it can probe wherever "
"kprobes can probe (this means, all functions except those with __kprobes/"
"nokprobe_inline annotation and those marked NOKPROBE_SYMBOL). Unlike the "
"tracepoint-based event, this can be added and removed dynamically, on the "
"fly."
msgstr ""

#: ../../../trace/kprobetrace.rst:16
msgid "To enable this feature, build your kernel with CONFIG_KPROBE_EVENTS=y."
msgstr ""

#: ../../../trace/kprobetrace.rst:18
msgid ""
"Similar to the event tracer, this doesn't need to be activated via "
"current_tracer. Instead of that, add probe points via /sys/kernel/tracing/"
"kprobe_events, and enable it via /sys/kernel/tracing/events/kprobes/<EVENT>/"
"enable."
msgstr ""

#: ../../../trace/kprobetrace.rst:23
msgid ""
"You can also use /sys/kernel/tracing/dynamic_events instead of "
"kprobe_events. That interface will provide unified access to other dynamic "
"events too."
msgstr ""

#: ../../../trace/kprobetrace.rst:28
msgid "Synopsis of kprobe_events"
msgstr ""

#: ../../../trace/kprobetrace.rst:75
msgid "Function arguments at kretprobe"
msgstr ""

#: ../../../trace/kprobetrace.rst:76
msgid ""
"Function arguments can be accessed at kretprobe using $arg<N> fetcharg. This "
"is useful to record the function parameter and return value at once, and "
"trace the difference of structure fields (for debugging a function whether "
"it correctly updates the given data structure or not). See the :ref:"
"`sample<fprobetrace_exit_args_sample>` in fprobe event for how it works."
msgstr ""

#: ../../../trace/kprobetrace.rst:86
msgid "Types"
msgstr ""

#: ../../../trace/kprobetrace.rst:87
msgid ""
"Several types are supported for fetchargs. Kprobe tracer will access memory "
"by given type. Prefix 's' and 'u' means those types are signed and unsigned "
"respectively. 'x' prefix implies it is unsigned. Traced arguments are shown "
"in decimal ('s' and 'u') or hexadecimal ('x'). Without type casting, 'x32' "
"or 'x64' is used depends on the architecture (e.g. x86-32 uses x32, and "
"x86-64 uses x64)."
msgstr ""

#: ../../../trace/kprobetrace.rst:94
msgid ""
"These value types can be an array. To record array data, you can add "
"'[N]' (where N is a fixed number, less than 64) to the base type. E.g. "
"'x16[4]' means an array of x16 (2-byte hex) with 4 elements. Note that the "
"array can be applied to memory type fetchargs, you can not apply it to "
"registers/stack-entries etc. (for example, '$stack1:x8[8]' is wrong, but "
"'+8($stack):x8[8]' is OK.)"
msgstr ""

#: ../../../trace/kprobetrace.rst:101
msgid "Char type can be used to show the character value of traced arguments."
msgstr ""

#: ../../../trace/kprobetrace.rst:103
msgid ""
"String type is a special type, which fetches a \"null-terminated\" string "
"from kernel space. This means it will fail and store NULL if the string "
"container has been paged out. \"ustring\" type is an alternative of string "
"for user-space. See :ref:`user_mem_access` for more info."
msgstr ""

#: ../../../trace/kprobetrace.rst:108
msgid ""
"The string array type is a bit different from other types. For other base "
"types, <base-type>[1] is equal to <base-type> (e.g. +0(%di):x32[1] is same "
"as +0(%di):x32.) But string[1] is not equal to string. The string type "
"itself represents \"char array\", but string array type represents \"char * "
"array\". So, for example, +0(%di):string[1] is equal to +0(+0(%di)):string. "
"Bitfield is another special type, which takes 3 parameters, bit-width, bit- "
"offset, and container-size (usually 32). The syntax is::"
msgstr ""

#: ../../../trace/kprobetrace.rst:118
msgid ""
"Symbol type('symbol') is an alias of u32 or u64 type (depends on "
"BITS_PER_LONG) which shows given pointer in \"symbol+offset\" style. On the "
"other hand, symbol-string type ('symstr') converts the given address to "
"\"symbol+offset/symbolsize\" style and stores it as a null-terminated "
"string. With 'symstr' type, you can filter the event with wildcard pattern "
"of the symbols, and you don't need to solve symbol name by yourself. For "
"$comm, the default type is \"string\"; any other type is invalid."
msgstr ""

#: ../../../trace/kprobetrace.rst:126
msgid ""
"VFS layer common type(%pd/%pD) is a special type, which fetches dentry's or "
"file's name from struct dentry's address or struct file's address."
msgstr ""

#: ../../../trace/kprobetrace.rst:132
msgid "User Memory Access"
msgstr ""

#: ../../../trace/kprobetrace.rst:133
msgid ""
"Kprobe events supports user-space memory access. For that purpose, you can "
"use either user-space dereference syntax or 'ustring' type."
msgstr ""

#: ../../../trace/kprobetrace.rst:136
msgid ""
"The user-space dereference syntax allows you to access a field of a data "
"structure in user-space. This is done by adding the \"u\" prefix to the "
"dereference syntax. For example, +u4(%si) means it will read memory from the "
"address in the register %si offset by 4, and the memory is expected to be in "
"user-space. You can use this for strings too, e.g. +u0(%si):string will read "
"a string from the address in the register %si that is expected to be in "
"user- space. 'ustring' is a shortcut way of performing the same task. That "
"is, +0(%si):ustring is equivalent to +u0(%si):string."
msgstr ""

#: ../../../trace/kprobetrace.rst:145
msgid ""
"Note that kprobe-event provides the user-memory access syntax but it doesn't "
"use it transparently. This means if you use normal dereference or string "
"type for user memory, it might fail, and may always fail on some "
"architectures. The user has to carefully check if the target data is in "
"kernel or user space."
msgstr ""

#: ../../../trace/kprobetrace.rst:151
msgid "Per-Probe Event Filtering"
msgstr ""

#: ../../../trace/kprobetrace.rst:152
msgid ""
"Per-probe event filtering feature allows you to set different filter on each "
"probe and gives you what arguments will be shown in trace buffer. If an "
"event name is specified right after 'p:' or 'r:' in kprobe_events, it adds "
"an event under tracing/events/kprobes/<EVENT>, at the directory you can see "
"'id', 'enable', 'format', 'filter' and 'trigger'."
msgstr ""

#: ../../../trace/kprobetrace.rst:158
msgid "enable:"
msgstr ""

#: ../../../trace/kprobetrace.rst:159
msgid "You can enable/disable the probe by writing 1 or 0 on it."
msgstr ""

#: ../../../trace/kprobetrace.rst:161
msgid "format:"
msgstr ""

#: ../../../trace/kprobetrace.rst:162
msgid "This shows the format of this probe event."
msgstr ""

#: ../../../trace/kprobetrace.rst:164
msgid "filter:"
msgstr ""

#: ../../../trace/kprobetrace.rst:165
msgid "You can write filtering rules of this event."
msgstr ""

#: ../../../trace/kprobetrace.rst:167
msgid "id:"
msgstr ""

#: ../../../trace/kprobetrace.rst:168
msgid "This shows the id of this probe event."
msgstr ""

#: ../../../trace/kprobetrace.rst:170
msgid "trigger:"
msgstr ""

#: ../../../trace/kprobetrace.rst:171
msgid ""
"This allows to install trigger commands which are executed when the event is "
"hit (for details, see Documentation/trace/events.rst, section 6)."
msgstr ""

#: ../../../trace/kprobetrace.rst:175
msgid "Event Profiling"
msgstr ""

#: ../../../trace/kprobetrace.rst:176
msgid ""
"You can check the total number of probe hits and probe miss-hits via /sys/"
"kernel/tracing/kprobe_profile. The first column is event name, the second is "
"the number of probe hits, the third is the number of probe miss-hits."
msgstr ""

#: ../../../trace/kprobetrace.rst:182
msgid "Kernel Boot Parameter"
msgstr ""

#: ../../../trace/kprobetrace.rst:183
msgid ""
"You can add and enable new kprobe events when booting up the kernel by "
"\"kprobe_event=\" parameter. The parameter accepts a semicolon-delimited "
"kprobe events, which format is similar to the kprobe_events. The difference "
"is that the probe definition parameters are comma-delimited instead of "
"space. For example, adding myprobe event on do_sys_open like below::"
msgstr ""

#: ../../../trace/kprobetrace.rst:191
msgid ""
"should be below for kernel boot parameter (just replace spaces with comma)::"
msgstr ""

#: ../../../trace/kprobetrace.rst:197
msgid "Usage examples"
msgstr ""

#: ../../../trace/kprobetrace.rst:198
msgid ""
"To add a probe as a new event, write a new definition to kprobe_events as "
"below::"
msgstr ""

#: ../../../trace/kprobetrace.rst:203
msgid ""
"This sets a kprobe on the top of do_sys_open() function with recording 1st "
"to 4th arguments as \"myprobe\" event. Note, which register/stack entry is "
"assigned to each function argument depends on arch-specific ABI. If you "
"unsure the ABI, please try to use probe subcommand of perf-tools (you can "
"find it under tools/perf/). As this example shows, users can choose more "
"familiar names for each arguments. ::"
msgstr ""

#: ../../../trace/kprobetrace.rst:213
msgid ""
"This sets a kretprobe on the return point of do_sys_open() function with "
"recording return value as \"myretprobe\" event. You can see the format of "
"these events via /sys/kernel/tracing/events/kprobes/<EVENT>/format. ::"
msgstr ""

#: ../../../trace/kprobetrace.rst:239
msgid ""
"You can see that the event has 4 arguments as in the expressions you "
"specified. ::"
msgstr ""

#: ../../../trace/kprobetrace.rst:244
msgid "This clears all probe points."
msgstr ""

#: ../../../trace/kprobetrace.rst:246
msgid "Or, ::"
msgstr ""

#: ../../../trace/kprobetrace.rst:251
msgid "This clears probe points selectively."
msgstr ""

#: ../../../trace/kprobetrace.rst:253
msgid ""
"Right after definition, each event is disabled by default. For tracing these "
"events, you need to enable it. ::"
msgstr ""

#: ../../../trace/kprobetrace.rst:260
msgid "Use the following command to start tracing in an interval. ::"
msgstr ""

#: ../../../trace/kprobetrace.rst:267
msgid ""
"And you can see the traced information via /sys/kernel/tracing/trace. ::"
msgstr ""

#: ../../../trace/kprobetrace.rst:283
msgid ""
"Each line shows when the kernel hits an event, and <- SYMBOL means kernel "
"returns from SYMBOL(e.g. \"sys_open+0x1b/0x1d <- do_sys_open\" means kernel "
"returns from do_sys_open to sys_open+0x1b)."
msgstr ""
