# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/packet_mmap.rst:5
msgid "Packet MMAP"
msgstr ""

#: ../../../networking/packet_mmap.rst:8
msgid "Abstract"
msgstr ""

#: ../../../networking/packet_mmap.rst:10
msgid ""
"This file documents the mmap() facility available with the PACKET socket "
"interface. This type of sockets is used for"
msgstr ""

#: ../../../networking/packet_mmap.rst:13
msgid "capture network traffic with utilities like tcpdump,"
msgstr ""

#: ../../../networking/packet_mmap.rst:14
msgid ""
"transmit network traffic, or any other that needs raw access to network "
"interface."
msgstr ""

#: ../../../networking/packet_mmap.rst:17
msgid "Howto can be found at:"
msgstr ""

#: ../../../networking/packet_mmap.rst:19
msgid ""
"https://web.archive.org/web/20220404160947/https://sites.google.com/site/"
"packetmmap/"
msgstr ""

#: ../../../networking/packet_mmap.rst:21
msgid "Please send your comments to"
msgstr ""

#: ../../../networking/packet_mmap.rst:22
msgid "Ulisses Alonso Camar√≥ <uaca@i.hate.spam.alumni.uv.es>"
msgstr ""

#: ../../../networking/packet_mmap.rst:23
msgid "Johann Baudy"
msgstr ""

#: ../../../networking/packet_mmap.rst:26
msgid "Why use PACKET_MMAP"
msgstr ""

#: ../../../networking/packet_mmap.rst:28
msgid ""
"Non PACKET_MMAP capture process (plain AF_PACKET) is very inefficient. It "
"uses very limited buffers and requires one system call to capture each "
"packet, it requires two if you want to get packet's timestamp (like libpcap "
"always does)."
msgstr ""

#: ../../../networking/packet_mmap.rst:33
msgid ""
"On the other hand PACKET_MMAP is very efficient. PACKET_MMAP provides a size "
"configurable circular buffer mapped in user space that can be used to either "
"send or receive packets. This way reading packets just needs to wait for "
"them, most of the time there is no need to issue a single system call. "
"Concerning transmission, multiple packets can be sent through one system "
"call to get the highest bandwidth. By using a shared buffer between the "
"kernel and the user also has the benefit of minimizing packet copies."
msgstr ""

#: ../../../networking/packet_mmap.rst:41
msgid ""
"It's fine to use PACKET_MMAP to improve the performance of the capture and "
"transmission process, but it isn't everything. At least, if you are "
"capturing at high speeds (this is relative to the cpu speed), you should "
"check if the device driver of your network interface card supports some sort "
"of interrupt load mitigation or (even better) if it supports NAPI, also make "
"sure it is enabled. For transmission, check the MTU (Maximum Transmission "
"Unit) used and supported by devices of your network. CPU IRQ pinning of your "
"network interface card can also be an advantage."
msgstr ""

#: ../../../networking/packet_mmap.rst:51
msgid "How to use mmap() to improve capture process"
msgstr ""

#: ../../../networking/packet_mmap.rst:53
msgid ""
"From the user standpoint, you should use the higher level libpcap library, "
"which is a de facto standard, portable across nearly all operating systems "
"including Win32."
msgstr ""

#: ../../../networking/packet_mmap.rst:57
msgid ""
"Packet MMAP support was integrated into libpcap around the time of version "
"1.3.0; TPACKET_V3 support was added in version 1.5.0"
msgstr ""

#: ../../../networking/packet_mmap.rst:61
msgid "How to use mmap() directly to improve capture process"
msgstr ""

#: ../../../networking/packet_mmap.rst:63
msgid ""
"From the system calls stand point, the use of PACKET_MMAP involves the "
"following process::"
msgstr ""

#: ../../../networking/packet_mmap.rst:80
msgid ""
"socket creation and destruction is straight forward, and is done the same "
"way with or without PACKET_MMAP::"
msgstr ""

#: ../../../networking/packet_mmap.rst:85
msgid ""
"where mode is SOCK_RAW for the raw interface were link level information can "
"be captured or SOCK_DGRAM for the cooked interface where link level "
"information capture is not supported and a link level pseudo-header is "
"provided by the kernel."
msgstr ""

#: ../../../networking/packet_mmap.rst:91
msgid ""
"The destruction of the socket and all associated resources is done by a "
"simple call to close(fd)."
msgstr ""

#: ../../../networking/packet_mmap.rst:94
msgid ""
"Similarly as without PACKET_MMAP, it is possible to use one socket for "
"capture and transmission. This can be done by mapping the allocated RX and "
"TX buffer ring with a single mmap() call. See \"Mapping and use of the "
"circular buffer (ring)\"."
msgstr ""

#: ../../../networking/packet_mmap.rst:99
msgid ""
"Next I will describe PACKET_MMAP settings and its constraints, also the "
"mapping of the circular buffer in the user process and the use of this "
"buffer."
msgstr ""

#: ../../../networking/packet_mmap.rst:104
msgid "How to use mmap() directly to improve transmission process"
msgstr ""

#: ../../../networking/packet_mmap.rst:105
msgid "Transmission process is similar to capture as shown below::"
msgstr ""

#: ../../../networking/packet_mmap.rst:123
msgid ""
"Socket creation and destruction is also straight forward, and is done the "
"same way as in capturing described in the previous paragraph::"
msgstr ""

#: ../../../networking/packet_mmap.rst:128
msgid ""
"The protocol can optionally be 0 in case we only want to transmit via this "
"socket, which avoids an expensive call to packet_rcv(). In this case, you "
"also need to bind(2) the TX_RING with sll_protocol = 0 set. Otherwise, "
"htons(ETH_P_ALL) or any other protocol, for example."
msgstr ""

#: ../../../networking/packet_mmap.rst:133
msgid ""
"Binding the socket to your network interface is mandatory (with zero copy) "
"to know the header size of frames used in the circular buffer."
msgstr ""

#: ../../../networking/packet_mmap.rst:136
msgid "As capture, each frame contains two parts::"
msgstr ""

#: ../../../networking/packet_mmap.rst:172
msgid "By default, the user should put data at::"
msgstr ""

#: ../../../networking/packet_mmap.rst:176
msgid ""
"So, whatever you choose for the socket mode (SOCK_DGRAM or SOCK_RAW), the "
"beginning of the user data will be at::"
msgstr ""

#: ../../../networking/packet_mmap.rst:181
msgid ""
"If you wish to put user data at a custom offset from the beginning of the "
"frame (for payload alignment with SOCK_RAW mode for instance) you can set "
"tp_net (with SOCK_DGRAM) or tp_mac (with SOCK_RAW). In order to make this "
"work it must be enabled previously with setsockopt() and the "
"PACKET_TX_HAS_OFF option."
msgstr ""

#: ../../../networking/packet_mmap.rst:188
msgid "PACKET_MMAP settings"
msgstr ""

#: ../../../networking/packet_mmap.rst:190
msgid "To setup PACKET_MMAP from user level code is done with a call like"
msgstr ""

#: ../../../networking/packet_mmap.rst:192
msgid "Capture process::"
msgstr ""

#: ../../../networking/packet_mmap.rst:196
msgid "Transmission process::"
msgstr ""

#: ../../../networking/packet_mmap.rst:200
msgid ""
"The most significant argument in the previous call is the req parameter, "
"this parameter must to have the following structure::"
msgstr ""

#: ../../../networking/packet_mmap.rst:211
msgid ""
"This structure is defined in /usr/include/linux/if_packet.h and establishes "
"a circular buffer (ring) of unswappable memory. Being mapped in the capture "
"process allows reading the captured frames and related meta-information like "
"timestamps without requiring a system call."
msgstr ""

#: ../../../networking/packet_mmap.rst:216
msgid ""
"Frames are grouped in blocks. Each block is a physically contiguous region "
"of memory and holds tp_block_size/tp_frame_size frames. The total number of "
"blocks is tp_block_nr. Note that tp_frame_nr is a redundant parameter "
"because::"
msgstr ""

#: ../../../networking/packet_mmap.rst:222
msgid "indeed, packet_set_ring checks that the following condition is true::"
msgstr ""

#: ../../../networking/packet_mmap.rst:226
msgid "Lets see an example, with the following values::"
msgstr ""

#: ../../../networking/packet_mmap.rst:233
msgid "we will get the following buffer structure::"
msgstr ""

#: ../../../networking/packet_mmap.rst:245
msgid ""
"A frame can be of any size with the only condition it can fit in a block. A "
"block can only hold an integer number of frames, or in other words, a frame "
"cannot be spawned across two blocks, so there are some details you have to "
"take into account when choosing the frame_size. See \"Mapping and use of the "
"circular buffer (ring)\"."
msgstr ""

#: ../../../networking/packet_mmap.rst:252
msgid "PACKET_MMAP setting constraints"
msgstr ""

#: ../../../networking/packet_mmap.rst:254
msgid ""
"In kernel versions prior to 2.4.26 (for the 2.4 branch) and 2.6.5 (2.6 "
"branch), the PACKET_MMAP buffer could hold only 32768 frames in a 32 bit "
"architecture or 16384 in a 64 bit architecture."
msgstr ""

#: ../../../networking/packet_mmap.rst:259
msgid "Block size limit"
msgstr ""

#: ../../../networking/packet_mmap.rst:261
msgid ""
"As stated earlier, each block is a contiguous physical region of memory. "
"These memory regions are allocated with calls to the __get_free_pages() "
"function. As the name indicates, this function allocates pages of memory, "
"and the second argument is \"order\" or a power of two number of pages, that "
"is (for PAGE_SIZE == 4096) order=0 ==> 4096 bytes, order=1 ==> 8192 bytes, "
"order=2 ==> 16384 bytes, etc. The maximum size of a region allocated by "
"__get_free_pages is determined by the MAX_PAGE_ORDER macro. More precisely "
"the limit can be calculated as::"
msgstr ""

#: ../../../networking/packet_mmap.rst:276
msgid ""
"So get_free_pages can allocate as much as 4MB or 8MB in a 2.4/2.6 kernel "
"respectively, with an i386 architecture."
msgstr ""

#: ../../../networking/packet_mmap.rst:279
msgid ""
"User space programs can include /usr/include/sys/user.h and /usr/include/"
"linux/mmzone.h to get PAGE_SIZE MAX_PAGE_ORDER declarations."
msgstr ""

#: ../../../networking/packet_mmap.rst:282
msgid ""
"The pagesize can also be determined dynamically with the getpagesize (2) "
"system call."
msgstr ""

#: ../../../networking/packet_mmap.rst:286
msgid "Block number limit"
msgstr ""

#: ../../../networking/packet_mmap.rst:288
msgid ""
"To understand the constraints of PACKET_MMAP, we have to see the structure "
"used to hold the pointers to each block."
msgstr ""

#: ../../../networking/packet_mmap.rst:291
msgid ""
"Currently, this structure is a dynamically allocated vector with kmalloc "
"called pg_vec, its size limits the number of blocks that can be allocated::"
msgstr ""

#: ../../../networking/packet_mmap.rst:304
msgid ""
"kmalloc allocates any number of bytes of physically contiguous memory from a "
"pool of pre-determined sizes. This pool of memory is maintained by the slab "
"allocator which is at the end the responsible for doing the allocation and "
"hence which imposes the maximum memory that kmalloc can allocate."
msgstr ""

#: ../../../networking/packet_mmap.rst:309
msgid ""
"In a 2.4/2.6 kernel and the i386 architecture, the limit is 131072 bytes. "
"The predetermined sizes that kmalloc uses can be checked in the \"size-"
"<bytes>\" entries of /proc/slabinfo"
msgstr ""

#: ../../../networking/packet_mmap.rst:313
msgid ""
"In a 32 bit architecture, pointers are 4 bytes long, so the total number of "
"pointers to blocks is::"
msgstr ""

#: ../../../networking/packet_mmap.rst:319
msgid "PACKET_MMAP buffer size calculator"
msgstr ""

#: ../../../networking/packet_mmap.rst:321
msgid "Definitions:"
msgstr ""

#: ../../../networking/packet_mmap.rst:324
msgid "<size-max>"
msgstr ""

#: ../../../networking/packet_mmap.rst:324
msgid "is the maximum size of allocable with kmalloc (see /proc/slabinfo)"
msgstr ""

#: ../../../networking/packet_mmap.rst:326
msgid "<pointer size>"
msgstr ""

#: ../../../networking/packet_mmap.rst:326
msgid "depends on the architecture -- ``sizeof(void *)``"
msgstr ""

#: ../../../networking/packet_mmap.rst:327
msgid "<page size>"
msgstr ""

#: ../../../networking/packet_mmap.rst:327
msgid "depends on the architecture -- PAGE_SIZE or getpagesize (2)"
msgstr ""

#: ../../../networking/packet_mmap.rst:328
msgid "<max-order>"
msgstr ""

#: ../../../networking/packet_mmap.rst:328
msgid "is the value defined with MAX_PAGE_ORDER"
msgstr ""

#: ../../../networking/packet_mmap.rst:329
msgid "<frame size>"
msgstr ""

#: ../../../networking/packet_mmap.rst:329
msgid "it's an upper bound of frame's capture size (more on this later)"
msgstr ""

#: ../../../networking/packet_mmap.rst:332
msgid "from these definitions we will derive::"
msgstr ""

#: ../../../networking/packet_mmap.rst:337
msgid "so, the max buffer size is::"
msgstr ""

#: ../../../networking/packet_mmap.rst:341
msgid "and, the number of frames be::"
msgstr ""

#: ../../../networking/packet_mmap.rst:345
msgid ""
"Suppose the following parameters, which apply for 2.6 kernel and an i386 "
"architecture::"
msgstr ""

#: ../../../networking/packet_mmap.rst:353
msgid ""
"and a value for <frame size> of 2048 bytes. These parameters will yield::"
msgstr ""

#: ../../../networking/packet_mmap.rst:358
msgid ""
"and hence the buffer will have a 262144 MiB size. So it can hold 262144 "
"MiB / 2048 bytes = 134217728 frames"
msgstr ""

#: ../../../networking/packet_mmap.rst:361
msgid ""
"Actually, this buffer size is not possible with an i386 architecture. "
"Remember that the memory is allocated in kernel space, in the case of an "
"i386 kernel's memory size is limited to 1GiB."
msgstr ""

#: ../../../networking/packet_mmap.rst:365
msgid ""
"All memory allocations are not freed until the socket is closed. The memory "
"allocations are done with GFP_KERNEL priority, this basically means that the "
"allocation can wait and swap other process' memory in order to allocate the "
"necessary memory, so normally limits can be reached."
msgstr ""

#: ../../../networking/packet_mmap.rst:371
msgid "Other constraints"
msgstr ""

#: ../../../networking/packet_mmap.rst:373
msgid ""
"If you check the source code you will see that what I draw here as a frame "
"is not only the link level frame. At the beginning of each frame there is a "
"header called struct tpacket_hdr used in PACKET_MMAP to hold link level's "
"frame meta information like timestamp. So what we draw here a frame it's "
"really the following (from include/linux/if_packet.h)::"
msgstr ""

#: ../../../networking/packet_mmap.rst:393
msgid "The following are conditions that are checked in packet_set_ring"
msgstr ""

#: ../../../networking/packet_mmap.rst:395
msgid "tp_block_size must be a multiple of PAGE_SIZE (1)"
msgstr ""

#: ../../../networking/packet_mmap.rst:396
msgid "tp_frame_size must be greater than TPACKET_HDRLEN (obvious)"
msgstr ""

#: ../../../networking/packet_mmap.rst:397
msgid "tp_frame_size must be a multiple of TPACKET_ALIGNMENT"
msgstr ""

#: ../../../networking/packet_mmap.rst:398
msgid "tp_frame_nr   must be exactly frames_per_block*tp_block_nr"
msgstr ""

#: ../../../networking/packet_mmap.rst:400
msgid ""
"Note that tp_block_size should be chosen to be a power of two or there will "
"be a waste of memory."
msgstr ""

#: ../../../networking/packet_mmap.rst:404
msgid "Mapping and use of the circular buffer (ring)"
msgstr ""

#: ../../../networking/packet_mmap.rst:406
msgid ""
"The mapping of the buffer in the user process is done with the conventional "
"mmap function. Even the circular buffer is compound of several physically "
"discontiguous blocks of memory, they are contiguous to the user space, hence "
"just one call to mmap is needed::"
msgstr ""

#: ../../../networking/packet_mmap.rst:413
msgid ""
"If tp_frame_size is a divisor of tp_block_size frames will be contiguously "
"spaced by tp_frame_size bytes. If not, each tp_block_size/tp_frame_size "
"frames there will be a gap between the frames. This is because a frame "
"cannot be spawn across two blocks."
msgstr ""

#: ../../../networking/packet_mmap.rst:419
msgid ""
"To use one socket for capture and transmission, the mapping of both the RX "
"and TX buffer ring has to be done with one call to mmap::"
msgstr ""

#: ../../../networking/packet_mmap.rst:429
msgid ""
"RX must be the first as the kernel maps the TX ring memory right after the "
"RX one."
msgstr ""

#: ../../../networking/packet_mmap.rst:432
msgid ""
"At the beginning of each frame there is an status field (see struct "
"tpacket_hdr). If this field is 0 means that the frame is ready to be used "
"for the kernel, If not, there is a frame the user can read and the following "
"flags apply:"
msgstr ""

#: ../../../networking/packet_mmap.rst:438
msgid "Capture process"
msgstr ""

#: ../../../networking/packet_mmap.rst:440
msgid "From include/linux/if_packet.h::"
msgstr ""

#: ../../../networking/packet_mmap.rst:448
msgid "TP_STATUS_COPY"
msgstr ""

#: ../../../networking/packet_mmap.rst:448
msgid ""
"This flag indicates that the frame (and associated meta information) has "
"been truncated because it's larger than tp_frame_size. This packet can be "
"read entirely with recvfrom()."
msgstr ""

#: ../../../networking/packet_mmap.rst:453
msgid ""
"In order to make this work it must to be enabled previously with "
"setsockopt() and the PACKET_COPY_THRESH option."
msgstr ""

#: ../../../networking/packet_mmap.rst:457
msgid ""
"The number of frames that can be buffered to be read with recvfrom is "
"limited like a normal socket. See the SO_RCVBUF option in the socket (7) man "
"page."
msgstr ""

#: ../../../networking/packet_mmap.rst:461
msgid "TP_STATUS_LOSING"
msgstr ""

#: ../../../networking/packet_mmap.rst:461
msgid ""
"indicates there were packet drops from last time statistics where checked "
"with getsockopt() and the PACKET_STATISTICS option."
msgstr ""

#: ../../../networking/packet_mmap.rst:465
msgid "TP_STATUS_CSUMNOTREADY"
msgstr ""

#: ../../../networking/packet_mmap.rst:465
msgid ""
"currently it's used for outgoing IP packets which its checksum will be done "
"in hardware. So while reading the packet we should not try to check the "
"checksum."
msgstr ""

#: ../../../networking/packet_mmap.rst:470
msgid "TP_STATUS_CSUM_VALID"
msgstr ""

#: ../../../networking/packet_mmap.rst:470
msgid ""
"This flag indicates that at least the transport header checksum of the "
"packet has been already validated on the kernel side. If the flag is not set "
"then we are free to check the checksum by ourselves provided that "
"TP_STATUS_CSUMNOTREADY is also not set."
msgstr ""

#: ../../../networking/packet_mmap.rst:477
msgid "for convenience there are also the following defines::"
msgstr ""

#: ../../../networking/packet_mmap.rst:482
msgid ""
"The kernel initializes all frames to TP_STATUS_KERNEL, when the kernel "
"receives a packet it puts in the buffer and updates the status with at least "
"the TP_STATUS_USER flag. Then the user can read the packet, once the packet "
"is read the user must zero the status field, so the kernel can use again "
"that frame buffer."
msgstr ""

#: ../../../networking/packet_mmap.rst:488
msgid ""
"The user can use poll (any other variant should apply too) to check if new "
"packets are in the ring::"
msgstr ""

#: ../../../networking/packet_mmap.rst:500
msgid ""
"It doesn't incur in a race condition to first check the status value and "
"then poll for frames."
msgstr ""

#: ../../../networking/packet_mmap.rst:504
msgid "Transmission process"
msgstr ""

#: ../../../networking/packet_mmap.rst:506
msgid "Those defines are also used for transmission::"
msgstr ""

#: ../../../networking/packet_mmap.rst:513
msgid ""
"First, the kernel initializes all frames to TP_STATUS_AVAILABLE. To send a "
"packet, the user fills a data buffer of an available frame, sets tp_len to "
"current data buffer size and sets its status field to "
"TP_STATUS_SEND_REQUEST. This can be done on multiple frames. Once the user "
"is ready to transmit, it calls send(). Then all buffers with status equal to "
"TP_STATUS_SEND_REQUEST are forwarded to the network device. The kernel "
"updates each status of sent frames with TP_STATUS_SENDING until the end of "
"transfer."
msgstr ""

#: ../../../networking/packet_mmap.rst:521
msgid ""
"At the end of each transfer, buffer status returns to TP_STATUS_AVAILABLE."
msgstr ""

#: ../../../networking/packet_mmap.rst:529
msgid "The user can also use poll() to check if a buffer is available:"
msgstr ""

#: ../../../networking/packet_mmap.rst:531
msgid "(status == TP_STATUS_SENDING)"
msgstr ""

#: ../../../networking/packet_mmap.rst:542
msgid "What TPACKET versions are available and when to use them?"
msgstr ""

#: ../../../networking/packet_mmap.rst:550
msgid ""
"where 'tpacket_version' can be TPACKET_V1 (default), TPACKET_V2, TPACKET_V3."
msgstr ""

#: ../../../networking/packet_mmap.rst:552
msgid "TPACKET_V1:"
msgstr ""

#: ../../../networking/packet_mmap.rst:553
msgid "Default if not otherwise specified by setsockopt(2)"
msgstr ""

#: ../../../networking/packet_mmap.rst:554
#: ../../../networking/packet_mmap.rst:561
msgid "RX_RING, TX_RING available"
msgstr ""

#: ../../../networking/packet_mmap.rst:556
msgid "TPACKET_V1 --> TPACKET_V2:"
msgstr ""

#: ../../../networking/packet_mmap.rst:557
msgid ""
"Made 64 bit clean due to unsigned long usage in TPACKET_V1 structures, thus "
"this also works on 64 bit kernel with 32 bit userspace and the like"
msgstr ""

#: ../../../networking/packet_mmap.rst:560
msgid "Timestamp resolution in nanoseconds instead of microseconds"
msgstr ""

#: ../../../networking/packet_mmap.rst:562
msgid ""
"VLAN metadata information available for packets (TP_STATUS_VLAN_VALID, "
"TP_STATUS_VLAN_TPID_VALID), in the tpacket2_hdr structure:"
msgstr ""

#: ../../../networking/packet_mmap.rst:566
msgid ""
"TP_STATUS_VLAN_VALID bit being set into the tp_status field indicates that "
"the tp_vlan_tci field has valid VLAN TCI value"
msgstr ""

#: ../../../networking/packet_mmap.rst:568
msgid ""
"TP_STATUS_VLAN_TPID_VALID bit being set into the tp_status field indicates "
"that the tp_vlan_tpid field has valid VLAN TPID value"
msgstr ""

#: ../../../networking/packet_mmap.rst:571
msgid "How to switch to TPACKET_V2:"
msgstr ""

#: ../../../networking/packet_mmap.rst:573
msgid "Replace struct tpacket_hdr by struct tpacket2_hdr"
msgstr ""

#: ../../../networking/packet_mmap.rst:574
msgid "Query header len and save"
msgstr ""

#: ../../../networking/packet_mmap.rst:575
msgid "Set protocol version to 2, set up ring as usual"
msgstr ""

#: ../../../networking/packet_mmap.rst:576
msgid ""
"For getting the sockaddr_ll, use ``(void *)hdr + TPACKET_ALIGN(hdrlen)`` "
"instead of ``(void *)hdr + TPACKET_ALIGN(sizeof(struct tpacket_hdr))``"
msgstr ""

#: ../../../networking/packet_mmap.rst:580
msgid "TPACKET_V2 --> TPACKET_V3:"
msgstr ""

#: ../../../networking/packet_mmap.rst:581
msgid "Flexible buffer implementation for RX_RING:"
msgstr ""

#: ../../../networking/packet_mmap.rst:582
msgid "Blocks can be configured with non-static frame-size"
msgstr ""

#: ../../../networking/packet_mmap.rst:583
msgid "Read/poll is at a block-level (as opposed to packet-level)"
msgstr ""

#: ../../../networking/packet_mmap.rst:584
msgid "Added poll timeout to avoid indefinite user-space wait on idle links"
msgstr ""

#: ../../../networking/packet_mmap.rst:586
msgid "Added user-configurable knobs:"
msgstr ""

#: ../../../networking/packet_mmap.rst:588
msgid "4.1 block::timeout 4.2 tpkt_hdr::sk_rxhash"
msgstr ""

#: ../../../networking/packet_mmap.rst:591
msgid "RX Hash data available in user space"
msgstr ""

#: ../../../networking/packet_mmap.rst:592
msgid ""
"TX_RING semantics are conceptually similar to TPACKET_V2; use tpacket3_hdr "
"instead of tpacket2_hdr, and TPACKET3_HDRLEN instead of TPACKET2_HDRLEN. In "
"the current implementation, the tp_next_offset field in the tpacket3_hdr "
"MUST be set to zero, indicating that the ring does not hold variable sized "
"frames. Packets with non-zero values of tp_next_offset will be dropped."
msgstr ""

#: ../../../networking/packet_mmap.rst:600
msgid "AF_PACKET fanout mode"
msgstr ""

#: ../../../networking/packet_mmap.rst:602
msgid ""
"In the AF_PACKET fanout mode, packet reception can be load balanced among "
"processes. This also works in combination with mmap(2) on packet sockets."
msgstr ""

#: ../../../networking/packet_mmap.rst:605
msgid "Currently implemented fanout policies are:"
msgstr ""

#: ../../../networking/packet_mmap.rst:607
msgid "PACKET_FANOUT_HASH: schedule to socket by skb's packet hash"
msgstr ""

#: ../../../networking/packet_mmap.rst:608
msgid "PACKET_FANOUT_LB: schedule to socket by round-robin"
msgstr ""

#: ../../../networking/packet_mmap.rst:609
msgid "PACKET_FANOUT_CPU: schedule to socket by CPU packet arrives on"
msgstr ""

#: ../../../networking/packet_mmap.rst:610
msgid "PACKET_FANOUT_RND: schedule to socket by random selection"
msgstr ""

#: ../../../networking/packet_mmap.rst:611
msgid "PACKET_FANOUT_ROLLOVER: if one socket is full, rollover to another"
msgstr ""

#: ../../../networking/packet_mmap.rst:612
msgid "PACKET_FANOUT_QM: schedule to socket by skbs recorded queue_mapping"
msgstr ""

#: ../../../networking/packet_mmap.rst:614
msgid ""
"Minimal example code by David S. Miller (try things like \"./test eth0 "
"hash\", \"./test eth0 lb\", etc.)::"
msgstr ""

#: ../../../networking/packet_mmap.rst:756
msgid "AF_PACKET TPACKET_V3 example"
msgstr ""

#: ../../../networking/packet_mmap.rst:758
msgid ""
"AF_PACKET's TPACKET_V3 ring buffer can be configured to use non-static frame "
"sizes by doing its own memory management. It is based on blocks where "
"polling works on a per block basis instead of per ring as in TPACKET_V2 and "
"predecessor."
msgstr ""

#: ../../../networking/packet_mmap.rst:762
msgid "It is said that TPACKET_V3 brings the following benefits:"
msgstr ""

#: ../../../networking/packet_mmap.rst:764
msgid "~15% - 20% reduction in CPU-usage"
msgstr ""

#: ../../../networking/packet_mmap.rst:765
msgid "~20% increase in packet capture rate"
msgstr ""

#: ../../../networking/packet_mmap.rst:766
msgid "~2x increase in packet density"
msgstr ""

#: ../../../networking/packet_mmap.rst:767
msgid "Port aggregation analysis"
msgstr ""

#: ../../../networking/packet_mmap.rst:768
msgid "Non static frame size to capture entire packet payload"
msgstr ""

#: ../../../networking/packet_mmap.rst:770
msgid "So it seems to be a good candidate to be used with packet fanout."
msgstr ""

#: ../../../networking/packet_mmap.rst:772
msgid ""
"Minimal example code by Daniel Borkmann based on Chetan Loke's lolpcap "
"(compile it with gcc -Wall -O2 blob.c, and try things like \"./a.out eth0\", "
"etc.)::"
msgstr ""

#: ../../../networking/packet_mmap.rst:1006
msgid "PACKET_QDISC_BYPASS"
msgstr ""

#: ../../../networking/packet_mmap.rst:1008
msgid ""
"If there is a requirement to load the network with many packets in a similar "
"fashion as pktgen does, you might set the following option after socket "
"creation::"
msgstr ""

#: ../../../networking/packet_mmap.rst:1015
msgid ""
"This has the side-effect, that packets sent through PF_PACKET will bypass "
"the kernel's qdisc layer and are forcedly pushed to the driver directly. "
"Meaning, packet are not buffered, tc disciplines are ignored, increased loss "
"can occur and such packets are also not visible to other PF_PACKET sockets "
"anymore. So, you have been warned; generally, this can be useful for stress "
"testing various components of a system."
msgstr ""

#: ../../../networking/packet_mmap.rst:1022
msgid ""
"On default, PACKET_QDISC_BYPASS is disabled and needs to be explicitly "
"enabled on PF_PACKET sockets."
msgstr ""

#: ../../../networking/packet_mmap.rst:1026
msgid "PACKET_TIMESTAMP"
msgstr ""

#: ../../../networking/packet_mmap.rst:1028
msgid ""
"The PACKET_TIMESTAMP setting determines the source of the timestamp in the "
"packet meta information for mmap(2)ed RX_RING and TX_RINGs.  If your NIC is "
"capable of timestamping packets in hardware, you can request those hardware "
"timestamps to be used. Note: you may need to enable the generation of "
"hardware timestamps with SIOCSHWTSTAMP (see related information from "
"Documentation/networking/timestamping.rst)."
msgstr ""

#: ../../../networking/packet_mmap.rst:1035
msgid ""
"PACKET_TIMESTAMP accepts the same integer bit field as SO_TIMESTAMPING::"
msgstr ""

#: ../../../networking/packet_mmap.rst:1040
msgid ""
"For the mmap(2)ed ring buffers, such timestamps are stored in the "
"``tpacket{,2,3}_hdr`` structure's tp_sec and ``tp_{n,u}sec`` members. To "
"determine what kind of timestamp has been reported, the tp_status field is "
"binary or'ed with the following possible bits ..."
msgstr ""

#: ../../../networking/packet_mmap.rst:1050
msgid ""
"... that are equivalent to its ``SOF_TIMESTAMPING_*`` counterparts. For the "
"RX_RING, if neither is set (i.e. PACKET_TIMESTAMP is not set), then a "
"software fallback was invoked *within* PF_PACKET's processing code (less "
"precise)."
msgstr ""

#: ../../../networking/packet_mmap.rst:1055
msgid ""
"Getting timestamps for the TX_RING works as follows: i) fill the ring "
"frames, ii) call sendto() e.g. in blocking mode, iii) wait for status of "
"relevant frames to be updated resp. the frame handed over to the "
"application, iv) walk through the frames to pick up the individual hw/sw "
"timestamps."
msgstr ""

#: ../../../networking/packet_mmap.rst:1060
msgid ""
"Only (!) if transmit timestamping is enabled, then these bits are combined "
"with binary | with TP_STATUS_AVAILABLE, so you must check for that in your "
"application (e.g. !(tp_status & (TP_STATUS_SEND_REQUEST | "
"TP_STATUS_SENDING)) in a first step to see if the frame belongs to the "
"application, and then one can extract the type of timestamp in a second step "
"from tp_status)!"
msgstr ""

#: ../../../networking/packet_mmap.rst:1066
msgid ""
"If you don't care about them, thus having it disabled, checking for "
"TP_STATUS_AVAILABLE resp. TP_STATUS_WRONG_FORMAT is sufficient. If in the "
"TX_RING part only TP_STATUS_AVAILABLE is set, then the tp_sec and tp_{n,u}"
"sec members do not contain a valid value. For TX_RINGs, by default no "
"timestamp is generated!"
msgstr ""

#: ../../../networking/packet_mmap.rst:1072
msgid ""
"See include/linux/net_tstamp.h and Documentation/networking/timestamping.rst "
"for more information on hardware timestamps."
msgstr ""

#: ../../../networking/packet_mmap.rst:1076
msgid "Miscellaneous bits"
msgstr ""

#: ../../../networking/packet_mmap.rst:1078
msgid ""
"Packet sockets work well together with Linux socket filters, thus you also "
"might want to have a look at Documentation/networking/filter.rst"
msgstr ""

#: ../../../networking/packet_mmap.rst:1082
msgid "THANKS"
msgstr ""

#: ../../../networking/packet_mmap.rst:1084
msgid "Jesse Brandeburg, for fixing my grammathical/spelling errors"
msgstr ""
