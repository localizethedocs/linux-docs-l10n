# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3
msgid "Writing an ALSA Driver"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:0
msgid "Author"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:5
msgid "Takashi Iwai <tiwai@suse.de>"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:8
msgid "Preface"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:10
msgid ""
"This document describes how to write an `ALSA (Advanced Linux Sound "
"Architecture) <http://www.alsa-project.org/>`__ driver. The document focuses "
"mainly on PCI soundcards. In the case of other device types, the API might "
"be different, too. However, at least the ALSA kernel API is consistent, and "
"therefore it would be still a bit help for writing them."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:16
msgid ""
"This document targets people who already have enough C language skills and "
"have basic linux kernel programming knowledge. This document doesn't explain "
"the general topic of linux kernel coding and doesn't cover low-level driver "
"implementation details. It only describes the standard way to write a PCI "
"sound driver on ALSA."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:23
msgid "File Tree Structure"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:26
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1099
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2350
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2723
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2923
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3957
msgid "General"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:28
msgid "The file tree structure of ALSA driver is depicted below::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:56
msgid "core directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:58
msgid ""
"This directory contains the middle layer which is the heart of ALSA drivers. "
"In this directory, the native ALSA modules are stored. The sub-directories "
"contain different modules and are dependent upon the kernel config."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:64
msgid "core/oss"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:66
msgid ""
"The code for OSS PCM and mixer emulation modules is stored in this "
"directory. The OSS rawmidi emulation is included in the ALSA rawmidi code "
"since it's quite small. The sequencer code is stored in ``core/seq/oss`` "
"directory (see `below <core/seq/oss_>`__)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:72
msgid "core/seq"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:74
msgid ""
"This directory and its sub-directories are for the ALSA sequencer. This "
"directory contains the sequencer core and primary sequencer modules such as "
"snd-seq-midi, snd-seq-virmidi, etc. They are compiled only when "
"``CONFIG_SND_SEQUENCER`` is set in the kernel config."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:80
msgid "core/seq/oss"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:82
msgid "This contains the OSS sequencer emulation code."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:85
msgid "include directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:87
msgid ""
"This is the place for the public header files of ALSA drivers, which are to "
"be exported to user-space, or included by several files in different "
"directories. Basically, the private header files should not be placed in "
"this directory, but you may still find files there, due to historical "
"reasons :)"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:94
msgid "drivers directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:96
msgid ""
"This directory contains code shared among different drivers on different "
"architectures. They are hence supposed not to be architecture-specific. For "
"example, the dummy PCM driver and the serial MIDI driver are found in this "
"directory. In the sub-directories, there is code for components which are "
"independent from bus and cpu architectures."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:103
msgid "drivers/mpu401"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:105
msgid "The MPU401 and MPU401-UART modules are stored here."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:108
msgid "drivers/opl3 and opl4"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:110
msgid "The OPL3 and OPL4 FM-synth stuff is found here."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:113
msgid "i2c directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:115
msgid "This contains the ALSA i2c components."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:117
msgid ""
"Although there is a standard i2c layer on Linux, ALSA has its own i2c code "
"for some cards, because the soundcard needs only a simple operation and the "
"standard i2c API is too complicated for such a purpose."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:122
msgid "synth directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:124
msgid "This contains the synth middle-level modules."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:126
msgid ""
"So far, there is only Emu8000/Emu10k1 synth driver under the ``synth/emux`` "
"sub-directory."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:130
msgid "pci directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:132
msgid ""
"This directory and its sub-directories hold the top-level card modules for "
"PCI soundcards and the code specific to the PCI BUS."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:135
msgid ""
"The drivers compiled from a single file are stored directly in the pci "
"directory, while the drivers with several source files are stored on their "
"own sub-directory (e.g. emu10k1, ice1712)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:140
msgid "isa directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:142
msgid ""
"This directory and its sub-directories hold the top-level card modules for "
"ISA soundcards."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:146
msgid "arm, ppc, and sparc directories"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:148
msgid ""
"They are used for top-level card modules which are specific to one of these "
"architectures."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:152
msgid "usb directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:154
msgid ""
"This directory contains the USB-audio driver. The USB MIDI driver is "
"integrated in the usb-audio driver."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:158
msgid "pcmcia directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:160
msgid ""
"The PCMCIA, especially PCCard drivers will go here. CardBus drivers will be "
"in the pci directory, because their API is identical to that of standard PCI "
"cards."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:165
msgid "soc directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:167
msgid ""
"This directory contains the codes for ASoC (ALSA System on Chip) layer "
"including ASoC core, codec and machine drivers."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:171
msgid "oss directory"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:173
msgid ""
"This contains OSS/Lite code. At the time of writing, all code has been "
"removed except for dmasound on m68k."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:179
msgid "Basic Flow for PCI Drivers"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:182
msgid "Outline"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:184
msgid "The minimum flow for PCI soundcards is as follows:"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:186
msgid "define the PCI ID table (see the section `PCI Entries`_)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:188
msgid "create ``probe`` callback."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:190
msgid "create ``remove`` callback."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:192
msgid ""
"create a struct pci_driver structure containing the three pointers above."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:195
msgid ""
"create an ``init`` function just calling the :c:func:`pci_register_driver()` "
"to register the pci_driver table defined above."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:199
msgid ""
"create an ``exit`` function to call the :c:func:`pci_unregister_driver()` "
"function."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:203
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:695
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1126
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2730
msgid "Full Code Example"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:205
msgid ""
"The code example is shown below. Some parts are kept unimplemented at this "
"moment but will be filled in the next sections. The numbers in the comment "
"lines of the :c:func:`snd_mychip_probe()` function refer to details "
"explained in the following section."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:351
msgid "Driver Constructor"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:353
msgid ""
"The real constructor of PCI drivers is the ``probe`` callback. The ``probe`` "
"callback and other component-constructors which are called from the "
"``probe`` callback cannot be used with the ``__init`` prefix because any PCI "
"device could be a hotplug device."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:358
msgid "In the ``probe`` callback, the following scheme is often used."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:361
msgid "1) Check and increment the device index."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:375
msgid "where ``enable[dev]`` is the module option."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:377
msgid ""
"Each time the ``probe`` callback is called, check the availability of the "
"device. If not available, simply increment the device index and return. dev "
"will be incremented also later (`step 7 <7) Set the PCI driver data and "
"return zero._>`__)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:383
msgid "2) Create a card instance"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:394
msgid ""
"The details will be explained in the section `Management of Cards and "
"Components`_."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:398
msgid "3) Create a main component"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:400
msgid "In this part, the PCI resources are allocated::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:408
msgid ""
"The details will be explained in the section `PCI Resource Management`_."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:411
msgid ""
"When something goes wrong, the probe function needs to deal with the error.  "
"In this example, we have a single error handling path placed at the end of "
"the function::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:419
msgid ""
"Since each component can be properly freed, the single :c:func:"
"`snd_card_free()` call should suffice in most cases."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:424
msgid "4) Set the driver ID and name strings."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:433
msgid ""
"The driver field holds the minimal ID string of the chip. This is used by "
"alsa-lib's configurator, so keep it simple but unique. Even the same driver "
"can have different driver IDs to distinguish the functionality of each chip "
"type."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:438
msgid ""
"The shortname field is a string shown as more verbose name. The longname "
"field contains the information shown in ``/proc/asound/cards``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:442
msgid "5) Create other components, such as mixer, MIDI, etc."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:444
msgid ""
"Here you define the basic components such as `PCM <PCM Interface_>`__, mixer "
"(e.g. `AC97 <API for AC97 Codec_>`__), MIDI (e.g. `MPU-401 <MIDI (MPU401-"
"UART) Interface_>`__), and other interfaces. Also, if you want a `proc file "
"<Proc Interface_>`__, define it here, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:451
msgid "6) Register the card instance."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:459
msgid ""
"Will be explained in the section `Management of Cards and Components`_, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:463
msgid "7) Set the PCI driver data and return zero."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:471
msgid ""
"In the above, the card record is stored. This pointer is used in the remove "
"callback and power-management callbacks, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:475
msgid "Destructor"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:477
msgid ""
"The destructor, the remove callback, simply releases the card instance. Then "
"the ALSA middle layer will release all the attached components automatically."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:481
msgid "It would be typically just calling :c:func:`snd_card_free()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:489
msgid ""
"The above code assumes that the card pointer is set to the PCI driver data."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:493
msgid "Header Files"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:495
msgid ""
"For the above example, at least the following include files are necessary::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:504
msgid ""
"where the last one is necessary only when module options are defined in the "
"source file. If the code is split into several files, the files without "
"module options don't need them."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:508
msgid ""
"In addition to these headers, you'll need ``<linux/interrupt.h>`` for "
"interrupt handling, and ``<linux/io.h>`` for I/O access. If you use the :c:"
"func:`mdelay()` or :c:func:`udelay()` functions, you'll need to include "
"``<linux/delay.h>`` too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:513
msgid ""
"The ALSA interfaces like the PCM and control APIs are defined in other "
"``<sound/xxx.h>`` header files. They have to be included after ``<sound/core."
"h>``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:518
msgid "Management of Cards and Components"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:521
msgid "Card Instance"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:523
msgid "For each soundcard, a “card” record must be allocated."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:525
msgid ""
"A card record is the headquarters of the soundcard. It manages the whole "
"list of devices (components) on the soundcard, such as PCM, mixers, MIDI, "
"synthesizer, and so on. Also, the card record holds the ID and the name "
"strings of the card, manages the root of proc files, and controls the power-"
"management states and hotplug disconnections. The component list on the card "
"record is used to manage the correct release of resources at destruction."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:533
msgid ""
"As mentioned above, to create a card instance, call :c:func:"
"`snd_card_new()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:541
msgid ""
"The function takes six arguments: the parent device pointer, the card-index "
"number, the id string, the module pointer (usually ``THIS_MODULE``), the "
"size of extra-data space, and the pointer to return the card instance. The "
"extra_size argument is used to allocate card->private_data for the chip-"
"specific data. Note that these data are allocated by :c:func:"
"`snd_card_new()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:548
msgid ""
"The first argument, the pointer of struct device, specifies the parent "
"device. For PCI devices, typically ``&pci->`` is passed there."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:552
msgid "Components"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:554
msgid ""
"After the card is created, you can attach the components (devices) to the "
"card instance. In an ALSA driver, a component is represented as a struct "
"snd_device object. A component can be a PCM instance, a control interface, a "
"raw MIDI interface, etc. Each such instance has one component entry."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:560
msgid ""
"A component can be created via the :c:func:`snd_device_new()` function::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:565
msgid ""
"This takes the card pointer, the device-level (``SNDRV_DEV_XXX``), the data "
"pointer, and the callback pointers (``&ops``). The device-level defines the "
"type of components and the order of registration and de-registration. For "
"most components, the device-level is already defined. For a user-defined "
"component, you can use ``SNDRV_DEV_LOWLEVEL``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:572
msgid ""
"This function itself doesn't allocate the data space. The data must be "
"allocated manually beforehand, and its pointer is passed as the argument. "
"This pointer (``chip`` in the above example) is used as the identifier for "
"the instance."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:577
msgid ""
"Each pre-defined ALSA component such as AC97 and PCM calls :c:func:"
"`snd_device_new()` inside its constructor. The destructor for each component "
"is defined in the callback pointers. Hence, you don't need to take care of "
"calling a destructor for such a component."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:582
msgid ""
"If you wish to create your own component, you need to set the destructor "
"function to the dev_free callback in the ``ops``, so that it can be released "
"automatically via :c:func:`snd_card_free()`. The next example will show an "
"implementation of chip-specific data."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:588
msgid "Chip-Specific Data"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:590
msgid ""
"Chip-specific information, e.g. the I/O port address, its resource pointer, "
"or the irq number, is stored in the chip-specific record::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:598
msgid "In general, there are two ways of allocating the chip record."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:601
msgid "1. Allocating via :c:func:`snd_card_new()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:603
msgid ""
"As mentioned above, you can pass the extra-data-length to the 5th argument "
"of :c:func:`snd_card_new()`, e.g.::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:609
msgid "struct mychip is the type of the chip record."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:611
msgid "In return, the allocated record can be accessed as"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:617
msgid ""
"With this method, you don't have to allocate twice. The record is released "
"together with the card instance."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:621
msgid "2. Allocating an extra device."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:623
msgid ""
"After allocating a card instance via :c:func:`snd_card_new()` (with ``0`` on "
"the 4th arg), call :c:func:`kzalloc()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:633
msgid ""
"The chip record should have the field to hold the card pointer at least,"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:643
msgid "Then, set the card pointer in the returned chip instance::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:647
msgid ""
"Next, initialize the fields, and register this chip record as a low-level "
"device with a specified ``ops``::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:656
msgid ""
":c:func:`snd_mychip_dev_free()` is the device-destructor function, which "
"will call the real destructor::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:664
msgid "where :c:func:`snd_mychip_free()` is the real destructor."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:666
msgid ""
"The demerit of this method is the obviously larger amount of code. The merit "
"is, however, that you can trigger your own callback at registering and "
"disconnecting the card via a setting in snd_device_ops. About registering "
"and disconnecting the card, see the subsections below."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:674
msgid "Registration and Release"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:676
msgid ""
"After all components are assigned, register the card instance by calling :c:"
"func:`snd_card_register()`. Access to the device files is enabled at this "
"point. That is, before :c:func:`snd_card_register()` is called, the "
"components are safely inaccessible from external side. If this call fails, "
"exit the probe function after releasing the card via :c:func:"
"`snd_card_free()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:683
msgid ""
"For releasing the card instance, you can call simply :c:func:"
"`snd_card_free()`. As mentioned earlier, all components are released "
"automatically by this call."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:687
msgid ""
"For a device which allows hotplugging, you can use :c:func:"
"`snd_card_free_when_closed()`. This one will postpone the destruction until "
"all devices are closed."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:692
msgid "PCI Resource Management"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:697
msgid ""
"In this section, we'll complete the chip-specific constructor, destructor "
"and PCI entries. Example code is shown first, below::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:826
msgid "Some Hafta's"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:828
msgid ""
"The allocation of PCI resources is done in the ``probe`` function, and "
"usually an extra :c:func:`xxx_create()` function is written for this purpose."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:832
msgid ""
"In the case of PCI devices, you first have to call the :c:func:"
"`pci_enable_device()` function before allocating resources. Also, you need "
"to set the proper PCI DMA mask to limit the accessed I/O range. In some "
"cases, you might need to call :c:func:`pci_set_master()` function, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:838
msgid "Suppose a 28bit mask, the code to be added would look like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:852
msgid "Resource Allocation"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:854
msgid ""
"The allocation of I/O ports and irqs is done via standard kernel functions.  "
"These resources must be released in the destructor function (see below)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:858
msgid ""
"Now assume that the PCI device has an I/O port with 8 bytes and an "
"interrupt. Then struct mychip will have the following fields::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:870
msgid ""
"For an I/O port (and also a memory region), you need to have the resource "
"pointer for the standard resource management. For an irq, you have to keep "
"only the irq number (integer). But you need to initialize this number to -1 "
"before actual allocation, since irq 0 is valid. The port address and its "
"resource pointer can be initialized as null by :c:func:`kzalloc()` "
"automatically, so you don't have to take care of resetting them."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:878
msgid "The allocation of an I/O port is done like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:888
msgid ""
"It will reserve the I/O port region of 8 bytes of the given PCI device. The "
"returned value, ``chip->res_port``, is allocated via :c:func:`kmalloc()` by :"
"c:func:`request_region()`. The pointer must be released via :c:func:"
"`kfree()`, but there is a problem with this. This issue will be explained "
"later."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:894
msgid "The allocation of an interrupt source is done like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:904
msgid ""
"where :c:func:`snd_mychip_interrupt()` is the interrupt handler defined "
"`later <PCM Interrupt Handler_>`__. Note that ``chip->irq`` should be "
"defined only when :c:func:`request_irq()` succeeded."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:909
msgid ""
"On the PCI bus, interrupts can be shared. Thus, ``IRQF_SHARED`` is used as "
"the interrupt flag of :c:func:`request_irq()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:912
msgid ""
"The last argument of :c:func:`request_irq()` is the data pointer passed to "
"the interrupt handler. Usually, the chip-specific record is used for that, "
"but you can use what you like, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:916
msgid ""
"I won't give details about the interrupt handler at this point, but at least "
"its appearance can be explained now. The interrupt handler looks usually as "
"follows::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:927
msgid ""
"After requesting the IRQ, you can passed it to ``card->sync_irq`` field::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:932
msgid ""
"This allows the PCM core to automatically call :c:func:`synchronize_irq()` "
"at the right time, like before ``hw_free``. See the later section `sync_stop "
"callback`_ for details."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:936
msgid ""
"Now let's write the corresponding destructor for the resources above. The "
"role of destructor is simple: disable the hardware (if already activated) "
"and release the resources. So far, we have no hardware part, so the "
"disabling code is not written here."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:941
msgid ""
"To release the resources, the “check-and-release” method is a safer way. For "
"the interrupt, do like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:947
msgid ""
"Since the irq number can start from 0, you should initialize ``chip->irq`` "
"with a negative value (e.g. -1), so that you can check the validity of the "
"irq number as above."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:951
msgid ""
"When you requested I/O ports or memory regions via :c:func:"
"`pci_request_region()` or :c:func:`pci_request_regions()` like in this "
"example, release the resource(s) using the corresponding function, :c:func:"
"`pci_release_region()` or :c:func:`pci_release_regions()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:960
msgid ""
"When you requested manually via :c:func:`request_region()` or :c:func:"
"`request_mem_region()`, you can release it via :c:func:`release_resource()`. "
"Suppose that you keep the resource pointer returned from :c:func:"
"`request_region()` in chip->res_port, the release procedure looks like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:968
msgid "Don't forget to call :c:func:`pci_disable_device()` before the end."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:971
msgid "And finally, release the chip-specific record::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:975
msgid ""
"We didn't implement the hardware disabling part above. If you need to do "
"this, please note that the destructor may be called even before the "
"initialization of the chip is completed. It would be better to have a flag "
"to skip hardware disabling if the hardware was not initialized yet."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:981
msgid ""
"When the chip-data is assigned to the card using :c:func:`snd_device_new()` "
"with ``SNDRV_DEV_LOWLELVEL``, its destructor is called last. That is, it is "
"assured that all other components like PCMs and controls have already been "
"released. You don't have to stop PCMs, etc. explicitly, but just call low-"
"level hardware stopping."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:988
msgid ""
"The management of a memory-mapped region is almost as same as the management "
"of an I/O port. You'll need two fields as follows::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:997
msgid "and the allocation would look like below::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1008
msgid "and the corresponding destructor would be::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1020
msgid ""
"Of course, a modern way with :c:func:`pci_iomap()` will make things a bit "
"easier, too::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1030
msgid "which is paired with :c:func:`pci_iounmap()` at destructor."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1034
msgid "PCI Entries"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1036
msgid ""
"So far, so good. Let's finish the missing PCI stuff. At first, we need a "
"struct pci_device_id table for this chipset. It's a table of PCI vendor/"
"device ID number, and some masks."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1041
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2577
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2617
msgid "For example::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1051
msgid ""
"The first and second fields of the struct pci_device_id are the vendor and "
"device IDs. If you have no reason to filter the matching devices, you can "
"leave the remaining fields as above. The last field of the struct "
"pci_device_id contains private data for this entry. You can specify any "
"value here, for example, to define specific operations for supported device "
"IDs. Such an example is found in the intel8x0 driver."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1058
msgid ""
"The last entry of this list is the terminator. You must specify this all-"
"zero entry."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1061
msgid "Then, prepare the struct pci_driver record::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1071
msgid ""
"The ``probe`` and ``remove`` functions have already been defined in the "
"previous sections. The ``name`` field is the name string of this device. "
"Note that you must not use slashes (“/”) in this string."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1075
msgid "And at last, the module entries::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1090
msgid ""
"Note that these module entries are tagged with ``__init`` and ``__exit`` "
"prefixes."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1093
msgid "That's all!"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1096
msgid "PCM Interface"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1101
msgid ""
"The PCM middle layer of ALSA is quite powerful and it is only necessary for "
"each driver to implement the low-level functions to access its hardware."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1105
msgid ""
"To access the PCM layer, you need to include ``<sound/pcm.h>`` first. In "
"addition, ``<sound/pcm_params.h>`` might be needed if you access some "
"functions related with hw_param."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1109
msgid ""
"Each card device can have up to four PCM instances. A PCM instance "
"corresponds to a PCM device file. The limitation of number of instances "
"comes only from the available bit size of Linux' device numbers. Once 64bit "
"device numbers are used, we'll have more PCM instances available."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1115
msgid ""
"A PCM instance consists of PCM playback and capture streams, and each PCM "
"stream consists of one or more PCM substreams. Some soundcards support "
"multiple playback functions. For example, emu10k1 has a PCM playback of 32 "
"stereo substreams. In this case, at each open, a free substream is (usually) "
"automatically chosen and opened. Meanwhile, when only one substream exists "
"and it was already opened, a subsequent open will either block or error with "
"``EAGAIN`` according to the file open mode. But you don't have to care about "
"such details in your driver. The PCM middle layer will take care of such "
"work."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1128
msgid ""
"The example code below does not include any hardware access routines but "
"shows only the skeleton, how to build up the PCM interfaces::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1333
msgid "PCM Constructor"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1335
msgid ""
"A PCM instance is allocated by the :c:func:`snd_pcm_new()` function. It "
"would be better to create a constructor for the PCM, namely::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1353
msgid ""
"The :c:func:`snd_pcm_new()` function takes six arguments. The first argument "
"is the card pointer to which this PCM is assigned, and the second is the ID "
"string."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1357
msgid ""
"The third argument (``index``, 0 in the above) is the index of this new PCM. "
"It begins from zero. If you create more than one PCM instances, specify the "
"different numbers in this argument. For example, ``index = 1`` for the "
"second PCM device."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1362
msgid ""
"The fourth and fifth arguments are the number of substreams for playback and "
"capture, respectively. Here 1 is used for both arguments. When no playback "
"or capture substreams are available, pass 0 to the corresponding argument."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1367
msgid ""
"If a chip supports multiple playbacks or captures, you can specify more "
"numbers, but they must be handled properly in open/close, etc. callbacks. "
"When you need to know which substream you are referring to, then it can be "
"obtained from struct snd_pcm_substream data passed to each callback as "
"follows::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1377
msgid ""
"After the PCM is created, you need to set operators for each PCM stream::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1384
msgid "The operators are defined typically like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1396
msgid "All the callbacks are described in the Operators_ subsection."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1398
msgid ""
"After setting the operators, you probably will want to pre-allocate the "
"buffer and set up the managed allocation mode. For that, simply call the "
"following::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1406
msgid ""
"It will allocate a buffer up to 64kB by default. Buffer management details "
"will be described in the later section `Buffer and Memory Management`_."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1410
msgid ""
"Additionally, you can set some extra information for this PCM in ``pcm-"
">info_flags``. The available values are defined as ``SNDRV_PCM_INFO_XXX`` in "
"``<sound/asound.h>``, which is used for the hardware definition (described "
"later). When your soundchip supports only half-duplex, specify it like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1420
msgid "... And the Destructor?"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1422
msgid ""
"The destructor for a PCM instance is not always necessary. Since the PCM "
"device will be released by the middle layer code automatically, you don't "
"have to call the destructor explicitly."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1426
msgid ""
"The destructor would be necessary if you created special records internally "
"and needed to release them. In such a case, set the destructor function to "
"``pcm->private_free``::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1454
msgid "Runtime Pointer - The Chest of PCM Information"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1456
msgid ""
"When the PCM substream is opened, a PCM runtime instance is allocated and "
"assigned to the substream. This pointer is accessible via ``substream-"
">runtime``. This runtime pointer holds most information you need to control "
"the PCM: a copy of hw_params and sw_params configurations, the buffer "
"pointers, mmap records, spinlocks, etc."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1462
msgid ""
"The definition of runtime instance is found in ``<sound/pcm.h>``. Here is "
"the relevant part of this file::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1549
msgid ""
"For the operators (callbacks) of each sound driver, most of these records "
"are supposed to be read-only. Only the PCM middle-layer changes / updates "
"them. The exceptions are the hardware description (hw) DMA buffer "
"information and the private data. Besides, if you use the standard managed "
"buffer allocation mode, you don't need to set the DMA buffer information by "
"yourself."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1556
msgid "In the sections below, important records are explained."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1559
msgid "Hardware Description"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1561
msgid ""
"The hardware descriptor (struct snd_pcm_hardware) contains the definitions "
"of the fundamental hardware configuration. Above all, you'll need to define "
"this in the `PCM open callback`_. Note that the runtime instance holds a "
"copy of the descriptor, not a pointer to the existing descriptor. That is, "
"in the open callback, you can modify the copied descriptor (``runtime->hw``) "
"as you need. For example, if the maximum number of channels is 1 only on "
"some chip models, you can still use the same hardware descriptor and change "
"the channels_max later::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1576
msgid "Typically, you'll have a hardware descriptor as below::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1596
msgid ""
"The ``info`` field contains the type and capabilities of this PCM. The bit "
"flags are defined in ``<sound/asound.h>`` as ``SNDRV_PCM_INFO_XXX``. Here, "
"at least, you have to specify whether mmap is supported and which "
"interleaving formats are supported. When the hardware supports mmap, add the "
"``SNDRV_PCM_INFO_MMAP`` flag here. When the hardware supports the "
"interleaved or the non-interleaved formats, the "
"``SNDRV_PCM_INFO_INTERLEAVED`` or ``SNDRV_PCM_INFO_NONINTERLEAVED`` flag "
"must be set, respectively. If both are supported, you can set both, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1607
msgid ""
"In the above example, ``MMAP_VALID`` and ``BLOCK_TRANSFER`` are specified "
"for the OSS mmap mode. Usually both are set. Of course, ``MMAP_VALID`` is "
"set only if mmap is really supported."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1611
msgid ""
"The other possible flags are ``SNDRV_PCM_INFO_PAUSE`` and "
"``SNDRV_PCM_INFO_RESUME``. The ``PAUSE`` bit means that the PCM supports the "
"“pause” operation, while the ``RESUME`` bit means that the PCM supports the "
"full “suspend/resume” operation. If the ``PAUSE`` flag is set, the "
"``trigger`` callback below must handle the corresponding (pause push/"
"release) commands. The suspend/resume trigger commands can be defined even "
"without the ``RESUME`` flag. See the `Power Management`_ section for details."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1620
msgid ""
"When the PCM substreams can be synchronized (typically, synchronized start/"
"stop of a playback and a capture stream), you can give "
"``SNDRV_PCM_INFO_SYNC_START``, too. In this case, you'll need to check the "
"linked-list of PCM substreams in the trigger callback. This will be "
"described in a later section."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1626
msgid ""
"The ``formats`` field contains the bit-flags of supported formats "
"(``SNDRV_PCM_FMTBIT_XXX``). If the hardware supports more than one format, "
"give all or'ed bits. In the example above, the signed 16bit little-endian "
"format is specified."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1631
msgid ""
"The ``rates`` field contains the bit-flags of supported rates "
"(``SNDRV_PCM_RATE_XXX``). When the chip supports continuous rates, pass the "
"``CONTINUOUS`` bit additionally. The pre-defined rate bits are provided only "
"for typical rates. If your chip supports unconventional rates, you need to "
"add the ``KNOT`` bit and set up the hardware constraint manually (explained "
"later)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1638
msgid ""
"``rate_min`` and ``rate_max`` define the minimum and maximum sample rate. "
"This should correspond somehow to ``rates`` bits."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1641
msgid ""
"``channels_min`` and ``channels_max`` define, as you might have already "
"expected, the minimum and maximum number of channels."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1644
msgid ""
"``buffer_bytes_max`` defines the maximum buffer size in bytes. There is no "
"``buffer_bytes_min`` field, since it can be calculated from the minimum "
"period size and the minimum number of periods. Meanwhile, "
"``period_bytes_min`` and ``period_bytes_max`` define the minimum and maximum "
"size of the period in bytes. ``periods_max`` and ``periods_min`` define the "
"maximum and minimum number of periods in the buffer."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1652
msgid ""
"The “period” is a term that corresponds to a fragment in the OSS world. The "
"period defines the point at which a PCM interrupt is generated. This point "
"strongly depends on the hardware. Generally, a smaller period size will give "
"you more interrupts, which results in being able to fill/drain the buffer "
"more timely. In the case of capture, this size defines the input latency. On "
"the other hand, the whole buffer size defines the output latency for the "
"playback direction."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1661
msgid ""
"There is also a field ``fifo_size``. This specifies the size of the hardware "
"FIFO, but currently it is neither used by the drivers nor in the alsa-lib. "
"So, you can ignore this field."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1666
msgid "PCM Configurations"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1668
msgid ""
"Ok, let's go back again to the PCM runtime records. The most frequently "
"referred records in the runtime instance are the PCM configurations. The PCM "
"configurations are stored in the runtime instance after the application "
"sends ``hw_params`` data via alsa-lib. There are many fields copied from "
"hw_params and sw_params structs. For example, ``format`` holds the format "
"type chosen by the application. This field contains the enum value "
"``SNDRV_PCM_FORMAT_XXX``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1677
msgid ""
"One thing to be noted is that the configured buffer and period sizes are "
"stored in “frames” in the runtime. In the ALSA world, ``1 frame = channels "
"\\* samples-size``. For conversion between frames and bytes, you can use "
"the :c:func:`frames_to_bytes()` and :c:func:`bytes_to_frames()` helper "
"functions::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1685
msgid ""
"Also, many software parameters (sw_params) are stored in frames, too. Please "
"check the type of the field. ``snd_pcm_uframes_t`` is for frames as unsigned "
"integer while ``snd_pcm_sframes_t`` is for frames as signed integer."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1691
msgid "DMA Buffer Information"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1693
msgid ""
"The DMA buffer is defined by the following four fields: ``dma_area``, "
"``dma_addr``, ``dma_bytes`` and ``dma_private``. ``dma_area`` holds the "
"buffer pointer (the logical address). You can call :c:func:`memcpy()` from/"
"to this pointer. Meanwhile, ``dma_addr`` holds the physical address of the "
"buffer. This field is specified only when the buffer is a linear buffer. "
"``dma_bytes`` holds the size of the buffer in bytes. ``dma_private`` is used "
"for the ALSA DMA allocator."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1701
msgid ""
"If you use either the managed buffer allocation mode or the standard API "
"function :c:func:`snd_pcm_lib_malloc_pages()` for allocating the buffer, "
"these fields are set by the ALSA middle layer, and you should *not* change "
"them by yourself. You can read them but not write them. On the other hand, "
"if you want to allocate the buffer by yourself, you'll need to manage it in "
"the hw_params callback. At least, ``dma_bytes`` is mandatory. ``dma_area`` "
"is necessary when the buffer is mmapped. If your driver doesn't support "
"mmap, this field is not necessary. ``dma_addr`` is also optional. You can "
"use dma_private as you like, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1713
msgid "Running Status"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1715
msgid ""
"The running status can be referred via ``runtime->status``. This is a "
"pointer to a struct snd_pcm_mmap_status record. For example, you can get the "
"current DMA hardware pointer via ``runtime->status->hw_ptr``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1720
msgid ""
"The DMA application pointer can be referred via ``runtime->control``, which "
"points to a struct snd_pcm_mmap_control record. However, accessing this "
"value directly is not recommended."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1725
msgid "Private Data"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1727
msgid ""
"You can allocate a record for the substream and store it in ``runtime-"
">private_data``. Usually, this is done in the `PCM open callback`_. Don't "
"mix this with ``pcm->private_data``. The ``pcm->private_data`` usually "
"points to the chip instance assigned statically at creation time of the PCM "
"device, while ``runtime->private_data`` points to a dynamic data structure "
"created in the PCM open callback::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1746
msgid "The allocated object must be released in the `close callback`_."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1749
msgid "Operators"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1751
msgid ""
"OK, now let me give details about each PCM callback (``ops``). In general, "
"every callback must return 0 if successful, or a negative error number such "
"as ``-EINVAL``. To choose an appropriate error number, it is advised to "
"check what value other parts of the kernel return when the same kind of "
"request fails."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1757
msgid ""
"Each callback function takes at least one argument containing a struct "
"snd_pcm_substream pointer. To retrieve the chip record from the given "
"substream instance, you can use the following macro::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1767
msgid ""
"The macro reads ``substream->private_data``, which is a copy of ``pcm-"
">private_data``. You can override the former if you need to assign different "
"data records per PCM substream. For example, the cmi8330 driver assigns "
"different ``private_data`` for playback and capture directions, because it "
"uses two different codecs (SB- and AD-compatible) for different directions."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1775
msgid "PCM open callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1781
msgid "This is called when a PCM substream is opened."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1783
msgid ""
"At least, here you have to initialize the ``runtime->hw`` record. Typically, "
"this is done like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1795
msgid ""
"where ``snd_mychip_playback_hw`` is the pre-defined hardware description."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1798
msgid ""
"You can allocate private data in this callback, as described in the `Private "
"Data`_ section."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1801
msgid ""
"If the hardware configuration needs more constraints, set the hardware "
"constraints here, too. See Constraints_ for more details."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1805
msgid "close callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1812
msgid "Obviously, this is called when a PCM substream is closed."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1814
msgid ""
"Any private instance for a PCM substream allocated in the ``open`` callback "
"will be released here::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1825
msgid "ioctl callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1827
msgid ""
"This is used for any special call to PCM ioctls. But usually you can leave "
"it NULL, then the PCM core calls the generic ioctl callback function :c:func:"
"`snd_pcm_lib_ioctl()`.  If you need to deal with a unique setup of channel "
"info or reset procedure, you can pass your own callback function here."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1834
msgid "hw_params callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1841
msgid ""
"This is called when the hardware parameters (``hw_params``) are set up by "
"the application, that is, once when the buffer size, the period size, the "
"format, etc. are defined for the PCM substream."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1845
msgid ""
"Many hardware setups should be done in this callback, including the "
"allocation of buffers."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1848
msgid ""
"Parameters to be initialized are retrieved by the :c:func:`params_xxx()` "
"macros."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1851
msgid ""
"When you choose managed buffer allocation mode for the substream, a buffer "
"is already allocated before this callback gets called. Alternatively, you "
"can call a helper function below for allocating the buffer::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1858
msgid ""
":c:func:`snd_pcm_lib_malloc_pages()` is available only when the DMA buffers "
"have been pre-allocated. See the section `Buffer Types`_ for more details."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1862
msgid ""
"Note that this one and the ``prepare`` callback may be called multiple times "
"per initialization. For example, the OSS emulation may call these callbacks "
"at each change via its ioctl."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1866
msgid ""
"Thus, you need to be careful not to allocate the same buffers many times, "
"which will lead to memory leaks! Calling the helper function above many "
"times is OK. It will release the previous buffer automatically when it was "
"already allocated."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1871
msgid ""
"Another note is that this callback is non-atomic (schedulable) by default, i."
"e. when no ``nonatomic`` flag set. This is important, because the "
"``trigger`` callback is atomic (non-schedulable). That is, mutexes or any "
"schedule-related functions are not available in the ``trigger`` callback. "
"Please see the subsection Atomicity_ for details."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1879
msgid "hw_free callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1885
msgid "This is called to release the resources allocated via ``hw_params``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1888
msgid ""
"This function is always called before the close callback is called. Also, "
"the callback may be called multiple times, too. Keep track whether each "
"resource was already released."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1892
msgid ""
"When you have chosen managed buffer allocation mode for the PCM substream, "
"the allocated PCM buffer will be automatically released after this callback "
"gets called.  Otherwise you'll have to release the buffer manually.  "
"Typically, when the buffer was allocated from the pre-allocated pool, you "
"can use the standard API function :c:func:`snd_pcm_lib_malloc_pages()` like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1902
msgid "prepare callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1908
msgid ""
"This callback is called when the PCM is “prepared”. You can set the format "
"type, sample rate, etc. here. The difference from ``hw_params`` is that the "
"``prepare`` callback will be called each time :c:func:`snd_pcm_prepare()` is "
"called, i.e. when recovering after underruns, etc."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1914
msgid ""
"Note that this callback is non-atomic. You can use schedule-related "
"functions safely in this callback."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1917
msgid ""
"In this and the following callbacks, you can refer to the values via the "
"runtime record, ``substream->runtime``. For example, to get the current "
"rate, format or channels, access to ``runtime->rate``, ``runtime->format`` "
"or ``runtime->channels``, respectively. The physical address of the "
"allocated buffer is set to ``runtime->dma_area``. The buffer and period "
"sizes are in ``runtime->buffer_size`` and ``runtime->period_size``, "
"respectively."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1925
msgid ""
"Be careful that this callback will be called many times at each setup, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1929
msgid "trigger callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1935
msgid "This is called when the PCM is started, stopped or paused."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1937
msgid ""
"The action is specified in the second argument, ``SNDRV_PCM_TRIGGER_XXX`` "
"defined in ``<sound/pcm.h>``. At least, the ``START`` and ``STOP`` commands "
"must be defined in this callback::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1952
msgid ""
"When the PCM supports the pause operation (given in the info field of the "
"hardware table), the ``PAUSE_PUSH`` and ``PAUSE_RELEASE`` commands must be "
"handled here, too. The former is the command to pause the PCM, and the "
"latter to restart the PCM again."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1957
msgid ""
"When the PCM supports the suspend/resume operation, regardless of full or "
"partial suspend/resume support, the ``SUSPEND`` and ``RESUME`` commands must "
"be handled, too. These commands are issued when the power-management status "
"is changed. Obviously, the ``SUSPEND`` and ``RESUME`` commands suspend and "
"resume the PCM substream, and usually, they are identical to the ``STOP`` "
"and ``START`` commands, respectively. See the `Power Management`_ section "
"for details."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1965
msgid ""
"As mentioned, this callback is atomic by default unless the ``nonatomic`` "
"flag set, and you cannot call functions which may sleep. The ``trigger`` "
"callback should be as minimal as possible, just really triggering the DMA. "
"The other stuff should be initialized in ``hw_params`` and ``prepare`` "
"callbacks properly beforehand."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1972
msgid "sync_stop callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1978
msgid ""
"This callback is optional, and NULL can be passed.  It's called after the "
"PCM core stops the stream, before it changes the stream state via "
"``prepare``, ``hw_params`` or ``hw_free``. Since the IRQ handler might be "
"still pending, we need to wait until the pending task finishes before moving "
"to the next step; otherwise it might lead to a crash due to resource "
"conflicts or access to freed resources.  A typical behavior is to call a "
"synchronization function like :c:func:`synchronize_irq()` here."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1987
msgid ""
"For the majority of drivers that need only a call of :c:func:"
"`synchronize_irq()`, there is a simpler setup, too. While keeping the "
"``sync_stop`` PCM callback NULL, the driver can set the ``card->sync_irq`` "
"field to the returned interrupt number after requesting an IRQ, instead.   "
"Then PCM core will call :c:func:`synchronize_irq()` with the given IRQ "
"appropriately."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:1994
msgid ""
"If the IRQ handler is released by the card destructor, you don't need to "
"clear ``card->sync_irq``, as the card itself is being released. So, usually "
"you'll need to add just a single line for assigning ``card->sync_irq`` in "
"the driver code unless the driver re-acquires the IRQ.  When the driver "
"frees and re-acquires the IRQ dynamically (e.g. for suspend/resume), it "
"needs to clear and re-set ``card->sync_irq`` again appropriately."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2003
msgid "pointer callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2009
msgid ""
"This callback is called when the PCM middle layer inquires the current "
"hardware position in the buffer. The position must be returned in frames, "
"ranging from 0 to ``buffer_size - 1``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2013
msgid ""
"This is usually called from the buffer-update routine in the PCM middle "
"layer, which is invoked when :c:func:`snd_pcm_period_elapsed()` is called by "
"the interrupt routine. Then the PCM middle layer updates the position and "
"calculates the available space, and wakes up the sleeping poll threads, etc."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2019
msgid "This callback is also atomic by default."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2022
msgid "copy and fill_silence ops"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2024
msgid ""
"These callbacks are not mandatory, and can be omitted in most cases. These "
"callbacks are used when the hardware buffer cannot be in the normal memory "
"space. Some chips have their own buffer in the hardware which is not "
"mappable. In such a case, you have to transfer the data manually from the "
"memory buffer to the hardware buffer. Or, if the buffer is non-contiguous on "
"both physical and virtual memory spaces, these callbacks must be defined, "
"too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2032
msgid ""
"If these two callbacks are defined, copy and set-silence operations are done "
"by them. The details will be described in the later section `Buffer and "
"Memory Management`_."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2037
msgid "ack callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2039
msgid ""
"This callback is also not mandatory. This callback is called when the "
"``appl_ptr`` is updated in read or write operations. Some drivers like "
"emu10k1-fx and cs46xx need to track the current ``appl_ptr`` for the "
"internal buffer, and this callback is useful only for such a purpose."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2044
msgid ""
"The callback function may return 0 or a negative error. When the return "
"value is ``-EPIPE``, PCM core treats that as a buffer XRUN, and changes the "
"state to ``SNDRV_PCM_STATE_XRUN`` automatically."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2048
msgid "This callback is atomic by default."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2051
msgid "page callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2053
msgid ""
"This callback is optional too. The mmap calls this callback to get the page "
"fault address."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2056
msgid ""
"You need no special callback for the standard SG-buffer or vmalloc- buffer. "
"Hence this callback should be rarely used."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2060
msgid "mmap callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2062
msgid ""
"This is another optional callback for controlling mmap behavior. When "
"defined, the PCM core calls this callback when a page is memory-mapped, "
"instead of using the standard helper. If you need special handling (due to "
"some architecture or device-specific issues), implement everything here as "
"you like."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2070
msgid "PCM Interrupt Handler"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2072
msgid ""
"The remainder of the PCM stuff is the PCM interrupt handler. The role of the "
"PCM interrupt handler in the sound driver is to update the buffer position "
"and to tell the PCM middle layer when the buffer position goes across the "
"specified period boundary. To inform about this, call the :c:func:"
"`snd_pcm_period_elapsed()` function."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2079
msgid "There are several ways sound chips can generate interrupts."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2082
msgid "Interrupts at the period (fragment) boundary"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2084
msgid ""
"This is the most frequently found type: the hardware generates an interrupt "
"at each period boundary. In this case, you can call :c:func:"
"`snd_pcm_period_elapsed()` at each interrupt."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2088
msgid ""
":c:func:`snd_pcm_period_elapsed()` takes the substream pointer as its "
"argument. Thus, you need to keep the substream pointer accessible from the "
"chip instance. For example, define ``substream`` field in the chip record to "
"hold the current running substream pointer, and set the pointer value at "
"``open`` callback (and reset at ``close`` callback)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2094
msgid ""
"If you acquire a spinlock in the interrupt handler, and the lock is used in "
"other PCM callbacks, too, then you have to release the lock before calling :"
"c:func:`snd_pcm_period_elapsed()`, because :c:func:"
"`snd_pcm_period_elapsed()` calls other PCM callbacks inside."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2100
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3762
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3796
msgid "Typical code would look like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2120
msgid ""
"Also, when the device can detect a buffer underrun/overrun, the driver can "
"notify the XRUN status to the PCM core by calling :c:func:"
"`snd_pcm_stop_xrun()`. This function stops the stream and sets the PCM state "
"to ``SNDRV_PCM_STATE_XRUN``. Note that it must be called outside the PCM "
"stream lock, hence it can't be called from the atomic callback."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2129
msgid "High frequency timer interrupts"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2131
msgid ""
"This happens when the hardware doesn't generate interrupts at the period "
"boundary but issues timer interrupts at a fixed timer rate (e.g. es1968 or "
"ymfpci drivers). In this case, you need to check the current hardware "
"position and accumulate the processed sample length at each interrupt. When "
"the accumulated size exceeds the period size, call :c:func:"
"`snd_pcm_period_elapsed()` and reset the accumulator."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2138
msgid "Typical code would look as follows::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2181
msgid "On calling :c:func:`snd_pcm_period_elapsed()`"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2183
msgid ""
"In both cases, even if more than one period has elapsed, you don't have to "
"call :c:func:`snd_pcm_period_elapsed()` many times. Call only once. And the "
"PCM layer will check the current hardware pointer and update to the latest "
"status."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2189
msgid "Atomicity"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2191
msgid ""
"One of the most important (and thus difficult to debug) problems in kernel "
"programming are race conditions. In the Linux kernel, they are usually "
"avoided via spin-locks, mutexes or semaphores. In general, if a race "
"condition can happen in an interrupt handler, it has to be managed "
"atomically, and you have to use a spinlock to protect the critical section. "
"If the critical section is not in interrupt handler code and if taking a "
"relatively long time to execute is acceptable, you should use mutexes or "
"semaphores instead."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2200
msgid ""
"As already seen, some PCM callbacks are atomic and some are not. For "
"example, the ``hw_params`` callback is non-atomic, while the ``trigger`` "
"callback is atomic. This means, the latter is called already in a spinlock "
"held by the PCM middle layer, the PCM stream lock. Please take this "
"atomicity into account when you choose a locking scheme in the callbacks."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2207
msgid ""
"In the atomic callbacks, you cannot use functions which may call :c:func:"
"`schedule()` or go to :c:func:`sleep()`. Semaphores and mutexes can sleep, "
"and hence they cannot be used inside the atomic callbacks (e.g. ``trigger`` "
"callback). To implement some delay in such a callback, please use :c:func:"
"`udelay()` or :c:func:`mdelay()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2213
msgid ""
"All three atomic callbacks (trigger, pointer, and ack) are called with local "
"interrupts disabled."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2216
msgid ""
"However, it is possible to request all PCM operations to be non-atomic. This "
"assumes that all call sites are in non-atomic contexts. For example, the "
"function :c:func:`snd_pcm_period_elapsed()` is called typically from the "
"interrupt handler. But, if you set up the driver to use a threaded interrupt "
"handler, this call can be in non-atomic context, too. In such a case, you "
"can set the ``nonatomic`` field of the struct snd_pcm object after creating "
"it. When this flag is set, mutex and rwsem are used internally in the PCM "
"core instead of spin and rwlocks, so that you can call all PCM functions "
"safely in a non-atomic context."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2228
msgid ""
"Also, in some cases, you might need to call :c:func:"
"`snd_pcm_period_elapsed()` in the atomic context (e.g. the period gets "
"elapsed during ``ack`` or other callback). There is a variant that can be "
"called inside the PCM stream lock :c:func:"
"`snd_pcm_period_elapsed_under_stream_lock()` for that purpose, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2236
msgid "Constraints"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2238
msgid ""
"Due to physical limitations, hardware is not infinitely configurable. These "
"limitations are expressed by setting constraints."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2241
msgid ""
"For example, in order to restrict the sample rates to some supported values, "
"use :c:func:`snd_pcm_hw_constraint_list()`. You need to call this function "
"in the open callback::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2265
msgid ""
"There are many different constraints. Look at ``sound/pcm.h`` for a complete "
"list. You can even define your own constraint rules. For example, let's "
"suppose my_chip can manage a substream of 1 channel if and only if the "
"format is ``S16_LE``, otherwise it supports any format specified in struct "
"snd_pcm_hardware (or in any other constraint_list). You can build a rule "
"like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2290
msgid "Then you need to call this function to add your rule::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2296
msgid ""
"The rule function is called when an application sets the PCM format, and it "
"refines the number of channels accordingly. But an application may set the "
"number of channels before setting the format. Thus you also need to define "
"the inverse rule::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2318
msgid "... and in the open callback::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2324
msgid ""
"One typical usage of the hw constraints is to align the buffer size with the "
"period size.  By default, ALSA PCM core doesn't enforce the buffer size to "
"be aligned with the period size.  For example, it'd be possible to have a "
"combination like 256 period bytes with 999 buffer bytes."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2330
msgid ""
"Many device chips, however, require the buffer to be a multiple of periods.  "
"In such a case, call :c:func:`snd_pcm_hw_constraint_integer()` for "
"``SNDRV_PCM_HW_PARAM_PERIODS``::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2338
msgid ""
"This assures that the number of periods is integer, hence the buffer size is "
"aligned with the period size."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2341
msgid ""
"The hw constraint is a very powerful mechanism to define the preferred PCM "
"configuration, and there are relevant helpers. I won't give more details "
"here, rather I would like to say, “Luke, use the source.”"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2347
msgid "Control Interface"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2352
msgid ""
"The control interface is used widely for many switches, sliders, etc. which "
"are accessed from user-space. Its most important use is the mixer interface. "
"In other words, since ALSA 0.9.x, all the mixer stuff is implemented on the "
"control kernel API."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2357
msgid ""
"ALSA has a well-defined AC97 control module. If your chip supports only the "
"AC97 and nothing else, you can skip this section."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2360
msgid ""
"The control API is defined in ``<sound/control.h>``. Include this file if "
"you want to add your own controls."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2364
msgid "Definition of Controls"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2366
msgid ""
"To create a new control, you need to define the following three callbacks: "
"``info``, ``get`` and ``put``. Then, define a struct snd_kcontrol_new "
"record, such as::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2383
msgid ""
"The ``iface`` field specifies the control type, "
"``SNDRV_CTL_ELEM_IFACE_XXX``, which is usually ``MIXER``. Use ``CARD`` for "
"global controls that are not logically part of the mixer. If the control is "
"closely associated with some specific device on the sound card, use "
"``HWDEP``, ``PCM``, ``RAWMIDI``, ``TIMER``, or ``SEQUENCER``, and specify "
"the device number with the ``device`` and ``subdevice`` fields."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2391
msgid ""
"The ``name`` is the name identifier string. Since ALSA 0.9.x, the control "
"name is very important, because its role is classified from its name. There "
"are pre-defined standard control names. The details are described in the "
"`Control Names`_ subsection."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2396
msgid ""
"The ``index`` field holds the index number of this control. If there are "
"several different controls with the same name, they can be distinguished by "
"the index number. This is the case when several codecs exist on the card. If "
"the index is zero, you can omit the definition above."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2402
msgid ""
"The ``access`` field contains the access type of this control. Give the "
"combination of bit masks, ``SNDRV_CTL_ELEM_ACCESS_XXX``, there. The details "
"will be explained in the `Access Flags`_ subsection."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2407
msgid ""
"The ``private_value`` field contains an arbitrary long integer value for "
"this record. When using the generic ``info``, ``get`` and ``put`` callbacks, "
"you can pass a value through this field. If several small numbers are "
"necessary, you can combine them in bitwise. Or, it's possible to store a "
"pointer (casted to unsigned long) of some record in this field, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2414
msgid ""
"The ``tlv`` field can be used to provide metadata about the control; see the "
"`Metadata`_ subsection."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2417
msgid "The other three are `Control Callbacks`_."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2420
msgid "Control Names"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2422
msgid ""
"There are some standards to define the control names. A control is usually "
"defined from the three parts as “SOURCE DIRECTION FUNCTION”."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2425
msgid ""
"The first, ``SOURCE``, specifies the source of the control, and is a string "
"such as “Master”, “PCM”, “CD” and “Line”. There are many pre-defined sources."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2429
msgid ""
"The second, ``DIRECTION``, is one of the following strings according to the "
"direction of the control: “Playback”, “Capture”, “Bypass Playback” and "
"“Bypass Capture”. Or, it can be omitted, meaning both playback and capture "
"directions."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2434
msgid ""
"The third, ``FUNCTION``, is one of the following strings according to the "
"function of the control: “Switch”, “Volume” and “Route”."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2437
msgid ""
"The example of control names are, thus, “Master Capture Switch” or “PCM "
"Playback Volume”."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2440
msgid "There are some exceptions:"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2443
msgid "Global capture and playback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2445
msgid ""
"“Capture Source”, “Capture Switch” and “Capture Volume” are used for the "
"global capture (input) source, switch and volume. Similarly, “Playback "
"Switch” and “Playback Volume” are used for the global output gain switch and "
"volume."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2451
msgid "Tone-controls"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2453
msgid ""
"tone-control switch and volumes are specified like “Tone Control - XXX”, e."
"g. “Tone Control - Switch”, “Tone Control - Bass”, “Tone Control - Center”."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2458
msgid "3D controls"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2460
msgid ""
"3D-control switches and volumes are specified like “3D Control - XXX”, e.g. "
"“3D Control - Switch”, “3D Control - Center”, “3D Control - Space”."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2464
msgid "Mic boost"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2466
msgid "Mic-boost switch is set as “Mic Boost” or “Mic Boost (6dB)”."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2468
msgid ""
"More precise information can be found in ``Documentation/sound/designs/"
"control-names.rst``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2472
msgid "Access Flags"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2474
msgid ""
"The access flag is the bitmask which specifies the access type of the given "
"control. The default access type is ``SNDRV_CTL_ELEM_ACCESS_READWRITE``, "
"which means both read and write are allowed to this control. When the access "
"flag is omitted (i.e. = 0), it is considered as ``READWRITE`` access by "
"default."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2480
msgid ""
"When the control is read-only, pass ``SNDRV_CTL_ELEM_ACCESS_READ`` instead. "
"In this case, you don't have to define the ``put`` callback. Similarly, when "
"the control is write-only (although it's a rare case), you can use the "
"``WRITE`` flag instead, and you don't need the ``get`` callback."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2486
msgid ""
"If the control value changes frequently (e.g. the VU meter), ``VOLATILE`` "
"flag should be given. This means that the control may be changed without "
"`Change notification`_. Applications should poll such a control constantly."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2491
msgid ""
"When the control may be updated, but currently has no effect on anything, "
"setting the ``INACTIVE`` flag may be appropriate. For example, PCM controls "
"should be inactive while no PCM device is open."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2495
msgid "There are ``LOCK`` and ``OWNER`` flags to change the write permissions."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2498
msgid "Control Callbacks"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2501
msgid "info callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2503
msgid ""
"The ``info`` callback is used to get detailed information on this control. "
"This must store the values of the given struct snd_ctl_elem_info object. For "
"example, for a boolean control with a single element::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2521
msgid ""
"The ``type`` field specifies the type of the control. There are ``BOOLEAN``, "
"``INTEGER``, ``ENUMERATED``, ``BYTES``, ``IEC958`` and ``INTEGER64``. The "
"``count`` field specifies the number of elements in this control. For "
"example, a stereo volume would have count = 2. The ``value`` field is a "
"union, and the values stored depend on the type. The boolean and integer "
"types are identical."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2528
msgid ""
"The enumerated type is a bit different from the others. You'll need to set "
"the string for the selectec item index::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2547
msgid ""
"The above callback can be simplified with a helper function, :c:func:"
"`snd_ctl_enum_info()`. The final code looks like below. (You can pass "
"``ARRAY_SIZE(texts)`` instead of 4 in the third argument; it's a matter of "
"taste.)"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2564
msgid ""
"Some common info callbacks are available for your convenience: :c:func:"
"`snd_ctl_boolean_mono_info()` and :c:func:`snd_ctl_boolean_stereo_info()`. "
"Obviously, the former is an info callback for a mono channel boolean item, "
"just like :c:func:`snd_myctl_mono_info()` above, and the latter is for a "
"stereo channel boolean item."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2572
msgid "get callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2574
msgid ""
"This callback is used to read the current value of the control, so it can be "
"returned to user-space."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2589
msgid ""
"The ``value`` field depends on the type of control as well as on the info "
"callback. For example, the sb driver uses this field to store the register "
"offset, the bit-shift and the bit-mask. The ``private_value`` field is set "
"as follows::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2596
msgid "and is retrieved in callbacks like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2607
msgid ""
"In the ``get`` callback, you have to fill all the elements if the control "
"has more than one element, i.e. ``count > 1``. In the example above, we "
"filled only one element (``value.integer.value[0]``) since ``count = 1`` is "
"assumed."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2613
msgid "put callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2615
msgid "This callback is used to write a value coming from user-space."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2635
msgid ""
"As seen above, you have to return 1 if the value is changed. If the value is "
"not changed, return 0 instead. If any fatal error happens, return a negative "
"error code as usual."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2639
msgid ""
"As in the ``get`` callback, when the control has more than one element, all "
"elements must be evaluated in this callback, too."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2643
msgid "Callbacks are not atomic"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2645
msgid "All these three callbacks are not-atomic."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2648
msgid "Control Constructor"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2650
msgid ""
"When everything is ready, finally we can create a new control. To create a "
"control, there are two functions to be called, :c:func:`snd_ctl_new1()` and :"
"c:func:`snd_ctl_add()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2654
msgid "In the simplest way, you can do it like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2660
msgid ""
"where ``my_control`` is the struct snd_kcontrol_new object defined above, "
"and chip is the object pointer to be passed to kcontrol->private_data which "
"can be referred to in callbacks."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2664
msgid ""
":c:func:`snd_ctl_new1()` allocates a new struct snd_kcontrol instance, and :"
"c:func:`snd_ctl_add()` assigns the given control component to the card."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2669
msgid "Change Notification"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2671
msgid ""
"If you need to change and update a control in the interrupt routine, you can "
"call :c:func:`snd_ctl_notify()`. For example::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2676
msgid ""
"This function takes the card pointer, the event-mask, and the control id "
"pointer for the notification. The event-mask specifies the types of "
"notification, for example, in the above example, the change of control "
"values is notified. The id pointer is the pointer of struct snd_ctl_elem_id "
"to be notified. You can find some examples in ``es1938.c`` or ``es1968.c`` "
"for hardware volume interrupts."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2684
msgid "Metadata"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2686
msgid ""
"To provide information about the dB values of a mixer control, use one of "
"the ``DECLARE_TLV_xxx`` macros from ``<sound/tlv.h>`` to define a variable "
"containing this information, set the ``tlv.p`` field to point to this "
"variable, and include the ``SNDRV_CTL_ELEM_ACCESS_TLV_READ`` flag in the "
"``access`` field; like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2703
msgid ""
"The :c:func:`DECLARE_TLV_DB_SCALE()` macro defines information about a mixer "
"control where each step in the control's value changes the dB value by a "
"constant dB amount. The first parameter is the name of the variable to be "
"defined. The second parameter is the minimum value, in units of 0.01 dB. The "
"third parameter is the step size, in units of 0.01 dB. Set the fourth "
"parameter to 1 if the minimum value actually mutes the control."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2711
msgid ""
"The :c:func:`DECLARE_TLV_DB_LINEAR()` macro defines information about a "
"mixer control where the control's value affects the output linearly. The "
"first parameter is the name of the variable to be defined. The second "
"parameter is the minimum value, in units of 0.01 dB. The third parameter is "
"the maximum value, in units of 0.01 dB. If the minimum value mutes the "
"control, set the second parameter to ``TLV_DB_GAIN_MUTE``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2720
msgid "API for AC97 Codec"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2725
msgid ""
"The ALSA AC97 codec layer is a well-defined one, and you don't have to write "
"much code to control it. Only low-level control routines are necessary. The "
"AC97 codec API is defined in ``<sound/ac97_codec.h>``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2777
msgid "AC97 Constructor"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2779
msgid ""
"To create an ac97 instance, first call :c:func:`snd_ac97_bus()` with an "
"``ac97_bus_ops_t`` record with callback functions::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2790
msgid "The bus record is shared among all belonging ac97 instances."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2792
msgid ""
"And then call :c:func:`snd_ac97_mixer()` with a struct snd_ac97_template "
"record together with the bus pointer created above::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2802
msgid ""
"where chip->ac97 is a pointer to a newly created ``ac97_t`` instance. In "
"this case, the chip pointer is set as the private data, so that the read/"
"write callback functions can refer to this chip instance. This instance is "
"not necessarily stored in the chip record. If you need to change the "
"register values from the driver, or need the suspend/resume of ac97 codecs, "
"keep this pointer to pass to the corresponding functions."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2811
msgid "AC97 Callbacks"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2813
msgid ""
"The standard callbacks are ``read`` and ``write``. Obviously they correspond "
"to the functions for read and write accesses to the hardware low-level codes."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2817
msgid ""
"The ``read`` callback returns the register value specified in the argument::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2828
msgid "Here, the chip can be cast from ``ac97->private_data``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2830
msgid "Meanwhile, the ``write`` callback is used to set the register value::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2837
msgid "These callbacks are non-atomic like the control API callbacks."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2839
msgid "There are also other callbacks: ``reset``, ``wait`` and ``init``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2841
msgid ""
"The ``reset`` callback is used to reset the codec. If the chip requires a "
"special kind of reset, you can define this callback."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2844
msgid ""
"The ``wait`` callback is used to add some waiting time in the standard "
"initialization of the codec. If the chip requires the extra waiting time, "
"define this callback."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2848
msgid ""
"The ``init`` callback is used for additional initialization of the codec."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2852
msgid "Updating Registers in The Driver"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2854
msgid ""
"If you need to access to the codec from the driver, you can call the "
"following functions: :c:func:`snd_ac97_write()`, :c:func:`snd_ac97_read()`, :"
"c:func:`snd_ac97_update()` and :c:func:`snd_ac97_update_bits()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2859
msgid ""
"Both :c:func:`snd_ac97_write()` and :c:func:`snd_ac97_update()` functions "
"are used to set a value to the given register (``AC97_XXX``). The difference "
"between them is that :c:func:`snd_ac97_update()` doesn't write a value if "
"the given value has been already set, while :c:func:`snd_ac97_write()` "
"always rewrites the value::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2869
msgid ""
":c:func:`snd_ac97_read()` is used to read the value of the given register. "
"For example::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2874
msgid ""
":c:func:`snd_ac97_update_bits()` is used to update some bits in the given "
"register::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2879
msgid ""
"Also, there is a function to change the sample rate (of a given register "
"such as ``AC97_PCM_FRONT_DAC_RATE``) when VRA or DRA is supported by the "
"codec: :c:func:`snd_ac97_set_rate()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2886
msgid ""
"The following registers are available to set the rate: "
"``AC97_PCM_MIC_ADC_RATE``, ``AC97_PCM_FRONT_DAC_RATE``, "
"``AC97_PCM_LR_ADC_RATE``, ``AC97_SPDIF``. When ``AC97_SPDIF`` is specified, "
"the register is not really changed but the corresponding IEC958 status bits "
"will be updated."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2893
msgid "Clock Adjustment"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2895
msgid ""
"In some chips, the clock of the codec isn't 48000 but using a PCI clock (to "
"save a quartz!). In this case, change the field ``bus->clock`` to the "
"corresponding value. For example, intel8x0 and es1968 drivers have their own "
"function to read from the clock."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2901
msgid "Proc Files"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2903
msgid ""
"The ALSA AC97 interface will create a proc file such as ``/proc/asound/card0/"
"codec97#0/ac97#0-0`` and ``ac97#0-0+regs``. You can refer to these files to "
"see the current status and registers of the codec."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2909
msgid "Multiple Codecs"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2911
msgid ""
"When there are several codecs on the same card, you need to call :c:func:"
"`snd_ac97_mixer()` multiple times with ``ac97.num=1`` or greater. The "
"``num`` field specifies the codec number."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2915
msgid ""
"If you set up multiple codecs, you either need to write different callbacks "
"for each codec or check ``ac97->num`` in the callback routines."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2920
msgid "MIDI (MPU401-UART) Interface"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2925
msgid ""
"Many soundcards have built-in MIDI (MPU401-UART) interfaces. When the "
"soundcard supports the standard MPU401-UART interface, most likely you can "
"use the ALSA MPU401-UART API. The MPU401-UART API is defined in ``<sound/"
"mpu401.h>``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2930
msgid ""
"Some soundchips have a similar but slightly different implementation of "
"mpu401 stuff. For example, emu10k1 has its own mpu401 routines."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2934
msgid "MIDI Constructor"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2936
msgid "To create a rawmidi object, call :c:func:`snd_mpu401_uart_new()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2943
msgid ""
"The first argument is the card pointer, and the second is the index of this "
"component. You can create up to 8 rawmidi devices."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2946
msgid ""
"The third argument is the type of the hardware, ``MPU401_HW_XXX``. If it's "
"not a special one, you can use ``MPU401_HW_MPU401``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2949
msgid ""
"The 4th argument is the I/O port address. Many backward-compatible MPU401 "
"have an I/O port such as 0x330. Or, it might be a part of its own PCI I/O "
"region. It depends on the chip design."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2953
msgid ""
"The 5th argument is a bitflag for additional information. When the I/O port "
"address above is part of the PCI I/O region, the MPU401 I/O port might have "
"been already allocated (reserved) by the driver itself. In such a case, pass "
"a bit flag ``MPU401_INFO_INTEGRATED``, and the mpu401-uart layer will "
"allocate the I/O ports by itself."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2959
msgid ""
"When the controller supports only the input or output MIDI stream, pass the "
"``MPU401_INFO_INPUT`` or ``MPU401_INFO_OUTPUT`` bitflag, respectively. Then "
"the rawmidi instance is created as a single stream."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2963
msgid ""
"``MPU401_INFO_MMIO`` bitflag is used to change the access method to MMIO "
"(via readb and writeb) instead of iob and outb. In this case, you have to "
"pass the iomapped address to :c:func:`snd_mpu401_uart_new()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2967
msgid ""
"When ``MPU401_INFO_TX_IRQ`` is set, the output stream isn't checked in the "
"default interrupt handler. The driver needs to call :c:func:"
"`snd_mpu401_uart_interrupt_tx()` by itself to start processing the output "
"stream in the irq handler."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2972
msgid ""
"If the MPU-401 interface shares its interrupt with the other logical devices "
"on the card, set ``MPU401_INFO_IRQ_HOOK`` (see `below <MIDI Interrupt "
"Handler_>`__)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2976
msgid ""
"Usually, the port address corresponds to the command port and port + 1 "
"corresponds to the data port. If not, you may change the ``cport`` field of "
"struct snd_mpu401 manually afterward. However, struct snd_mpu401 pointer is "
"not returned explicitly by :c:func:`snd_mpu401_uart_new()`. You need to cast "
"``rmidi->private_data`` to struct snd_mpu401 explicitly::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2986
msgid "and reset the ``cport`` as you like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2990
msgid ""
"The 6th argument specifies the ISA irq number that will be allocated. If no "
"interrupt is to be allocated (because your code is already allocating a "
"shared interrupt, or because the device does not use interrupts), pass -1 "
"instead. For a MPU-401 device without an interrupt, a polling timer will be "
"used instead."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2997
msgid "MIDI Interrupt Handler"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:2999
msgid ""
"When the interrupt is allocated in :c:func:`snd_mpu401_uart_new()`, an "
"exclusive ISA interrupt handler is automatically used, hence you don't have "
"anything else to do than creating the mpu401 stuff. Otherwise, you have to "
"set ``MPU401_INFO_IRQ_HOOK``, and call :c:func:`snd_mpu401_uart_interrupt()` "
"explicitly from your own interrupt handler when it has determined that a "
"UART interrupt has occurred."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3008
msgid ""
"In this case, you need to pass the private_data of the returned rawmidi "
"object from :c:func:`snd_mpu401_uart_new()` as the second argument of :c:"
"func:`snd_mpu401_uart_interrupt()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3016
msgid "RawMIDI Interface"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3019
msgid "Overview"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3021
msgid ""
"The raw MIDI interface is used for hardware MIDI ports that can be accessed "
"as a byte stream. It is not used for synthesizer chips that do not directly "
"understand MIDI."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3025
msgid ""
"ALSA handles file and buffer management. All you have to do is to write some "
"code to move data between the buffer and the hardware."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3028
msgid "The rawmidi API is defined in ``<sound/rawmidi.h>``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3031
msgid "RawMIDI Constructor"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3033
msgid ""
"To create a rawmidi device, call the :c:func:`snd_rawmidi_new()` function::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3046
msgid ""
"The first argument is the card pointer, the second argument is the ID string."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3049
msgid ""
"The third argument is the index of this component. You can create up to 8 "
"rawmidi devices."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3052
msgid ""
"The fourth and fifth arguments are the number of output and input "
"substreams, respectively, of this device (a substream is the equivalent of a "
"MIDI port)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3056
msgid ""
"Set the ``info_flags`` field to specify the capabilities of the device. Set "
"``SNDRV_RAWMIDI_INFO_OUTPUT`` if there is at least one output port, "
"``SNDRV_RAWMIDI_INFO_INPUT`` if there is at least one input port, and "
"``SNDRV_RAWMIDI_INFO_DUPLEX`` if the device can handle output and input at "
"the same time."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3062
msgid ""
"After the rawmidi device is created, you need to set the operators "
"(callbacks) for each substream. There are helper functions to set the "
"operators for all the substreams of a device::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3069
msgid "The operators are usually defined like this::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3077
msgid "These callbacks are explained in the `RawMIDI Callbacks`_ section."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3079
msgid ""
"If there are more than one substream, you should give a unique name to each "
"of them::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3091
msgid "RawMIDI Callbacks"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3093
msgid ""
"In all the callbacks, the private data that you've set for the rawmidi "
"device can be accessed as ``substream->rmidi->private_data``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3096
msgid ""
"If there is more than one port, your callbacks can determine the port index "
"from the struct snd_rawmidi_substream data passed to each callback::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3104
msgid "RawMIDI open callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3111
msgid ""
"This is called when a substream is opened. You can initialize the hardware "
"here, but you shouldn't start transmitting/receiving data yet."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3115
msgid "RawMIDI close callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3121
msgid "Guess what."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3123
msgid ""
"The ``open`` and ``close`` callbacks of a rawmidi device are serialized with "
"a mutex, and can sleep."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3127
msgid "Rawmidi trigger callback for output substreams"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3134
msgid ""
"This is called with a nonzero ``up`` parameter when there is some data in "
"the substream buffer that must be transmitted."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3137
msgid ""
"To read data from the buffer, call :c:func:`snd_rawmidi_transmit_peek()`. It "
"will return the number of bytes that have been read; this will be less than "
"the number of bytes requested when there are no more data in the buffer. "
"After the data have been transmitted successfully, call :c:func:"
"`snd_rawmidi_transmit_ack()` to remove the data from the substream buffer::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3153
msgid ""
"If you know beforehand that the hardware will accept data, you can use the :"
"c:func:`snd_rawmidi_transmit()` function which reads some data and removes "
"them from the buffer at once::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3164
msgid ""
"If you know beforehand how many bytes you can accept, you can use a buffer "
"size greater than one with the ``snd_rawmidi_transmit*()`` functions."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3167
msgid ""
"The ``trigger`` callback must not sleep. If the hardware FIFO is full before "
"the substream buffer has been emptied, you have to continue transmitting "
"data later, either in an interrupt handler, or with a timer if the hardware "
"doesn't have a MIDI transmit interrupt."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3172
msgid ""
"The ``trigger`` callback is called with a zero ``up`` parameter when the "
"transmission of data should be aborted."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3176
msgid "RawMIDI trigger callback for input substreams"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3183
msgid ""
"This is called with a nonzero ``up`` parameter to enable receiving data, or "
"with a zero ``up`` parameter do disable receiving data."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3186
msgid ""
"The ``trigger`` callback must not sleep; the actual reading of data from the "
"device is usually done in an interrupt handler."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3189
msgid ""
"When data reception is enabled, your interrupt handler should call :c:func:"
"`snd_rawmidi_receive()` for all received data::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3203
msgid "drain callback"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3210
msgid ""
"This is only used with output substreams. This function should wait until "
"all data read from the substream buffer have been transmitted. This ensures "
"that the device can be closed and the driver unloaded without losing data."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3215
msgid ""
"This callback is optional. If you do not set ``drain`` in the struct "
"snd_rawmidi_ops structure, ALSA will simply wait for 50 milliseconds instead."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3220
msgid "Miscellaneous Devices"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3223
msgid "FM OPL3"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3225
msgid ""
"The FM OPL3 is still used in many chips (mainly for backward compatibility). "
"ALSA has a nice OPL3 FM control layer, too. The OPL3 API is defined in "
"``<sound/opl3.h>``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3229
msgid ""
"FM registers can be directly accessed through the direct-FM API, defined in "
"``<sound/asound_fm.h>``. In ALSA native mode, FM registers are accessed "
"through the Hardware-Dependent Device direct-FM extension API, whereas in "
"OSS compatible mode, FM registers can be accessed with the OSS direct-FM "
"compatible API in ``/dev/dmfmX`` device."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3235
msgid ""
"To create the OPL3 component, you have two functions to call. The first one "
"is a constructor for the ``opl3_t`` instance::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3242
msgid ""
"The first argument is the card pointer, the second one is the left port "
"address, and the third is the right port address. In most cases, the right "
"port is placed at the left port + 2."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3246
msgid "The fourth argument is the hardware type."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3248
msgid ""
"When the left and right ports have been already allocated by the card "
"driver, pass non-zero to the fifth argument (``integrated``). Otherwise, the "
"opl3 module will allocate the specified ports by itself."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3252
msgid ""
"When the accessing the hardware requires special method instead of the "
"standard I/O access, you can create opl3 instance separately with :c:func:"
"`snd_opl3_new()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3259
msgid ""
"Then set ``command``, ``private_data`` and ``private_free`` for the private "
"access function, the private data and the destructor. The ``l_port`` and "
"``r_port`` are not necessarily set. Only the command must be set properly. "
"You can retrieve the data from the ``opl3->private_data`` field."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3265
msgid ""
"After creating the opl3 instance via :c:func:`snd_opl3_new()`, call :c:func:"
"`snd_opl3_init()` to initialize the chip to the proper state. Note that :c:"
"func:`snd_opl3_create()` always calls it internally."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3270
msgid ""
"If the opl3 instance is created successfully, then create a hwdep device for "
"this opl3::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3276
msgid ""
"The first argument is the ``opl3_t`` instance you created, and the second is "
"the index number, usually 0."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3279
msgid ""
"The third argument is the index-offset for the sequencer client assigned to "
"the OPL3 port. When there is an MPU401-UART, give 1 for here (UART always "
"takes 0)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3284
msgid "Hardware-Dependent Devices"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3286
msgid ""
"Some chips need user-space access for special controls or for loading the "
"micro code. In such a case, you can create a hwdep (hardware-dependent) "
"device. The hwdep API is defined in ``<sound/hwdep.h>``. You can find "
"examples in opl3 driver or ``isa/sb/sb16_csp.c``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3292
msgid ""
"The creation of the ``hwdep`` instance is done via :c:func:"
"`snd_hwdep_new()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3298
msgid "where the third argument is the index number."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3300
msgid ""
"You can then pass any pointer value to the ``private_data``. If you assign "
"private data, you should define a destructor, too. The destructor function "
"is set in the ``private_free`` field::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3308
msgid "and the implementation of the destructor would be::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3316
msgid ""
"The arbitrary file operations can be defined for this instance. The file "
"operators are defined in the ``ops`` table. For example, assume that this "
"chip needs an ioctl::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3324
msgid "And implement the callback functions as you like."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3327
msgid "IEC958 (S/PDIF)"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3329
msgid ""
"Usually the controls for IEC958 devices are implemented via the control "
"interface. There is a macro to compose a name string for IEC958 controls, :c:"
"func:`SNDRV_CTL_NAME_IEC958()` defined in ``<include/asound.h>``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3334
msgid ""
"There are some standard controls for IEC958 status bits. These controls use "
"the type ``SNDRV_CTL_ELEM_TYPE_IEC958``, and the size of element is fixed as "
"4 bytes array (value.iec958.status[x]). For the ``info`` callback, you don't "
"specify the value field for this type (the count field must be set, though)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3340
msgid ""
"“IEC958 Playback Con Mask” is used to return the bit-mask for the IEC958 "
"status bits of consumer mode. Similarly, “IEC958 Playback Pro Mask” returns "
"the bitmask for professional mode. They are read-only controls."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3344
msgid ""
"Meanwhile, “IEC958 Playback Default” control is defined for getting and "
"setting the current default IEC958 bits."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3347
msgid ""
"Due to historical reasons, both variants of the Playback Mask and the "
"Playback Default controls can be implemented on either a "
"``SNDRV_CTL_ELEM_IFACE_PCM`` or a ``SNDRV_CTL_ELEM_IFACE_MIXER`` iface. "
"Drivers should expose the mask and default on the same iface though."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3352
msgid ""
"In addition, you can define the control switches to enable/disable or to set "
"the raw bit mode. The implementation will depend on the chip, but the "
"control should be named as “IEC958 xxx”, preferably using the :c:func:"
"`SNDRV_CTL_NAME_IEC958()` macro."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3357
msgid ""
"You can find several cases, for example, ``pci/emu10k1``, ``pci/ice1712``, "
"or ``pci/cmipci.c``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3361
msgid "Buffer and Memory Management"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3364
msgid "Buffer Types"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3366
msgid ""
"ALSA provides several different buffer allocation functions depending on the "
"bus and the architecture. All these have a consistent API. The allocation of "
"physically-contiguous pages is done via the :c:func:`snd_malloc_xxx_pages()` "
"function, where xxx is the bus type."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3372
msgid ""
"The allocation of pages with fallback is done via :c:func:"
"`snd_dma_alloc_pages_fallback()`. This function tries to allocate the "
"specified number of pages, but if not enough pages are available, it tries "
"to reduce the request size until enough space is found, down to one page."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3378
msgid "To release the pages, call the :c:func:`snd_dma_free_pages()` function."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3381
msgid ""
"Usually, ALSA drivers try to allocate and reserve a large contiguous "
"physical space at the time the module is loaded for later use. This is "
"called “pre-allocation”. As already written, you can call the following "
"function at PCM instance construction time (in the case of PCI bus)::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3390
msgid ""
"where ``size`` is the byte size to be pre-allocated and ``max`` is the "
"maximum size settable via the ``prealloc`` proc file. The allocator will try "
"to get an area as large as possible within the given size."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3395
msgid ""
"The second argument (type) and the third argument (device pointer) are "
"dependent on the bus. For normal devices, pass the device pointer (typically "
"identical as ``card->dev``) to the third argument with "
"``SNDRV_DMA_TYPE_DEV`` type."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3400
msgid ""
"A continuous buffer unrelated to the bus can be pre-allocated with "
"``SNDRV_DMA_TYPE_CONTINUOUS`` type. You can pass NULL to the device pointer "
"in that case, which is the default mode implying to allocate with the "
"``GFP_KERNEL`` flag. If you need a restricted (lower) address, set up the "
"coherent DMA mask bits for the device, and pass the device pointer, like the "
"normal device memory allocations.  For this type, it's still allowed to pass "
"NULL to the device pointer, too, if no address restriction is needed."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3409
msgid ""
"For the scatter-gather buffers, use ``SNDRV_DMA_TYPE_DEV_SG`` with the "
"device pointer (see the `Non-Contiguous Buffers`_ section)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3412
msgid ""
"Once the buffer is pre-allocated, you can use the allocator in the "
"``hw_params`` callback::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3417
msgid "Note that you have to pre-allocate to use this function."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3419
msgid ""
"But most drivers use the \"managed buffer allocation mode\" instead of "
"manual allocation and release. This is done by calling :c:func:"
"`snd_pcm_set_managed_buffer_all()` instead of :c:func:"
"`snd_pcm_lib_preallocate_pages_for_all()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3427
msgid ""
"where the passed arguments are identical for both functions. The difference "
"in the managed mode is that PCM core will call :c:func:"
"`snd_pcm_lib_malloc_pages()` internally already before calling the PCM "
"``hw_params`` callback, and call :c:func:`snd_pcm_lib_free_pages()` after "
"the PCM ``hw_free`` callback automatically.  So the driver doesn't have to "
"call these functions explicitly in its callback any longer.  This allows "
"many drivers to have NULL ``hw_params`` and ``hw_free`` entries."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3437
msgid "External Hardware Buffers"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3439
msgid ""
"Some chips have their own hardware buffers and DMA transfer from the host "
"memory is not available. In such a case, you need to either 1) copy/set the "
"audio data directly to the external hardware buffer, or 2) make an "
"intermediate buffer and copy/set the data from it to the external hardware "
"buffer in interrupts (or in tasklets, preferably)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3445
msgid ""
"The first case works fine if the external hardware buffer is large enough. "
"This method doesn't need any extra buffers and thus is more efficient. You "
"need to define the ``copy`` callback for the data transfer, in addition to "
"the ``fill_silence`` callback for playback. However, there is a drawback: it "
"cannot be mmapped. The examples are GUS's GF1 PCM or emu8000's wavetable PCM."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3452
msgid ""
"The second case allows for mmap on the buffer, although you have to handle "
"an interrupt or a tasklet to transfer the data from the intermediate buffer "
"to the hardware buffer. You can find an example in the vxpocket driver."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3457
msgid ""
"Another case is when the chip uses a PCI memory-map region for the buffer "
"instead of the host memory. In this case, mmap is available only on certain "
"architectures like the Intel one. In non-mmap mode, the data cannot be "
"transferred as in the normal way. Thus you need to define the ``copy`` and "
"``fill_silence`` callbacks as well, as in the cases above. Examples are "
"found in ``rme32.c`` and ``rme96.c``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3465
msgid ""
"The implementation of the ``copy`` and ``silence`` callbacks depends upon "
"whether the hardware supports interleaved or non-interleaved samples. The "
"``copy`` callback is defined like below, a bit differently depending on "
"whether the direction is playback or capture::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3478
msgid ""
"In the case of interleaved samples, the second argument (``channel``) is not "
"used. The third argument (``pos``) specifies the position in bytes."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3481
msgid ""
"The meaning of the fourth argument is different between playback and "
"capture. For playback, it holds the source data pointer, and for capture, "
"it's the destination data pointer."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3485
msgid "The last argument is the number of bytes to be copied."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3487
msgid ""
"What you have to do in this callback is again different between playback and "
"capture directions. In the playback case, you copy the given amount of data "
"(``count``) at the specified pointer (``src``) to the specified offset "
"(``pos``) in the hardware buffer. When coded like memcpy-like way, the copy "
"would look like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3495
msgid ""
"For the capture direction, you copy the given amount of data (``count``) at "
"the specified offset (``pos``) in the hardware buffer to the specified "
"pointer (``dst``)::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3501
msgid ""
"The given ``src`` or ``dst`` a struct iov_iter pointer containing the "
"pointer and the size.  Use the existing helpers to copy or access the data "
"as defined in ``linux/uio.h``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3505
msgid ""
"Careful readers might notice that these callbacks receive the arguments in "
"bytes, not in frames like other callbacks.  It's because this makes coding "
"easier like in the examples above, and also it makes it easier to unify both "
"the interleaved and non-interleaved cases, as explained below."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3511
msgid ""
"In the case of non-interleaved samples, the implementation will be a bit "
"more complicated.  The callback is called for each channel, passed in the "
"second argument, so in total it's called N times per transfer."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3515
msgid ""
"The meaning of the other arguments are almost the same as in the interleaved "
"case.  The callback is supposed to copy the data from/to the given user-"
"space buffer, but only for the given channel. For details, please check "
"``isa/gus/gus_pcm.c`` or ``pci/rme9652/rme9652.c`` as examples."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3521
msgid ""
"Usually for the playback, another callback ``fill_silence`` is defined.  "
"It's implemented in a similar way as the copy callbacks above::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3528
msgid ""
"The meanings of arguments are the same as in the ``copy`` callback, although "
"there is no buffer pointer argument. In the case of interleaved samples, the "
"channel argument has no meaning, as for the ``copy`` callback."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3533
msgid ""
"The role of the ``fill_silence`` callback is to set the given amount "
"(``count``) of silence data at the specified offset (``pos``) in the "
"hardware buffer. Suppose that the data format is signed (that is, the silent-"
"data is 0), and the implementation using a memset-like function would look "
"like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3541
msgid ""
"In the case of non-interleaved samples, again, the implementation becomes a "
"bit more complicated, as it's called N times per transfer for each channel. "
"See, for example, ``isa/gus/gus_pcm.c``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3546
msgid "Non-Contiguous Buffers"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3548
msgid ""
"If your hardware supports a page table as in emu10k1 or buffer descriptors "
"as in via82xx, you can use scatter-gather (SG) DMA. ALSA provides an "
"interface for handling SG-buffers. The API is provided in ``<sound/pcm.h>``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3553
msgid ""
"For creating the SG-buffer handler, call :c:func:"
"`snd_pcm_set_managed_buffer()` or :c:func:`snd_pcm_set_managed_buffer_all()` "
"with ``SNDRV_DMA_TYPE_DEV_SG`` in the PCM constructor like for other PCI pre-"
"allocations. You need to pass ``&pci->dev``, where pci is the struct pci_dev "
"pointer of the chip as well::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3563
msgid ""
"The ``struct snd_sg_buf`` instance is created as ``substream->dma_private`` "
"in turn. You can cast the pointer like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3568
msgid ""
"Then in the :c:func:`snd_pcm_lib_malloc_pages()` call, the common SG-buffer "
"handler will allocate the non-contiguous kernel pages of the given size and "
"map them as virtually contiguous memory. The virtual pointer is addressed "
"via runtime->dma_area. The physical address (``runtime->dma_addr``) is set "
"to zero, because the buffer is physically non-contiguous. The physical "
"address table is set up in ``sgbuf->table``. You can get the physical "
"address at a certain offset via :c:func:`snd_pcm_sgbuf_get_addr()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3577
msgid ""
"If you need to release the SG-buffer data explicitly, call the standard API "
"function :c:func:`snd_pcm_lib_free_pages()` as usual."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3581
msgid "Vmalloc'ed Buffers"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3583
msgid ""
"It's possible to use a buffer allocated via :c:func:`vmalloc()`, for "
"example, for an intermediate buffer. You can simply allocate it via the "
"standard :c:func:`snd_pcm_lib_malloc_pages()` and co. after setting up the "
"buffer preallocation with ``SNDRV_DMA_TYPE_VMALLOC`` type::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3592
msgid ""
"NULL is passed as the device pointer argument, which indicates that default "
"pages (GFP_KERNEL and GFP_HIGHMEM) will be allocated."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3596
msgid ""
"Also, note that zero is passed as both the size and the max size argument "
"here.  Since each vmalloc call should succeed at any time, we don't need to "
"pre-allocate the buffers like other continuous pages."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3602
msgid "Proc Interface"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3604
msgid ""
"ALSA provides an easy interface for procfs. The proc files are very useful "
"for debugging. I recommend you set up proc files if you write a driver and "
"want to get a running status or register dumps. The API is found in ``<sound/"
"info.h>``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3609
msgid "To create a proc file, call :c:func:`snd_card_proc_new()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3614
msgid ""
"where the second argument specifies the name of the proc file to be created. "
"The above example will create a file ``my-file`` under the card directory, e."
"g. ``/proc/asound/card0/my-file``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3618
msgid ""
"Like other components, the proc entry created via :c:func:"
"`snd_card_proc_new()` will be registered and released automatically in the "
"card registration and release functions."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3622
msgid ""
"When the creation is successful, the function stores a new instance in the "
"pointer given in the third argument. It is initialized as a text proc file "
"for read only. To use this proc file as a read-only text file as-is, set the "
"read callback with private data via :c:func:`snd_info_set_text_ops()`::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3630
msgid ""
"where the second argument (``chip``) is the private data to be used in the "
"callback. The third parameter specifies the read buffer size and the fourth "
"(``my_proc_read``) is the callback function, which is defined like::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3638
msgid ""
"In the read callback, use :c:func:`snd_iprintf()` for output strings, which "
"works just like normal :c:func:`printf()`. For example::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3651
msgid ""
"The file permissions can be changed afterwards. By default, they are read "
"only for all users. If you want to add write permission for the user (root "
"by default), do as follows::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3657
msgid "and set the write buffer size and the callback::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3661
msgid ""
"In the write callback, you can use :c:func:`snd_info_get_line()` to get a "
"text line, and :c:func:`snd_info_get_str()` to retrieve a string from the "
"line. Some examples are found in ``core/oss/mixer_oss.c``, core/oss/and "
"``pcm_oss.c``."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3666
msgid "For a raw-data proc-file, set the attributes as follows::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3678
msgid ""
"For raw data, ``size`` field must be set properly. This specifies the "
"maximum size of the proc file access."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3681
msgid ""
"The read/write callbacks of raw mode are more direct than the text mode. You "
"need to use a low-level I/O functions such as :c:func:`copy_from_user()` "
"and :c:func:`copy_to_user()` to transfer the data::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3698
msgid ""
"If the size of the info entry has been set up properly, ``count`` and "
"``pos`` are guaranteed to fit within 0 and the given size. You don't have to "
"check the range in the callbacks unless any other condition is required."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3704
msgid "Power Management"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3706
msgid ""
"If the chip is supposed to work with suspend/resume functions, you need to "
"add power-management code to the driver. The additional code for power-"
"management should be ifdef-ed with ``CONFIG_PM``, or annotated with "
"__maybe_unused attribute; otherwise the compiler will complain."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3711
msgid ""
"If the driver *fully* supports suspend/resume that is, the device can be "
"properly resumed to its state when suspend was called, you can set the "
"``SNDRV_PCM_INFO_RESUME`` flag in the PCM info field. Usually, this is "
"possible when the registers of the chip can be safely saved and restored to "
"RAM. If this is set, the trigger callback is called with "
"``SNDRV_PCM_TRIGGER_RESUME`` after the resume callback completes."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3718
msgid ""
"Even if the driver doesn't support PM fully but partial suspend/resume is "
"still possible, it's still worthy to implement suspend/resume callbacks. In "
"such a case, applications would reset the status by calling :c:func:"
"`snd_pcm_prepare()` and restart the stream appropriately. Hence, you can "
"define suspend/resume callbacks below but don't set the "
"``SNDRV_PCM_INFO_RESUME`` info flag to the PCM."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3725
msgid ""
"Note that the trigger with SUSPEND can always be called when :c:func:"
"`snd_pcm_suspend_all()` is called, regardless of the "
"``SNDRV_PCM_INFO_RESUME`` flag. The ``RESUME`` flag affects only the "
"behavior of :c:func:`snd_pcm_resume()`. (Thus, in theory, "
"``SNDRV_PCM_TRIGGER_RESUME`` isn't needed to be handled in the trigger "
"callback when no ``SNDRV_PCM_INFO_RESUME`` flag is set. But, it's better to "
"keep it for compatibility reasons.)"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3733
msgid ""
"The driver needs to define the suspend/resume hooks according to the bus the "
"device is connected to. In the case of PCI drivers, the callbacks look like "
"below::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3748
msgid "The scheme of the real suspend job is as follows:"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3750
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3783
msgid "Retrieve the card and the chip data."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3752
msgid ""
"Call :c:func:`snd_power_change_state()` with ``SNDRV_CTL_POWER_D3hot`` to "
"change the power status."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3755
msgid ""
"If AC97 codecs are used, call :c:func:`snd_ac97_suspend()` for each codec."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3758
msgid "Save the register values if necessary."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3760
msgid "Stop the hardware if necessary."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3781
msgid "The scheme of the real resume job is as follows:"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3785
msgid "Re-initialize the chip."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3787
msgid "Restore the saved registers if necessary."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3789
msgid "Resume the mixer, e.g. by calling :c:func:`snd_ac97_resume()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3791
msgid "Restart the hardware (if any)."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3793
msgid ""
"Call :c:func:`snd_power_change_state()` with ``SNDRV_CTL_POWER_D0`` to "
"notify the processes."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3816
msgid ""
"Note that, at the time this callback gets called, the PCM stream has been "
"already suspended via its own PM ops calling :c:func:`snd_pcm_suspend_all()` "
"internally."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3820
msgid ""
"OK, we have all callbacks now. Let's set them up. In the initialization of "
"the card, make sure that you can get the chip data from the card instance, "
"typically via ``private_data`` field, in case you created the chip data "
"individually::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3842
msgid ""
"When you created the chip data with :c:func:`snd_card_new()`, it's anyway "
"accessible via ``private_data`` field::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3860
msgid ""
"If you need space to save the registers, allocate the buffer for it here, "
"too, since it would be fatal if you cannot allocate a memory in the suspend "
"phase. The allocated buffer should be released in the corresponding "
"destructor."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3865
msgid "And next, set suspend/resume callbacks to the pci_driver::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3880
msgid "Module Parameters"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3882
msgid ""
"There are standard module options for ALSA. At least, each module should "
"have the ``index``, ``id`` and ``enable`` options."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3885
msgid ""
"If the module supports multiple cards (usually up to 8 = ``SNDRV_CARDS`` "
"cards), they should be arrays. The default initial values are defined "
"already as constants for easier programming::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3893
msgid ""
"If the module supports only a single card, they could be single variables, "
"instead. ``enable`` option is not always necessary in this case, but it "
"would be better to have a dummy option for compatibility."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3897
msgid ""
"The module parameters must be declared with the standard ``module_param()``, "
"``module_param_array()`` and :c:func:`MODULE_PARM_DESC()` macros."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3901
msgid "Typical code would look as below::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3912
msgid ""
"Also, don't forget to define the module description and the license. "
"Especially, the recent modprobe requires to define the module license as "
"GPL, etc., otherwise the system is shown as “tainted”::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3921
msgid "Device-Managed Resources"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3923
msgid ""
"In the examples above, all resources are allocated and released manually.  "
"But human beings are lazy in nature, especially developers are lazier.  So "
"there are some ways to automate the release part; it's the (device-)managed "
"resources aka devres or devm family.  For example, an object allocated via :"
"c:func:`devm_kmalloc()` will be freed automatically at unbinding the device."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3930
msgid ""
"ALSA core provides also the device-managed helper, namely, :c:func:"
"`snd_devm_card_new()` for creating a card object. Call this functions "
"instead of the normal :c:func:`snd_card_new()`, and you can forget the "
"explicit :c:func:`snd_card_free()` call, as it's called automagically at "
"error and removal paths."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3936
msgid ""
"One caveat is that the call of :c:func:`snd_card_free()` would be put at the "
"beginning of the call chain only after you call :c:func:"
"`snd_card_register()`."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3940
msgid ""
"Also, the ``private_free`` callback is always called at the card free, so be "
"careful to put the hardware clean-up procedure in ``private_free`` "
"callback.  It might be called even before you actually set up at an earlier "
"error path.  For avoiding such an invalid initialization, you can set "
"``private_free`` callback after :c:func:`snd_card_register()` call succeeds."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3947
msgid ""
"Another thing to be remarked is that you should use device-managed helpers "
"for each component as much as possible once when you manage the card in that "
"way.  Mixing up with the normal and the managed resources may screw up the "
"release order."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3954
msgid "How To Put Your Driver Into ALSA Tree"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3959
msgid ""
"So far, you've learned how to write the driver codes. And you might have a "
"question now: how to put my own driver into the ALSA driver tree? Here "
"(finally :) the standard procedure is described briefly."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3963
msgid ""
"Suppose that you create a new PCI driver for the card “xyz”. The card module "
"name would be snd-xyz. The new driver is usually put into the alsa-driver "
"tree, ``sound/pci`` directory in the case of PCI cards."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3968
msgid ""
"In the following sections, the driver code is supposed to be put into Linux "
"kernel tree. The two cases are covered: a driver consisting of a single "
"source file and one consisting of several source files."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3973
msgid "Driver with A Single Source File"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3975
msgid "Modify sound/pci/Makefile"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3977
msgid "Suppose you have a file xyz.c. Add the following two lines::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3982
#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4025
msgid "Create the Kconfig entry"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3984
msgid "Add the new entry of Kconfig for your xyz driver::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:3995
msgid ""
"The line ``select SND_PCM`` specifies that the driver xyz supports PCM. In "
"addition to SND_PCM, the following components are supported for select "
"command: SND_RAWMIDI, SND_TIMER, SND_HWDEP, SND_MPU401_UART, SND_OPL3_LIB, "
"SND_OPL4_LIB, SND_VX_LIB, SND_AC97_CODEC. Add the select command for each "
"supported component."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4001
msgid ""
"Note that some selections imply the lowlevel selections. For example, PCM "
"includes TIMER, MPU401_UART includes RAWMIDI, AC97_CODEC includes PCM, and "
"OPL3_LIB includes HWDEP. You don't need to give the lowlevel selections "
"again."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4006
msgid "For the details of Kconfig script, refer to the kbuild documentation."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4009
msgid "Drivers with Several Source Files"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4011
msgid ""
"Suppose that the driver snd-xyz have several source files. They are located "
"in the new subdirectory, sound/pci/xyz."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4014
msgid ""
"Add a new directory (``sound/pci/xyz``) in ``sound/pci/Makefile`` as below::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4020
msgid "Under the directory ``sound/pci/xyz``, create a Makefile::"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4027
msgid "This procedure is as same as in the last section."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4031
msgid "Useful Functions"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4034
msgid ":c:func:`snd_BUG()`"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4036
msgid ""
"It shows the ``BUG?`` message and stack trace as well as :c:func:"
"`snd_BUG_ON()` at the point. It's useful to show that a fatal error happens "
"there."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4040
msgid "When no debug flag is set, this macro is ignored."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4043
msgid ":c:func:`snd_BUG_ON()`"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4045
msgid ""
":c:func:`snd_BUG_ON()` macro is similar with :c:func:`WARN_ON()` macro. For "
"example, snd_BUG_ON(!pointer); or it can be used as the condition, if "
"(snd_BUG_ON(non_zero_is_bug)) return -EINVAL;"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4050
msgid ""
"The macro takes an conditional expression to evaluate. When "
"``CONFIG_SND_DEBUG``, is set, if the expression is non-zero, it shows the "
"warning message such as ``BUG? (xxx)`` normally followed by stack trace. In "
"both cases it returns the evaluated value."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4056
msgid "Acknowledgments"
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4058
msgid ""
"I would like to thank Phil Kerr for his help for improvement and corrections "
"of this document."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4061
msgid "Kevin Conder reformatted the original plain-text to the DocBook format."
msgstr ""

#: ../../../sound/kernel-api/writing-an-alsa-driver.rst:4063
msgid ""
"Giuliano Pochini corrected typos and contributed the example codes in the "
"hardware constraints section."
msgstr ""
