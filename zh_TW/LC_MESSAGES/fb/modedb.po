# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../fb/modedb.rst:3
msgid "modedb default video mode support"
msgstr ""

#: ../../../fb/modedb.rst:6
msgid ""
"Currently all frame buffer device drivers have their own video mode "
"databases, which is a mess and a waste of resources. The main idea of modedb "
"is to have"
msgstr ""

#: ../../../fb/modedb.rst:9
msgid ""
"one routine to probe for video modes, which can be used by all frame buffer "
"devices"
msgstr ""

#: ../../../fb/modedb.rst:11
msgid ""
"one generic video mode database with a fair amount of standard videomodes "
"(taken from XFree86)"
msgstr ""

#: ../../../fb/modedb.rst:13
msgid ""
"the possibility to supply your own mode database for graphics hardware that "
"needs non-standard modes, like amifb and Mac frame buffer drivers (which use "
"macmodes.c)"
msgstr ""

#: ../../../fb/modedb.rst:17
msgid ""
"When a frame buffer device receives a video= option it doesn't know, it "
"should consider that to be a video mode option. If no frame buffer device is "
"specified in a video= option, fbmem considers that to be a global video mode "
"option."
msgstr ""

#: ../../../fb/modedb.rst:21
msgid "Valid mode specifiers (mode_option argument)::"
msgstr ""

#: ../../../fb/modedb.rst:26
msgid ""
"with <xres>, <yres>, <bpp> and <refresh> decimal numbers and <name> a "
"string. Things between square brackets are optional."
msgstr ""

#: ../../../fb/modedb.rst:29
msgid "Valid names are::"
msgstr ""

#: ../../../fb/modedb.rst:37
msgid ""
"If 'M' is specified in the mode_option argument (after <yres> and before "
"<bpp> and <refresh>, if specified) the timings will be calculated using "
"VESA(TM) Coordinated Video Timings instead of looking up the mode from a "
"table. If 'R' is specified, do a 'reduced blanking' calculation for digital "
"displays. If 'i' is specified, calculate for an interlaced mode.  And if 'm' "
"is specified, add margins to the calculation (1.8% of xres rounded down to 8 "
"pixels and 1.8% of yres)."
msgstr ""

#: ../../../fb/modedb.rst:45
msgid "Sample usage: 1024x768M@60m - CVT timing with margins"
msgstr ""

#: ../../../fb/modedb.rst:47
msgid "DRM drivers also add options to enable or disable outputs:"
msgstr ""

#: ../../../fb/modedb.rst:49
msgid ""
"'e' will force the display to be enabled, i.e. it will override the "
"detection if a display is connected. 'D' will force the display to be "
"enabled and use digital output. This is useful for outputs that have both "
"analog and digital signals (e.g. HDMI and DVI-I). For other outputs it "
"behaves like 'e'. If 'd' is specified the output is disabled."
msgstr ""

#: ../../../fb/modedb.rst:55
msgid ""
"You can additionally specify which output the options matches to. To force "
"the VGA output to be enabled and drive a specific mode say::"
msgstr ""

#: ../../../fb/modedb.rst:60
msgid ""
"Specifying the option multiple times for different ports is possible, e.g.::"
msgstr ""

#: ../../../fb/modedb.rst:64
msgid "Options can also be passed after the mode, using commas as separator."
msgstr ""

#: ../../../fb/modedb.rst:66
msgid "Sample usage: 720x480,rotate=180 - 720x480 mode, rotated by 180 degrees"
msgstr ""

#: ../../../fb/modedb.rst:68
msgid "Valid options are::"
msgstr ""

#: ../../../fb/modedb.rst:86
msgid "What is the VESA(TM) Coordinated Video Timings (CVT)?"
msgstr ""

#: ../../../fb/modedb.rst:88
msgid "From the VESA(TM) Website:"
msgstr ""

#: ../../../fb/modedb.rst:90
msgid "\"The purpose of CVT is to provide a method for generating a consistent"
msgstr ""

#: ../../../fb/modedb.rst:91
msgid ""
"and coordinated set of standard formats, display refresh rates, and timing "
"specifications for computer display products, both those employing CRTs, and "
"those using other display technologies. The intention of CVT is to give both "
"source and display manufacturers a common set of tools to enable new timings "
"to be developed in a consistent manner that ensures greater compatibility.\""
msgstr ""

#: ../../../fb/modedb.rst:98
msgid ""
"This is the third standard approved by VESA(TM) concerning video timings.  "
"The first was the Discrete Video Timings (DVT) which is  a collection of pre-"
"defined modes approved by VESA(TM).  The second is the Generalized Timing "
"Formula (GTF) which is an algorithm to calculate the timings, given the "
"pixelclock, the horizontal sync frequency, or the vertical refresh rate."
msgstr ""

#: ../../../fb/modedb.rst:104
msgid ""
"The GTF is limited by the fact that it is designed mainly for CRT displays. "
"It artificially increases the pixelclock because of its high blanking "
"requirement. This is inappropriate for digital display interface with its "
"high data rate which requires that it conserves the pixelclock as much as "
"possible. Also, GTF does not take into account the aspect ratio of the "
"display."
msgstr ""

#: ../../../fb/modedb.rst:110
msgid ""
"The CVT addresses these limitations.  If used with CRT's, the formula used "
"is a derivation of GTF with a few modifications.  If used with digital "
"displays, the \"reduced blanking\" calculation can be used."
msgstr ""

#: ../../../fb/modedb.rst:114
msgid ""
"From the framebuffer subsystem perspective, new formats need not be added to "
"the global mode database whenever a new mode is released by display "
"manufacturers. Specifying for CVT will work for most, if not all, relatively "
"new CRT displays and probably with most flatpanels, if 'reduced blanking' "
"calculation is specified.  (The CVT compatibility of the display can be "
"determined from its EDID. The version 1.3 of the EDID has extra 128-byte "
"blocks where additional timing information is placed.  As of this time, "
"there is no support yet in the layer to parse this additional blocks.)"
msgstr ""

#: ../../../fb/modedb.rst:123
msgid ""
"CVT also introduced a new naming convention (should be seen from dmesg "
"output)::"
msgstr ""

#: ../../../fb/modedb.rst:134
msgid "Note: VESA(TM) has restrictions on what is a standard CVT timing:"
msgstr ""

#: ../../../fb/modedb.rst:136
msgid "aspect ratio can only be one of the above values"
msgstr ""

#: ../../../fb/modedb.rst:137
msgid "acceptable refresh rates are 50, 60, 70 or 85 Hz only"
msgstr ""

#: ../../../fb/modedb.rst:138
msgid "if reduced blanking, the refresh rate must be at 60Hz"
msgstr ""

#: ../../../fb/modedb.rst:140
msgid ""
"If one of the above are not satisfied, the kernel will print a warning but "
"the timings will still be calculated."
msgstr ""

#: ../../../fb/modedb.rst:145
msgid "To find a suitable video mode, you just call::"
msgstr ""

#: ../../../fb/modedb.rst:153
msgid ""
"with db/dbsize your non-standard video mode database, or NULL to use the "
"standard video mode database."
msgstr ""

#: ../../../fb/modedb.rst:156
msgid ""
"fb_find_mode() first tries the specified video mode (or any mode that "
"matches, e.g. there can be multiple 640x480 modes, each of them is tried). "
"If that fails, the default mode is tried. If that fails, it walks over all "
"modes."
msgstr ""

#: ../../../fb/modedb.rst:160
msgid "To specify a video mode at bootup, use the following boot options::"
msgstr ""

#: ../../../fb/modedb.rst:164
msgid ""
"where <driver> is a name from the table below.  Valid default modes can be "
"found in drivers/video/fbdev/core/modedb.c.  Check your driver's "
"documentation. There may be more modes::"
msgstr ""

#: ../../../fb/modedb.rst:181
msgid ""
"BTW, only a few fb drivers use this at the moment. Others are to follow "
"(feel free to send patches). The DRM drivers also support this."
msgstr ""
