# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../fpga/dfl.rst:3
msgid "FPGA Device Feature List (DFL) Framework Overview"
msgstr ""

#: ../../../fpga/dfl.rst:5
msgid "Authors:"
msgstr ""

#: ../../../fpga/dfl.rst:7
msgid "Enno Luebbers <enno.luebbers@intel.com>"
msgstr ""

#: ../../../fpga/dfl.rst:8
msgid "Xiao Guangrong <guangrong.xiao@linux.intel.com>"
msgstr ""

#: ../../../fpga/dfl.rst:9
msgid "Wu Hao <hao.wu@intel.com>"
msgstr ""

#: ../../../fpga/dfl.rst:10
msgid "Xu Yilun <yilun.xu@intel.com>"
msgstr ""

#: ../../../fpga/dfl.rst:12
msgid ""
"The Device Feature List (DFL) FPGA framework (and drivers according to this "
"framework) hides the very details of low layer hardware and provides unified "
"interfaces to userspace. Applications could use these interfaces to "
"configure, enumerate, open and access FPGA accelerators on platforms which "
"implement the DFL in the device memory. Besides this, the DFL framework "
"enables system level management functions such as FPGA reconfiguration."
msgstr ""

#: ../../../fpga/dfl.rst:21
msgid "Device Feature List (DFL) Overview"
msgstr ""

#: ../../../fpga/dfl.rst:22
msgid ""
"Device Feature List (DFL) defines a linked list of feature headers within "
"the device MMIO space to provide an extensible way of adding features. "
"Software can walk through these predefined data structures to enumerate FPGA "
"features: FPGA Interface Unit (FIU), Accelerated Function Unit (AFU) and "
"Private Features, as illustrated below::"
msgstr ""

#: ../../../fpga/dfl.rst:56
msgid ""
"FPGA Interface Unit (FIU) represents a standalone functional unit for the "
"interface to FPGA, e.g. the FPGA Management Engine (FME) and Port (more "
"descriptions on FME and Port in later sections)."
msgstr ""

#: ../../../fpga/dfl.rst:60
msgid ""
"Accelerated Function Unit (AFU) represents an FPGA programmable region and "
"always connects to a FIU (e.g. a Port) as its child as illustrated above."
msgstr ""

#: ../../../fpga/dfl.rst:63
msgid ""
"Private Features represent sub features of the FIU and AFU. They could be "
"various function blocks with different IDs, but all private features which "
"belong to the same FIU or AFU, must be linked to one list via the Next "
"Device Feature Header (Next_DFH) pointer."
msgstr ""

#: ../../../fpga/dfl.rst:68
msgid ""
"Each FIU, AFU and Private Feature could implement its own functional "
"registers. The functional register set for FIU and AFU, is named as Header "
"Register Set, e.g. FME Header Register Set, and the one for Private Feature, "
"is named as Feature Register Set, e.g. FME Partial Reconfiguration Feature "
"Register Set."
msgstr ""

#: ../../../fpga/dfl.rst:73
msgid ""
"This Device Feature List provides a way of linking features together, it's "
"convenient for software to locate each feature by walking through this list, "
"and can be implemented in register regions of any FPGA device."
msgstr ""

#: ../../../fpga/dfl.rst:79
msgid "Device Feature Header - Version 0"
msgstr ""

#: ../../../fpga/dfl.rst:80
msgid ""
"Version 0 (DFHv0) is the original version of the Device Feature Header. All "
"multi-byte quantities in DFHv0 are little-endian. The format of DFHv0 is "
"shown below::"
msgstr ""

#: ../../../fpga/dfl.rst:92 ../../../fpga/dfl.rst:151
msgid "Offset 0x00"
msgstr ""

#: ../../../fpga/dfl.rst:94 ../../../fpga/dfl.rst:153
msgid "Type - The type of DFH (e.g. FME, AFU, or private feature)."
msgstr ""

#: ../../../fpga/dfl.rst:95 ../../../fpga/dfl.rst:154
msgid "DFH VER - The version of the DFH."
msgstr ""

#: ../../../fpga/dfl.rst:96 ../../../fpga/dfl.rst:155
msgid "Rsvd - Currently unused."
msgstr ""

#: ../../../fpga/dfl.rst:97 ../../../fpga/dfl.rst:156
msgid "EOL - Set if the DFH is the end of the Device Feature List (DFL)."
msgstr ""

#: ../../../fpga/dfl.rst:98 ../../../fpga/dfl.rst:157
msgid ""
"Next - The offset in bytes of the next DFH in the DFL from the DFH start, "
"and the start of a DFH must be aligned to an 8 byte boundary. If EOL is set, "
"Next is the size of MMIO of the last feature in the list."
msgstr ""

#: ../../../fpga/dfl.rst:101 ../../../fpga/dfl.rst:160
msgid "REV - The revision of the feature associated with this header."
msgstr ""

#: ../../../fpga/dfl.rst:102 ../../../fpga/dfl.rst:161
msgid "ID - The feature ID if Type is private feature."
msgstr ""

#: ../../../fpga/dfl.rst:104 ../../../fpga/dfl.rst:163
msgid "Offset 0x08"
msgstr ""

#: ../../../fpga/dfl.rst:106
msgid ""
"GUID_L - Least significant 64 bits of a 128-bit Globally Unique Identifier "
"(present only if Type is FME or AFU)."
msgstr ""

#: ../../../fpga/dfl.rst:109 ../../../fpga/dfl.rst:167
msgid "Offset 0x10"
msgstr ""

#: ../../../fpga/dfl.rst:111
msgid ""
"GUID_H - Most significant 64 bits of a 128-bit Globally Unique Identifier "
"(present only if Type is FME or AFU)."
msgstr ""

#: ../../../fpga/dfl.rst:116
msgid "Device Feature Header - Version 1"
msgstr ""

#: ../../../fpga/dfl.rst:117
msgid ""
"Version 1 (DFHv1) of the Device Feature Header adds the following "
"functionality:"
msgstr ""

#: ../../../fpga/dfl.rst:119
msgid ""
"Provides a standardized mechanism for features to describe parameters/"
"capabilities to software."
msgstr ""

#: ../../../fpga/dfl.rst:121
msgid "Standardize the use of a GUID for all DFHv1 types."
msgstr ""

#: ../../../fpga/dfl.rst:122
msgid ""
"Decouples the DFH location from the register space of the feature itself."
msgstr ""

#: ../../../fpga/dfl.rst:124
msgid ""
"All multi-byte quantities in DFHv1 are little-endian. The format of Version "
"1 of the Device Feature Header (DFH) is shown below::"
msgstr ""

#: ../../../fpga/dfl.rst:165
msgid ""
"GUID_L - Least significant 64 bits of a 128-bit Globally Unique Identifier."
msgstr ""

#: ../../../fpga/dfl.rst:169
msgid ""
"GUID_H - Most significant 64 bits of a 128-bit Globally Unique Identifier."
msgstr ""

#: ../../../fpga/dfl.rst:171
msgid "Offset 0x18"
msgstr ""

#: ../../../fpga/dfl.rst:173
msgid ""
"Reg Address/Offset - If Rel bit is set, then the value is the high 63 bits "
"of a 16-bit aligned absolute address of the feature's registers. Otherwise "
"the value is the offset from the start of the DFH of the feature's registers."
msgstr ""

#: ../../../fpga/dfl.rst:177
msgid "Offset 0x20"
msgstr ""

#: ../../../fpga/dfl.rst:179
msgid "Reg Size - Size of feature's register set in bytes."
msgstr ""

#: ../../../fpga/dfl.rst:180
msgid "Params - Set if DFH has a list of parameter blocks."
msgstr ""

#: ../../../fpga/dfl.rst:181
msgid "Group - Id of group if feature is part of a group."
msgstr ""

#: ../../../fpga/dfl.rst:182
msgid "Instance - Id of feature instance within a group."
msgstr ""

#: ../../../fpga/dfl.rst:184
msgid "Offset 0x28 if feature has parameters"
msgstr ""

#: ../../../fpga/dfl.rst:186
msgid ""
"Next - Offset to the next parameter block in 8 byte words. If EOP set, size "
"in 8 byte words of last parameter."
msgstr ""

#: ../../../fpga/dfl.rst:188
msgid "Param Version - Version of Param ID."
msgstr ""

#: ../../../fpga/dfl.rst:189
msgid "Param ID - ID of parameter."
msgstr ""

#: ../../../fpga/dfl.rst:191
msgid "Offset 0x30"
msgstr ""

#: ../../../fpga/dfl.rst:193
msgid ""
"Parameter Data - Parameter data whose size and format is defined by version "
"and ID of the parameter."
msgstr ""

#: ../../../fpga/dfl.rst:198
msgid "FIU - FME (FPGA Management Engine)"
msgstr ""

#: ../../../fpga/dfl.rst:199
msgid ""
"The FPGA Management Engine performs reconfiguration and other infrastructure "
"functions. Each FPGA device only has one FME."
msgstr ""

#: ../../../fpga/dfl.rst:202
msgid ""
"User-space applications can acquire exclusive access to the FME using "
"open(), and release it using close()."
msgstr ""

#: ../../../fpga/dfl.rst:205 ../../../fpga/dfl.rst:265
msgid "The following functions are exposed through ioctls:"
msgstr ""

#: ../../../fpga/dfl.rst:207 ../../../fpga/dfl.rst:267
msgid "Get driver API version (DFL_FPGA_GET_API_VERSION)"
msgstr ""

#: ../../../fpga/dfl.rst:208 ../../../fpga/dfl.rst:268
msgid "Check for extensions (DFL_FPGA_CHECK_EXTENSION)"
msgstr ""

#: ../../../fpga/dfl.rst:209
msgid "Program bitstream (DFL_FPGA_FME_PORT_PR)"
msgstr ""

#: ../../../fpga/dfl.rst:210
msgid "Assign port to PF (DFL_FPGA_FME_PORT_ASSIGN)"
msgstr ""

#: ../../../fpga/dfl.rst:211
msgid "Release port from PF (DFL_FPGA_FME_PORT_RELEASE)"
msgstr ""

#: ../../../fpga/dfl.rst:212
msgid "Get number of irqs of FME global error (DFL_FPGA_FME_ERR_GET_IRQ_NUM)"
msgstr ""

#: ../../../fpga/dfl.rst:213
msgid "Set interrupt trigger for FME error (DFL_FPGA_FME_ERR_SET_IRQ)"
msgstr ""

#: ../../../fpga/dfl.rst:215
msgid ""
"More functions are exposed through sysfs (/sys/class/fpga_region/regionX/dfl-"
"fme.n/):"
msgstr ""

#: ../../../fpga/dfl.rst:218
msgid "Read bitstream ID (bitstream_id)"
msgstr ""

#: ../../../fpga/dfl.rst:219
msgid "bitstream_id indicates version of the static FPGA region."
msgstr ""

#: ../../../fpga/dfl.rst:221
msgid "Read bitstream metadata (bitstream_metadata)"
msgstr ""

#: ../../../fpga/dfl.rst:222
msgid ""
"bitstream_metadata includes detailed information of static FPGA region, e.g. "
"synthesis date and seed."
msgstr ""

#: ../../../fpga/dfl.rst:225
msgid "Read number of ports (ports_num)"
msgstr ""

#: ../../../fpga/dfl.rst:226
msgid ""
"one FPGA device may have more than one port, this sysfs interface indicates "
"how many ports the FPGA device has."
msgstr ""

#: ../../../fpga/dfl.rst:229
msgid "Global error reporting management (errors/)"
msgstr ""

#: ../../../fpga/dfl.rst:230
msgid ""
"error reporting sysfs interfaces allow user to read errors detected by the "
"hardware, and clear the logged errors."
msgstr ""

#: ../../../fpga/dfl.rst:233
msgid "Power management (dfl_fme_power hwmon)"
msgstr ""

#: ../../../fpga/dfl.rst:234
msgid ""
"power management hwmon sysfs interfaces allow user to read power management "
"information (power consumption, thresholds, threshold status, limits, etc.) "
"and configure power thresholds for different throttling levels."
msgstr ""

#: ../../../fpga/dfl.rst:238
msgid "Thermal management (dfl_fme_thermal hwmon)"
msgstr ""

#: ../../../fpga/dfl.rst:239
msgid ""
"thermal management hwmon sysfs interfaces allow user to read thermal "
"management information (current temperature, thresholds, threshold status, "
"etc.)."
msgstr ""

#: ../../../fpga/dfl.rst:243
msgid "Performance reporting"
msgstr ""

#: ../../../fpga/dfl.rst:244
msgid ""
"performance counters are exposed through perf PMU APIs. Standard perf tool "
"can be used to monitor all available perf events. Please see performance "
"counter section below for more detailed information."
msgstr ""

#: ../../../fpga/dfl.rst:250
msgid "FIU - PORT"
msgstr ""

#: ../../../fpga/dfl.rst:251
msgid ""
"A port represents the interface between the static FPGA fabric and a "
"partially reconfigurable region containing an AFU. It controls the "
"communication from SW to the accelerator and exposes features such as reset "
"and debug. Each FPGA device may have more than one port, but always one AFU "
"per port."
msgstr ""

#: ../../../fpga/dfl.rst:258
msgid "AFU"
msgstr ""

#: ../../../fpga/dfl.rst:259
msgid ""
"An AFU is attached to a port FIU and exposes a fixed length MMIO region to "
"be used for accelerator-specific control registers."
msgstr ""

#: ../../../fpga/dfl.rst:262
msgid ""
"User-space applications can acquire exclusive access to an AFU attached to a "
"port by using open() on the port device node and release it using close()."
msgstr ""

#: ../../../fpga/dfl.rst:269
msgid "Get port info (DFL_FPGA_PORT_GET_INFO)"
msgstr ""

#: ../../../fpga/dfl.rst:270
msgid "Get MMIO region info (DFL_FPGA_PORT_GET_REGION_INFO)"
msgstr ""

#: ../../../fpga/dfl.rst:271
msgid "Map DMA buffer (DFL_FPGA_PORT_DMA_MAP)"
msgstr ""

#: ../../../fpga/dfl.rst:272
msgid "Unmap DMA buffer (DFL_FPGA_PORT_DMA_UNMAP)"
msgstr ""

#: ../../../fpga/dfl.rst:273
msgid "Reset AFU (DFL_FPGA_PORT_RESET)"
msgstr ""

#: ../../../fpga/dfl.rst:274
msgid "Get number of irqs of port error (DFL_FPGA_PORT_ERR_GET_IRQ_NUM)"
msgstr ""

#: ../../../fpga/dfl.rst:275
msgid "Set interrupt trigger for port error (DFL_FPGA_PORT_ERR_SET_IRQ)"
msgstr ""

#: ../../../fpga/dfl.rst:276
msgid "Get number of irqs of UINT (DFL_FPGA_PORT_UINT_GET_IRQ_NUM)"
msgstr ""

#: ../../../fpga/dfl.rst:277
msgid "Set interrupt trigger for UINT (DFL_FPGA_PORT_UINT_SET_IRQ)"
msgstr ""

#: ../../../fpga/dfl.rst:279
msgid "DFL_FPGA_PORT_RESET:"
msgstr ""

#: ../../../fpga/dfl.rst:280
msgid ""
"reset the FPGA Port and its AFU. Userspace can do Port reset at any time, e."
"g. during DMA or Partial Reconfiguration. But it should never cause any "
"system level issue, only functional failure (e.g. DMA or PR operation "
"failure) and be recoverable from the failure."
msgstr ""

#: ../../../fpga/dfl.rst:285
msgid "User-space applications can also mmap() accelerator MMIO regions."
msgstr ""

#: ../../../fpga/dfl.rst:287
msgid ""
"More functions are exposed through sysfs: (/sys/class/fpga_region/<regionX>/"
"<dfl-port.m>/):"
msgstr ""

#: ../../../fpga/dfl.rst:290
msgid "Read Accelerator GUID (afu_id)"
msgstr ""

#: ../../../fpga/dfl.rst:291
msgid "afu_id indicates which PR bitstream is programmed to this AFU."
msgstr ""

#: ../../../fpga/dfl.rst:293
msgid "Error reporting (errors/)"
msgstr ""

#: ../../../fpga/dfl.rst:294
msgid ""
"error reporting sysfs interfaces allow user to read port/afu errors detected "
"by the hardware, and clear the logged errors."
msgstr ""

#: ../../../fpga/dfl.rst:299
msgid "DFL Framework Overview"
msgstr ""

#: ../../../fpga/dfl.rst:320
msgid ""
"DFL framework in kernel provides common interfaces to create container "
"device (FPGA base region), discover feature devices and their private "
"features from the given Device Feature Lists and create platform devices for "
"feature devices (e.g. FME, Port and AFU) with related resources under the "
"container device. It also abstracts operations for the private features and "
"exposes common ops to feature device drivers."
msgstr ""

#: ../../../fpga/dfl.rst:327
msgid ""
"The FPGA DFL Device could be different hardware, e.g. PCIe device, platform "
"device and etc. Its driver module is always loaded first once the device is "
"created by the system. This driver plays an infrastructural role in the "
"driver architecture. It locates the DFLs in the device memory, handles them "
"and related resources to common interfaces from DFL framework for "
"enumeration. (Please refer to drivers/fpga/dfl.c for detailed enumeration "
"APIs)."
msgstr ""

#: ../../../fpga/dfl.rst:334
msgid ""
"The FPGA Management Engine (FME) driver is a platform driver which is loaded "
"automatically after FME platform device creation from the DFL device module. "
"It provides the key features for FPGA management, including:"
msgstr ""

#: ../../../fpga/dfl.rst:338
msgid ""
"Expose static FPGA region information, e.g. version and metadata. Users can "
"read related information via sysfs interfaces exposed by FME driver."
msgstr ""

#: ../../../fpga/dfl.rst:342
msgid ""
"Partial Reconfiguration. The FME driver creates FPGA manager, FPGA bridges "
"and FPGA regions during PR sub feature initialization. Once it receives a "
"DFL_FPGA_FME_PORT_PR ioctl from user, it invokes the common interface "
"function from FPGA Region to complete the partial reconfiguration of the PR "
"bitstream to the given port."
msgstr ""

#: ../../../fpga/dfl.rst:348
msgid ""
"Similar to the FME driver, the FPGA Accelerated Function Unit (AFU) driver "
"is probed once the AFU platform device is created. The main function of this "
"module is to provide an interface for userspace applications to access the "
"individual accelerators, including basic reset control on port, AFU MMIO "
"region export, dma buffer mapping service functions."
msgstr ""

#: ../../../fpga/dfl.rst:354
msgid ""
"After feature platform devices creation, matched platform drivers will be "
"loaded automatically to handle different functionalities. Please refer to "
"next sections for detailed information on functional units which have been "
"already implemented under this DFL framework."
msgstr ""

#: ../../../fpga/dfl.rst:361
msgid "Partial Reconfiguration"
msgstr ""

#: ../../../fpga/dfl.rst:362
msgid ""
"As mentioned above, accelerators can be reconfigured through partial "
"reconfiguration of a PR bitstream file. The PR bitstream file must have been "
"generated for the exact static FPGA region and targeted reconfigurable "
"region (port) of the FPGA, otherwise, the reconfiguration operation will "
"fail and possibly cause system instability. This compatibility can be "
"checked by comparing the compatibility ID noted in the header of PR "
"bitstream file against the compat_id exposed by the target FPGA region. This "
"check is usually done by userspace before calling the reconfiguration IOCTL."
msgstr ""

#: ../../../fpga/dfl.rst:373
msgid "FPGA virtualization - PCIe SRIOV"
msgstr ""

#: ../../../fpga/dfl.rst:374
msgid ""
"This section describes the virtualization support on DFL based FPGA device "
"to enable accessing an accelerator from applications running in a virtual "
"machine (VM). This section only describes the PCIe based FPGA device with "
"SRIOV support."
msgstr ""

#: ../../../fpga/dfl.rst:378
msgid ""
"Features supported by the particular FPGA device are exposed through Device "
"Feature Lists, as illustrated below:"
msgstr ""

#: ../../../fpga/dfl.rst:402
msgid "FME is always accessed through the physical function (PF)."
msgstr ""

#: ../../../fpga/dfl.rst:404
msgid ""
"Ports (and related AFUs) are accessed via PF by default, but could be "
"exposed through virtual function (VF) devices via PCIe SRIOV. Each VF only "
"contains 1 Port and 1 AFU for isolation. Users could assign individual VFs "
"(accelerators) created via PCIe SRIOV interface, to virtual machines."
msgstr ""

#: ../../../fpga/dfl.rst:409
msgid "The driver organization in virtualization case is illustrated below: ::"
msgstr ""

#: ../../../fpga/dfl.rst:433
msgid ""
"FPGA PCIe device driver is always loaded first once an FPGA PCIe PF or VF "
"device is detected. It:"
msgstr ""

#: ../../../fpga/dfl.rst:436
msgid ""
"Finishes enumeration on both FPGA PCIe PF and VF device using common "
"interfaces from DFL framework."
msgstr ""

#: ../../../fpga/dfl.rst:438
msgid "Supports SRIOV."
msgstr ""

#: ../../../fpga/dfl.rst:440
msgid ""
"The FME device driver plays a management role in this driver architecture, "
"it provides ioctls to release Port from PF and assign Port to PF. After "
"release a port from PF, then it's safe to expose this port through a VF via "
"PCIe SRIOV sysfs interface."
msgstr ""

#: ../../../fpga/dfl.rst:445
msgid ""
"To enable accessing an accelerator from applications running in a VM, the "
"respective AFU's port needs to be assigned to a VF using the following steps:"
msgstr ""

#: ../../../fpga/dfl.rst:448
msgid ""
"The PF owns all AFU ports by default. Any port that needs to be reassigned "
"to a VF must first be released through the DFL_FPGA_FME_PORT_RELEASE ioctl "
"on the FME device."
msgstr ""

#: ../../../fpga/dfl.rst:452
msgid ""
"Once N ports are released from PF, then user can use command below to enable "
"SRIOV and VFs. Each VF owns only one Port with AFU."
msgstr ""

#: ../../../fpga/dfl.rst:459
msgid "Pass through the VFs to VMs"
msgstr ""

#: ../../../fpga/dfl.rst:461
msgid ""
"The AFU under VF is accessible from applications in VM (using the same "
"driver inside the VF)."
msgstr ""

#: ../../../fpga/dfl.rst:464
msgid ""
"Note that an FME can't be assigned to a VF, thus PR and other management "
"functions are only available via the PF."
msgstr ""

#: ../../../fpga/dfl.rst:468
msgid "Device enumeration"
msgstr ""

#: ../../../fpga/dfl.rst:469
msgid ""
"This section introduces how applications enumerate the fpga device from the "
"sysfs hierarchy under /sys/class/fpga_region."
msgstr ""

#: ../../../fpga/dfl.rst:472
msgid ""
"In the example below, two DFL based FPGA devices are installed in the host. "
"Each fpga device has one FME and two ports (AFUs)."
msgstr ""

#: ../../../fpga/dfl.rst:475
msgid "FPGA regions are created under /sys/class/fpga_region/::"
msgstr ""

#: ../../../fpga/dfl.rst:482
msgid ""
"Application needs to search each regionX folder, if feature device is found, "
"(e.g. \"dfl-port.n\" or \"dfl-fme.m\" is found), then it's the base fpga "
"region which represents the FPGA device."
msgstr ""

#: ../../../fpga/dfl.rst:486
msgid "Each base region has one FME and two ports (AFUs) as child devices::"
msgstr ""

#: ../../../fpga/dfl.rst:498
msgid "In general, the FME/AFU sysfs interfaces are named as follows::"
msgstr ""

#: ../../../fpga/dfl.rst:503
msgid ""
"with 'n' consecutively numbering all FMEs and 'm' consecutively numbering "
"all ports."
msgstr ""

#: ../../../fpga/dfl.rst:506
msgid "The device nodes used for ioctl() or mmap() can be referenced through::"
msgstr ""

#: ../../../fpga/dfl.rst:513
msgid "Performance Counters"
msgstr ""

#: ../../../fpga/dfl.rst:514
msgid ""
"Performance reporting is one private feature implemented in FME. It could "
"supports several independent, system-wide, device counter sets in hardware "
"to monitor and count for performance events, including \"basic\", \"cache\", "
"\"fabric\", \"vtd\" and \"vtd_sip\" counters. Users could use standard perf "
"tool to monitor FPGA cache hit/miss rate, transaction number, interface "
"clock counter of AFU and other FPGA performance events."
msgstr ""

#: ../../../fpga/dfl.rst:521
msgid ""
"Different FPGA devices may have different counter sets, depending on "
"hardware implementation. E.g., some discrete FPGA cards don't have any "
"cache. User could use \"perf list\" to check which perf events are supported "
"by target hardware."
msgstr ""

#: ../../../fpga/dfl.rst:525
msgid ""
"In order to allow user to use standard perf API to access these performance "
"counters, driver creates a perf PMU, and related sysfs interfaces in /sys/"
"bus/event_source/devices/dfl_fme* to describe available perf events and "
"configuration options."
msgstr ""

#: ../../../fpga/dfl.rst:530
msgid ""
"The \"format\" directory describes the format of the config field of struct "
"perf_event_attr. There are 3 bitfields for config: \"evtype\" defines which "
"type the perf event belongs to; \"event\" is the identity of the event "
"within its category; \"portid\" is introduced to decide counters set to "
"monitor on FPGA overall data or a specific port."
msgstr ""

#: ../../../fpga/dfl.rst:536
msgid ""
"The \"events\" directory describes the configuration templates for all "
"available events which can be used with perf tool directly. For example, "
"fab_mmio_read has the configuration \"event=0x06,evtype=0x02,portid=0xff\", "
"which shows this event belongs to fabric type (0x02), the local event id is "
"0x06 and it is for overall monitoring (portid=0xff)."
msgstr ""

#: ../../../fpga/dfl.rst:542
msgid "Example usage of perf::"
msgstr ""

#: ../../../fpga/dfl.rst:557
msgid ""
"Another example, fab_port_mmio_read monitors mmio read of a specific port. "
"So its configuration template is \"event=0x06,evtype=0x01,portid=?\". The "
"portid should be explicitly set."
msgstr ""

#: ../../../fpga/dfl.rst:561
msgid "Its usage of perf::"
msgstr ""

#: ../../../fpga/dfl.rst:569
msgid ""
"Please note for fabric counters, overall perf events (fab_*) and port perf "
"events (fab_port_*) actually share one set of counters in hardware, so it "
"can't monitor both at the same time. If this set of counters is configured "
"to monitor overall data, then per port perf data is not supported. See below "
"example::"
msgstr ""

#: ../../../fpga/dfl.rst:584
msgid ""
"The driver also provides a \"cpumask\" sysfs attribute, which contains only "
"one CPU id used to access these perf events. Counting on multiple CPU is not "
"allowed since they are system-wide counters on FPGA device."
msgstr ""

#: ../../../fpga/dfl.rst:588
msgid ""
"The current driver does not support sampling. So \"perf record\" is "
"unsupported."
msgstr ""

#: ../../../fpga/dfl.rst:592
msgid "Interrupt support"
msgstr ""

#: ../../../fpga/dfl.rst:593
msgid ""
"Some FME and AFU private features are able to generate interrupts. As "
"mentioned above, users could call ioctl (DFL_FPGA_*_GET_IRQ_NUM) to know "
"whether or how many interrupts are supported for this private feature. "
"Drivers also implement an eventfd based interrupt handling mechanism for "
"users to get notified when interrupt happens. Users could set eventfds to "
"driver via ioctl (DFL_FPGA_*_SET_IRQ), and then poll/select on these "
"eventfds waiting for notification. In Current DFL, 3 sub features (Port "
"error, FME global error and AFU interrupt) support interrupts."
msgstr ""

#: ../../../fpga/dfl.rst:605
msgid "Add new FIUs support"
msgstr ""

#: ../../../fpga/dfl.rst:606
msgid ""
"It's possible that developers made some new function blocks (FIUs) under "
"this DFL framework, then new platform device driver needs to be developed "
"for the new feature dev (FIU) following the same way as existing feature dev "
"drivers (e.g. FME and Port/AFU platform device driver). Besides that, it "
"requires modification on DFL framework enumeration code too, for new FIU "
"type detection and related platform devices creation."
msgstr ""

#: ../../../fpga/dfl.rst:615
msgid "Add new private features support"
msgstr ""

#: ../../../fpga/dfl.rst:616
msgid ""
"In some cases, we may need to add some new private features to existing FIUs "
"(e.g. FME or Port). Developers don't need to touch enumeration code in DFL "
"framework, as each private feature will be parsed automatically and related "
"mmio resources can be found under FIU platform device created by DFL "
"framework. Developer only needs to provide a sub feature driver with matched "
"feature id. FME Partial Reconfiguration Sub Feature driver (see drivers/fpga/"
"dfl-fme-pr.c) could be a reference."
msgstr ""

#: ../../../fpga/dfl.rst:624
msgid ""
"Please refer to below link to existing feature id table and guide for new "
"feature ids application. https://github.com/OPAE/dfl-feature-id"
msgstr ""

#: ../../../fpga/dfl.rst:630
msgid "Location of DFLs on a PCI Device"
msgstr ""

#: ../../../fpga/dfl.rst:631
msgid ""
"The original method for finding a DFL on a PCI device assumed the start of "
"the first DFL to offset 0 of bar 0.  If the first node of the DFL is an FME, "
"then further DFLs in the port(s) are specified in FME header registers. "
"Alternatively, a PCIe vendor specific capability structure can be used to "
"specify the location of all the DFLs on the device, providing flexibility "
"for the type of starting node in the DFL.  Intel has reserved the VSEC ID of "
"0x43 for this purpose.  The vendor specific data begins with a 4 byte vendor "
"specific register for the number of DFLs followed 4 byte Offset/BIR vendor "
"specific registers for each DFL. Bits 2:0 of Offset/BIR register indicates "
"the BAR, and bits 31:3 form the 8 byte aligned offset where bits 2:0 are "
"zero. ::"
msgstr ""

#: ../../../fpga/dfl.rst:654
msgid ""
"Being able to specify more than one DFL per BAR has been considered, but it "
"was determined the use case did not provide value.  Specifying a single DFL "
"per BAR simplifies the implementation and allows for extra error checking."
msgstr ""

#: ../../../fpga/dfl.rst:660
msgid "Userspace driver support for DFL devices"
msgstr ""

#: ../../../fpga/dfl.rst:661
msgid ""
"The purpose of an FPGA is to be reprogrammed with newly developed hardware "
"components. New hardware can instantiate a new private feature in the DFL, "
"and then present a DFL device in the system. In some cases users may need a "
"userspace driver for the DFL device:"
msgstr ""

#: ../../../fpga/dfl.rst:666
msgid "Users may need to run some diagnostic test for their hardware."
msgstr ""

#: ../../../fpga/dfl.rst:667
msgid "Users may prototype the kernel driver in user space."
msgstr ""

#: ../../../fpga/dfl.rst:668
msgid ""
"Some hardware is designed for specific purposes and does not fit into one of "
"the standard kernel subsystems."
msgstr ""

#: ../../../fpga/dfl.rst:671
msgid ""
"This requires direct access to MMIO space and interrupt handling from "
"userspace. The uio_dfl module exposes the UIO device interfaces for this "
"purpose."
msgstr ""

#: ../../../fpga/dfl.rst:675
msgid ""
"Currently the uio_dfl driver only supports the Ether Group sub feature, "
"which has no irq in hardware. So the interrupt handling is not added in this "
"driver."
msgstr ""

#: ../../../fpga/dfl.rst:678
msgid ""
"UIO_DFL should be selected to enable the uio_dfl module driver. To support a "
"new DFL feature via UIO direct access, its feature id should be added to the "
"driver's id_table."
msgstr ""

#: ../../../fpga/dfl.rst:684
msgid "Open discussion"
msgstr ""

#: ../../../fpga/dfl.rst:685
msgid ""
"FME driver exports one ioctl (DFL_FPGA_FME_PORT_PR) for partial "
"reconfiguration to user now. In the future, if unified user interfaces for "
"reconfiguration are added, FME driver should switch to them from ioctl "
"interface."
msgstr ""
