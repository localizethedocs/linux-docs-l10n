# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../staging/rpmsg.rst:3
msgid "Remote Processor Messaging (rpmsg) Framework"
msgstr ""

#: ../../../staging/rpmsg.rst:7
msgid ""
"This document describes the rpmsg bus and how to write rpmsg drivers. To "
"learn how to add rpmsg support for new platforms, check out remoteproc.txt "
"(also a resident of Documentation/)."
msgstr ""

#: ../../../staging/rpmsg.rst:12
msgid "Introduction"
msgstr ""

#: ../../../staging/rpmsg.rst:14
msgid ""
"Modern SoCs typically employ heterogeneous remote processor devices in "
"asymmetric multiprocessing (AMP) configurations, which may be running "
"different instances of operating system, whether it's Linux or any other "
"flavor of real-time OS."
msgstr ""

#: ../../../staging/rpmsg.rst:19
msgid ""
"OMAP4, for example, has dual Cortex-A9, dual Cortex-M3 and a C64x+ DSP. "
"Typically, the dual cortex-A9 is running Linux in a SMP configuration, and "
"each of the other three cores (two M3 cores and a DSP) is running its own "
"instance of RTOS in an AMP configuration."
msgstr ""

#: ../../../staging/rpmsg.rst:24
msgid ""
"Typically AMP remote processors employ dedicated DSP codecs and multimedia "
"hardware accelerators, and therefore are often used to offload CPU-intensive "
"multimedia tasks from the main application processor."
msgstr ""

#: ../../../staging/rpmsg.rst:28
msgid ""
"These remote processors could also be used to control latency-sensitive "
"sensors, drive random hardware blocks, or just perform background tasks "
"while the main CPU is idling."
msgstr ""

#: ../../../staging/rpmsg.rst:32
msgid ""
"Users of those remote processors can either be userland apps (e.g. "
"multimedia frameworks talking with remote OMX components) or kernel drivers "
"(controlling hardware accessible only by the remote processor, reserving "
"kernel-controlled resources on behalf of the remote processor, etc..)."
msgstr ""

#: ../../../staging/rpmsg.rst:37
msgid ""
"Rpmsg is a virtio-based messaging bus that allows kernel drivers to "
"communicate with remote processors available on the system. In turn, drivers "
"could then expose appropriate user space interfaces, if needed."
msgstr ""

#: ../../../staging/rpmsg.rst:41
msgid ""
"When writing a driver that exposes rpmsg communication to userland, please "
"keep in mind that remote processors might have direct access to the system's "
"physical memory and other sensitive hardware resources (e.g. on OMAP4, "
"remote cores and hardware accelerators may have direct access to the "
"physical memory, gpio banks, dma controllers, i2c bus, gptimers, mailbox "
"devices, hwspinlocks, etc..). Moreover, those remote processors might be "
"running RTOS where every task can access the entire memory/devices exposed "
"to the processor. To minimize the risks of rogue (or buggy) userland code "
"exploiting remote bugs, and by that taking over the system, it is often "
"desired to limit userland to specific rpmsg channels (see definition below) "
"it can send messages on, and if possible, minimize how much control it has "
"over the content of the messages."
msgstr ""

#: ../../../staging/rpmsg.rst:54
msgid ""
"Every rpmsg device is a communication channel with a remote processor (thus "
"rpmsg devices are called channels). Channels are identified by a textual "
"name and have a local (\"source\") rpmsg address, and remote "
"(\"destination\") rpmsg address."
msgstr ""

#: ../../../staging/rpmsg.rst:59
msgid ""
"When a driver starts listening on a channel, its rx callback is bound with a "
"unique rpmsg local address (a 32-bit integer). This way when inbound "
"messages arrive, the rpmsg core dispatches them to the appropriate driver "
"according to their destination address (this is done by invoking the "
"driver's rx handler with the payload of the inbound message)."
msgstr ""

#: ../../../staging/rpmsg.rst:67
msgid "User API"
msgstr ""

#: ../../../staging/rpmsg.rst:73
msgid ""
"sends a message across to the remote processor from the given endpoint. The "
"caller should specify the endpoint, the data it wants to send, and its "
"length (in bytes). The message will be sent on the specified endpoint's "
"channel, i.e. its source and destination address fields will be respectively "
"set to the endpoint's src address and its parent channel dst addresses."
msgstr ""

#: ../../../staging/rpmsg.rst:80 ../../../staging/rpmsg.rst:104
msgid ""
"In case there are no TX buffers available, the function will block until one "
"becomes available (i.e. until the remote processor consumes a tx buffer and "
"puts it back on virtio's used descriptor ring), or a timeout of 15 seconds "
"elapses. When the latter happens, -ERESTARTSYS is returned."
msgstr ""

#: ../../../staging/rpmsg.rst:86 ../../../staging/rpmsg.rst:110
#: ../../../staging/rpmsg.rst:127 ../../../staging/rpmsg.rst:148
msgid ""
"The function can only be called from a process context (for now). Returns 0 "
"on success and an appropriate error value on failure."
msgstr ""

#: ../../../staging/rpmsg.rst:93
msgid ""
"sends a message across to the remote processor from a given endpoint, to a "
"destination address provided by the caller."
msgstr ""

#: ../../../staging/rpmsg.rst:96
msgid ""
"The caller should specify the endpoint, the data it wants to send, its "
"length (in bytes), and an explicit destination address."
msgstr ""

#: ../../../staging/rpmsg.rst:99
msgid ""
"The message will then be sent to the remote processor to which the "
"endpoints's channel belongs, using the endpoints's src address, and the user-"
"provided dst address (thus the channel's dst address will be ignored)."
msgstr ""

#: ../../../staging/rpmsg.rst:117
msgid ""
"sends a message across to the remote processor from a given endpoint. The "
"caller should specify the endpoint, the data it wants to send, and its "
"length (in bytes). The message will be sent on the specified endpoint's "
"channel, i.e. its source and destination address fields will be respectively "
"set to the endpoint's src address and its parent channel dst addresses."
msgstr ""

#: ../../../staging/rpmsg.rst:124 ../../../staging/rpmsg.rst:145
msgid ""
"In case there are no TX buffers available, the function will immediately "
"return -ENOMEM without waiting until one becomes available."
msgstr ""

#: ../../../staging/rpmsg.rst:135
msgid ""
"sends a message across to the remote processor from a given endpoint, to a "
"destination address provided by the user."
msgstr ""

#: ../../../staging/rpmsg.rst:138
msgid ""
"The user should specify the channel, the data it wants to send, its length "
"(in bytes), and an explicit destination address."
msgstr ""

#: ../../../staging/rpmsg.rst:141
msgid ""
"The message will then be sent to the remote processor to which the channel "
"belongs, using the channel's src address, and the user-provided dst address "
"(thus the channel's dst address will be ignored)."
msgstr ""

#: ../../../staging/rpmsg.rst:157
msgid ""
"every rpmsg address in the system is bound to an rx callback (so when "
"inbound messages arrive, they are dispatched by the rpmsg bus using the "
"appropriate callback handler) by means of an rpmsg_endpoint struct."
msgstr ""

#: ../../../staging/rpmsg.rst:161
msgid ""
"This function allows drivers to create such an endpoint, and by that, bind a "
"callback, and possibly some private data too, to an rpmsg address (either "
"one that is known in advance, or one that will be dynamically assigned for "
"them)."
msgstr ""

#: ../../../staging/rpmsg.rst:166
msgid ""
"Simple rpmsg drivers need not call rpmsg_create_ept, because an endpoint is "
"already created for them when they are probed by the rpmsg bus (using the rx "
"callback they provide when they registered to the rpmsg bus)."
msgstr ""

#: ../../../staging/rpmsg.rst:170
msgid ""
"So things should just work for simple drivers: they already have an "
"endpoint, their rx callback is bound to their rpmsg address, and when "
"relevant inbound messages arrive (i.e. messages which their dst address "
"equals to the src address of their rpmsg channel), the driver's handler is "
"invoked to process it."
msgstr ""

#: ../../../staging/rpmsg.rst:176
msgid ""
"That said, more complicated drivers might do need to allocate additional "
"rpmsg addresses, and bind them to different rx callbacks. To accomplish "
"that, those drivers need to call this function. Drivers should provide their "
"channel (so the new endpoint would bind to the same remote processor their "
"channel belongs to), an rx callback function, an optional private data "
"(which is provided back when the rx callback is invoked), and an address "
"they want to bind with the callback. If addr is RPMSG_ADDR_ANY, then "
"rpmsg_create_ept will dynamically assign them an available rpmsg address "
"(drivers should have a very good reason why not to always use RPMSG_ADDR_ANY "
"here)."
msgstr ""

#: ../../../staging/rpmsg.rst:187
msgid "Returns a pointer to the endpoint on success, or NULL on error."
msgstr ""

#: ../../../staging/rpmsg.rst:194
msgid ""
"destroys an existing rpmsg endpoint. user should provide a pointer to an "
"rpmsg endpoint that was previously created with rpmsg_create_ept()."
msgstr ""

#: ../../../staging/rpmsg.rst:202
msgid ""
"registers an rpmsg driver with the rpmsg bus. user should provide a pointer "
"to an rpmsg_driver struct, which contains the driver's ->probe() and -"
">remove() functions, an rx callback, and an id_table specifying the names of "
"the channels this driver is interested to be probed with."
msgstr ""

#: ../../../staging/rpmsg.rst:213
msgid ""
"unregisters an rpmsg driver from the rpmsg bus. user should provide a "
"pointer to a previously-registered rpmsg_driver struct. Returns 0 on "
"success, and an appropriate error value on failure."
msgstr ""

#: ../../../staging/rpmsg.rst:219
msgid "Typical usage"
msgstr ""

#: ../../../staging/rpmsg.rst:221
msgid ""
"The following is a simple rpmsg driver, that sends an \"hello!\" message on "
"probe(), and whenever it receives an incoming message, it dumps its content "
"to the console."
msgstr ""

#: ../../../staging/rpmsg.rst:276
msgid ""
"a similar sample which can be built and loaded can be found in samples/"
"rpmsg/."
msgstr ""

#: ../../../staging/rpmsg.rst:280
msgid "Allocations of rpmsg channels"
msgstr ""

#: ../../../staging/rpmsg.rst:282
msgid "At this point we only support dynamic allocations of rpmsg channels."
msgstr ""

#: ../../../staging/rpmsg.rst:284
msgid ""
"This is possible only with remote processors that have the VIRTIO_RPMSG_F_NS "
"virtio device feature set. This feature bit means that the remote processor "
"supports dynamic name service announcement messages."
msgstr ""

#: ../../../staging/rpmsg.rst:288
msgid ""
"When this feature is enabled, creation of rpmsg devices (i.e. channels) is "
"completely dynamic: the remote processor announces the existence of a remote "
"rpmsg service by sending a name service message (which contains the name and "
"rpmsg addr of the remote service, see struct rpmsg_ns_msg)."
msgstr ""

#: ../../../staging/rpmsg.rst:293
msgid ""
"This message is then handled by the rpmsg bus, which in turn dynamically "
"creates and registers an rpmsg channel (which represents the remote "
"service). If/when a relevant rpmsg driver is registered, it will be "
"immediately probed by the bus, and can then start sending messages to the "
"remote service."
msgstr ""

#: ../../../staging/rpmsg.rst:298
msgid ""
"The plan is also to add static creation of rpmsg channels via the virtio "
"config space, but it's not implemented yet."
msgstr ""
