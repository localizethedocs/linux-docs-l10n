# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/map_sockmap.rst:6
msgid "BPF_MAP_TYPE_SOCKMAP and BPF_MAP_TYPE_SOCKHASH"
msgstr ""

#: ../../../bpf/map_sockmap.rst:9
msgid "``BPF_MAP_TYPE_SOCKMAP`` was introduced in kernel version 4.14"
msgstr ""

#: ../../../bpf/map_sockmap.rst:10
msgid "``BPF_MAP_TYPE_SOCKHASH`` was introduced in kernel version 4.18"
msgstr ""

#: ../../../bpf/map_sockmap.rst:12
msgid ""
"``BPF_MAP_TYPE_SOCKMAP`` and ``BPF_MAP_TYPE_SOCKHASH`` maps can be used to "
"redirect skbs between sockets or to apply policy at the socket level based "
"on the result of a BPF (verdict) program with the help of the BPF helpers "
"``bpf_sk_redirect_map()``, ``bpf_sk_redirect_hash()``, "
"``bpf_msg_redirect_map()`` and ``bpf_msg_redirect_hash()``."
msgstr ""

#: ../../../bpf/map_sockmap.rst:18
msgid ""
"``BPF_MAP_TYPE_SOCKMAP`` is backed by an array that uses an integer key as "
"the index to look up a reference to a ``struct sock``. The map values are "
"socket descriptors. Similarly, ``BPF_MAP_TYPE_SOCKHASH`` is a hash backed "
"BPF map that holds references to sockets via their socket descriptors."
msgstr ""

#: ../../../bpf/map_sockmap.rst:24
msgid ""
"The value type is either __u32 or __u64; the latter (__u64) is to support "
"returning socket cookies to userspace. Returning the ``struct sock *`` that "
"the map holds to user-space is neither safe nor useful."
msgstr ""

#: ../../../bpf/map_sockmap.rst:28
msgid ""
"These maps may have BPF programs attached to them, specifically a parser "
"program and a verdict program. The parser program determines how much data "
"has been parsed and therefore how much data needs to be queued to come to a "
"verdict. The verdict program is essentially the redirect program and can "
"return a verdict of ``__SK_DROP``, ``__SK_PASS``, or ``__SK_REDIRECT``."
msgstr ""

#: ../../../bpf/map_sockmap.rst:34
msgid ""
"When a socket is inserted into one of these maps, its socket callbacks are "
"replaced and a ``struct sk_psock`` is attached to it. Additionally, this "
"``sk_psock`` inherits the programs that are attached to the map."
msgstr ""

#: ../../../bpf/map_sockmap.rst:38
msgid ""
"A sock object may be in multiple maps, but can only inherit a single parse "
"or verdict program. If adding a sock object to a map would result in having "
"multiple parser programs the update will return an EBUSY error."
msgstr ""

#: ../../../bpf/map_sockmap.rst:42
msgid "The supported programs to attach to these maps are:"
msgstr ""

#: ../../../bpf/map_sockmap.rst:54
msgid ""
"Users are not allowed to attach ``stream_verdict`` and ``skb_verdict`` "
"programs to the same map."
msgstr ""

#: ../../../bpf/map_sockmap.rst:57
msgid "The attach types for the map programs are:"
msgstr ""

#: ../../../bpf/map_sockmap.rst:59
msgid "``msg_parser`` program - ``BPF_SK_MSG_VERDICT``."
msgstr ""

#: ../../../bpf/map_sockmap.rst:60
msgid "``stream_parser`` program - ``BPF_SK_SKB_STREAM_PARSER``."
msgstr ""

#: ../../../bpf/map_sockmap.rst:61
msgid "``stream_verdict`` program - ``BPF_SK_SKB_STREAM_VERDICT``."
msgstr ""

#: ../../../bpf/map_sockmap.rst:62
msgid "``skb_verdict`` program - ``BPF_SK_SKB_VERDICT``."
msgstr ""

#: ../../../bpf/map_sockmap.rst:64
msgid ""
"There are additional helpers available to use with the parser and verdict "
"programs: ``bpf_msg_apply_bytes()`` and ``bpf_msg_cork_bytes()``. With "
"``bpf_msg_apply_bytes()`` BPF programs can tell the infrastructure how many "
"bytes the given verdict should apply to. The helper ``bpf_msg_cork_bytes()`` "
"handles a different case where a BPF program cannot reach a verdict on a msg "
"until it receives more bytes AND the program doesn't want to forward the "
"packet until it is known to be good."
msgstr ""

#: ../../../bpf/map_sockmap.rst:72
msgid ""
"Finally, the helpers ``bpf_msg_pull_data()`` and ``bpf_msg_push_data()`` are "
"available to ``BPF_PROG_TYPE_SK_MSG`` BPF programs to pull in data and set "
"the start and end pointers to given values or to add metadata to the "
"``struct sk_msg_buff *msg``."
msgstr ""

#: ../../../bpf/map_sockmap.rst:77
msgid "All these helpers will be described in more detail below."
msgstr ""

#: ../../../bpf/map_sockmap.rst:80
msgid "Usage"
msgstr ""

#: ../../../bpf/map_sockmap.rst:82 ../../../bpf/map_sockmap.rst:345
msgid "Kernel BPF"
msgstr ""

#: ../../../bpf/map_sockmap.rst:84
msgid "bpf_msg_redirect_map()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:89
msgid ""
"This helper is used in programs implementing policies at the socket level. "
"If the message ``msg`` is allowed to pass (i.e., if the verdict BPF program "
"returns ``SK_PASS``), redirect it to the socket referenced by ``map`` (of "
"type ``BPF_MAP_TYPE_SOCKMAP``) at index ``key``. Both ingress and egress "
"interfaces can be used for redirection. The ``BPF_F_INGRESS`` value in "
"``flags`` is used to select the ingress path otherwise the egress path is "
"selected. This is the only flag supported for now."
msgstr ""

#: ../../../bpf/map_sockmap.rst:97 ../../../bpf/map_sockmap.rst:111
#: ../../../bpf/map_sockmap.rst:177 ../../../bpf/map_sockmap.rst:193
msgid "Returns ``SK_PASS`` on success, or ``SK_DROP`` on error."
msgstr ""

#: ../../../bpf/map_sockmap.rst:100
msgid "bpf_sk_redirect_map()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:105
msgid ""
"Redirect the packet to the socket referenced by ``map`` (of type "
"``BPF_MAP_TYPE_SOCKMAP``) at index ``key``. Both ingress and egress "
"interfaces can be used for redirection. The ``BPF_F_INGRESS`` value in "
"``flags`` is used to select the ingress path otherwise the egress path is "
"selected. This is the only flag supported for now."
msgstr ""

#: ../../../bpf/map_sockmap.rst:114 ../../../bpf/map_sockmap.rst:262
#: ../../../bpf/map_sockmap.rst:320
msgid "bpf_map_lookup_elem()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:119
msgid ""
"socket entries of type ``struct sock *`` can be retrieved using the "
"``bpf_map_lookup_elem()`` helper."
msgstr ""

#: ../../../bpf/map_sockmap.rst:123
msgid "bpf_sock_map_update()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:128
msgid ""
"Add an entry to, or update a ``map`` referencing sockets. The ``skops`` is "
"used as a new value for the entry associated to ``key``. The ``flags`` "
"argument can be one of the following:"
msgstr ""

#: ../../../bpf/map_sockmap.rst:132 ../../../bpf/map_sockmap.rst:153
msgid "``BPF_ANY``: Create a new element or update an existing element."
msgstr ""

#: ../../../bpf/map_sockmap.rst:133 ../../../bpf/map_sockmap.rst:154
msgid "``BPF_NOEXIST``: Create a new element only if it did not exist."
msgstr ""

#: ../../../bpf/map_sockmap.rst:134 ../../../bpf/map_sockmap.rst:155
msgid "``BPF_EXIST``: Update an existing element."
msgstr ""

#: ../../../bpf/map_sockmap.rst:136 ../../../bpf/map_sockmap.rst:157
msgid ""
"If the ``map`` has BPF programs (parser and verdict), those will be "
"inherited by the socket being added. If the socket is already attached to "
"BPF programs, this results in an error."
msgstr ""

#: ../../../bpf/map_sockmap.rst:140 ../../../bpf/map_sockmap.rst:161
#: ../../../bpf/map_sockmap.rst:259 ../../../bpf/map_sockmap.rst:286
#: ../../../bpf/map_sockmap.rst:296
msgid "Returns 0 on success, or a negative error in case of failure."
msgstr ""

#: ../../../bpf/map_sockmap.rst:143
msgid "bpf_sock_hash_update()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:148
msgid ""
"Add an entry to, or update a sockhash ``map`` referencing sockets. The "
"``skops`` is used as a new value for the entry associated to ``key``."
msgstr ""

#: ../../../bpf/map_sockmap.rst:151
msgid "The ``flags`` argument can be one of the following:"
msgstr ""

#: ../../../bpf/map_sockmap.rst:164
msgid "bpf_msg_redirect_hash()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:169
msgid ""
"This helper is used in programs implementing policies at the socket level. "
"If the message ``msg`` is allowed to pass (i.e., if the verdict BPF program "
"returns ``SK_PASS``), redirect it to the socket referenced by ``map`` (of "
"type ``BPF_MAP_TYPE_SOCKHASH``) using hash ``key``. Both ingress and egress "
"interfaces can be used for redirection. The ``BPF_F_INGRESS`` value in "
"``flags`` is used to select the ingress path otherwise the egress path is "
"selected. This is the only flag supported for now."
msgstr ""

#: ../../../bpf/map_sockmap.rst:180
msgid "bpf_sk_redirect_hash()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:185
msgid ""
"This helper is used in programs implementing policies at the skb socket "
"level. If the sk_buff ``skb`` is allowed to pass (i.e., if the verdict BPF "
"program returns ``SK_PASS``), redirect it to the socket referenced by "
"``map`` (of type ``BPF_MAP_TYPE_SOCKHASH``) using hash ``key``. Both ingress "
"and egress interfaces can be used for redirection. The ``BPF_F_INGRESS`` "
"value in ``flags`` is used to select the ingress path otherwise the egress "
"path is selected. This is the only flag supported for now."
msgstr ""

#: ../../../bpf/map_sockmap.rst:196
msgid "bpf_msg_apply_bytes()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:201
msgid ""
"For socket policies, apply the verdict of the BPF program to the next "
"(number of ``bytes``) of message ``msg``. For example, this helper can be "
"used in the following cases:"
msgstr ""

#: ../../../bpf/map_sockmap.rst:205
msgid ""
"A single ``sendmsg()`` or ``sendfile()`` system call contains multiple "
"logical messages that the BPF program is supposed to read and for which it "
"should apply a verdict."
msgstr ""

#: ../../../bpf/map_sockmap.rst:208
msgid ""
"A BPF program only cares to read the first ``bytes`` of a ``msg``. If the "
"message has a large payload, then setting up and calling the BPF program "
"repeatedly for all bytes, even though the verdict is already known, would "
"create unnecessary overhead."
msgstr ""

#: ../../../bpf/map_sockmap.rst:213 ../../../bpf/map_sockmap.rst:228
msgid "Returns 0"
msgstr ""

#: ../../../bpf/map_sockmap.rst:216
msgid "bpf_msg_cork_bytes()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:221
msgid ""
"For socket policies, prevent the execution of the verdict BPF program for "
"message ``msg`` until the number of ``bytes`` have been accumulated."
msgstr ""

#: ../../../bpf/map_sockmap.rst:224
msgid ""
"This can be used when one needs a specific number of bytes before a verdict "
"can be assigned, even if the data spans multiple ``sendmsg()`` or "
"``sendfile()`` calls."
msgstr ""

#: ../../../bpf/map_sockmap.rst:231
msgid "bpf_msg_pull_data()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:236
msgid ""
"For socket policies, pull in non-linear data from user space for ``msg`` and "
"set pointers ``msg->data`` and ``msg->data_end`` to ``start`` and ``end`` "
"bytes offsets into ``msg``, respectively."
msgstr ""

#: ../../../bpf/map_sockmap.rst:240
msgid ""
"If a program of type ``BPF_PROG_TYPE_SK_MSG`` is run on a ``msg`` it can "
"only parse data that the (``data``, ``data_end``) pointers have already "
"consumed. For ``sendmsg()`` hooks this is likely the first scatterlist "
"element. But for calls relying on MSG_SPLICE_PAGES (e.g., ``sendfile()``) "
"this will be the range (**0**, **0**) because the data is shared with user "
"space and by default the objective is to avoid allowing user space to modify "
"data while (or after) BPF verdict is being decided. This helper can be used "
"to pull in data and to set the start and end pointers to given values. Data "
"will be copied if necessary (i.e., if data was not linear and if start and "
"end pointers do not point to the same chunk)."
msgstr ""

#: ../../../bpf/map_sockmap.rst:251
msgid ""
"A call to this helper is susceptible to change the underlying packet buffer. "
"Therefore, at load time, all checks on pointers previously done by the "
"verifier are invalidated and must be performed again, if the helper is used "
"in combination with direct packet access."
msgstr ""

#: ../../../bpf/map_sockmap.rst:256
msgid ""
"All values for ``flags`` are reserved for future usage, and must be left at "
"zero."
msgstr ""

#: ../../../bpf/map_sockmap.rst:268
msgid "Look up a socket entry in the sockmap or sockhash map."
msgstr ""

#: ../../../bpf/map_sockmap.rst:270
msgid ""
"Returns the socket entry associated to ``key``, or NULL if no entry was "
"found."
msgstr ""

#: ../../../bpf/map_sockmap.rst:273 ../../../bpf/map_sockmap.rst:301
msgid "bpf_map_update_elem()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:278
msgid "Add or update a socket entry in a sockmap or sockhash."
msgstr ""

#: ../../../bpf/map_sockmap.rst:280 ../../../bpf/map_sockmap.rst:313
msgid "The flags argument can be one of the following:"
msgstr ""

#: ../../../bpf/map_sockmap.rst:282 ../../../bpf/map_sockmap.rst:315
msgid "BPF_ANY: Create a new element or update an existing element."
msgstr ""

#: ../../../bpf/map_sockmap.rst:283 ../../../bpf/map_sockmap.rst:316
msgid "BPF_NOEXIST: Create a new element only if it did not exist."
msgstr ""

#: ../../../bpf/map_sockmap.rst:284 ../../../bpf/map_sockmap.rst:317
msgid "BPF_EXIST: Update an existing element."
msgstr ""

#: ../../../bpf/map_sockmap.rst:289 ../../../bpf/map_sockmap.rst:331
msgid "bpf_map_delete_elem()"
msgstr ""

#: ../../../bpf/map_sockmap.rst:294
msgid "Delete a socket entry from a sockmap or a sockhash."
msgstr ""

#: ../../../bpf/map_sockmap.rst:299 ../../../bpf/map_sockmap.rst:436
msgid "User space"
msgstr ""

#: ../../../bpf/map_sockmap.rst:306
msgid ""
"Sockmap entries can be added or updated using the ``bpf_map_update_elem()`` "
"function. The ``key`` parameter is the index value of the sockmap array. And "
"the ``value`` parameter is the FD value of that socket."
msgstr ""

#: ../../../bpf/map_sockmap.rst:310
msgid ""
"Under the hood, the sockmap update function uses the socket FD value to "
"retrieve the associated socket and its attached psock."
msgstr ""

#: ../../../bpf/map_sockmap.rst:325
msgid ""
"Sockmap entries can be retrieved using the ``bpf_map_lookup_elem()`` "
"function."
msgstr ""

#: ../../../bpf/map_sockmap.rst:328
msgid "The entry returned is a socket cookie rather than a socket itself."
msgstr ""

#: ../../../bpf/map_sockmap.rst:336
msgid ""
"Sockmap entries can be deleted using the ``bpf_map_delete_elem()`` function."
msgstr ""

#: ../../../bpf/map_sockmap.rst:339
msgid "Returns 0 on success, or negative error in case of failure."
msgstr ""

#: ../../../bpf/map_sockmap.rst:342
msgid "Examples"
msgstr ""

#: ../../../bpf/map_sockmap.rst:346 ../../../bpf/map_sockmap.rst:437
msgid "Several examples of the use of sockmap APIs can be found in:"
msgstr ""

#: ../../../bpf/map_sockmap.rst:348
msgid "`tools/testing/selftests/bpf/progs/test_sockmap_kern.h`_"
msgstr ""

#: ../../../bpf/map_sockmap.rst:349
msgid "`tools/testing/selftests/bpf/progs/sockmap_parse_prog.c`_"
msgstr ""

#: ../../../bpf/map_sockmap.rst:350
msgid "`tools/testing/selftests/bpf/progs/sockmap_verdict_prog.c`_"
msgstr ""

#: ../../../bpf/map_sockmap.rst:351
msgid "`tools/testing/selftests/bpf/progs/test_sockmap_listen.c`_"
msgstr ""

#: ../../../bpf/map_sockmap.rst:352
msgid "`tools/testing/selftests/bpf/progs/test_sockmap_update.c`_"
msgstr ""

#: ../../../bpf/map_sockmap.rst:354
msgid "The following code snippet shows how to declare a sockmap."
msgstr ""

#: ../../../bpf/map_sockmap.rst:365
msgid "The following code snippet shows a sample parser program."
msgstr ""

#: ../../../bpf/map_sockmap.rst:375
msgid ""
"The following code snippet shows a simple verdict program that interacts "
"with a sockmap to redirect traffic to another socket based on the local port."
msgstr ""

#: ../../../bpf/map_sockmap.rst:392
msgid "The following code snippet shows how to declare a sockhash map."
msgstr ""

#: ../../../bpf/map_sockmap.rst:410
msgid ""
"The following code snippet shows a simple verdict program that interacts "
"with a sockhash to redirect traffic to another socket based on a hash of "
"some of the skb parameters."
msgstr ""

#: ../../../bpf/map_sockmap.rst:439
msgid "`tools/testing/selftests/bpf/prog_tests/sockmap_basic.c`_"
msgstr ""

#: ../../../bpf/map_sockmap.rst:440
msgid "`tools/testing/selftests/bpf/test_sockmap.c`_"
msgstr ""

#: ../../../bpf/map_sockmap.rst:441
msgid "`tools/testing/selftests/bpf/test_maps.c`_"
msgstr ""

#: ../../../bpf/map_sockmap.rst:443
msgid ""
"The following code sample shows how to create a sockmap, attach a parser and "
"verdict program, as well as add a socket entry."
msgstr ""

#: ../../../bpf/map_sockmap.rst:483
msgid "References"
msgstr ""

#: ../../../bpf/map_sockmap.rst:485
msgid ""
"https://github.com/jrfastab/linux-kernel-xdp/commit/"
"c89fd73cb9d2d7f3c716c3e00836f07b1aeb261f"
msgstr ""

#: ../../../bpf/map_sockmap.rst:486
msgid "https://lwn.net/Articles/731133/"
msgstr ""

#: ../../../bpf/map_sockmap.rst:487
msgid "http://vger.kernel.org/lpc_net2018_talks/ktls_bpf_paper.pdf"
msgstr ""

#: ../../../bpf/map_sockmap.rst:488
msgid "https://lwn.net/Articles/748628/"
msgstr ""

#: ../../../bpf/map_sockmap.rst:489
msgid ""
"https://lore.kernel.org/bpf/20200218171023.844439-7-jakub@cloudflare.com/"
msgstr ""
