# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../power/opp.rst:3
msgid "Operating Performance Points (OPP) Library"
msgstr ""

#: ../../../power/opp.rst:5
msgid "2009-2010 Nishanth Menon <nm@ti.com>, Texas Instruments Incorporated"
msgstr ""

#: ../../../power/opp.rst:17
msgid "1. Introduction"
msgstr ""

#: ../../../power/opp.rst:20
msgid "1.1 What is an Operating Performance Point (OPP)?"
msgstr ""

#: ../../../power/opp.rst:22
msgid ""
"Complex SoCs of today consists of a multiple sub-modules working in "
"conjunction. In an operational system executing varied use cases, not all "
"modules in the SoC need to function at their highest performing frequency "
"all the time. To facilitate this, sub-modules in a SoC are grouped into "
"domains, allowing some domains to run at lower voltage and frequency while "
"other domains run at voltage/frequency pairs that are higher."
msgstr ""

#: ../../../power/opp.rst:29
msgid ""
"The set of discrete tuples consisting of frequency and voltage pairs that "
"the device will support per domain are called Operating Performance Points "
"or OPPs."
msgstr ""

#: ../../../power/opp.rst:33
msgid "As an example:"
msgstr ""

#: ../../../power/opp.rst:35
msgid ""
"Let us consider an MPU device which supports the following: {300MHz at "
"minimum voltage of 1V}, {800MHz at minimum voltage of 1.2V}, {1GHz at "
"minimum voltage of 1.3V}"
msgstr ""

#: ../../../power/opp.rst:39
msgid "We can represent these as three OPPs as the following {Hz, uV} tuples:"
msgstr ""

#: ../../../power/opp.rst:41
msgid "{300000000, 1000000}"
msgstr ""

#: ../../../power/opp.rst:42
msgid "{800000000, 1200000}"
msgstr ""

#: ../../../power/opp.rst:43
msgid "{1000000000, 1300000}"
msgstr ""

#: ../../../power/opp.rst:46
msgid "1.2 Operating Performance Points Library"
msgstr ""

#: ../../../power/opp.rst:48
msgid ""
"OPP library provides a set of helper functions to organize and query the OPP "
"information. The library is located in drivers/opp/ directory and the header "
"is located in include/linux/pm_opp.h. OPP library can be enabled by enabling "
"CONFIG_PM_OPP from power management menuconfig menu. Certain SoCs such as "
"Texas Instrument's OMAP framework allows to optionally boot at a certain OPP "
"without needing cpufreq."
msgstr ""

#: ../../../power/opp.rst:55
msgid "Typical usage of the OPP library is as follows::"
msgstr ""

#: ../../../power/opp.rst:61
msgid ""
"OPP layer expects each domain to be represented by a unique device pointer. "
"SoC framework registers a set of initial OPPs per device with the OPP layer. "
"This list is expected to be an optimally small number typically around 5 per "
"device. This initial list contains a set of OPPs that the framework expects "
"to be safely enabled by default in the system."
msgstr ""

#: ../../../power/opp.rst:68
msgid "Note on OPP Availability"
msgstr ""

#: ../../../power/opp.rst:70
msgid ""
"As the system proceeds to operate, SoC framework may choose to make certain "
"OPPs available or not available on each device based on various external "
"factors. Example usage: Thermal management or other exceptional situations "
"where SoC framework might choose to disable a higher frequency OPP to safely "
"continue operations until that OPP could be re-enabled if possible."
msgstr ""

#: ../../../power/opp.rst:76
msgid ""
"OPP library facilitates this concept in its implementation. The following "
"operational functions operate only on available opps: "
"dev_pm_opp_find_freq_{ceil, floor}, dev_pm_opp_get_voltage, "
"dev_pm_opp_get_freq, dev_pm_opp_get_opp_count."
msgstr ""

#: ../../../power/opp.rst:81
msgid ""
"dev_pm_opp_find_freq_exact is meant to be used to find the opp pointer which "
"can then be used for dev_pm_opp_enable/disable functions to make an opp "
"available as required."
msgstr ""

#: ../../../power/opp.rst:85
msgid ""
"WARNING: Users of OPP library should refresh their availability count using "
"get_opp_count if dev_pm_opp_enable/disable functions are invoked for a "
"device, the exact mechanism to trigger these or the notification mechanism "
"to other dependent subsystems such as cpufreq are left to the discretion of "
"the SoC specific framework which uses the OPP library. Similar care needs to "
"be taken care to refresh the cpufreq table in cases of these operations."
msgstr ""

#: ../../../power/opp.rst:93
msgid "2. Initial OPP List Registration"
msgstr ""

#: ../../../power/opp.rst:94
msgid ""
"The SoC implementation calls dev_pm_opp_add function iteratively to add OPPs "
"per device. It is expected that the SoC framework will register the OPP "
"entries optimally- typical numbers range to be less than 5. The list "
"generated by registering the OPPs is maintained by OPP library throughout "
"the device operation. The SoC framework can subsequently control the "
"availability of the OPPs dynamically using the dev_pm_opp_enable / disable "
"functions."
msgstr ""

#: ../../../power/opp.rst:101
msgid "dev_pm_opp_add"
msgstr ""

#: ../../../power/opp.rst:102
msgid ""
"Add a new OPP for a specific domain represented by the device pointer. The "
"OPP is defined using the frequency and voltage. Once added, the OPP is "
"assumed to be available and control of its availability can be done with the "
"dev_pm_opp_enable/disable functions. OPP library internally stores and "
"manages this information in the dev_pm_opp struct. This function may be used "
"by SoC framework to define a optimal list as per the demands of SoC usage "
"environment."
msgstr ""

#: ../../../power/opp.rst:110 ../../../power/opp.rst:210
#: ../../../power/opp.rst:351
msgid "WARNING:"
msgstr ""

#: ../../../power/opp.rst:111
msgid "Do not use this function in interrupt context."
msgstr ""

#: ../../../power/opp.rst:113
msgid "Example::"
msgstr ""

#: ../../../power/opp.rst:129
msgid "3. OPP Search Functions"
msgstr ""

#: ../../../power/opp.rst:130
msgid ""
"High level framework such as cpufreq operates on frequencies. To map the "
"frequency back to the corresponding OPP, OPP library provides handy "
"functions to search the OPP list that OPP library internally manages. These "
"search functions return the matching pointer representing the opp if a match "
"is found, else returns error. These errors are expected to be handled by "
"standard error checks such as IS_ERR() and appropriate actions taken by the "
"caller."
msgstr ""

#: ../../../power/opp.rst:137
msgid ""
"Callers of these functions shall call dev_pm_opp_put() after they have used "
"the OPP. Otherwise the memory for the OPP will never get freed and result in "
"memleak."
msgstr ""

#: ../../../power/opp.rst:141
msgid "dev_pm_opp_find_freq_exact"
msgstr ""

#: ../../../power/opp.rst:142
msgid ""
"Search for an OPP based on an *exact* frequency and availability. This "
"function is especially useful to enable an OPP which is not available by "
"default. Example: In a case when SoC framework detects a situation where a "
"higher frequency could be made available, it can use this function to find "
"the OPP prior to call the dev_pm_opp_enable to actually make it available::"
msgstr ""

#: ../../../power/opp.rst:160
msgid "NOTE:"
msgstr ""

#: ../../../power/opp.rst:161
msgid ""
"This is the only search function that operates on OPPs which are not "
"available."
msgstr ""

#: ../../../power/opp.rst:164
msgid "dev_pm_opp_find_freq_floor"
msgstr ""

#: ../../../power/opp.rst:165
msgid ""
"Search for an available OPP which is *at most* the provided frequency. This "
"function is useful while searching for a lesser match OR operating on OPP "
"information in the order of decreasing frequency. Example: To find the "
"highest opp for a device::"
msgstr ""

#: ../../../power/opp.rst:175
msgid "dev_pm_opp_find_freq_ceil"
msgstr ""

#: ../../../power/opp.rst:176
msgid ""
"Search for an available OPP which is *at least* the provided frequency. This "
"function is useful while searching for a higher match OR operating on OPP "
"information in the order of increasing frequency. Example 1: To find the "
"lowest opp for a device::"
msgstr ""

#: ../../../power/opp.rst:186
msgid ""
"Example 2: A simplified implementation of a SoC cpufreq_driver->target::"
msgstr ""

#: ../../../power/opp.rst:202
msgid "4. OPP Availability Control Functions"
msgstr ""

#: ../../../power/opp.rst:203
msgid ""
"A default OPP list registered with the OPP library may not cater to all "
"possible situation. The OPP library provides a set of functions to modify "
"the availability of a OPP within the OPP list. This allows SoC frameworks to "
"have fine grained dynamic control of which sets of OPPs are operationally "
"available. These functions are intended to *temporarily* remove an OPP in "
"conditions such as thermal considerations (e.g. don't use OPPx until the "
"temperature drops)."
msgstr ""

#: ../../../power/opp.rst:211
msgid "Do not use these functions in interrupt context."
msgstr ""

#: ../../../power/opp.rst:213
msgid "dev_pm_opp_enable"
msgstr ""

#: ../../../power/opp.rst:214
msgid ""
"Make a OPP available for operation. Example: Lets say that 1GHz OPP is to be "
"made available only if the SoC temperature is lower than a certain "
"threshold. The SoC framework implementation might choose to do something as "
"follows::"
msgstr ""

#: ../../../power/opp.rst:230
msgid "dev_pm_opp_disable"
msgstr ""

#: ../../../power/opp.rst:231
msgid ""
"Make an OPP to be not available for operation Example: Lets say that 1GHz "
"OPP is to be disabled if the temperature exceeds a threshold value. The SoC "
"framework implementation might choose to do something as follows::"
msgstr ""

#: ../../../power/opp.rst:248
msgid "5. OPP Data Retrieval Functions"
msgstr ""

#: ../../../power/opp.rst:249
msgid ""
"Since OPP library abstracts away the OPP information, a set of functions to "
"pull information from the dev_pm_opp structure is necessary. Once an OPP "
"pointer is retrieved using the search functions, the following functions can "
"be used by SoC framework to retrieve the information represented inside the "
"OPP layer."
msgstr ""

#: ../../../power/opp.rst:254
msgid "dev_pm_opp_get_voltage"
msgstr ""

#: ../../../power/opp.rst:255
msgid ""
"Retrieve the voltage represented by the opp pointer. Example: At a cpufreq "
"transition to a different frequency, SoC framework requires to set the "
"voltage represented by the OPP using the regulator framework to the Power "
"Management chip providing the voltage::"
msgstr ""

#: ../../../power/opp.rst:272
msgid "dev_pm_opp_get_freq"
msgstr ""

#: ../../../power/opp.rst:273
msgid ""
"Retrieve the freq represented by the opp pointer. Example: Lets say the SoC "
"framework uses a couple of helper functions we could pass opp pointers "
"instead of doing additional parameters to handle quiet a bit of data "
"parameters::"
msgstr ""

#: ../../../power/opp.rst:299
msgid "dev_pm_opp_get_opp_count"
msgstr ""

#: ../../../power/opp.rst:300
msgid ""
"Retrieve the number of available opps for a device Example: Lets say a co-"
"processor in the SoC needs to know the available frequencies in a table, the "
"main processor can notify as following::"
msgstr ""

#: ../../../power/opp.rst:323
msgid "6. Data Structures"
msgstr ""

#: ../../../power/opp.rst:324
msgid ""
"Typically an SoC contains multiple voltage domains which are variable. Each "
"domain is represented by a device pointer. The relationship to OPP can be "
"represented as follows::"
msgstr ""

#: ../../../power/opp.rst:338
msgid ""
"OPP library maintains a internal list that the SoC framework populates and "
"accessed by various functions as described above. However, the structures "
"representing the actual OPPs and domains are internal to the OPP library "
"itself to allow for suitable abstraction reusable across systems."
msgstr ""

#: ../../../power/opp.rst:343
msgid "struct dev_pm_opp"
msgstr ""

#: ../../../power/opp.rst:344
msgid ""
"The internal data structure of OPP library which is used to represent an "
"OPP. In addition to the freq, voltage, availability information, it also "
"contains internal book keeping information required for the OPP library to "
"operate on.  Pointer to this structure is provided back to the users such as "
"SoC framework to be used as a identifier for OPP in the interactions with "
"OPP layer."
msgstr ""

#: ../../../power/opp.rst:352
msgid ""
"The struct dev_pm_opp pointer should not be parsed or modified by the users. "
"The defaults of for an instance is populated by dev_pm_opp_add, but the "
"availability of the OPP can be modified by dev_pm_opp_enable/disable "
"functions."
msgstr ""

#: ../../../power/opp.rst:357
msgid "struct device"
msgstr ""

#: ../../../power/opp.rst:358
msgid ""
"This is used to identify a domain to the OPP layer. The nature of the device "
"and its implementation is left to the user of OPP library such as the SoC "
"framework."
msgstr ""

#: ../../../power/opp.rst:362
msgid ""
"Overall, in a simplistic view, the data structure operations is represented "
"as following::"
msgstr ""
