# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../power/freezing-of-tasks.rst:3
msgid "Freezing of tasks"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:5
msgid "2007 Rafael J. Wysocki <rjw@sisk.pl>, GPL"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:8
msgid "I. What is the freezing of tasks?"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:10
msgid ""
"The freezing of tasks is a mechanism by which user space processes and some "
"kernel threads are controlled during hibernation or system-wide suspend (on "
"some architectures)."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:15
msgid "II. How does it work?"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:17
msgid ""
"There is one per-task flag (PF_NOFREEZE) and three per-task states "
"(TASK_FROZEN, TASK_FREEZABLE and __TASK_FREEZABLE_UNSAFE) used for that. The "
"tasks that have PF_NOFREEZE unset (all user space tasks and some kernel "
"threads) are regarded as 'freezable' and treated in a special way before the "
"system enters a sleep state as well as before a hibernation image is created "
"(hibernation is directly covered by what follows, but the description "
"applies to system-wide suspend too)."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:25
msgid ""
"Namely, as the first step of the hibernation procedure the function "
"freeze_processes() (defined in kernel/power/process.c) is called.  A system-"
"wide static key freezer_active (as opposed to a per-task flag or state) is "
"used to indicate whether the system is to undergo a freezing operation. And "
"freeze_processes() sets this static key.  After this, it executes "
"try_to_freeze_tasks() that sends a fake signal to all user space processes, "
"and wakes up all the kernel threads. All freezable tasks must react to that "
"by calling try_to_freeze(), which results in a call to __refrigerator() "
"(defined in kernel/freezer.c), which changes the task's state to "
"TASK_FROZEN, and makes it loop until it is woken by an explicit TASK_FROZEN "
"wakeup. Then, that task is regarded as 'frozen' and so the set of functions "
"handling this mechanism is referred to as 'the freezer' (these functions are "
"defined in kernel/power/process.c, kernel/freezer.c & include/linux/freezer."
"h). User space tasks are generally frozen before kernel threads."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:40
msgid ""
"__refrigerator() must not be called directly.  Instead, use the "
"try_to_freeze() function (defined in include/linux/freezer.h), that checks "
"if the task is to be frozen and makes the task enter __refrigerator()."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:44
msgid ""
"For user space processes try_to_freeze() is called automatically from the "
"signal-handling code, but the freezable kernel threads need to call it "
"explicitly in suitable places or use the wait_event_freezable() or "
"wait_event_freezable_timeout() macros (defined in include/linux/wait.h) that "
"put the task to sleep (TASK_INTERRUPTIBLE) or freeze it (TASK_FROZEN) if "
"freezer_active is set. The main loop of a freezable kernel thread may look "
"like the following one::"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:69
msgid "(from mm/oom_kill.c::oom_reaper())."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:71
msgid ""
"If a freezable kernel thread is not put to the frozen state after the "
"freezer has initiated a freezing operation, the freezing of tasks will fail "
"and the entire system-wide transition will be cancelled.  For this reason, "
"freezable kernel threads must call try_to_freeze() somewhere or use one of "
"the wait_event_freezable() and wait_event_freezable_timeout() macros."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:77
msgid ""
"After the system memory state has been restored from a hibernation image and "
"devices have been reinitialized, the function thaw_processes() is called in "
"order to wake up each frozen task.  Then, the tasks that have been frozen "
"leave __refrigerator() and continue running."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:84
msgid ""
"Rationale behind the functions dealing with freezing and thawing of tasks"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:86
msgid "freeze_processes():"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:87
msgid "freezes only userspace tasks"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:89
msgid "freeze_kernel_threads():"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:90
msgid ""
"freezes all tasks (including kernel threads) because we can't freeze kernel "
"threads without freezing userspace tasks"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:93
msgid "thaw_kernel_threads():"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:94
msgid ""
"thaws only kernel threads; this is particularly useful if we need to do "
"anything special in between thawing of kernel threads and thawing of "
"userspace tasks, or if we want to postpone the thawing of userspace tasks"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:98
msgid "thaw_processes():"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:99
msgid ""
"thaws all tasks (including kernel threads) because we can't thaw userspace "
"tasks without thawing kernel threads"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:104
msgid "III. Which kernel threads are freezable?"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:106
msgid ""
"Kernel threads are not freezable by default.  However, a kernel thread may "
"clear PF_NOFREEZE for itself by calling set_freezable() (the resetting of "
"PF_NOFREEZE directly is not allowed).  From this point it is regarded as "
"freezable and must call try_to_freeze() or variants of "
"wait_event_freezable() in a suitable place."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:113
msgid "IV. Why do we do that?"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:115
msgid ""
"Generally speaking, there is a couple of reasons to use the freezing of "
"tasks:"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:117
msgid ""
"The principal reason is to prevent filesystems from being damaged after "
"hibernation.  At the moment we have no simple means of checkpointing "
"filesystems, so if there are any modifications made to filesystem data and/"
"or metadata on disks, we cannot bring them back to the state from before the "
"modifications.  At the same time each hibernation image contains some "
"filesystem-related information that must be consistent with the state of the "
"on-disk data and metadata after the system memory state has been restored "
"from the image (otherwise the filesystems will be damaged in a nasty way, "
"usually making them almost impossible to repair).  We therefore freeze tasks "
"that might cause the on-disk filesystems' data and metadata to be modified "
"after the hibernation image has been created and before the system is "
"finally powered off. The majority of these are user space processes, but if "
"any of the kernel threads may cause something like this to happen, they have "
"to be freezable."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:132
msgid ""
"Next, to create the hibernation image we need to free a sufficient amount of "
"memory (approximately 50% of available RAM) and we need to do that before "
"devices are deactivated, because we generally need them for swapping out. "
"Then, after the memory for the image has been freed, we don't want tasks to "
"allocate additional memory and we prevent them from doing that by freezing "
"them earlier. [Of course, this also means that device drivers should not "
"allocate substantial amounts of memory from their .suspend() callbacks "
"before hibernation, but this is a separate issue.]"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:141
msgid ""
"The third reason is to prevent user space processes and some kernel threads "
"from interfering with the suspending and resuming of devices.  A user space "
"process running on a second CPU while we are suspending devices may, for "
"example, be troublesome and without the freezing of tasks we would need some "
"safeguards against race conditions that might occur in such a case."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:147
msgid ""
"Although Linus Torvalds doesn't like the freezing of tasks, he said this in "
"one of the discussions on LKML (https://lore.kernel.org/r/alpine."
"LFD.0.98.0704271801020.9964@woody.linux-foundation.org):"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:150
msgid "\"RJW:> Why we freeze tasks at all or why we freeze kernel threads?"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:152
msgid "Linus: In many ways, 'at all'."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:154
msgid ""
"I **do** realize the IO request queue issues, and that we cannot actually do "
"s2ram with some devices in the middle of a DMA.  So we want to be able to "
"avoid *that*, there's no question about that.  And I suspect that stopping "
"user threads and then waiting for a sync is practically one of the easier "
"ways to do so."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:160
msgid ""
"So in practice, the 'at all' may become a 'why freeze kernel threads?' and "
"freezing user threads I don't find really objectionable.\""
msgstr ""

#: ../../../power/freezing-of-tasks.rst:163
msgid ""
"Still, there are kernel threads that may want to be freezable.  For example, "
"if a kernel thread that belongs to a device driver accesses the device "
"directly, it in principle needs to know when the device is suspended, so "
"that it doesn't try to access it at that time.  However, if the kernel "
"thread is freezable, it will be frozen before the driver's .suspend() "
"callback is executed and it will be thawed after the driver's .resume() "
"callback has run, so it won't be accessing the device while it's suspended."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:171
msgid ""
"Another reason for freezing tasks is to prevent user space processes from "
"realizing that hibernation (or suspend) operation takes place.  Ideally, "
"user space processes should not notice that such a system-wide operation has "
"occurred and should continue running without any problems after the restore "
"(or resume from suspend).  Unfortunately, in the most general case this is "
"quite difficult to achieve without the freezing of tasks.  Consider, for "
"example, a process that depends on all CPUs being online while it's "
"running.  Since we need to disable nonboot CPUs during the hibernation, if "
"this process is not frozen, it may notice that the number of CPUs has "
"changed and may start to work incorrectly because of that."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:183
msgid "V. Are there any problems related to the freezing of tasks?"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:185
#: ../../../power/freezing-of-tasks.rst:227
msgid "Yes, there are."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:187
msgid ""
"First of all, the freezing of kernel threads may be tricky if they depend "
"one on another.  For example, if kernel thread A waits for a completion (in "
"the TASK_UNINTERRUPTIBLE state) that needs to be done by freezable kernel "
"thread B and B is frozen in the meantime, then A will be blocked until B is "
"thawed, which may be undesirable.  That's why kernel threads are not "
"freezable by default."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:193
msgid ""
"Second, there are the following two problems related to the freezing of user "
"space processes:"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:196
msgid ""
"Putting processes into an uninterruptible sleep distorts the load average."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:197
msgid ""
"Now that we have FUSE, plus the framework for doing device drivers in "
"userspace, it gets even more complicated because some userspace processes "
"are now doing the sorts of things that kernel threads do (https://lists."
"linux-foundation.org/pipermail/linux-pm/2007-May/012309.html)."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:202
msgid ""
"The problem 1. seems to be fixable, although it hasn't been fixed so far.  "
"The other one is more serious, but it seems that we can work around it by "
"using hibernation (and suspend) notifiers (in that case, though, we won't be "
"able to avoid the realization by the user space processes that the "
"hibernation is taking place)."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:208
msgid ""
"There are also problems that the freezing of tasks tends to expose, although "
"they are not directly related to it.  For example, if request_firmware() is "
"called from a device driver's .resume() routine, it will timeout and "
"eventually fail, because the user land process that should respond to the "
"request is frozen at this point.  So, seemingly, the failure is due to the "
"freezing of tasks. Suppose, however, that the firmware file is located on a "
"filesystem accessible only through another device that hasn't been resumed "
"yet.  In that case, request_firmware() will fail regardless of whether or "
"not the freezing of tasks is used.  Consequently, the problem is not really "
"related to the freezing of tasks, since it generally exists anyway."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:219
msgid ""
"A driver must have all firmwares it may need in RAM before suspend() is "
"called. If keeping them is not practical, for example due to their size, "
"they must be requested early enough using the suspend notifier API described "
"in Documentation/driver-api/pm/notifiers.rst."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:225
msgid "VI. Are there any precautions to be taken to prevent freezing failures?"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:229
msgid ""
"First of all, grabbing the 'system_transition_mutex' lock to mutually "
"exclude a piece of code from system-wide sleep such as suspend/hibernation "
"is not encouraged.  If possible, that piece of code must instead hook onto "
"the suspend/hibernation notifiers to achieve mutual exclusion. Look at the "
"CPU-Hotplug code (kernel/cpu.c) for an example."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:235
msgid ""
"However, if that is not feasible, and grabbing 'system_transition_mutex' is "
"deemed necessary, it is strongly discouraged to directly call "
"mutex_[un]lock(&system_transition_mutex) since that could lead to freezing "
"failures, because if the suspend/hibernate code successfully acquired the "
"'system_transition_mutex' lock, and hence that other entity failed to "
"acquire the lock, then that task would get blocked in TASK_UNINTERRUPTIBLE "
"state. As a consequence, the freezer would not be able to freeze that task, "
"leading to freezing failure."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:244
msgid ""
"However, the [un]lock_system_sleep() APIs are safe to use in this scenario, "
"since they ask the freezer to skip freezing this task, since it is anyway "
"\"frozen enough\" as it is blocked on 'system_transition_mutex', which will "
"be released only after the entire suspend/hibernation sequence is complete.  "
"So, to summarize, use [un]lock_system_sleep() instead of directly using "
"mutex_[un]lock(&system_transition_mutex). That would prevent freezing "
"failures."
msgstr ""

#: ../../../power/freezing-of-tasks.rst:252
msgid "V. Miscellaneous"
msgstr ""

#: ../../../power/freezing-of-tasks.rst:254
msgid ""
"/sys/power/pm_freeze_timeout controls how long it will cost at most to "
"freeze all user space processes or all freezable kernel threads, in unit of "
"millisecond.  The default value is 20000, with range of unsigned integer."
msgstr ""
