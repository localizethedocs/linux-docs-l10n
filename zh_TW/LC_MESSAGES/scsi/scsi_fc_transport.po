# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scsi/scsi_fc_transport.rst:5
msgid "SCSI FC Transport"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:7
msgid "Date:  11/18/2008"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:9
msgid "Kernel Revisions for features::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:17
msgid "Introduction"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:18
msgid ""
"This file documents the features and components of the SCSI FC Transport. It "
"also provides documents the API between the transport and FC LLDDs."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:21
msgid "The FC transport can be found at::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:28
msgid "This file is found at Documentation/scsi/scsi_fc_transport.rst"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:32
msgid "FC Remote Ports (rports)"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:34
msgid ""
"In the Fibre Channel (FC) subsystem, a remote port (rport) refers to a "
"remote Fibre Channel node that the local port can communicate with. These "
"are typically storage targets (e.g., arrays, tapes) that respond to SCSI "
"commands over FC transport."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:39
msgid ""
"In Linux, rports are managed by the FC transport class and are represented "
"in sysfs under:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:42
msgid "/sys/class/fc_remote_ports/"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:44
msgid ""
"Each rport directory contains attributes describing the remote port, such as "
"port ID, node name, port state, and link speed."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:47
msgid ""
"rports are typically created by the FC transport when a new device is "
"discovered during a fabric login or scan, and they persist until the device "
"is removed or the link is lost."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:51
msgid ""
"Common attributes: - node_name: World Wide Node Name (WWNN). - port_name: "
"World Wide Port Name (WWPN). - port_id: FC address of the remote port. - "
"roles: Indicates if the port is an initiator, target, or both. - port_state: "
"Shows the current operational state."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:58
msgid ""
"After discovering a remote port, the driver typically populates a "
"fc_rport_identifiers structure and invokes fc_remote_port_add() to create "
"and register the remote port with the SCSI subsystem via the Fibre Channel "
"(FC) transport class."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:63
msgid "rports are also visible via sysfs as children of the FC host adapter."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:65
msgid ""
"For developers: use fc_remote_port_add() and fc_remote_port_delete() when "
"implementing a driver that interacts with the FC transport class."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:70
msgid "FC Virtual Ports (vports)"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:73
msgid "Overview"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:75
msgid ""
"New FC standards have defined mechanisms which allows for a single physical "
"port to appear on as multiple communication ports. Using the N_Port Id "
"Virtualization (NPIV) mechanism, a point-to-point connection to a Fabric can "
"be assigned more than 1 N_Port_ID.  Each N_Port_ID appears as a separate "
"port to other endpoints on the fabric, even though it shares one physical "
"link to the switch for communication. Each N_Port_ID can have a unique view "
"of the fabric based on fabric zoning and array lun-masking (just like a "
"normal non-NPIV adapter).  Using the Virtual Fabric (VF) mechanism, adding a "
"fabric header to each frame allows the port to interact with the Fabric Port "
"to join multiple fabrics. The port will obtain an N_Port_ID on each fabric "
"it joins. Each fabric will have its own unique view of endpoints and "
"configuration parameters.  NPIV may be used together with VF so that the "
"port can obtain multiple N_Port_IDs on each virtual fabric."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:90
msgid ""
"The FC transport is now recognizing a new object - a vport.  A vport is an "
"entity that has a world-wide unique World Wide Port Name (wwpn) and World "
"Wide Node Name (wwnn). The transport also allows for the FC4's to be "
"specified for the vport, with FCP_Initiator being the primary role expected. "
"Once instantiated by one of the above methods, it will have a distinct "
"N_Port_ID and view of fabric endpoints and storage entities. The fc_host "
"associated with the physical adapter will export the ability to create "
"vports. The transport will create the vport object within the Linux device "
"tree, and instruct the fc_host's driver to instantiate the virtual port. "
"Typically, the driver will create a new scsi_host instance on the vport, "
"resulting in a unique <H,C,T,L> namespace for the vport. Thus, whether a FC "
"port is based on a physical port or on a virtual port, each will appear as a "
"unique scsi_host with its own target and lun space."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:105
msgid ""
"At this time, the transport is written to create only NPIV-based vports. "
"However, consideration was given to VF-based vports and it should be a minor "
"change to add support if needed.  The remaining discussion will concentrate "
"on NPIV."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:111
msgid ""
"World Wide Name assignment (and uniqueness guarantees) are left up to an "
"administrative entity controlling the vport. For example, if vports are to "
"be associated with virtual machines, a XEN mgmt utility would be responsible "
"for creating wwpn/wwnn's for the vport, using its own naming authority and "
"OUI. (Note: it already does this for virtual MAC addresses)."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:120
msgid "Device Trees and Vport Objects:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:122
msgid ""
"Today, the device tree typically contains the scsi_host object, with rports "
"and scsi target objects underneath it. Currently the FC transport creates "
"the vport object and places it under the scsi_host object corresponding to "
"the physical adapter.  The LLDD will allocate a new scsi_host for the vport "
"and link its object under the vport. The remainder of the tree under the "
"vports scsi_host is the same as the non-NPIV case. The transport is written "
"currently to easily allow the parent of the vport to be something other than "
"the scsi_host. This could be used in the future to link the object onto a vm-"
"specific device tree. If the vport's parent is not the physical port's "
"scsi_host, a symbolic link to the vport object will be placed in the "
"physical port's scsi_host."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:135
msgid "Here's what to expect in the device tree :"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:137
msgid "The typical Physical Port's Scsi_Host::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:141
msgid "and it has the typical descendant tree::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:145
msgid "and then the vport is created on the Physical Port::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:149
msgid "and the vport's Scsi_Host is then created::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:153
msgid "and then the rest of the tree progresses, such as::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:157
msgid "Here's what to expect in the sysfs tree::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:173
msgid "Vport Attributes"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:175
msgid "The new fc_vport class object has the following attributes"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:177
msgid "node_name:                                                 Read_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:178
msgid "The WWNN of the vport"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:180
msgid "port_name:                                                 Read_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:181
msgid "The WWPN of the vport"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:183
msgid "roles:                                                     Read_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:184
msgid "Indicates the FC4 roles enabled on the vport."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:186
msgid "symbolic_name:                                             Read_Write"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:187
msgid ""
"A string, appended to the driver's symbolic port name string, which is "
"registered with the switch to identify the vport. For example, a hypervisor "
"could set this string to \"Xen Domain 2 VM 5 Vport 2\", and this set of "
"identifiers can be seen on switch management screens to identify the port."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:193
#: ../../../scsi/scsi_fc_transport.rst:232
msgid "vport_delete:                                              Write_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:194
msgid "When written with a \"1\", will tear down the vport."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:196
msgid "vport_disable:                                             Write_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:197
msgid ""
"When written with a \"1\", will transition the vport to a disabled. state.  "
"The vport will still be instantiated with the Linux kernel, but it will not "
"be active on the FC link. When written with a \"0\", will enable the vport."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:202
msgid "vport_last_state:                                          Read_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:203
msgid ""
"Indicates the previous state of the vport.  See the section below on \"Vport "
"States\"."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:206
msgid "vport_state:                                               Read_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:207
msgid ""
"Indicates the state of the vport.  See the section below on \"Vport States\"."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:210
msgid "vport_type:                                                Read_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:211
msgid ""
"Reflects the FC mechanism used to create the virtual port. Only NPIV is "
"supported currently."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:215
msgid ""
"For the fc_host class object, the following attributes are added for vports:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:217
msgid "max_npiv_vports:                                           Read_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:218
msgid ""
"Indicates the maximum number of NPIV-based vports that the driver/adapter "
"can support on the fc_host."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:221
msgid "npiv_vports_inuse:                                         Read_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:222
msgid ""
"Indicates how many NPIV-based vports have been instantiated on the fc_host."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:225
msgid "vport_create:                                              Write_Only"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:226
msgid ""
"A \"simple\" create interface to instantiate a vport on an fc_host. A "
"\"<WWPN>:<WWNN>\" string is written to the attribute. The transport then "
"instantiates the vport object and calls the LLDD to create the vport with "
"the role of FCP_Initiator.  Each WWN is specified as 16 hex characters and "
"may *not* contain any prefixes (e.g. 0x, x, etc)."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:233
msgid ""
"A \"simple\" delete interface to teardown a vport. A \"<WWPN>:<WWNN>\" "
"string is written to the attribute. The transport will locate the vport on "
"the fc_host with the same WWNs and tear it down.  Each WWN is specified as "
"16 hex characters and may *not* contain any prefixes (e.g. 0x, x, etc)."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:241
msgid "Vport States"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:243
msgid "Vport instantiation consists of two parts:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:245
#: ../../../scsi/scsi_fc_transport.rst:401
msgid ""
"Creation with the kernel and LLDD. This means all transport and driver data "
"structures are built up, and device objects created. This is equivalent to a "
"driver \"attach\" on an adapter, which is independent of the adapter's link "
"state."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:249
#: ../../../scsi/scsi_fc_transport.rst:405
msgid ""
"Instantiation of the vport on the FC link via ELS traffic, etc. This is "
"equivalent to a \"link up\" and successful link initialization."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:252
msgid ""
"Further information can be found in the interfaces section below for Vport "
"Creation."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:255
msgid ""
"Once a vport has been instantiated with the kernel/LLDD, a vport state can "
"be reported via the sysfs attribute. The following states exist:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:258
msgid "FC_VPORT_UNKNOWN            - Unknown"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:259
msgid ""
"An temporary state, typically set only while the vport is being instantiated "
"with the kernel and LLDD."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:262
msgid "FC_VPORT_ACTIVE             - Active"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:263
msgid ""
"The vport has been successfully been created on the FC link. It is fully "
"functional."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:266
msgid "FC_VPORT_DISABLED           - Disabled"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:267
msgid ""
"The vport instantiated, but \"disabled\". The vport is not instantiated on "
"the FC link. This is equivalent to a physical port with the link \"down\"."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:271
msgid "FC_VPORT_LINKDOWN           - Linkdown"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:272
msgid "The vport is not operational as the physical link is not operational."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:274
msgid "FC_VPORT_INITIALIZING       - Initializing"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:275
msgid ""
"The vport is in the process of instantiating on the FC link. The LLDD will "
"set this state just prior to starting the ELS traffic to create the vport. "
"This state will persist until the vport is successfully created (state "
"becomes FC_VPORT_ACTIVE) or it fails (state is one of the values below).  As "
"this state is transitory, it will not be preserved in the "
"\"vport_last_state\"."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:282
msgid "FC_VPORT_NO_FABRIC_SUPP     - No Fabric Support"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:283
msgid ""
"The vport is not operational. One of the following conditions were "
"encountered:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:286
msgid "The FC topology is not Point-to-Point"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:287
msgid "The FC port is not connected to an F_Port"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:288
msgid "The F_Port has indicated that NPIV is not supported."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:290
msgid "FC_VPORT_NO_FABRIC_RSCS     - No Fabric Resources"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:291
msgid ""
"The vport is not operational. The Fabric failed FDISC with a status "
"indicating that it does not have sufficient resources to complete the "
"operation."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:295
msgid "FC_VPORT_FABRIC_LOGOUT      - Fabric Logout"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:296
msgid ""
"The vport is not operational. The Fabric has LOGO'd the N_Port_ID associated "
"with the vport."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:299
msgid "FC_VPORT_FABRIC_REJ_WWN     - Fabric Rejected WWN"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:300
msgid ""
"The vport is not operational. The Fabric failed FDISC with a status "
"indicating that the WWN's are not valid."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:303
msgid "FC_VPORT_FAILED             - VPort Failed"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:304
msgid ""
"The vport is not operational. This is a catchall for all other error "
"conditions."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:308
msgid "The following state table indicates the different state transitions:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:311
msgid "State"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:311
msgid "Event"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:311
msgid "New State"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:313
msgid "n/a"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:313
msgid "Initialization"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:313
#: ../../../scsi/scsi_fc_transport.rst:328
#: ../../../scsi/scsi_fc_transport.rst:344
#: ../../../scsi/scsi_fc_transport.rst:352
msgid "Unknown"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:315
msgid "Unknown:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:315
#: ../../../scsi/scsi_fc_transport.rst:340
#: ../../../scsi/scsi_fc_transport.rst:348
msgid "Link Down"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:315
#: ../../../scsi/scsi_fc_transport.rst:340
#: ../../../scsi/scsi_fc_transport.rst:348
msgid "Linkdown"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:317
msgid "Link Up & Loop"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:317
#: ../../../scsi/scsi_fc_transport.rst:319
#: ../../../scsi/scsi_fc_transport.rst:321
msgid "No Fabric Support"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:319
msgid "Link Up & no Fabric"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:321
msgid "Link Up & FLOGI response indicates no NPIV support"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:324
msgid "Link Up & FDISC being sent"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:324
msgid "Initializing"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:326
#: ../../../scsi/scsi_fc_transport.rst:342
#: ../../../scsi/scsi_fc_transport.rst:350
msgid "Disable request"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:326
#: ../../../scsi/scsi_fc_transport.rst:342
#: ../../../scsi/scsi_fc_transport.rst:350
msgid "Disable"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:328
msgid "Linkdown:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:328
msgid "Link Up"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:330
msgid "Initializing:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:330
msgid "FDISC ACC"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:330
msgid "Active"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:332
msgid "FDISC LS_RJT w/ no resources"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:332
msgid "No Fabric Resources"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:334
msgid "FDISC LS_RJT w/ invalid pname or invalid nport_id"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:334
msgid "Fabric Rejected WWN"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:337
msgid "FDISC LS_RJT failed for other reasons"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:337
msgid "Vport Failed"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:344
msgid "Disable:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:344
msgid "Enable request"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:346
msgid "Active:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:346
msgid "LOGO received from fabric"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:346
msgid "Fabric Logout"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:352
msgid "Fabric Logout:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:352
msgid "Link still up"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:355
msgid "The following 4 error states all have the same transitions::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:366
msgid "Transport <-> LLDD Interfaces"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:368
msgid "Vport support by LLDD:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:370
msgid ""
"The LLDD indicates support for vports by supplying a vport_create() function "
"in the transport template.  The presence of this function will cause the "
"creation of the new attributes on the fc_host.  As part of the physical port "
"completing its initialization relative to the transport, it should set the "
"max_npiv_vports attribute to indicate the maximum number of vports the "
"driver and/or adapter supports."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:378
msgid "Vport Creation:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:380
msgid "The LLDD vport_create() syntax is::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:384
#: ../../../scsi/scsi_fc_transport.rst:470
#: ../../../scsi/scsi_fc_transport.rst:501
msgid "where:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:387
#: ../../../scsi/scsi_fc_transport.rst:473
msgid "vport"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:387
msgid "Is the newly allocated vport object"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:388
#: ../../../scsi/scsi_fc_transport.rst:474
msgid "disable"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:388
msgid ""
"If \"true\", the vport is to be created in a disabled stated. If \"false\", "
"the vport is to be enabled upon creation."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:392
msgid ""
"When a request is made to create a new vport (via sgio/netlink, or the "
"vport_create fc_host attribute), the transport will validate that the LLDD "
"can support another vport (e.g. max_npiv_vports > npiv_vports_inuse). If "
"not, the create request will be failed.  If space remains, the transport "
"will increment the vport count, create the vport object, and then call the "
"LLDD's vport_create() function with the newly allocated vport object."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:399
msgid "As mentioned above, vport creation is divided into two parts:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:408
msgid ""
"The LLDD's vport_create() function will not synchronously wait for both "
"parts to be fully completed before returning. It must validate that the "
"infrastructure exists to support NPIV, and complete the first part of vport "
"creation (data structure build up) before returning.  We do not hinge "
"vport_create() on the link-side operation mainly because:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:414
msgid ""
"The link may be down. It is not a failure if it is. It simply means the "
"vport is in an inoperable state until the link comes up. This is consistent "
"with the link bouncing post vport creation."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:417
msgid "The vport may be created in a disabled state."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:418
msgid ""
"This is consistent with a model where:  the vport equates to a FC adapter. "
"The vport_create is synonymous with driver attachment to the adapter, which "
"is independent of link state."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:424
msgid ""
"special error codes have been defined to delineate infrastructure failure "
"cases for quicker resolution."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:427
msgid "The expected behavior for the LLDD's vport_create() function is:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:429
msgid "Validate Infrastructure:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:431
msgid "If the driver or adapter cannot support another vport, whether"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:432
msgid ""
"due to improper firmware, (a lie about) max_npiv, or a lack of some other "
"resource - return VPCERR_UNSUPPORTED."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:434
msgid "If the driver validates the WWN's against those already active on"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:435
msgid "the adapter and detects an overlap - return VPCERR_BAD_WWN."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:436
msgid "If the driver detects the topology is loop, non-fabric, or the"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:437
msgid "FLOGI did not support NPIV - return VPCERR_NO_FABRIC_SUPP."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:439
msgid "Allocate data structures. If errors are encountered, such as out"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:440
msgid "of memory conditions, return the respective negative Exxx error code."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:441
msgid "If the role is FCP Initiator, the LLDD is to :"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:443
msgid "Call scsi_host_alloc() to allocate a scsi_host for the vport."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:444
msgid ""
"Call scsi_add_host(new_shost, &vport->dev) to start the scsi_host and bind "
"it as a child of the vport device."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:446
msgid "Initializes the fc_host attribute values."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:448
msgid "Kick of further vport state transitions based on the disable flag and"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:449
msgid "link state - and return success (zero)."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:451
msgid "LLDD Implementers Notes:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:453
msgid ""
"It is suggested that there be a different fc_function_templates for the "
"physical port and the virtual port.  The physical port's template would have "
"the vport_create, vport_delete, and vport_disable functions, while the "
"vports would not."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:457
msgid ""
"It is suggested that there be different scsi_host_templates for the physical "
"port and virtual port. Likely, there are driver attributes, embedded into "
"the scsi_host_template, that are applicable for the physical port only (link "
"speed, topology setting, etc). This ensures that the attributes are "
"applicable to the respective scsi_host."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:464
msgid "Vport Disable/Enable:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:466
msgid "The LLDD vport_disable() syntax is::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:473
msgid "Is vport to be enabled or disabled"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:474
msgid ""
"If \"true\", the vport is to be disabled. If \"false\", the vport is to be "
"enabled."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:478
msgid ""
"When a request is made to change the disabled state on a vport, the "
"transport will validate the request against the existing vport state. If the "
"request is to disable and the vport is already disabled, the request will "
"fail. Similarly, if the request is to enable, and the vport is not in a "
"disabled state, the request will fail.  If the request is valid for the "
"vport state, the transport will call the LLDD to change the vport's state."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:486
msgid ""
"Within the LLDD, if a vport is disabled, it remains instantiated with the "
"kernel and LLDD, but it is not active or visible on the FC link in any way. "
"(see Vport Creation and the 2 part instantiation discussion). The vport will "
"remain in this state until it is deleted or re-enabled. When enabling a "
"vport, the LLDD reinstantiates the vport on the FC link - essentially "
"restarting the LLDD statemachine (see Vport States above)."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:495
msgid "Vport Deletion:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:497
msgid "The LLDD vport_delete() syntax is::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:503
msgid "vport:    Is vport to delete"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:505
msgid ""
"When a request is made to delete a vport (via sgio/netlink, or via the "
"fc_host or fc_vport vport_delete attributes), the transport will call the "
"LLDD to terminate the vport on the FC link, and teardown all other "
"datastructures and references.  If the LLDD completes successfully, the "
"transport will teardown the vport objects and complete the vport removal.  "
"If the LLDD delete request fails, the vport object will remain, but will be "
"in an indeterminate state."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:513
msgid ""
"Within the LLDD, the normal code paths for a scsi_host teardown should be "
"followed. E.g. If the vport has a FCP Initiator role, the LLDD will call "
"fc_remove_host() for the vports scsi_host, followed by scsi_remove_host() "
"and scsi_host_put() for the vports scsi_host."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:519
msgid "Other:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:520
msgid "fc_host port_type attribute:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:521
msgid ""
"There is a new fc_host port_type value - FC_PORTTYPE_NPIV. This value must "
"be set on all vport-based fc_hosts.  Normally, on a physical port, the "
"port_type attribute would be set to NPORT, NLPORT, etc based on the topology "
"type and existence of the fabric. As this is not applicable to a vport, it "
"makes more sense to report the FC mechanism used to create the vport."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:528
msgid "Driver unload:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:529
msgid ""
"FC drivers are required to call fc_remove_host() prior to calling "
"scsi_remove_host().  This allows the fc_host to tear down all remote ports "
"prior the scsi_host being torn down.  The fc_remove_host() call was updated "
"to remove all vports for the fc_host as well."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:536
msgid "Transport supplied functions"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:538
msgid ""
"The following functions are supplied by the FC-transport for use by LLDs."
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:541
msgid "fc_vport_create"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:541
msgid "create a vport"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:542
msgid "fc_vport_terminate"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:542
msgid "detach and remove a vport"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:545
msgid "Details::"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:574
msgid "FC BSG support (CT & ELS passthru, and more)"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:576
msgid "<< To Be Supplied >>"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:583
msgid "Credits"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:584
msgid "The following people have contributed to this document:"
msgstr ""

#: ../../../scsi/scsi_fc_transport.rst:591
msgid "James Smart james.smart@broadcom.com"
msgstr ""
