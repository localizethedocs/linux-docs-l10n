# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/ntb.rst:3
msgid "NTB Drivers"
msgstr ""

#: ../../../driver-api/ntb.rst:5
msgid ""
"NTB (Non-Transparent Bridge) is a type of PCI-Express bridge chip that "
"connects the separate memory systems of two or more computers to the same "
"PCI-Express fabric. Existing NTB hardware supports a common feature set: "
"doorbell registers and memory translation windows, as well as non common "
"features like scratchpad and message registers. Scratchpad registers are "
"read-and-writable registers that are accessible from either side of the "
"device, so that peers can exchange a small amount of information at a fixed "
"address. Message registers can be utilized for the same purpose. "
"Additionally they are provided with special status bits to make sure the "
"information isn't rewritten by another peer. Doorbell registers provide a "
"way for peers to send interrupt events. Memory windows allow translated read "
"and write access to the peer memory."
msgstr ""

#: ../../../driver-api/ntb.rst:18
msgid "NTB Core Driver (ntb)"
msgstr ""

#: ../../../driver-api/ntb.rst:20
msgid ""
"The NTB core driver defines an api wrapping the common feature set, and "
"allows clients interested in NTB features to discover NTB the devices "
"supported by hardware drivers.  The term \"client\" is used here to mean an "
"upper layer component making use of the NTB api.  The term \"driver,\" or "
"\"hardware driver,\" is used here to mean a driver for a specific vendor and "
"model of NTB hardware."
msgstr ""

#: ../../../driver-api/ntb.rst:27
msgid "NTB Client Drivers"
msgstr ""

#: ../../../driver-api/ntb.rst:29
msgid ""
"NTB client drivers should register with the NTB core driver.  After "
"registering, the client probe and remove functions will be called "
"appropriately as ntb hardware, or hardware drivers, are inserted and "
"removed.  The registration uses the Linux Device framework, so it should "
"feel familiar to anyone who has written a pci driver."
msgstr ""

#: ../../../driver-api/ntb.rst:36
msgid "NTB Typical client driver implementation"
msgstr ""

#: ../../../driver-api/ntb.rst:38
msgid ""
"Primary purpose of NTB is to share some piece of memory between at least two "
"systems. So the NTB device features like Scratchpad/Message registers are "
"mainly used to perform the proper memory window initialization. Typically "
"there are two types of memory window interfaces supported by the NTB API: "
"inbound translation configured on the local ntb port and outbound "
"translation configured by the peer, on the peer ntb port. The first type is "
"depicted on the next figure::"
msgstr ""

#: ../../../driver-api/ntb.rst:55
msgid ""
"So typical scenario of the first type memory window initialization looks: 1) "
"allocate a memory region, 2) put translated address to NTB config, 3) "
"somehow notify a peer device of performed initialization, 4) peer device "
"maps corresponding outbound memory window so to have access to the shared "
"memory region."
msgstr ""

#: ../../../driver-api/ntb.rst:61
msgid ""
"The second type of interface, that implies the shared windows being "
"initialized by a peer device, is depicted on the figure::"
msgstr ""

#: ../../../driver-api/ntb.rst:73
msgid ""
"Typical scenario of the second type interface initialization would be: 1) "
"allocate a memory region, 2) somehow deliver a translated address to a peer "
"device, 3) peer puts the translated address to NTB config, 4) peer device "
"maps outbound memory window so to have access to the shared memory region."
msgstr ""

#: ../../../driver-api/ntb.rst:78
msgid ""
"As one can see the described scenarios can be combined in one portable "
"algorithm."
msgstr ""

#: ../../../driver-api/ntb.rst:81 ../../../driver-api/ntb.rst:96
msgid "Local device:"
msgstr ""

#: ../../../driver-api/ntb.rst:82
msgid "Allocate memory for a shared window"
msgstr ""

#: ../../../driver-api/ntb.rst:83
msgid ""
"Initialize memory window by translated address of the allocated region (it "
"may fail if local memory window initialization is unsupported)"
msgstr ""

#: ../../../driver-api/ntb.rst:85
msgid "Send the translated address and memory window index to a peer device"
msgstr ""

#: ../../../driver-api/ntb.rst:87 ../../../driver-api/ntb.rst:112
msgid "Peer device:"
msgstr ""

#: ../../../driver-api/ntb.rst:88
msgid ""
"Initialize memory window with retrieved address of the allocated by another "
"device memory region (it may fail if peer memory window initialization is "
"unsupported)"
msgstr ""

#: ../../../driver-api/ntb.rst:91
msgid "Map outbound memory window"
msgstr ""

#: ../../../driver-api/ntb.rst:93
msgid ""
"In accordance with this scenario, the NTB Memory Window API can be used as "
"follows:"
msgstr ""

#: ../../../driver-api/ntb.rst:97
msgid ""
"ntb_mw_count(pidx) - retrieve number of memory ranges, which can be "
"allocated for memory windows between local device and peer device of port "
"with specified index."
msgstr ""

#: ../../../driver-api/ntb.rst:100
msgid ""
"ntb_get_align(pidx, midx) - retrieve parameters restricting the shared "
"memory region alignment and size. Then memory can be properly allocated."
msgstr ""

#: ../../../driver-api/ntb.rst:103
msgid ""
"Allocate physically contiguous memory region in compliance with restrictions "
"retrieved in 2)."
msgstr ""

#: ../../../driver-api/ntb.rst:105
msgid ""
"ntb_mw_set_trans(pidx, midx) - try to set translation address of the memory "
"window with specified index for the defined peer device (it may fail if "
"local translated address setting is not supported)"
msgstr ""

#: ../../../driver-api/ntb.rst:108
msgid ""
"Send translated base address (usually together with memory window number) to "
"the peer device using, for instance, scratchpad or message registers."
msgstr ""

#: ../../../driver-api/ntb.rst:113
msgid ""
"ntb_peer_mw_set_trans(pidx, midx) - try to set received from other device "
"(related to pidx) translated address for specified memory window. It may "
"fail if retrieved address, for instance, exceeds maximum possible address or "
"isn't properly aligned."
msgstr ""

#: ../../../driver-api/ntb.rst:117
msgid ""
"ntb_peer_mw_get_addr(widx) - retrieve MMIO address to map the memory window "
"so to have an access to the shared memory."
msgstr ""

#: ../../../driver-api/ntb.rst:120
msgid ""
"Also it is worth to note, that method ntb_mw_count(pidx) should return the "
"same value as ntb_peer_mw_count() on the peer with port index - pidx."
msgstr ""

#: ../../../driver-api/ntb.rst:124
msgid "NTB Transport Client (ntb\\_transport) and NTB Netdev (ntb\\_netdev)"
msgstr ""

#: ../../../driver-api/ntb.rst:126
msgid ""
"The primary client for NTB is the Transport client, used in tandem with NTB "
"Netdev.  These drivers function together to create a logical link to the "
"peer, across the ntb, to exchange packets of network data.  The Transport "
"client establishes a logical link to the peer, and creates queue pairs to "
"exchange messages and data.  The NTB Netdev then creates an ethernet device "
"using a Transport queue pair.  Network data is copied between socket buffers "
"and the Transport queue pair buffer.  The Transport client may be used for "
"other things besides Netdev, however no other applications have yet been "
"written."
msgstr ""

#: ../../../driver-api/ntb.rst:136
msgid "NTB Ping Pong Test Client (ntb\\_pingpong)"
msgstr ""

#: ../../../driver-api/ntb.rst:138
msgid ""
"The Ping Pong test client serves as a demonstration to exercise the doorbell "
"and scratchpad registers of NTB hardware, and as an example simple NTB "
"client. Ping Pong enables the link when started, waits for the NTB link to "
"come up, and then proceeds to read and write the doorbell scratchpad "
"registers of the NTB. The peers interrupt each other using a bit mask of "
"doorbell bits, which is shifted by one in each round, to test the behavior "
"of multiple doorbell bits and interrupt vectors.  The Ping Pong driver also "
"reads the first local scratchpad, and writes the value plus one to the first "
"peer scratchpad, each round before writing the peer doorbell register."
msgstr ""

#: ../../../driver-api/ntb.rst:148 ../../../driver-api/ntb.rst:241
msgid "Module Parameters:"
msgstr ""

#: ../../../driver-api/ntb.rst:150
msgid "unsafe - Some hardware has known issues with scratchpad and doorbell"
msgstr ""

#: ../../../driver-api/ntb.rst:151
msgid ""
"registers.  By default, Ping Pong will not attempt to exercise such "
"hardware.  You may override this behavior at your own risk by setting "
"unsafe=1."
msgstr ""

#: ../../../driver-api/ntb.rst:154
msgid "delay\\_ms - Specify the delay between receiving a doorbell"
msgstr ""

#: ../../../driver-api/ntb.rst:155
msgid ""
"interrupt event and setting the peer doorbell register for the next round."
msgstr ""

#: ../../../driver-api/ntb.rst:157
msgid ""
"init\\_db - Specify the doorbell bits to start new series of rounds.  A new"
msgstr ""

#: ../../../driver-api/ntb.rst:158
msgid ""
"series begins once all the doorbell bits have been shifted out of range."
msgstr ""

#: ../../../driver-api/ntb.rst:160
msgid ""
"dyndbg - It is suggested to specify dyndbg=+p when loading this module, and"
msgstr ""

#: ../../../driver-api/ntb.rst:161
msgid "then to observe debugging output on the console."
msgstr ""

#: ../../../driver-api/ntb.rst:164
msgid "NTB Tool Test Client (ntb\\_tool)"
msgstr ""

#: ../../../driver-api/ntb.rst:166
msgid ""
"The Tool test client serves for debugging, primarily, ntb hardware and "
"drivers. The Tool provides access through debugfs for reading, setting, and "
"clearing the NTB doorbell, and reading and writing scratchpads."
msgstr ""

#: ../../../driver-api/ntb.rst:170
msgid "The Tool does not currently have any module parameters."
msgstr ""

#: ../../../driver-api/ntb.rst:172
msgid "Debugfs Files:"
msgstr ""

#: ../../../driver-api/ntb.rst:174
msgid "*debugfs*/ntb\\_tool/*hw*/"
msgstr ""

#: ../../../driver-api/ntb.rst:175
msgid ""
"A directory in debugfs will be created for each NTB device probed by the "
"tool.  This directory is shortened to *hw* below."
msgstr ""

#: ../../../driver-api/ntb.rst:178
msgid "*hw*/db"
msgstr ""

#: ../../../driver-api/ntb.rst:179
msgid ""
"This file is used to read, set, and clear the local doorbell.  Not all "
"operations may be supported by all hardware.  To read the doorbell, read the "
"file.  To set the doorbell, write `s` followed by the bits to set (eg: `echo "
"'s 0x0101' > db`).  To clear the doorbell, write `c` followed by the bits to "
"clear."
msgstr ""

#: ../../../driver-api/ntb.rst:184
msgid "*hw*/mask"
msgstr ""

#: ../../../driver-api/ntb.rst:185
msgid ""
"This file is used to read, set, and clear the local doorbell mask. See *db* "
"for details."
msgstr ""

#: ../../../driver-api/ntb.rst:187
msgid "*hw*/peer\\_db"
msgstr ""

#: ../../../driver-api/ntb.rst:188
msgid ""
"This file is used to read, set, and clear the peer doorbell. See *db* for "
"details."
msgstr ""

#: ../../../driver-api/ntb.rst:190
msgid "*hw*/peer\\_mask"
msgstr ""

#: ../../../driver-api/ntb.rst:191
msgid ""
"This file is used to read, set, and clear the peer doorbell mask.  See *db* "
"for details."
msgstr ""

#: ../../../driver-api/ntb.rst:193
msgid "*hw*/spad"
msgstr ""

#: ../../../driver-api/ntb.rst:194
msgid ""
"This file is used to read and write local scratchpads.  To read the values "
"of all scratchpads, read the file.  To write values, write a series of pairs "
"of scratchpad number and value (eg: `echo '4 0x123 7 0xabc' > spad` # to set "
"scratchpads `4` and `7` to `0x123` and `0xabc`, respectively)."
msgstr ""

#: ../../../driver-api/ntb.rst:199
msgid "*hw*/peer\\_spad"
msgstr ""

#: ../../../driver-api/ntb.rst:200
msgid ""
"This file is used to read and write peer scratchpads.  See *spad* for "
"details."
msgstr ""

#: ../../../driver-api/ntb.rst:204
msgid "NTB MSI Test Client (ntb\\_msi\\_test)"
msgstr ""

#: ../../../driver-api/ntb.rst:206
msgid ""
"The MSI test client serves to test and debug the MSI library which allows "
"for passing MSI interrupts across NTB memory windows. The test client is "
"interacted with through the debugfs filesystem:"
msgstr ""

#: ../../../driver-api/ntb.rst:210
msgid "*debugfs*/ntb\\_msi\\_test/*hw*/"
msgstr ""

#: ../../../driver-api/ntb.rst:211
msgid ""
"A directory in debugfs will be created for each NTB device probed by the msi "
"test.  This directory is shortened to *hw* below."
msgstr ""

#: ../../../driver-api/ntb.rst:214
msgid "*hw*/port"
msgstr ""

#: ../../../driver-api/ntb.rst:215
msgid "This file describes the local port number"
msgstr ""

#: ../../../driver-api/ntb.rst:216
msgid "*hw*/irq*_occurrences"
msgstr ""

#: ../../../driver-api/ntb.rst:217
msgid ""
"One occurrences file exists for each interrupt and, when read, returns the "
"number of times the interrupt has been triggered."
msgstr ""

#: ../../../driver-api/ntb.rst:219
msgid "*hw*/peer*/port"
msgstr ""

#: ../../../driver-api/ntb.rst:220
msgid "This file describes the port number for each peer"
msgstr ""

#: ../../../driver-api/ntb.rst:221
msgid "*hw*/peer*/count"
msgstr ""

#: ../../../driver-api/ntb.rst:222
msgid ""
"This file describes the number of interrupts that can be triggered on each "
"peer"
msgstr ""

#: ../../../driver-api/ntb.rst:224
msgid "*hw*/peer*/trigger"
msgstr ""

#: ../../../driver-api/ntb.rst:225
msgid ""
"Writing an interrupt number (any number less than the value specified in "
"count) will trigger the interrupt on the specified peer. That peer's "
"interrupt's occurrence file should be incremented."
msgstr ""

#: ../../../driver-api/ntb.rst:231
msgid "NTB Hardware Drivers"
msgstr ""

#: ../../../driver-api/ntb.rst:233
msgid ""
"NTB hardware drivers should register devices with the NTB core driver.  "
"After registering, clients probe and remove functions will be called."
msgstr ""

#: ../../../driver-api/ntb.rst:237
msgid "NTB Intel Hardware Driver (ntb\\_hw\\_intel)"
msgstr ""

#: ../../../driver-api/ntb.rst:239
msgid "The Intel hardware driver supports NTB on Xeon and Atom CPUs."
msgstr ""

#: ../../../driver-api/ntb.rst:243
msgid "b2b\\_mw\\_idx"
msgstr ""

#: ../../../driver-api/ntb.rst:244
msgid ""
"If the peer ntb is to be accessed via a memory window, then use this memory "
"window to access the peer ntb.  A value of zero or positive starts from the "
"first mw idx, and a negative value starts from the last mw idx.  Both sides "
"MUST set the same value here!  The default value is `-1`."
msgstr ""

#: ../../../driver-api/ntb.rst:249
msgid "b2b\\_mw\\_share"
msgstr ""

#: ../../../driver-api/ntb.rst:250
msgid ""
"If the peer ntb is to be accessed via a memory window, and if the memory "
"window is large enough, still allow the client to use the second half of the "
"memory window for address translation to the peer."
msgstr ""

#: ../../../driver-api/ntb.rst:253
msgid "xeon\\_b2b\\_usd\\_bar2\\_addr64"
msgstr ""

#: ../../../driver-api/ntb.rst:254
msgid ""
"If using B2B topology on Xeon hardware, use this 64 bit address on the bus "
"between the NTB devices for the window at BAR2, on the upstream side of the "
"link."
msgstr ""

#: ../../../driver-api/ntb.rst:257
msgid "xeon\\_b2b\\_usd\\_bar4\\_addr64 - See *xeon\\_b2b\\_bar2\\_addr64*."
msgstr ""

#: ../../../driver-api/ntb.rst:258
msgid "xeon\\_b2b\\_usd\\_bar4\\_addr32 - See *xeon\\_b2b\\_bar2\\_addr64*."
msgstr ""

#: ../../../driver-api/ntb.rst:259
msgid "xeon\\_b2b\\_usd\\_bar5\\_addr32 - See *xeon\\_b2b\\_bar2\\_addr64*."
msgstr ""

#: ../../../driver-api/ntb.rst:260
msgid "xeon\\_b2b\\_dsd\\_bar2\\_addr64 - See *xeon\\_b2b\\_bar2\\_addr64*."
msgstr ""

#: ../../../driver-api/ntb.rst:261
msgid "xeon\\_b2b\\_dsd\\_bar4\\_addr64 - See *xeon\\_b2b\\_bar2\\_addr64*."
msgstr ""

#: ../../../driver-api/ntb.rst:262
msgid "xeon\\_b2b\\_dsd\\_bar4\\_addr32 - See *xeon\\_b2b\\_bar2\\_addr64*."
msgstr ""

#: ../../../driver-api/ntb.rst:263
msgid "xeon\\_b2b\\_dsd\\_bar5\\_addr32 - See *xeon\\_b2b\\_bar2\\_addr64*."
msgstr ""
