# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:5
msgid "BIOS/EFI Configuration"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:7
msgid ""
"BIOS and EFI are largely responsible for configuring static information "
"about devices (or potential future devices) such that Linux can build the "
"appropriate logical representations of these devices."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:11
msgid ""
"At a high level, this is what occurs during this phase of configuration."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:13
msgid "The bootloader starts the BIOS/EFI."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:15
msgid "BIOS/EFI do early device probe to determine static configuration"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:17
msgid "BIOS/EFI creates ACPI Tables that describe static config for the OS"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:19
msgid "BIOS/EFI create the system memory map (EFI Memory Map, E820, etc)"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:21
msgid ""
"BIOS/EFI calls :code:`start_kernel` and begins the Linux Early Boot process."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:23
msgid ""
"Much of what this section is concerned with is ACPI Table production and "
"static memory map configuration. More detail on these tables can be found "
"at :doc:`ACPI Tables <acpi>`."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:28
msgid ""
"Platform Vendors should read carefully, as this sections has recommendations "
"on physical memory region size and alignment, memory holes, HDM interleave, "
"and what linux expects of HDM decoders trying to work with these features."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:33
msgid "UEFI Settings"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:34
msgid ""
"If your platform supports it, the :code:`uefisettings` command can be used "
"to read/write EFI settings. Changes will be reflected on the next reboot. "
"Kexec is not a sufficient reboot."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:38
msgid ""
"One notable configuration here is the EFI_MEMORY_SP (Specific Purpose) bit. "
"When this is enabled, this bit tells linux to defer management of a memory "
"region to a driver (in this case, the CXL driver). Otherwise, the memory is "
"treated as \"normal memory\", and is exposed to the page allocator during :"
"code:`__init`."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:45
msgid "uefisettings examples"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:47
msgid ":code:`uefisettings identify` ::"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:59
msgid ""
"On some AMD platforms, the :code:`EFI_MEMORY_SP` bit is set via the :code:"
"`CXL Memory Attribute` field.  This may be called something else on your "
"platform."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:62
msgid ":code:`uefisettings get \"CXL Memory Attribute\"` ::"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:73
msgid "Physical Memory Map"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:76
msgid "Physical Address Region Alignment"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:78
msgid ""
"As of Linux v6.14, the hotplug memory system requires memory regions to be "
"uniform in size and alignment.  While the CXL specification allows for "
"memory regions as small as 256MB, the supported memory block size and "
"alignment for hotplugged memory is architecture-defined."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:83
msgid ""
"A Linux memory blocks may be as small as 128MB and increase in powers of two."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:85
msgid "On ARM, the default block size and alignment is either 128MB or 256MB."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:87
msgid ""
"On x86, the default block size is 256MB, and increases to 2GB as the "
"capacity of the system increases up to 64GB."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:90
msgid ""
"For best support across versions, platform vendors should place CXL memory "
"at a 2GB aligned base address, and regions should be 2GB aligned.  This also "
"helps prevent the creating thousands of memory devices (one per block)."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:95
#: ../../../driver-api/cxl/platform/bios-and-efi.rst:204
msgid "Memory Holes"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:97
msgid ""
"Holes in the memory map are tricky.  Consider a 4GB device located at base "
"address 0x100000000, but with the following memory map ::"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:114
msgid "There are two issues to consider:"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:116
msgid "decoder programming, and"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:117
msgid "memory block alignment."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:119
msgid ""
"If your architecture requires 2GB uniform size and aligned memory blocks, "
"the only capacity Linux is capable of mapping (as of v6.14) would be the "
"capacity from `0x100000000-0x180000000`.  The remaining capacity will be "
"stranded, as they are not of 2GB aligned length."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:124
msgid ""
"Assuming your architecture and memory configuration allows 1GB memory "
"blocks, this memory map is supported and this should be presented as "
"multiple CFMWS in the CEDT that describe each side of the memory hole "
"separately - along with matching decoders."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:129
msgid ""
"Multiple decoders can (and should) be used to manage such a memory hole (see "
"below), but each chunk of a memory hole should be aligned to a reasonable "
"block size (larger alignment is always better).  If you intend to have "
"memory holes in the memory map, expect to use one decoder per contiguous "
"chunk of host physical memory."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:135
msgid ""
"As of v6.14, Linux does provide support for memory hotplug of multiple "
"physical memory regions separated by a memory hole described by a single HDM "
"decoder."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:141
msgid "Decoder Programming"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:142
msgid ""
"If BIOS/EFI intends to program the decoders to be statically configured, "
"there are a few things to consider to avoid major pitfalls that will prevent "
"Linux compatibility.  Some of these recommendations are not required \"per "
"the specification\", but Linux makes no guarantees of support otherwise."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:150
msgid "Translation Point"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:151
msgid ""
"Per the specification, the only decoders which **TRANSLATE** Host Physical "
"Address (HPA) to Device Physical Address (DPA) are the **Endpoint "
"Decoders**. All other decoders in the fabric are intended to route accesses "
"without translating the addresses."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:156
msgid "This is heavily implied by the specification, see: ::"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:163
msgid ""
"Given this, Linux makes a strong assumption that decoders between CPU and "
"endpoint will all be programmed with addresses ranges that are subsets of "
"their parent decoder."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:167
msgid ""
"Due to some ambiguity in how Architecture, ACPI, PCI, and CXL specifications "
"\"hand off\" responsibility between domains, some early adopting platforms "
"attempted to do translation at the originating memory controller or host "
"bridge.  This configuration requires a platform specific extension to the "
"driver and is not officially endorsed - despite being supported."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:173
msgid ""
"It is *highly recommended* **NOT** to do this; otherwise, you are on your "
"own to implement driver support for your platform."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:177
msgid "Interleave and Configuration Flexibility"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:178
msgid ""
"If providing cross-host-bridge interleave, a CFMWS entry in the :doc:`CEDT "
"<acpi/cedt>` must be presented with target host-bridges for the interleaved "
"device sets (there may be multiple behind each host bridge)."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:182
msgid ""
"If providing intra-host-bridge interleaving, only 1 CFMWS entry in the CEDT "
"is required for that host bridge - if it covers the entire capacity of the "
"devices behind the host bridge."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:186
msgid ""
"If intending to provide users flexibility in programming decoders beyond the "
"root, you may want to provide multiple CFMWS entries in the CEDT intended "
"for different purposes.  For example, you may want to consider adding:"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:190
msgid "A CFMWS entry to cover all interleavable host bridges."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:191
msgid "A CFMWS entry to cover all devices on a single host bridge."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:192
msgid "A CFMWS entry to cover each device."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:194
msgid ""
"A platform may choose to add all of these, or change the mode based on a "
"BIOS setting.  For each CFMWS entry, Linux expects descriptions of the "
"described memory regions in the :doc:`SRAT <acpi/srat>` to determine the "
"number of NUMA nodes it should reserve during early boot / init."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:199
msgid ""
"As of v6.14, Linux will create a NUMA node for each CEDT CFMWS entry, even "
"if a matching SRAT entry does not exist; however, this is not guaranteed in "
"the future and such a configuration should be avoided."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:205
msgid ""
"If your platform includes memory holes interspersed between your CXL memory, "
"it is recommended to utilize multiple decoders to cover these regions of "
"memory, rather than try to program the decoders to accept the entire range "
"and expect Linux to manage the overlap."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:210
msgid "For example, consider the Memory Hole described above ::"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:226
msgid ""
"Assuming this is provided by a single device attached directly to a host "
"bridge, Linux would expect the following decoder programming ::"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:247
msgid ""
"With a CEDT configuration with two CFMWS describing the above root decoders."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:249
msgid "Linux makes no guarantee of support for strange memory hole situations."
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:252
msgid "Multi-Media Devices"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:253
msgid ""
"The CFMWS field of the CEDT has special restriction bits which describe "
"whether the described memory region allows volatile or persistent memory (or "
"both). If the platform intends to support either:"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:257
msgid "A device with multiple medias, or"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:258
msgid "Using a persistent memory device as normal memory"
msgstr ""

#: ../../../driver-api/cxl/platform/bios-and-efi.rst:260
msgid ""
"A platform may wish to create multiple CEDT CFMWS entries to describe the "
"same memory, with the intent of allowing the end user flexibility in how "
"that memory is configured. Linux does not presently have strong requirements "
"in this area."
msgstr ""
