# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-21 08:55+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/serial/driver.rst:3
msgid "Low Level Serial API"
msgstr ""

#: ../../../driver-api/serial/driver.rst:6
msgid ""
"This document is meant as a brief overview of some aspects of the new serial "
"driver.  It is not complete, any questions you have should be directed to "
"<rmk@arm.linux.org.uk>"
msgstr ""

#: ../../../driver-api/serial/driver.rst:10
msgid "The reference implementation is contained within amba-pl011.c."
msgstr ""

#: ../../../driver-api/serial/driver.rst:15
msgid "Low Level Serial Hardware Driver"
msgstr ""

#: ../../../driver-api/serial/driver.rst:17
msgid ""
"The low level serial hardware driver is responsible for supplying port "
"information (defined by uart_port) and a set of control methods (defined by "
"uart_ops) to the core serial driver.  The low level driver is also "
"responsible for handling interrupts for the port, and providing any console "
"support."
msgstr ""

#: ../../../driver-api/serial/driver.rst:25
msgid "Console Support"
msgstr ""

#: ../../../driver-api/serial/driver.rst:27
msgid ""
"The serial core provides a few helper functions.  This includes decoding "
"command line arguments (uart_parse_options())."
msgstr ""

#: ../../../driver-api/serial/driver.rst:30
msgid ""
"There is also a helper function (uart_console_write()) which performs a "
"character by character write, translating newlines to CRLF sequences. Driver "
"writers are recommended to use this function rather than implementing their "
"own version."
msgstr ""

#: ../../../driver-api/serial/driver.rst:37
msgid "Locking"
msgstr ""

#: ../../../driver-api/serial/driver.rst:39
msgid ""
"It is the responsibility of the low level hardware driver to perform the "
"necessary locking using port->lock.  There are some exceptions (which are "
"described in the struct uart_ops listing below.)"
msgstr ""

#: ../../../driver-api/serial/driver.rst:43
msgid "There are two locks.  A per-port spinlock, and an overall semaphore."
msgstr ""

#: ../../../driver-api/serial/driver.rst:45
msgid ""
"From the core driver perspective, the port->lock locks the following data::"
msgstr ""

#: ../../../driver-api/serial/driver.rst:53
msgid ""
"The low level driver is free to use this lock to provide any additional "
"locking."
msgstr ""

#: ../../../driver-api/serial/driver.rst:56
msgid ""
"The port_sem semaphore is used to protect against ports being added/ removed "
"or reconfigured at inappropriate times. Since v2.6.27, this semaphore has "
"been the 'mutex' member of the tty_port struct, and commonly referred to as "
"the port mutex."
msgstr ""

#: ../../../driver-api/serial/driver.rst:63
msgid "uart_ops"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:37
msgid "interface between serial_core and the driver"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:41
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:75
msgid "**Members**"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:42
msgid "``tx_empty``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:43
#: include/linux/serial_core.h:73
msgid "``unsigned int ()(struct uart_port *port)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:53
msgid "``set_mctrl``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:54
msgid "``void ()(struct uart_port *port, unsigned int mctrl)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:72
msgid "``get_mctrl``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:92
msgid "``stop_tx``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:93
#: include/linux/serial_core.h:105 include/linux/serial_core.h:113
#: include/linux/serial_core.h:123 include/linux/serial_core.h:147
#: include/linux/serial_core.h:155 include/linux/serial_core.h:163
#: include/linux/serial_core.h:193 include/linux/serial_core.h:207
#: include/linux/serial_core.h:297
msgid "``void ()(struct uart_port *port)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:104
msgid "``start_tx``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:112
msgid "``throttle``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:122
msgid "``unthrottle``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:133
msgid "``send_xchar``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:134
msgid "``void ()(struct uart_port *port, char ch)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:154
msgid "``stop_rx``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:146
msgid "``start_rx``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:162
msgid "``enable_ms``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:173
msgid "``break_ctl``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:174
msgid "``void ()(struct uart_port *port, int ctl)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:181
msgid "``startup``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:182
#: include/linux/serial_core.h:305 include/linux/serial_core.h:348
#: include/linux/serial_core.h:366
msgid "``int ()(struct uart_port *port)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:192
msgid "``shutdown``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:206
msgid "``flush_buffer``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:218
msgid "``set_termios``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:219
msgid ""
"``void ()(struct uart_port *port, struct ktermios *new, struct ktermios "
"*old)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:265
msgid "``set_ldisc``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:266
msgid "``void ()(struct uart_port *port, struct ktermios *termios)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:272
msgid "``pm``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:273
msgid ""
"``void ()(struct uart_port *port, unsigned int state, unsigned int "
"oldstate)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:288
msgid "``type``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:289
msgid "``const char *()(struct uart_port *port)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:296
msgid "``release_port``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:304
msgid "``request_port``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:313
msgid "``config_port``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:314
msgid "``void ()(struct uart_port *port, int type)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:329
msgid "``verify_port``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:330
msgid "``int ()(struct uart_port *port, struct serial_struct *serinfo)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:338
msgid "``ioctl``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:339
msgid "``int ()(struct uart_port *port, unsigned int cmd, unsigned long arg)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:347
msgid "``poll_init``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:356
msgid "``poll_put_char``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:357
msgid "``void ()(struct uart_port *port, unsigned char ch)``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:365
msgid "``poll_get_char``"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:50
#: drivers/tty/serial/serial_mctrl_gpio.c:95
#: drivers/tty/serial/serial_mctrl_gpio.c:218
#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:369
#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:106
#: drivers/tty/serial/serial_core.c:438 drivers/tty/serial/serial_core.c:463
#: drivers/tty/serial/serial_core.c:561 drivers/tty/serial/serial_core.c:2121
#: drivers/tty/serial/serial_core.c:2183 drivers/tty/serial/serial_core.c:2214
#: drivers/tty/serial/serial_core.c:2725 drivers/tty/serial/serial_core.c:2801
#: drivers/tty/serial/serial_core.c:3212 drivers/tty/serial/serial_core.c:3378
#: drivers/tty/serial/serial_core.c:3413 drivers/tty/serial/serial_core.c:3488
#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:962
#: include/linux/serial_core.h:1010
msgid "**Description**"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:38
msgid ""
"This structure describes all the operations that can be done on the physical "
"hardware."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:42
msgid ""
"This function tests whether the transmitter fifo and shifter for the "
"**port** is empty. If it is empty, this function should return "
"``TIOCSER_TEMT``, otherwise return 0. If the port does not support this "
"operation, then it should return ``TIOCSER_TEMT``."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:47
#: include/linux/serial_core.h:330 include/linux/serial_core.h:339
msgid "Locking: none. Interrupts: caller dependent. This call must not sleep"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:52
msgid ""
"This function sets the modem control lines for **port** to the state "
"described by **mctrl**. The relevant bits of **mctrl** are:"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:55
msgid "``TIOCM_RTS``    RTS signal."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:56
msgid "``TIOCM_DTR``    DTR signal."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:57
msgid "``TIOCM_OUT1``   OUT1 signal."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:58
msgid "``TIOCM_OUT2``   OUT2 signal."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:59
msgid "``TIOCM_LOOP``   Set the port into loopback mode."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:61
msgid ""
"If the appropriate bit is set, the signal should be driven active.  If the "
"bit is clear, the signal should be driven inactive."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:65
#: include/linux/serial_core.h:84 include/linux/serial_core.h:95
#: include/linux/serial_core.h:102 include/linux/serial_core.h:140
#: include/linux/serial_core.h:147 include/linux/serial_core.h:157
#: include/linux/serial_core.h:198
msgid ""
"Locking: **port->lock** taken. Interrupts: locally disabled. This call must "
"not sleep"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:70
msgid ""
"Returns the current state of modem control inputs of **port**. The state of "
"the outputs should not be returned, since the core keeps track of their "
"state. The state information should include:"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:74
msgid "``TIOCM_CAR``    state of DCD signal"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:75
msgid "``TIOCM_CTS``    state of CTS signal"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:76
msgid "``TIOCM_DSR``    state of DSR signal"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:77
msgid "``TIOCM_RI``     state of RI signal"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:79
msgid ""
"The bit is set if the signal is currently driven active.  If the port does "
"not support CTS, DCD or DSR, the driver should indicate that the signal is "
"permanently active. If RI is not available, the signal should not be "
"indicated as active."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:89
msgid ""
"Stop transmitting characters. This might be due to the CTS line becoming "
"inactive or the tty layer indicating we want to stop transmission due to an "
"``XOFF`` character."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:93
msgid "The driver should stop transmitting characters as soon as possible."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:100
msgid "Start transmitting characters."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:107
msgid ""
"Notify the serial driver that input buffers for the line discipline are "
"close to full, and it should somehow signal that no more characters should "
"be sent to the serial port. This will be called only if hardware assisted "
"flow control is enabled."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:112
msgid ""
"Locking: serialized with **unthrottle\\(\\)** and termios modification by "
"the tty layer."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:116
msgid ""
"Notify the serial driver that characters can now be sent to the serial port "
"without fear of overrunning the input buffers of the line disciplines."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:120
msgid "This will be called only if hardware assisted flow control is enabled."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:122
msgid ""
"Locking: serialized with **throttle\\(\\)** and termios modification by the "
"tty layer."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:126
msgid ""
"Transmit a high priority character, even if the port is stopped. This is "
"used to implement XON/XOFF flow control and tcflow(). If the serial driver "
"does not implement this function, the tty core will append the character to "
"the circular buffer and then call start_tx() / stop_tx() to flush the data "
"out."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:132
msgid "Do not transmit if **ch** == '\\0' (``__DISABLED_CHAR``)."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:134
#: include/linux/serial_core.h:264 include/linux/serial_core.h:271
#: include/linux/serial_core.h:278 include/linux/serial_core.h:286
#: include/linux/serial_core.h:301 include/linux/serial_core.h:308
#: include/linux/serial_core.h:315
msgid "Locking: none. Interrupts: caller dependent."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:138
msgid "Start receiving characters."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:145
msgid ""
"Stop receiving characters; the **port** is in the process of being closed."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:152
msgid "Enable the modem status interrupts."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:154
msgid ""
"This method may be called multiple times. Modem status interrupts should be "
"disabled when the **shutdown\\(\\)** method is called."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:162
msgid ""
"Control the transmission of a break signal. If **ctl** is nonzero, the break "
"signal should be transmitted. The signal should be terminated when another "
"call is made with a zero **ctl**."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:166
#: include/linux/serial_core.h:251
msgid "Locking: caller holds tty_port->mutex"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:169
msgid ""
"Grab any interrupt resources and initialise any low level driver state. "
"Enable the port for reception. It should not activate RTS nor DTR; this will "
"be done via a separate call to **set_mctrl\\(\\)**."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:173
msgid "This method will only be called when the port is initially opened."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:175
msgid "Locking: port_sem taken. Interrupts: globally disabled."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:179
msgid ""
"Disable the **port**, disable any break condition that may be in effect, and "
"free any interrupt resources. It should not disable RTS nor DTR; this will "
"have already been done via a separate call to **set_mctrl\\(\\)**."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:183
msgid "Drivers must not access **port->state** once this call has completed."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:185
msgid ""
"This method will only be called when there are no more users of this "
"**port**."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:188
msgid "Locking: port_sem taken. Interrupts: caller dependent."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:192
msgid ""
"Flush any write buffers, reset any DMA state and stop any ongoing DMA "
"transfers."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:195
msgid ""
"This will be called whenever the **port->state->xmit** circular buffer is "
"cleared."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:203
msgid ""
"Change the **port** parameters, including word length, parity, stop bits. "
"Update **port->read_status_mask** and **port->ignore_status_mask** to "
"indicate the types of events we are interested in receiving. Relevant "
"ktermios::c_cflag bits are:"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:208
msgid "``CSIZE`` - word size"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:209
msgid "``CSTOPB`` - 2 stop bits"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:210
msgid "``PARENB`` - parity enable"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:211
msgid "``PARODD`` - odd parity (when ``PARENB`` is in force)"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:212
msgid "``ADDRB`` - address bit (changed through uart_port::rs485_config())."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:213
msgid ""
"``CREAD`` - enable reception of characters (if not set, still receive "
"characters from the port, but throw them away)."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:215
msgid "``CRTSCTS`` - if set, enable CTS status change reporting."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:216
msgid "``CLOCAL`` - if not set, enable modem status change reporting."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:218
msgid "Relevant ktermios::c_iflag bits are:"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:220
msgid ""
"``INPCK`` - enable frame and parity error events to be passed to the TTY "
"layer."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:222
msgid ""
"``BRKINT`` / ``PARMRK`` - both of these enable break events to be passed to "
"the TTY layer."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:224
msgid "``IGNPAR`` - ignore parity and framing errors."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:225
msgid ""
"``IGNBRK`` - ignore break errors. If ``IGNPAR`` is also set, ignore overrun "
"errors as well."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:228
msgid ""
"The interaction of the ktermios::c_iflag bits is as follows (parity error "
"given as an example):"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:232
msgid "Parity error"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:232
msgid "INPCK"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:232
msgid "IGNPAR"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:234
#: include/linux/serial_core.h:235
msgid "n/a"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:234
#: include/linux/serial_core.h:236
msgid "0"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:234
#: include/linux/serial_core.h:235
msgid "character received, marked as ``TTY_NORMAL``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:235
msgid "None"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:235
#: include/linux/serial_core.h:236 include/linux/serial_core.h:237
msgid "1"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:236
#: include/linux/serial_core.h:237
msgid "Yes"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:236
msgid "character received, marked as ``TTY_PARITY``"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:237
msgid "character discarded"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:240
msgid ""
"Other flags may be used (eg, xon/xoff characters) if your hardware supports "
"hardware \"soft\" flow control."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:243
msgid ""
"Locking: caller holds tty_port->mutex Interrupts: caller dependent. This "
"call must not sleep"
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:248
msgid ""
"Notifier for discipline change. See Documentation/driver-api/tty/tty_ldisc."
"rst."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:254
msgid ""
"Perform any power management related activities on the specified **port**. "
"**state** indicates the new state (defined by enum uart_pm_state), "
"**oldstate** indicates the previous state."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:258
msgid "This function should not be used to grab any resources."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:260
msgid ""
"This will be called when the **port** is initially opened and finally "
"closed, except when the **port** is also the system console. This will occur "
"even if ``CONFIG_PM`` is not set."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:268
msgid ""
"Return a pointer to a string constant describing the specified **port**, or "
"return ``NULL``, in which case the string 'unknown' is substituted."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:275
msgid ""
"Release any memory and IO region resources currently in use by the **port**."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:282
msgid ""
"Request any memory and IO region resources required by the port. If any "
"fail, no resources should be registered when this function returns, and it "
"should return -``EBUSY`` on failure."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:290
msgid ""
"Perform any autoconfiguration steps required for the **port**. **type** "
"contains a bit mask of the required configuration. ``UART_CONFIG_TYPE`` "
"indicates that the port requires detection and identification. **port-"
">type** should be set to the type found, or ``PORT_UNKNOWN`` if no port was "
"detected."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:296
msgid ""
"``UART_CONFIG_IRQ`` indicates autoconfiguration of the interrupt signal, "
"which should be probed using standard kernel autoprobing techniques. This is "
"not necessary on platforms where ports have interrupts internally hard wired "
"(eg, system on a chip implementations)."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:305
msgid ""
"Verify the new serial port information contained within **serinfo** is "
"suitable for this port type."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:312
msgid ""
"Perform any port specific IOCTLs. IOCTL commands must be defined using the "
"standard numbering system found in <asm/ioctl.h>."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:319
msgid ""
"Called by kgdb to perform the minimal hardware initialization needed to "
"support **poll_put_char\\(\\)** and **poll_get_char\\(\\)**. Unlike "
"**startup\\(\\)**, this should not request interrupts."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:323
msgid "Locking: ``tty_mutex`` and tty_port->mutex taken. Interrupts: n/a."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:327
msgid ""
"Called by kgdb to write a single character **ch** directly to the serial "
"**port**. It can and should block until there is space in the TX FIFO."
msgstr ""

#: ../../../driver-api/serial/driver:65: include/linux/serial_core.h:335
msgid ""
"Called by kgdb to read a single character directly from the serial port. If "
"data is available, it should be returned; otherwise the function should "
"return ``NO_POLL_CHAR`` immediately."
msgstr ""

#: ../../../driver-api/serial/driver.rst:69
msgid "Other functions"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:103
msgid "schedule write processing"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:50
#: drivers/tty/serial/serial_mctrl_gpio.c:78
#: drivers/tty/serial/serial_mctrl_gpio.c:94
#: drivers/tty/serial/serial_mctrl_gpio.c:218
#: drivers/tty/serial/serial_mctrl_gpio.c:275
#: drivers/tty/serial/serial_mctrl_gpio.c:327
#: drivers/tty/serial/serial_mctrl_gpio.c:338
#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:107
#: drivers/tty/serial/serial_core.c:437 drivers/tty/serial/serial_core.c:460
#: drivers/tty/serial/serial_core.c:561 drivers/tty/serial/serial_core.c:1059
#: drivers/tty/serial/serial_core.c:2098 drivers/tty/serial/serial_core.c:2119
#: drivers/tty/serial/serial_core.c:2180 drivers/tty/serial/serial_core.c:2210
#: drivers/tty/serial/serial_core.c:2726 drivers/tty/serial/serial_core.c:2802
#: drivers/tty/serial/serial_core.c:3212 drivers/tty/serial/serial_core.c:3378
#: drivers/tty/serial/serial_core.c:3413 drivers/tty/serial/serial_core.c:3488
#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:958
#: include/linux/serial_core.h:1008
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:220
#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:109
#: drivers/tty/serial/serial_core.c:439 drivers/tty/serial/serial_core.c:462
#: drivers/tty/serial/serial_core.c:563 drivers/tty/serial/serial_core.c:2100
#: drivers/tty/serial/serial_core.c:2212 drivers/tty/serial/serial_core.c:3490
msgid "``struct uart_port *port``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:104
msgid "port to be processed"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:105
msgid ""
"This routine is used by the interrupt handler to schedule processing in the "
"software interrupt portion of the driver. A driver is expected to call this "
"function when the number of characters in the transmit buffer have dropped "
"below a threshold."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:110
msgid "Locking: **port->lock** should be held"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:433
msgid "update per-port frame timing information"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:434
#: drivers/tty/serial/serial_core.c:558
msgid "uart_port structure describing the port"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:436
msgid "``unsigned int cflag``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:435
msgid "termios cflag value"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:437
#: drivers/tty/serial/serial_core.c:560
msgid "``unsigned int baud``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:436
msgid "speed of the port"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:437
msgid ""
"Set the **port** frame timing information from which the FIFO timeout value "
"is derived. The **cflag** value should reflect the actual hardware settings "
"as number of bits, parity, stop bits and baud rate is taken into account "
"here."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:441
msgid "Locking: caller is expected to take **port->lock**"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:456
msgid "return baud rate for a particular port"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:457
msgid "uart_port structure describing the port in question."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:459
msgid "``struct ktermios *termios``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:458
msgid "desired termios settings"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:460
msgid "``const struct ktermios *old``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:459
msgid "old termios (or ``NULL``)"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:461
msgid "``unsigned int min``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:460
msgid "minimum acceptable baud rate"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:462
msgid "``unsigned int max``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:461
msgid "maximum acceptable baud rate"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:462
msgid ""
"Decode the termios structure into a numeric baud rate, taking account of the "
"magic 38400 baud rate (with spd_* flags), and mapping the ``B0`` rate to "
"9600 baud."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:466
msgid ""
"If the new baud rate is invalid, try the **old** termios setting. If it's "
"still invalid, we try 9600 baud. If that is also invalid 0 is returned."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:469
msgid ""
"The **termios** structure is updated to reflect the baud rate we're actually "
"going to be using. Don't do this for the case where B0 is requested (\"hang "
"up\")."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:473
#: drivers/tty/serial/serial_core.c:566
msgid "Locking: caller dependent"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:557
msgid "return uart clock divisor"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:559
msgid "desired baud rate"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:560
msgid ""
"Calculate the divisor (baud_base / baud) for the specified **baud**, "
"appropriately rounded."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:563
msgid ""
"If 38400 baud and custom divisor is selected, return the custom divisor "
"instead."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:1055
msgid "get line status register info"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:1061
msgid "``struct tty_struct *tty``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:1056
msgid "tty associated with the UART"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:1058
msgid "``struct uart_state *state``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:1057
msgid "UART being queried"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:1059
msgid "``unsigned int __user *value``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:1058
msgid "returned modem value"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2094
msgid "write a console message to a serial port"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2095
msgid "the port to write the message"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2097
msgid "``const char *s``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2096
msgid "array of characters"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2098
msgid "``unsigned int count``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2097
msgid "number of characters in string to write"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2099
msgid "``void (*putchar)(struct uart_port *, unsigned char)``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2098
msgid "function to write character to port"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2115
msgid "Parse earlycon options"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2121
msgid "``char *p``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2116
msgid "ptr to 2nd field (ie., just beyond '<name>,')"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2118
msgid "``enum uart_iotype *iotype``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2117
msgid "ptr for decoded iotype (out)"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2119
msgid "``resource_size_t *addr``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2118
msgid "ptr for decoded mapbase/iobase (out)"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2120
msgid "``char **options``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2119
msgid "ptr for <options> field; ``NULL`` if not present (out)"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2120
msgid "Decodes earlycon kernel command line parameters of the form:"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2121
msgid ""
"earlycon=<name>,io|mmio|mmio16|mmio32|mmio32be|mmio32native,<addr>,<options>"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2122
msgid ""
"console=<name>,io|mmio|mmio16|mmio32|mmio32be|mmio32native,<addr>,<options>"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2124
msgid "The optional form:"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2125
msgid "earlycon=<name>,0x<addr>,<options>"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2126
msgid "console=<name>,0x<addr>,<options>"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2128
msgid "is also accepted; the returned **iotype** will be ``UPIO_MEM``."
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:78
#: drivers/tty/serial/serial_mctrl_gpio.c:94
#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2130
#: drivers/tty/serial/serial_core.c:3490 ../../../driver-api/serial/driver:80:
#: include/linux/serial_core.h:977
msgid "**Return**"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2131
msgid "0 on success or -``EINVAL`` on failure"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2176
msgid "Parse serial port baud/parity/bits/flow control."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2182
msgid "``const char *options``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2177
msgid "pointer to option string"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2179
msgid "``int *baud``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2178
msgid "pointer to an 'int' variable for the baud rate."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2180
msgid "``int *parity``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2179
msgid "pointer to an 'int' variable for the parity."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2181
msgid "``int *bits``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2180
msgid "pointer to an 'int' variable for the number of data bits."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2182
msgid "``int *flow``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2181
msgid "pointer to an 'int' variable for the flow control character."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2182
msgid ""
"uart_parse_options() decodes a string containing the serial console options. "
"The format of the string is <baud><parity><bits><flow>, eg: 115200n8r"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2206
msgid "setup the serial console parameters"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2207
msgid "pointer to the serial ports uart_port structure"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2209
msgid "``struct console *co``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2208
msgid "console pointer"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2210
msgid "``int baud``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2209
msgid "baud rate"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2211
msgid "``int parity``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2210
msgid "parity character - 'n' (none), 'o' (odd), 'e' (even)"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2212
msgid "``int bits``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2211
msgid "number of data bits"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2213
msgid "``int flow``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2212
msgid "flow control character - 'r' (rts)"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2213
msgid ""
"Locking: Caller must hold console_list_lock in order to serialize early "
"initialization of the serial-console lock."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2722
msgid "register a driver with the uart core layer"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2728
#: drivers/tty/serial/serial_core.c:2804
msgid "``struct uart_driver *drv``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2723
#: drivers/tty/serial/serial_core.c:2799
msgid "low level driver structure"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2724
msgid ""
"Register a uart driver with the core driver. We in turn register with the "
"tty layer, and initialise the core driver per-port state."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2727
msgid ""
"We have a proc file in /proc/tty/driver which is named after the normal "
"driver."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2730
msgid ""
"**drv->port** should be ``NULL``, and the per-port structures should be "
"registered using uart_add_one_port() after this call has succeeded."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2733
#: drivers/tty/serial/serial_core.c:2804
msgid "Locking: none, Interrupts: enabled"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2798
msgid "remove a driver from the uart core layer"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:2800
msgid ""
"Remove all references to a driver from the core driver. The low level driver "
"must have removed all its ports via the uart_remove_one_port() if it "
"registered them with uart_add_one_port(). (I.e. **drv->port** is ``NULL``.)"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3208
msgid "are the two ports equivalent?"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3214
msgid "``const struct uart_port *port1``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3209
msgid "first port"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3211
msgid "``const struct uart_port *port2``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3210
msgid "second port"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3211
msgid ""
"This utility function can be used to determine whether two uart_port "
"structures describe the same port."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3374
msgid "handle a change of carrier detect state"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3380
#: drivers/tty/serial/serial_core.c:3415
msgid "``struct uart_port *uport``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3375
#: drivers/tty/serial/serial_core.c:3410
msgid "uart_port structure for the open port"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3377
#: drivers/tty/serial/serial_core.c:3412
msgid "``bool active``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3376
msgid "new carrier detect status"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3377
#: drivers/tty/serial/serial_core.c:3412
msgid "Caller must hold uport->lock."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3409
msgid "handle a change of clear-to-send state"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3411
msgid "new clear-to-send status"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3484
msgid "Enables SysRq from serial line"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3485
msgid "uart_port structure where char(s) after BREAK met"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3487
msgid "``u8 ch``"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3486
msgid "new character in the sequence after received BREAK"
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3487
msgid ""
"Enables magic SysRq when the required sequence is met on port (see "
"CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE)."
msgstr ""

#: ../../../driver-api/serial/driver:71: drivers/tty/serial/serial_core.c:3491
msgid ""
"``false`` if **ch** is out of enabling sequence and should be handled some "
"other way, ``true`` if **ch** was consumed."
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:956
msgid "``uart_port_tx_limited (port, ch, count, tx_ready, put_char, tx_done)``"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:954
msgid "transmit helper for uart_port with count limiting"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:960
#: include/linux/serial_core.h:1010
msgid "``port``"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:955
#: include/linux/serial_core.h:1005
msgid "uart port"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:957
#: include/linux/serial_core.h:1007
msgid "``ch``"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:956
#: include/linux/serial_core.h:1006
msgid "variable to store a character to be written to the HW"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:958
msgid "``count``"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:957
msgid "a limit of characters to send"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:959
#: include/linux/serial_core.h:1008
msgid "``tx_ready``"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:958
#: include/linux/serial_core.h:1007
msgid "can HW accept more data function"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:960
#: include/linux/serial_core.h:1009
msgid "``put_char``"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:959
#: include/linux/serial_core.h:1008
msgid "function to write a character"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:961
msgid "``tx_done``"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:960
msgid "function to call after the loop is done"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:961
msgid ""
"This helper transmits characters from the xmit buffer to the hardware using "
"**put_char\\(\\)**. It does so until **count** characters are sent and while "
"**tx_ready** evaluates to true."
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:966
msgid "The expression in macro parameters shall be designed as follows:"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:967
msgid ""
"**tx_ready:** should evaluate to true if the HW can accept more data to be "
"sent. This parameter can be ``true``, which means the HW is always ready."
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:969
msgid "**put_char:** shall write **ch** to the device of **port**."
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:970
msgid ""
"**tx_done:** when the write loop is done, this can perform arbitrary action "
"before potential invocation of ops->stop_tx() happens. If the driver does "
"not need to do anything, use e.g. ({})."
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:974
msgid ""
"For all of them, **port->lock** is held, interrupts are locally disabled and "
"the expressions must not sleep."
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:966
msgid "the number of characters in the xmit buffer when done."
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:1006
msgid "``uart_port_tx (port, ch, tx_ready, put_char)``"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:1004
msgid "transmit helper for uart_port"
msgstr ""

#: ../../../driver-api/serial/driver:80: include/linux/serial_core.h:1009
msgid "See uart_port_tx_limited() for more details."
msgstr ""

#: ../../../driver-api/serial/driver.rst:84
msgid "Other notes"
msgstr ""

#: ../../../driver-api/serial/driver.rst:86
msgid ""
"It is intended some day to drop the 'unused' entries from uart_port, and "
"allow low level drivers to register their own individual uart_port's with "
"the core.  This will allow drivers to use uart_port as a pointer to a "
"structure containing both the uart_port entry with their own extensions, "
"thus::"
msgstr ""

#: ../../../driver-api/serial/driver.rst:98
msgid "Modem control lines via GPIO"
msgstr ""

#: ../../../driver-api/serial/driver.rst:100
msgid ""
"Some helpers are provided in order to set/get modem control lines via GPIO."
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:46
msgid "set gpios according to mctrl state"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:52
#: drivers/tty/serial/serial_mctrl_gpio.c:80
#: drivers/tty/serial/serial_mctrl_gpio.c:96
#: drivers/tty/serial/serial_mctrl_gpio.c:277
#: drivers/tty/serial/serial_mctrl_gpio.c:329
#: drivers/tty/serial/serial_mctrl_gpio.c:340
msgid "``struct mctrl_gpios *gpios``"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:47
msgid "gpios to set"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:49
msgid "``unsigned int mctrl``"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:48
msgid "state to set"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:49
msgid "Set the gpios according to the mctrl state."
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:74
msgid "obtain gpio_desc of modem line index"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:75
msgid "gpios to look into"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:77
msgid "``enum mctrl_gpio_idx gidx``"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:76
msgid "index of the modem line"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:77
msgid "the gpio_desc structure associated to the modem line index"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:90
msgid "update mctrl with the gpios values."
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:91
msgid "gpios to get the info from"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:93
msgid "``unsigned int *mctrl``"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:92
msgid "mctrl to set"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:93
msgid "modified mctrl (the same value as in **mctrl**)"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:94
msgid "Update mctrl with the gpios values."
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:214
msgid "initialize uart gpios"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:215
msgid "port to initialize gpios for"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:217
msgid "``unsigned int idx``"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:216
msgid "index of the gpio in the **port**'s device"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:217
msgid ""
"This will get the {cts,rts,...}-gpios from device tree if they are present "
"and request them, set direction etc, and return an allocated structure. "
"`devm_*` functions are used, so there's no need to explicitly free. As this "
"sets up the irq handling, make sure to not handle changes to the gpio input "
"lines in your driver, too."
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:271
msgid "enable irqs and handling of changes to the ms lines"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:272
msgid "gpios to enable"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:323
msgid ""
"disable irqs and handling of changes to the ms lines, and wait for any "
"pending IRQ to be processed"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:325
#: drivers/tty/serial/serial_mctrl_gpio.c:336
msgid "gpios to disable"
msgstr ""

#: ../../../driver-api/serial/driver:102:
#: drivers/tty/serial/serial_mctrl_gpio.c:334
msgid ""
"disable irqs and handling of changes to the ms lines, and return immediately"
msgstr ""
