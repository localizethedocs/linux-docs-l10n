# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/driver-model/design-patterns.rst:3
msgid "Device Driver Design Patterns"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:5
msgid ""
"This document describes a few common design patterns found in device "
"drivers. It is likely that subsystem maintainers will ask driver developers "
"to conform to these design patterns."
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:9
msgid "State Container"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:10
msgid "container_of()"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:14
msgid "1. State Container"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:16
msgid ""
"While the kernel contains a few device drivers that assume that they will "
"only be probed() once on a certain system (singletons), it is custom to "
"assume that the device the driver binds to will appear in several instances. "
"This means that the probe() function and all callbacks need to be reentrant."
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:21
msgid ""
"The most common way to achieve this is to use the state container design "
"pattern. It usually has this form::"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:40
msgid ""
"This will create an instance of struct foo in memory every time probe() is "
"called. This is our state container for this instance of the device driver. "
"Of course it is then necessary to always pass this instance of the state "
"around to all functions that need access to the state and its members."
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:45
msgid ""
"For example, if the driver is registering an interrupt handler, you would "
"pass around a pointer to struct foo like this::"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:62
msgid ""
"This way you always get a pointer back to the correct instance of foo in "
"your interrupt handler."
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:67
msgid "2. container_of()"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:69
msgid "Continuing on the above example we add an offloaded work::"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:102
msgid ""
"The design pattern is the same for an hrtimer or something similar that will "
"return a single argument which is a pointer to a struct member in the "
"callback."
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:106
msgid "container_of() is a macro defined in <linux/kernel.h>"
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:108
msgid ""
"What container_of() does is to obtain a pointer to the containing struct "
"from a pointer to a member by a simple subtraction using the offsetof() "
"macro from standard C, which allows something similar to object oriented "
"behaviours. Notice that the contained member must not be a pointer, but an "
"actual member for this to work."
msgstr ""

#: ../../../driver-api/driver-model/design-patterns.rst:114
msgid ""
"We can see here that we avoid having global pointers to our struct foo * "
"instance this way, while still keeping the number of parameters passed to "
"the work function to a single pointer."
msgstr ""
