# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../kbuild/kconfig-macro-language.rst:3
msgid "Kconfig macro language"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:6
msgid "Concept"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:8
msgid ""
"The basic idea was inspired by Make. When we look at Make, we notice sort of "
"two languages in one. One language describes dependency graphs consisting of "
"targets and prerequisites. The other is a macro language for performing "
"textual substitution."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:13
msgid ""
"There is clear distinction between the two language stages. For example, you "
"can write a makefile like follows::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:23
msgid ""
"The macro language replaces the variable references with their expanded "
"form, and handles as if the source file were input like follows::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:29
msgid ""
"Then, Make analyzes the dependency graph and determines the targets to be "
"updated."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:32
msgid ""
"The idea is quite similar in Kconfig - it is possible to describe a Kconfig "
"file like this::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:40
msgid ""
"The macro language in Kconfig processes the source file into the following "
"intermediate::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:46
msgid ""
"Then, Kconfig moves onto the evaluation stage to resolve inter-symbol "
"dependency as explained in kconfig-language.rst."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:51
msgid "Variables"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:53
msgid ""
"Like in Make, a variable in Kconfig works as a macro variable.  A macro "
"variable is expanded \"in place\" to yield a text string that may then be "
"expanded further. To get the value of a variable, enclose the variable name "
"in $( ). The parentheses are required even for single-letter variable names; "
"$X is a syntax error. The curly brace form as in ${CC} is not supported "
"either."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:59
msgid ""
"There are two types of variables: simply expanded variables and recursively "
"expanded variables."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:62
msgid ""
"A simply expanded variable is defined using the := assignment operator. Its "
"righthand side is expanded immediately upon reading the line from the "
"Kconfig file."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:66
msgid ""
"A recursively expanded variable is defined using the = assignment operator. "
"Its righthand side is simply stored as the value of the variable without "
"expanding it in any way. Instead, the expansion is performed when the "
"variable is used."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:71
msgid ""
"There is another type of assignment operator; += is used to append text to a "
"variable. The righthand side of += is expanded immediately if the lefthand "
"side was originally defined as a simple variable. Otherwise, its evaluation "
"is deferred."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:76
msgid "The variable reference can take parameters, in the following form::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:80
msgid ""
"You can consider the parameterized reference as a function. (more precisely, "
"\"user-defined function\" in contrast to \"built-in function\" listed below)."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:83
msgid ""
"Useful functions must be expanded when they are used since the same function "
"is expanded differently if different parameters are passed. Hence, a user-"
"defined function is defined using the = assignment operator. The parameters "
"are referenced within the body definition with $(1), $(2), etc."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:88
msgid ""
"In fact, recursively expanded variables and user-defined functions are the "
"same internally. (In other words, \"variable\" is \"function with zero "
"argument\".) When we say \"variable\" in a broad sense, it includes \"user-"
"defined function\"."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:94
msgid "Built-in functions"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:96
msgid ""
"Like Make, Kconfig provides several built-in functions. Every function takes "
"a particular number of arguments."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:99
msgid ""
"In Make, every built-in function takes at least one argument. Kconfig allows "
"zero argument for built-in functions, such as $(filename), $(lineno). You "
"could consider those as \"built-in variable\", but it is just a matter of "
"how we call it after all. Let's say \"built-in function\" here to refer to "
"natively supported functionality."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:105
msgid "Kconfig currently supports the following built-in functions."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:107
msgid "$(shell,command)"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:109
msgid ""
"The \"shell\" function accepts a single argument that is expanded and passed "
"to a subshell for execution. The standard output of the command is then read "
"and returned as the value of the function. Every newline in the output is "
"replaced with a space. Any trailing newlines are deleted. The standard error "
"is not returned, nor is any program exit status."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:115
msgid "$(info,text)"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:117
msgid ""
"The \"info\" function takes a single argument and prints it to stdout. It "
"evaluates to an empty string."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:120
msgid "$(warning-if,condition,text)"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:122
msgid ""
"The \"warning-if\" function takes two arguments. If the condition part is "
"\"y\", the text part is sent to stderr. The text is prefixed with the name "
"of the current Kconfig file and the current line number."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:126
msgid "$(error-if,condition,text)"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:128
msgid ""
"The \"error-if\" function is similar to \"warning-if\", but it terminates "
"the parsing immediately if the condition part is \"y\"."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:131
msgid "$(filename)"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:133
msgid ""
"The 'filename' takes no argument, and $(filename) is expanded to the file "
"name being parsed."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:136
msgid "$(lineno)"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:138
msgid ""
"The 'lineno' takes no argument, and $(lineno) is expanded to the line number "
"being parsed."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:143
msgid "Make vs Kconfig"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:145
msgid ""
"Kconfig adopts Make-like macro language, but the function call syntax is "
"slightly different."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:148
msgid "A function call in Make looks like this::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:152
msgid ""
"The function name and the first argument are separated by at least one "
"whitespace. Then, leading whitespaces are trimmed from the first argument, "
"while whitespaces in the other arguments are kept. You need to use a kind of "
"trick to start the first parameter with spaces. For example, if you want to "
"make \"info\" function print \"  hello\", you can write like follows::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:162
msgid ""
"Kconfig uses only commas for delimiters, and keeps all whitespaces in the "
"function call. Some people prefer putting a space after each comma "
"delimiter::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:167
msgid ""
"In this case, \"func-name\" will receive \" arg1\", \" arg2\", \" arg3\". "
"The presence of leading spaces may matter depending on the function. The "
"same applies to Make - for example, $(subst .c, .o, $(sources)) is a typical "
"mistake; it replaces \".c\" with \" .o\"."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:172
msgid ""
"In Make, a user-defined function is referenced by using a built-in function, "
"'call', like this::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:177
msgid ""
"Kconfig invokes user-defined functions and built-in functions in the same "
"way. The omission of 'call' makes the syntax shorter."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:180
msgid ""
"In Make, some functions treat commas verbatim instead of argument "
"separators. For example, $(shell echo hello, world) runs the command \"echo "
"hello, world\". Likewise, $(info hello, world) prints \"hello, world\" to "
"stdout. You could say this is _useful_ inconsistency."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:185
msgid ""
"In Kconfig, for simpler implementation and grammatical consistency, commas "
"that appear in the $( ) context are always delimiters. It means::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:190
msgid ""
"is an error because it is passing two parameters where the 'shell' function "
"accepts only one. To pass commas in arguments, you can use the following "
"trick::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:198
msgid "Caveats"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:200
msgid ""
"A variable (or function) cannot be expanded across tokens. So, you cannot "
"use a variable as a shorthand for an expression that consists of multiple "
"tokens. The following works::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:211
msgid "But, the following does not work::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:219
msgid ""
"A variable cannot be expanded to any keyword in Kconfig.  The following does "
"not work::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:228
msgid ""
"Obviously from the design, $(shell command) is expanded in the textual "
"substitution phase. You cannot pass symbols to the 'shell' function."
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:231
msgid "The following does not work as expected::"
msgstr ""

#: ../../../kbuild/kconfig-macro-language.rst:241
msgid ""
"Instead, you can do like follows so that any function call is statically "
"expanded::"
msgstr ""
