<!DOCTYPE html>

<html lang="en-US" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Live Update Orchestrator &#8212; The Linux Kernel unknown version documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=adfc0c0d" />
    <script src="../_static/documentation_options.js?v=750ed68d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/core-api/liveupdate.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memfd Preservation via LUO" href="../mm/memfd_preservation.html" />
    <link rel="prev" title="Reed-Solomon Library Programming Interface" href="librs.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#everything-else">Everything else</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Live Update Orchestrator</a></li>
<li class="toctree-l3"><a class="reference internal" href="netlink.html">Netlink notes for kernel developers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer’s API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/liveupdate.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="live-update-orchestrator">
<h1>Live Update Orchestrator<a class="headerlink" href="#live-update-orchestrator" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pasha Tatashin &lt;<a class="reference external" href="mailto:pasha&#46;tatashin&#37;&#52;&#48;soleen&#46;com">pasha<span>&#46;</span>tatashin<span>&#64;</span>soleen<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<p>Live Update is a specialized, kexec-based reboot process that allows a
running kernel to be updated from one version to another while preserving
the state of selected resources and keeping designated hardware devices
operational. For these devices, DMA activity may continue throughout the
kernel transition.</p>
<p>While the primary use case driving this work is supporting live updates of
the Linux kernel when it is used as a hypervisor in cloud environments, the
LUO framework itself is designed to be workload-agnostic. Live Update
facilitates a full kernel version upgrade for any type of system.</p>
<p>For example, a non-hypervisor system running an in-memory cache like
memcached with many gigabytes of data can use LUO. The userspace service
can place its cache into a memfd, have its state preserved by LUO, and
restore it immediately after the kernel kexec.</p>
<p>Whether the system is running virtual machines, containers, a
high-performance database, or networking services, LUO’s primary goal is to
enable a full kernel update by preserving critical userspace state and
keeping essential devices operational.</p>
<p>The core of LUO is a mechanism that tracks the progress of a live update,
along with a callback API that allows other kernel subsystems to participate
in the process. Example subsystems that can hook into LUO include: kvm,
iommu, interrupts, vfio, participating filesystems, and memory management.</p>
<p>LUO uses Kexec Handover to transfer memory state from the current kernel to
the next kernel. For more details see
<a class="reference internal" href="kho/concepts.html"><span class="doc">Kexec Handover Concepts</span></a>.</p>
<section id="luo-sessions">
<h2>LUO Sessions<a class="headerlink" href="#luo-sessions" title="Link to this heading">¶</a></h2>
<p>LUO Sessions provide the core mechanism for grouping and managing <cite><a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">file</span></code></a> *</cite> instances that need to be preserved across a kexec-based live
update. Each session acts as a named container for a set of file objects,
allowing a userspace agent to manage the lifecycle of resources critical to a
workload.</p>
<p>Core Concepts:</p>
<ul class="simple">
<li><p>Named Containers: Sessions are identified by a unique, user-provided name,
which is used for both creation in the current kernel and retrieval in the
next kernel.</p></li>
<li><p>Userspace Interface: Session management is driven from userspace via
ioctls on /dev/liveupdate.</p></li>
<li><p>Serialization: Session metadata is preserved using the KHO framework. When
a live update is triggered via kexec, an array of <cite><a class="reference internal" href="#c.luo_session_ser" title="luo_session_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session_ser</span></code></a></cite>
is populated and placed in a preserved memory region. An FDT node is also
created, containing the count of sessions and the physical address of this
array.</p></li>
</ul>
<p>Session Lifecycle:</p>
<ol class="arabic simple">
<li><p>Creation: A userspace agent calls <cite><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">luo_session_create()</span></code></cite> to create a
new, empty session and receives a file descriptor for it.</p></li>
<li><p>Serialization: When the <cite>reboot(LINUX_REBOOT_CMD_KEXEC)</cite> syscall is
made, <cite><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">luo_session_serialize()</span></code></cite> is called. It iterates through all
active sessions and writes their metadata into a memory area preserved
by KHO.</p></li>
<li><p>Deserialization (in new kernel): After kexec, <cite><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">luo_session_deserialize()</span></code></cite>
runs, reading the serialized data and creating a list of <cite><code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">luo_session</span></code></cite> objects representing the preserved sessions.</p></li>
<li><p>Retrieval: A userspace agent in the new kernel can then call
<cite><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">luo_session_retrieve()</span></code></cite> with a session name to get a new file
descriptor and access the preserved state.</p></li>
</ol>
</section>
<section id="luo-preserving-file-descriptors">
<h2>LUO Preserving File Descriptors<a class="headerlink" href="#luo-preserving-file-descriptors" title="Link to this heading">¶</a></h2>
<p>LUO provides the infrastructure to preserve specific, stateful file
descriptors across a kexec-based live update. The primary goal is to allow
workloads, such as virtual machines using vfio, memfd, or iommufd, to
retain access to their essential resources without interruption.</p>
<p>The framework is built around a callback-based handler model and a well-
defined lifecycle for each preserved file.</p>
<p>Handler Registration:
Kernel modules responsible for a specific file type (e.g., memfd, vfio)
register a <a class="reference internal" href="#c.liveupdate_file_handler" title="liveupdate_file_handler"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">liveupdate_file_handler</span></code></a>. This handler provides a set of
callbacks that LUO invokes at different stages of the update process, most
notably:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">can_preserve()</span></code>: A lightweight check to determine if the handler is
compatible with a given ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’.</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preserve()</span></code>: The heavyweight operation that saves the file’s state and
returns an opaque u64 handle. This is typically performed while the
workload is still active to minimize the downtime during the
actual reboot transition.</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unpreserve()</span></code>: Cleans up any resources allocated by .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preserve()</span></code>, called
if the preservation process is aborted before the reboot (i.e. session is
closed).</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code>: A final pre-reboot opportunity to prepare the state for kexec.
We are already in reboot syscall, and therefore userspace cannot mutate
the file anymore.</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unfreeze()</span></code>: Undoes the actions of .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code>, called if the live update
is aborted after the freeze phase.</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">retrieve()</span></code>: Reconstructs the file in the new kernel from the preserved
handle.</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish()</span></code>: Performs final check and cleanup in the new kernel. After
succesul finish call, LUO gives up ownership to this file.</p></li>
</ul>
</div></blockquote>
<p>File Preservation Lifecycle happy path:</p>
<ol class="arabic simple">
<li><p>Preserve (Normal Operation): A userspace agent preserves files one by one
via an ioctl. For each file, <a class="reference internal" href="#c.luo_preserve_file" title="luo_preserve_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_preserve_file()</span></code></a> finds a compatible
handler, calls its .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preserve()</span></code> operation, and creates an internal <a class="reference internal" href="#c.luo_file" title="luo_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">luo_file</span></code></a> to track the live state.</p></li>
<li><p>Freeze (Pre-Reboot): Just before the kexec, <a class="reference internal" href="#c.luo_file_freeze" title="luo_file_freeze"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_freeze()</span></code></a> is called.
It iterates through all preserved files, calls their respective .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code>
operation, and serializes their final metadata (compatible string, token,
and data handle) into a contiguous memory block for KHO.</p></li>
<li><p>Deserialize: After kexec, <a class="reference internal" href="#c.luo_file_deserialize" title="luo_file_deserialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_deserialize()</span></code></a> runs when session gets
deserialized (which is when /dev/liveupdate is first opened). It reads the
serialized data from the KHO memory region and reconstructs the in-memory
list of <a class="reference internal" href="#c.luo_file" title="luo_file"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file</span></code></a> instances for the new kernel, linking them to
their corresponding handlers.</p></li>
<li><p>Retrieve (New Kernel - Userspace Ready): The userspace agent can now
restore file descriptors by providing a token. <a class="reference internal" href="#c.luo_retrieve_file" title="luo_retrieve_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_retrieve_file()</span></code></a>
searches for the matching token, calls the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">retrieve()</span></code> op to
re-create the ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’, and returns a new FD. Files can be
retrieved in ANY order.</p></li>
<li><p>Finish (New Kernel - Cleanup): Once a session retrival is complete,
<a class="reference internal" href="#c.luo_file_finish" title="luo_file_finish"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_finish()</span></code></a> is called. It iterates through all files, invokes their
.<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish()</span></code> operations for final cleanup, and releases all associated kernel
resources.</p></li>
</ol>
<p>File Preservation Lifecycle unhappy paths:</p>
<ol class="arabic simple">
<li><p>Abort Before Reboot: If the userspace agent aborts the live update
process before calling reboot (e.g., by closing the session file
descriptor), the session’s release handler calls
<a class="reference internal" href="#c.luo_file_unpreserve_files" title="luo_file_unpreserve_files"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_unpreserve_files()</span></code></a>. This invokes the .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unpreserve()</span></code> callback on
all preserved files, ensuring all allocated resources are cleaned up and
returning the system to a clean state.</p></li>
<li><p>Freeze Failure: During the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">reboot()</span></code> syscall, if any handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code>
op fails, the .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unfreeze()</span></code> op is invoked on all previously <em>successful</em>
freezes to roll back their state. The <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">reboot()</span></code> syscall then returns an
error to userspace, canceling the live update.</p></li>
<li><p>Finish Failure: In the new kernel, if a handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish()</span></code> op fails,
the <a class="reference internal" href="#c.luo_file_finish" title="luo_file_finish"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_finish()</span></code></a> operation is aborted. LUO retains ownership of
all files within that session, including those that were not yet
processed. The userspace agent can attempt to call the finish operation
again later. If the issue cannot be resolved, these resources will be held
by LUO until the next live update cycle, at which point they will be
discarded.</p></li>
</ol>
</section>
<section id="live-update-orchestrator-abi">
<h2>Live Update Orchestrator ABI<a class="headerlink" href="#live-update-orchestrator-abi" title="Link to this heading">¶</a></h2>
<p>This header defines the stable Application Binary Interface used by the
Live Update Orchestrator to pass state from a pre-update kernel to a
post-update kernel. The ABI is built upon the Kexec HandOver framework
and uses a Flattened Device Tree to describe the preserved data.</p>
<p>This interface is a contract. Any modification to the FDT structure, node
properties, compatible strings, or the layout of the <cite>__packed</cite> serialization
structures defined here constitutes a breaking change. Such changes require
incrementing the version number in the relevant <cite>_COMPATIBLE</cite> string to
prevent a new kernel from misinterpreting data from an old kernel.</p>
<p>Changes are allowed provided the compatibility version is incremented;
however, backward/forward compatibility is only guaranteed for kernels
supporting the same ABI version.</p>
<dl>
<dt>FDT Structure Overview:</dt><dd><p>The entire LUO state is encapsulated within a single KHO entry named “LUO”.
This entry contains an FDT with the following layout:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/ {
    compatible = &quot;luo-v1&quot;;
    liveupdate-number = &lt;...&gt;;

    luo-session {
        compatible = &quot;luo-session-v1&quot;;
        luo-session-header = &lt;phys_addr_of_session_header_ser&gt;;
    };
};
</pre></div>
</div>
</dd>
</dl>
<p>Main LUO Node (/):</p>
<blockquote>
<div><ul class="simple">
<li><p>compatible: “luo-v1”
Identifies the overall LUO ABI version.</p></li>
<li><p>liveupdate-number: u64
A counter tracking the number of successful live updates performed.</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Session Node (luo-session):</dt><dd><p>This node describes all preserved user-space sessions.</p>
<ul class="simple">
<li><p>compatible: “luo-session-v1”
Identifies the session ABI version.</p></li>
<li><p>luo-session-header: u64
The physical address of a <cite><a class="reference internal" href="#c.luo_session_header_ser" title="luo_session_header_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session_header_ser</span></code></a></cite>. This structure
is the header for a contiguous block of memory containing an array of
<cite><a class="reference internal" href="#c.luo_session_ser" title="luo_session_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session_ser</span></code></a></cite>, one for each preserved session.</p></li>
</ul>
</dd>
<dt>Serialization Structures:</dt><dd><p>The FDT properties point to memory regions containing arrays of simple,
<cite>__packed</cite> structures. These structures contain the actual preserved state.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.luo_session_header_ser" title="luo_session_header_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session_header_ser</span></code></a>:
Header for the session array. Contains the total page count of the
preserved memory block and the number of <cite><a class="reference internal" href="#c.luo_session_ser" title="luo_session_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session_ser</span></code></a></cite>
entries that follow.</p></li>
<li><p><a class="reference internal" href="#c.luo_session_ser" title="luo_session_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session_ser</span></code></a>:
Metadata for a single session, including its name and a physical pointer
to another preserved memory block containing an array of
<cite><a class="reference internal" href="#c.luo_file_ser" title="luo_file_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_ser</span></code></a></cite> for all files in that session.</p></li>
<li><p><a class="reference internal" href="#c.luo_file_ser" title="luo_file_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_ser</span></code></a>:
Metadata for a single preserved file. Contains the <cite>compatible</cite> string to
find the correct handler in the new kernel, a user-provided <cite>token</cite> for
identification, and an opaque <cite>data</cite> handle for the handler to use.</p></li>
</ul>
</dd>
</dl>
<p>The following types of file descriptors can be preserved</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mm/memfd_preservation.html">Memfd Preservation via LUO</a></li>
</ul>
</div>
</section>
<section id="public-api">
<h2>Public API<a class="headerlink" href="#public-api" title="Link to this heading">¶</a></h2>
<dl class="c struct">
<dt class="sig sig-object c" id="c.liveupdate_file_op_args">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">liveupdate_file_op_args</span></span></span><a class="headerlink" href="#c.liveupdate_file_op_args" title="Link to this definition">¶</a><br /></dt>
<dd><p>Arguments for file operation callbacks.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct liveupdate_file_op_args {
    struct liveupdate_file_handler *handler;
    bool retrieved;
    struct file *file;
    u64 serialized_data;
    void *private_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">handler</span></code></dt><dd><p>The file handler being called.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">retrieved</span></code></dt><dd><p>The retrieve status for the ‘can_finish / finish’
operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>The file object. For retrieve: [OUT] The callback sets
this to the new file. For other ops: [IN] The caller sets
this to the file being operated on.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">serialized_data</span></code></dt><dd><p>The opaque u64 handle, preserve/prepare/freeze may update
this field.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt><dd><p>Private data for the file used to hold runtime state that
is not preserved. Set by the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preserve()</span></code>
callback, and must be freed in the handler’s
.<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unpreserve()</span></code> callback.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure bundles all parameters for the file operation callbacks.
The ‘data’ and ‘file’ fields are used for both input and output.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.liveupdate_file_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">liveupdate_file_ops</span></span></span><a class="headerlink" href="#c.liveupdate_file_ops" title="Link to this definition">¶</a><br /></dt>
<dd><p>Callbacks for live-updatable files.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct liveupdate_file_ops {
    bool (*can_preserve)(struct liveupdate_file_handler *handler, struct file *file);
    int (*preserve)(struct liveupdate_file_op_args *args);
    void (*unpreserve)(struct liveupdate_file_op_args *args);
    int (*freeze)(struct liveupdate_file_op_args *args);
    void (*unfreeze)(struct liveupdate_file_op_args *args);
    int (*retrieve)(struct liveupdate_file_op_args *args);
    bool (*can_finish)(struct liveupdate_file_op_args *args);
    void (*finish)(struct liveupdate_file_op_args *args);
    struct module *owner;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">can_preserve</span></code></dt><dd><p>Required. Lightweight check to see if this handler is
compatible with the given file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">preserve</span></code></dt><dd><p>Required. Performs state-saving for the file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unpreserve</span></code></dt><dd><p>Required. Cleans up any resources allocated by <strong>preserve</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">freeze</span></code></dt><dd><p>Optional. Final actions just before kernel transition.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unfreeze</span></code></dt><dd><p>Optional. Undo freeze operations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">retrieve</span></code></dt><dd><p>Required. Restores the file in the new kernel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">can_finish</span></code></dt><dd><p>Optional. Check if this FD can finish, i.e. all restoration
pre-requirements for this FD are satisfied. Called prior to
finish, in order to do successful finish calls for all
resources in the session.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">finish</span></code></dt><dd><p>Required. Final cleanup in the new kernel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">owner</span></code></dt><dd><p>Module reference</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>All operations (except can_preserve) receive a pointer to a
‘<a class="reference internal" href="#c.liveupdate_file_op_args" title="liveupdate_file_op_args"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">liveupdate_file_op_args</span></code></a>’ containing the necessary context.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.liveupdate_file_handler">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">liveupdate_file_handler</span></span></span><a class="headerlink" href="#c.liveupdate_file_handler" title="Link to this definition">¶</a><br /></dt>
<dd><p>Represents a handler for a live-updatable file type.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct liveupdate_file_handler {
    const struct liveupdate_file_ops *ops;
    const char compatible[LIVEUPDATE_HNDL_COMPAT_LENGTH];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Callback functions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">compatible</span></code></dt><dd><p>The compatibility string (e.g., “memfd-v1”, “vfiofd-v1”)
that uniquely identifies the file type this handler
supports. This is matched against the compatible string
associated with individual <a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a> instances.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Modules that want to support live update for specific file types should
register an instance of this structure. LUO uses this registration to
determine if a given file can be preserved and to find the appropriate
operations to manage its state across the update.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.luo_file_ser">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_file_ser</span></span></span><a class="headerlink" href="#c.luo_file_ser" title="Link to this definition">¶</a><br /></dt>
<dd><p>Represents the serialized preserves files.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct luo_file_ser {
    char compatible[LIVEUPDATE_HNDL_COMPAT_LENGTH];
    u64 data;
    u64 token;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">compatible</span></code></dt><dd><p>File handler compatible string.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Private data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">token</span></code></dt><dd><p>User provided token for this file</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>If this structure is modified, LUO_SESSION_COMPATIBLE must be updated.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.luo_file_set_ser">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_file_set_ser</span></span></span><a class="headerlink" href="#c.luo_file_set_ser" title="Link to this definition">¶</a><br /></dt>
<dd><p>Represents the serialized metadata for file set</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct luo_file_set_ser {
    u64 files;
    u64 count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">files</span></code></dt><dd><p>The physical address of a contiguous memory block that holds
the serialized state of files (array of luo_file_ser) in this file
set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>The total number of files that were part of this session during
serialization. Used for iteration and validation during
restoration.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.luo_session_header_ser">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_session_header_ser</span></span></span><a class="headerlink" href="#c.luo_session_header_ser" title="Link to this definition">¶</a><br /></dt>
<dd><p>Header for the serialized session data block.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct luo_session_header_ser {
    u64 count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>The number of <cite><a class="reference internal" href="#c.luo_session_ser" title="luo_session_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session_ser</span></code></a></cite> entries that immediately
follow this header in the memory block.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is located at the beginning of a contiguous block of
physical memory preserved across the kexec. It provides the necessary
metadata to interpret the array of session entries that follow.</p>
<p>If this structure is modified, <cite>LUO_FDT_SESSION_COMPATIBLE</cite> must be updated.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.luo_session_ser">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_session_ser</span></span></span><a class="headerlink" href="#c.luo_session_ser" title="Link to this definition">¶</a><br /></dt>
<dd><p>Represents the serialized metadata for a LUO session.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct luo_session_ser {
    char name[LIVEUPDATE_SESSION_NAME_LENGTH];
    struct luo_file_set_ser file_set_ser;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>The unique name of the session, provided by the userspace at
the time of session creation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file_set_ser</span></code></dt><dd><p>Serialized files belonging to this session,</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is used to package session-specific metadata for transfer
between kernels via Kexec Handover. An array of these structures (one per
session) is created and passed to the new kernel, allowing it to reconstruct
the session context.</p>
<p>If this structure is modified, <cite>LUO_FDT_SESSION_COMPATIBLE</cite> must be updated.</p>
</section>
<section id="internal-api">
<h2>Internal API<a class="headerlink" href="#internal-api" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.liveupdate_reboot">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">liveupdate_reboot</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.liveupdate_reboot" title="Link to this definition">¶</a><br /></dt>
<dd><p>Kernel reboot notifier for live update final serialization.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is invoked directly from the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">reboot()</span></code> syscall pathway
if kexec is in progress.</p>
<p>If any callback fails, this function aborts KHO, undoes the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code>
callbacks, and returns an error.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.liveupdate_enabled">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">liveupdate_enabled</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.liveupdate_enabled" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check if the live update feature is enabled.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the state of the live update feature flag, which
can be controlled via the <code class="docutils literal notranslate"><span class="pre">liveupdate</span></code> kernel command-line parameter.</p>
<p><strong>return</strong> true if live update is enabled, false otherwise.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.luo_session_header">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_session_header</span></span></span><a class="headerlink" href="#c.luo_session_header" title="Link to this definition">¶</a><br /></dt>
<dd><p>Header struct for managing LUO sessions.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct luo_session_header {
    long count;
    struct list_head list;
    struct rw_semaphore rwsem;
    struct luo_session_header_ser *header_ser;
    struct luo_session_ser *ser;
    bool active;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code></dt><dd><p>The number of sessions currently tracked in the <strong>list</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>The head of the linked list of <cite><code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session</span></code></cite> instances.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">rwsem</span></code></dt><dd><p>A read-write semaphore providing synchronized access to the
session list and other fields in this structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">header_ser</span></code></dt><dd><p>The header data of serialization array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ser</span></code></dt><dd><p>The serialized session data (an array of
<cite><a class="reference internal" href="#c.luo_session_ser" title="luo_session_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_session_ser</span></code></a></cite>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">active</span></code></dt><dd><p>Set to true when first initialized. If previous kernel did not
send session data, active stays false for incoming.</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.luo_session_global">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_session_global</span></span></span><a class="headerlink" href="#c.luo_session_global" title="Link to this definition">¶</a><br /></dt>
<dd><p>Global container for managing LUO sessions.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct luo_session_global {
    struct luo_session_header incoming;
    struct luo_session_header outgoing;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">incoming</span></code></dt><dd><p>The sessions passed from the previous kernel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">outgoing</span></code></dt><dd><p>The sessions that are going to be passed to the next kernel.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_session_quiesce">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_session_quiesce</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_session_quiesce" title="Link to this definition">¶</a><br /></dt>
<dd><p>Ensure no active sessions exist and lock session lists.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires exclusive write locks on both incoming and outgoing session lists.
It then validates no sessions exist in either list.</p>
<p>This mechanism is used during file handler un/registration to ensure that no
sessions are currently using the handler, and no new sessions can be created
while un/registration is in progress.</p>
<p>This prevents registering new handlers while sessions are active or
while deserialization is in progress.</p>
<p><strong>Return</strong></p>
<p>true  - System is quiescent (0 sessions) and locked.
false - Active sessions exist. The locks are released internally.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_session_resume">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_session_resume</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_session_resume" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unlock session lists and resume normal activity.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void</span></code></dt><dd><p>no arguments</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the exclusive locks acquired by a successful call to
<a class="reference internal" href="#c.luo_session_quiesce" title="luo_session_quiesce"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_session_quiesce()</span></code></a>.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.luo_file">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_file</span></span></span><a class="headerlink" href="#c.luo_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>Represents a single preserved file instance.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct luo_file {
    struct liveupdate_file_handler *fh;
    struct file *file;
    u64 serialized_data;
    void *private_data;
    bool retrieved;
    struct mutex mutex;
    struct list_head list;
    u64 token;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fh</span></code></dt><dd><p>Pointer to the <a class="reference internal" href="#c.liveupdate_file_handler" title="liveupdate_file_handler"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">liveupdate_file_handler</span></code></a> that manages
this type of file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>Pointer to the kernel’s <a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a> that is being preserved.
This is NULL in the new kernel until the file is successfully
retrieved.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">serialized_data</span></code></dt><dd><p>The opaque u64 handle to the serialized state of the file.
This handle is passed back to the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code>,
.<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">retrieve()</span></code>, and .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish()</span></code> callbacks, allowing it to track
and update its serialized state across phases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private_data</span></code></dt><dd><p>Pointer to the private data for the file used to hold runtime
state that is not preserved. Set by the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preserve()</span></code>
callback, and must be freed in the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unpreserve()</span></code>
callback.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">retrieved</span></code></dt><dd><p>A flag indicating whether a user/kernel in the new kernel has
successfully called <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">retrieve()</span></code> on this file. This prevents
multiple retrieval attempts.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mutex</span></code></dt><dd><p>A mutex that protects the fields of this specific instance
(e.g., <strong>retrieved</strong>, <strong>file</strong>), ensuring that operations like
retrieving or finishing a file are atomic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list</span></code></dt><dd><p>The list_head linking this instance into its parent
file_set’s list of preserved files.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">token</span></code></dt><dd><p>The user-provided unique token used to identify this file.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>This structure is the core in-kernel representation of a single file being
managed through a live update. An instance is created by <a class="reference internal" href="#c.luo_preserve_file" title="luo_preserve_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_preserve_file()</span></code></a>
to link a ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’ to its corresponding handler, a user-provided token,
and the serialized state handle returned by the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preserve()</span></code>
operation.</p>
<p>These instances are tracked in a per-file_set list. The <strong>serialized_data</strong>
field, which holds a handle to the file’s serialized state, may be updated
during the .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code> callback before being serialized for the next kernel.
After reboot, these structures are recreated by <a class="reference internal" href="#c.luo_file_deserialize" title="luo_file_deserialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_deserialize()</span></code></a> and
are finally cleaned up by <a class="reference internal" href="#c.luo_file_finish" title="luo_file_finish"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_finish()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_preserve_file">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_preserve_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">luo_file_set</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">token</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">fd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_preserve_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initiate the preservation of a file descriptor.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set</span> <span class="pre">*file_set</span></code></dt><dd><p>The file_set to which the preserved file will be added.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">token</span></code></dt><dd><p>A unique, user-provided identifier for the file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>The file descriptor to be preserved.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function orchestrates the first phase of preserving a file. Upon entry,
it takes a reference to the ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’ via <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fget()</span></code>, effectively making LUO
a co-owner of the file. This reference is held until the file is either
unpreserved or successfully finished in the next kernel, preventing the file
from being prematurely destroyed.</p>
<p>This function orchestrates the first phase of preserving a file. It performs
the following steps:</p>
<ol class="arabic simple">
<li><p>Validates that the <strong>token</strong> is not already in use within the file_set.</p></li>
<li><p>Ensures the file_set’s memory for files serialization is allocated
(allocates if needed).</p></li>
<li><p>Iterates through registered handlers, calling <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">can_preserve()</span></code> to find one
compatible with the given <strong>fd</strong>.</p></li>
<li><p>Calls the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preserve()</span></code> operation, which saves the file’s state
and returns an opaque private data handle.</p></li>
<li><p>Adds the new instance to the file_set’s internal list.</p></li>
</ol>
<p>On success, LUO takes a reference to the ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’ and considers it
under its management until it is unpreserved or finished.</p>
<p>In case of any failure, all intermediate allocations (file reference, memory
for the ‘luo_file’ struct, etc.) are cleaned up before returning an error.</p>
<p><strong>Context</strong></p>
<p>Can be called from an ioctl handler during normal system operation.</p>
<p><strong>Return</strong></p>
<p>0 on success. Returns a negative errno on failure:
-EEXIST if the token is already used.
-EBADF if the file descriptor is invalid.
-ENOSPC if the file_set is full.
-ENOENT if no compatible handler is found.
-ENOMEM on memory allocation failure.
Other erros might be returned by .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preserve()</span></code>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_file_unpreserve_files">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_file_unpreserve_files</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">luo_file_set</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_file_unpreserve_files" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpreserves all files from a file_set.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set</span> <span class="pre">*file_set</span></code></dt><dd><p>The files to be cleaned up.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function serves as the primary cleanup path for a file_set. It is
invoked when the userspace agent closes the file_set’s file descriptor.</p>
<dl class="simple">
<dt>For each file, it performs the following cleanup actions:</dt><dd><ol class="arabic simple">
<li><p>Calls the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unpreserve()</span></code> callback to allow the handler to
release any resources it allocated.</p></li>
<li><p>Removes the file from the file_set’s internal tracking list.</p></li>
<li><p>Releases the reference to the ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’ that was taken by
<a class="reference internal" href="#c.luo_preserve_file" title="luo_preserve_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_preserve_file()</span></code></a> via <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fput()</span></code>, returning ownership.</p></li>
<li><p>Frees the memory associated with the internal ‘<a class="reference internal" href="#c.luo_file" title="luo_file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file</span></code></a>’.</p></li>
</ol>
</dd>
</dl>
<p>After all individual files are unpreserved, it frees the contiguous memory
block that was allocated to hold their serialization data.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_file_freeze">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_file_freeze</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">luo_file_set</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.luo_file_set_ser" title="luo_file_set_ser"><span class="n"><span class="pre">luo_file_set_ser</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set_ser</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_file_freeze" title="Link to this definition">¶</a><br /></dt>
<dd><p>Freezes all preserved files and serializes their metadata.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set</span> <span class="pre">*file_set</span></code></dt><dd><p>The file_set whose files are to be frozen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set_ser</span> <span class="pre">*file_set_ser</span></code></dt><dd><p>Where to put the serialized file_set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called from the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">reboot()</span></code> syscall path, just before the
kernel transitions to the new image via kexec. Its purpose is to perform the
final preparation and serialization of all preserved files in the file_set.</p>
<p>It iterates through each preserved file in FIFO order (the order of
preservation) and performs two main actions:</p>
<ol class="arabic simple">
<li><p>Freezes the File: It calls the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code> callback for each
file. This gives the handler a final opportunity to quiesce the device or
prepare its state for the upcoming reboot. The handler may update its
private data handle during this step.</p></li>
<li><p>Serializes Metadata: After a successful freeze, it copies the final file
metadata—the handler’s compatible string, the user token, and the final
private data handle—into the pre-allocated contiguous memory buffer
(file_set-&gt;files) that will be handed over to the next kernel via KHO.</p></li>
</ol>
<p>Error Handling (Rollback):
This function is atomic. If any handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">freeze()</span></code> operation fails, the
entire live update is aborted. The <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">__luo_file_unfreeze()</span></code> helper is
immediately called to invoke the .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unfreeze()</span></code> op on all files that were
successfully frozen before the point of failure, rolling them back to a
running state. The function then returns an error, causing the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">reboot()</span></code>
syscall to fail.</p>
<p><strong>Context</strong></p>
<p>Called only from the <a class="reference internal" href="#c.liveupdate_reboot" title="liveupdate_reboot"><code class="xref c c-func docutils literal notranslate"><span class="pre">liveupdate_reboot()</span></code></a> path.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_file_unfreeze">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_file_unfreeze</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">luo_file_set</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.luo_file_set_ser" title="luo_file_set_ser"><span class="n"><span class="pre">luo_file_set_ser</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set_ser</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_file_unfreeze" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unfreezes all files in a file_set and clear serialization</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set</span> <span class="pre">*file_set</span></code></dt><dd><p>The file_set whose files are to be unfrozen.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set_ser</span> <span class="pre">*file_set_ser</span></code></dt><dd><p>Serialized file_set.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function rolls back the state of all files in a file_set after the
freeze phase has begun but must be aborted. It is the counterpart to
<a class="reference internal" href="#c.luo_file_freeze" title="luo_file_freeze"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_freeze()</span></code></a>.</p>
<p>It invokes the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">__luo_file_unfreeze()</span></code> helper with a NULL argument, which
signals the helper to iterate through all files in the file_set and call
their respective .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unfreeze()</span></code> handler callbacks.</p>
<p><strong>Context</strong></p>
<p>This is called when the live update is aborted during
the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">reboot()</span></code> syscall, after <a class="reference internal" href="#c.luo_file_freeze" title="luo_file_freeze"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_file_freeze()</span></code></a> has been called.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_retrieve_file">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_retrieve_file</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">luo_file_set</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set</span></span>, <span class="n"><span class="pre">u64</span></span><span class="w"> </span><span class="n"><span class="pre">token</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><span class="n"><span class="pre">file</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filep</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_retrieve_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>Restores a preserved file from a file_set by its token.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set</span> <span class="pre">*file_set</span></code></dt><dd><p>The file_set from which to retrieve the file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u64</span> <span class="pre">token</span></code></dt><dd><p>The unique token identifying the file to be restored.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">**filep</span></code></dt><dd><p>Output parameter; on success, this is populated with a pointer
to the newly retrieved ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is the primary mechanism for recreating a file in the new
kernel after a live update. It searches the file_set’s list of deserialized
files for an entry matching the provided <strong>token</strong>.</p>
<p>The operation is idempotent: if a file has already been successfully
retrieved, this function will simply return a pointer to the existing
‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’ and report success without re-executing the retrieve
operation. This is handled by checking the ‘retrieved’ flag under a lock.</p>
<p>File retrieval can happen in any order; it is not bound by the order of
preservation.</p>
<p><strong>Context</strong></p>
<p>Can be called from an ioctl or other in-kernel code in the new
kernel.</p>
<p><strong>Return</strong></p>
<p>0 on success. Returns a negative errno on failure:
-ENOENT if no file with the matching token is found.
Any error code returned by the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">retrieve()</span></code> op.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_file_finish">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_file_finish</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">luo_file_set</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_file_finish" title="Link to this definition">¶</a><br /></dt>
<dd><p>Completes the lifecycle for all files in a file_set.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set</span> <span class="pre">*file_set</span></code></dt><dd><p>The file_set to be finalized.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function orchestrates the final teardown of a live update file_set in
the new kernel. It should be called after all necessary files have been
retrieved and the userspace agent is ready to release the preserved state.</p>
<p>The function iterates through all tracked files. For each file, it performs
the following sequence of cleanup actions:</p>
<ol class="arabic simple">
<li><p>If file is not yet retrieved, retrieves it, and calls <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">can_finish()</span></code> on
every file in the file_set. If all can_finish return true, continue to
finish.</p></li>
<li><p>Calls the handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish()</span></code> callback (via luo_file_finish_one) to
allow for final resource cleanup within the handler.</p></li>
<li><p>Releases LUO’s ownership reference on the ‘<a class="reference internal" href="../filesystems/api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>’ via <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fput()</span></code>. This
is the counterpart to the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_file()</span></code> call in <a class="reference internal" href="#c.luo_retrieve_file" title="luo_retrieve_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_retrieve_file()</span></code></a>.</p></li>
<li><p>Removes the ‘<a class="reference internal" href="#c.luo_file" title="luo_file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file</span></code></a>’ from the file_set’s internal list.</p></li>
<li><p>Frees the memory for the ‘<a class="reference internal" href="#c.luo_file" title="luo_file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file</span></code></a>’ instance itself.</p></li>
</ol>
<p>After successfully finishing all individual files, it frees the
contiguous memory block that was used to transfer the serialized metadata
from the previous kernel.</p>
<p>Error Handling (Atomic Failure):
This operation is atomic. If any handler’s .<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">can_finish()</span></code> op fails, the entire
function aborts immediately and returns an error.</p>
<p><strong>Context</strong></p>
<p>Can be called from an ioctl handler in the new kernel.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.luo_file_deserialize">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">luo_file_deserialize</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">luo_file_set</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.luo_file_set_ser" title="luo_file_set_ser"><span class="n"><span class="pre">luo_file_set_ser</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file_set_ser</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.luo_file_deserialize" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reconstructs the list of preserved files in the new kernel.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set</span> <span class="pre">*file_set</span></code></dt><dd><p>The incoming file_set to fill with deserialized data.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_set_ser</span> <span class="pre">*file_set_ser</span></code></dt><dd><p>Serialized KHO file_set data from the previous kernel.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called during the early boot process of the new kernel. It
takes the raw, contiguous memory block of ‘<a class="reference internal" href="#c.luo_file_ser" title="luo_file_ser"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file_ser</span></code></a>’ entries,
provided by the previous kernel, and transforms it back into a live,
in-memory linked list of ‘<a class="reference internal" href="#c.luo_file" title="luo_file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file</span></code></a>’ instances.</p>
<dl class="simple">
<dt>For each serialized entry, it performs the following steps:</dt><dd><ol class="arabic simple">
<li><p>Reads the ‘compatible’ string.</p></li>
<li><p>Searches the global list of registered file handlers for one that
matches the compatible string.</p></li>
<li><p>Allocates a new ‘<a class="reference internal" href="#c.luo_file" title="luo_file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file</span></code></a>’.</p></li>
<li><p>Populates the new structure with the deserialized data (token, private
data handle) and links it to the found handler. The ‘file’ pointer is
initialized to NULL, as the file has not been retrieved yet.</p></li>
<li><p>Adds the new ‘<a class="reference internal" href="#c.luo_file" title="luo_file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">luo_file</span></code></a>’ to the file_set’s files_list.</p></li>
</ol>
</dd>
</dl>
<p>This prepares the file_set for userspace, which can later call
<a class="reference internal" href="#c.luo_retrieve_file" title="luo_retrieve_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">luo_retrieve_file()</span></code></a> to restore the actual file descriptors.</p>
<p><strong>Context</strong></p>
<p>Called from session deserialization.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.liveupdate_register_file_handler">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">liveupdate_register_file_handler</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.liveupdate_file_handler" title="liveupdate_file_handler"><span class="n"><span class="pre">liveupdate_file_handler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fh</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.liveupdate_register_file_handler" title="Link to this definition">¶</a><br /></dt>
<dd><p>Register a file handler with LUO.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">liveupdate_file_handler</span> <span class="pre">*fh</span></code></dt><dd><p>Pointer to a caller-allocated <a class="reference internal" href="#c.liveupdate_file_handler" title="liveupdate_file_handler"><code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">liveupdate_file_handler</span></code></a>.
The caller must initialize this structure, including a unique
‘compatible’ string and a valid ‘fh’ callbacks. This function adds the
handler to the global list of supported file handlers.</p>
</dd>
</dl>
<p><strong>Context</strong></p>
<p>Typically called during module initialization for file types that
support live update preservation.</p>
<p><strong>Return</strong></p>
<p>0 on success. Negative errno on failure.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.liveupdate_unregister_file_handler">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">liveupdate_unregister_file_handler</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.liveupdate_file_handler" title="liveupdate_file_handler"><span class="n"><span class="pre">liveupdate_file_handler</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fh</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.liveupdate_unregister_file_handler" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unregister a liveupdate file handler</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">liveupdate_file_handler</span> <span class="pre">*fh</span></code></dt><dd><p>The file handler to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters the file handler from the liveupdate core. This function
reverses the operations of <a class="reference internal" href="#c.liveupdate_register_file_handler" title="liveupdate_register_file_handler"><code class="xref c c-func docutils literal notranslate"><span class="pre">liveupdate_register_file_handler()</span></code></a>.</p>
<p>It ensures safe removal by checking that:
No live update session is currently in progress.</p>
<p>If the unregistration fails, the internal test state is reverted.</p>
<p><strong>Return</strong></p>
<p>0 Success. -EOPNOTSUPP when live update is not enabled. -EBUSY A live
update is in progress, can’t quiesce live update.</p>
</div>
</section>
<section id="see-also">
<h2>See Also<a class="headerlink" href="#see-also" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="../userspace-api/liveupdate.html"><span class="doc">Live Update uAPI</span></a></p></li>
<li><p><a class="reference internal" href="kho/concepts.html"><span class="doc">Kexec Handover Concepts</span></a></p></li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/core-api/liveupdate.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>