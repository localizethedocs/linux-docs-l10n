<!DOCTYPE html>

<html lang="en-US" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Linux Color Pipeline API &#8212; The Linux Kernel unknown version documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../_static/documentation_options.js?v=750ed68d"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/gpu/rfc/color_pipeline.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Frame Buffer" href="../../fb/index.html" />
    <link rel="prev" title="I915 VM_BIND feature design and use cases" href="i915_vm_bind.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../input/index.html">Input Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">GPU Driver Developer’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/gpu/rfc/color_pipeline.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="linux-color-pipeline-api">
<h1>Linux Color Pipeline API<a class="headerlink" href="#linux-color-pipeline-api" title="Link to this heading">¶</a></h1>
<section id="what-problem-are-we-solving">
<h2>What problem are we solving?<a class="headerlink" href="#what-problem-are-we-solving" title="Link to this heading">¶</a></h2>
<p>We would like to support pre-, and post-blending complex color
transformations in display controller hardware in order to allow for
HW-supported HDR use-cases, as well as to provide support to
color-managed applications, such as video or image editors.</p>
<p>It is possible to support an HDR output on HW supporting the Colorspace
and HDR Metadata drm_connector properties, but that requires the
compositor or application to render and compose the content into one
final buffer intended for display. Doing so is costly.</p>
<p>Most modern display HW offers various 1D LUTs, 3D LUTs, matrices, and other
operations to support color transformations. These operations are often
implemented in fixed-function HW and therefore much more power efficient than
performing similar operations via shaders or CPU.</p>
<p>We would like to make use of this HW functionality to support complex color
transformations with no, or minimal CPU or shader load. The switch between HW
fixed-function blocks and shaders/CPU must be seamless with no visible
difference when fallback to shaders/CPU is neceesary at any time.</p>
</section>
<section id="how-are-other-oses-solving-this-problem">
<h2>How are other OSes solving this problem?<a class="headerlink" href="#how-are-other-oses-solving-this-problem" title="Link to this heading">¶</a></h2>
<p>The most widely supported use-cases regard HDR content, whether video or
gaming.</p>
<p>Most OSes will specify the source content format (color gamut, encoding transfer
function, and other metadata, such as max and average light levels) to a driver.
Drivers will then program their fixed-function HW accordingly to map from a
source content buffer’s space to a display’s space.</p>
<p>When fixed-function HW is not available the compositor will assemble a shader to
ask the GPU to perform the transformation from the source content format to the
display’s format.</p>
<p>A compositor’s mapping function and a driver’s mapping function are usually
entirely separate concepts. On OSes where a HW vendor has no insight into
closed-source compositor code such a vendor will tune their color management
code to visually match the compositor’s. On other OSes, where both mapping
functions are open to an implementer they will ensure both mappings match.</p>
<p>This results in mapping algorithm lock-in, meaning that no-one alone can
experiment with or introduce new mapping algorithms and achieve
consistent results regardless of which implementation path is taken.</p>
</section>
<section id="why-is-linux-different">
<h2>Why is Linux different?<a class="headerlink" href="#why-is-linux-different" title="Link to this heading">¶</a></h2>
<p>Unlike other OSes, where there is one compositor for one or more drivers, on
Linux we have a many-to-many relationship. Many compositors; many drivers.
In addition each compositor vendor or community has their own view of how
color management should be done. This is what makes Linux so beautiful.</p>
<p>This means that a HW vendor can now no longer tune their driver to one
compositor, as tuning it to one could make it look fairly different from
another compositor’s color mapping.</p>
<p>We need a better solution.</p>
</section>
<section id="descriptive-api">
<h2>Descriptive API<a class="headerlink" href="#descriptive-api" title="Link to this heading">¶</a></h2>
<p>An API that describes the source and destination colorspaces is a descriptive
API. It describes the input and output color spaces but does not describe
how precisely they should be mapped. Such a mapping includes many minute
design decision that can greatly affect the look of the final result.</p>
<p>It is not feasible to describe such mapping with enough detail to ensure the
same result from each implementation. In fact, these mappings are a very active
research area.</p>
</section>
<section id="prescriptive-api">
<h2>Prescriptive API<a class="headerlink" href="#prescriptive-api" title="Link to this heading">¶</a></h2>
<p>A prescriptive API describes not the source and destination colorspaces. It
instead prescribes a recipe for how to manipulate pixel values to arrive at the
desired outcome.</p>
<p>This recipe is generally an ordered list of straight-forward operations,
with clear mathematical definitions, such as 1D LUTs, 3D LUTs, matrices,
or other operations that can be described in a precise manner.</p>
</section>
<section id="the-color-pipeline-api">
<h2>The Color Pipeline API<a class="headerlink" href="#the-color-pipeline-api" title="Link to this heading">¶</a></h2>
<p>HW color management pipelines can significantly differ between HW
vendors in terms of availability, ordering, and capabilities of HW
blocks. This makes a common definition of color management blocks and
their ordering nigh impossible. Instead we are defining an API that
allows user space to discover the HW capabilities in a generic manner,
agnostic of specific drivers and hardware.</p>
</section>
<section id="drm-colorop-object">
<h2>drm_colorop Object<a class="headerlink" href="#drm-colorop-object" title="Link to this heading">¶</a></h2>
<p>To support the definition of color pipelines we define the DRM core
object type drm_colorop. Individual drm_colorop objects will be chained
via the NEXT property of a drm_colorop to constitute a color pipeline.
Each drm_colorop object is unique, i.e., even if multiple color
pipelines have the same operation they won’t share the same drm_colorop
object to describe that operation.</p>
<p>Note that drivers are not expected to map drm_colorop objects statically
to specific HW blocks. The mapping of drm_colorop objects is entirely a
driver-internal detail and can be as dynamic or static as a driver needs
it to be. See more in the Driver Implementation Guide section below.</p>
<p>Each drm_colorop has three core properties:</p>
<p>TYPE: An enumeration property, defining the type of transformation, such as
* enumerated curve
* custom (uniform) 1D LUT
* 3x3 matrix
* 3x4 matrix
* 3D LUT
* etc.</p>
<p>Depending on the type of transformation other properties will describe
more details.</p>
<p>BYPASS: A boolean property that can be used to easily put a block into
bypass mode. The BYPASS property is not mandatory for a colorop, as long
as the entire pipeline can get bypassed by setting the COLOR_PIPELINE on
a plane to ‘0’.</p>
<p>NEXT: The ID of the next drm_colorop in a color pipeline, or 0 if this
drm_colorop is the last in the chain.</p>
<p>An example of a drm_colorop object might look like one of these:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* 1D enumerated curve */
Color operation 42
├─ &quot;TYPE&quot;: immutable enum {1D enumerated curve, 1D LUT, 3x3 matrix, 3x4 matrix, 3D LUT, etc.} = 1D enumerated curve
├─ &quot;BYPASS&quot;: bool {true, false}
├─ &quot;CURVE_1D_TYPE&quot;: enum {sRGB EOTF, sRGB inverse EOTF, PQ EOTF, PQ inverse EOTF, …}
└─ &quot;NEXT&quot;: immutable color operation ID = 43

/* custom 4k entry 1D LUT */
Color operation 52
├─ &quot;TYPE&quot;: immutable enum {1D enumerated curve, 1D LUT, 3x3 matrix, 3x4 matrix, 3D LUT, etc.} = 1D LUT
├─ &quot;BYPASS&quot;: bool {true, false}
├─ &quot;SIZE&quot;: immutable range = 4096
├─ &quot;DATA&quot;: blob
└─ &quot;NEXT&quot;: immutable color operation ID = 0

/* 17^3 3D LUT */
Color operation 72
├─ &quot;TYPE&quot;: immutable enum {1D enumerated curve, 1D LUT, 3x3 matrix, 3x4 matrix, 3D LUT, etc.} = 3D LUT
├─ &quot;BYPASS&quot;: bool {true, false}
├─ &quot;SIZE&quot;: immutable range = 17
├─ &quot;DATA&quot;: blob
└─ &quot;NEXT&quot;: immutable color operation ID = 73
</pre></div>
</div>
<section id="drm-colorop-extensibility">
<h3>drm_colorop extensibility<a class="headerlink" href="#drm-colorop-extensibility" title="Link to this heading">¶</a></h3>
<p>Unlike existing DRM core objects, like &amp;drm_plane, drm_colorop is not
extensible. This simplifies implementations and keeps all functionality
for managing &amp;drm_colorop objects in the DRM core.</p>
<p>If there is a need one may introduce a simple &amp;drm_colorop_funcs
function table in the future, for example to support an IN_FORMATS
property on a &amp;drm_colorop.</p>
<p>If a driver requires the ability to create a driver-specific colorop
object they will need to add &amp;drm_colorop func table support with
support for the usual functions, like destroy, atomic_duplicate_state,
and atomic_destroy_state.</p>
</section>
</section>
<section id="color-pipeline-plane-property">
<h2>COLOR_PIPELINE Plane Property<a class="headerlink" href="#color-pipeline-plane-property" title="Link to this heading">¶</a></h2>
<p>Color Pipelines are created by a driver and advertised via a new
COLOR_PIPELINE <code class="xref c c-enum broken_xref docutils literal notranslate"><span class="pre">enum</span> <span class="pre">property</span></code> on each plane. Values of the property
always include object id 0, which is the default and means all color
processing is disabled. Additional values will be the object IDs of the
first drm_colorop in a pipeline. A driver can create and advertise none,
one, or more possible color pipelines. A DRM client will select a color
pipeline by setting the COLOR PIPELINE to the respective value.</p>
<p>NOTE: Many DRM clients will set enumeration properties via the string
value, often hard-coding it. Since this enumeration is generated based
on the colorop object IDs it is important to perform the Color Pipeline
Discovery, described below, instead of hard-coding color pipeline
assignment. Drivers might generate the <code class="xref c c-enum broken_xref docutils literal notranslate"><span class="pre">enum</span> <span class="pre">strings</span></code> dynamically.
Hard-coded strings might only work for specific drivers on a specific
pieces of HW. Color Pipeline Discovery can work universally, as long as
drivers implement the required color operations.</p>
<p>The COLOR_PIPELINE property is only exposed when the
DRM_CLIENT_CAP_PLANE_COLOR_PIPELINE is set. Drivers shall ignore any
existing pre-blend color operations when this cap is set, such as
COLOR_RANGE and COLOR_ENCODING. If drivers want to support COLOR_RANGE
or COLOR_ENCODING functionality when the color pipeline client cap is
set, they are expected to expose colorops in the pipeline to allow for
the appropriate color transformation.</p>
<p>Setting of the COLOR_PIPELINE plane property or drm_colorop properties
is only allowed for userspace that sets this client cap.</p>
<p>An example of a COLOR_PIPELINE property on a plane might look like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Plane 10
├─ &quot;TYPE&quot;: immutable enum {Overlay, Primary, Cursor} = Primary
├─ …
└─ &quot;COLOR_PIPELINE&quot;: enum {0, 42, 52} = 0
</pre></div>
</div>
</section>
<section id="color-pipeline-discovery">
<h2>Color Pipeline Discovery<a class="headerlink" href="#color-pipeline-discovery" title="Link to this heading">¶</a></h2>
<p>A DRM client wanting color management on a drm_plane will:</p>
<ol class="arabic simple">
<li><p>Get the COLOR_PIPELINE property of the plane</p></li>
<li><p>iterate all COLOR_PIPELINE <code class="xref c c-enum broken_xref docutils literal notranslate"><span class="pre">enum</span> <span class="pre">values</span></code></p></li>
<li><p>for each <code class="xref c c-enum broken_xref docutils literal notranslate"><span class="pre">enum</span> <span class="pre">value</span></code> walk the color pipeline (via the NEXT pointers)
and see if the available color operations are suitable for the
desired color management operations</p></li>
</ol>
<p>If userspace encounters an unknown or unsuitable color operation during
discovery it does not need to reject the entire color pipeline outright,
as long as the unknown or unsuitable colorop has a “BYPASS” property.
Drivers will ensure that a bypassed block does not have any effect.</p>
<p>An example of chained properties to define an AMD pre-blending color
pipeline might look like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Plane 10
├─ &quot;TYPE&quot; (immutable) = Primary
└─ &quot;COLOR_PIPELINE&quot;: enum {0, 44} = 0

Color operation 44
├─ &quot;TYPE&quot; (immutable) = 1D enumerated curve
├─ &quot;BYPASS&quot;: bool
├─ &quot;CURVE_1D_TYPE&quot;: enum {sRGB EOTF, PQ EOTF} = sRGB EOTF
└─ &quot;NEXT&quot; (immutable) = 45

Color operation 45
├─ &quot;TYPE&quot; (immutable) = 3x4 Matrix
├─ &quot;BYPASS&quot;: bool
├─ &quot;DATA&quot;: blob
└─ &quot;NEXT&quot; (immutable) = 46

Color operation 46
├─ &quot;TYPE&quot; (immutable) = 1D enumerated curve
├─ &quot;BYPASS&quot;: bool
├─ &quot;CURVE_1D_TYPE&quot;: enum {sRGB Inverse EOTF, PQ Inverse EOTF} = sRGB EOTF
└─ &quot;NEXT&quot; (immutable) = 47

Color operation 47
├─ &quot;TYPE&quot; (immutable) = 1D LUT
├─ &quot;SIZE&quot;: immutable range = 4096
├─ &quot;DATA&quot;: blob
└─ &quot;NEXT&quot; (immutable) = 48

Color operation 48
├─ &quot;TYPE&quot; (immutable) = 3D LUT
├─ &quot;DATA&quot;: blob
└─ &quot;NEXT&quot; (immutable) = 49

Color operation 49
├─ &quot;TYPE&quot; (immutable) = 1D enumerated curve
├─ &quot;BYPASS&quot;: bool
├─ &quot;CURVE_1D_TYPE&quot;: enum {sRGB EOTF, PQ EOTF} = sRGB EOTF
└─ &quot;NEXT&quot; (immutable) = 0
</pre></div>
</div>
</section>
<section id="color-pipeline-programming">
<h2>Color Pipeline Programming<a class="headerlink" href="#color-pipeline-programming" title="Link to this heading">¶</a></h2>
<p>Once a DRM client has found a suitable pipeline it will:</p>
<ol class="arabic simple">
<li><p>Set the COLOR_PIPELINE <code class="xref c c-enum broken_xref docutils literal notranslate"><span class="pre">enum</span> <span class="pre">value</span></code> to the one pointing at the first
drm_colorop object of the desired pipeline</p></li>
<li><p>Set the properties for all drm_colorop objects in the pipeline to the
desired values, setting BYPASS to true for unused drm_colorop blocks,
and false for enabled drm_colorop blocks</p></li>
<li><p>Perform (TEST_ONLY or not) atomic commit with all the other KMS
states it wishes to change</p></li>
</ol>
<p>To configure the pipeline for an HDR10 PQ plane and blending in linear
space, a compositor might perform an atomic commit with the following
property values:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Plane 10
└─ &quot;COLOR_PIPELINE&quot; = 42

Color operation 42
└─ &quot;BYPASS&quot; = true

Color operation 44
└─ &quot;BYPASS&quot; = true

Color operation 45
└─ &quot;BYPASS&quot; = true

Color operation 46
└─ &quot;BYPASS&quot; = true

Color operation 47
├─ &quot;DATA&quot; = Gamut mapping + tone mapping + night mode
└─ &quot;BYPASS&quot; = false

Color operation 48
├─ &quot;CURVE_1D_TYPE&quot; = PQ EOTF
└─ &quot;BYPASS&quot; = false
</pre></div>
</div>
</section>
<section id="driver-implementer-s-guide">
<h2>Driver Implementer’s Guide<a class="headerlink" href="#driver-implementer-s-guide" title="Link to this heading">¶</a></h2>
<p>What does this all mean for driver implementations? As noted above the
colorops can map to HW directly but don’t need to do so. Here are some
suggestions on how to think about creating your color pipelines:</p>
<ul class="simple">
<li><p>Try to expose pipelines that use already defined colorops, even if
your hardware pipeline is split differently. This allows existing
userspace to immediately take advantage of the hardware.</p></li>
<li><p>Additionally, try to expose your actual hardware blocks as colorops.
Define new colorop types where you believe it can offer significant
benefits if userspace learns to program them.</p></li>
<li><p>Avoid defining new colorops for compound operations with very narrow
scope. If you have a hardware block for a special operation that
cannot be split further, you can expose that as a new colorop type.
However, try to not define colorops for “use cases”, especially if
they require you to combine multiple hardware blocks.</p></li>
<li><p>Design new colorops as prescriptive, not descriptive; by the
mathematical formula, not by the assumed input and output.</p></li>
</ul>
<p>A defined colorop type must be deterministic. The exact behavior of the
colorop must be documented entirely, whether via a mathematical formula
or some other description. Its operation can depend only on its
properties and input and nothing else, allowed error tolerance
notwithstanding.</p>
</section>
<section id="driver-forward-backward-compatibility">
<h2>Driver Forward/Backward Compatibility<a class="headerlink" href="#driver-forward-backward-compatibility" title="Link to this heading">¶</a></h2>
<p>As this is uAPI drivers can’t regress color pipelines that have been
introduced for a given HW generation. New HW generations are free to
abandon color pipelines advertised for previous generations.
Nevertheless, it can be beneficial to carry support for existing color
pipelines forward as those will likely already have support in DRM
clients.</p>
<p>Introducing new colorops to a pipeline is fine, as long as they can be
bypassed or are purely informational. DRM clients implementing support
for the pipeline can always skip unknown properties as long as they can
be confident that doing so will not cause unexpected results.</p>
<p>If a new colorop doesn’t fall into one of the above categories
(bypassable or informational) the modified pipeline would be unusable
for user space. In this case a new pipeline should be defined.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://lore.kernel.org/dri-devel/QMers3awXvNCQlyhWdTtsPwkp5ie9bze_hD5nAccFW7a_RXlWjYB7MoUW_8CKLT2bSQwIXVi5H6VULYIxCdgvryZoAoJnC5lZgyK1QWn488=&#64;emersion.fr/">https://lore.kernel.org/dri-devel/QMers3awXvNCQlyhWdTtsPwkp5ie9bze_hD5nAccFW7a_RXlWjYB7MoUW_8CKLT2bSQwIXVi5H6VULYIxCdgvryZoAoJnC5lZgyK1QWn488=&#64;emersion.fr/</a></p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/gpu/rfc/color_pipeline.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>