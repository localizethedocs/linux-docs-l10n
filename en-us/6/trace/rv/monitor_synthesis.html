<!DOCTYPE html>

<html lang="en-US" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Runtime Verification Monitor Synthesis &#8212; The Linux Kernel  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../_static/documentation_options.js?v=ccd1e645"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/trace/rv/monitor_synthesis.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Deterministic Automata Instrumentation" href="da_monitor_instrumentation.html" />
    <link rel="prev" title="Linear temporal logic" href="linear_temporal_logic.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.18.0-rc2</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Tracing</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#introduction-to-tracing">Introduction to Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#core-tracing-frameworks">Core Tracing Frameworks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#event-tracing-and-analysis">Event Tracing and Analysis</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#hardware-and-performance-tracing">Hardware and Performance Tracing</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../intel_th.html">Intel(R) Trace Hub (TH)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stm.html">System Trace Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sys-t.html">MIPI SyS-T over STP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../coresight/index.html">CoreSight - ARM Hardware Trace</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Runtime Verification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hisi-ptt.html">HiSilicon PCIe Tune and Trace device</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmiotrace.html">In-kernel memory-mapped I/O tracing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hwlat_detector.html">Hardware Latency Detector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../osnoise-tracer.html">OSNOISE Tracer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timerlat-tracer.html">Timerlat tracer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#user-space-tracing">User-Space Tracing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#additional-resources">Additional Resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/trace/rv/monitor_synthesis.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="runtime-verification-monitor-synthesis">
<h1>Runtime Verification Monitor Synthesis<a class="headerlink" href="#runtime-verification-monitor-synthesis" title="Link to this heading">Â¶</a></h1>
<p>The starting point for the application of runtime verification (RV) techniques
is the <em>specification</em> or <em>modeling</em> of the desired (or undesired) behavior
of the system under scrutiny.</p>
<p>The formal representation needs to be then <em>synthesized</em> into a <em>monitor</em>
that can then be used in the analysis of the trace of the system. The
<em>monitor</em> connects to the system via an <em>instrumentation</em> that converts
the events from the <em>system</em> to the events of the <em>specification</em>.</p>
<p>In Linux terms, the runtime verification monitors are encapsulated inside
the <em>RV monitor</em> abstraction. The RV monitor includes a set of instances
of the monitor (per-cpu monitor, per-task monitor, and so on), the helper
functions that glue the monitor to the system reference model, and the
trace output as a reaction to event parsing and exceptions, as depicted
below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Linux  +----- RV Monitor ----------------------------------+ Formal
 Realm |                                                   |  Realm
 +-------------------+     +----------------+     +-----------------+
 |   Linux kernel    |     |     Monitor    |     |     Reference   |
 |     Tracing       |  -&gt; |   Instance(s)  | &lt;-  |       Model     |
 | (instrumentation) |     | (verification) |     | (specification) |
 +-------------------+     +----------------+     +-----------------+
        |                          |                       |
        |                          V                       |
        |                     +----------+                 |
        |                     | Reaction |                 |
        |                     +--+--+--+-+                 |
        |                        |  |  |                   |
        |                        |  |  +-&gt; trace output ?  |
        +------------------------|--|----------------------+
                                 |  +----&gt; panic ?
                                 +-------&gt; &lt;user-specified&gt;
</pre></div>
</div>
<section id="rv-monitor-synthesis">
<h2>RV monitor synthesis<a class="headerlink" href="#rv-monitor-synthesis" title="Link to this heading">Â¶</a></h2>
<p>The synthesis of a specification into the Linux <em>RV monitor</em> abstraction is
automated by the rvgen tool and the header file containing common code for
creating monitors. The header files are:</p>
<blockquote>
<div><ul class="simple">
<li><p>rv/da_monitor.h for deterministic automaton monitor.</p></li>
<li><p>rv/ltl_monitor.h for linear temporal logic monitor.</p></li>
</ul>
</div></blockquote>
</section>
<section id="rvgen">
<h2>rvgen<a class="headerlink" href="#rvgen" title="Link to this heading">Â¶</a></h2>
<p>The rvgen utility converts a specification into the C presentation and creating
the skeleton of a kernel monitor in C.</p>
<p>For example, it is possible to transform the wip.dot model present in
[1] into a per-cpu monitor with the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ rvgen monitor -c da -s wip.dot -t per_cpu
</pre></div>
</div>
<p>This will create a directory named wip/ with the following files:</p>
<ul class="simple">
<li><p>wip.h: the wip model in C</p></li>
<li><p>wip.c: the RV monitor</p></li>
</ul>
<p>The wip.c file contains the monitor declaration and the starting point for
the system instrumentation.</p>
<p>Similarly, a linear temporal logic monitor can be generated with the following
command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ rvgen monitor -c ltl -s pagefault.ltl -t per_task
</pre></div>
</div>
<p>This generates pagefault/ directory with:</p>
<ul class="simple">
<li><p>pagefault.h: The Buchi automaton (the non-deterministic state machine to
verify the specification)</p></li>
<li><p>pagefault.c: The skeleton for the RV monitor</p></li>
</ul>
</section>
<section id="monitor-header-files">
<h2>Monitor header files<a class="headerlink" href="#monitor-header-files" title="Link to this heading">Â¶</a></h2>
<p>The header files:</p>
<ul class="simple">
<li><p><cite>rv/da_monitor.h</cite> for deterministic automaton monitor</p></li>
<li><p><cite>rv/ltl_monitor</cite> for linear temporal logic monitor</p></li>
</ul>
<p>include common macros and static functions for implementing <em>Monitor
Instance(s)</em>.</p>
<p>The benefits of having all common functionalities in a single header file are
3-fold:</p>
<blockquote>
<div><ul class="simple">
<li><p>Reduce the code duplication;</p></li>
<li><p>Facilitate the bug fix/improvement;</p></li>
<li><p>Avoid the case of developers changing the core of the monitor code to
manipulate the model in a (letâs say) non-standard way.</p></li>
</ul>
</div></blockquote>
<section id="rv-da-monitor-h">
<h3>rv/da_monitor.h<a class="headerlink" href="#rv-da-monitor-h" title="Link to this heading">Â¶</a></h3>
<p>This initial implementation presents three different types of monitor instances:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">DECLARE_DA_MON_GLOBAL(name,</span> <span class="pre">type)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">DECLARE_DA_MON_PER_CPU(name,</span> <span class="pre">type)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">DECLARE_DA_MON_PER_TASK(name,</span> <span class="pre">type)</span></code></p></li>
</ul>
<p>The first declares the functions for a global deterministic automata monitor,
the second for monitors with per-cpu instances, and the third with per-task
instances.</p>
<p>In all cases, the ânameâ argument is a string that identifies the monitor, and
the âtypeâ argument is the data type used by rvgen on the representation of
the model in C.</p>
<p>For example, the wip model with two states and three events can be
stored in an âunsigned charâ type. Considering that the preemption control
is a per-cpu behavior, the monitor declaration in the âwip.câ file is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DECLARE_DA_MON_PER_CPU(wip, unsigned char);
</pre></div>
</div>
<p>The monitor is executed by sending events to be processed via the functions
presented below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>da_handle_event_$(MONITOR_NAME)($(event from event enum));
da_handle_start_event_$(MONITOR_NAME)($(event from event enum));
da_handle_start_run_event_$(MONITOR_NAME)($(event from event enum));
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">da_handle_event_$(MONITOR_NAME)()</span></code> is the regular case where
the event will be processed if the monitor is processing events.</p>
<p>When a monitor is enabled, it is placed in the initial state of the automata.
However, the monitor does not know if the system is in the <em>initial state</em>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">da_handle_start_event_$(MONITOR_NAME)()</span></code> function is used to notify the
monitor that the system is returning to the initial state, so the monitor can
start monitoring the next event.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">da_handle_start_run_event_$(MONITOR_NAME)()</span></code> function is used to notify
the monitor that the system is known to be in the initial state, so the
monitor can start monitoring and monitor the current event.</p>
<p>Using the wip model as example, the events âpreempt_disableâ and
âsched_wakingâ should be sent to monitor, respectively, via [2]:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>da_handle_event_wip(preempt_disable_wip);
da_handle_event_wip(sched_waking_wip);
</pre></div>
</div>
<p>While the event âpreempt_enabledâ will use:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>da_handle_start_event_wip(preempt_enable_wip);
</pre></div>
</div>
<p>To notify the monitor that the system will be returning to the initial state,
so the system and the monitor should be in sync.</p>
</section>
<section id="rv-ltl-monitor-h">
<h3>rv/ltl_monitor.h<a class="headerlink" href="#rv-ltl-monitor-h" title="Link to this heading">Â¶</a></h3>
<p>This file must be combined with the $(MODEL_NAME).h file (generated by <cite>rvgen</cite>)
to be complete. For example, for the <cite>pagefault</cite> monitor, the <cite>pagefault.c</cite>
source file must include:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &quot;pagefault.h&quot;
#include &lt;rv/ltl_monitor.h&gt;
</pre></div>
</div>
<p>(the skeleton monitor file generated by <cite>rvgen</cite> already does this).</p>
<p><cite>$(MODEL_NAME).h</cite> (<cite>pagefault.h</cite> in the above example) includes the
implementation of the Buchi automaton - a non-deterministic state machine that
verifies the LTL specification. While <cite>rv/ltl_monitor.h</cite> includes the common
helper functions to interact with the Buchi automaton and to implement an RV
monitor. An important definition in <cite>$(MODEL_NAME).h</cite> is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>enum ltl_atom {
    LTL_$(FIRST_ATOMIC_PROPOSITION),
    LTL_$(SECOND_ATOMIC_PROPOSITION),
    ...
    LTL_NUM_ATOM
};
</pre></div>
</div>
<p>which is the list of atomic propositions present in the LTL specification
(prefixed with âLTL_â to avoid name collision). This <cite>enum</cite> is passed to the
functions interacting with the Buchi automaton.</p>
<p>While generating code, <cite>rvgen</cite> cannot understand the meaning of the atomic
propositions. Thus, that task is left for manual work. The recommended practice
is adding tracepoints to places where the atomic propositions change; and in the
tracepointsâ handlers: the Buchi automaton is executed using:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void ltl_atom_update(struct task_struct *task, enum ltl_atom atom, bool value)
</pre></div>
</div>
<p>which tells the Buchi automaton that the atomic proposition <cite>atom</cite> is now
<cite>value</cite>. The Buchi automaton checks whether the LTL specification is still
satisfied, and invokes the monitorâs error tracepoint and the reactor if
violation is detected.</p>
<p>Tracepoints and <cite><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ltl_atom_update()</span></code></cite> should be used whenever possible. However,
it is sometimes not the most convenient. For some atomic propositions which are
changed in multiple places in the kernel, it is cumbersome to trace all those
places. Furthermore, it may not be important that the atomic propositions are
updated at precise times. For example, considering the following linear temporal
logic:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RULE = always (RT imply not PAGEFAULT)
</pre></div>
</div>
<p>This LTL states that a real-time task does not raise page faults. For this
specification, it is not important when <cite>RT</cite> changes, as long as it has the
correct value when <cite>PAGEFAULT</cite> is true.  Motivated by this case, another
function is introduced:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void ltl_atom_fetch(struct task_struct *task, struct ltl_monitor *mon)
</pre></div>
</div>
<p>This function is called whenever the Buchi automaton is triggered. Therefore, it
can be manually implemented to âfetchâ <cite>RT</cite>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void ltl_atom_fetch(struct task_struct *task, struct ltl_monitor *mon)
{
    ltl_atom_set(mon, LTL_RT, rt_task(task));
}
</pre></div>
</div>
<p>Effectively, whenever <cite>PAGEFAULT</cite> is updated with a call to <cite><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ltl_atom_update()</span></code></cite>,
<cite>RT</cite> is also fetched. Thus, the LTL specification can be verified without
tracing <cite>RT</cite> everywhere.</p>
<p>For atomic propositions which act like events, they usually need to be set (or
cleared) and then immediately cleared (or set). A convenient function is
provided:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void ltl_atom_pulse(struct task_struct *task, enum ltl_atom atom, bool value)
</pre></div>
</div>
<p>which is equivalent to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ltl_atom_update(task, atom, value);
ltl_atom_update(task, atom, !value);
</pre></div>
</div>
<p>To initialize the atomic propositions, the following function must be
implemented:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ltl_atoms_init(struct task_struct *task, struct ltl_monitor *mon, bool task_creation)
</pre></div>
</div>
<p>This function is called for all running tasks when the monitor is enabled. It is
also called for new tasks created after the enabling the monitor. It should
initialize as many atomic propositions as possible, for example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void ltl_atom_init(struct task_struct *task, struct ltl_monitor *mon, bool task_creation)
{
    ltl_atom_set(mon, LTL_RT, rt_task(task));
    if (task_creation)
        ltl_atom_set(mon, LTL_PAGEFAULT, false);
}
</pre></div>
</div>
<p>Atomic propositions not initialized by <cite><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ltl_atom_init()</span></code></cite> will stay in the
unknown state until relevant tracepoints are hit, which can take some time. As
monitoring for a task cannot be done until all atomic propositions is known for
the task, the monitor may need some time to start validating tasks which have
been running before the monitor is enabled. Therefore, it is recommended to
start the tasks of interest after enabling the monitor.</p>
</section>
</section>
<section id="final-remarks">
<h2>Final remarks<a class="headerlink" href="#final-remarks" title="Link to this heading">Â¶</a></h2>
<p>With the monitor synthesis in place using the header files and
rvgen, the developerâs work should be limited to the instrumentation
of the system, increasing the confidence in the overall approach.</p>
<p>[1] For details about deterministic automata format and the translation
from one representation to another, see:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Documentation/trace/rv/deterministic_automata.rst
</pre></div>
</div>
<p>[2] rvgen appends the monitorâs name suffix to the events enums to
avoid conflicting variables when exporting the global vmlinux.h
use by BPF programs.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/trace/rv/monitor_synthesis.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>