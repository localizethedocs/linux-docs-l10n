<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Linked Lists in Linux &#8212; The Linux Kernel unknown version 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=adfc0c0d" />
    <script src="../_static/documentation_options.js?v=c459948e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/core-api/list.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Entry/exit handling for exceptions, interrupts, syscalls and KVM" href="entry.html" />
    <link rel="prev" title="Generic parser" href="parser.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kobject.html">Everything you never wanted to know about kobjects, ksets, and ktypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="kref.html">Adding reference counters (krefs) to kernel objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="cleanup.html">Scope-based Cleanup Helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="folio_queue.html">Folio Queue</a></li>
<li class="toctree-l3"><a class="reference internal" href="xarray.html">XArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="maple_tree.html">Maple Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="idr.html">ID Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="circular-buffers.html">Circular Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="rbtree.html">Red-black Trees (rbtree) in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-radix-tree.html">Generic radix trees/sparse arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="packing.html">Generic bitfield packing and unpacking functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="this_cpu_ops.html">this_cpu operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="timekeeping.html">ktime accessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="errseq.html">The errseq_t datatype</a></li>
<li class="toctree-l3"><a class="reference internal" href="wrappers/atomic_t.html">Atomic types</a></li>
<li class="toctree-l3"><a class="reference internal" href="wrappers/atomic_bitops.html">Atomic bitops</a></li>
<li class="toctree-l3"><a class="reference internal" href="floating-point.html">Floating-point API</a></li>
<li class="toctree-l3"><a class="reference internal" href="union_find.html">Union-Find in Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="min_heap.html">Min Heap API</a></li>
<li class="toctree-l3"><a class="reference internal" href="parser.html">Generic parser</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Linked Lists in Linux</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/list.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="linked-lists-in-linux">
<h1><a class="toc-backref" href="#id2" role="doc-backlink">Linked Lists in Linux</a><a class="headerlink" href="#linked-lists-in-linux" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Nicolas Frattaroli &lt;<a class="reference external" href="mailto:nicolas&#46;frattaroli&#37;&#52;&#48;collabora&#46;com">nicolas<span>&#46;</span>frattaroli<span>&#64;</span>collabora<span>&#46;</span>com</a>&gt;</p>
</dd>
</dl>
<nav class="contents" id="id1">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#linked-lists-in-linux" id="id2">Linked Lists in Linux</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction" id="id3">Introduction</a></p></li>
<li><p><a class="reference internal" href="#linux-implementation-of-doubly-linked-lists" id="id4">Linux implementation of doubly linked lists</a></p>
<ul>
<li><p><a class="reference internal" href="#declaring-a-node" id="id5">Declaring a node</a></p></li>
<li><p><a class="reference internal" href="#declaring-and-initializing-a-list" id="id6">Declaring and initializing a list</a></p></li>
<li><p><a class="reference internal" href="#adding-nodes-to-the-list" id="id7">Adding nodes to the list</a></p></li>
<li><p><a class="reference internal" href="#traversing-the-list" id="id8">Traversing the list</a></p></li>
<li><p><a class="reference internal" href="#removing-nodes-from-the-list" id="id9">Removing nodes from the list</a></p></li>
<li><p><a class="reference internal" href="#traversing-whilst-removing-nodes" id="id10">Traversing whilst removing nodes</a></p></li>
<li><p><a class="reference internal" href="#cutting-a-list" id="id11">Cutting a list</a></p></li>
<li><p><a class="reference internal" href="#moving-entries-and-partial-lists" id="id12">Moving entries and partial lists</a></p></li>
<li><p><a class="reference internal" href="#rotating-entries" id="id13">Rotating entries</a></p></li>
<li><p><a class="reference internal" href="#swapping-entries" id="id14">Swapping entries</a></p></li>
<li><p><a class="reference internal" href="#splicing-two-lists-together" id="id15">Splicing two lists together</a></p></li>
<li><p><a class="reference internal" href="#concurrency-considerations" id="id16">Concurrency considerations</a></p></li>
<li><p><a class="reference internal" href="#further-reading" id="id17">Further reading</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#full-list-api" id="id18">Full List API</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Linked lists are one of the most basic data structures used in many programs.
The Linux kernel implements several different flavours of linked lists. The
purpose of this document is not to explain linked lists in general, but to show
new kernel developers how to use the Linux kernel implementations of linked
lists.</p>
<p>Please note that while linked lists certainly are ubiquitous, they are rarely
the best data structure to use in cases where a simple array doesn't already
suffice. In particular, due to their poor data locality, linked lists are a bad
choice in situations where performance may be of consideration. Familiarizing
oneself with other in-kernel generic data structures, especially for concurrent
accesses, is highly encouraged.</p>
</section>
<section id="linux-implementation-of-doubly-linked-lists">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Linux implementation of doubly linked lists</a><a class="headerlink" href="#linux-implementation-of-doubly-linked-lists" title="Link to this heading">¶</a></h2>
<p>Linux's linked list implementations can be used by including the header file
<code class="docutils literal notranslate"><span class="pre">&lt;linux/list.h&gt;</span></code>.</p>
<p>The doubly-linked list will likely be the most familiar to many readers. It's a
list that can efficiently be traversed forwards and backwards.</p>
<p>The Linux kernel's doubly-linked list is circular in nature. This means that to
get from the head node to the tail, we can just travel one edge backwards.
Similarly, to get from the tail node to the head, we can simply travel forwards
&quot;beyond&quot; the tail and arrive back at the head.</p>
<section id="declaring-a-node">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Declaring a node</a><a class="headerlink" href="#declaring-a-node" title="Link to this heading">¶</a></h3>
<p>A node in a doubly-linked list is declared by adding a <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code>
member to the data structure you wish to be contained in the list:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">shoe_size</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">  </span><span class="cm">/* the aforementioned member */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This may be an unfamiliar approach to some, as the classical explanation of a
linked list is a list node data structure with pointers to the previous and next
list node, as well the payload data. Linux chooses this approach because it
allows for generic list modification code regardless of what data structure is
contained within the list. Since the <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> member is not a pointer
but part of the data structure proper, the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">container_of()</span></code> pattern can be used by
the list implementation to access the payload data regardless of its type, while
staying oblivious to what said type actually is.</p>
</section>
<section id="declaring-and-initializing-a-list">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Declaring and initializing a list</a><a class="headerlink" href="#declaring-and-initializing-a-list" title="Link to this heading">¶</a></h3>
<p>A doubly-linked list can then be declared as just another <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code>,
and initialized with the <a class="reference internal" href="#c.LIST_HEAD_INIT" title="LIST_HEAD_INIT"><code class="xref c c-func docutils literal notranslate"><span class="pre">LIST_HEAD_INIT()</span></code></a> macro during initial assignment, or
with the <a class="reference internal" href="#c.INIT_LIST_HEAD" title="INIT_LIST_HEAD"><code class="xref c c-func docutils literal notranslate"><span class="pre">INIT_LIST_HEAD()</span></code></a> function later:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tyre_pressure</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">clowns</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Looks like a node! */</span>
<span class="p">};</span>

<span class="cm">/* ... Somewhere later in our driver ... */</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">circus_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="n">other_car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="p">.</span><span class="n">tyre_pressure</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">},</span>
<span class="w">              </span><span class="p">.</span><span class="n">clowns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">other_car</span><span class="p">.</span><span class="n">clowns</span><span class="p">)</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">.</span><span class="n">clowns</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A further point of confusion to some may be that the list itself doesn't really
have its own type. The concept of the entire linked list and a
<code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> member that points to other entries in the list are one and
the same.</p>
</section>
<section id="adding-nodes-to-the-list">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Adding nodes to the list</a><a class="headerlink" href="#adding-nodes-to-the-list" title="Link to this heading">¶</a></h3>
<p>Adding a node to the linked list is done through the <a class="reference internal" href="#c.list_add" title="list_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add()</span></code></a> macro.</p>
<p>We'll return to our clown car example to illustrate how nodes get added to the
list:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">circus_fill_car</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">grock</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">dimitri</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* State 1 */</span>

<span class="w">        </span><span class="n">grock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">grock</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">grock</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="n">grock</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Grock&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">grock</span><span class="o">-&gt;</span><span class="n">shoe_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Note that we&#39;re adding the &quot;node&quot; member */</span>
<span class="w">        </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grock</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 2 */</span>

<span class="w">        </span><span class="n">dimitri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dimitri</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">dimitri</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Dimitri&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">shoe_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span>

<span class="w">        </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 3 */</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In State 1, our list of clowns is still empty:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .------.
     v      |
.--------.  |
| clowns |--&#39;
&#39;--------&#39;
</pre></div>
</div>
<p>This diagram shows the singular &quot;clowns&quot; node pointing at itself. In this
diagram, and all following diagrams, only the forward edges are shown, to aid in
clarity.</p>
<p>In State 2, we've added Grock after the list head:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .--------------------.
     v                    |
.--------.     .-------.  |
| clowns |----&gt;| Grock |--&#39;
&#39;--------&#39;     &#39;-------&#39;
</pre></div>
</div>
<p>This diagram shows the &quot;clowns&quot; node pointing at a new node labeled &quot;Grock&quot;.
The Grock node is pointing back at the &quot;clowns&quot; node.</p>
<p>In State 3, we've added Dimitri after the list head, resulting in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .------------------------------------.
     v                                    |
.--------.     .---------.     .-------.  |
| clowns |----&gt;| Dimitri |----&gt;| Grock |--&#39;
&#39;--------&#39;     &#39;---------&#39;     &#39;-------&#39;
</pre></div>
</div>
<p>This diagram shows the &quot;clowns&quot; node pointing at a new node labeled &quot;Dimitri&quot;,
which then points at the node labeled &quot;Grock&quot;. The &quot;Grock&quot; node still points
back at the &quot;clowns&quot; node.</p>
<p>If we wanted to have Dimitri inserted at the end of the list instead, we'd use
<a class="reference internal" href="#c.list_add_tail" title="list_add_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add_tail()</span></code></a>. Our code would then look like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">circus_fill_car</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* ... */</span>

<span class="w">        </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 3b */</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This results in the following list:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .------------------------------------.
     v                                    |
.--------.     .-------.     .---------.  |
| clowns |----&gt;| Grock |----&gt;| Dimitri |--&#39;
&#39;--------&#39;     &#39;-------&#39;     &#39;---------&#39;
</pre></div>
</div>
<p>This diagram shows the &quot;clowns&quot; node pointing at the node labeled &quot;Grock&quot;,
which points at the new node labeled &quot;Dimitri&quot;. The node labeled &quot;Dimitri&quot;
points back at the &quot;clowns&quot; node.</p>
</section>
<section id="traversing-the-list">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Traversing the list</a><a class="headerlink" href="#traversing-the-list" title="Link to this heading">¶</a></h3>
<p>To iterate the list, we can loop through all nodes within the list with
<a class="reference internal" href="#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each()</span></code></a>.</p>
<p>In our clown example, this results in the following somewhat awkward code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">circus_get_max_shoe_size</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">cur</span><span class="p">;</span>

<span class="w">        </span><span class="n">list_for_each</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">.</span><span class="n">clowns</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_entry</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">shoe_size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">)</span>
<span class="w">                        </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">shoe_size</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#c.list_entry" title="list_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_entry()</span></code></a> macro internally uses the aforementioned <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">container_of()</span></code> to
retrieve the data structure instance that <code class="docutils literal notranslate"><span class="pre">node</span></code> is a member of.</p>
<p>Note how the additional <a class="reference internal" href="#c.list_entry" title="list_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_entry()</span></code></a> call is a little awkward here. It's only
there because we're iterating through the <code class="docutils literal notranslate"><span class="pre">node</span></code> members, but we really want
to iterate through the payload, i.e. the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">clown</span></code> that contains each
node's <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code>. For this reason, there is a second macro:
<a class="reference internal" href="#c.list_for_each_entry" title="list_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry()</span></code></a></p>
<p>Using it would change our code to something like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">circus_get_max_shoe_size</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">;</span>

<span class="w">        </span><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">.</span><span class="n">clowns</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">shoe_size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">)</span>
<span class="w">                        </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">shoe_size</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This eliminates the need for the <a class="reference internal" href="#c.list_entry" title="list_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_entry()</span></code></a> step, and our loop cursor is now
of the type of our payload. The macro is given the member name that corresponds
to the list's <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> within the clown data structure so that it can
still walk the list.</p>
</section>
<section id="removing-nodes-from-the-list">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Removing nodes from the list</a><a class="headerlink" href="#removing-nodes-from-the-list" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="#c.list_del" title="list_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del()</span></code></a> function can be used to remove entries from the list. It not only
removes the given entry from the list, but poisons the entry's <code class="docutils literal notranslate"><span class="pre">prev</span></code> and
<code class="docutils literal notranslate"><span class="pre">next</span></code> pointers, so that unintended use of the entry after removal does not
go unnoticed.</p>
<p>We can extend our previous example to remove one of the entries:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">circus_fill_car</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* ... */</span>

<span class="w">        </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 3 */</span>

<span class="w">        </span><span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 4 */</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The result of this would be this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .--------------------.
     v                    |
.--------.     .-------.  |      .---------.
| clowns |----&gt;| Grock |--&#39;      | Dimitri |
&#39;--------&#39;     &#39;-------&#39;         &#39;---------&#39;
</pre></div>
</div>
<p>This diagram shows the &quot;clowns&quot; node pointing at the node labeled &quot;Grock&quot;,
which points back at the &quot;clowns&quot; node. Off to the side is a lone node labeled
&quot;Dimitri&quot;, which has no arrows pointing anywhere.</p>
<p>Note how the Dimitri node does not point to itself; its pointers are
intentionally set to a &quot;poison&quot; value that the list code refuses to traverse.</p>
<p>If we wanted to reinitialize the removed node instead to make it point at itself
again like an empty list head, we can use <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_init()</span></code></a> instead:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">circus_fill_car</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* ... */</span>

<span class="w">        </span><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 3 */</span>

<span class="w">        </span><span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 4b */</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This results in the deleted node pointing to itself again:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .--------------------.           .-------.
     v                    |           v       |
.--------.     .-------.  |      .---------.  |
| clowns |----&gt;| Grock |--&#39;      | Dimitri |--&#39;
&#39;--------&#39;     &#39;-------&#39;         &#39;---------&#39;
</pre></div>
</div>
<p>This diagram shows the &quot;clowns&quot; node pointing at the node labeled &quot;Grock&quot;,
which points back at the &quot;clowns&quot; node. Off to the side is a lone node labeled
&quot;Dimitri&quot;, which points to itself.</p>
</section>
<section id="traversing-whilst-removing-nodes">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Traversing whilst removing nodes</a><a class="headerlink" href="#traversing-whilst-removing-nodes" title="Link to this heading">¶</a></h3>
<p>Deleting entries while we're traversing the list will cause problems if we use
<a class="reference internal" href="#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each()</span></code></a> and <a class="reference internal" href="#c.list_for_each_entry" title="list_for_each_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry()</span></code></a>, as deleting the current entry would
modify the <code class="docutils literal notranslate"><span class="pre">next</span></code> pointer of it, which means the traversal can't properly
advance to the next list entry.</p>
<p>There is a solution to this however: <a class="reference internal" href="#c.list_for_each_safe" title="list_for_each_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_safe()</span></code></a> and
<a class="reference internal" href="#c.list_for_each_entry_safe" title="list_for_each_entry_safe"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_safe()</span></code></a>. These take an additional parameter of a pointer to
a <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage for the next entry during
iteration, solving the issue.</p>
<p>An example of how to use it:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">circus_eject_insufficient_clowns</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">n</span><span class="p">;</span><span class="w">      </span><span class="cm">/* temporary storage for safe iteration */</span>

<span class="w">        </span><span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">.</span><span class="n">clowns</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">shoe_size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">500</span><span class="p">)</span>
<span class="w">                      </span><span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Proper memory management (i.e. freeing the deleted node while making sure
nothing still references it) in this case is left as an exercise to the reader.</p>
</section>
<section id="cutting-a-list">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Cutting a list</a><a class="headerlink" href="#cutting-a-list" title="Link to this heading">¶</a></h3>
<p>There are two helper functions to cut lists with. Both take elements from the
list <code class="docutils literal notranslate"><span class="pre">head</span></code>, and replace the contents of the list <code class="docutils literal notranslate"><span class="pre">list</span></code>.</p>
<p>The first such function is <a class="reference internal" href="#c.list_cut_position" title="list_cut_position"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_cut_position()</span></code></a>. It removes all list entries from
<code class="docutils literal notranslate"><span class="pre">head</span></code> up to and including <code class="docutils literal notranslate"><span class="pre">entry</span></code>, placing them in <code class="docutils literal notranslate"><span class="pre">list</span></code> instead.</p>
<p>In this example, it's assumed we start with the following list:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .----------------------------------------------------------------.
     v                                                                |
.--------.     .-------.     .---------.     .-----.     .---------.  |
| clowns |----&gt;| Grock |----&gt;| Dimitri |----&gt;| Pic |----&gt;| Alfredo |--&#39;
&#39;--------&#39;     &#39;-------&#39;     &#39;---------&#39;     &#39;-----&#39;     &#39;---------&#39;
</pre></div>
</div>
<p>With the following code, every clown up to and including &quot;Pic&quot; is moved from
the &quot;clowns&quot; list head to a separate <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> initialized at local
stack variable <code class="docutils literal notranslate"><span class="pre">retirement</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">circus_retire_clowns</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">retirement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">retirement</span><span class="p">);</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">grock</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">dimitri</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pic</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">alfredo</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* ... clown initialization, list adding ... */</span>

<span class="w">        </span><span class="n">list_cut_position</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retirement</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pic</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 1 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The resulting <code class="docutils literal notranslate"><span class="pre">car-&gt;clowns</span></code> list would be this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .----------------------.
     v                      |
.--------.     .---------.  |
| clowns |----&gt;| Alfredo |--&#39;
&#39;--------&#39;     &#39;---------&#39;
</pre></div>
</div>
<p>Meanwhile, the <code class="docutils literal notranslate"><span class="pre">retirement</span></code> list is transformed to the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>       .--------------------------------------------------.
       v                                                  |
.------------.     .-------.     .---------.     .-----.  |
| retirement |----&gt;| Grock |----&gt;| Dimitri |----&gt;| Pic |--&#39;
&#39;------------&#39;     &#39;-------&#39;     &#39;---------&#39;     &#39;-----&#39;
</pre></div>
</div>
<p>The second function, <a class="reference internal" href="#c.list_cut_before" title="list_cut_before"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_cut_before()</span></code></a>, is much the same, except it cuts before
the <code class="docutils literal notranslate"><span class="pre">entry</span></code> node, i.e. it removes all list entries from <code class="docutils literal notranslate"><span class="pre">head</span></code> up to but
excluding <code class="docutils literal notranslate"><span class="pre">entry</span></code>, placing them in <code class="docutils literal notranslate"><span class="pre">list</span></code> instead. This example assumes the
same initial starting list as the previous example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">circus_retire_clowns</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">retirement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">retirement</span><span class="p">);</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">grock</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">dimitri</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pic</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">alfredo</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* ... clown initialization, list adding ... */</span>

<span class="w">        </span><span class="n">list_cut_before</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retirement</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pic</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 1b */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The resulting <code class="docutils literal notranslate"><span class="pre">car-&gt;clowns</span></code> list would be this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .----------------------------------.
     v                                  |
.--------.     .-----.     .---------.  |
| clowns |----&gt;| Pic |----&gt;| Alfredo |--&#39;
&#39;--------&#39;     &#39;-----&#39;     &#39;---------&#39;
</pre></div>
</div>
<p>Meanwhile, the <code class="docutils literal notranslate"><span class="pre">retirement</span></code> list is transformed to the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>       .--------------------------------------.
       v                                      |
.------------.     .-------.     .---------.  |
| retirement |----&gt;| Grock |----&gt;| Dimitri |--&#39;
&#39;------------&#39;     &#39;-------&#39;     &#39;---------&#39;
</pre></div>
</div>
<p>It should be noted that both functions will destroy links to any existing nodes
in the destination <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code>.</p>
</section>
<section id="moving-entries-and-partial-lists">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Moving entries and partial lists</a><a class="headerlink" href="#moving-entries-and-partial-lists" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="#c.list_move" title="list_move"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_move()</span></code></a> and <a class="reference internal" href="#c.list_move_tail" title="list_move_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_move_tail()</span></code></a> functions can be used to move an entry
from one list to another, to either the start or end respectively.</p>
<p>In the following example, we'll assume we start with two lists (&quot;clowns&quot; and
&quot;sidewalk&quot; in the following initial state &quot;State 0&quot;:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .----------------------------------------------------------------.
     v                                                                |
.--------.     .-------.     .---------.     .-----.     .---------.  |
| clowns |----&gt;| Grock |----&gt;| Dimitri |----&gt;| Pic |----&gt;| Alfredo |--&#39;
&#39;--------&#39;     &#39;-------&#39;     &#39;---------&#39;     &#39;-----&#39;     &#39;---------&#39;

      .-------------------.
      v                   |
.----------.     .-----.  |
| sidewalk |----&gt;| Pio |--&#39;
&#39;----------&#39;     &#39;-----&#39;
</pre></div>
</div>
<p>We apply the following example code to the two lists:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">circus_clowns_exit_car</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">sidewalk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">sidewalk</span><span class="p">);</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">grock</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">dimitri</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pic</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">alfredo</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pio</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* ... clown initialization, list adding ... */</span>

<span class="w">        </span><span class="cm">/* State 0 */</span>

<span class="w">        </span><span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sidewalk</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 1 */</span>

<span class="w">        </span><span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sidewalk</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 2 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In State 1, we arrive at the following situation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    .-----------------------------------------------------.
    |                                                     |
    v                                                     |
.--------.     .-------.     .---------.     .---------.  |
| clowns |----&gt;| Grock |----&gt;| Dimitri |----&gt;| Alfredo |--&#39;
&#39;--------&#39;     &#39;-------&#39;     &#39;---------&#39;     &#39;---------&#39;

      .-------------------------------.
      v                               |
.----------.     .-----.     .-----.  |
| sidewalk |----&gt;| Pic |----&gt;| Pio |--&#39;
&#39;----------&#39;     &#39;-----&#39;     &#39;-----&#39;
</pre></div>
</div>
<p>In State 2, after we've moved Dimitri to the tail of sidewalk, the situation
changes as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    .-------------------------------------.
    |                                     |
    v                                     |
.--------.     .-------.     .---------.  |
| clowns |----&gt;| Grock |----&gt;| Alfredo |--&#39;
&#39;--------&#39;     &#39;-------&#39;     &#39;---------&#39;

      .-----------------------------------------------.
      v                                               |
.----------.     .-----.     .-----.     .---------.  |
| sidewalk |----&gt;| Pic |----&gt;| Pio |----&gt;| Dimitri |--&#39;
&#39;----------&#39;     &#39;-----&#39;     &#39;-----&#39;     &#39;---------&#39;
</pre></div>
</div>
<p>As long as the source and destination list head are part of the same list, we
can also efficiently bulk move a segment of the list to the tail end of the
list. We continue the previous example by adding a <a class="reference internal" href="#c.list_bulk_move_tail" title="list_bulk_move_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_bulk_move_tail()</span></code></a> after
State 2, moving Pic and Pio to the tail end of the sidewalk list.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">circus_clowns_exit_car</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">sidewalk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">sidewalk</span><span class="p">);</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">grock</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">dimitri</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pic</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">alfredo</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pio</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* ... clown initialization, list adding ... */</span>

<span class="w">        </span><span class="cm">/* State 0 */</span>

<span class="w">        </span><span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sidewalk</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 1 */</span>

<span class="w">        </span><span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sidewalk</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 2 */</span>

<span class="w">        </span><span class="n">list_bulk_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sidewalk</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pic</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pio</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 3 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the sake of brevity, only the altered &quot;sidewalk&quot; list at State 3 is depicted
in the following diagram:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      .-----------------------------------------------.
      v                                               |
.----------.     .---------.     .-----.     .-----.  |
| sidewalk |----&gt;| Dimitri |----&gt;| Pic |----&gt;| Pio |--&#39;
&#39;----------&#39;     &#39;---------&#39;     &#39;-----&#39;     &#39;-----&#39;
</pre></div>
</div>
<p>Do note that <a class="reference internal" href="#c.list_bulk_move_tail" title="list_bulk_move_tail"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_bulk_move_tail()</span></code></a> does not do any checking as to whether all
three supplied <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span></code> parameters really do belong to the same
list. If you use it outside the constraints the documentation gives, then the
result is a matter between you and the implementation.</p>
</section>
<section id="rotating-entries">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Rotating entries</a><a class="headerlink" href="#rotating-entries" title="Link to this heading">¶</a></h3>
<p>A common write operation on lists, especially when using them as queues, is
to rotate it. A list rotation means entries at the front are sent to the back.</p>
<p>For rotation, Linux provides us with two functions: <a class="reference internal" href="#c.list_rotate_left" title="list_rotate_left"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_rotate_left()</span></code></a> and
<a class="reference internal" href="#c.list_rotate_to_front" title="list_rotate_to_front"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_rotate_to_front()</span></code></a>. The former can be pictured like a bicycle chain, taking
the entry after the supplied <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span></code> and moving it to the tail,
which in essence means the entire list, due to its circular nature, rotates by
one position.</p>
<p>The latter, <a class="reference internal" href="#c.list_rotate_to_front" title="list_rotate_to_front"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_rotate_to_front()</span></code></a>, takes the same concept one step further:
instead of advancing the list by one entry, it advances it <em>until</em> the specified
entry is the new front.</p>
<p>In the following example, our starting state, State 0, is the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .-----------------------------------------------------------------.
     v                                                                 |
.--------.   .-------.   .---------.   .-----.   .---------.   .-----. |
| clowns |--&gt;| Grock |--&gt;| Dimitri |--&gt;| Pic |--&gt;| Alfredo |--&gt;| Pio |-&#39;
&#39;--------&#39;   &#39;-------&#39;   &#39;---------&#39;   &#39;-----&#39;   &#39;---------&#39;   &#39;-----&#39;
</pre></div>
</div>
<p>The example code being used to demonstrate list rotations is the following:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">circus_clowns_rotate</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">grock</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">dimitri</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pic</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">alfredo</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pio</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* ... clown initialization, list adding ... */</span>

<span class="w">        </span><span class="cm">/* State 0 */</span>

<span class="w">        </span><span class="n">list_rotate_left</span><span class="p">(</span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 1 */</span>

<span class="w">        </span><span class="n">list_rotate_to_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alfredo</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">clowns</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 2 */</span>

<span class="p">}</span>
</pre></div>
</div>
<p>In State 1, we arrive at the following situation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .-----------------------------------------------------------------.
     v                                                                 |
.--------.   .---------.   .-----.   .---------.   .-----.   .-------. |
| clowns |--&gt;| Dimitri |--&gt;| Pic |--&gt;| Alfredo |--&gt;| Pio |--&gt;| Grock |-&#39;
&#39;--------&#39;   &#39;---------&#39;   &#39;-----&#39;   &#39;---------&#39;   &#39;-----&#39;   &#39;-------&#39;
</pre></div>
</div>
<p>Next, after the <a class="reference internal" href="#c.list_rotate_to_front" title="list_rotate_to_front"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_rotate_to_front()</span></code></a> call, we arrive in the following
State 2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .-----------------------------------------------------------------.
     v                                                                 |
.--------.   .---------.   .-----.   .-------.   .---------.   .-----. |
| clowns |--&gt;| Alfredo |--&gt;| Pio |--&gt;| Grock |--&gt;| Dimitri |--&gt;| Pic |-&#39;
&#39;--------&#39;   &#39;---------&#39;   &#39;-----&#39;   &#39;-------&#39;   &#39;---------&#39;   &#39;-----&#39;
</pre></div>
</div>
<p>As is hopefully evident from the diagrams, the entries in front of &quot;Alfredo&quot;
were cycled to the tail end of the list.</p>
</section>
<section id="swapping-entries">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Swapping entries</a><a class="headerlink" href="#swapping-entries" title="Link to this heading">¶</a></h3>
<p>Another common operation is that two entries need to be swapped with each other.</p>
<p>For this, Linux provides us with <a class="reference internal" href="#c.list_swap" title="list_swap"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_swap()</span></code></a>.</p>
<p>In the following example, we have a list with three entries, and swap two of
them. This is our starting state in &quot;State 0&quot;:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .-----------------------------------------.
     v                                         |
.--------.   .-------.   .---------.   .-----. |
| clowns |--&gt;| Grock |--&gt;| Dimitri |--&gt;| Pic |-&#39;
&#39;--------&#39;   &#39;-------&#39;   &#39;---------&#39;   &#39;-----&#39;
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">circus_clowns_swap</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">circus_priv</span><span class="w"> </span><span class="o">*</span><span class="n">circus</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">grock</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">dimitri</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pic</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown_car</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">circus</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* ... clown initialization, list adding ... */</span>

<span class="w">        </span><span class="cm">/* State 0 */</span>

<span class="w">        </span><span class="n">list_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pic</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 1 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The resulting list at State 1 is the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>     .-----------------------------------------.
     v                                         |
.--------.   .-------.   .-----.   .---------. |
| clowns |--&gt;| Grock |--&gt;| Pic |--&gt;| Dimitri |-&#39;
&#39;--------&#39;   &#39;-------&#39;   &#39;-----&#39;   &#39;---------&#39;
</pre></div>
</div>
<p>As is evident by comparing the diagrams, the &quot;Pic&quot; and &quot;Dimitri&quot; nodes have
traded places.</p>
</section>
<section id="splicing-two-lists-together">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Splicing two lists together</a><a class="headerlink" href="#splicing-two-lists-together" title="Link to this heading">¶</a></h3>
<p>Say we have two lists, in the following example one represented by a list head
we call &quot;knie&quot; and one we call &quot;stey&quot;. In a hypothetical circus acquisition,
the two list of clowns should be spliced together. The following is our
situation in &quot;State 0&quot;:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    .-----------------------------------------.
    |                                         |
    v                                         |
.------.   .-------.   .---------.   .-----.  |
| knie |--&gt;| Grock |--&gt;| Dimitri |--&gt;| Pic |--&#39;
&#39;------&#39;   &#39;-------&#39;   &#39;---------&#39;   &#39;-----&#39;

    .-----------------------------.
    v                             |
.------.   .---------.   .-----.  |
| stey |--&gt;| Alfredo |--&gt;| Pio |--&#39;
&#39;------&#39;   &#39;---------&#39;   &#39;-----&#39;
</pre></div>
</div>
<p>The function to splice these two lists together is <a class="reference internal" href="#c.list_splice" title="list_splice"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_splice()</span></code></a>. Our example
code is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">circus_clowns_splice</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">clown</span><span class="w"> </span><span class="o">*</span><span class="n">grock</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">dimitri</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pic</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">alfredo</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">pio</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">knie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">knie</span><span class="p">);</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">stey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">stey</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* ... Clown allocation and initialization here ... */</span>

<span class="w">        </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grock</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">knie</span><span class="p">);</span>
<span class="w">        </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">knie</span><span class="p">);</span>
<span class="w">        </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pic</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">knie</span><span class="p">);</span>
<span class="w">        </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alfredo</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stey</span><span class="p">);</span>
<span class="w">        </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pio</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stey</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 0 */</span>

<span class="w">        </span><span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stey</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dimitri</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* State 1 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#c.list_splice" title="list_splice"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_splice()</span></code></a> call here adds all the entries in <code class="docutils literal notranslate"><span class="pre">stey</span></code> to the list
<code class="docutils literal notranslate"><span class="pre">dimitri</span></code>'s <code class="docutils literal notranslate"><span class="pre">node</span></code> list_head is in, after the <code class="docutils literal notranslate"><span class="pre">node</span></code> of <code class="docutils literal notranslate"><span class="pre">dimitri</span></code>. A
somewhat surprising diagram of the resulting &quot;State 1&quot; follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    .-----------------------------------------------------------------.
    |                                                                 |
    v                                                                 |
.------.   .-------.   .---------.   .---------.   .-----.   .-----.  |
| knie |--&gt;| Grock |--&gt;| Dimitri |--&gt;| Alfredo |--&gt;| Pio |--&gt;| Pic |--&#39;
&#39;------&#39;   &#39;-------&#39;   &#39;---------&#39;   &#39;---------&#39;   &#39;-----&#39;   &#39;-----&#39;
                                          ^
          .-------------------------------&#39;
          |
.------.  |
| stey |--&#39;
&#39;------&#39;
</pre></div>
</div>
<p>Traversing the <code class="docutils literal notranslate"><span class="pre">stey</span></code> list no longer results in correct behavior. A call of
<a class="reference internal" href="#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each()</span></code></a> on <code class="docutils literal notranslate"><span class="pre">stey</span></code> results in an infinite loop, as it never returns
back to the <code class="docutils literal notranslate"><span class="pre">stey</span></code> list head.</p>
<p>This is because <a class="reference internal" href="#c.list_splice" title="list_splice"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_splice()</span></code></a> did not reinitialize the list_head it took
entries from, leaving its pointer pointing into what is now a different list.</p>
<p>If we want to avoid this situation, <a class="reference internal" href="#c.list_splice_init" title="list_splice_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_splice_init()</span></code></a> can be used. It does the
same thing as <a class="reference internal" href="#c.list_splice" title="list_splice"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_splice()</span></code></a>, except reinitalizes the donor list_head after the
transplant.</p>
</section>
<section id="concurrency-considerations">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Concurrency considerations</a><a class="headerlink" href="#concurrency-considerations" title="Link to this heading">¶</a></h3>
<p>Concurrent access and modification of a list needs to be protected with a lock
in most cases. Alternatively and preferably, one may use the RCU primitives for
lists in read-mostly use-cases, where read accesses to the list are common but
modifications to the list less so. See <a class="reference internal" href="../RCU/listRCU.html"><span class="doc">Using RCU to Protect Read-Mostly Linked Lists</span></a> for more
details.</p>
</section>
<section id="further-reading">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Further reading</a><a class="headerlink" href="#further-reading" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://kernelnewbies.org/FAQ/LinkedLists">How does the kernel implements Linked Lists? - KernelNewbies</a></p></li>
</ul>
</section>
</section>
<section id="full-list-api">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Full List API</a><a class="headerlink" href="#full-list-api" title="Link to this heading">¶</a></h2>
<dl class="c macro">
<dt class="sig sig-object c" id="c.LIST_HEAD_INIT">
<span class="sig-name descname"><span class="n"><span class="pre">LIST_HEAD_INIT</span></span></span><a class="headerlink" href="#c.LIST_HEAD_INIT" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">LIST_HEAD_INIT</span> <span class="pre">(name)</span></code></p>
<blockquote>
<div><p>initialize a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code>'s links to point to itself</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the list_head</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.LIST_HEAD">
<span class="sig-name descname"><span class="n"><span class="pre">LIST_HEAD</span></span></span><a class="headerlink" href="#c.LIST_HEAD" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">LIST_HEAD</span> <span class="pre">(name)</span></code></p>
<blockquote>
<div><p>definition of a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> with initialization values</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the list_head</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.INIT_LIST_HEAD">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">INIT_LIST_HEAD</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.INIT_LIST_HEAD" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a list_head structure</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>list_head structure to be initialized.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the list_head to point to itself.  If it is a list header,
the result is an empty list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_add</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a new entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list head to add it after</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_add_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_add_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a new entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>list head to add it before</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del" title="Link to this definition">¶</a><br /></dt>
<dd><p>deletes entry from list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty()</span></code></a> on entry does not return true after this, the entry is
in an undefined state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_replace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_replace</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace" title="Link to this definition">¶</a><br /></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_replace_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_replace_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>replace old entry by new one and initialize the old one</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*old</span></code></dt><dd><p>the element to be replaced</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*new</span></code></dt><dd><p>the new element to insert</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_swap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_swap</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry1</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_swap" title="Link to this definition">¶</a><br /></dt>
<dd><p>replace entry1 with entry2 and re-add entry1 at entry2's position</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry1</span></code></dt><dd><p>the location to place entry2</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry2</span></code></dt><dd><p>the location to place entry1</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_del_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_del_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>deletes entry from list and reinitialize it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_move">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_move</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move" title="Link to this definition">¶</a><br /></dt>
<dd><p>delete from one list and add as another's head</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head that will precede our entry</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_move_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_move_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move_tail" title="Link to this definition">¶</a><br /></dt>
<dd><p>delete from one list and add as another's tail</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head that will follow our entry</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_bulk_move_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_bulk_move_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">first</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">last</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_bulk_move_tail" title="Link to this definition">¶</a><br /></dt>
<dd><p>move a subsection of a list to its tail</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head that will follow our entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*first</span></code></dt><dd><p>first entry to move</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*last</span></code></dt><dd><p>last entry to move, can be the same as first</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move all entries between <strong>first</strong> and including <strong>last</strong> before <strong>head</strong>.
All three entries must belong to the same linked list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_is_first">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_is_first</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_first" title="Link to this definition">¶</a><br /></dt>
<dd><ul class="simple">
<li><p>tests whether <strong>list</strong> is the first entry in list <strong>head</strong></p></li>
</ul>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_is_last">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_is_last</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_last" title="Link to this definition">¶</a><br /></dt>
<dd><p>tests whether <strong>list</strong> is the last entry in list <strong>head</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_is_head">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_is_head</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_head" title="Link to this definition">¶</a><br /></dt>
<dd><p>tests whether <strong>list</strong> is the list <strong>head</strong></p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the entry to test</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_empty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty" title="Link to this definition">¶</a><br /></dt>
<dd><p>tests whether a list is empty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the list to test.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_del_init_careful">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_del_init_careful</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_init_careful" title="Link to this definition">¶</a><br /></dt>
<dd><p>deletes entry from list and reinitialize it.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>the element to delete from the list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_init()</span></code></a>, except designed to be used
together with <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty_careful()</span></code></a> in a way to guarantee ordering
of other memory operations.</p>
<p>Any memory operations done before a <a class="reference internal" href="#c.list_del_init_careful" title="list_del_init_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_init_careful()</span></code></a> are
guaranteed to be visible after a <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty_careful()</span></code></a> test.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_empty_careful">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_empty_careful</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty_careful" title="Link to this definition">¶</a><br /></dt>
<dd><p>tests whether a list is empty and not being modified</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the list to test</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>tests whether a list is empty _and_ checks that no other CPU might be
in the process of modifying either member (next or prev)</p>
<p><strong>NOTE</strong></p>
<p>using <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_empty_careful()</span></code></a> without synchronization
can only be safe if the only activity that can happen
to the list entry is <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_del_init()</span></code></a>. Eg. it cannot be used
if another CPU could re-<a class="reference internal" href="#c.list_add" title="list_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_add()</span></code></a> it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_rotate_left">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_rotate_left</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_left" title="Link to this definition">¶</a><br /></dt>
<dd><p>rotate the list to the left</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head of the list</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_rotate_to_front">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_rotate_to_front</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_to_front" title="Link to this definition">¶</a><br /></dt>
<dd><p>Rotate list to specific item.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>The desired new front of the list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>The head of the list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rotates list so that <strong>list</strong> becomes the new front of the list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_is_singular">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_is_singular</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_singular" title="Link to this definition">¶</a><br /></dt>
<dd><p>tests whether a list has just one entry.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the list to test.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_cut_position">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_cut_position</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_position" title="Link to this definition">¶</a><br /></dt>
<dd><p>cut a list into two</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>a new list to add all removed entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>a list with entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>an entry within head, could be the head itself
and if so we won't cut the list</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to and
including <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>. You should
pass on <strong>entry</strong> an element you know is on <strong>head</strong>. <strong>list</strong>
should be an empty list or a list you do not care about
losing its data.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_cut_before">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_cut_before</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">entry</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_before" title="Link to this definition">¶</a><br /></dt>
<dd><p>cut a list into two, before given entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>a new list to add all removed entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>a list with entries</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*entry</span></code></dt><dd><p>an entry within head, could be the head itself</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to but
excluding <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>.  You should pass
in <strong>entry</strong> an element you know is on <strong>head</strong>.  <strong>list</strong> should
be an empty list or a list you do not care about losing
its data.
If <strong>entry</strong> == <strong>head</strong>, all entries on <strong>head</strong> are moved to
<strong>list</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice" title="Link to this definition">¶</a><br /></dt>
<dd><p>join two lists, this is designed for stacks</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice_tail">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice_tail</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail" title="Link to this definition">¶</a><br /></dt>
<dd><p>join two lists, each list being a queue</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>join two lists and reinitialise the emptied list.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list at <strong>list</strong> is reinitialised</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_splice_tail_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_splice_tail_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">list</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>join two lists and reinitialise the emptied list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*list</span></code></dt><dd><p>the new list to add.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the place to add it in the first list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_entry</span></span></span><a class="headerlink" href="#c.list_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_entry</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the struct for this entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">this</span></code> is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_first_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_first_entry</span></span></span><a class="headerlink" href="#c.list_first_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_first_entry</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the first element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">this</span></code> is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_last_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_last_entry</span></span></span><a class="headerlink" href="#c.list_last_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_last_entry</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the last element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">this</span></code> is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_first_entry_or_null">
<span class="sig-name descname"><span class="n"><span class="pre">list_first_entry_or_null</span></span></span><a class="headerlink" href="#c.list_first_entry_or_null" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_first_entry_or_null</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the first element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">this</span></code> is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_last_entry_or_null">
<span class="sig-name descname"><span class="n"><span class="pre">list_last_entry_or_null</span></span></span><a class="headerlink" href="#c.list_last_entry_or_null" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_last_entry_or_null</span> <span class="pre">(ptr,</span> <span class="pre">type,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the last element from a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ptr</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>the type of the <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">this</span></code> is embedded in.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_next_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_next_entry</span></span></span><a class="headerlink" href="#c.list_next_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_next_entry</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the next element in list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_next_entry_circular">
<span class="sig-name descname"><span class="n"><span class="pre">list_next_entry_circular</span></span></span><a class="headerlink" href="#c.list_next_entry_circular" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_next_entry_circular</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the next element in list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wraparound if pos is the last element (return the first element).
Note, that list is expected to be not empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_prev_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_prev_entry</span></span></span><a class="headerlink" href="#c.list_prev_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_prev_entry</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the prev element in list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_prev_entry_circular">
<span class="sig-name descname"><span class="n"><span class="pre">list_prev_entry_circular</span></span></span><a class="headerlink" href="#c.list_prev_entry_circular" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_prev_entry_circular</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>get the prev element in list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the list head to take the element from.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wraparound if pos is the first element (return the last element).
Note, that list is expected to be not empty.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each</span></span></span><a class="headerlink" href="#c.list_for_each" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each</span> <span class="pre">(pos,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_continue">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_continue</span></span></span><a class="headerlink" href="#c.list_for_each_continue" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_continue</span> <span class="pre">(pos,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>continue iteration over a list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over a list, continuing after the current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_prev">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_prev</span></span></span><a class="headerlink" href="#c.list_for_each_prev" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_prev</span> <span class="pre">(pos,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over a list backwards</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_safe">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_safe</span></span></span><a class="headerlink" href="#c.list_for_each_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_safe</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over a list safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_prev_safe">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_prev_safe</span></span></span><a class="headerlink" href="#c.list_for_each_prev_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_prev_safe</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head)</span></code></p>
<blockquote>
<div><p>iterate over a list backwards safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.list_count_nodes">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">list_count_nodes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">list_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.list_count_nodes" title="Link to this definition">¶</a><br /></dt>
<dd><p>count nodes in the list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head</span></code></dt><dd><p>the head for your list.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_entry_is_head">
<span class="sig-name descname"><span class="n"><span class="pre">list_entry_is_head</span></span></span><a class="headerlink" href="#c.list_entry_is_head" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_entry_is_head</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>test if the entry points to the head of the list</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to cursor</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry</span></span></span><a class="headerlink" href="#c.list_for_each_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_reverse</span></span></span><a class="headerlink" href="#c.list_for_each_entry_reverse" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_reverse</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate backwards over list of given type.</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_prepare_entry">
<span class="sig-name descname"><span class="n"><span class="pre">list_prepare_entry</span></span></span><a class="headerlink" href="#c.list_prepare_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_prepare_entry</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>prepare a pos entry for use in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_continue()</span></code></a></p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a start point</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head of the list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a pos entry for use as a start point in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal notranslate"><span class="pre">list_for_each_entry_continue()</span></code></a>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_continue">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_continue</span></span></span><a class="headerlink" href="#c.list_for_each_entry_continue" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_continue</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>continue iteration over list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_continue_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_continue_reverse</span></span></span><a class="headerlink" href="#c.list_for_each_entry_continue_reverse" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_continue_reverse</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate backwards from the given point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start to iterate over list of given type backwards, continuing after
the current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_from">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_from</span></span></span><a class="headerlink" href="#c.list_for_each_entry_from" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_from</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type from the current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing from current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_from_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_from_reverse</span></span></span><a class="headerlink" href="#c.list_for_each_entry_from_reverse" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_from_reverse</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate backwards over list of given type from the current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, continuing from current position.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_safe">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_safe</span></span></span><a class="headerlink" href="#c.list_for_each_entry_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_safe</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_safe_continue">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_safe_continue</span></span></span><a class="headerlink" href="#c.list_for_each_entry_safe_continue" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_safe_continue</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>continue list iteration safe against removal</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing after current point,
safe against removal of list entry.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_safe_from">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_safe_from</span></span></span><a class="headerlink" href="#c.list_for_each_entry_safe_from" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_safe_from</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list from current point safe against removal</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type from current point, safe against
removal of list entry.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_for_each_entry_safe_reverse">
<span class="sig-name descname"><span class="n"><span class="pre">list_for_each_entry_safe_reverse</span></span></span><a class="headerlink" href="#c.list_for_each_entry_safe_reverse" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_for_each_entry_safe_reverse</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate backwards over list safe against removal</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>another type * to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, safe against removal
of list entry.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.list_safe_reset_next">
<span class="sig-name descname"><span class="n"><span class="pre">list_safe_reset_next</span></span></span><a class="headerlink" href="#c.list_safe_reset_next" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">list_safe_reset_next</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>reset a stale list_for_each_entry_safe loop</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the loop cursor used in the list_for_each_entry_safe loop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>temporary storage used in list_for_each_entry_safe</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the list_head within the struct.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>list_safe_reset_next is not safe to use in general if the list may be
modified concurrently (eg. the lock is dropped in the loop body). An
exception to this is if the cursor element (pos) is pinned in the list,
and list_safe_reset_next is called after re-taking the lock and before
completing the current iteration of the loop body.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_unhashed">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_unhashed</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_unhashed" title="Link to this definition">¶</a><br /></dt>
<dd><p>Has node been removed from list and reinitialized?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*h</span></code></dt><dd><p>Node to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not that not all removal functions will leave a node in unhashed
state.  For example, <a class="reference internal" href="kernel-api.html#c.hlist_nulls_del_init_rcu" title="hlist_nulls_del_init_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_nulls_del_init_rcu()</span></code></a> does leave the
node in unhashed state, but <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">hlist_nulls_del()</span></code> does not.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_unhashed_lockless">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_unhashed_lockless</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_unhashed_lockless" title="Link to this definition">¶</a><br /></dt>
<dd><p>Version of hlist_unhashed for lockless use</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*h</span></code></dt><dd><p>Node to be checked</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.hlist_unhashed" title="hlist_unhashed"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_unhashed()</span></code></a> must be used in lockless contexts
to avoid potential load-tearing.  The <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">READ_ONCE()</span></code> is paired with the
various <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">WRITE_ONCE()</span></code> in hlist helpers that are defined below.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_empty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_empty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Is the specified hlist_head structure an empty hlist?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*h</span></code></dt><dd><p>Structure to check.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_del</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del" title="Link to this definition">¶</a><br /></dt>
<dd><p>Delete the specified hlist_node from its list</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>Node to delete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function leaves the node in hashed state.  Use
<a class="reference internal" href="#c.hlist_del_init" title="hlist_del_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del_init()</span></code></a> or similar instead to unhash <strong>n</strong>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_del_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_del_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Delete the specified hlist_node from its list and initialize</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>Node to delete.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function leaves the node in unhashed state.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_head">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_head</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_head" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a new entry at the beginning of the hlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*h</span></code></dt><dd><p>hlist head to add it after</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_before">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_before</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">next</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_before" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a new entry before the one specified</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*next</span></code></dt><dd><p>hlist node to add it before, which must be non-NULL</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_behind">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_behind</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prev</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_behind" title="Link to this definition">¶</a><br /></dt>
<dd><p>add a new entry after the one specified</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>new entry to be added</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*prev</span></code></dt><dd><p>hlist node to add it after, which must be non-NULL</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_add_fake">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_add_fake</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_fake" title="Link to this definition">¶</a><br /></dt>
<dd><p>create a fake hlist consisting of a single headless node</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>Node to make a fake list out of</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This makes <strong>n</strong> appear to be its own predecessor on a headless hlist.
The point of this is to allow things like <a class="reference internal" href="#c.hlist_del" title="hlist_del"><code class="xref c c-func docutils literal notranslate"><span class="pre">hlist_del()</span></code></a> to work correctly
in cases where there is no list.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_fake">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_fake</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_fake" title="Link to this definition">¶</a><br /></dt>
<dd><p>Is this node a fake hlist?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*h</span></code></dt><dd><p>Node to check for being a self-referential fake hlist.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_is_singular_node">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_is_singular_node</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_is_singular_node" title="Link to this definition">¶</a><br /></dt>
<dd><p>is node the only element of the specified hlist?</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*n</span></code></dt><dd><p>Node to check for singularity.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*h</span></code></dt><dd><p>Header for potentially singular list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the node is the only node of the head without
accessing head, thus avoiding unnecessary cache misses.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_move_list">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_move_list</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">old</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_move_list" title="Link to this definition">¶</a><br /></dt>
<dd><p>Move an hlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*old</span></code></dt><dd><p>hlist_head for old list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*new</span></code></dt><dd><p>hlist_head for new list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Move a list from one list head to another. Fixup the pprev
reference of the first entry if it exists.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_splice_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_splice_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_node</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">last</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_splice_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>move all entries from one list to another</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*from</span></code></dt><dd><p>hlist_head from which entries will be moved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*last</span></code></dt><dd><p>last entry on the <strong>from</strong> list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*to</span></code></dt><dd><p>hlist_head to which entries will be moved</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>to</strong> can be empty, <strong>from</strong> must contain at least <strong>last</strong>.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry</span> <span class="pre">(pos,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_continue">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_continue</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_continue" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_continue</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over a hlist continuing after current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_from">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_from</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_from" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_from</span> <span class="pre">(pos,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over a hlist continuing from current point</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.hlist_for_each_entry_safe">
<span class="sig-name descname"><span class="n"><span class="pre">hlist_for_each_entry_safe</span></span></span><a class="headerlink" href="#c.hlist_for_each_entry_safe" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">hlist_for_each_entry_safe</span> <span class="pre">(pos,</span> <span class="pre">n,</span> <span class="pre">head,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>iterate over list of given type safe against removal of list entry</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>the type * to use as a loop cursor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>a <code class="xref c c-type docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as temporary storage</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">head</span></code></dt><dd><p>the head for your list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>the name of the hlist_node within the struct.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.hlist_count_nodes">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">hlist_count_nodes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">hlist_head</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">head</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_count_nodes" title="Link to this definition">¶</a><br /></dt>
<dd><p>count nodes in the hlist</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*head</span></code></dt><dd><p>the head for your hlist.</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/core-api/list.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>