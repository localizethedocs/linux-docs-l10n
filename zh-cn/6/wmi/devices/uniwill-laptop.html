<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>6. Uniwill Notebook driver (uniwill-laptop) &#8212; The Linux Kernel unknown version 文档</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../_static/documentation_options.js?v=c459948e"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/wmi/devices/uniwill-laptop.html" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="7. WMI embedded Binary MOF driver" href="wmi-bmof.html" />
    <link rel="prev" title="5. MSI WMI Platform Features driver (msi-wmi-platform)" href="msi-wmi-platform.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../accounting/index.html">Accounting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cpu-freq/index.html">CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../edac/index.html">EDAC Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../fpga/index.html">FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../pcmcia/index.html">PCMCIA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../watchdog/index.html">Watchdog Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../virt/index.html">Virtualization Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../hwmon/index.html">Hardware Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../accel/index.html">Compute Accelerators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../crypto/index.html">Crypto API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usb/index.html">USB support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../PCI/index.html">PCI Bus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../peci/index.html">PECI Subsystem</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">WMI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tee/index.html">TEE Subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/wmi/devices/uniwill-laptop.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="uniwill-notebook-driver-uniwill-laptop">
<h1><span class="section-number">6. </span>Uniwill Notebook driver (uniwill-laptop)<a class="headerlink" href="#uniwill-notebook-driver-uniwill-laptop" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2><span class="section-number">6.1. </span>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Many notebooks manufactured by Uniwill (either directly or as ODM) provide a EC interface
for controlling various platform settings like sensors and fan control. This interface is
used by the <code class="docutils literal notranslate"><span class="pre">uniwill-laptop</span></code> driver to map those features onto standard kernel interfaces.</p>
</section>
<section id="ec-wmi-interface-description">
<h2><span class="section-number">6.2. </span>EC WMI interface description<a class="headerlink" href="#ec-wmi-interface-description" title="Link to this heading">¶</a></h2>
<p>The EC WMI interface description can be decoded from the embedded binary MOF (bmof)
data using the <a class="reference external" href="https://github.com/pali/bmfdec">bmfdec</a> utility:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[WMI, Dynamic, Provider(&quot;WmiProv&quot;), Locale(&quot;MS\\0x409&quot;),
 Description(&quot;Class used to operate methods on a ULong&quot;),
 guid(&quot;{ABBC0F6F-8EA1-11d1-00A0-C90629100000}&quot;)]
class AcpiTest_MULong {
  [key, read] string InstanceName;
  [read] boolean Active;

  [WmiMethodId(1), Implemented, read, write, Description(&quot;Return the contents of a ULong&quot;)]
  void GetULong([out, Description(&quot;Ulong Data&quot;)] uint32 Data);

  [WmiMethodId(2), Implemented, read, write, Description(&quot;Set the contents of a ULong&quot;)]
  void SetULong([in, Description(&quot;Ulong Data&quot;)] uint32 Data);

  [WmiMethodId(3), Implemented, read, write,
   Description(&quot;Generate an event containing ULong data&quot;)]
  void FireULong([in, Description(&quot;WMI requires a parameter&quot;)] uint32 Hack);

  [WmiMethodId(4), Implemented, read, write, Description(&quot;Get and Set the contents of a ULong&quot;)]
  void GetSetULong([in, Description(&quot;Ulong Data&quot;)] uint64 Data,
                   [out, Description(&quot;Ulong Data&quot;)] uint32 Return);

  [WmiMethodId(5), Implemented, read, write,
   Description(&quot;Get and Set the contents of a ULong for Dollby button&quot;)]
  void GetButton([in, Description(&quot;Ulong Data&quot;)] uint64 Data,
                 [out, Description(&quot;Ulong Data&quot;)] uint32 Return);
};
</pre></div>
</div>
<p>Most of the WMI-related code was copied from the Windows driver samples, which unfortunately means
that the WMI-GUID is not unique. This makes the WMI-GUID unusable for autoloading.</p>
<section id="wmi-method-getulong">
<h3><span class="section-number">6.2.1. </span>WMI method GetULong()<a class="headerlink" href="#wmi-method-getulong" title="Link to this heading">¶</a></h3>
<p>This WMI method was copied from the Windows driver samples and has no function.</p>
</section>
<section id="wmi-method-setulong">
<h3><span class="section-number">6.2.2. </span>WMI method SetULong()<a class="headerlink" href="#wmi-method-setulong" title="Link to this heading">¶</a></h3>
<p>This WMI method was copied from the Windows driver samples and has no function.</p>
</section>
<section id="wmi-method-fireulong">
<h3><span class="section-number">6.2.3. </span>WMI method FireULong()<a class="headerlink" href="#wmi-method-fireulong" title="Link to this heading">¶</a></h3>
<p>This WMI method allows to inject a WMI event with a 32-bit payload. Its primary purpose seems
to be debugging.</p>
</section>
<section id="wmi-method-getsetulong">
<h3><span class="section-number">6.2.4. </span>WMI method GetSetULong()<a class="headerlink" href="#wmi-method-getsetulong" title="Link to this heading">¶</a></h3>
<p>This WMI method is used to communicate with the EC. The <code class="docutils literal notranslate"><span class="pre">Data</span></code> argument holds the following
information (starting with the least significant byte):</p>
<ol class="arabic simple">
<li><p>16-bit address</p></li>
<li><p>16-bit data (set to <code class="docutils literal notranslate"><span class="pre">0x0000</span></code> when reading)</p></li>
<li><p>16-bit operation (<code class="docutils literal notranslate"><span class="pre">0x0100</span></code> for reading and <code class="docutils literal notranslate"><span class="pre">0x0000</span></code> for writing)</p></li>
<li><p>16-bit reserved (set to <code class="docutils literal notranslate"><span class="pre">0x0000</span></code>)</p></li>
</ol>
<p>The first 8 bits of the <code class="docutils literal notranslate"><span class="pre">Return</span></code> value contain the data returned by the EC when reading.
The special value <code class="docutils literal notranslate"><span class="pre">0xFEFEFEFE</span></code> is used to indicate a communication failure with the EC.</p>
</section>
<section id="wmi-method-getbutton">
<h3><span class="section-number">6.2.5. </span>WMI method GetButton()<a class="headerlink" href="#wmi-method-getbutton" title="Link to this heading">¶</a></h3>
<p>This WMI method is not implemented on all machines and has an unknown purpose.</p>
</section>
</section>
<section id="reverse-engineering-the-ec-wmi-interface">
<h2><span class="section-number">6.3. </span>Reverse-Engineering the EC WMI interface<a class="headerlink" href="#reverse-engineering-the-ec-wmi-interface" title="Link to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Randomly poking the EC can potentially cause damage to the machine and other unwanted
side effects, please be careful.</p>
</div>
<p>The EC behind the <code class="docutils literal notranslate"><span class="pre">GetSetULong</span></code> method is used by the OEM software supplied by the manufacturer.
Reverse-engineering of this software is difficult since it uses an obfuscator, however some parts
are not obfuscated. In this case <a class="reference external" href="https://github.com/dnSpy/dnSpy">dnSpy</a> could also be helpful.</p>
<p>The EC can be accessed under Windows using powershell (requires admin privileges):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt; $obj = Get-CimInstance -Namespace root/wmi -ClassName AcpiTest_MULong | Select-Object -First 1
&gt; Invoke-CimMethod -InputObject $obj -MethodName GetSetULong -Arguments @{Data = &lt;input&gt;}
</pre></div>
</div>
</section>
<section id="wmi-event-interface-description">
<h2><span class="section-number">6.4. </span>WMI event interface description<a class="headerlink" href="#wmi-event-interface-description" title="Link to this heading">¶</a></h2>
<p>The WMI interface description can also be decoded from the embedded binary MOF (bmof)
data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[WMI, Dynamic, Provider(&quot;WmiProv&quot;), Locale(&quot;MS\\0x409&quot;),
 Description(&quot;Class containing event generated ULong data&quot;),
 guid(&quot;{ABBC0F72-8EA1-11d1-00A0-C90629100000}&quot;)]
class AcpiTest_EventULong : WmiEvent {
  [key, read] string InstanceName;
  [read] boolean Active;

  [WmiDataId(1), read, write, Description(&quot;ULong Data&quot;)] uint32 ULong;
};
</pre></div>
</div>
<p>Most of the WMI-related code was again copied from the Windows driver samples, causing this WMI
interface to suffer from the same restrictions as the EC WMI interface described above.</p>
<section id="wmi-event-data">
<h3><span class="section-number">6.4.1. </span>WMI event data<a class="headerlink" href="#wmi-event-data" title="Link to this heading">¶</a></h3>
<p>The WMI event data contains a single 32-bit value which is used to indicate various platform events.</p>
</section>
</section>
<section id="reverse-engineering-the-uniwill-wmi-event-interface">
<h2><span class="section-number">6.5. </span>Reverse-Engineering the Uniwill WMI event interface<a class="headerlink" href="#reverse-engineering-the-uniwill-wmi-event-interface" title="Link to this heading">¶</a></h2>
<p>The driver logs debug messages when receiving a WMI event. Thus enabling debug messages will be
useful for finding unknown event codes.</p>
</section>
<section id="ec-acpi-interface-description">
<h2><span class="section-number">6.6. </span>EC ACPI interface description<a class="headerlink" href="#ec-acpi-interface-description" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">INOU0000</span></code> ACPI device is a virtual device used to access various hardware registers
available on notebooks manufactured by Uniwill. Reading and writing those registers happens
by calling ACPI control methods. The <code class="docutils literal notranslate"><span class="pre">uniwill-laptop</span></code> driver uses this device to communicate
with the EC because the ACPI control methods are faster than the WMI methods described above.</p>
<p>ACPI control methods used for reading registers take a single ACPI integer containing the address
of the register to read and return a ACPI integer containing the data inside said register. ACPI
control methods used for writing registers however take two ACPI integers, with the additional
ACPI integer containing the data to be written into the register. Such ACPI control methods return
nothing.</p>
<section id="system-memory">
<h3><span class="section-number">6.6.1. </span>System memory<a class="headerlink" href="#system-memory" title="Link to this heading">¶</a></h3>
<p>System memory can be accessed with a granularity of either a single byte (<code class="docutils literal notranslate"><span class="pre">MMRB</span></code> for reading and
<code class="docutils literal notranslate"><span class="pre">MMWB</span></code> for writing) or four bytes (<code class="docutils literal notranslate"><span class="pre">MMRD</span></code> for reading and <code class="docutils literal notranslate"><span class="pre">MMWD</span></code> for writing). Those ACPI
control methods are unused because they provide no benefit when compared to the native memory
access functions provided by the kernel.</p>
</section>
<section id="ec-ram">
<h3><span class="section-number">6.6.2. </span>EC RAM<a class="headerlink" href="#ec-ram" title="Link to this heading">¶</a></h3>
<p>The internal RAM of the EC can be accessed with a granularity of a single byte using the <code class="docutils literal notranslate"><span class="pre">ECRR</span></code>
(read) and <code class="docutils literal notranslate"><span class="pre">ECRW</span></code> (write) ACPI control methods, with the maximum register address being <code class="docutils literal notranslate"><span class="pre">0xFFF</span></code>.
The OEM software waits 6 ms after calling one of those ACPI control methods, likely to avoid
overwhelming the EC when being connected over LPC.</p>
</section>
<section id="pci-config-space">
<h3><span class="section-number">6.6.3. </span>PCI config space<a class="headerlink" href="#pci-config-space" title="Link to this heading">¶</a></h3>
<p>The PCI config space can be accessed with a granularity of four bytes using the <code class="docutils literal notranslate"><span class="pre">PCRD</span></code> (read) and
<code class="docutils literal notranslate"><span class="pre">PCWD</span></code> (write) ACPI control methods. The exact address format is unknown, and poking random PCI
devices might confuse the PCI subsystem. Because of this those ACPI control methods are not used.</p>
</section>
<section id="io-ports">
<h3><span class="section-number">6.6.4. </span>IO ports<a class="headerlink" href="#io-ports" title="Link to this heading">¶</a></h3>
<p>IO ports can be accessed with a granularity of four bytes using the <code class="docutils literal notranslate"><span class="pre">IORD</span></code> (read) and <code class="docutils literal notranslate"><span class="pre">IOWD</span></code>
(write) ACPI control methods. Those ACPI control methods are unused because they provide no benefit
when compared to the native IO port access functions provided by the kernel.</p>
</section>
<section id="cmos-ram">
<h3><span class="section-number">6.6.5. </span>CMOS RAM<a class="headerlink" href="#cmos-ram" title="Link to this heading">¶</a></h3>
<p>The CMOS RAM can be accessed with a granularity of a single byte using the <code class="docutils literal notranslate"><span class="pre">RCMS</span></code> (read) and
<code class="docutils literal notranslate"><span class="pre">WCMS</span></code> ACPI control methods. Using those ACPI methods might interfere with the native CMOS RAM
access functions provided by the kernel due to the usage of indexed IO, so they are unused.</p>
</section>
<section id="indexed-io">
<h3><span class="section-number">6.6.6. </span>Indexed IO<a class="headerlink" href="#indexed-io" title="Link to this heading">¶</a></h3>
<p>Indexed IO with IO ports with a granularity of a single byte can be performed using the <code class="docutils literal notranslate"><span class="pre">RIOP</span></code>
(read) and <code class="docutils literal notranslate"><span class="pre">WIOP</span></code> (write) ACPI control methods. Those ACPI methods are unused because they
provide no benifit when compared to the native IO port access functions provided by the kernel.</p>
<p>Special thanks go to github user <cite>pobrn</cite> which developed the
<a class="reference external" href="https://github.com/pobrn/qc71_laptop">qc71_laptop</a> driver on which this driver is partly based.
The same is true for Tuxedo Computers, which developed the
<a class="reference external" href="https://gitlab.com/tuxedocomputers/development/packages/tuxedo-drivers">tuxedo-drivers</a> package
which also served as a foundation for this driver.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/wmi/devices/uniwill-laptop.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>