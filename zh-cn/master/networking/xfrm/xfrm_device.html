<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>XFRM device - offloading the IPsec computations &#8212; The Linux Kernel unknown version 文档</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../_static/documentation_options.js?v=c459948e"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/networking/xfrm/xfrm_device.html" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="XFRM proc - /proc/net/xfrm_* files" href="xfrm_proc.html" />
    <link rel="prev" title="XFRM Framework" href="index.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../isdn/index.html">ISDN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../mhi/index.html">MHI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/networking/xfrm/xfrm_device.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="xfrm-device-offloading-the-ipsec-computations">
<span id="xfrm-device"></span><h1>XFRM device - offloading the IPsec computations<a class="headerlink" href="#xfrm-device-offloading-the-ipsec-computations" title="Link to this heading">¶</a></h1>
<p>Shannon Nelson &lt;<a class="reference external" href="mailto:shannon&#46;nelson&#37;&#52;&#48;oracle&#46;com">shannon<span>&#46;</span>nelson<span>&#64;</span>oracle<span>&#46;</span>com</a>&gt;
Leon Romanovsky &lt;<a class="reference external" href="mailto:leonro&#37;&#52;&#48;nvidia&#46;com">leonro<span>&#64;</span>nvidia<span>&#46;</span>com</a>&gt;</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>IPsec is a useful feature for securing network traffic, but the
computational cost is high: a 10Gbps link can easily be brought down
to under 1Gbps, depending on the traffic and link configuration.
Luckily, there are NICs that offer a hardware based IPsec offload which
can radically increase throughput and decrease CPU utilization.  The XFRM
Device interface allows NIC drivers to offer to the stack access to the
hardware offload.</p>
<p>Right now, there are two types of hardware offload that kernel supports:</p>
<blockquote>
<div><ul class="simple">
<li><p>IPsec crypto offload:</p>
<ul>
<li><p>NIC performs encrypt/decrypt</p></li>
<li><p>Kernel does everything else</p></li>
</ul>
</li>
<li><p>IPsec packet offload:</p>
<ul>
<li><p>NIC performs encrypt/decrypt</p></li>
<li><p>NIC does encapsulation</p></li>
<li><p>Kernel and NIC have SA and policy in-sync</p></li>
<li><p>NIC handles the SA and policies states</p></li>
<li><p>The Kernel talks to the keymanager</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<p>Userland access to the offload is typically through a system such as
libreswan or KAME/raccoon, but the iproute2 'ip xfrm' command set can
be handy when experimenting.  An example command might look something
like this for crypto offload:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ip x s add proto esp dst 14.0.0.70 src 14.0.0.52 spi 0x07 mode transport \
   reqid 0x07 replay-window 32 \
   aead &#39;rfc4106(gcm(aes))&#39; 0x44434241343332312423222114131211f4f3f2f1 128 \
   sel src 14.0.0.52/24 dst 14.0.0.70/24 proto tcp \
   offload dev eth4 dir in
</pre></div>
</div>
<p>and for packet offload:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ip x s add proto esp dst 14.0.0.70 src 14.0.0.52 spi 0x07 mode transport \
   reqid 0x07 replay-window 32 \
   aead &#39;rfc4106(gcm(aes))&#39; 0x44434241343332312423222114131211f4f3f2f1 128 \
   sel src 14.0.0.52/24 dst 14.0.0.70/24 proto tcp \
   offload packet dev eth4 dir in

ip x p add src 14.0.0.70 dst 14.0.0.52 offload packet dev eth4 dir in
tmpl src 14.0.0.70 dst 14.0.0.52 proto esp reqid 10000 mode transport
</pre></div>
</div>
<p>Yes, that's ugly, but that's what shell scripts and/or libreswan are for.</p>
</section>
<section id="callbacks-to-implement">
<h2>Callbacks to implement<a class="headerlink" href="#callbacks-to-implement" title="Link to this heading">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* from include/linux/netdevice.h */
struct xfrmdev_ops {
      /* Crypto and Packet offload callbacks */
      int     (*xdo_dev_state_add)(struct net_device *dev,
                                   struct xfrm_state *x,
                                   struct netlink_ext_ack *extack);
      void    (*xdo_dev_state_delete)(struct net_device *dev,
                                      struct xfrm_state *x);
      void    (*xdo_dev_state_free)(struct net_device *dev,
                                    struct xfrm_state *x);
      bool    (*xdo_dev_offload_ok) (struct sk_buff *skb,
                                     struct xfrm_state *x);
      void    (*xdo_dev_state_advance_esn) (struct xfrm_state *x);
      void    (*xdo_dev_state_update_stats) (struct xfrm_state *x);

      /* Solely packet offload callbacks */
      int     (*xdo_dev_policy_add) (struct xfrm_policy *x, struct netlink_ext_ack *extack);
      void    (*xdo_dev_policy_delete) (struct xfrm_policy *x);
      void    (*xdo_dev_policy_free) (struct xfrm_policy *x);
};
</pre></div>
</div>
<p>The NIC driver offering ipsec offload will need to implement callbacks
relevant to supported offload to make the offload available to the network
stack's XFRM subsystem. Additionally, the feature bits NETIF_F_HW_ESP and
NETIF_F_HW_ESP_TX_CSUM will signal the availability of the offload.</p>
</section>
<section id="flow">
<h2>Flow<a class="headerlink" href="#flow" title="Link to this heading">¶</a></h2>
<p>At probe time and before the call to <a class="reference internal" href="../kapi.html#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal notranslate"><span class="pre">register_netdev()</span></code></a>, the driver should
set up local data structures and XFRM callbacks, and set the feature bits.
The XFRM code's listener will finish the setup on NETDEV_REGISTER.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>adapter-&gt;netdev-&gt;xfrmdev_ops = &amp;ixgbe_xfrmdev_ops;
adapter-&gt;netdev-&gt;features |= NETIF_F_HW_ESP;
adapter-&gt;netdev-&gt;hw_enc_features |= NETIF_F_HW_ESP;
</pre></div>
</div>
<p>When new SAs are set up with a request for &quot;offload&quot; feature, the
driver's <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_state_add()</span></code> will be given the new SA to be offloaded
and an indication of whether it is for Rx or Tx.  The driver should</p>
<blockquote>
<div><ul>
<li><p>verify the algorithm is supported for offloads</p></li>
<li><p>store the SA information (key, salt, target-ip, protocol, etc)</p></li>
<li><p>enable the HW offload of the SA</p></li>
<li><p>return status value:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>0</p></td>
<td><p>success</p></td>
</tr>
<tr class="row-even"><td><p>-EOPNETSUPP</p></td>
<td><p>offload not supported, try SW IPsec,
not applicable for packet offload mode</p></td>
</tr>
<tr class="row-odd"><td><p>other</p></td>
<td><p>fail the request</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>The driver can also set an offload_handle in the SA, an opaque void pointer
that can be used to convey context into the fast-path offload requests:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xs-&gt;xso.offload_handle = context;
</pre></div>
</div>
<p>When the network stack is preparing an IPsec packet for an SA that has
been setup for offload, it first calls into <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_offload_ok()</span></code> with
the skb and the intended offload state to ask the driver if the offload
will serviceable.  This can check the packet information to be sure the
offload can be supported (e.g. IPv4 or IPv6, no IPv4 options, etc) and
return true or false to signify its support. In case driver doesn't implement
this callback, the stack provides reasonable defaults.</p>
<p>Crypto offload mode:
When ready to send, the driver needs to inspect the Tx packet for the
offload information, including the opaque context, and set up the packet
send accordingly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xs = xfrm_input_state(skb);
context = xs-&gt;xso.offload_handle;
set up HW for send
</pre></div>
</div>
<p>The stack has already inserted the appropriate IPsec headers in the
packet data, the offload just needs to do the encryption and fix up the
header values.</p>
<p>When a packet is received and the HW has indicated that it offloaded a
decryption, the driver needs to add a reference to the decoded SA into
the packet's skb.  At this point the data should be decrypted but the
IPsec headers are still in the packet data; they are removed later up
the stack in <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xfrm_input()</span></code>.</p>
<ol class="arabic">
<li><p>Find and hold the SA that was used to the Rx skb:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* get spi, protocol, and destination IP from packet headers */
xs = find xs from (spi, protocol, dest_IP)
xfrm_state_hold(xs);
</pre></div>
</div>
</li>
<li><p>Store the state information into the skb:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sp = secpath_set(skb);
if (!sp) return;
sp-&gt;xvec[sp-&gt;len++] = xs;
sp-&gt;olen++;
</pre></div>
</div>
</li>
<li><p>Indicate the success and/or error status of the offload:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xo = xfrm_offload(skb);
xo-&gt;flags = CRYPTO_DONE;
xo-&gt;status = crypto_status;
</pre></div>
</div>
</li>
<li><p>Hand the packet to <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">napi_gro_receive()</span></code> as usual.</p></li>
</ol>
<p>In ESN mode, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_state_advance_esn()</span></code> is called from
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xfrm_replay_advance_esn()</span></code> for RX, and xfrm_replay_overflow_offload_esn for TX.
Driver will check packet seq number and update HW ESN state machine if needed.</p>
<p>Packet offload mode:
HW adds and deletes XFRM headers. So in RX path, XFRM stack is bypassed if HW
reported success. In TX path, the packet lefts kernel without extra header
and not encrypted, the HW is responsible to perform it.</p>
<p>When the SA is removed by the user, the driver's <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_state_delete()</span></code>
and <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_policy_delete()</span></code> are asked to disable the offload.  Later,
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_state_free()</span></code> and <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_policy_free()</span></code> are called from a garbage
collection routine after all reference counts to the state and policy
have been removed and any remaining resources can be cleared for the
offload state.  How these are used by the driver will depend on specific
hardware needs.</p>
<p>As a netdev is set to DOWN the XFRM stack's netdev listener will call
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_state_delete()</span></code>, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_policy_delete()</span></code>, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_state_free()</span></code> and
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_policy_free()</span></code> on any remaining offloaded states.</p>
<p>Outcome of HW handling packets, the XFRM core can't count hard, soft limits.
The HW/driver are responsible to perform it and provide accurate data when
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xdo_dev_state_update_stats()</span></code> is called. In case of one of these limits
occuried, the driver needs to call to <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">xfrm_state_check_expire()</span></code> to make sure
that XFRM performs rekeying sequence.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/networking/xfrm/xfrm_device.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>