<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PSP Security Protocol &#8212; The Linux Kernel unknown version 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=adfc0c0d" />
    <script src="../_static/documentation_options.js?v=c459948e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/networking/psp.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="How to use radiotap headers" href="radiotap-headers.html" />
    <link rel="prev" title="PSE Power Interface (PSE PI) Documentation" href="pse-pd/pse-pi.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l3"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/networking/psp.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="psp-security-protocol">
<h1>PSP Security Protocol<a class="headerlink" href="#psp-security-protocol" title="Link to this heading">¶</a></h1>
<section id="protocol">
<h2>Protocol<a class="headerlink" href="#protocol" title="Link to this heading">¶</a></h2>
<p>PSP Security Protocol (PSP) was defined at Google and published in:</p>
<p><a class="reference external" href="https://raw.githubusercontent.com/google/psp/main/doc/PSP_Arch_Spec.pdf">https://raw.githubusercontent.com/google/psp/main/doc/PSP_Arch_Spec.pdf</a></p>
<p>This section briefly covers protocol aspects crucial for understanding
the kernel API. Refer to the protocol specification for further details.</p>
<p>Note that the kernel implementation and documentation uses the term
&quot;device key&quot; in place of &quot;master key&quot;, it is both less confusing
to an average developer and is less likely to run afoul any naming
guidelines.</p>
<section id="derived-rx-keys">
<h3>Derived Rx keys<a class="headerlink" href="#derived-rx-keys" title="Link to this heading">¶</a></h3>
<p>PSP borrows some terms and mechanisms from IPsec. PSP was designed
with HW offloads in mind. The key feature of PSP is that Rx keys for every
connection do not have to be stored by the receiver but can be derived
from device key and information present in packet headers.
This makes it possible to implement receivers which require a constant
amount of memory regardless of the number of connections (<code class="docutils literal notranslate"><span class="pre">O(1)</span></code> scaling).</p>
<p>Tx keys have to be stored like with any other protocol, but Tx is much
less latency sensitive than Rx, and delays in fetching keys from slow
memory is less likely to cause packet drops. Preferably, the Tx keys
should be provided with the packet (e.g. as part of the descriptors).</p>
</section>
<section id="key-rotation">
<h3>Key rotation<a class="headerlink" href="#key-rotation" title="Link to this heading">¶</a></h3>
<p>The device key known only to the receiver is fundamental to the design.
Per specification this state cannot be directly accessible (it must be
impossible to read it out of the hardware of the receiver NIC).
Moreover, it has to be &quot;rotated&quot; periodically (usually daily). Rotation
means that new device key gets generated (by a random number generator
of the device), and used for all new connections. To avoid disrupting
old connections the old device key remains in the NIC. A phase bit
carried in the packet headers indicates which generation of device key
the packet has been encrypted with.</p>
</section>
</section>
<section id="user-facing-api">
<h2>User facing API<a class="headerlink" href="#user-facing-api" title="Link to this heading">¶</a></h2>
<p>PSP is designed primarily for hardware offloads. There is currently
no software fallback for systems which do not have PSP capable NICs.
There is also no standard (or otherwise defined) way of establishing
a PSP-secured connection or exchanging the symmetric keys.</p>
<p>The expectation is that higher layer protocols will take care of
protocol and key negotiation. For example one may use TLS key exchange,
announce the PSP capability, and switch to PSP if both endpoints
are PSP-capable.</p>
<p>All configuration of PSP is performed via the PSP netlink family.</p>
<section id="device-discovery">
<h3>Device discovery<a class="headerlink" href="#device-discovery" title="Link to this heading">¶</a></h3>
<p>The PSP netlink family defines operations to retrieve information
about the PSP devices available on the system, configure them and
access PSP related statistics.</p>
</section>
<section id="securing-a-connection">
<h3>Securing a connection<a class="headerlink" href="#securing-a-connection" title="Link to this heading">¶</a></h3>
<p>PSP encryption is currently only supported for TCP connections.
Rx and Tx keys are allocated separately. First the <code class="docutils literal notranslate"><span class="pre">rx-assoc</span></code>
Netlink command needs to be issued, specifying a target TCP socket.
Kernel will allocate a new PSP Rx key from the NIC and associate it
with given socket. At this stage socket will accept both PSP-secured
and plain text TCP packets.</p>
<p>Tx keys are installed using the <code class="docutils literal notranslate"><span class="pre">tx-assoc</span></code> Netlink command.
Once the Tx keys are installed, all data read from the socket will
be PSP-secured. In other words act of installing Tx keys has a secondary
effect on the Rx direction.</p>
<p>There is an intermediate period after <code class="docutils literal notranslate"><span class="pre">tx-assoc</span></code> successfully
returns and before the TCP socket encounters it's first PSP
authenticated packet, where the TCP stack will allow certain nondata
packets, i.e. ACKs, FINs, and RSTs, to enter TCP receive processing
even if not PSP authenticated. During the <code class="docutils literal notranslate"><span class="pre">tx-assoc</span></code> call, the TCP
socket's <code class="docutils literal notranslate"><span class="pre">rcv_nxt</span></code> field is recorded. At this point, ACKs and RSTs
will be accepted with any sequence number, while FINs will only be
accepted at the latched value of <code class="docutils literal notranslate"><span class="pre">rcv_nxt</span></code>. Once the TCP stack
encounters the first TCP packet containing PSP authenticated data, the
other end of the connection must have executed the <code class="docutils literal notranslate"><span class="pre">tx-assoc</span></code>
command, so any TCP packet, including those without data, will be
dropped before receive processing if it is not successfully
authenticated. This is summarized in the table below. The
aforementioned state of rejecting all non-PSP packets is labeled &quot;PSP
Full&quot;.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Event</p></th>
<th class="head"><p>Normal TCP</p></th>
<th class="head"><p>Rx PSP</p></th>
<th class="head"><p>Tx PSP</p></th>
<th class="head"><p>PSP Full</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Rx plain
(data)</p></td>
<td><p>accept</p></td>
<td><p>accept</p></td>
<td><p>drop</p></td>
<td><p>drop</p></td>
</tr>
<tr class="row-odd"><td><p>Rx plain
(ACK|FIN|RST)</p></td>
<td><p>accept</p></td>
<td><p>accept</p></td>
<td><p>accept</p></td>
<td><p>drop</p></td>
</tr>
<tr class="row-even"><td><p>Rx PSP (good)</p></td>
<td><p>drop</p></td>
<td><p>accept</p></td>
<td><p>accept</p></td>
<td><p>accept</p></td>
</tr>
<tr class="row-odd"><td><p>Rx PSP (bad
crypt, !=SPI)</p></td>
<td><p>drop</p></td>
<td><p>drop</p></td>
<td><p>drop</p></td>
<td><p>drop</p></td>
</tr>
<tr class="row-even"><td><p>Tx</p></td>
<td><p>plain text</p></td>
<td><p>plain text</p></td>
<td><p>encrypted
(excl. rtx)</p></td>
<td><p>encrypted
(excl. rtx)</p></td>
</tr>
</tbody>
</table>
<p>To ensure that any data read from the socket after the <code class="docutils literal notranslate"><span class="pre">tx-assoc</span></code>
call returns success has been authenticated, the kernel will scan the
receive and ofo queues of the socket at <code class="docutils literal notranslate"><span class="pre">tx-assoc</span></code> time. If any
enqueued packet was received in clear text, the Tx association will
fail, and the application should retry installing the Tx key after
draining the socket (this should not be necessary if both endpoints
are well behaved).</p>
<p>Because TCP sequence numbers are not integrity protected prior to
upgrading to PSP, it is possible that a MITM could offset sequence
numbers in a way that deletes a prefix of the PSP protected part of
the TCP stream. If userspace cares to mitigate this type of attack, a
special &quot;start of PSP&quot; message should be exchanged after <code class="docutils literal notranslate"><span class="pre">tx-assoc</span></code>.</p>
</section>
<section id="rotation-notifications">
<h3>Rotation notifications<a class="headerlink" href="#rotation-notifications" title="Link to this heading">¶</a></h3>
<p>The rotations of device key happen asynchronously and are usually
performed by management daemons, not under application control.
The PSP netlink family will generate a notification whenever keys
are rotated. The applications are expected to re-establish connections
before keys are rotated again.</p>
</section>
</section>
<section id="kernel-implementation">
<h2>Kernel implementation<a class="headerlink" href="#kernel-implementation" title="Link to this heading">¶</a></h2>
<section id="driver-notes">
<h3>Driver notes<a class="headerlink" href="#driver-notes" title="Link to this heading">¶</a></h3>
<p>Drivers are expected to start with no PSP enabled (<code class="docutils literal notranslate"><span class="pre">psp-versions-ena</span></code>
in <code class="docutils literal notranslate"><span class="pre">dev-get</span></code> set to <code class="docutils literal notranslate"><span class="pre">0</span></code>) whenever possible. The user space should
not depend on this behavior, as future extension may necessitate creation
of devices with PSP already enabled, nonetheless drivers should not enable
PSP by default. Enabling PSP should be the responsibility of the system
component which also takes care of key rotation.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">psp-versions-ena</span></code> is expected to be used only for enabling
receive processing. The device is not expected to reject transmit requests
after <code class="docutils literal notranslate"><span class="pre">psp-versions-ena</span></code> has been disabled. User may also disable
<code class="docutils literal notranslate"><span class="pre">psp-versions-ena</span></code> while there are active associations, which will
break all PSP Rx processing.</p>
<p>Drivers are expected to ensure that a device key is usable and secure
upon init, without explicit key rotation by the user space. It must be
possible to allocate working keys, and that no duplicate keys must be
generated. If the device allows the host to request the key for an
arbitrary SPI - driver should discard both device keys (rotate the
device key twice), to avoid potentially using a SPI+key which previous
OS instance already had access to.</p>
<p>Drivers must use <code class="docutils literal notranslate"><span class="pre">psp_skb_get_assoc_rcu()</span></code> to check if PSP Tx offload
was requested for given skb. On Rx drivers should allocate and populate
the <code class="docutils literal notranslate"><span class="pre">SKB_EXT_PSP</span></code> skb extension, and set the skb-&gt;decrypted bit to 1.</p>
</section>
<section id="kernel-implementation-notes">
<h3>Kernel implementation notes<a class="headerlink" href="#kernel-implementation-notes" title="Link to this heading">¶</a></h3>
<p>PSP implementation follows the TLS offload more closely than the IPsec
offload, with per-socket state, and the use of skb-&gt;decrypted to prevent
clear text leaks.</p>
<p>PSP device is separate from netdev, to make it possible to &quot;delegate&quot;
PSP offload capabilities to software devices (e.g. <code class="docutils literal notranslate"><span class="pre">veth</span></code>).</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/networking/psp.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>