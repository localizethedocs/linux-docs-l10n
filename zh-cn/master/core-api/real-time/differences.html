<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>How realtime kernels differ &#8212; The Linux Kernel  文档</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../_static/documentation_options.js?v=7d86a446"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/core-api/real-time/differences.html" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="Porting an architecture to support PREEMPT_RT" href="architecture-porting.html" />
    <link rel="prev" title="Theory of operation" href="theory.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.18.0-rc2</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Core API</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../kernel-api.html">The Linux Kernel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../workqueue.html">Workqueue</a></li>
<li class="toctree-l3"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
<li class="toctree-l3"><a class="reference internal" href="../printk-basics.html">Message logging with printk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../printk-formats.html">How to get printk format specifiers right</a></li>
<li class="toctree-l3"><a class="reference internal" href="../printk-index.html">Printk Index</a></li>
<li class="toctree-l3"><a class="reference internal" href="../symbol-namespaces.html">Symbol Namespaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Real-time preemption</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#low-level-hardware-management">Low-level hardware management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Core API Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/core-api/real-time/differences.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="how-realtime-kernels-differ">
<h1>How realtime kernels differ<a class="headerlink" href="#how-realtime-kernels-differ" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Sebastian Andrzej Siewior &lt;<a class="reference external" href="mailto:bigeasy&#37;&#52;&#48;linutronix&#46;de">bigeasy<span>&#64;</span>linutronix<span>&#46;</span>de</a>&gt;</p>
</dd>
</dl>
<section id="preface">
<h2>Preface<a class="headerlink" href="#preface" title="Link to this heading">¶</a></h2>
<p>With forced-threaded interrupts and sleeping spin locks, code paths that
previously caused long scheduling latencies have been made preemptible and
moved into process context. This allows the scheduler to manage them more
effectively and respond to higher-priority tasks with reduced latency.</p>
<p>The following chapters provide an overview of key differences between a
PREEMPT_RT kernel and a standard, non-PREEMPT_RT kernel.</p>
</section>
<section id="locking">
<h2>Locking<a class="headerlink" href="#locking" title="Link to this heading">¶</a></h2>
<p>Spinning locks such as spinlock_t are used to provide synchronization for data
structures accessed from both interrupt context and process context. For this
reason, locking functions are also available with the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_irq()</span></code> or <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_irqsave()</span></code>
suffixes, which disable interrupts before acquiring the lock. This ensures that
the lock can be safely acquired in process context when interrupts are enabled.</p>
<p>However, on a PREEMPT_RT system, interrupts are forced-threaded and no longer
run in hard IRQ context. As a result, there is no need to disable interrupts as
part of the locking procedure when using spinlock_t.</p>
<p>For low-level core components such as interrupt handling, the scheduler, or the
timer subsystem the kernel uses raw_spinlock_t. This lock type preserves
traditional semantics: it disables preemption and, when used with <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_irq()</span></code> or
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_irqsave()</span></code>, also disables interrupts. This ensures proper synchronization in
critical sections that must remain non-preemptible or with interrupts disabled.</p>
</section>
<section id="execution-context">
<h2>Execution context<a class="headerlink" href="#execution-context" title="Link to this heading">¶</a></h2>
<p>Interrupt handling in a PREEMPT_RT system is invoked in process context through
the use of threaded interrupts. Other parts of the kernel also shift their
execution into threaded context by different mechanisms. The goal is to keep
execution paths preemptible, allowing the scheduler to interrupt them when a
higher-priority task needs to run.</p>
<p>Below is an overview of the kernel subsystems involved in this transition to
threaded, preemptible execution.</p>
<section id="interrupt-handling">
<h3>Interrupt handling<a class="headerlink" href="#interrupt-handling" title="Link to this heading">¶</a></h3>
<p>All interrupts are forced-threaded in a PREEMPT_RT system. The exceptions are
interrupts that are requested with the IRQF_NO_THREAD, IRQF_PERCPU, or
IRQF_ONESHOT flags.</p>
<p>The IRQF_ONESHOT flag is used together with threaded interrupts, meaning those
registered using <a class="reference internal" href="../genericirq.html#c.request_threaded_irq" title="request_threaded_irq"><code class="xref c c-func docutils literal notranslate"><span class="pre">request_threaded_irq()</span></code></a> and providing only a threaded handler.
Its purpose is to keep the interrupt line masked until the threaded handler has
completed.</p>
<p>If a primary handler is also provided in this case, it is essential that the
handler does not acquire any sleeping locks, as it will not be threaded. The
handler should be minimal and must avoid introducing delays, such as
busy-waiting on hardware registers.</p>
</section>
<section id="soft-interrupts-bottom-half-handling">
<h3>Soft interrupts, bottom half handling<a class="headerlink" href="#soft-interrupts-bottom-half-handling" title="Link to this heading">¶</a></h3>
<p>Soft interrupts are raised by the interrupt handler and are executed after the
handler returns. Since they run in thread context, they can be preempted by
other threads. Do not assume that softirq context runs with preemption
disabled. This means you must not rely on mechanisms like <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">local_bh_disable()</span></code> in
process context to protect per-CPU variables. Because softirq handlers are
preemptible under PREEMPT_RT, this approach does not provide reliable
synchronization.</p>
<p>If this kind of protection is required for performance reasons, consider using
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">local_lock_nested_bh()</span></code>. On non-PREEMPT_RT kernels, this allows lockdep to
verify that bottom halves are disabled. On PREEMPT_RT systems, it adds the
necessary locking to ensure proper protection.</p>
<p>Using <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">local_lock_nested_bh()</span></code> also makes the locking scope explicit and easier
for readers and maintainers to understand.</p>
</section>
<section id="per-cpu-variables">
<h3>per-CPU variables<a class="headerlink" href="#per-cpu-variables" title="Link to this heading">¶</a></h3>
<p>Protecting access to per-CPU variables solely by using <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preempt_disable()</span></code> should
be avoided, especially if the critical section has unbounded runtime or may
call APIs that can sleep.</p>
<p>If using a spinlock_t is considered too costly for performance reasons,
consider using local_lock_t. On non-PREEMPT_RT configurations, this introduces
no runtime overhead when lockdep is disabled. With lockdep enabled, it verifies
that the lock is only acquired in process context and never from softirq or
hard IRQ context.</p>
<p>On a PREEMPT_RT kernel, local_lock_t is implemented using a per-CPU spinlock_t,
which provides safe local protection for per-CPU data while keeping the system
preemptible.</p>
<p>Because spinlock_t on PREEMPT_RT does not disable preemption, it cannot be used
to protect per-CPU data by relying on implicit preemption disabling. If this
inherited preemption disabling is essential and if local_lock_t cannot be used
due to performance constraints, brevity of the code, or abstraction boundaries
within an API then <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">preempt_disable_nested()</span></code> may be a suitable alternative. On
non-PREEMPT_RT kernels, it verifies with lockdep that preemption is already
disabled. On PREEMPT_RT, it explicitly disables preemption.</p>
</section>
<section id="timers">
<h3>Timers<a class="headerlink" href="#timers" title="Link to this heading">¶</a></h3>
<p>By default, an hrtimer is executed in hard interrupt context. The exception is
timers initialized with the HRTIMER_MODE_SOFT flag, which are executed in
softirq context.</p>
<p>On a PREEMPT_RT kernel, this behavior is reversed: hrtimers are executed in
softirq context by default, typically within the ktimersd thread. This thread
runs at the lowest real-time priority, ensuring it executes before any
SCHED_OTHER tasks but does not interfere with higher-priority real-time
threads. To explicitly request execution in hard interrupt context on
PREEMPT_RT, the timer must be marked with the HRTIMER_MODE_HARD flag.</p>
</section>
<section id="memory-allocation">
<h3>Memory allocation<a class="headerlink" href="#memory-allocation" title="Link to this heading">¶</a></h3>
<p>The memory allocation APIs, such as <a class="reference internal" href="../mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> and <a class="reference internal" href="../mm-api.html#c.alloc_pages" title="alloc_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">alloc_pages()</span></code></a>, require a
gfp_t flag to indicate the allocation context. On non-PREEMPT_RT kernels, it is
necessary to use GFP_ATOMIC when allocating memory from interrupt context or
from sections where preemption is disabled. This is because the allocator must
not sleep in these contexts waiting for memory to become available.</p>
<p>However, this approach does not work on PREEMPT_RT kernels. The memory
allocator in PREEMPT_RT uses sleeping locks internally, which cannot be
acquired when preemption is disabled. Fortunately, this is generally not a
problem, because PREEMPT_RT moves most contexts that would traditionally run
with preemption or interrupts disabled into threaded context, where sleeping is
allowed.</p>
<p>What remains problematic is code that explicitly disables preemption or
interrupts. In such cases, memory allocation must be performed outside the
critical section.</p>
<p>This restriction also applies to memory deallocation routines such as <a class="reference internal" href="../mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kfree()</span></code></a>
and <a class="reference internal" href="../mm-api.html#c.free_pages" title="free_pages"><code class="xref c c-func docutils literal notranslate"><span class="pre">free_pages()</span></code></a>, which may also involve internal locking and must not be
called from non-preemptible contexts.</p>
</section>
<section id="irq-work">
<h3>IRQ work<a class="headerlink" href="#irq-work" title="Link to this heading">¶</a></h3>
<p>The irq_work API provides a mechanism to schedule a callback in interrupt
context. It is designed for use in contexts where traditional scheduling is not
possible, such as from within NMI handlers or from inside the scheduler, where
using a workqueue would be unsafe.</p>
<p>On non-PREEMPT_RT systems, all irq_work items are executed immediately in
interrupt context. Items marked with IRQ_WORK_LAZY are deferred until the next
timer tick but are still executed in interrupt context.</p>
<p>On PREEMPT_RT systems, the execution model changes. Because irq_work callbacks
may acquire sleeping locks or have unbounded execution time, they are handled
in thread context by a per-CPU irq_work kernel thread. This thread runs at the
lowest real-time priority, ensuring it executes before any SCHED_OTHER tasks
but does not interfere with higher-priority real-time threads.</p>
<p>The exception are work items marked with IRQ_WORK_HARD_IRQ, which are still
executed in hard interrupt context. Lazy items (IRQ_WORK_LAZY) continue to be
deferred until the next timer tick and are also executed by the irq_work/
thread.</p>
</section>
<section id="rcu-callbacks">
<h3>RCU callbacks<a class="headerlink" href="#rcu-callbacks" title="Link to this heading">¶</a></h3>
<p>RCU callbacks are invoked by default in softirq context. Their execution is
important because, depending on the use case, they either free memory or ensure
progress in state transitions. Running these callbacks as part of the softirq
chain can lead to undesired situations, such as contention for CPU resources
with other SCHED_OTHER tasks when executed within ksoftirqd.</p>
<p>To avoid running callbacks in softirq context, the RCU subsystem provides a
mechanism to execute them in process context instead. This behavior can be
enabled by setting the boot command-line parameter rcutree.use_softirq=0. This
setting is enforced in kernels configured with PREEMPT_RT.</p>
</section>
</section>
<section id="spin-until-ready">
<h2>Spin until ready<a class="headerlink" href="#spin-until-ready" title="Link to this heading">¶</a></h2>
<p>The &quot;spin until ready&quot; pattern involves repeatedly checking (spinning on) the
state of a data structure until it becomes available. This pattern assumes that
preemption, soft interrupts, or interrupts are disabled. If the data structure
is marked busy, it is presumed to be in use by another CPU, and spinning should
eventually succeed as that CPU makes progress.</p>
<p>Some examples are <a class="reference internal" href="../../driver-api/basics.html#c.hrtimer_cancel" title="hrtimer_cancel"><code class="xref c c-func docutils literal notranslate"><span class="pre">hrtimer_cancel()</span></code></a> or <a class="reference internal" href="../../driver-api/basics.html#c.timer_delete_sync" title="timer_delete_sync"><code class="xref c c-func docutils literal notranslate"><span class="pre">timer_delete_sync()</span></code></a>. These functions
cancel timers that execute with interrupts or soft interrupts disabled. If a
thread attempts to cancel a timer and finds it active, spinning until the
callback completes is safe because the callback can only run on another CPU and
will eventually finish.</p>
<p>On PREEMPT_RT kernels, however, timer callbacks run in thread context. This
introduces a challenge: a higher-priority thread attempting to cancel the timer
may preempt the timer callback thread. Since the scheduler cannot migrate the
callback thread to another CPU due to affinity constraints, spinning can result
in livelock even on multiprocessor systems.</p>
<p>To avoid this, both the canceling and callback sides must use a handshake
mechanism that supports priority inheritance. This allows the canceling thread
to suspend until the callback completes, ensuring forward progress without
risking livelock.</p>
<p>In order to solve the problem at the API level, the sequence locks were extended
to allow a proper handover between the the spinning reader and the maybe
blocked writer.</p>
<section id="sequence-locks">
<h3>Sequence locks<a class="headerlink" href="#sequence-locks" title="Link to this heading">¶</a></h3>
<p>Sequence counters and sequential locks are documented in
<a class="reference internal" href="../../locking/seqlock.html"><span class="doc">Sequence counters and sequential locks</span></a>.</p>
<p>The interface has been extended to ensure proper preemption states for the
writer and spinning reader contexts. This is achieved by embedding the writer
serialization lock directly into the sequence counter type, resulting in
composite types such as seqcount_spinlock_t or seqcount_mutex_t.</p>
<p>These composite types allow readers to detect an ongoing write and actively
boost the writer’s priority to help it complete its update instead of spinning
and waiting for its completion.</p>
<p>If the plain seqcount_t is used, extra care must be taken to synchronize the
reader with the writer during updates. The writer must ensure its update is
serialized and non-preemptible relative to the reader. This cannot be achieved
using a regular spinlock_t because spinlock_t on PREEMPT_RT does not disable
preemption. In such cases, using seqcount_spinlock_t is the preferred solution.</p>
<p>However, if there is no spinning involved i.e., if the reader only needs to
detect whether a write has started and not serialize against it then using
seqcount_t is reasonable.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/core-api/real-time/differences.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>