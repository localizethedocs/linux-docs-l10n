<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Generic Radix Page Table &#8212; The Linux Kernel unknown version 文档</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=adfc0c0d" />
    <script src="../_static/documentation_options.js?v=c459948e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/driver-api/generic_pt.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="General Purpose Input/Output (GPIO)" href="gpio/index.html" />
    <link rel="prev" title="Generic Counter Interface" href="generic-counter.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="提交" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">Submitting patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">Code of conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Maintainer handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer's Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l3"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="coco/index.html">Confidential Computing</a></li>
<li class="toctree-l3"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="crypto/index.html">Crypto Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="dpll.html">The Linux kernel dpll subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="extcon.html">Extcon Device Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l3"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="aperture.html">Managing Ownership of the Framebuffer Aperture</a></li>
<li class="toctree-l3"><a class="reference internal" href="generic-counter.html">Generic Counter Interface</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Generic Radix Page Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hte/index.html">The Linux Hardware Timestamping Engine (HTE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hw-recoverable-errors.html">Recoverable Hardware Error Tracking in vmcoreinfo</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="libata.html">libATA Developer's Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l3"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l3"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l3"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="pwrseq.html">Power Sequencing API</a></li>
<li class="toctree-l3"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l3"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l3"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="tee.html">TEE (Trusted Execution Environment) driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l3"><a class="reference internal" href="tty/index.html">TTY</a></li>
<li class="toctree-l3"><a class="reference internal" href="wbrf.html">WBRF - Wifi Band RFI Mitigations</a></li>
<li class="toctree-l3"><a class="reference internal" href="wmi.html">WMI Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l3"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">Subsystems</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">Memory Management Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">Writing documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">Testing guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Build system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Userspace tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">Userspace API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">Firmware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted documentation</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/generic_pt.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="generic-radix-page-table">
<h1>Generic Radix Page Table<a class="headerlink" href="#generic-radix-page-table" title="Link to this heading">¶</a></h1>
<p>Generic Radix Page Table is a set of functions and helpers to efficiently
parse radix style page tables typically seen in HW implementations. The
interface is built to deliver similar code generation as the mm's pte/pmd/etc
system by fully inlining the exact code required to handle each table level.</p>
<p>Like the mm subsystem each format contributes its parsing implementation
under common names and the common code implements the required algorithms.</p>
<p>The system is divided into three logical levels:</p>
<blockquote>
<div><ul class="simple">
<li><p>The page table format and its manipulation functions</p></li>
<li><p>Generic helpers to give a consistent API regardless of underlying format</p></li>
<li><p>An algorithm implementation (e.g. IOMMU/DRM/KVM/MM)</p></li>
</ul>
</div></blockquote>
<p>Multiple implementations are supported. The intention is to have the generic
format code be re-usable for whatever specialized implementation is required.
The generic code is solely about the format of the radix tree; it does not
include memory allocation or higher level decisions that are left for the
implementation.</p>
<p>The generic framework supports a superset of functions across many HW
implementations:</p>
<blockquote>
<div><ul class="simple">
<li><p>Entries comprised of contiguous blocks of IO PTEs for larger page sizes</p></li>
<li><p>Multi-level tables, up to 6 levels. Runtime selected top level</p></li>
<li><p>Runtime variable table level size (ARM's concatenated tables)</p></li>
<li><p>Expandable top level allowing dynamic sizing of table levels</p></li>
<li><p>Optional leaf entries at any level</p></li>
<li><p>32-bit/64-bit virtual and output addresses, using every address bit</p></li>
<li><p>Dirty tracking</p></li>
<li><p>Sign extended addressing</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Language used in Generic Page Table</dt><dd><dl class="simple">
<dt>VA</dt><dd><p>The input address to the page table, often the virtual address.</p>
</dd>
<dt>OA</dt><dd><p>The output address from the page table, often the physical address.</p>
</dd>
<dt>leaf</dt><dd><p>An entry that results in an output address.</p>
</dd>
<dt>start/end</dt><dd><p>An half-open range, e.g. [0,0) refers to no VA.</p>
</dd>
<dt>start/last</dt><dd><p>An inclusive closed range, e.g. [0,0] refers to the VA 0</p>
</dd>
<dt>common</dt><dd><p>The generic page table container <a class="reference internal" href="#c.pt_common" title="pt_common"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span></code></a></p>
</dd>
<dt>level</dt><dd><p>Level 0 is always a table of only leaves with no futher table pointers.
Increasing levels increase the size of the table items. The least
significant VA bits used to index page tables are used to index the Level
0 table. The various labels for table levels used by HW descriptions are
not used.</p>
</dd>
<dt>top_level</dt><dd><p>The inclusive highest level of the table. A two-level table
has a top level of 1.</p>
</dd>
<dt>table</dt><dd><p>A linear array of translation items for that level.</p>
</dd>
<dt>index</dt><dd><p>The position in a table of an element: item = table[index]</p>
</dd>
<dt>item</dt><dd><p>A single index in a table</p>
</dd>
<dt>entry</dt><dd><p>A single logical element in a table. If contiguous pages are not
supported then item and entry are the same thing, otherwise entry refers
to all the items that comprise a single contiguous translation.</p>
</dd>
<dt>item/entry_size</dt><dd><p>The number of bytes of VA the table index translates for.
If the item is a table entry then the next table covers
this size. If the entry translates to an output address then the
full OA is: OA | (VA % entry_size)</p>
</dd>
<dt>contig_count</dt><dd><p>The number of consecutive items fused into a single entry.
item_size * contig_count is the size of that entry's translation.</p>
</dd>
<dt>lg2</dt><dd><p>Indicates the value is encoded as log2, i.e. 1&lt;&lt;x is the actual value.
Normally the compiler is fine to optimize divide and mod with log2 values
automatically when inlining, however if the values are not constant
expressions it can't. So we do it by hand; we want to avoid 64-bit
divmod.</p>
</dd>
</dl>
</dd>
</dl>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h2>
<p>Generic PT is structured as a multi-compilation system. Since each format
provides an API using a common set of names there can be only one format active
within a compilation unit. This design avoids function pointers around the low
level API.</p>
<p>Instead the function pointers can end up at the higher level API (i.e.
map/unmap, etc.) and the per-format code can be directly inlined into the
per-format compilation unit. For something like IOMMU each format will be
compiled into a per-format IOMMU operations kernel module.</p>
<p>For this to work the .c file for each compilation unit will include both the
format headers and the generic code for the implementation. For instance in an
implementation compilation unit the headers would normally be included as
follows:</p>
<p>generic_pt/fmt/iommu_amdv1.c:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;linux/generic_pt/common.h&gt;
#include &quot;defs_amdv1.h&quot;
#include &quot;../pt_defs.h&quot;
#include &quot;amdv1.h&quot;
#include &quot;../pt_common.h&quot;
#include &quot;../pt_iter.h&quot;
#include &quot;../iommu_pt.h&quot;  /* The IOMMU implementation */
</pre></div>
</div>
<p>iommu_pt.h includes definitions that will generate the operations functions for
map/unmap/etc. using the definitions provided by AMDv1. The resulting module
will have exported symbols named like <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">pt_iommu_amdv1_init()</span></code>.</p>
<p>Refer to drivers/iommu/generic_pt/fmt/iommu_template.h for an example of how the
IOMMU implementation uses multi-compilation to generate per-format ops structs
pointers.</p>
<p>The format code is written so that the common names arise from #defines to
distinct format specific names. This is intended to aid debuggability by
avoiding symbol clashes across all the different formats.</p>
<p>Exported symbols and other global names are mangled using a per-format string
via the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">NS()</span></code> helper macro.</p>
<p>The format uses <a class="reference internal" href="#c.pt_common" title="pt_common"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span></code></a> as the top-level struct for the table,
and each format will have its own <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_xxx</span></code> which embeds it to store
format-specific information.</p>
<p>The implementation will further wrap <a class="reference internal" href="#c.pt_common" title="pt_common"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span></code></a> in its own top-level
struct, such as <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_iommu_amdv1</span></code>.</p>
<section id="format-functions-at-the-struct-pt-common-level">
<h3>Format functions at the struct pt_common level<a class="headerlink" href="#format-functions-at-the-struct-pt-common-level" title="Link to this heading">¶</a></h3>
<dl class="c struct">
<dt class="sig sig-object c" id="c.pt_common">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_common</span></span></span><a class="headerlink" href="#c.pt_common" title="Link to this definition">¶</a><br /></dt>
<dd><p>struct for all page table implementations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct pt_common {
    uintptr_t top_of_table;
    u8 max_oasz_lg2;
    u8 max_vasz_lg2;
    unsigned int features;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">top_of_table</span></code></dt><dd><p>Encodes the table top pointer and the top level in a
single value. Must use READ_ONCE/WRITE_ONCE to access it. The lower
bits of the aligned table pointer are used for the level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_oasz_lg2</span></code></dt><dd><p>Maximum number of bits the OA can contain. Upper bits
must be zero. This may be less than what the page table format
supports, but must not be more.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">max_vasz_lg2</span></code></dt><dd><p>Maximum number of bits the VA can contain. Upper bits
are 0 or 1 depending on <a class="reference internal" href="#c.pt_full_va_prefix" title="pt_full_va_prefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_full_va_prefix()</span></code></a>. This may be less than
what the page table format supports, but must not be more. When
PT_FEAT_DYNAMIC_TOP is set this reflects the maximum VA capability.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">features</span></code></dt><dd><p>Bitmap of <cite><a class="reference internal" href="#c.pt_features" title="pt_features"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">pt_features</span></code></a></cite></p>
</dd>
</dl>
</div>
<dl class="c enum">
<dt class="sig sig-object c" id="c.pt_features">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_features</span></span></span><a class="headerlink" href="#c.pt_features" title="Link to this definition">¶</a><br /></dt>
<dd><p>Features turned on in the table. Each symbol is a bit position.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">PT_FEAT_DMA_INCOHERENT</span></code></dt><dd><p>Cache flush page table memory before
assuming the HW can read it. Otherwise a SMP release is sufficient
for HW to read it.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PT_FEAT_FULL_VA</span></code></dt><dd><p>The table can span the full VA range from 0 to
PT_VADDR_MAX.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PT_FEAT_DYNAMIC_TOP</span></code></dt><dd><p>The table's top level can be increased
dynamically during map. This requires HW support for atomically
setting both the table top pointer and the starting table level.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PT_FEAT_SIGN_EXTEND</span></code></dt><dd><p>The top most bit of the valid VA range sign
extends up to the full pt_vaddr_t. This divides the page table into
three VA ranges:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0         -&gt; 2^N - 1             Lower
2^N       -&gt; (MAX - 2^N - 1)     Non-Canonical
MAX - 2^N -&gt; MAX                 Upper
</pre></div>
</div>
<p>In this mode pt_common::max_vasz_lg2 includes the sign bit and the
upper bits that don't fall within the translation are just validated.</p>
<p>If not set there is no sign extension and valid VA goes from 0 to 2^N
- 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PT_FEAT_FLUSH_RANGE</span></code></dt><dd><p>IOTLB maintenance is done by flushing IOVA
ranges which will clean out any walk cache or any IOPTE fully
contained by the range. The optimization objective is to minimize the
number of flushes even if ranges include IOVA gaps that do not need
to be flushed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PT_FEAT_FLUSH_RANGE_NO_GAPS</span></code></dt><dd><p>Like PT_FEAT_FLUSH_RANGE except that
the optimization objective is to only flush IOVA that has been
changed. This mode is suitable for cases like hypervisor shadowing
where flushing unchanged ranges may cause the hypervisor to reparse
significant amount of page table.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_attr_from_entry">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_attr_from_entry</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_write_attrs</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_attr_from_entry" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert the permission bits back to attrs</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to convert from</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_write_attrs</span> <span class="pre">*attrs</span></code></dt><dd><p>Resulting attrs</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the attrs with the permission bits encoded in the current leaf entry.
The attrs should be usable with <a class="reference internal" href="#c.pt_install_leaf_entry" title="pt_install_leaf_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_install_leaf_entry()</span></code></a> to reconstruct the
same entry.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_can_have_leaf">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_can_have_leaf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_can_have_leaf" title="Link to this definition">¶</a><br /></dt>
<dd><p>True if the current level can have an OA entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>The current level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>True if the current level can support <a class="reference internal" href="#c.pt_install_leaf_entry" title="pt_install_leaf_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_install_leaf_entry()</span></code></a>. A leaf
entry produce an OA.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_can_have_table">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_can_have_table</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_can_have_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>True if the current level can have a lower table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>The current level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Every level except 0 is allowed to have a lower table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_clear_entries">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_clear_entries</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">num_contig_lg2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_clear_entries" title="Link to this definition">¶</a><br /></dt>
<dd><p>Make entries empty (non-present)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Starting table index</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_contig_lg2</span></code></dt><dd><p>Number of contiguous items to clear</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear a run of entries. A cleared entry will load back as PT_ENTRY_EMPTY
and does not have any effect on table walking. The starting index must be
aligned to num_contig_lg2.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_entry_make_write_dirty">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_entry_make_write_dirty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_entry_make_write_dirty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Make an entry dirty</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Table entry to change</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make <a class="reference internal" href="#c.pt_entry_is_write_dirty" title="pt_entry_is_write_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_entry_is_write_dirty()</span></code></a> return true for this entry. This can be called
asynchronously with any other table manipulation under a RCU lock and must
not corrupt the table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_entry_make_write_clean">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_entry_make_write_clean</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_entry_make_write_clean" title="Link to this definition">¶</a><br /></dt>
<dd><p>Make the entry write clean</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Table entry to change</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Modify the entry so that <a class="reference internal" href="#c.pt_entry_is_write_dirty" title="pt_entry_is_write_dirty"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_entry_is_write_dirty()</span></code></a> == false. The HW will
eventually be notified of this change via a TLB flush, which is the point
that the HW must become synchronized. Any &quot;write dirty&quot; prior to the TLB
flush can be lost, but once the TLB flush completes all writes must make
their entries write dirty.</p>
<p>The format should alter the entry in a way that is compatible with any
concurrent update from HW. The entire contiguous entry is changed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_entry_is_write_dirty">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_entry_is_write_dirty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_entry_is_write_dirty" title="Link to this definition">¶</a><br /></dt>
<dd><p>True if the entry has been written to</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>&quot;write dirty&quot; means that the HW has written to the OA translated
by this entry. If the entry is contiguous then the consolidated
&quot;write dirty&quot; for all the items must be returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_dirty_supported">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_dirty_supported</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_dirty_supported" title="Link to this definition">¶</a><br /></dt>
<dd><p>True if the page table supports dirty tracking</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Page table to query</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_entry_num_contig_lg2">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_entry_num_contig_lg2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_entry_num_contig_lg2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Number of contiguous items for this leaf entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the number of contiguous items this leaf entry spans. If the entry
is single item it returns ilog2(1).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_entry_oa">
<span class="n"><span class="pre">pt_oaddr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_entry_oa</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_entry_oa" title="Link to this definition">¶</a><br /></dt>
<dd><p>Output Address for this leaf entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the output address for the start of the entry. If the entry
is contiguous this returns the same value for each sub-item. I.e.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>log2_mod(pt_entry_oa(), pt_entry_oa_lg2sz()) == 0
</pre></div>
</div>
<p>See <a class="reference internal" href="#c.pt_item_oa" title="pt_item_oa"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_item_oa()</span></code></a>. The format should implement one of these two functions
depending on how it stores the OAs in the table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_entry_oa_lg2sz">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_entry_oa_lg2sz</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_entry_oa_lg2sz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the size of an OA entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the entry is not contiguous this returns <a class="reference internal" href="#c.pt_table_item_lg2sz" title="pt_table_item_lg2sz"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_table_item_lg2sz()</span></code></a>, otherwise
it returns the total VA/OA size of the entire contiguous entry.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_entry_oa_exact">
<span class="n"><span class="pre">pt_oaddr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_entry_oa_exact</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_entry_oa_exact" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the complete OA for an entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>During iteration the first entry could have a VA with an offset from the
natural start of the entry. Return the exact OA including the pts's VA
offset.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_full_va_prefix">
<span class="n"><span class="pre">pt_vaddr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_full_va_prefix</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_full_va_prefix" title="Link to this definition">¶</a><br /></dt>
<dd><p>The top bits of the VA</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Page table to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is usually 0, but some formats have their VA space going downward from
PT_VADDR_MAX, and will return that instead. This value must always be
adjusted by <a class="reference internal" href="#c.pt_common" title="pt_common"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span></code></a> max_vasz_lg2.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_has_system_page_size">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_has_system_page_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_has_system_page_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>True if level 0 can install a PAGE_SHIFT entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Page table to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>If true the caller can use, at level 0, pt_install_leaf_entry(PAGE_SHIFT).
This is useful to create optimized paths for common cases of PAGE_SIZE
mappings.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_install_leaf_entry">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_install_leaf_entry</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="n"><span class="pre">pt_oaddr_t</span></span><span class="w"> </span><span class="n"><span class="pre">oa</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">oasz_lg2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_write_attrs</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_install_leaf_entry" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write a leaf entry to the table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Table index to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_oaddr_t</span> <span class="pre">oa</span></code></dt><dd><p>Output Address for this leaf</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">oasz_lg2</span></code></dt><dd><p>Size in VA/OA for this leaf</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_write_attrs</span> <span class="pre">*attrs</span></code></dt><dd><p>Attributes to modify the entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A leaf OA entry will return PT_ENTRY_OA from <a class="reference internal" href="#c.pt_load_entry" title="pt_load_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_load_entry()</span></code></a>. It translates
the VA indicated by pts to the given OA.</p>
<p>For a single item non-contiguous entry oasz_lg2 is <a class="reference internal" href="#c.pt_table_item_lg2sz" title="pt_table_item_lg2sz"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_table_item_lg2sz()</span></code></a>.
For contiguous it is <a class="reference internal" href="#c.pt_table_item_lg2sz" title="pt_table_item_lg2sz"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_table_item_lg2sz()</span></code></a> + num_contig_lg2.</p>
<p>This must not be called if <a class="reference internal" href="#c.pt_can_have_leaf" title="pt_can_have_leaf"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_can_have_leaf()</span></code></a> == false. Contiguous sizes
not indicated by <a class="reference internal" href="#c.pt_possible_sizes" title="pt_possible_sizes"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_possible_sizes()</span></code></a> must not be specified.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_install_table">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_install_table</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="n"><span class="pre">pt_oaddr_t</span></span><span class="w"> </span><span class="n"><span class="pre">table_pa</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_write_attrs</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_install_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write a table entry to the table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Table index to change</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_oaddr_t</span> <span class="pre">table_pa</span></code></dt><dd><p>CPU physical address of the lower table's memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_write_attrs</span> <span class="pre">*attrs</span></code></dt><dd><p>Attributes to modify the table index</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A table entry will return PT_ENTRY_TABLE from <a class="reference internal" href="#c.pt_load_entry" title="pt_load_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_load_entry()</span></code></a>. The table_pa
is the table at pts-&gt;level - 1. This is done by cmpxchg so pts must have the
current entry loaded. The pts is updated with the installed entry.</p>
<p>This must not be called if <a class="reference internal" href="#c.pt_can_have_table" title="pt_can_have_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_can_have_table()</span></code></a> == false.</p>
<p><strong>Return</strong></p>
<p>true if the table was installed successfully.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_item_oa">
<span class="n"><span class="pre">pt_oaddr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_item_oa</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_item_oa" title="Link to this definition">¶</a><br /></dt>
<dd><p>Output Address for this leaf item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Item to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the output address for this item. If the item is part of a contiguous
entry it returns the value of the OA for this individual sub item.</p>
<p>See <a class="reference internal" href="#c.pt_entry_oa" title="pt_entry_oa"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_entry_oa()</span></code></a>. The format should implement one of these two functions
depending on how it stores the OA's in the table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_load_entry_raw">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">pt_entry_type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_load_entry_raw</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_load_entry_raw" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read from the location pts points at into the pts</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Table index to load</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the type of entry that was loaded. pts-&gt;entry will be filled in with
the entry's content. See <a class="reference internal" href="#c.pt_load_entry" title="pt_load_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_load_entry()</span></code></a></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_max_oa_lg2">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_max_oa_lg2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_max_oa_lg2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the maximum OA the table format can hold</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Page table to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The value oalog2_to_max_int(<a class="reference internal" href="#c.pt_max_oa_lg2" title="pt_max_oa_lg2"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_max_oa_lg2()</span></code></a>) is the MAX for the
OA. This is the absolute maximum address the table can hold. <a class="reference internal" href="#c.pt_common" title="pt_common"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span></code></a>
max_oasz_lg2 sets a lower dynamic maximum based on HW capability.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_num_items_lg2">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_num_items_lg2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_num_items_lg2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the number of items in this table level</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>The current level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The number of items in a table level defines the number of bits this level
decodes from the VA. This function is not called for the top level,
so it does not need to compute a special value for the top case. The
result for the top is based on pt_common max_vasz_lg2.</p>
<p>The value is used as part of determining the table indexes via the
equation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>log2_mod(log2_div(VA, pt_table_item_lg2sz()), pt_num_items_lg2())
</pre></div>
</div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_pgsz_lg2_to_level">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_pgsz_lg2_to_level</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">pgsize_lg2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_pgsz_lg2_to_level" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the level that maps the page size</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Page table to query</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pgsize_lg2</span></code></dt><dd><p>Log2 page size</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the table level that will map the given page size. The page
size must be part of the <a class="reference internal" href="#c.pt_possible_sizes" title="pt_possible_sizes"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_possible_sizes()</span></code></a> for some level.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_possible_sizes">
<span class="n"><span class="pre">pt_vaddr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_possible_sizes</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_possible_sizes" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a bitmap of possible output sizes at this level</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>The current level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each level has a list of possible output sizes that can be installed as
leaf entries. If <a class="reference internal" href="#c.pt_can_have_leaf" title="pt_can_have_leaf"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_can_have_leaf()</span></code></a> is false returns zero.</p>
<p>Otherwise the bit in position <a class="reference internal" href="#c.pt_table_item_lg2sz" title="pt_table_item_lg2sz"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_table_item_lg2sz()</span></code></a> should be set indicating
that a non-contiguous single item leaf entry is supported. The following
<a class="reference internal" href="#c.pt_num_items_lg2" title="pt_num_items_lg2"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_num_items_lg2()</span></code></a> number of bits can be set indicating contiguous entries
are supported. Bit <a class="reference internal" href="#c.pt_table_item_lg2sz" title="pt_table_item_lg2sz"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_table_item_lg2sz()</span></code></a> + <a class="reference internal" href="#c.pt_num_items_lg2" title="pt_num_items_lg2"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_num_items_lg2()</span></code></a> must not be
set, contiguous entries cannot span the entire table.</p>
<p>The OR of <a class="reference internal" href="#c.pt_possible_sizes" title="pt_possible_sizes"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_possible_sizes()</span></code></a> of all levels is the typical bitmask of all
supported sizes in the entire table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_table_item_lg2sz">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_table_item_lg2sz</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_table_item_lg2sz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Size of a single item entry in this table level</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>The current level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The size of the item specifies how much VA and OA a single item occupies.</p>
<p>See <a class="reference internal" href="#c.pt_entry_oa_lg2sz" title="pt_entry_oa_lg2sz"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_entry_oa_lg2sz()</span></code></a> for the same value including the effect of contiguous
entries.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_table_oa_lg2sz">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_table_oa_lg2sz</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_table_oa_lg2sz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the VA/OA size of the entire table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>The current level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the size of VA decoded by the entire table level.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_table_pa">
<span class="n"><span class="pre">pt_oaddr_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_table_pa</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_table_pa" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the CPU physical address of the table entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is only ever called on PT_ENTRY_TABLE entries. Must return the same
value passed to <a class="reference internal" href="#c.pt_install_table" title="pt_install_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_install_table()</span></code></a>.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_table_ptr">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_table_p</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">pt_table_ptr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_table_ptr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a CPU pointer for a table item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to query</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.pt_table_pa" title="pt_table_pa"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_table_pa()</span></code></a> but returns a CPU pointer.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_max_sw_bit">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_max_sw_bit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_max_sw_bit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the maximum software bit usable for any level and entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Page table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The swbit can be passed as bitnr to the other sw_bit functions.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_test_sw_bit_acquire">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_test_sw_bit_acquire</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bitnr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_test_sw_bit_acquire" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read a software bit in an item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to read</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bitnr</span></code></dt><dd><p>Bit to read</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Software bits are ignored by HW and can be used for any purpose by the
software. This does a test bit and acquire operation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_set_sw_bit_release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_set_sw_bit_release</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bitnr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_set_sw_bit_release" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set a software bit in an item</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Entry to set</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bitnr</span></code></dt><dd><p>Bit to set</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Software bits are ignored by HW and can be used for any purpose by the
software. This does a set bit and release operation.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_load_entry">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_load_entry</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_load_entry" title="Link to this definition">¶</a><br /></dt>
<dd><p>Read from the location pts points at into the pts</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Table index to load</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the type of entry that was loaded. pts-&gt;entry and pts-&gt;table_lower
will be filled in with the entry's content.</p>
</div>
</section>
<section id="iteration-helpers">
<h3>Iteration Helpers<a class="headerlink" href="#iteration-helpers" title="Link to this heading">¶</a></h3>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_check_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_check_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_check_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Validate the range can be iterated</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_range</span> <span class="pre">*range</span></code></dt><dd><p>Range to validate</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that VA and last_va fall within the permitted range of VAs. If the
format is using PT_FEAT_SIGN_EXTEND then this also checks the sign extension
is correct.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_index_to_va">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_index_to_va</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_index_to_va" title="Link to this definition">¶</a><br /></dt>
<dd><p>Update range-&gt;va to the current pts-&gt;index</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Iteration State</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adjust range-&gt;va to match the current index. This is done in a lazy manner
since computing the VA takes several instructions and is rarely required.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_entry_fully_covered">
<span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_entry_fully_covered</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">oasz_lg2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_entry_fully_covered" title="Link to this definition">¶</a><br /></dt>
<dd><p>Check if the item or entry is entirely contained within pts-&gt;range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Iteration State</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">oasz_lg2</span></code></dt><dd><p>The size of the item to check, <a class="reference internal" href="#c.pt_table_item_lg2sz" title="pt_table_item_lg2sz"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_table_item_lg2sz()</span></code></a> or
<a class="reference internal" href="#c.pt_entry_oa_lg2sz" title="pt_entry_oa_lg2sz"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_entry_oa_lg2sz()</span></code></a></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the item is fully enclosed by the pts-&gt;range.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_range_to_index">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_range_to_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_range_to_index" title="Link to this definition">¶</a><br /></dt>
<dd><p>Starting index for an iteration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Iteration State</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the starting index for the iteration in pts.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_range_to_end_index">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_range_to_end_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_range_to_end_index" title="Link to this definition">¶</a><br /></dt>
<dd><p>Ending index iteration</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Iteration State</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the last index for the iteration in pts.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_next_entry">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_next_entry</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_next_entry" title="Link to this definition">¶</a><br /></dt>
<dd><p>Advance pts to the next entry</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Iteration State</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update pts to go to the next index at this level. If pts is pointing at a
contiguous entry then the index may advance my more than one.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.for_each_pt_level_entry">
<span class="sig-name descname"><span class="n"><span class="pre">for_each_pt_level_entry</span></span></span><a class="headerlink" href="#c.for_each_pt_level_entry" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">for_each_pt_level_entry</span> <span class="pre">(pts)</span></code></p>
<blockquote>
<div><p>For loop wrapper over entries in the range</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pts</span></code></dt><dd><p>Iteration State</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the basic iteration primitive. It iterates over all the entries in
pts-&gt;range that fall within the pts's current table level. Each step does
pt_load_entry(pts).</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_load_single_entry">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="n"><span class="pre">pt_entry_type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_load_single_entry</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_load_single_entry" title="Link to this definition">¶</a><br /></dt>
<dd><p>Version of <a class="reference internal" href="#c.pt_load_entry" title="pt_load_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_load_entry()</span></code></a> usable within a walker</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Iteration State</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Alternative to <a class="reference internal" href="#c.for_each_pt_level_entry" title="for_each_pt_level_entry"><code class="xref c c-func docutils literal notranslate"><span class="pre">for_each_pt_level_entry()</span></code></a> if the walker function uses only a
single entry.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_top_range">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_top_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_top_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a range that spans part of the top level</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For PT_FEAT_SIGN_EXTEND this will return the lower range, and cover half the
total page table. Otherwise it returns the entire page table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_all_range">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_all_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_all_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a range that spans the entire page table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The returned range spans the whole page table. Due to how PT_FEAT_SIGN_EXTEND
is supported range-&gt;va and range-&gt;last_va will be incorrect during the
iteration and must not be accessed.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_upper_range">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_upper_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_upper_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a range that spans part of the top level</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Table</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For PT_FEAT_SIGN_EXTEND this will return the upper range, and cover half the
total page table. Otherwise it returns the entire page table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_make_range">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_make_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span>, <span class="n"><span class="pre">pt_vaddr_t</span></span><span class="w"> </span><span class="n"><span class="pre">va</span></span>, <span class="n"><span class="pre">pt_vaddr_t</span></span><span class="w"> </span><span class="n"><span class="pre">last_va</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_make_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a range that spans part of the table</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_vaddr_t</span> <span class="pre">va</span></code></dt><dd><p>Start address</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_vaddr_t</span> <span class="pre">last_va</span></code></dt><dd><p>Last address</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must validate the range with <a class="reference internal" href="#c.pt_check_range" title="pt_check_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_check_range()</span></code></a> before using it.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_init">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_init</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">range</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">level</span></span>, <span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_table_p</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">table</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a pt_state on the stack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_range</span> <span class="pre">*range</span></code></dt><dd><p>Range pointer to embed in the state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">level</span></code></dt><dd><p>Table level for the state</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_table_p</span> <span class="pre">*table</span></code></dt><dd><p>Pointer to the table memory at level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to initialize the on-stack pt_state from walker arguments.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_init_top">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_init_top</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">range</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_init_top" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a pt_state on the stack</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_range</span> <span class="pre">*range</span></code></dt><dd><p>Range pointer to embed in the state</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The pt_state points to the top most level.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_descend">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_descend</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span>, <span class="n"><span class="pre">pt_level_fn_t</span></span><span class="w"> </span><span class="n"><span class="pre">fn</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_descend" title="Link to this definition">¶</a><br /></dt>
<dd><p>Recursively invoke the walker for the lower level</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Iteration State</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>Value to pass to the function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_level_fn_t</span> <span class="pre">fn</span></code></dt><dd><p>Walker function to call</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>pts must point to a table item. Invoke fn as a walker on the table
pts points to.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_walk_range">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_walk_range</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">range</span></span>, <span class="n"><span class="pre">pt_level_fn_t</span></span><span class="w"> </span><span class="n"><span class="pre">fn</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_walk_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Walk over a VA range</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_range</span> <span class="pre">*range</span></code></dt><dd><p>Range pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_level_fn_t</span> <span class="pre">fn</span></code></dt><dd><p>Walker function to call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code></dt><dd><p>Value to pass to the function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk over a VA range. The caller should have done a validity check, at
least calling <a class="reference internal" href="#c.pt_check_range" title="pt_check_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">pt_check_range()</span></code></a>, when building range. The walk will
start at the top most table.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_range_slice">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_range</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_range_slice</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">pt_state</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">start_index</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">end_index</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_range_slice" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a range that spans indexes</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pt_state</span> <span class="pre">*pts</span></code></dt><dd><p>Iteration State</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">start_index</span></code></dt><dd><p>Starting index within pts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">end_index</span></code></dt><dd><p>Ending index within pts</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a range than spans an index range of the current table level
pt_state points at.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_top_memsize_lg2">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_top_memsize_lg2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.pt_common" title="pt_common"><span class="n"><span class="pre">pt_common</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">common</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">top_of_table</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_top_memsize_lg2" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pt_common</span> <span class="pre">*common</span></code></dt><dd><p>Table</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uintptr_t</span> <span class="pre">top_of_table</span></code></dt><dd><p>Top of table value from <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_pt_top_set()</span></code></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compute the allocation size of the top table. For PT_FEAT_DYNAMIC_TOP this
will compute the top size assuming the table will grow.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.pt_compute_best_pgsize">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pt_compute_best_pgsize</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">pt_vaddr_t</span></span><span class="w"> </span><span class="n"><span class="pre">pgsz_bitmap</span></span>, <span class="n"><span class="pre">pt_vaddr_t</span></span><span class="w"> </span><span class="n"><span class="pre">va</span></span>, <span class="n"><span class="pre">pt_vaddr_t</span></span><span class="w"> </span><span class="n"><span class="pre">last_va</span></span>, <span class="n"><span class="pre">pt_oaddr_t</span></span><span class="w"> </span><span class="n"><span class="pre">oa</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.pt_compute_best_pgsize" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determine the best page size for leaf entries</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pt_vaddr_t</span> <span class="pre">pgsz_bitmap</span></code></dt><dd><p>Permitted page sizes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_vaddr_t</span> <span class="pre">va</span></code></dt><dd><p>Starting virtual address for the leaf entry</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_vaddr_t</span> <span class="pre">last_va</span></code></dt><dd><p>Last virtual address for the leaf entry, sets the max page size</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">pt_oaddr_t</span> <span class="pre">oa</span></code></dt><dd><p>Starting output address for the leaf entry</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compute the largest page size for va, last_va, and oa together and return it
in lg2. The largest page size depends on the format's supported page sizes at
this level, and the relative alignment of the VA and OA addresses. 0 means
the OA cannot be stored with the provided pgsz_bitmap.</p>
</div>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PT_MAKE_LEVELS">
<span class="sig-name descname"><span class="n"><span class="pre">PT_MAKE_LEVELS</span></span></span><a class="headerlink" href="#c.PT_MAKE_LEVELS" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">PT_MAKE_LEVELS</span> <span class="pre">(fn,</span> <span class="pre">do_fn)</span></code></p>
<blockquote>
<div><p>Build an unwound walker</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fn</span></code></dt><dd><p>Name of the walker function</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">do_fn</span></code></dt><dd><p>Function to call at each level</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This builds a function call tree that can be fully inlined.
The caller must provide a function body in an __always_inline function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static __always_inline int do_fn(struct pt_range *range, void *arg,
       unsigned int level, struct pt_table_p *table,
       pt_level_fn_t descend_fn)
</pre></div>
</div>
<p>An inline function will be created for each table level that calls do_fn with
a compile time constant for level and a pointer to the next lower function.
This generates an optimally inlined walk where each of the functions sees a
constant level and can codegen the exact constants/etc for that level.</p>
<p>Note this can produce a lot of code!</p>
</div>
</section>
<section id="writing-a-format">
<h3>Writing a Format<a class="headerlink" href="#writing-a-format" title="Link to this heading">¶</a></h3>
<p>It is best to start from a simple format that is similar to the target. x86_64
is usually a good reference for something simple, and AMDv1 is something fairly
complete.</p>
<p>The required inline functions need to be implemented in the format header.
These should all follow the standard pattern of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>static inline pt_oaddr_t amdv1pt_entry_oa(const struct pt_state *pts)
{
       [..]
}
#define pt_entry_oa amdv1pt_entry_oa
</pre></div>
</div>
<p>where a uniquely named per-format inline function provides the implementation
and a define maps it to the generic name. This is intended to make debug symbols
work better. inline functions should always be used as the prototypes in
pt_common.h will cause the compiler to validate the function signature to
prevent errors.</p>
<p>Review pt_fmt_defaults.h to understand some of the optional inlines.</p>
<p>Once the format compiles then it should be run through the generic page table
kunit test in kunit_generic_pt.h using kunit. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ tools/testing/kunit/kunit.py run --build_dir build_kunit_x86_64 --arch x86_64 --kunitconfig ./drivers/iommu/generic_pt/.kunitconfig amdv1_fmt_test.*
[...]
[11:15:08] Testing complete. Ran 9 tests: passed: 9
[11:15:09] Elapsed time: 3.137s total, 0.001s configuring, 2.368s building, 0.311s running
</pre></div>
</div>
<p>The generic tests are intended to prove out the format functions and give
clearer failures to speed up finding the problems. Once those pass then the
entire kunit suite should be run.</p>
</section>
<section id="iommu-invalidation-features">
<h3>IOMMU Invalidation Features<a class="headerlink" href="#iommu-invalidation-features" title="Link to this heading">¶</a></h3>
<p>Invalidation is how the page table algorithms synchronize with a HW cache of the
page table memory, typically called the TLB (or IOTLB for IOMMU cases).</p>
<p>The TLB can store present PTEs, non-present PTEs and table pointers, depending
on its design. Every HW has its own approach on how to describe what has changed
to have changed items removed from the TLB.</p>
<section id="pt-feat-flush-range">
<h4>PT_FEAT_FLUSH_RANGE<a class="headerlink" href="#pt-feat-flush-range" title="Link to this heading">¶</a></h4>
<p>PT_FEAT_FLUSH_RANGE is the easiest scheme to understand. It tries to generate a
single range invalidation for each operation, over-invalidating if there are
gaps of VA that don't need invalidation. This trades off impacted VA for number
of invalidation operations. It does not keep track of what is being invalidated;
however, if pages have to be freed then page table pointers have to be cleaned
from the walk cache. The range can start/end at any page boundary.</p>
</section>
<section id="pt-feat-flush-range-no-gaps">
<h4>PT_FEAT_FLUSH_RANGE_NO_GAPS<a class="headerlink" href="#pt-feat-flush-range-no-gaps" title="Link to this heading">¶</a></h4>
<p>PT_FEAT_FLUSH_RANGE_NO_GAPS is similar to PT_FEAT_FLUSH_RANGE; however, it tries
to minimize the amount of impacted VA by issuing extra flush operations. This is
useful if the cost of processing VA is very high, for instance because a
hypervisor is processing the page table with a shadowing algorithm.</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/driver-api/generic_pt.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>