# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/allocation-profiling.rst:5
msgid "MEMORY ALLOCATION PROFILING"
msgstr ""

#: ../../../mm/allocation-profiling.rst:7
msgid ""
"Low overhead (suitable for production) accounting of all memory allocations, "
"tracked by file and line number."
msgstr ""

#: ../../../mm/allocation-profiling.rst:10
msgid "Usage: kconfig options: - CONFIG_MEM_ALLOC_PROFILING"
msgstr ""

#: ../../../mm/allocation-profiling.rst:14
msgid "CONFIG_MEM_ALLOC_PROFILING_ENABLED_BY_DEFAULT"
msgstr ""

#: ../../../mm/allocation-profiling.rst:16
msgid ""
"CONFIG_MEM_ALLOC_PROFILING_DEBUG adds warnings for allocations that weren't "
"accounted because of a missing annotation"
msgstr ""

#: ../../../mm/allocation-profiling.rst:20
msgid "Boot parameter:"
msgstr ""

#: ../../../mm/allocation-profiling.rst:21
msgid "sysctl.vm.mem_profiling={0|1|never}[,compressed]"
msgstr ""

#: ../../../mm/allocation-profiling.rst:23
msgid ""
"When set to \"never\", memory allocation profiling overhead is minimized and "
"it cannot be enabled at runtime (sysctl becomes read-only). When "
"CONFIG_MEM_ALLOC_PROFILING_ENABLED_BY_DEFAULT=y, default value is \"1\". "
"When CONFIG_MEM_ALLOC_PROFILING_ENABLED_BY_DEFAULT=n, default value is "
"\"never\". \"compressed\" optional parameter will try to store page tag "
"references in a compact format, avoiding page extensions. This results in "
"improved performance and memory consumption, however it might fail depending "
"on system configuration. If compression fails, a warning is issued and "
"memory allocation profiling gets disabled."
msgstr ""

#: ../../../mm/allocation-profiling.rst:33
msgid "sysctl:"
msgstr ""

#: ../../../mm/allocation-profiling.rst:34
msgid "/proc/sys/vm/mem_profiling"
msgstr ""

#: ../../../mm/allocation-profiling.rst:36
msgid "Runtime info:"
msgstr ""

#: ../../../mm/allocation-profiling.rst:37
msgid "/proc/allocinfo"
msgstr ""

#: ../../../mm/allocation-profiling.rst:39
msgid "Example output::"
msgstr ""

#: ../../../mm/allocation-profiling.rst:55
msgid "Theory of operation"
msgstr ""

#: ../../../mm/allocation-profiling.rst:57
msgid ""
"Memory allocation profiling builds off of code tagging, which is a library "
"for declaring static structs (that typically describe a file and line number "
"in some way, hence code tagging) and then finding and operating on them at "
"runtime, - i.e. iterating over them to print them in debugfs/procfs."
msgstr ""

#: ../../../mm/allocation-profiling.rst:62
msgid ""
"To add accounting for an allocation call, we replace it with a macro "
"invocation, alloc_hooks(), that - declares a code tag - stashes a pointer to "
"it in task_struct - calls the real allocation function - and finally, "
"restores the task_struct alloc tag pointer to its previous value."
msgstr ""

#: ../../../mm/allocation-profiling.rst:69
msgid ""
"This allows for alloc_hooks() calls to be nested, with the most recent one "
"taking effect. This is important for allocations internal to the mm/ code "
"that do not properly belong to the outer allocation context and should be "
"counted separately: for example, slab object extension vectors, or when the "
"slab allocates pages from the page allocator."
msgstr ""

#: ../../../mm/allocation-profiling.rst:75
msgid ""
"Thus, proper usage requires determining which function in an allocation call "
"stack should be tagged. There are many helper functions that essentially "
"wrap e.g. kmalloc() and do a little more work, then are called in multiple "
"places; we'll generally want the accounting to happen in the callers of "
"these helpers, not in the helpers themselves."
msgstr ""

#: ../../../mm/allocation-profiling.rst:81
msgid ""
"To fix up a given helper, for example foo(), do the following: - switch its "
"allocation call to the _noprof() version, e.g. kmalloc_noprof()"
msgstr ""

#: ../../../mm/allocation-profiling.rst:84
msgid "rename it to foo_noprof()"
msgstr ""

#: ../../../mm/allocation-profiling.rst:86
msgid "define a macro version of foo() like so:"
msgstr ""

#: ../../../mm/allocation-profiling.rst:88
msgid "#define foo(...) alloc_hooks(foo_noprof(__VA_ARGS__))"
msgstr ""

#: ../../../mm/allocation-profiling.rst:90
msgid ""
"It's also possible to stash a pointer to an alloc tag in your own data "
"structures."
msgstr ""

#: ../../../mm/allocation-profiling.rst:92
msgid ""
"Do this when you're implementing a generic data structure that does "
"allocations \"on behalf of\" some other code - for example, the rhashtable "
"code. This way, instead of seeing a large line in /proc/allocinfo for "
"rhashtable.c, we can break it out by rhashtable type."
msgstr ""

#: ../../../mm/allocation-profiling.rst:97
msgid ""
"To do so: - Hook your data structure's init function, like any other "
"allocation function."
msgstr ""

#: ../../../mm/allocation-profiling.rst:100
msgid ""
"Within your init function, use the convenience macro alloc_tag_record() to "
"record alloc tag in your data structure."
msgstr ""

#: ../../../mm/allocation-profiling.rst:103
msgid ""
"Then, use the following form for your allocations: alloc_hooks_tag(ht-"
">your_saved_tag, kmalloc_noprof(...))"
msgstr ""
