# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/edac.rst:2
msgid "Error Detection And Correction (EDAC) Devices"
msgstr ""

#: ../../../driver-api/edac.rst:5
msgid "Main Concepts used at the EDAC subsystem"
msgstr ""

#: ../../../driver-api/edac.rst:7
msgid ""
"There are several things to be aware of that aren't at all obvious, like "
"*sockets, *socket sets*, *banks*, *rows*, *chip-select rows*, *channels*, "
"etc..."
msgstr ""

#: ../../../driver-api/edac.rst:11
msgid ""
"These are some of the many terms that are thrown about that don't always "
"mean what people think they mean (Inconceivable!).  In the interest of "
"creating a common ground for discussion, terms and their definitions will be "
"established."
msgstr ""

#: ../../../driver-api/edac.rst:16
msgid "Memory devices"
msgstr ""

#: ../../../driver-api/edac.rst:18
msgid ""
"The individual DRAM chips on a memory stick.  These devices commonly output "
"4 and 8 bits each (x4, x8). Grouping several of these in parallel provides "
"the number of bits that the memory controller expects: typically 72 bits, in "
"order to provide 64 bits + 8 bits of ECC data."
msgstr ""

#: ../../../driver-api/edac.rst:23
msgid "Memory Stick"
msgstr ""

#: ../../../driver-api/edac.rst:25
msgid ""
"A printed circuit board that aggregates multiple memory devices in "
"parallel.  In general, this is the Field Replaceable Unit (FRU) which gets "
"replaced, in the case of excessive errors. Most often it is also called DIMM "
"(Dual Inline Memory Module)."
msgstr ""

#: ../../../driver-api/edac.rst:30
msgid "Memory Socket"
msgstr ""

#: ../../../driver-api/edac.rst:32
msgid ""
"A physical connector on the motherboard that accepts a single memory stick. "
"Also called as \"slot\" on several datasheets."
msgstr ""

#: ../../../driver-api/edac.rst:35
msgid "Channel"
msgstr ""

#: ../../../driver-api/edac.rst:37
msgid ""
"A memory controller channel, responsible to communicate with a group of "
"DIMMs. Each channel has its own independent control (command) and data bus, "
"and can be used independently or grouped with other channels."
msgstr ""

#: ../../../driver-api/edac.rst:41
msgid "Branch"
msgstr ""

#: ../../../driver-api/edac.rst:43
msgid ""
"It is typically the highest hierarchy on a Fully-Buffered DIMM memory "
"controller. Typically, it contains two channels. Two channels at the same "
"branch can be used in single mode or in lockstep mode. When lockstep is "
"enabled, the cacheline is doubled, but it generally brings some performance "
"penalty. Also, it is generally not possible to point to just one memory "
"stick when an error occurs, as the error correction code is calculated using "
"two DIMMs instead of one. Due to that, it is capable of correcting more "
"errors than on single mode."
msgstr ""

#: ../../../driver-api/edac.rst:52
msgid "Single-channel"
msgstr ""

#: ../../../driver-api/edac.rst:54
msgid ""
"The data accessed by the memory controller is contained into one dimm only. "
"E. g. if the data is 64 bits-wide, the data flows to the CPU using one 64 "
"bits parallel access. Typically used with SDR, DDR, DDR2 and DDR3 memories. "
"FB-DIMM and RAMBUS use a different concept for channel, so this concept "
"doesn't apply there."
msgstr ""

#: ../../../driver-api/edac.rst:60
msgid "Double-channel"
msgstr ""

#: ../../../driver-api/edac.rst:62
msgid ""
"The data size accessed by the memory controller is interlaced into two "
"dimms, accessed at the same time. E. g. if the DIMM is 64 bits-wide (72 bits "
"with ECC), the data flows to the CPU using a 128 bits parallel access."
msgstr ""

#: ../../../driver-api/edac.rst:67
msgid "Chip-select row"
msgstr ""

#: ../../../driver-api/edac.rst:69
msgid ""
"This is the name of the DRAM signal used to select the DRAM ranks to be "
"accessed. Common chip-select rows for single channel are 64 bits, for dual "
"channel 128 bits. It may not be visible by the memory controller, as some "
"DIMM types have a memory buffer that can hide direct access to it from the "
"Memory Controller."
msgstr ""

#: ../../../driver-api/edac.rst:75
msgid "Single-Ranked stick"
msgstr ""

#: ../../../driver-api/edac.rst:77
msgid ""
"A Single-ranked stick has 1 chip-select row of memory. Motherboards commonly "
"drive two chip-select pins to a memory stick. A single-ranked stick, will "
"occupy only one of those rows. The other will be unused."
msgstr ""

#: ../../../driver-api/edac.rst:83
msgid "Double-Ranked stick"
msgstr ""

#: ../../../driver-api/edac.rst:85
msgid ""
"A double-ranked stick has two chip-select rows which access different sets "
"of memory devices.  The two rows cannot be accessed concurrently."
msgstr ""

#: ../../../driver-api/edac.rst:88
msgid "Double-sided stick"
msgstr ""

#: ../../../driver-api/edac.rst:90
msgid "**DEPRECATED TERM**, see :ref:`Double-Ranked stick <doubleranked>`."
msgstr ""

#: ../../../driver-api/edac.rst:92
msgid ""
"A double-sided stick has two chip-select rows which access different sets of "
"memory devices. The two rows cannot be accessed concurrently. \"Double-"
"sided\" is irrespective of the memory devices being mounted on both sides of "
"the memory stick."
msgstr ""

#: ../../../driver-api/edac.rst:97
msgid "Socket set"
msgstr ""

#: ../../../driver-api/edac.rst:99
msgid ""
"All of the memory sticks that are required for a single memory access or all "
"of the memory sticks spanned by a chip-select row.  A single socket set has "
"two chip-select rows and if double-sided sticks are used these will occupy "
"those chip-select rows."
msgstr ""

#: ../../../driver-api/edac.rst:104
msgid "Bank"
msgstr ""

#: ../../../driver-api/edac.rst:106
msgid ""
"This term is avoided because it is unclear when needing to distinguish "
"between chip-select rows and socket sets."
msgstr ""

#: ../../../driver-api/edac.rst:109
msgid "High Bandwidth Memory (HBM)"
msgstr ""

#: ../../../driver-api/edac.rst:111
msgid ""
"HBM is a new memory type with low power consumption and ultra-wide "
"communication lanes. It uses vertically stacked memory chips (DRAM dies) "
"interconnected by microscopic wires called \"through-silicon vias,\" or TSVs."
msgstr ""

#: ../../../driver-api/edac.rst:116
msgid ""
"Several stacks of HBM chips connect to the CPU or GPU through an ultra-fast "
"interconnect called the \"interposer\". Therefore, HBM's characteristics are "
"nearly indistinguishable from on-chip integrated RAM."
msgstr ""

#: ../../../driver-api/edac.rst:121
msgid "Memory Controllers"
msgstr ""

#: ../../../driver-api/edac.rst:123
msgid ""
"Most of the EDAC core is focused on doing Memory Controller error detection. "
"The :c:func:`edac_mc_alloc`. It uses internally the struct ``mem_ctl_info`` "
"to describe the memory controllers, with is an opaque struct for the EDAC "
"drivers. Only the EDAC core is allowed to touch it."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:60
msgid "describe the type of memory DRAM chips used at the stick"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:64
#: include/linux/edac.h:97 include/linux/edac.h:143 include/linux/edac.h:260
#: include/linux/edac.h:296 include/linux/edac.h:340
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:66
msgid "``DEV_UNKNOWN``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:67
msgid "Can't be determined, or MC doesn't support detect it"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:69
msgid "``DEV_X1``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:70
msgid "1 bit for data"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:72
msgid "``DEV_X2``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:73
msgid "2 bits for data"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:75
msgid "``DEV_X4``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:76
msgid "4 bits for data"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:78
msgid "``DEV_X8``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:79
msgid "8 bits for data"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:81
msgid "``DEV_X16``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:82
msgid "16 bits for data"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:84
msgid "``DEV_X32``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:85
msgid "32 bits for data"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:87
msgid "``DEV_X64``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:88
msgid "64 bits for data"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:90
#: include/linux/edac.h:359 include/linux/edac.h:415 include/linux/edac.h:630
#: include/linux/edac.h:809 ../../../driver-api/edac:130:
#: drivers/edac/edac_mc.h:106 drivers/edac/edac_mc.h:173
#: drivers/edac/edac_mc.h:217 ../../../driver-api/edac:139:
#: drivers/edac/edac_pci.h:163 drivers/edac/edac_pci.h:177
#: drivers/edac/edac_pci.h:215 drivers/edac/edac_pci.h:232
#: drivers/edac/edac_pci.h:248 drivers/edac/edac_pci.h:256
#: drivers/edac/edac_pci.h:264
msgid "**Description**"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:69
msgid "Typical values are x4 and x8."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:93
msgid "type of the detected error"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:99
msgid "``HW_EVENT_ERR_CORRECTED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:100
msgid "Corrected Error - Indicates that an ECC corrected error was detected"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:103
msgid "``HW_EVENT_ERR_UNCORRECTED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:104
msgid ""
"Uncorrected Error - Indicates an error that can't be corrected by ECC, but "
"it is not fatal (maybe it is on an unused memory area, or the memory "
"controller could recover from it for example, by re-trying the operation)."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:110
msgid "``HW_EVENT_ERR_DEFERRED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:111
msgid ""
"Deferred Error - Indicates an uncorrectable error whose handling is not "
"urgent. This could be due to hardware data poisoning where the system can "
"continue operation until the poisoned data is consumed. Preemptive measures "
"may also be taken, e.g. offlining pages, etc."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:118
msgid "``HW_EVENT_ERR_FATAL``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:119
msgid "Fatal Error - Uncorrected error that could not be recovered."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:122
msgid "``HW_EVENT_ERR_INFO``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:123
msgid ""
"Informational - The CPER spec defines a forth type of error: informational "
"logs."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:139
msgid ""
"memory types. For a more detailed reference, please see http://en.wikipedia."
"org/wiki/DRAM"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:145
msgid "``MEM_EMPTY``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:146
msgid "Empty csrow"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:148
msgid "``MEM_RESERVED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:149
msgid "Reserved csrow type"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:151
msgid "``MEM_UNKNOWN``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:152
msgid "Unknown csrow type"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:154
msgid "``MEM_FPM``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:155
msgid "FPM - Fast Page Mode, used on systems up to 1995."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:157
msgid "``MEM_EDO``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:158
msgid "EDO - Extended data out, used on systems up to 1998."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:160
msgid "``MEM_BEDO``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:161
msgid "BEDO - Burst Extended data out, an EDO variant."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:163
msgid "``MEM_SDR``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:164
msgid ""
"SDR - Single data rate SDRAM http://en.wikipedia.org/wiki/"
"Synchronous_dynamic_random-access_memory They use 3 pins for chip select: "
"Pins 0 and 2 are for rank 0; pins 1 and 3 are for rank 1, if the memory is "
"dual-rank."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:170
msgid "``MEM_RDR``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:171
msgid "Registered SDR SDRAM"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:173
msgid "``MEM_DDR``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:174
msgid "Double data rate SDRAM http://en.wikipedia.org/wiki/DDR_SDRAM"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:177
msgid "``MEM_RDDR``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:178
msgid ""
"Registered Double data rate SDRAM This is a variant of the DDR memories. A "
"registered memory has a buffer inside it, hiding part of the memory details "
"to the memory controller."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:183
msgid "``MEM_RMBS``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:184
msgid "Rambus DRAM, used on a few Pentium III/IV controllers."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:186
msgid "``MEM_DDR2``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:187
msgid ""
"DDR2 RAM, as described at JEDEC JESD79-2F. Those memories are labeled as "
"\"PC2-\" instead of \"PC\" to differentiate from DDR."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:191
msgid "``MEM_FB_DDR2``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:192
msgid ""
"Fully-Buffered DDR2, as described at JEDEC Std No. 205 and JESD206. Those "
"memories are accessed per DIMM slot, and not by a chip select signal."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:197
msgid "``MEM_RDDR2``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:198
msgid "Registered DDR2 RAM This is a variant of the DDR2 memories."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:201
msgid "``MEM_XDR``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:202
msgid ""
"Rambus XDR It is an evolution of the original RAMBUS memories, created to "
"compete with DDR2. Weren't used on any x86 arch, but cell_edac PPC memory "
"controller uses it."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:207
msgid "``MEM_DDR3``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:208
msgid "DDR3 RAM"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:210
msgid "``MEM_RDDR3``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:211
msgid "Registered DDR3 RAM This is a variant of the DDR3 memories."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:214
msgid "``MEM_LRDDR3``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:215
msgid "Load-Reduced DDR3 memory."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:217
msgid "``MEM_LPDDR3``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:218
msgid "Low-Power DDR3 memory."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:220
msgid "``MEM_DDR4``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:221
msgid "Unbuffered DDR4 RAM"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:223
msgid "``MEM_RDDR4``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:224
msgid "Registered DDR4 RAM This is a variant of the DDR4 memories."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:227
msgid "``MEM_LRDDR4``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:228
msgid "Load-Reduced DDR4 memory."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:230
msgid "``MEM_LPDDR4``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:231
msgid "Low-Power DDR4 memory."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:233
msgid "``MEM_DDR5``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:234
msgid "Unbuffered DDR5 RAM"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:236
msgid "``MEM_RDDR5``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:237
msgid "Registered DDR5 RAM"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:239
msgid "``MEM_LRDDR5``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:240
msgid "Load-Reduced DDR5 memory."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:242
msgid "``MEM_NVDIMM``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:243
msgid "Non-volatile RAM"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:245
msgid "``MEM_WIO2``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:246
msgid "Wide I/O 2."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:248
msgid "``MEM_HBM2``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:249
msgid "High bandwidth Memory Gen 2."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:251
msgid "``MEM_HBM3``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:252
msgid "High bandwidth Memory Gen 3."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:256
msgid "Error Detection and Correction capabilities and mode"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:262
msgid "``EDAC_UNKNOWN``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:263
msgid "Unknown if ECC is available"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:265
msgid "``EDAC_NONE``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:266
msgid "Doesn't support ECC"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:268
msgid "``EDAC_RESERVED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:269
msgid "Reserved ECC type"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:271
msgid "``EDAC_PARITY``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:272
msgid "Detects parity errors"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:274
msgid "``EDAC_EC``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:275
msgid "Error Checking - no correction"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:277
msgid "``EDAC_SECDED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:278
msgid "Single bit error correction, Double detection"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:280
msgid "``EDAC_S2ECD2ED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:281
msgid "Chipkill x2 devices - do these exist?"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:283
msgid "``EDAC_S4ECD4ED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:284
msgid "Chipkill x4 devices"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:286
msgid "``EDAC_S8ECD8ED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:287
msgid "Chipkill x8 devices"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:289
msgid "``EDAC_S16ECD16ED``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:290
msgid "Chipkill x16 devices"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:292
msgid "scrubbing capabilities"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:298
msgid "``SCRUB_UNKNOWN``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:299
msgid "Unknown if scrubber is available"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:301
msgid "``SCRUB_NONE``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:302
msgid "No scrubber"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:304
msgid "``SCRUB_SW_PROG``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:305
msgid "SW progressive (sequential) scrubbing"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:307
msgid "``SCRUB_SW_SRC``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:308
msgid "Software scrub only errors"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:310
msgid "``SCRUB_SW_PROG_SRC``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:311
msgid "Progressive software scrub from an error"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:313
msgid "``SCRUB_SW_TUNABLE``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:314
msgid "Software scrub frequency is tunable"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:316
msgid "``SCRUB_HW_PROG``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:317
msgid "HW progressive (sequential) scrubbing"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:319
msgid "``SCRUB_HW_SRC``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:320
msgid "Hardware scrub only errors"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:322
msgid "``SCRUB_HW_PROG_SRC``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:323
msgid "Progressive hardware scrub from an error"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:325
msgid "``SCRUB_HW_TUNABLE``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:326
msgid "Hardware scrub frequency is tunable"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:336
msgid "memory controller hierarchy layer"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:342
msgid "``EDAC_MC_LAYER_BRANCH``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:343
msgid "memory layer is named \"branch\""
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:345
msgid "``EDAC_MC_LAYER_CHANNEL``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:346
msgid "memory layer is named \"channel\""
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:348
msgid "``EDAC_MC_LAYER_SLOT``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:349
msgid "memory layer is named \"slot\""
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:351
msgid "``EDAC_MC_LAYER_CHIP_SELECT``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:352
msgid "memory layer is named \"chip select\""
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:354
msgid "``EDAC_MC_LAYER_ALL_MEM``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:355
msgid ""
"memory layout is unknown. All memory is mapped as a single memory area. This "
"is used when retrieving errors from a firmware driven driver."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:345
msgid ""
"This enum is used by the drivers to tell edac_mc_sysfs what name should be "
"used when describing a memory stick location."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:358
msgid "describes the memory controller hierarchy"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:362
#: include/linux/edac.h:412 include/linux/edac.h:465 include/linux/edac.h:680
#: include/linux/edac.h:717 include/linux/edac.h:767
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:370
#: include/linux/edac.h:421 include/linux/edac.h:483 include/linux/edac.h:695
#: include/linux/edac.h:729 include/linux/edac.h:801
msgid "**Members**"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:359
#: include/linux/edac.h:464
msgid "``type``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:360
msgid "layer type"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:360
msgid "``size``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:361
msgid ""
"number of components per layer. For example, if the channel layer has two "
"channels, size = 2"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:362
msgid "``is_virt_csrow``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:363
msgid ""
"This layer is part of the \"csrow\" when old API compatibility mode is "
"enabled. Otherwise, it is a channel"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:408
msgid "contains the information for one DIMM rank"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:410
msgid "``chan_idx``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:411
msgid "channel number where the rank is (typically, 0 or 1)"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:412
msgid "``csrow``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:413
msgid ""
"A pointer to the chip select row structure (the parent structure). The "
"location of the rank is given by the (csrow->csrow_idx, chan_idx) vector."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:415
msgid "``dimm``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:416
msgid ""
"A pointer to the DIMM structure, where the DIMM label information is stored."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:411
msgid "``ce_count``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:412
msgid "number of correctable errors for this rank"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:417
msgid "FIXME: Currently, the EDAC core model will assume one DIMM per rank."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:418
msgid ""
"This is a bad assumption, but it makes this patch easier. Later patches in "
"this series will fix this issue."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:461
msgid "Raw error report structure"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:473
msgid "``location``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:474
msgid "location of the error"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:474
msgid "``label``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:475
msgid "label of the affected DIMM(s)"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:462
msgid "``grain``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:463
msgid "minimum granularity for an error report, in bytes"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:463
msgid "``error_count``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:464
msgid "number of errors of the same type"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:465
#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:226
msgid "severity of the error (CE/UE/Fatal)"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:465
msgid "``top_layer``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:466
msgid "top layer of the error (layer[0])"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:466
msgid "``mid_layer``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:467
msgid "middle layer of the error (layer[1])"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:467
msgid "``low_layer``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:468
msgid "low layer of the error (layer[2])"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:468
msgid "``page_frame_number``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:469
msgid "page where the error happened"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:469
msgid "``offset_in_page``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:470
msgid "page offset"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:470
msgid "``syndrome``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:471
msgid ""
"syndrome of the error (or 0 if unknown or if the syndrome is not applicable)"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:472
msgid "``msg``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:473
msgid "error message"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:475
msgid "``other_detail``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:476
msgid "other driver-specific detail about the error"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:622
msgid ""
"Get DIMM info from a memory controller given by [layer0,layer1,layer2] "
"position"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:626
#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:103
#: drivers/edac/edac_mc.h:135 drivers/edac/edac_mc.h:157
#: drivers/edac/edac_mc.h:164 drivers/edac/edac_mc.h:173
#: drivers/edac/edac_mc.h:183 drivers/edac/edac_mc.h:194
#: drivers/edac/edac_mc.h:204 drivers/edac/edac_mc.h:216
#: drivers/edac/edac_mc.h:228 ../../../driver-api/edac:139:
#: drivers/edac/edac_pci.h:160 drivers/edac/edac_pci.h:176
#: drivers/edac/edac_pci.h:189 drivers/edac/edac_pci.h:198
#: drivers/edac/edac_pci.h:212 drivers/edac/edac_pci.h:227
#: drivers/edac/edac_pci.h:247 drivers/edac/edac_pci.h:255
#: drivers/edac/edac_pci.h:263 ../../../driver-api/edac:188:
#: drivers/edac/edac_device.h:252 drivers/edac/edac_device.h:265
#: drivers/edac/edac_device.h:279 drivers/edac/edac_device.h:292
#: drivers/edac/edac_device.h:305 drivers/edac/edac_device.h:320
#: drivers/edac/edac_device.h:335
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:628
#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:159
#: drivers/edac/edac_mc.h:206 drivers/edac/edac_mc.h:228
msgid "``struct mem_ctl_info *mci``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:625
msgid "MC descriptor struct mem_ctl_info"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:627
msgid "``int layer0``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:626
msgid "layer0 position"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:628
msgid "``int layer1``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:627
msgid "layer1 position. Unused if n_layers < 2"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:629
msgid "``int layer2``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:628
msgid "layer2 position. Unused if n_layers < 3"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:629
msgid "For 1 layer, this function returns \"dimms[layer0]\";"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:631
msgid ""
"For 2 layers, this function is similar to allocating a two-dimensional array "
"and returning \"dimms[layer0][layer1]\";"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:634
msgid ""
"For 3 layers, this function is similar to allocating a tri-dimensional array "
"and returning \"dimms[layer0][layer1][layer2]\";"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:676
msgid "scrub device operations (all elements optional)"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:677
msgid "``read_addr``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:678
msgid "read base address of scrubbing range."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:678
msgid "``read_size``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:679
msgid "read offset of scrubbing range."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:679
msgid "``write_addr``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:680
msgid "set base address of the scrubbing range."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:680
msgid "``write_size``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:681
msgid "set offset of the scrubbing range."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:681
msgid "``get_enabled_bg``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:682
msgid "check if currently performing background scrub."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:682
msgid "``set_enabled_bg``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:683
msgid "start or stop a bg-scrub."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:683
msgid "``get_min_cycle``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:684
msgid "get minimum supported scrub cycle duration in seconds."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:684
msgid "``get_max_cycle``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:685
msgid "get maximum supported scrub cycle duration in seconds."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:685
msgid "``get_cycle_duration``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:686
msgid "get current scrub cycle duration in seconds."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:686
msgid "``set_cycle_duration``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:687
msgid "set current scrub cycle duration in seconds."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:713
msgid "ECS device operations (all elements optional)"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:714
msgid "``get_log_entry_type``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:715
msgid "read the log entry type value."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:715
msgid "``set_log_entry_type``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:716
msgid "set the log entry type value."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:716
msgid "``get_mode``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:717
msgid "read the mode value."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:717
msgid "``set_mode``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:718
msgid "set the mode value."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:718
msgid "``reset``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:719
msgid "reset the ECS counter."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:719
msgid "``get_threshold``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:720
msgid "read the threshold count per gigabits of memory cells."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:720
msgid "``set_threshold``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:721
msgid "set the threshold count per gigabits of memory cells."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:763
msgid ""
"memory repair operations (all elements are optional except do_repair, "
"set_hpa/set_dpa)"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:765
msgid "``get_repair_type``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:766
msgid "get the memory repair type, listed in enum edac_mem_repair_function."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:767
msgid "``get_persist_mode``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:768
msgid ""
"get the current persist mode. false - Soft repair type (temporary repair). "
"true - Hard memory repair type (permanent repair)."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:770
msgid "``set_persist_mode``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:771
msgid "set the persist mode of the memory repair instance."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:771
msgid "``get_repair_safe_when_in_use``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:772
msgid ""
"get whether memory media is accessible and data is retained during repair "
"operation."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:773
msgid "``get_hpa``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:774
msgid "get current host physical address (HPA) of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:774
msgid "``set_hpa``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:775
msgid "set host physical address (HPA) of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:775
msgid "``get_min_hpa``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:776
msgid "get the minimum supported host physical address (HPA)."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:776
msgid "``get_max_hpa``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:777
msgid "get the maximum supported host physical address (HPA)."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:777
msgid "``get_dpa``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:778
msgid "get current device physical address (DPA) of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:778
msgid "``set_dpa``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:779
msgid ""
"set device physical address (DPA) of memory to repair. In some states of "
"system configuration (e.g. before address decoders have been configured), "
"memory devices (e.g. CXL) may not have an active mapping in the host "
"physical address map. As such, the memory to repair must be identified by a "
"device specific physical addressing scheme using a device physical "
"address(DPA). The DPA and other control attributes to use for the repair "
"operations will be presented in related error records."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:786
msgid "``get_min_dpa``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:787
msgid "get the minimum supported device physical address (DPA)."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:787
msgid "``get_max_dpa``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:788
msgid "get the maximum supported device physical address (DPA)."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:788
msgid "``get_nibble_mask``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:789
msgid "get current nibble mask of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:789
msgid "``set_nibble_mask``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:790
msgid "set nibble mask of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:790
msgid "``get_bank_group``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:791
msgid "get current bank group of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:791
msgid "``set_bank_group``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:792
msgid "set bank group of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:792
msgid "``get_bank``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:793
msgid "get current bank of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:793
msgid "``set_bank``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:794
msgid "set bank of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:794
msgid "``get_rank``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:795
msgid "get current rank of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:795
msgid "``set_rank``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:796
msgid "set rank of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:796
msgid "``get_row``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:797
msgid "get current row of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:797
msgid "``set_row``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:798
msgid "set row of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:798
msgid "``get_column``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:799
msgid "get current column of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:799
msgid "``set_column``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:800
msgid "set column of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:800
msgid "``get_channel``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:801
msgid "get current channel of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:801
msgid "``set_channel``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:802
msgid "set channel of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:802
msgid "``get_sub_channel``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:803
msgid "get current subchannel of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:803
msgid "``set_sub_channel``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:804
msgid "set subchannel of memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:804
msgid "``do_repair``"
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:805
msgid ""
"Issue memory repair operation for the HPA/DPA and other control attributes "
"set for the memory to repair."
msgstr ""

#: ../../../driver-api/edac:128: include/linux/edac.h:806
msgid ""
"All elements are optional except do_repair and at least one of set_hpa/"
"set_dpa."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:99
msgid "Allocate and partially fill a struct :c:type:`mem_ctl_info`."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:105
msgid "``unsigned int mc_num``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:101
msgid "Memory controller number"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:103
msgid "``unsigned int n_layers``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:102
msgid "Number of MC hierarchy layers"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:104
msgid "``struct edac_mc_layer *layers``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:103
msgid "Describes each layer as seen by the Memory Controller"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:105
#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:162
msgid "``unsigned int sz_pvt``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:104
msgid "size of private storage needed"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:105
msgid ""
"Everything is kmalloc'ed as one big chunk - more efficient. Only can be used "
"if all structures have the same lifetime - otherwise you have to allocate "
"and initialize your own structures."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:109
msgid "Use edac_mc_free() to free mc structures allocated by this function."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:113
msgid ""
"drivers handle multi-rank memories in different ways: in some drivers, one "
"multi-rank memory stick is mapped as one entry, while, in others, a single "
"multi-rank memory stick would be mapped into several entries. Currently, "
"this function will allocate multiple struct dimm_info on such scenarios, as "
"grouping the multiple ranks require drivers change."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:3
#: drivers/edac/edac_mc.h:119 drivers/edac/edac_mc.h:184
#: drivers/edac/edac_mc.h:195 drivers/edac/edac_mc.h:206
#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:3
#: drivers/edac/edac_pci.h:165 drivers/edac/edac_pci.h:202
#: drivers/edac/edac_pci.h:212 drivers/edac/edac_pci.h:233
#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:3
#: drivers/edac/edac_device.h:255 drivers/edac/edac_device.h:267
msgid "**Return**"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:121
msgid ""
"On success, return a pointer to struct mem_ctl_info pointer; ``NULL`` "
"otherwise"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:131
msgid "Return the owner's mod_name of EDAC MC"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:137
#: drivers/edac/edac_mc.h:166 ../../../driver-api/edac:139:
#: drivers/edac/edac_pci.h:191 ../../../driver-api/edac:188:
#: drivers/edac/edac_device.h:337
msgid "``void``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:1
#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:1
#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:1
msgid "no arguments"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:133
msgid "Pointer to mod_name string when EDAC MC is owned. NULL otherwise."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:153
msgid "Frees a previously allocated **mci** structure"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:155
#: drivers/edac/edac_mc.h:203
msgid "pointer to a struct mem_ctl_info structure"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:160
msgid "Check if any MCs have been allocated."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:162
msgid ""
"True if MC instances have been registered successfully. False otherwise."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:169
msgid "Search for a mem_ctl_info structure whose index is **idx**."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:175
msgid "``int idx``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:171
msgid "index to be seek"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:172
msgid "If found, return a pointer to the structure. Else return NULL."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:179
msgid ""
"Scan list of controllers looking for the one that manages the **dev** device."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:185
#: drivers/edac/edac_mc.h:196 ../../../driver-api/edac:139:
#: drivers/edac/edac_pci.h:214 drivers/edac/edac_pci.h:229
#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:267
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:182
msgid "pointer to a struct device related with the MCI"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:184
msgid ""
"on success, returns a pointer to struct :c:type:`mem_ctl_info`; ``NULL`` "
"otherwise."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:190
msgid ""
"Remove sysfs entries for mci structure associated with **dev** and remove "
"mci structure from global list."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:193
msgid ""
"Pointer to struct :c:type:`device` representing mci structure to remove."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:195
msgid "pointer to removed mci structure, or ``NULL`` if device not found."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:200
msgid "Ancillary routine to identify what csrow contains a memory page."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:205
msgid "``unsigned long page``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:204
msgid "memory page to find"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:206
msgid "on success, returns the csrow. -1 if not found."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:212
msgid ""
"Reports a memory event to userspace without doing anything to discover the "
"error location."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:218
msgid "``struct edac_raw_error_desc *e``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:215
msgid "error description"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:216
msgid ""
"This raw function is used internally by edac_mc_handle_error(). It should "
"only be called directly when the hardware error come directly from BIOS, "
"like in the case of APEI GHES driver."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:224
msgid "Reports a memory event to userspace."
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:230
msgid "``const enum hw_event_mc_err_type type``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:227
msgid "a struct mem_ctl_info pointer"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:229
msgid "``const u16 error_count``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:228
msgid "Number of errors of the same type"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:230
msgid "``const unsigned long page_frame_number``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:229
msgid "mem page where the error occurred"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:231
msgid "``const unsigned long offset_in_page``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:230
msgid "offset of the error inside the page"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:232
msgid "``const unsigned long syndrome``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:231
msgid "ECC syndrome"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:233
msgid "``const int top_layer``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:232
msgid "Memory layer[0] position"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:234
msgid "``const int mid_layer``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:233
msgid "Memory layer[1] position"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:235
msgid "``const int low_layer``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:234
msgid "Memory layer[2] position"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:236
#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:282
#: drivers/edac/edac_device.h:295 drivers/edac/edac_device.h:307
#: drivers/edac/edac_device.h:322
msgid "``const char *msg``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:235
msgid "Message meaningful to the end users that explains the event"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:238
msgid "``const char *other_detail``"
msgstr ""

#: ../../../driver-api/edac:130: drivers/edac/edac_mc.h:237
msgid ""
"Technical details about the event that may help hardware manufacturers and "
"EDAC developers to analyse the event"
msgstr ""

#: ../../../driver-api/edac.rst:133
msgid "PCI Controllers"
msgstr ""

#: ../../../driver-api/edac.rst:135
msgid ""
"The EDAC subsystem provides a mechanism to handle PCI controllers by calling "
"the :c:func:`edac_pci_alloc_ctl_info`. It will use the struct :c:type:"
"`edac_pci_ctl_info` to describe the PCI controllers."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:156
msgid "The alloc() function for the 'edac_pci' control info structure."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:160
msgid "size of the private info at struct :c:type:`edac_pci_ctl_info`"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:162
msgid "``const char *edac_pci_name``"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:161
#: drivers/edac/edac_pci.h:230
msgid "name of the PCI device"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:162
msgid ""
"The chip driver will allocate one of these for each edac_pci it is going to "
"control/register with the EDAC CORE."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:166
msgid ""
"a pointer to struct :c:type:`edac_pci_ctl_info` on success; ``NULL`` "
"otherwise."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:172
msgid "Last action on the pci control structure."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:178
#: drivers/edac/edac_pci.h:200 drivers/edac/edac_pci.h:249
#: drivers/edac/edac_pci.h:257 drivers/edac/edac_pci.h:265
msgid "``struct edac_pci_ctl_info *pci``"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:175
#: drivers/edac/edac_pci.h:246 drivers/edac/edac_pci.h:254
#: drivers/edac/edac_pci.h:262
msgid "pointer to struct :c:type:`edac_pci_ctl_info`"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:176
msgid ""
"Calls the remove sysfs information, which will unregister this control "
"struct's kobj. When that kobj's ref count goes to zero, its release function "
"will be call and then kfree() the memory."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:185
msgid "Allocate a unique PCI index number"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:187
#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:333
msgid "allocated index number"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:194
msgid ""
"Insert the 'edac_dev' structure into the edac_pci global list and create "
"sysfs entries associated with edac_pci structure."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:198
msgid "pointer to the edac_device structure to be added to the list"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:200
msgid "``int edac_idx``"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:199
msgid "A unique numeric identifier to be assigned to the 'edac_pci' structure."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:202
#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:255
msgid "0 on Success, or an error code on failure"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:212
msgid "Pointer to 'struct device' representing edac_pci structure to remove"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:209
msgid ""
"Remove sysfs entries for specified edac_pci structure and then remove "
"edac_pci structure from global list"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:216
msgid "Pointer to removed edac_pci structure, or ``NULL`` if device not found"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:229
msgid "pointer to struct :c:type:`device`;"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:231
msgid "``const char *mod_name``"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:224
msgid ""
"A generic constructor for a PCI parity polling device Some systems have more "
"than one domain of PCI busses. For systems with one domain, then this API "
"will provide for a generic poller."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:230
msgid ""
"This routine calls the edac_pci_alloc_ctl_info() for the generic device, "
"with default values"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:235
msgid ""
"Pointer to struct :c:type:`edac_pci_ctl_info` on success, ``NULL`` on "
"failure."
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:244
msgid "The release function of a generic EDAC PCI polling device"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:252
msgid "Create the controls/attributes for the specified EDAC PCI device"
msgstr ""

#: ../../../driver-api/edac:139: drivers/edac/edac_pci.h:260
msgid "remove the controls and attributes for this EDAC PCI device"
msgstr ""

#: ../../../driver-api/edac.rst:142
msgid "EDAC Blocks"
msgstr ""

#: ../../../driver-api/edac.rst:144
msgid ""
"The EDAC subsystem also provides a generic mechanism to report errors on "
"other parts of the hardware via :c:func:`edac_device_alloc_ctl_info` "
"function."
msgstr ""

#: ../../../driver-api/edac.rst:147
msgid ""
"The structures :c:type:`edac_dev_sysfs_block_attribute`, :c:type:"
"`edac_device_block`, :c:type:`edac_device_instance` and :c:type:"
"`edac_device_ctl_info` provide a generic or abstract 'edac_device' "
"representation at sysfs."
msgstr ""

#: ../../../driver-api/edac.rst:152
msgid ""
"This set of structures and the code that implements the APIs for the same, "
"provide for registering EDAC type devices which are NOT standard memory or "
"PCI, like:"
msgstr ""

#: ../../../driver-api/edac.rst:155
msgid "CPU caches (L1 and L2)"
msgstr ""

#: ../../../driver-api/edac.rst:156
msgid "DMA engines"
msgstr ""

#: ../../../driver-api/edac.rst:157
msgid "Core CPU switches"
msgstr ""

#: ../../../driver-api/edac.rst:158
msgid "Fabric switch units"
msgstr ""

#: ../../../driver-api/edac.rst:159
msgid "PCIe interface controllers"
msgstr ""

#: ../../../driver-api/edac.rst:160
msgid "other EDAC/ECC type devices that can be monitored for errors, etc."
msgstr ""

#: ../../../driver-api/edac.rst:163
msgid "It allows for a 2 level set of hierarchy."
msgstr ""

#: ../../../driver-api/edac.rst:165
msgid ""
"For example, a cache could be composed of L1, L2 and L3 levels of cache. "
"Each CPU core would have its own L1 cache, while sharing L2 and maybe L3 "
"caches. On such case, those can be represented via the following sysfs "
"nodes::"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:248
msgid ""
"Insert the 'edac_dev' structure into the edac_device global list and create "
"sysfs entries associated with edac_device structure."
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:254
#: drivers/edac/edac_device.h:281 drivers/edac/edac_device.h:294
#: drivers/edac/edac_device.h:307 drivers/edac/edac_device.h:322
msgid "``struct edac_device_ctl_info *edac_dev``"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:252
msgid ""
"pointer to edac_device structure to be added to the list 'edac_device' "
"structure."
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:261
msgid ""
"Remove sysfs entries for specified edac_device structure and then remove "
"edac_device structure from global list"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:264
msgid ""
"Pointer to struct :c:type:`device` representing the edac device structure to "
"remove."
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:268
msgid ""
"Pointer to removed edac_device structure, or ``NULL`` if device not found."
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:275
msgid "Log correctable errors."
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:277
#: drivers/edac/edac_device.h:290 drivers/edac/edac_device.h:303
#: drivers/edac/edac_device.h:318
msgid "pointer to struct :c:type:`edac_device_ctl_info`"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:279
#: drivers/edac/edac_device.h:292
msgid "``unsigned int count``"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:279
#: drivers/edac/edac_device.h:292
msgid "Number of errors to log."
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:281
#: drivers/edac/edac_device.h:294 drivers/edac/edac_device.h:305
#: drivers/edac/edac_device.h:320
msgid "``int inst_nr``"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:278
#: drivers/edac/edac_device.h:291 drivers/edac/edac_device.h:304
msgid "number of the instance where the CE error happened"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:280
#: drivers/edac/edac_device.h:293 drivers/edac/edac_device.h:306
#: drivers/edac/edac_device.h:321
msgid "``int block_nr``"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:280
#: drivers/edac/edac_device.h:293 drivers/edac/edac_device.h:305
msgid "number of the block where the CE error happened"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:281
#: drivers/edac/edac_device.h:294 drivers/edac/edac_device.h:306
#: drivers/edac/edac_device.h:321
msgid "message to be printed"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:288
msgid "Log uncorrectable errors."
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:301
msgid "Log a single correctable error"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:316
msgid "Log a single uncorrectable error"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:319
msgid "number of the instance where the UE error happened"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:320
msgid "number of the block where the UE error happened"
msgstr ""

#: ../../../driver-api/edac:188: drivers/edac/edac_device.h:331
msgid "Allocate a unique device index number"
msgstr ""

#: ../../../driver-api/edac.rst:192
msgid "Heterogeneous system support"
msgstr ""

#: ../../../driver-api/edac.rst:194
msgid ""
"An AMD heterogeneous system is built by connecting the data fabrics of both "
"CPUs and GPUs via custom xGMI links. Thus, the data fabric on the GPU nodes "
"can be accessed the same way as the data fabric on CPU nodes."
msgstr ""

#: ../../../driver-api/edac.rst:198
msgid ""
"The MI200 accelerators are data center GPUs. They have 2 data fabrics, and "
"each GPU data fabric contains four Unified Memory Controllers (UMC). Each "
"UMC contains eight channels. Each UMC channel controls one 128-bit HBM2e "
"(2GB) channel (equivalent to 8 X 2GB ranks).  This creates a total of 4096-"
"bits of DRAM data bus."
msgstr ""

#: ../../../driver-api/edac.rst:204
msgid ""
"While the UMC is interfacing a 16GB (8high X 2GB DRAM) HBM stack, each UMC "
"channel is interfacing 2GB of DRAM (represented as rank)."
msgstr ""

#: ../../../driver-api/edac.rst:207
msgid "Memory controllers on AMD GPU nodes can be represented in EDAC thusly:"
msgstr ""

#: ../../../driver-api/edac.rst:209
msgid ""
"GPU DF / GPU Node -> EDAC MC GPU UMC           -> EDAC CSROW GPU UMC "
"channel   -> EDAC CHANNEL"
msgstr ""

#: ../../../driver-api/edac.rst:213
msgid ""
"For example: a heterogeneous system with 1 AMD CPU is connected to 4 MI200 "
"(Aldebaran) GPUs using xGMI."
msgstr ""

#: ../../../driver-api/edac.rst:216
msgid "Some more heterogeneous hardware details:"
msgstr ""

#: ../../../driver-api/edac.rst:218
msgid ""
"The CPU UMC (Unified Memory Controller) is mostly the same as the GPU UMC. "
"They have chip selects (csrows) and channels. However, the layouts are "
"different for performance, physical layout, or other reasons."
msgstr ""

#: ../../../driver-api/edac.rst:221
msgid ""
"CPU UMCs use 1 channel, In this case UMC = EDAC channel. This follows the "
"marketing speak. CPU has X memory channels, etc."
msgstr ""

#: ../../../driver-api/edac.rst:223
msgid "CPU UMCs use up to 4 chip selects, So UMC chip select = EDAC CSROW."
msgstr ""

#: ../../../driver-api/edac.rst:224
msgid "GPU UMCs use 1 chip select, So UMC = EDAC CSROW."
msgstr ""

#: ../../../driver-api/edac.rst:225
msgid "GPU UMCs use 8 channels, So UMC channel = EDAC channel."
msgstr ""

#: ../../../driver-api/edac.rst:227
msgid ""
"The EDAC subsystem provides a mechanism to handle AMD heterogeneous systems "
"by calling system specific ops for both CPUs and GPUs."
msgstr ""

#: ../../../driver-api/edac.rst:230
msgid ""
"AMD GPU nodes are enumerated in sequential order based on the PCI hierarchy, "
"and the first GPU node is assumed to have a Node ID value following those of "
"the CPU nodes after latter are fully populated::"
msgstr ""

#: ../../../driver-api/edac.rst:245
msgid ""
"For example, a heterogeneous system with one AMD CPU is connected to four "
"MI200 (Aldebaran) GPUs using xGMI. This topology can be represented via the "
"following sysfs entries::"
msgstr ""
