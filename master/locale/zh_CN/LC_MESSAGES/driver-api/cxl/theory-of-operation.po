# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/cxl/theory-of-operation.rst:6
msgid "Compute Express Link Driver Theory of Operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:8
msgid ""
"A Compute Express Link Memory Device is a CXL component that implements the "
"CXL.mem protocol. It contains some amount of volatile memory, persistent "
"memory, or both. It is enumerated as a PCI device for configuration and "
"passing messages over an MMIO mailbox. Its contribution to the System "
"Physical Address space is handled via HDM (Host Managed Device Memory) "
"decoders that optionally define a device's contribution to an interleaved "
"address range across multiple devices underneath a host-bridge or "
"interleaved across host-bridges."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:18
msgid "The CXL Bus"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:19
msgid ""
"Similar to how a RAID driver takes disk objects and assembles them into a "
"new logical device, the CXL subsystem is tasked to take PCIe and ACPI "
"objects and assemble them into a CXL.mem decode topology. The need for "
"runtime configuration of the CXL.mem topology is also similar to RAID in "
"that different environments with the same hardware configuration may decide "
"to assemble the topology in contrasting ways. One may choose performance "
"(RAID0) striping memory across multiple Host Bridges and endpoints while "
"another may opt for fault tolerance and disable any striping in the CXL.mem "
"topology."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:28
msgid ""
"Platform firmware enumerates a menu of interleave options at the \"CXL root "
"port\" (Linux term for the top of the CXL decode topology). From there, PCIe "
"topology dictates which endpoints can participate in which Host Bridge "
"decode regimes. Each PCIe Switch in the path between the root and an "
"endpoint introduces a point at which the interleave can be split. For "
"example, platform firmware may say a given range only decodes to one Host "
"Bridge, but that Host Bridge may in turn interleave cycles across multiple "
"Root Ports. An intervening Switch between a port and an endpoint may "
"interleave cycles across multiple Downstream Switch Ports, etc."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:38
msgid ""
"Here is a sample listing of a CXL topology defined by 'cxl_test'. The "
"'cxl_test' module generates an emulated CXL topology of 2 Host Bridges each "
"with 2 Root Ports. Each of those Root Ports are connected to 2-way switches "
"with endpoints connected to those downstream ports for a total of 8 "
"endpoints::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:183
msgid ""
"In that listing each \"root\", \"port\", and \"endpoint\" object correspond "
"a kernel 'struct cxl_port' object. A 'cxl_port' is a device that can decode "
"CXL.mem to its descendants. So \"root\" claims non-PCIe enumerable platform "
"decode ranges and decodes them to \"ports\", \"ports\" decode to "
"\"endpoints\", and \"endpoints\" represent the decode from SPA (System "
"Physical Address) to DPA (Device Physical Address)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:190
msgid ""
"Continuing the RAID analogy, disks have both topology metadata and on-device "
"metadata that determine RAID set assembly. CXL Port topology and CXL Port "
"link status is metadata for CXL.mem set assembly. The CXL Port topology is "
"enumerated by the arrival of a CXL.mem device. I.e. unless and until the "
"PCIe core attaches the cxl_pci driver to a CXL Memory Expander there is no "
"role for CXL Port objects. Conversely for hot-unplug / removal scenarios, "
"there is no need for the Linux PCI core to tear down switch-level CXL "
"resources because the endpoint ->remove() event cleans up the port data that "
"was established to support that Memory Expander."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:200
msgid ""
"The port metadata and potential decode schemes that a given memory device "
"may participate can be determined via a command like::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:249
msgid ""
"...which queries the CXL topology to ask \"given CXL Memory Expander with a "
"kernel device name of 'mem3' which platform level decode ranges may this "
"device participate\". A given expander can participate in multiple CXL.mem "
"interleave sets simultaneously depending on how many decoder resources it "
"has. In this example mem3 can participate in one or more of a PMEM "
"interleave that spans two Host Bridges, a PMEM interleave that targets a "
"single Host Bridge, a Volatile memory interleave that spans 2 Host Bridges, "
"and a Volatile memory interleave that only targets a single Host Bridge."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:258
msgid ""
"Conversely the memory devices that can participate in a given platform level "
"decode scheme can be determined via a command like the following::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:312
msgid ""
"...where the naming scheme for decoders is \"decoder<port_id>."
"<instance_id>\"."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:315
msgid "Driver Infrastructure"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:317
msgid "This section covers the driver infrastructure for a CXL memory device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:320
msgid "CXL Memory Device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: drivers/cxl/pci.c:21
msgid ""
"This implements the PCI exclusive functionality for a CXL device as it is "
"defined by the Compute Express Link specification. CXL devices may surface "
"certain functionality even if it isn't CXL enabled. While this driver is "
"focused around the PCI specific aspects of a CXL device, it binds to the "
"specific CXL memory device class code, and therefore the implementation of "
"cxl_pci is focused around CXL memory devices."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: drivers/cxl/pci.c:28
msgid "The driver has several responsibilities, mainly:"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: drivers/cxl/pci.c:29
msgid "Create the memX device and register on the CXL bus."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: drivers/cxl/pci.c:30
msgid "Enumerate device's register interface and map them."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: drivers/cxl/pci.c:31
msgid "Registers nvdimm bridge device with cxl_core."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: drivers/cxl/pci.c:32
msgid "Registers a CXL mailbox with cxl_core."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:177
msgid "Execute a mailbox command"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:181
#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:591 drivers/cxl/core/memdev.c:611
#: drivers/cxl/core/memdev.c:744 drivers/cxl/core/memdev.c:778
#: drivers/cxl/core/memdev.c:811
#: ../../../driver-api/cxl/theory-of-operation:436: drivers/cxl/acpi.c:816
#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:141
#: drivers/cxl/core/hdm.c:299 drivers/cxl/core/hdm.c:1161
#: drivers/cxl/core/hdm.c:1223 drivers/cxl/core/hdm.c:1255
#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:547
#: drivers/cxl/core/cdat.c:615 drivers/cxl/core/cdat.c:743
#: drivers/cxl/core/cdat.c:860 drivers/cxl/core/cdat.c:904
#: drivers/cxl/core/cdat.c:954 drivers/cxl/core/cdat.c:976
#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:927
#: drivers/cxl/core/port.c:1223 drivers/cxl/core/port.c:1254
#: drivers/cxl/core/port.c:1300 drivers/cxl/core/port.c:1909
#: drivers/cxl/core/port.c:1962 drivers/cxl/core/port.c:2016
#: drivers/cxl/core/port.c:2053 drivers/cxl/core/port.c:2086
#: drivers/cxl/core/port.c:2139 drivers/cxl/core/port.c:2181
#: drivers/cxl/core/port.c:2324
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:48
#: drivers/cxl/core/pci.c:122 drivers/cxl/core/pci.c:443
#: drivers/cxl/core/pci.c:642 drivers/cxl/core/pci.c:854
#: drivers/cxl/core/pci.c:1045 ../../../driver-api/cxl/theory-of-operation:463:
#: drivers/cxl/core/pmem.c:59 drivers/cxl/core/pmem.c:123
#: drivers/cxl/core/pmem.c:243 ../../../driver-api/cxl/theory-of-operation:469:
#: drivers/cxl/core/regs.c:32 drivers/cxl/core/regs.c:116
#: drivers/cxl/core/regs.c:352 drivers/cxl/core/regs.c:372
#: drivers/cxl/core/regs.c:390 ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:232 drivers/cxl/core/mbox.c:315
#: drivers/cxl/core/mbox.c:482 drivers/cxl/core/mbox.c:571
#: drivers/cxl/core/mbox.c:744 drivers/cxl/core/mbox.c:832
#: drivers/cxl/core/mbox.c:1114 drivers/cxl/core/mbox.c:1140
#: drivers/cxl/core/mbox.c:1176 drivers/cxl/core/mbox.c:1275
#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:879 drivers/cxl/core/region.c:1067
#: drivers/cxl/core/region.c:1834 drivers/cxl/core/region.c:2532
#: drivers/cxl/core/region.c:3260
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:183
#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:234
#: drivers/cxl/core/mbox.c:481 drivers/cxl/core/mbox.c:573
msgid "``struct cxl_mailbox *cxl_mbox``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:178
#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:428
#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:229
#: drivers/cxl/core/mbox.c:480
msgid "CXL mailbox context"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:180
#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:231
#: drivers/cxl/core/mbox.c:484 drivers/cxl/core/mbox.c:570
msgid "``struct cxl_mbox_cmd *mbox_cmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:179
msgid "Command to send to the memory device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:181
#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2090 drivers/cxl/core/port.c:2140
#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:232
msgid "**Context**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:181
msgid "Any context. Expects mbox_mutex to be held."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:183
#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:747 drivers/cxl/core/memdev.c:782
#: drivers/cxl/core/memdev.c:814
#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:618
#: drivers/cxl/core/cdat.c:745 drivers/cxl/core/cdat.c:860
#: drivers/cxl/core/cdat.c:904 ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1962 drivers/cxl/core/port.c:2016
#: drivers/cxl/core/port.c:2052 drivers/cxl/core/port.c:2094
#: drivers/cxl/core/port.c:2325
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:1044
#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:123
#: drivers/cxl/core/pmem.c:243 ../../../driver-api/cxl/theory-of-operation:469:
#: drivers/cxl/core/regs.c:355 drivers/cxl/core/regs.c:373
#: drivers/cxl/core/regs.c:391 ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:234 drivers/cxl/core/mbox.c:315
#: drivers/cxl/core/mbox.c:483 drivers/cxl/core/mbox.c:575
#: drivers/cxl/core/mbox.c:1145 drivers/cxl/core/mbox.c:1175
#: drivers/cxl/core/mbox.c:1275
#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1840 drivers/cxl/core/region.c:2536
#: drivers/cxl/core/region.c:3259
msgid "**Return**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:182
msgid ""
"-ETIMEDOUT if timeout occurred waiting for completion. 0 on success. Caller "
"should check the return code in **mbox_cmd** to make sure it succeeded."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:186
#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:261
#: drivers/cxl/cxlmem.h:432 drivers/cxl/cxlmem.h:491 drivers/cxl/cxlmem.h:796
#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:591 drivers/cxl/core/memdev.c:743
#: drivers/cxl/core/memdev.c:778 drivers/cxl/core/memdev.c:810
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:415
#: drivers/cxl/cxl.h:489 ../../../driver-api/cxl/theory-of-operation:436:
#: drivers/cxl/acpi.c:815 ../../../driver-api/cxl/theory-of-operation:442:
#: drivers/cxl/core/hdm.c:301 drivers/cxl/core/hdm.c:1222
#: drivers/cxl/core/hdm.c:1254 ../../../driver-api/cxl/theory-of-operation:445:
#: drivers/cxl/core/cdat.c:620 drivers/cxl/core/cdat.c:748
#: drivers/cxl/core/cdat.c:976 ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1225 drivers/cxl/core/port.c:1256
#: drivers/cxl/core/port.c:1300 drivers/cxl/core/port.c:1909
#: drivers/cxl/core/port.c:2085 drivers/cxl/core/port.c:2138
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:48
#: drivers/cxl/core/pci.c:121 drivers/cxl/core/pci.c:444
#: drivers/cxl/core/pci.c:641 drivers/cxl/core/pci.c:1046
#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:33
#: drivers/cxl/core/regs.c:117 drivers/cxl/core/regs.c:357
#: drivers/cxl/core/regs.c:375 drivers/cxl/core/regs.c:390
#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:240
#: drivers/cxl/core/mbox.c:318 drivers/cxl/core/mbox.c:490
#: drivers/cxl/core/mbox.c:583 drivers/cxl/core/mbox.c:745
#: drivers/cxl/core/mbox.c:831 drivers/cxl/core/mbox.c:1114
#: drivers/cxl/core/mbox.c:1139 drivers/cxl/core/mbox.c:1177
#: drivers/cxl/core/mbox.c:1282
#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:880 drivers/cxl/core/region.c:1069
#: drivers/cxl/core/region.c:1833 drivers/cxl/core/region.c:2534
#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:123 include/uapi/linux/cxl_mem.h:156
#: include/uapi/linux/cxl_mem.h:205
msgid "**Description**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:185
msgid ""
"This is a generic form of the CXL mailbox send command thus only using the "
"registers defined by the mailbox capability ID - CXL 2.0 8.2.8.4. Memory "
"devices, and perhaps other types of CXL devices may have further information "
"available upon error conditions. Driver facilities wishing to send mailbox "
"commands should use the wrapper command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: drivers/cxl/pci.c:191
msgid ""
"The CXL spec allows for up to two mailboxes. The intention is for the "
"primary mailbox to be OS controlled and the secondary mailbox to be used by "
"system firmware. This allows the OS and firmware to communicate with the "
"device and not need to coordinate with each other. The driver only uses the "
"primary mailbox."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:414: drivers/cxl/mem.c:12
msgid ""
"CXL memory endpoint devices and switches are CXL capable devices that are "
"participating in CXL.mem protocol. Their functionality builds on top of the "
"CXL.io protocol that allows enumerating and configuring components via "
"standard PCI mechanisms."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:414: drivers/cxl/mem.c:17
msgid ""
"The cxl_mem driver owns kicking off the enumeration of this CXL.mem "
"capability. With the detection of a CXL capable endpoint, the driver will "
"walk up to find the platform specific port it is connected to, and determine "
"if there are intervening switches in the path. If there are switches, a "
"secondary action is to enumerate those (implemented in cxl_core). Finally "
"the cxl_mem driver adds the device it is bound to as a CXL endpoint-port for "
"use in higher level operations."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:38
msgid "CXL bus object representing a Type-3 Memory Device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:42
#: drivers/cxl/cxlmem.h:221 drivers/cxl/cxlmem.h:256 drivers/cxl/cxlmem.h:337
#: drivers/cxl/cxlmem.h:354 drivers/cxl/cxlmem.h:387 drivers/cxl/cxlmem.h:401
#: drivers/cxl/cxlmem.h:413 drivers/cxl/cxlmem.h:471 drivers/cxl/cxlmem.h:793
#: drivers/cxl/cxlmem.h:915 ../../../driver-api/cxl/theory-of-operation:433:
#: drivers/cxl/cxl.h:276 drivers/cxl/cxl.h:355 drivers/cxl/cxl.h:394
#: drivers/cxl/cxl.h:412 drivers/cxl/cxl.h:431 drivers/cxl/cxl.h:441
#: drivers/cxl/cxl.h:481 drivers/cxl/cxl.h:525 drivers/cxl/cxl.h:593
#: drivers/cxl/cxl.h:642 drivers/cxl/cxl.h:676 drivers/cxl/cxl.h:702
#: drivers/cxl/cxl.h:715 drivers/cxl/cxl.h:814
#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:106 include/uapi/linux/cxl_mem.h:150
#: include/uapi/linux/cxl_mem.h:186
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:59
#: drivers/cxl/cxlmem.h:228 drivers/cxl/cxlmem.h:265 drivers/cxl/cxlmem.h:347
#: drivers/cxl/cxlmem.h:365 drivers/cxl/cxlmem.h:396 drivers/cxl/cxlmem.h:409
#: drivers/cxl/cxlmem.h:434 drivers/cxl/cxlmem.h:490 drivers/cxl/cxlmem.h:802
#: drivers/cxl/cxlmem.h:926 ../../../driver-api/cxl/theory-of-operation:433:
#: drivers/cxl/cxl.h:291 drivers/cxl/cxl.h:371 drivers/cxl/cxl.h:405
#: drivers/cxl/cxl.h:420 drivers/cxl/cxl.h:438 drivers/cxl/cxl.h:454
#: drivers/cxl/cxl.h:494 drivers/cxl/cxl.h:541 drivers/cxl/cxl.h:620
#: drivers/cxl/cxl.h:649 drivers/cxl/cxl.h:691 drivers/cxl/cxl.h:710
#: drivers/cxl/cxl.h:727 drivers/cxl/cxl.h:823
#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:118 include/uapi/linux/cxl_mem.h:158
#: include/uapi/linux/cxl_mem.h:211
msgid "**Members**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:39
#: drivers/cxl/cxlmem.h:415 ../../../driver-api/cxl/theory-of-operation:433:
#: drivers/cxl/cxl.h:352 drivers/cxl/cxl.h:522 drivers/cxl/cxl.h:592
msgid "``dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:40
msgid "driver core device object"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:40
msgid "``cdev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:41
msgid "char dev core object for ioctl operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:41
#: drivers/cxl/cxlmem.h:473
msgid "``cxlds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:42
msgid "The device state backing this device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:42
msgid "``detach_work``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:43
msgid "active memdev lost a port in its ancestry"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:43
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:526
msgid "``cxl_nvb``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:44
msgid "coordinate removal of **cxl_nvd** if present"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:44
msgid "``cxl_nvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:45
msgid "optional bridge to an nvdimm if the device supports pmem"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:45
msgid "``endpoint``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:46
msgid "connection to the CXL port topology for this memory device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:46
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:353
#: drivers/cxl/cxl.h:523 drivers/cxl/cxl.h:595
#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:103 include/uapi/linux/cxl_mem.h:183
msgid "``id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:47
msgid "id number of this memdev instance."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:47
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:606
msgid "``depth``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:48
msgid "endpoint port depth"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:48
msgid "``scrub_cycle``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:49
msgid "current scrub cycle set for this device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:49
msgid "``scrub_region_id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:50
msgid "id number of a backed region (if any) for which current scrub cycle set"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:50
msgid "``err_rec_array``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:51
msgid ""
"List of xarrarys to store the memdev error records to check attributes for a "
"memory repair operation are from current boot."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:217
msgid "Event log driver state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:219
msgid "``buf``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:220
msgid "Buffer to receive event data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:220
msgid "``log_lock``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:221
msgid "Serialize event_buf and log use"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:252
msgid "Driver poison state info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:254
msgid "``max_errors``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:255
msgid "Maximum media error records held in device cache"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:255
#: drivers/cxl/cxlmem.h:353
msgid "``enabled_cmds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:256
msgid "All poison commands enabled in the CEL"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:256
msgid "``list_out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:257
msgid "The poison list payload returned by device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:257
msgid "``mutex``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:258
msgid "Protect reads of the poison list"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:258
msgid ""
"Reads of the poison list are synchronized to ensure that a reader does not "
"get an incomplete list because their request overlapped (was interrupted or "
"preceded by) another read request of the same DPA range. CXL Spec 3.0 "
"Section 8.2.9.8.4.1"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:333
msgid "Firmware upload / activation state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:335
#: drivers/cxl/cxlmem.h:352 ../../../driver-api/cxl/theory-of-operation:433:
#: drivers/cxl/cxl.h:394 drivers/cxl/cxl.h:478
msgid "``state``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:336
msgid "fw_uploader state bitmask"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:336
msgid "``oneshot``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:337
msgid "whether the fw upload fits in a single transfer"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:337
msgid "``num_slots``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:338
msgid "Number of FW slots available"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:338
msgid "``cur_slot``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:339
msgid "Slot number currently active"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:339
msgid "``next_slot``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:340
msgid "Slot number for the new firmware"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:350
msgid "Device security state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:353
msgid "state of last security operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:354
msgid "All security commands enabled in the CEL"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:354
msgid "``poll_tmo_secs``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:355
msgid "polling timeout"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:355
msgid "``sanitize_active``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:356
msgid "sanitize completion pending"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:356
msgid "``poll_dwork``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:357
msgid "polling work item"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:357
msgid "``sanitize_node``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:358
msgid "sanitation sysfs file to notify"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:383
msgid "DPA performance property entry"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:384
msgid "``dpa_range``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:385
msgid "range for DPA address"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:385
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:530
#: drivers/cxl/cxl.h:680
msgid "``coord``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:386
msgid "QoS performance data (i.e. latency, bandwidth)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:386
msgid "``cdat_coord``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:387
msgid "raw QoS performance data from CDAT"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:387
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:443
msgid "``qos_class``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:388
msgid "QoS Class cookies"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:397
msgid "DPA partition descriptor"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:398
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:438
#: drivers/cxl/cxl.h:482
msgid "``res``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:399
msgid "shortcut to the partition in the DPA resource tree (cxlds->dpa_res)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:399
msgid "``perf``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:400
msgid "performance attributes of the partition from CDAT"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:400
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:524
msgid "``mode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:401
msgid "operation mode for the DPA capacity, e.g. ram, pmem, dynamic..."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:409
msgid "The driver device state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:416
msgid "The device associated with this CXL state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:416
msgid "``cxlmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:417
msgid "The device representing the CXL.mem capabilities of **dev**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:417
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:601
#: drivers/cxl/cxl.h:674
msgid "``reg_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:418
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:602
#: drivers/cxl/cxl.h:675
msgid "component and ras register mapping parameters"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:418
#: drivers/cxl/cxlmem.h:912 ../../../driver-api/cxl/theory-of-operation:433:
#: drivers/cxl/cxl.h:679
msgid "``regs``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:419
msgid "Parsed register blocks"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:419
msgid "``cxl_dvsec``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:420
msgid "Offset to the PCIe device DVSEC"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:420
msgid "``rcd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:421
msgid "operating in RCD mode (CXL 3.0 9.11.8 CXL Devices Attached to an RCH)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:421
msgid "``media_ready``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:422
msgid "Indicate whether the device media is usable"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:422
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:392
msgid "``dpa_res``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:423
msgid "Overall DPA resource tree for the device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:423
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:395
msgid "``part``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:424
msgid "DPA partition array"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:424
msgid "``nr_partitions``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:425
msgid "Number of DPA partitions"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:425
msgid "``serial``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:426
msgid "PCIe Device Serial Number"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:426
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:525
msgid "``type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:427
msgid "Generic Memory Class device or Vendor Specific Memory device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:427
msgid "``cxl_mbox``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:428
msgid "``cxlfs``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:429
msgid "CXL features context"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:410
msgid ""
"cxl_dev_state represents the CXL driver/device state.  It provides an "
"interface to mailbox commands as well as some cached data about the device. "
"Currently only memory devices are represented."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:467
msgid "Generic Type-3 Memory Device Class driver data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:474
msgid "Core driver state common across Type-2 and Type-3 devices"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:474
msgid "``lsa_size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:475
msgid "Size of Label Storage Area (CXL 2.0 8.2.9.5.1.1 Identify Memory Device)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:476
msgid "``firmware_version``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:477
msgid "Firmware version for the memory device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:477
msgid "``total_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:478
msgid "sum of all possible capacities"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:478
msgid "``volatile_only_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:479
msgid "hard volatile capacity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:479
msgid "``persistent_only_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:480
msgid "hard persistent capacity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:480
msgid "``partition_align_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:481
msgid "alignment size for partition-able capacity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:481
msgid "``active_volatile_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:482
msgid "sum of hard + soft volatile"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:482
msgid "``active_persistent_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:483
msgid "sum of hard + soft persistent"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:483
msgid "``event``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:484
msgid "event log driver state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:484
msgid "``poison``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:485
msgid "poison driver state info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:485
msgid "``security``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:486
msgid "security driver state info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:486
msgid "``fw``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:487
msgid "firmware upload / activation state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:487
msgid "``mce_notifier``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:488
msgid "MCE notifier"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:468
msgid ""
"CXL 8.1.12.1 PCI Header - Class Code Register Memory Device defines common "
"memory device functionality like the presence of a mailbox and the "
"functionality related to that like Identify Memory Device and Get Partition "
"Info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:473
msgid ""
"See CXL 3.0 8.2.9.8.2 Capacity Configuration and Label Storage for details "
"on capacity parameters."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:789
msgid "Driver representation of a memory device command"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:790
msgid "``info``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:791
msgid "Command information as it exists for the UAPI"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:791
msgid "``opcode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:792
msgid "The actual bits used for the mailbox protocol"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:792
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:359
#: drivers/cxl/cxl.h:528 ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:104 include/uapi/linux/cxl_mem.h:185
msgid "``flags``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:793
msgid "Set of flags effecting driver behavior."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:793
msgid ""
"``CXL_CMD_FLAG_FORCE_ENABLE``: In cases of error, commands with this flag "
"will be enabled by the driver regardless of what hardware may have "
"advertised."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:797
msgid ""
"The cxl_mem_command is the driver's internal representation of commands that "
"are supported by the driver. Some of these commands may not be supported by "
"the hardware. The driver will use **info** to validate the fields passed in "
"by the user then submit the **opcode** to the hardware."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:802
#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:162
msgid "See struct cxl_command_info."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:911
msgid "HDM Decoder registers and cached / decoded capabilities"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:913
msgid "mapped registers, see devm_cxl_setup_hdm()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:913
msgid "``decoder_count``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:914
msgid "number of decoders for this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:914
msgid "``target_count``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:915
msgid "for switch decoders, max downstream port targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:915
msgid "``interleave_mask``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:916
msgid "interleave granularity capability, see check_interleave_cap()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:916
msgid "``iw_cap_mask``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:917
msgid "bitmask of supported interleave ways, see check_interleave_cap()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:917
#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:640
#: drivers/cxl/cxl.h:678 drivers/cxl/cxl.h:712 drivers/cxl/cxl.h:813
msgid "``port``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: drivers/cxl/cxlmem.h:918
msgid "mapped cxl_port, see devm_cxl_setup_hdm()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:587
msgid "atomically disable user cxl commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:593 drivers/cxl/core/memdev.c:613
#: drivers/cxl/core/memdev.c:746 drivers/cxl/core/memdev.c:780
#: drivers/cxl/core/memdev.c:813
#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:746
#: drivers/cxl/core/mbox.c:834 drivers/cxl/core/mbox.c:1116
#: drivers/cxl/core/mbox.c:1142 drivers/cxl/core/mbox.c:1178
msgid "``struct cxl_memdev_state *mds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:588
msgid "The device state to operate on"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:590 drivers/cxl/core/memdev.c:610
msgid "``unsigned long *cmds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:589
msgid "bitmap of commands to mark exclusive"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:590
msgid ""
"Grab the cxl_memdev_rwsem in write mode to flush in-flight invocations of "
"the ioctl path and then disable future execution of commands with the "
"command ids set in **cmds**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:607
msgid "atomically enable user cxl commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:608
msgid "The device state to modify"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:609
msgid "bitmap of commands to mark available for userspace"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:740
msgid "Get Firmware info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:741 drivers/cxl/core/memdev.c:775
#: drivers/cxl/core/memdev.c:808
msgid "The device data for the operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:742
msgid "Retrieve firmware info for the device specified."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:745
msgid "See CXL-3.0 8.2.9.3.1 Get FW Info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:745 drivers/cxl/core/memdev.c:780
#: drivers/cxl/core/memdev.c:812
#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1143
msgid "0 if no error: or the result of the mailbox command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:774
msgid "Activate Firmware"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:777
msgid "``int slot``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:776
msgid "slot number to activate"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:777
msgid "Activate firmware in a given slot for the device specified."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:780
msgid "See CXL-3.0 8.2.9.3.3 Activate FW"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:807
msgid "Abort an in-progress FW transfer"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:809
msgid "Abort an in-progress firmware transfer for the device specified."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: drivers/cxl/core/memdev.c:812
msgid "See CXL-3.0 8.2.9.3.2 Transfer FW"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:338
msgid "CXL Port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:425: drivers/cxl/port.c:11
msgid ""
"The port driver enumerates dport via PCI and scans for HDM (Host-managed-"
"Device-Memory) decoder resources via the **component_reg_phys** value passed "
"in by the agent that registered the port. All descendant ports of a CXL root "
"port (described by platform firmware) are managed in this drivers context. "
"Each driver instance is responsible for tearing down the driver context of "
"immediate descendant ports. The locking for this is validated by "
"CONFIG_PROVE_CXL_LOCKING."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:425: drivers/cxl/port.c:20
msgid ""
"The primary service this driver provides is presenting APIs to other drivers "
"to utilize the decoders, and indicating to userspace (via bind status) the "
"connectivity of the CXL.mem protocol throughout the PCIe topology."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:343
msgid "CXL Core"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:430: drivers/cxl/cxl.h:19
msgid ""
"The CXL core objects like ports, decoders, and regions are shared between "
"the subsystem drivers cxl_acpi, cxl_pci, and core drivers (port-driver, "
"region-driver, nvdimm object-drivers... etc)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:272
msgid "DVSEC harvested register block mapping parameters"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:273
msgid "``host``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:274
msgid "device for devm operations and logging"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:274
msgid "``base``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:275
msgid "virtual base of the register-block-BAR + **block_offset**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:275
msgid "``resource``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:276
msgid "physical resource base of the register block"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:276
msgid "``max_size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:277
msgid "maximum mapping size to perform register search"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:277
msgid "``reg_type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:278
msgid "see enum cxl_regloc_type"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:1
#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:2
#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:278
msgid "``component_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:279
msgid "cxl_reg_map for component registers"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:279
msgid "``device_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:280
msgid "cxl_reg_maps for device registers"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:280
msgid "``pmu_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:281
msgid "cxl_reg_maps for CXL Performance Monitoring Units"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:351
msgid "Common CXL HDM Decoder Attributes"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:353
msgid "this decoder's device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:354
msgid "kernel device name id"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:354
msgid "``hpa_range``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:355
msgid "Host physical address range mapped by this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:355
#: drivers/cxl/cxl.h:480
msgid "``interleave_ways``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:356
msgid "number of cxl_dports in this decode"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:356
#: drivers/cxl/cxl.h:481
msgid "``interleave_granularity``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:357
msgid "data stride per dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:357
msgid "``target_type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:358
msgid "accelerator vs expander (type2 vs type3) selector"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:358
#: drivers/cxl/cxl.h:714
msgid "``region``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:359
msgid "currently assigned region for this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:360
msgid "memory type capabilities and locking"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:360
msgid "``target_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:361
msgid ""
"cached copy of hardware port-id list, available at init before all **dport** "
"objects have been instantiated. While dport id is 8bit, CFMWS interleave "
"targets are 32bits."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:363
msgid "``commit``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:364
msgid "device/decoder-type specific callback to commit settings to hw"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:364
msgid "``reset``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:365
msgid "device/decoder-type specific callback to reset hw settings"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:390
msgid "Endpoint / SPA to DPA decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:391
#: drivers/cxl/cxl.h:409
msgid "``cxld``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:392
msgid "base cxl_decoder_object"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:393
msgid "actively claimed DPA span of this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:393
msgid "``skip``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:394
msgid "offset into **dpa_res** where **cxld.hpa_range** maps"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:395
msgid "autodiscovery state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:396
msgid "partition index this decoder maps"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:396
msgid "``pos``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:397
msgid "interleave position in **cxld.region**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:408
msgid "Switch specific CXL HDM Decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:410
msgid "base cxl_decoder object"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:410
#: drivers/cxl/cxl.h:484 drivers/cxl/cxl.h:718
msgid "``nr_targets``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:411
msgid "number of elements in **target**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:411
msgid "``target``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:412
msgid "active ordered target list in current decoder configuration"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:412
msgid ""
"The 'switch' decoder type represents the decoder instances of cxl_port's "
"that route from the root of a CXL memory decode topology to the endpoints. "
"They come in two flavors, root-level decoders, statically defined by "
"platform firmware, and mid-level decoders, where interleave-granularity, "
"interleave-width, and the target list are mutable."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:427
msgid "CXL root decoder callback operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:428
msgid "``hpa_to_spa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:429
msgid "Convert host physical address to system physical address"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:429
msgid "``spa_to_hpa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:430
msgid "Convert system physical address to host physical address"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:437
msgid "Static platform CXL address decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:439
msgid "host / parent resource for region allocations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:439
#: drivers/cxl/cxl.h:485
msgid "``cache_size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:440
#: drivers/cxl/cxl.h:486
msgid "extended linear cache size if exists, otherwise zero."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:440
msgid "``region_id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:441
msgid "region id for next region provisioning event"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:441
msgid "``platform_data``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:442
msgid "platform specific configuration data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:442
msgid "``range_lock``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:443
msgid "sync region autodiscovery by address range"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:444
msgid "QoS performance class cookie"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:444
#: drivers/cxl/cxl.h:641
msgid "``ops``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:445
msgid "CXL root decoder operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:445
msgid "``cxlsd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:446
msgid "base cxl switch decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:477
msgid "region settings"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:479
msgid "allow the driver to lockdown further parameter changes"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:479
msgid "``uuid``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:480
msgid "unique id for persistent regions"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:481
msgid "number of endpoints in the region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:482
msgid "capacity each endpoint contributes to a stripe"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:483
msgid "allocated iomem capacity for this region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:483
msgid "``targets``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:484
msgid "active ordered targets in current decoder configuration"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:485
msgid "number of targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:486
msgid "State transitions are protected by cxl_rwsem.region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:521
msgid "CXL region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:523
msgid "This region's device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:524
msgid "This region's id. Id is globally unique across all regions"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:525
msgid "Operational mode of the mapped capacity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:526
msgid "Endpoint decoder target type"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:527
msgid "nvdimm bridge for coordinating **cxlr_pmem** setup / shutdown"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:527
msgid "``cxlr_pmem``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:528
msgid "(for pmem regions) cached copy of the nvdimm bridge"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:529
msgid "Region state flags"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:529
msgid "``params``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:530
msgid "active + config params for the region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:531
msgid "QoS access coordinates for the region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:531
msgid "``node_notifier``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:532
msgid "notifier for setting the access coordinates to node"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:532
msgid "``adist_notifier``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:533
msgid "notifier for calculating the abstract distance of node"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:589
msgid ""
"logical collection of upstream port devices and downstream port devices to "
"construct a CXL memory decode hierarchy."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:593
msgid "this port's device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:593
msgid "``uport_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:594
msgid "PCI or platform device implementing the upstream port capability"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:594
msgid "``host_bridge``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:595
msgid "Shortcut to the platform attach point for this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:596
msgid "id for port device-name"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:596
msgid "``dports``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:597
msgid "cxl_dport instances referenced by decoders"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:597
#: drivers/cxl/cxl.h:715
msgid "``endpoints``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:598
msgid "cxl_ep instances, endpoints that are a descendant of this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:598
msgid "``regions``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:599
msgid "cxl_region_ref instances, regions mapped by this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:599
msgid "``parent_dport``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:600
msgid "dport that points to this port in the parent"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:600
msgid "``decoder_ida``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:601
msgid "allocator for decoder ids"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:602
msgid "``nr_dports``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:603
msgid "number of entries in **dports**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:603
msgid "``hdm_end``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:604
msgid "track last allocated HDM decoder instance for allocation ordering"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:604
msgid "``commit_end``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:605
msgid "cursor to track highest committed decoder for commit ordering"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:605
msgid "``dead``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:606
msgid "last ep has been removed, force port re-creation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:607
msgid "How deep this port is relative to the root. depth 0 is the root."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:607
msgid "``cdat``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:608
msgid "Cached CDAT data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:608
msgid "``cdat_available``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:609
msgid "Should a CDAT attribute be available in sysfs"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:609
msgid "``pci_latency``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:610
msgid "Upstream latency in picoseconds"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:610
msgid "``component_reg_phys``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:611
msgid "Physical address of component register"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:638
msgid "logical collection of root cxl_port items"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:641
msgid "cxl_port member"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:642
msgid "cxl root operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:672
msgid "CXL downstream port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:673
msgid "``dport_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:674
msgid "PCI bridge or firmware device representing the downstream link"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:675
msgid "``port_id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:676
msgid "unique hardware identifier for dport in decoder target list"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:676
msgid "``rcrb``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:677
msgid "Data about the Root Complex Register Block layout"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:677
msgid "``rch``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:678
msgid "Indicate whether this dport was enumerated in RCH or VH mode"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:679
msgid "reference to cxl_port that contains this downstream port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:680
msgid "Dport parsed register blocks"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:681
msgid "access coordinates (bandwidth and latency performance attributes)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:681
msgid "``link_latency``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:682
msgid "calculated PCIe downstream latency"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:682
msgid "``gpf_dvsec``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:683
msgid "Cached GPF port DVSEC"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:698
msgid "track an endpoint's interest in a port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:699
msgid "``ep``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:700
msgid "device that hosts a generic CXL endpoint (expander or accelerator)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:700
msgid "``dport``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:701
msgid "which dport routes to this endpoint on **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:701
msgid "``next``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:702
msgid ""
"cxl switch port across the link attached to **dport** NULL if attached to an "
"endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:711
msgid "track a region's interest in a port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:713
msgid "point in topology to install this reference"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:713
msgid "``decoder``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:714
msgid "decoder assigned for **region** in **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:715
msgid "region for this reference"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:716
msgid "cxl_ep references for region members beneath **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:716
msgid "``nr_targets_set``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:717
msgid "track how many targets have been programmed during setup"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:717
msgid "``nr_eps``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:718
msgid "number of endpoints beneath **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:719
msgid "number of distinct targets needed to reach **nr_eps**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:810
msgid "Cached DVSEC info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:811
msgid "``mem_enabled``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:812
msgid "cached value of mem_enabled in the DVSEC at init time"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:812
msgid "``ranges``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:813
msgid "Number of active HDM ranges this device uses."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:814
msgid "endpoint port associated with this info instance"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:814
msgid "``dvsec_range``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: drivers/cxl/cxl.h:815
msgid "cached attributes of the ranges in the DVSEC, PCIE_DEVICE"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: drivers/cxl/acpi.c:812
msgid "reflect CXL fixed memory windows in iomem_resource"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: drivers/cxl/acpi.c:818
msgid "``struct resource *cxl_res``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: drivers/cxl/acpi.c:813
msgid "A standalone resource tree where each CXL window is a sibling"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: drivers/cxl/acpi.c:814
msgid ""
"Walk each CXL window in **cxl_res** and add it to iomem_resource potentially "
"expanding its boundaries to ensure that any conflicting resources become "
"children. If a window is expanded it may then conflict with a another window "
"entry and require the window to be truncated or trimmed. Consider this "
"situation::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: drivers/cxl/acpi.c:823
msgid ""
"...where platform firmware has established as System RAM resource across 2 "
"windows, but has left some portion of window 1 for dynamic CXL region "
"provisioning. In this case \"Window 0\" will span the entirety of the "
"\"System RAM\" span, and \"CXL Window 1\" is truncated to the remaining tail "
"past the end of that \"System RAM\" resource."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:439: drivers/cxl/core/hdm.c:11
msgid ""
"Compute Express Link Host Managed Device Memory, starting with the CXL 2.0 "
"specification, is managed by an array of HDM Decoder register instances per "
"CXL port and per CXL endpoint. Define common helpers for enumerating these "
"registers and capabilities."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:137
msgid "map HDM decoder component registers"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:143
#: drivers/cxl/core/hdm.c:1225 drivers/cxl/core/hdm.c:1257
#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1225 drivers/cxl/core/port.c:1256
#: drivers/cxl/core/port.c:1911 drivers/cxl/core/port.c:1964
#: drivers/cxl/core/port.c:2018 drivers/cxl/core/port.c:2055
#: drivers/cxl/core/port.c:2326
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:50
#: drivers/cxl/core/pci.c:124 drivers/cxl/core/pci.c:644
#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:61
#: drivers/cxl/core/pmem.c:122 ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:881 drivers/cxl/core/region.c:1069
msgid "``struct cxl_port *port``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:138
msgid "cxl_port to map"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:140
#: drivers/cxl/core/hdm.c:1160 ../../../driver-api/cxl/theory-of-operation:457:
#: drivers/cxl/core/pci.c:443
msgid "``struct cxl_endpoint_dvsec_info *info``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:139
#: drivers/cxl/core/hdm.c:1159
msgid "cached DVSEC range register info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:295
msgid "Track DPA 'skip' in **cxlds->dpa_res** resource tree"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:301
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:445
msgid "``struct cxl_dev_state *cxlds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:296
msgid "CXL.mem device context that parents **cxled**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:298
#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:614
#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:878 drivers/cxl/core/region.c:1067
#: drivers/cxl/core/region.c:1836
msgid "``struct cxl_endpoint_decoder *cxled``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:297
msgid "Endpoint decoder establishing new allocation that skips lower DPA"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:299
msgid "``const resource_size_t skip_base``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:298
msgid "DPA < start of new DPA allocation (DPAnew)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:300
msgid "``const resource_size_t skip_len``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:299
msgid "**skip_base** + **skip_len** == DPAnew"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:300
msgid ""
"DPA 'skip' arises from out-of-sequence DPA allocation events relative to "
"free capacity across multiple partitions. It is a wasteful event as usable "
"DPA gets thrown away, but if a deployment has, for example, a dual RAM+PMEM "
"device, wants to use PMEM, and has unallocated RAM DPA, the free RAM DPA "
"must be sacrificed to start allocating PMEM. See third \"Implementation "
"Note\" in CXL 3.1 8.2.4.19.13 \"Decoder Protection\" for more details."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:308
msgid ""
"A 'skip' always covers the last allocated DPA in a previous partition to the "
"start of the current partition to allocate.  Allocations never start in the "
"middle of a partition, and allocations are always de-allocated in reverse "
"order (see cxl_dpa_free(), or natural devm unwind order from forced in-order "
"allocation)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:314
msgid ""
"If **cxlds->nr_partitions** was guaranteed to be <= 2 then the 'skip' would "
"always be contained to a single partition. Given **cxlds->nr_partitions** "
"may be > 2 it results in cases where the 'skip' might span \"tail capacity "
"of partition[0], all of partition[1], ..., all of partition[N-1]\" to "
"support allocating from partition[N]. That in turn interacts with the "
"partition 'struct resource' boundaries within **cxlds->dpa_res** whereby "
"'skip' requests need to be divided by partition. I.e. this is a quirk of "
"using a 'struct resource' tree to detect range conflicts while also tracking "
"partition boundaries in **cxlds->dpa_res**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:1157
msgid "add decoder objects per HDM register set"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:1163
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:442
msgid "``struct cxl_hdm *cxlhdm``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:1158
msgid "Structure to populate with HDM capabilities"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:1219
msgid "allocate and setup switch decoders"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:1220
#: drivers/cxl/core/hdm.c:1252
msgid "CXL port context"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:1221
#: drivers/cxl/core/hdm.c:1253
msgid "Return 0 or -errno on error"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442: drivers/cxl/core/hdm.c:1251
msgid "allocate and setup endpoint decoders"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:543
msgid "Combine the two input coordinates"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:549
msgid "``struct access_coordinate *out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:545
msgid "Output coordinate of c1 and c2 combined"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:547
msgid "``struct access_coordinate *c1``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:546
#: drivers/cxl/core/cdat.c:547
msgid "input coordinates"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:548
msgid "``struct access_coordinate *c2``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:611
msgid "collect all the endpoint bandwidth in an xarray"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:617
#: drivers/cxl/core/cdat.c:745 drivers/cxl/core/cdat.c:956
#: drivers/cxl/core/cdat.c:978 ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:879 drivers/cxl/core/region.c:1066
#: drivers/cxl/core/region.c:3262
msgid "``struct cxl_region *cxlr``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:612
msgid "CXL region for the bandwidth calculation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:613
msgid "endpoint decoder to start on"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:615
msgid "``struct xarray *usp_xa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:614
msgid ""
"(output) the xarray that collects all the bandwidth coordinates indexed by "
"the upstream device with data of 'struct cxl_perf_ctx'."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:617
#: drivers/cxl/core/cdat.c:744
msgid "``bool *gp_is_root``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:616
#: drivers/cxl/core/cdat.c:743
msgid "(output) bool of whether the grandparent is cxl root."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:618
msgid "0 for success or -errno"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:619
msgid ""
"Collects aggregated endpoint bandwidth and store the bandwidth in an xarray "
"indexed by the upstream device of the switch or the RP device. Each endpoint "
"consists the minimum of the bandwidth from DSLBIS from the endpoint CDAT, "
"the endpoint upstream link bandwidth, and the bandwidth from the SSLBIS of "
"the switch CDAT for the switch upstream port to the downstream port that's "
"associated with the endpoint. If the device is directly connected to a RP, "
"then no SSLBIS is involved."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:739
msgid "collect all the bandwidth at switch level in an xarray"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:740
#: drivers/cxl/core/cdat.c:951
msgid "The region being operated on"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:742
#: drivers/cxl/core/cdat.c:953
msgid "``struct xarray *input_xa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:741
msgid ""
"xarray indexed by upstream device of a switch with data of 'struct "
"cxl_perf_ctx'"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:745
msgid ""
"a xarray of resulting cxl_perf_ctx per parent switch or root port or "
"ERR_PTR(-errno)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:747
msgid ""
"Iterate through the xarray. Take the minimum of the downstream calculated "
"bandwidth, the upstream link bandwidth, and the SSLBIS of the upstream "
"switch if exists. Sum the resulting bandwidth under the switch upstream "
"device or a RP device. The function can be iterated over multiple switches "
"if the switches are present."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:856
msgid "handle the root port level bandwidth collection"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:862
#: drivers/cxl/core/cdat.c:906
msgid "``struct xarray *xa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:857
msgid ""
"the xarray that holds the cxl_perf_ctx that has the bandwidth calculated "
"below each root port device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:860
msgid "xarray that holds cxl_perf_ctx per host bridge or ERR_PTR(-errno)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:900
msgid "handle the host bridge level bandwidth collection"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:901
msgid ""
"the xarray that holds the cxl_perf_ctx that has the bandwidth calculated "
"below each host bridge."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:904
msgid "xarray that holds cxl_perf_ctx per ACPI0017 device or ERR_PTR(-errno)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:950
msgid "Update the bandwidth access coordinates of a region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:952
msgid ""
"xarray holds cxl_perf_ctx wht calculated bandwidth per ACPI0017 instance"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:972
msgid "Recalculate the bandwidth for the region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:974
msgid "the cxl region to recalculate"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445: drivers/cxl/core/cdat.c:975
msgid ""
"The function walks the topology from bottom up and calculates the bandwidth. "
"It starts at the endpoints, processes at the switches if any, processes at "
"the rootport level, at the host bridge level, and finally aggregates at the "
"region."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:448: drivers/cxl/core/port.c:20
msgid ""
"The CXL core provides a set of interfaces that can be consumed by CXL aware "
"drivers. The interfaces allow for creation, modification, and destruction of "
"regions, memory devices, ports, and decoders. CXL aware drivers must "
"register with the CXL core via these interfaces in order to be able to "
"participate in cross-device interleave coordination. The CXL core also "
"establishes and maintains the bridge to the nvdimm subsystem."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:448: drivers/cxl/core/port.c:27
msgid ""
"CXL core introduces sysfs hierarchy to control the devices that are "
"instantiated by the core."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:923
msgid "register a cxl_port in CXL memory decode hierarchy"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:929
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:853
#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:125
msgid "``struct device *host``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:924
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:852
msgid "host device for devm operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:926
msgid "``struct device *uport_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:925
msgid "\"physical\" device implementing this upstream port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:927
#: drivers/cxl/core/port.c:1224
msgid "``resource_size_t component_reg_phys``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:926
msgid "(optional) for configurable cxl_port instances"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:928
msgid "``struct cxl_dport *parent_dport``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451: drivers/cxl/core/port.c:927
msgid "next hop up in the CXL memory decode hierarchy"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1219
msgid "append VH downstream port data to a cxl_port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1220 drivers/cxl/core/port.c:1251
msgid "the cxl_port that references this dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1222 drivers/cxl/core/port.c:1253
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:47
msgid "``struct device *dport_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1221 drivers/cxl/core/port.c:1252
msgid "firmware or PCI device representing the dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1223 drivers/cxl/core/port.c:1254
msgid "``int port_id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1222 drivers/cxl/core/port.c:1253
msgid "identifier for this dport in a decoder's target list"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1223
msgid "optional location of CXL component registers"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1224
msgid ""
"Note that dports are appended to the devm release action's of the either the "
"port's host (for root ports), or the port itself (for switch ports)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1250
msgid "append RCH downstream port data to a cxl_port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1255
msgid "``resource_size_t rcrb``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1254
msgid "mandatory location of a Root Complex Register Block"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1255
msgid "See CXL 3.0 9.11.8 CXL Devices Attached to an RCH"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1296
msgid "register an endpoint's interest in a port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1302
#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:856
msgid "``struct cxl_dport *dport``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1297
msgid "the dport that routes to **ep_dev**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1299
msgid "``struct device *ep_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1298
msgid "device representing the endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1299
msgid ""
"Intermediate CXL ports are scanned based on the arrival of endpoints. When "
"those endpoints depart the port can be destroyed once all endpoints that "
"care about that port have been removed."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1905
msgid "Common decoder setup / initialization"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1906 drivers/cxl/core/port.c:2050
msgid "owning port of this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1908 drivers/cxl/core/port.c:2088
#: drivers/cxl/core/port.c:2141
msgid "``struct cxl_decoder *cxld``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1907
msgid "common decoder properties to initialize"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1908
msgid ""
"A port may contain one or more decoders. Each of those decoders enable some "
"address space for CXL.mem utilization. A decoder is expected to be "
"configured by the caller before registering via cxl_decoder_add()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1958
msgid "Allocate a root level decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1959
msgid "owning CXL root of this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1961 drivers/cxl/core/port.c:2015
msgid "``unsigned int nr_targets``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1960
msgid "static number of downstream targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:1962
msgid ""
"A new cxl decoder to be registered by cxl_decoder_add(). A 'CXL root' "
"decoder is one that decodes from a top-level / static platform firmware "
"description of CXL resources into a CXL standard decode topology."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2012
msgid "Allocate a switch level decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2013
msgid "owning CXL switch port of this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2014
msgid "max number of dynamically addressable downstream targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2016
msgid ""
"A new cxl decoder to be registered by cxl_decoder_add(). A 'switch' decoder "
"is any decoder that can be enumerated by PCIe topology and the HDM Decoder "
"Capability. This includes the decoders that sit between Switch Upstream "
"Ports / Switch Downstream Ports and Host Bridges / Root Ports."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2049
msgid "Allocate an endpoint decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2052
msgid "A new cxl decoder to be registered by cxl_decoder_add()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2082 drivers/cxl/core/port.c:2135
msgid "Add a decoder with targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2083 drivers/cxl/core/port.c:2136
msgid "The cxl decoder allocated by cxl_<type>_decoder_alloc()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2084
msgid ""
"Certain types of decoders may not have any targets. The main example of this "
"is an endpoint device. A more awkward example is a hostbridge whose root "
"ports get hot added (technically possible, though unlikely)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2088
msgid "This is the locked variant of cxl_decoder_add()."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2091
msgid ""
"Process context. Expects the device lock of the port that owns the **cxld** "
"to be held."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2094
msgid ""
"Negative error code if the decoder wasn't properly configured; else returns "
"0."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2137
msgid ""
"This is the unlocked variant of cxl_decoder_add_locked(). See "
"cxl_decoder_add_locked()."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2141
msgid ""
"Process context. Takes and releases the device lock of the port that owns "
"the **cxld**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2177
msgid "register a driver for the cxl bus"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2183
msgid "``struct cxl_driver *cxl_drv``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2178
msgid "cxl driver structure to attach"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2180
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2179
msgid "owning module/driver"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2181
msgid "``const char *modname``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2180
msgid "KBUILD_MODNAME for parent driver"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2320
msgid "Retrieve performance numbers stored in dports of CXL path"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2322
msgid "endpoint cxl_port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2324
msgid "``struct access_coordinate *coord``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2323
msgid "output performance data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: drivers/cxl/core/port.c:2325
msgid "errno on failure, 0 on success."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:454: drivers/cxl/core/pci.c:17
msgid ""
"Compute Express Link protocols are layered on top of PCIe. CXL core provides "
"a set of helpers for CXL interactions which occur via PCIe."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:44
msgid "allocate a dport by dport device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:45
msgid "cxl_port that hosts the dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:46
msgid "'struct device' of the dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:47
msgid "Returns the allocated dport on success or ERR_PTR() of -errno on error"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:118
msgid "enumerate downstream ports of the upstream port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:119
msgid "cxl_port whose ->uport_dev is the upstream of dports to be enumerated"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:120
msgid ""
"Returns a positive number of dports enumerated or a negative error code."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:439
msgid "Setup HDM decoding for the endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:440
msgid "Device state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:441
msgid "Mapped HDM decoder Capability"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:442
msgid "Cached DVSEC range registers info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:443
msgid "Try to enable the endpoint's HDM Decoder Capability"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:638
msgid "Read the CDAT data on this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:639
msgid "Port to read data from"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:640
msgid "This call will sleep waiting for responses from the DOE mailbox."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:850
msgid "Setup CXL RAS report on this dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:851
msgid "the cxl_dport that needs to be initialized"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:1041
msgid "calculate the link latency for the PCIe link"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:1047
#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:354
#: drivers/cxl/core/regs.c:374 drivers/cxl/core/regs.c:392
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:1042
msgid "PCI device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:1044
msgid "calculated latency or 0 for no latency"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457: drivers/cxl/core/pci.c:1045
msgid ""
"CXL Memory Device SW Guide v1.0 2.11.4 Link latency calculation Link latency "
"= LinkPropagationLatency + FlitLatency + RetimerLatency LinkProgationLatency "
"is negligible, so 0 will be used RetimerLatency is assumed to be negligible "
"and 0 will be used FlitLatency = FlitSize / LinkBandwidth FlitSize is "
"defined by spec. CXL rev3.0 4.2.1. 68B flit is used up to 32GT/s. >32GT/s, "
"256B flit size is used. The FlitLatency is converted to picoseconds."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:460: drivers/cxl/core/pmem.c:11
msgid ""
"The core CXL PMEM infrastructure supports persistent memory provisioning and "
"serves as a bridge to the LIBNVDIMM subsystem. A CXL 'bridge' device is "
"added at the root of a CXL device topology if platform firmware advertises "
"at least one persistent memory capable CXL window. That root-level bridge "
"corresponds to a LIBNVDIMM 'bus' device. Then for each cxl_memdev in the CXL "
"device topology a bridge device is added to host a LIBNVDIMM dimm object. "
"When these bridges are registered native LIBNVDIMM uapis are translated to "
"CXL operations, for example, namespace label access commands."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:55
msgid "find a bridge device relative to a port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:56
msgid "any descendant port of an nvdimm-bridge associated root-cxl-port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:119
msgid "add the root of a LIBNVDIMM topology"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:120
msgid "platform firmware root device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:121
msgid "CXL port at the root of a CXL topology"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:123
msgid "bridge device that can host cxl_nvdimm objects"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:239
msgid "add a bridge between a cxl_memdev and an nvdimm"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:245
msgid "``struct cxl_port *parent_port``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:240
msgid "parent port for the (to be added) **cxlmd** endpoint port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:242
#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1277
msgid "``struct cxl_memdev *cxlmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:241
msgid "cxl_memdev instance that will perform LIBNVDIMM operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463: drivers/cxl/core/pmem.c:243
#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:3259
msgid "0 on success negative error code on failure."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:466: drivers/cxl/core/regs.c:14
msgid ""
"CXL device capabilities are enumerated by PCI DVSEC (Designated Vendor-"
"specific) and / or descriptors provided by platform firmware. They can be "
"defined as a set like the device and component registers mandated by CXL "
"Section 8.1.12.2 Memory Device PCIe Capabilities and Extended Capabilities, "
"or they can be individual capabilities appended to bridged and endpoint "
"devices."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:466: drivers/cxl/core/regs.c:21
msgid ""
"Provide common infrastructure for enumerating and mapping these discrete "
"capabilities."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:28
msgid "Detect CXL Component register blocks"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:34
#: drivers/cxl/core/regs.c:118
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:29
#: drivers/cxl/core/regs.c:113
msgid "Host device of the **base** mapping"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:31
#: drivers/cxl/core/regs.c:115
msgid "``void __iomem *base``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:30
msgid "Mapping containing the HDM Decoder Capability Header"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:32
msgid "``struct cxl_component_reg_map *map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:31
#: drivers/cxl/core/regs.c:115
msgid "Map object describing the register block information found"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:32
msgid ""
"See CXL 2.0 8.2.4 Component Register Layout and Definition See CXL 2.0 "
"8.2.5.5 CXL Device Register Interface"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:35
msgid "Probe for component register information and return it in map object."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:112
msgid "Detect CXL Device register blocks"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:114
msgid "Mapping of CXL 2.0 8.2.8 CXL Device Register Interface"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:116
msgid "``struct cxl_device_reg_map *map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:116
msgid "Probe for device register information and return it in map object."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:348
msgid "Locate a register block by type / index"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:349
#: drivers/cxl/core/regs.c:369 drivers/cxl/core/regs.c:387
msgid "The CXL PCI device to enumerate."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:351
#: drivers/cxl/core/regs.c:371 drivers/cxl/core/regs.c:389
msgid "``enum cxl_regloc_type type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:350
#: drivers/cxl/core/regs.c:370 drivers/cxl/core/regs.c:388
msgid "Register Block Indicator id"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:352
#: drivers/cxl/core/regs.c:372
msgid "``struct cxl_register_map *map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:351
#: drivers/cxl/core/regs.c:371
msgid "Enumeration output, clobbered on error"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:353
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:352
msgid ""
"Index into which particular instance of a regblock wanted in the order found "
"in register locator DVSEC."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:355
#: drivers/cxl/core/regs.c:373
msgid "0 if register block enumerated, negative error code otherwise"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:356
msgid ""
"A CXL DVSEC may point to one or more register blocks, search for them by "
"**type** and **index**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:368
msgid "Locate register blocks by type"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:374
msgid ""
"A CXL DVSEC may point to one or more register blocks, search for them by "
"**type**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:386
msgid "Count instances of a given regblock type."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:389
msgid "Some regblocks may be repeated. Count how many instances."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469: drivers/cxl/core/regs.c:392
msgid ""
"non-negative count of matching regblocks, negative error code otherwise."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:472: drivers/cxl/core/mbox.c:19
msgid ""
"Core implementation of the CXL 2.0 Type-3 Memory Device Mailbox. The "
"implementation is used by the cxl_pci driver to initialize the device and "
"implement the cxl_mem.h IOCTL UAPI. It also implements the backend of the "
"cxl_pmem_ctl() transport for LIBNVDIMM."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:228
msgid "Kernel internal interface to send a mailbox command"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:230
msgid "initialized command to execute"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:232
msgid "Any context."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:233
msgid "%>=0      - Number of bytes returned in **out**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:234
msgid "``-E2BIG``   - Payload is too large for hardware."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:235
msgid "``-EBUSY``   - Couldn't acquire exclusive mailbox access."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:236
msgid "``-EFAULT``  - Hardware error occurred."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:237
msgid "``-ENXIO``   - Command completed, but device reported an error."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:238
msgid "``-EIO``     - Unexpected output size."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:240
msgid ""
"Mailbox commands may execute successfully yet the device itself reported an "
"error. While this distinction can be useful for commands from userspace, the "
"kernel will only be able to use results when both are successful."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:311
msgid "Check contents of in_payload."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:317
msgid "``u16 opcode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:312
msgid "The mailbox command opcode."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:314
msgid "``void *payload_in``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:313
msgid "Pointer to the input payload passed in from user space."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:315
msgid "true      - payload_in passes check for **opcode**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:316
msgid "false     - payload_in contains invalid or unsupported values."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:318
msgid ""
"The driver may inspect payload contents before sending a mailbox command "
"from user space to the device. The intent is to reject commands with input "
"payloads that are known to be unsafe. This check is not intended to replace "
"the users careful selection of mailbox command parameters and makes no "
"guarantee that the user command will succeed, nor that it is appropriate."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:325
msgid "The specific checks are determined by the opcode."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:478
msgid "Check fields for CXL_MEM_SEND_COMMAND."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:479
msgid "Sanitized and populated :c:type:`struct cxl_mbox_cmd <cxl_mbox_cmd>`."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:482
msgid "``const struct cxl_send_command *send_cmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:481
msgid ""
":c:type:`struct cxl_send_command <cxl_send_command>` copied in from "
"userspace."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:483
msgid "``0``        - **out_cmd** is ready to send."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:484
msgid "``-ENOTTY``  - Invalid command specified."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:485
msgid "``-EINVAL``  - Reserved fields or invalid values were used."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:486
msgid "``-ENOMEM``  - Input or output buffer wasn't sized properly."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:487
msgid "``-EPERM``   - Attempted to use a protected command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:488
msgid "``-EBUSY``   - Kernel has claimed exclusive access to this opcode"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:490
msgid ""
"The result of this command is a fully validated command in **mbox_cmd** that "
"is safe to send to the hardware."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:567
msgid "Dispatch a mailbox command for userspace."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:568
msgid "The mailbox context for the operation."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:569
msgid "The validated mailbox command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:571
msgid "``u64 out_payload``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:570
msgid "Pointer to userspace's output payload."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:572
msgid "``s32 *size_out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:571
msgid ""
"(Input) Max payload size to copy out. (Output) Payload size hardware "
"generated."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:574
msgid "``u32 *retval``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:573
msgid "Hardware generated return code from the operation."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:575
msgid "``0``        - Mailbox transaction succeeded. This implies the mailbox"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:576
msgid ""
"protocol completed successfully not that the operation itself was successful."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:578
msgid "``-ENOMEM``  - Couldn't allocate a bounce buffer."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:579
msgid "``-EFAULT``  - Something happened with copy_to/from_user."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:580
msgid "``-EINTR``   - Mailbox acquisition interrupted."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:581
msgid "``-EXXX``    - Transaction level failures."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:583
msgid ""
"Dispatches a mailbox command on behalf of a userspace request. The output "
"payload is copied to userspace."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:586
msgid "See cxl_send_cmd()."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:740
msgid "Walk through the Command Effects Log."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:741
#: drivers/cxl/core/mbox.c:829 drivers/cxl/core/mbox.c:1111
#: drivers/cxl/core/mbox.c:1137 drivers/cxl/core/mbox.c:1173
msgid "The driver data for the operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:743
msgid "``size_t size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:742
msgid "Length of the Command Effects Log."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:744
msgid "``u8 *cel``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:743
msgid "CEL"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:744
msgid ""
"Iterate over each entry in the CEL and determine if the driver supports the "
"command. If so, the command is enabled for the device and can be used later."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:828
msgid "Enumerate commands for a device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:830
msgid "Returns 0 if enumerate completed successfully."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475: drivers/cxl/core/mbox.c:832
msgid ""
"CXL devices have optional support for certain commands. This function will "
"determine the set of supported commands for the hardware and update the "
"enabled_cmds bitmap in the **mds**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1110
msgid "Get Event Records from the device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1113
msgid "``u32 status``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1112
msgid "Event Status register value identifying which events are available."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1113
msgid ""
"Retrieve all event records available on the device, report them as trace "
"events, and clear them."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1116
msgid ""
"See CXL rev 3.0 **8.2.9.2.2** Get Event Records See CXL rev 3.0 "
"**8.2.9.2.3** Clear Event Records"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1136
msgid "Get partition info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1138
msgid ""
"Retrieve the current partition info for the device specified.  The active "
"values are the current capacity in bytes.  If not 0, the 'next' values are "
"the pending values, in bytes, which take affect on next cold reset."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1143
msgid "See CXL **8.2.9.5.2.1** Get Partition Info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1172
msgid "Send the IDENTIFY command to the device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1175
msgid "0 if identify was executed successfully or media not ready."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1176
msgid ""
"This will dispatch the identify command to the device and on success "
"populate structures to be exported to sysfs."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1271
msgid "Send a sanitization command to the device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1272
msgid "The device for the operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1274
msgid "``u16 cmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1273
msgid "The specific sanitization command opcode"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1275
msgid ""
"0 if the command was executed successfully, regardless of whether or not the "
"actual security operation is done in the background, such as for the "
"Sanitize case. Error return values can be the result of the mailbox command, "
"-EINVAL when security requirements are not met or invalid contexts, or -"
"EBUSY if the sanitize operation is already in flight."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: drivers/cxl/core/mbox.c:1281
msgid "See CXL 3.0 **8.2.9.8.5.1** Sanitize and **8.2.9.8.5.2** Secure Erase."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:478:
#: drivers/cxl/core/features.c:13
msgid ""
"CXL Features: A CXL device that includes a mailbox supports commands that "
"allows listing, getting, and setting of optionally defined features such as "
"memory sparing or post package sparing. Vendors may define custom features "
"for the device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:395
msgid "See :c:func:`devm_cxl_setup_features` for API details."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:398
msgid "CXL Regions"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:485:
#: drivers/cxl/core/region.c:20
msgid ""
"CXL Regions represent mapped memory capacity in system physical address "
"space. Whereas the CXL Root Decoders identify the bounds of potential CXL "
"Memory ranges, Regions represent the active mapped capacity by the HDM "
"Decoder Capability structures throughout the Host Bridges, Switches, and "
"Endpoints in the topology."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:485:
#: drivers/cxl/core/region.c:26
msgid ""
"Region configuration has ordering constraints. UUID may be set at any time "
"but is only visible for persistent regions. 1. Interleave granularity 2. "
"Interleave size 3. Decoder targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:875
msgid "assign or lookup a decoder for a region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:876
msgid "a port in the ancestry of the endpoint implied by **cxled**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:877
msgid "endpoint decoder to be, or currently, mapped by **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:878
msgid "region to establish, or validate, decode **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:879
msgid ""
"In the region creation path cxl_port_pick_region_decoder() is an allocator "
"to find a free port. In the region assembly path, it is recalling the "
"decoder that platform firmware picked for validation purposes."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:884
msgid "The result is recorded in a 'struct cxl_region_ref' in **port**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1063
msgid "track a region's interest in a port by endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1064
msgid "port to add a new region reference 'struct cxl_region_ref'"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1065
msgid "region to attach to **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1066
msgid "endpoint decoder used to create or further pin a region reference"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1068
msgid "``int pos``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1067
msgid "interleave position of **cxled** in **cxlr**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1068
msgid ""
"The attach event is an opportunity to validate CXL decode setup constraints "
"and record metadata needed for programming HDM decoders, in particular "
"decoder target lists."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1072
msgid "The steps are:"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1074
msgid ""
"validate that there are no other regions with a higher HPA already "
"associated with **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1076
msgid "establish a region reference if one is not already present"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1078
msgid ""
"additionally allocate a decoder instance that will host **cxlr** on **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1081
msgid "pin the region reference by the endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1082
msgid ""
"account for how many entries in **port**'s target list are needed to cover "
"all of the added endpoints."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1830
msgid "calculate an endpoint position in a region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1831
msgid "endpoint decoder member of given region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1832
msgid ""
"The endpoint position is calculated by traversing the topology from the "
"endpoint to the root decoder and iteratively applying this calculation:"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1836
msgid "position = position * parent_ways + parent_pos;"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1838
msgid ""
"...where **position** is inferred from switch and root decoder target lists."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:1841
msgid "position >= 0 on success -ENXIO on failure"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2528
msgid "Adds a region to a decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2534
msgid "``struct cxl_root_decoder *cxlrd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2529
msgid "root decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2531
msgid "``int id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2530
msgid "memregion id to create, or memregion_free() on failure"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2532
msgid "``enum cxl_partition_mode mode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2531
msgid "mode for the endpoint decoders of this region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2533
msgid "``enum cxl_decoder_type type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2532
msgid "select whether this is an expander or accelerator (type-2 or type-3)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2533
msgid ""
"This is the second step of region initialization. Regions exist within an "
"address space which is mapped by a **cxlrd**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:2537
msgid ""
"0 if the region was added to the **cxlrd**, else returns negative error "
"code. The region will be named \"regionZ\" where Z is the unique region "
"number."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:3256
msgid "add a cxl_region-to-nd_region bridge"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: drivers/cxl/core/region.c:3257
msgid "parent CXL region for this pmem region bridge device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:406
msgid "External Interfaces"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:409
msgid "CXL IOCTL Interface"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:497:
#: include/uapi/linux/cxl_mem.h:12
msgid ""
"Not all of the commands that the driver supports are available for use by "
"userspace at all times.  Userspace can check the result of the QUERY command "
"to determine the live set of commands.  Alternatively, it can issue the "
"command and check for failure."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:102
msgid "Command information returned from a query."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:104
msgid "ID number for the command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:105
msgid "Flags that specify command behavior."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:118
msgid "``size_in``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:119
msgid "Expected input size, or ~0 if variable length."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:119
msgid "``size_out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:120
msgid "Expected output size, or ~0 if variable length."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:105
msgid "CXL_MEM_COMMAND_FLAG_USER_ENABLED"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:107
msgid ""
"The given command id is supported by the driver and is supported by a "
"related opcode on the device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:110
msgid "CXL_MEM_COMMAND_FLAG_EXCLUSIVE"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:112
msgid ""
"Requests with the given command id will terminate with EBUSY as the kernel "
"actively owns management of the given resource. For example, the label-"
"storage-area can not be written while the kernel is actively managing that "
"space."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:118
msgid ""
"Represents a single command that is supported by both the driver and the "
"hardware. This is returned as part of an array from the query ioctl. The "
"following would be a command that takes a variable length input and returns "
"0 bytes of output."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:123
msgid "**id** = 10"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:124
msgid "**flags** = CXL_MEM_COMMAND_FLAG_ENABLED"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:125
msgid "**size_in** = ~0"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:126
msgid "**size_out** = 0"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:128
msgid "See struct cxl_mem_query_commands."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:146
msgid "Query supported commands."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:147
msgid "``n_commands``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:148
msgid ""
"In/out parameter. When **n_commands** is > 0, the driver will return "
"min(num_support_commands, n_commands). When **n_commands** is 0, driver will "
"return the number of total supported commands."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:150 include/uapi/linux/cxl_mem.h:189
msgid "``rsvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:151
msgid "Reserved for future use."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:151
msgid "``commands``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:152
msgid ""
"Output array of supported commands. This array must be allocated by "
"userspace to be at least min(num_support_commands, **n_commands**)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:153
msgid ""
"Allow userspace to query the available commands supported by both the "
"driver, and the hardware. Commands that aren't supported by either the "
"driver, or the hardware are not returned in the query."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:157
msgid "**Examples**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:158
msgid "{ .n_commands = 0 } // Get number of supported commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:159
msgid ""
"{ .n_commands = 15, .commands = buf } // Return first 15 (or less) supported "
"commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:182
msgid "Send a command to a memory device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:184
msgid ""
"The command to send to the memory device. This must be one of the commands "
"returned by the query command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:186
msgid "Flags for the command (input)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:186
msgid "``raw``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:187
msgid "Special fields for raw commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:187
msgid "``raw.opcode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:188
msgid "Opcode passed to hardware when using the RAW command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:188
msgid "``raw.rsvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:189 include/uapi/linux/cxl_mem.h:190
#: include/uapi/linux/cxl_mem.h:194 include/uapi/linux/cxl_mem.h:201
msgid "Must be zero."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:190
msgid "``retval``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:191
msgid "Return value from the memory device (output)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:191
msgid "``in``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:192
msgid "Parameters associated with input payload."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:192
msgid "``in.size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:193
msgid "Size of the payload to provide to the device (input)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:193
msgid "``in.rsvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:194
msgid "``in.payload``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:195
msgid "Pointer to memory for payload input, payload is little endian."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:195
msgid "``out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:196
msgid "Parameters associated with output payload."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:196
msgid "``out.size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:197
msgid ""
"Size of the payload received from the device (input/output). This field is "
"filled in by userspace to let the driver know how much space was allocated "
"for output. It is populated by the driver to let userspace know how large "
"the output payload actually was."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:200
msgid "``out.rsvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:201
msgid "``out.payload``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:202
msgid "Pointer to memory for payload output, payload is little endian."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: include/uapi/linux/cxl_mem.h:202
msgid ""
"Mechanism for userspace to send a command to the hardware for processing. "
"The driver will do basic validation on the command sizes. In some cases even "
"the payload may be introspected. Userspace is required to allocate large "
"enough buffers for size_out which can be variable length in certain "
"situations."
msgstr ""
