# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/i2c.rst:2
msgid "I\\ :sup:`2`\\ C and SMBus Subsystem"
msgstr ""

#: ../../../driver-api/i2c.rst:4
msgid ""
"I\\ :sup:`2`\\ C (or without fancy typography, \"I2C\") is an acronym for "
"the \"Inter-IC\" bus, a simple bus protocol which is widely used where low "
"data rate communications suffice. Since it's also a licensed trademark, some "
"vendors use another name (such as \"Two-Wire Interface\", TWI) for the same "
"bus. I2C only needs two signals (SCL for clock, SDA for data), conserving "
"board real estate and minimizing signal quality issues. Most I2C devices use "
"seven bit addresses, and bus speeds of up to 400 kHz; there's a high speed "
"extension (3.4 MHz) that's not yet found wide use. I2C is a multi-master "
"bus; open drain signaling is used to arbitrate between masters, as well as "
"to handshake and to synchronize clocks from slower clients."
msgstr ""

#: ../../../driver-api/i2c.rst:16
msgid ""
"The Linux I2C programming interfaces support the master side of bus "
"interactions and the slave side. The programming interface is structured "
"around two kinds of driver, and two kinds of device. An I2C \"Adapter "
"Driver\" abstracts the controller hardware; it binds to a physical device "
"(perhaps a PCI device or platform_device) and exposes a :c:type:`struct "
"i2c_adapter <i2c_adapter>` representing each I2C bus segment it manages. On "
"each I2C bus segment will be I2C devices represented by a :c:type:`struct "
"i2c_client <i2c_client>`. Those devices will be bound to a :c:type:`struct "
"i2c_driver <i2c_driver>`, which should follow the standard Linux driver "
"model. There are functions to perform various I2C protocol operations; at "
"this writing all such functions are usable only from task context."
msgstr ""

#: ../../../driver-api/i2c.rst:29
msgid ""
"The System Management Bus (SMBus) is a sibling protocol. Most SMBus systems "
"are also I2C conformant. The electrical constraints are tighter for SMBus, "
"and it standardizes particular protocol messages and idioms. Controllers "
"that support I2C can also support most SMBus operations, but SMBus "
"controllers don't support all the protocol options that an I2C controller "
"will. There are functions to perform various SMBus protocol operations, "
"either using I2C primitives or by issuing SMBus commands to i2c_adapter "
"devices which don't support those I2C operations."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:69
msgid "issue a single I2C message in master receive mode"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:73 include/linux/i2c.h:87
#: include/linux/i2c.h:103 include/linux/i2c.h:117 include/linux/i2c.h:443
#: include/linux/i2c.h:805 include/linux/i2c.h:817 include/linux/i2c.h:831
#: include/linux/i2c.h:843 include/linux/i2c.h:860 include/linux/i2c.h:933
#: include/linux/i2c.h:977 include/linux/i2c.h:989 ../../../driver-api/i2c:41:
#: drivers/i2c/i2c-boardinfo.c:34 ../../../driver-api/i2c:44:
#: drivers/i2c/i2c-core-base.c:721 drivers/i2c/i2c-core-base.c:948
#: drivers/i2c/i2c-core-base.c:1054 drivers/i2c/i2c-core-base.c:1084
#: drivers/i2c/i2c-core-base.c:1131 drivers/i2c/i2c-core-base.c:1164
#: drivers/i2c/i2c-core-base.c:1193 drivers/i2c/i2c-core-base.c:1397
#: drivers/i2c/i2c-core-base.c:1495 drivers/i2c/i2c-core-base.c:1644
#: drivers/i2c/i2c-core-base.c:1682 drivers/i2c/i2c-core-base.c:1752
#: drivers/i2c/i2c-core-base.c:1837 drivers/i2c/i2c-core-base.c:1869
#: drivers/i2c/i2c-core-base.c:1899 drivers/i2c/i2c-core-base.c:1939
#: drivers/i2c/i2c-core-base.c:2044 drivers/i2c/i2c-core-base.c:2214
#: drivers/i2c/i2c-core-base.c:2286 drivers/i2c/i2c-core-base.c:2329
#: drivers/i2c/i2c-core-base.c:2360 drivers/i2c/i2c-core-base.c:2391
#: drivers/i2c/i2c-core-base.c:2638 drivers/i2c/i2c-core-base.c:2672
#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:47
#: drivers/i2c/i2c-core-smbus.c:101 drivers/i2c/i2c-core-smbus.c:120
#: drivers/i2c/i2c-core-smbus.c:135 drivers/i2c/i2c-core-smbus.c:155
#: drivers/i2c/i2c-core-smbus.c:175 drivers/i2c/i2c-core-smbus.c:195
#: drivers/i2c/i2c-core-smbus.c:215 drivers/i2c/i2c-core-smbus.c:247
#: drivers/i2c/i2c-core-smbus.c:528 drivers/i2c/i2c-core-smbus.c:627
#: drivers/i2c/i2c-core-smbus.c:684
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:75 include/linux/i2c.h:89
#: include/linux/i2c.h:105 include/linux/i2c.h:119 ../../../driver-api/i2c:44:
#: drivers/i2c/i2c-core-base.c:2331 drivers/i2c/i2c-core-base.c:2362
#: drivers/i2c/i2c-core-base.c:2393 ../../../driver-api/i2c:47:
#: drivers/i2c/i2c-core-smbus.c:103 drivers/i2c/i2c-core-smbus.c:122
#: drivers/i2c/i2c-core-smbus.c:137 drivers/i2c/i2c-core-smbus.c:157
#: drivers/i2c/i2c-core-smbus.c:177 drivers/i2c/i2c-core-smbus.c:197
#: drivers/i2c/i2c-core-smbus.c:217 drivers/i2c/i2c-core-smbus.c:249
#: drivers/i2c/i2c-core-smbus.c:629
msgid "``const struct i2c_client *client``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:70 include/linux/i2c.h:85
#: include/linux/i2c.h:100 include/linux/i2c.h:115 ../../../driver-api/i2c:44:
#: drivers/i2c/i2c-core-base.c:2327 ../../../driver-api/i2c:47:
#: drivers/i2c/i2c-core-smbus.c:98 drivers/i2c/i2c-core-smbus.c:117
#: drivers/i2c/i2c-core-smbus.c:132 drivers/i2c/i2c-core-smbus.c:152
#: drivers/i2c/i2c-core-smbus.c:172 drivers/i2c/i2c-core-smbus.c:192
#: drivers/i2c/i2c-core-smbus.c:212 drivers/i2c/i2c-core-smbus.c:244
#: drivers/i2c/i2c-core-smbus.c:624
msgid "Handle to slave device"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:72 include/linux/i2c.h:87
#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2329
msgid "``char *buf``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:71
msgid "Where to store data read from slave"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:73 include/linux/i2c.h:88
#: include/linux/i2c.h:103 include/linux/i2c.h:118 ../../../driver-api/i2c:44:
#: drivers/i2c/i2c-core-base.c:2330
msgid "``int count``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:72 include/linux/i2c.h:87
msgid "How many bytes to read, must be less than 64k since msg.len is u16"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:74 include/linux/i2c.h:89
#: include/linux/i2c.h:104 include/linux/i2c.h:119 include/linux/i2c.h:252
#: include/linux/i2c.h:329 include/linux/i2c.h:416 include/linux/i2c.h:443
#: include/linux/i2c.h:537 include/linux/i2c.h:593 include/linux/i2c.h:690
#: include/linux/i2c.h:842 include/linux/i2c.h:859 include/linux/i2c.h:976
#: include/linux/i2c.h:988 ../../../driver-api/i2c:41:
#: drivers/i2c/i2c-boardinfo.c:36 ../../../driver-api/i2c:44:
#: drivers/i2c/i2c-core-base.c:720 drivers/i2c/i2c-core-base.c:949
#: drivers/i2c/i2c-core-base.c:1083 drivers/i2c/i2c-core-base.c:1132
#: drivers/i2c/i2c-core-base.c:1166 drivers/i2c/i2c-core-base.c:1196
#: drivers/i2c/i2c-core-base.c:1396 drivers/i2c/i2c-core-base.c:1497
#: drivers/i2c/i2c-core-base.c:1644 drivers/i2c/i2c-core-base.c:1682
#: drivers/i2c/i2c-core-base.c:1752 drivers/i2c/i2c-core-base.c:1838
#: drivers/i2c/i2c-core-base.c:1868 drivers/i2c/i2c-core-base.c:1898
#: drivers/i2c/i2c-core-base.c:1941 drivers/i2c/i2c-core-base.c:2216
#: drivers/i2c/i2c-core-base.c:2288 drivers/i2c/i2c-core-base.c:2332
#: drivers/i2c/i2c-core-base.c:2360 drivers/i2c/i2c-core-base.c:2390
#: drivers/i2c/i2c-core-base.c:2643 ../../../driver-api/i2c:47:
#: drivers/i2c/i2c-core-smbus.c:48 drivers/i2c/i2c-core-smbus.c:100
#: drivers/i2c/i2c-core-smbus.c:120 drivers/i2c/i2c-core-smbus.c:135
#: drivers/i2c/i2c-core-smbus.c:156 drivers/i2c/i2c-core-smbus.c:175
#: drivers/i2c/i2c-core-smbus.c:196 drivers/i2c/i2c-core-smbus.c:217
#: drivers/i2c/i2c-core-smbus.c:249 drivers/i2c/i2c-core-smbus.c:533
#: drivers/i2c/i2c-core-smbus.c:631 drivers/i2c/i2c-core-smbus.c:685
msgid "**Description**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:73 include/linux/i2c.h:88
msgid "Returns negative errno, or else the number of bytes read."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:83
msgid ""
"issue a single I2C message in master receive mode using a DMA safe buffer"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:86
msgid "Where to store data read from slave, must be safe to use with DMA"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:99
msgid "issue a single I2C message in master transmit mode"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:102 include/linux/i2c.h:117
msgid "``const char *buf``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:101
msgid "Data that will be written to the slave"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:102 include/linux/i2c.h:117
msgid "How many bytes to write, must be less than 64k since msg.len is u16"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:103 include/linux/i2c.h:118
msgid "Returns negative errno, or else the number of bytes written."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:113
msgid ""
"issue a single I2C message in master transmit mode using a DMA safe buffer"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:116
msgid "Data that will be written to the slave, must be safe to use with DMA"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:195
msgid "i2c client device identification"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:199 include/linux/i2c.h:240
#: include/linux/i2c.h:313 include/linux/i2c.h:406 include/linux/i2c.h:519
#: include/linux/i2c.h:590 include/linux/i2c.h:604 include/linux/i2c.h:628
#: include/linux/i2c.h:684
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:222 include/linux/i2c.h:257
#: include/linux/i2c.h:337 include/linux/i2c.h:421 include/linux/i2c.h:545
#: include/linux/i2c.h:598 include/linux/i2c.h:617 include/linux/i2c.h:646
#: include/linux/i2c.h:695
msgid "**Members**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:196
msgid "``manufacturer_id``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:197
msgid "0 - 4095, database maintained by NXP"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:197
msgid "``part_id``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:198
msgid "0 - 511, according to manufacturer"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:198
msgid "``die_revision``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:199
msgid "0 - 7, according to manufacturer"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:227
msgid "Flags for an I2C device driver"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:231
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:233
msgid "``I2C_DRV_ACPI_WAIVE_D0_PROBE``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:234
msgid "Don't put the device in D0 state for probe"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:236
msgid "represent an I2C device driver"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:237
msgid "``class``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:238
msgid "What kind of i2c device we instantiate (for detect)"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:238
msgid "``probe``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:239
msgid "Callback for device binding"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:239
msgid "``remove``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:240
msgid "Callback for device unbinding"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:240
msgid "``shutdown``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:241
msgid "Callback for device shutdown"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:241
msgid "``alert``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:242
msgid "Alert callback, for example for the SMBus alert protocol"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:242
msgid "``command``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:243
msgid "Callback for bus-wide signaling (optional)"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:243
msgid "``driver``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:244
msgid "Device driver model driver"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:244
msgid "``id_table``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:245
msgid "List of I2C devices supported by this driver"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:245
msgid "``detect``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:246
msgid "Callback for device detection"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:246
msgid "``address_list``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:247
msgid "The I2C addresses to probe (for detect)"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:247
msgid "``clients``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:248
msgid "List of detected clients we created (for i2c-core use only)"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:248 include/linux/i2c.h:310
#: include/linux/i2c.h:404 include/linux/i2c.h:681
msgid "``flags``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:249
msgid ""
"A bitmask of flags defined in :c:type:`enum i2c_driver_flags "
"<i2c_driver_flags>`"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:249
msgid ""
"The driver.owner field should be set to the module owner of this driver. The "
"driver.name field should be set to the name of this driver."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:252
msgid ""
"For automatic device detection, both **detect** and **address_list** must be "
"defined. **class** should also be set, otherwise only devices forced with "
"module parameters will be created. The detect function must fill at least "
"the name field of the i2c_board_info structure it is handed upon successful "
"detection, and possibly also the flags field."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:258
msgid ""
"If **detect** is missing, the driver will still work fine for enumerated "
"devices. Detected devices simply won't be supported. This is expected for "
"the many I2C/SMBus devices which can't be detected reliably, and the ones "
"which can always be enumerated in practice."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:263
msgid ""
"The i2c_client structure which is handed to the **detect** callback is not a "
"real i2c_client. It is initialized just enough so that you can call "
"i2c_smbus_read_byte_data and friends on it. Don't do anything else with it. "
"In particular, calling dev_dbg and friends on it is not allowed."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:309
msgid "represent an I2C slave device"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:311
msgid "see I2C_CLIENT_* for possible flags"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:311 include/linux/i2c.h:405
msgid "``addr``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:312
msgid "Address used on the I2C bus connected to the parent adapter."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:312
msgid "``name``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:313
msgid ""
"Indicates the type of the device, usually a chip name that's generic enough "
"to hide second-sourcing and compatible revisions."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:314
msgid "``adapter``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:315
msgid "manages the bus segment hosting this I2C device"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:315
msgid "``dev``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:316
msgid "Driver model device node for the slave."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:316
msgid "``init_irq``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:317
msgid "IRQ that was set at initialization"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:317 include/linux/i2c.h:412
msgid "``irq``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:318
msgid "indicates the IRQ generated by this device (if any)"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:318
msgid "``detected``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:319
msgid ""
"member of an i2c_driver.clients list or i2c-core's userspace_devices list"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:320
msgid "``slave_cb``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:321
msgid ""
"Callback when I2C slave mode of an adapter is used. The adapter calls it to "
"pass on slave events to the slave driver."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:322
msgid "``devres_group_id``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:323
msgid ""
"id of the devres group that will be created for resources acquired when "
"probing this device."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:324
msgid "``debugfs``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:325
msgid ""
"pointer to the debugfs subdirectory which the I2C core created for this "
"client."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:326
msgid ""
"An i2c_client identifies a single device (i.e. chip) connected to an i2c "
"bus. The behaviour exposed to Linux is defined by the driver managing the "
"device."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:402
msgid "template for device creation"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:403
msgid "``type``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:404
msgid "chip type, to initialize i2c_client.name"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:405
msgid "to initialize i2c_client.flags"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:406
msgid "stored in i2c_client.addr"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:406
msgid "``dev_name``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:407
msgid "Overrides the default <busnr>-<addr> dev_name if set"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:407
msgid "``platform_data``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:408
msgid "stored in i2c_client.dev.platform_data"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:408
msgid "``fwnode``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:409
msgid "device node supplied by the platform firmware"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:409
msgid "``swnode``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:410
msgid "software node for the device"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:410
msgid "``resources``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:411
msgid "resources associated with the device"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:411
msgid "``num_resources``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:412
msgid "number of resources in the **resources** array"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:413
msgid "stored in i2c_client.irq"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:413
msgid ""
"I2C doesn't actually support hardware probing, although controllers and "
"devices may be able to use I2C_SMBUS_QUICK to tell whether or not there's a "
"device at a given address.  Drivers commonly need more information than "
"that, such as chip type, configuration, associated IRQ, and so on."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:418
msgid ""
"i2c_board_info is used to build tables of information listing I2C devices "
"that are present.  This information is used to grow the driver model tree. "
"For mainboards this is done statically using i2c_register_board_info(); bus "
"numbers identify adapters that aren't yet available.  For add-on boards, "
"i2c_new_client_device() does this dynamically with the adapter already known."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:441
msgid "``I2C_BOARD_INFO (dev_type, dev_addr)``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:439
msgid "macro used to list an i2c device and its address"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:445
msgid "``dev_type``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:440
msgid "identifies the device type"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:442
msgid "``dev_addr``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:441
msgid "the device's address on the bus."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:442
msgid ""
"This macro initializes essential fields of a struct i2c_board_info, "
"declaring what has been provided on a particular board.  Optional fields "
"(such as associated irq, or device-specific platform_data) are provided "
"using conventional syntax."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:515
msgid "represent I2C transfer methods"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:516
msgid "``xfer``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:517
msgid ""
"Transfer a given number of messages defined by the msgs array via the "
"specified adapter."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:530
msgid "``master_xfer``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:531
msgid "deprecated, use **xfer**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:518
msgid "``xfer_atomic``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:519
msgid ""
"Same as **xfer**. Yet, only using atomic context so e.g. PMICs can be "
"accessed very late before shutdown. Optional."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:531
msgid "``master_xfer_atomic``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:532
msgid "deprecated, use **xfer_atomic**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:520
msgid "``smbus_xfer``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:521
msgid ""
"Issue SMBus transactions to the given I2C adapter. If this is not present, "
"then the bus layer will try and convert the SMBus calls into I2C transfers "
"instead."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:523
msgid "``smbus_xfer_atomic``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:524
msgid ""
"Same as **smbus_xfer**. Yet, only using atomic context so e.g. PMICs can be "
"accessed very late before shutdown. Optional."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:525
msgid "``functionality``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:526
msgid ""
"Return the flags that this algorithm/adapter pair supports from the "
"``I2C_FUNC_*`` flags."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:527
msgid "``reg_target``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:528
msgid "Register given client to local target mode of this adapter"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:532
msgid "``reg_slave``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:533
msgid "deprecated, use **reg_target**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:528
msgid "``unreg_target``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:529
msgid "Unregister given client from local target mode of this adapter"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:533
msgid "``unreg_slave``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:534
msgid "deprecated, use **unreg_target**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:534
msgid ""
"i2c_algorithm is the interface to a class of hardware solutions which can be "
"addressed using the same bus algorithms - i.e. bit-banging or the PCF8584 to "
"name two of the most common."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:538
msgid ""
"The return codes from the ``xfer{_atomic}`` fields should indicate the type "
"of error code that occurred during the transfer, as documented in the Kernel "
"Documentation file Documentation/i2c/fault-codes.rst. Otherwise, the number "
"of messages executed should be returned."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:586
msgid "represent I2C locking operations"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:587
msgid "``lock_bus``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:588 include/linux/i2c.h:801
msgid "Get exclusive access to an I2C bus segment"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:588
msgid "``trylock_bus``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:589 include/linux/i2c.h:813
msgid "Try to get exclusive access to an I2C bus segment"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:589
msgid "``unlock_bus``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:590 include/linux/i2c.h:827
msgid "Release exclusive access to an I2C bus segment"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:590
msgid "The main operations are wrapped by i2c_lock_bus and i2c_unlock_bus."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:600
msgid "I2C timing information"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:601
msgid "``bus_freq_hz``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:602
msgid "the bus frequency in Hz"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:602
msgid "``scl_rise_ns``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:603
msgid "time SCL signal takes to rise in ns; t(r) in the I2C specification"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:603
msgid "``scl_fall_ns``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:604
msgid "time SCL signal takes to fall in ns; t(f) in the I2C specification"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:604
msgid "``scl_int_delay_ns``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:605
msgid "time IP core additionally needs to setup SCL in ns"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:605
msgid "``sda_fall_ns``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:606
msgid "time SDA signal takes to fall in ns; t(f) in the I2C specification"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:606
msgid "``sda_hold_ns``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:607
msgid "time IP core additionally needs to hold SDA in ns"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:607
msgid "``digital_filter_width_ns``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:608
msgid ""
"width in ns of spikes on i2c lines that the IP core digital filter can "
"filter out"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:609
msgid "``analog_filter_cutoff_freq_hz``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:610
msgid "threshold frequency for the low pass IP core analog filter"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:624
msgid "I2C bus recovery information"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:625
msgid "``recover_bus``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:626
msgid ""
"Recover routine. Either pass driver's recover_bus() routine, or "
"i2c_generic_scl_recovery()."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:627
msgid "``get_scl``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:628
msgid ""
"This gets current value of SCL line. Mandatory for generic SCL recovery. "
"Populated internally for generic GPIO recovery."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:629
msgid "``set_scl``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:630
msgid ""
"This sets/clears the SCL line. Mandatory for generic SCL recovery. Populated "
"internally for generic GPIO recovery."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:631
msgid "``get_sda``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:632
msgid ""
"This gets current value of SDA line. This or set_sda() is mandatory for "
"generic SCL recovery. Populated internally, if sda_gpio is a valid GPIO, for "
"generic GPIO recovery."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:634
msgid "``set_sda``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:635
msgid ""
"This sets/clears the SDA line. This or get_sda() is mandatory for generic "
"SCL recovery. Populated internally, if sda_gpio is a valid GPIO, for generic "
"GPIO recovery."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:637
msgid "``get_bus_free``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:638
msgid ""
"Returns the bus free state as seen from the IP core in case it has a more "
"complex internal logic than just reading SDA. Optional."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:639
msgid "``prepare_recovery``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:640
msgid ""
"This will be called before starting recovery. Platform may configure padmux "
"here for SDA/SCL line or something else they want."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:641
msgid "``unprepare_recovery``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:642
msgid ""
"This will be called after completing recovery. Platform may configure padmux "
"here for SDA/SCL line or something else they want."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:643
msgid "``scl_gpiod``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:644
msgid "gpiod of the SCL line. Only required for GPIO recovery."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:644
msgid "``sda_gpiod``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:645
msgid "gpiod of the SDA line. Only required for GPIO recovery."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:645
msgid "``pinctrl``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:646
msgid ""
"pinctrl used by GPIO recovery to change the state of the I2C pins. Optional."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:647
msgid "``pins_default``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:648
msgid ""
"default pinctrl state of SCL/SDA lines, when they are assigned to the I2C "
"bus. Optional. Populated internally for GPIO recovery, if state with the "
"name PINCTRL_STATE_DEFAULT is found and pinctrl is valid."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:650
msgid "``pins_gpio``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:651
msgid ""
"recovery pinctrl state of SCL/SDA lines, when they are used as GPIOs. "
"Optional. Populated internally for GPIO recovery, if this state is called "
"\"gpio\" or \"recovery\" and pinctrl is valid."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:680
msgid "describe flaws of an i2c adapter"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:682
msgid "see I2C_AQ_* for possible flags and read below"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:682
msgid "``max_num_msgs``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:683
msgid "maximum number of messages per transfer"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:683
msgid "``max_write_len``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:684
msgid "maximum length of a write message"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:684
msgid "``max_read_len``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:685
msgid "maximum length of a read message"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:685
msgid "``max_comb_1st_msg_len``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:686
msgid "maximum length of the first msg in a combined message"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:686
msgid "``max_comb_2nd_msg_len``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:687
msgid "maximum length of the second msg in a combined message"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:687
msgid ""
"Note about combined messages: Some I2C controllers can only send one message "
"per transfer, plus something called combined message or write-then-read. "
"This is (usually) a small write message followed by a read message and "
"barely enough to access register based devices like EEPROMs. There is a flag "
"to support this mode. It implies max_num_msg = 2 and does the length checks "
"with max_comb_*_len because combined message mode usually has its own "
"limitations. Because of HW implementations, some controllers can actually do "
"write-then-anything or other variants. To support that, write-then-read has "
"been broken out into smaller bits like write-first and read-second which can "
"be combined as needed."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:807 include/linux/i2c.h:819
#: include/linux/i2c.h:833 ../../../driver-api/i2c:44:
#: drivers/i2c/i2c-core-base.c:1133 drivers/i2c/i2c-core-base.c:1163
#: drivers/i2c/i2c-core-base.c:1646 drivers/i2c/i2c-core-base.c:1836
#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:530
#: drivers/i2c/i2c-core-smbus.c:686
msgid "``struct i2c_adapter *adapter``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:802 include/linux/i2c.h:814
#: include/linux/i2c.h:828
msgid "Target I2C bus segment"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:804 include/linux/i2c.h:816
#: include/linux/i2c.h:830
msgid "``unsigned int flags``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:803
msgid ""
"I2C_LOCK_ROOT_ADAPTER locks the root i2c adapter, I2C_LOCK_SEGMENT locks "
"only this branch in the adapter tree"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:815
msgid ""
"I2C_LOCK_ROOT_ADAPTER tries to locks the root i2c adapter, I2C_LOCK_SEGMENT "
"tries to lock only this branch in the adapter tree"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:818 include/linux/i2c.h:933
#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2639
msgid "**Return**"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:818
msgid "true if the I2C bus segment is locked, false otherwise"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:829
msgid ""
"I2C_LOCK_ROOT_ADAPTER unlocks the root i2c adapter, I2C_LOCK_SEGMENT unlocks "
"only this branch in the adapter tree"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:839
msgid "Report suspended state of the adapter to the core"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:845 include/linux/i2c.h:862
#: include/linux/i2c.h:935 ../../../driver-api/i2c:44:
#: drivers/i2c/i2c-core-base.c:950 drivers/i2c/i2c-core-base.c:1497
#: drivers/i2c/i2c-core-base.c:1684 drivers/i2c/i2c-core-base.c:1754
#: drivers/i2c/i2c-core-base.c:2216 drivers/i2c/i2c-core-base.c:2288
msgid "``struct i2c_adapter *adap``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:840
msgid "Adapter to mark as suspended"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:841
msgid ""
"When using this helper to mark an adapter as suspended, the core will reject "
"further transfers to this adapter. The usage of this helper is optional but "
"recommended for devices having distinct handlers for system suspend and "
"runtime suspend. More complex devices are free to implement custom solutions "
"to reject transfers when suspended."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:856
msgid "Report resumed state of the adapter to the core"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:857
msgid "Adapter to mark as resumed"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:858
msgid ""
"When using this helper to mark an adapter as resumed, the core will allow "
"further transfers to this adapter. See also further notes to "
"**i2c_mark_adapter_suspended\\(\\)**."
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:929
msgid "Function for checking the quirk flags in an i2c adapter"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:930
msgid "i2c adapter"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:932
msgid "``u64 quirks``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:931
msgid "quirk flags"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:933
msgid "true if the adapter has all the specified quirk flags, false if not"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:975
msgid "``module_i2c_driver (__i2c_driver)``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:973
msgid "Helper macro for registering a modular I2C driver"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:979 include/linux/i2c.h:991
msgid "``__i2c_driver``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:974 include/linux/i2c.h:986
msgid "i2c_driver struct"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:975
msgid ""
"Helper macro for I2C drivers which do not do anything special in module init/"
"exit. This eliminates a lot of boilerplate. Each module may only use this "
"macro once, and calling it replaces module_init() and module_exit()"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:987
msgid "``builtin_i2c_driver (__i2c_driver)``"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:985
msgid "Helper macro for registering a builtin I2C driver"
msgstr ""

#: ../../../driver-api/i2c:38: include/linux/i2c.h:987
msgid ""
"Helper macro for I2C drivers which do not do anything special in their init. "
"This eliminates a lot of boilerplate. Each driver may only use this macro "
"once, and calling it replaces device_initcall()."
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:30
msgid "statically declare I2C devices"
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:36
msgid "``int busnum``"
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:31
msgid "identifies the bus to which these devices belong"
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:33
#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:947
msgid "``struct i2c_board_info const *info``"
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:32
msgid "vector of i2c device descriptors"
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:34
msgid "``unsigned len``"
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:33
msgid ""
"how many descriptors in the vector; may be zero to reserve the specified bus "
"number."
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:35
msgid ""
"Systems using the Linux I2C driver stack can declare tables of board info "
"while they initialize.  This should be done in board-specific init code near "
"arch_initcall() time, or equivalent, before any I2C adapter driver is "
"registered.  For example, mainboard init code could define several devices, "
"as could the init code for each daughtercard in a board stack."
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:41
msgid ""
"The I2C devices will be created later, after the adapter for the relevant "
"bus has been registered.  After that moment, standard driver model tools are "
"used to bind \"new style\" I2C drivers to the devices.  The bus number for "
"any device declared using this routine is not available for dynamic "
"allocation."
msgstr ""

#: ../../../driver-api/i2c:41: drivers/i2c/i2c-boardinfo.c:47
msgid ""
"The board info passed can safely be __initdata, but be careful of embedded "
"pointers (for platform_data, functions, etc) since that won't be copied."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:717
msgid "return parameter as i2c_client, or NULL"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:723
#: drivers/i2c/i2c-core-base.c:1166 drivers/i2c/i2c-core-base.c:1399
#: drivers/i2c/i2c-core-base.c:1839 drivers/i2c/i2c-core-base.c:1941
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:718
#: drivers/i2c/i2c-core-base.c:1394
msgid "device, probably from some driver model iterator"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:719
msgid ""
"When traversing the driver model tree, perhaps using driver model iterators "
"like **device_for_each_child\\(\\)**, you can't assume very much about the "
"nodes you find.  Use this function to avoid oopses caused by wrongly "
"treating some non-I2C device as an i2c_client."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:944
msgid "instantiate an i2c device"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:945
#: drivers/i2c/i2c-core-base.c:1128 drivers/i2c/i2c-core-base.c:1162
msgid "the adapter managing the device"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:946
msgid "describes one I2C device; bus_num is ignored"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:948
#: drivers/i2c/i2c-core-base.c:1053 drivers/i2c/i2c-core-base.c:1131
#: drivers/i2c/i2c-core-base.c:1165 drivers/i2c/i2c-core-base.c:1195
#: drivers/i2c/i2c-core-base.c:1496 drivers/i2c/i2c-core-base.c:1643
#: drivers/i2c/i2c-core-base.c:1681 drivers/i2c/i2c-core-base.c:1751
#: drivers/i2c/i2c-core-base.c:1837 drivers/i2c/i2c-core-base.c:2043
#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:684
msgid "**Context**"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:947
#: drivers/i2c/i2c-core-base.c:1052 drivers/i2c/i2c-core-base.c:1130
#: drivers/i2c/i2c-core-base.c:1164 drivers/i2c/i2c-core-base.c:1194
#: drivers/i2c/i2c-core-base.c:1642 drivers/i2c/i2c-core-base.c:1680
#: drivers/i2c/i2c-core-base.c:1750 drivers/i2c/i2c-core-base.c:1836
#: drivers/i2c/i2c-core-base.c:2042 ../../../driver-api/i2c:47:
#: drivers/i2c/i2c-core-smbus.c:683
msgid "can sleep"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:948
msgid ""
"Create an i2c device. Binding is handled through driver model probe()/"
"remove() methods.  A driver may be bound to this device when we return from "
"this function, or any later moment (e.g. maybe hotplugging will load the "
"driver module).  This call is not appropriate for use by mainboard "
"initialization logic, which usually runs during an arch_initcall() long "
"before any i2c_adapter could exist."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:955
msgid ""
"This returns the new i2c client, which may be saved for later use with "
"i2c_unregister_device(); or an ERR_PTR to describe the error."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1050
msgid "reverse effect of i2c_new_*_device()"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1056
#: drivers/i2c/i2c-core-base.c:1195
msgid "``struct i2c_client *client``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1051
msgid "value returned from i2c_new_*_device()"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1080
msgid "find an i2c_client for the fwnode"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1086
#: drivers/i2c/i2c-core-base.c:1871 drivers/i2c/i2c-core-base.c:1901
msgid "``struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1081
msgid ""
":c:type:`struct fwnode_handle <fwnode_handle>` corresponding to the :c:type:"
"`struct i2c_client <i2c_client>`"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1082
msgid ""
"Look up and return the :c:type:`struct i2c_client <i2c_client>` "
"corresponding to the **fwnode**. If no client can be found, or **fwnode** is "
"NULL, this returns NULL."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1085
msgid ""
"The user must call put_device(:c:type:`client->dev <client>`) once done with "
"the i2c client."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1127
#: drivers/i2c/i2c-core-base.c:1160
msgid "return a new i2c device bound to a dummy driver"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1130
#: drivers/i2c/i2c-core-base.c:1164
msgid "``u16 address``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1129
#: drivers/i2c/i2c-core-base.c:1163
msgid "seven bit address to be used"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1131
msgid ""
"This returns an I2C client bound to the \"dummy\" driver, intended for use "
"with devices that consume multiple addresses.  Examples of such chips "
"include various EEPROMS (like 24c04 and 24c08 models)."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1135
msgid ""
"These dummy devices have two main uses.  First, most I2C and SMBus calls "
"except i2c_transfer() need a client handle; the dummy will be that handle. "
"And second, this prevents the specified address from being bound to a "
"different driver."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1140
#: drivers/i2c/i2c-core-base.c:1206
msgid ""
"This returns the new i2c client, which should be saved for later use with "
"i2c_unregister_device(); or an ERR_PTR to describe the error."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1161
msgid "device the managed resource is bound to"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1165
msgid ""
"This is the device-managed version of **i2c_new_dummy_device**. It returns "
"the new i2c client or an ERR_PTR in case of an error."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1189
msgid ""
"Helper to get the instantiated secondary address and create the associated "
"device"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1191
msgid "Handle to the primary client"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1193
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1192
msgid "Handle to specify which secondary address to get"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1194
msgid "``u16 default_addr``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1193
msgid "Used as a fallback if no secondary address was specified"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1195
msgid ""
"I2C clients can be composed of multiple I2C slaves bound together in a "
"single component. The I2C client driver then binds to the master I2C slave "
"and needs to create I2C dummy clients to communicate with all the other "
"slaves."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1199
msgid ""
"This function creates and returns an I2C dummy client whose I2C address is "
"retrieved from the platform firmware based on the given slave name. If no "
"address is specified by the firmware default_addr is used."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1203
msgid ""
"On DT-based platforms the address is retrieved from the \"reg\" property "
"entry cell whose \"reg-names\" value matches the slave name."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1393
msgid "return parameter as i2c_adapter or NULL"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1395
msgid ""
"When traversing the driver model tree, perhaps using driver model iterators "
"like **device_for_each_child\\(\\)**, you can't assume very much about the "
"nodes you find.  Use this function to avoid oopses caused by wrongly "
"treating some non-I2C device as an i2c_adapter."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1491
msgid "Forward a Host Notify event to the correct I2C client."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1493
msgid "the adapter"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1495
msgid "``unsigned short addr``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1494
msgid "the I2C address of the notifying device"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1495
msgid "can't sleep"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1496
msgid ""
"Helper function to be called from an I2C bus driver's interrupt handler. It "
"will schedule the Host Notify IRQ."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1640
msgid "declare i2c adapter, use dynamic bus number"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1641
#: drivers/i2c/i2c-core-base.c:1835
msgid "the adapter to add"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1643
msgid ""
"This routine is used to declare an I2C adapter when its bus number doesn't "
"matter or when its bus number is specified by an dt alias. Examples of bases "
"when the bus number doesn't matter: I2C adapters dynamically added by USB "
"links or PCI plugin cards."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1648
msgid ""
"When this returns zero, a new bus number was allocated and stored in adap-"
">nr, and the specified adapter became available for clients. Otherwise, a "
"negative errno value is returned."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1678
msgid "declare i2c adapter, use static bus number"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1679
msgid "the adapter to register (with adap->nr initialized)"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1681
msgid ""
"This routine is used to declare an I2C adapter when its bus number matters.  "
"For example, use it for I2C adapters from system-on-chip CPUs, or otherwise "
"built in to the system's mainboard, and where i2c_board_info is used to "
"properly configure I2C devices."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1686
msgid ""
"If the requested bus number is set to -1, then this function will behave "
"identically to i2c_add_adapter, and will dynamically assign a bus number."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1689
msgid ""
"If no devices have pre-been declared for this bus, then be sure to register "
"the adapter before any dynamically allocated ones.  Otherwise the required "
"bus ID may not be available."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1693
msgid ""
"When this returns zero, the specified adapter became available for clients "
"using the bus number provided in adap->nr.  Also, the table of I2C devices "
"pre-declared using i2c_register_board_info() is scanned, and the appropriate "
"driver model device nodes are created.  Otherwise, a negative errno value is "
"returned."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1748
msgid "unregister I2C adapter"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1749
msgid "the adapter being unregistered"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1751
msgid ""
"This unregisters an I2C adapter which was previously registered by "
"**i2c_add_adapter** or **i2c_add_numbered_adapter**."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1833
msgid "device-managed variant of i2c_add_adapter()"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1834
msgid "managing device for adding this I2C adapter"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1837
msgid ""
"Add adapter with dynamic bus number, same with i2c_add_adapter() but the "
"adapter will be auto deleted on driver detach."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1865
#: drivers/i2c/i2c-core-base.c:1895
msgid "find an i2c_adapter for the fwnode"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1866
#: drivers/i2c/i2c-core-base.c:1896
msgid ""
":c:type:`struct fwnode_handle <fwnode_handle>` corresponding to the :c:type:"
"`struct i2c_adapter <i2c_adapter>`"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1867
msgid ""
"Look up and return the :c:type:`struct i2c_adapter <i2c_adapter>` "
"corresponding to the **fwnode**. If no adapter can be found, or **fwnode** "
"is NULL, this returns NULL."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1870
msgid ""
"The user must call put_device(:c:type:`adapter->dev <adapter>`) once done "
"with the i2c adapter."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1897
msgid ""
"Look up and return the :c:type:`struct i2c_adapter <i2c_adapter>` "
"corresponding to the **fwnode**, and increment the adapter module's use "
"count. If no adapter can be found, or **fwnode** is NULL, this returns NULL."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1901
msgid ""
"The user must call i2c_put_adapter(adapter) once done with the i2c adapter. "
"Note that this is different from i2c_find_adapter_by_node()."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1935
msgid "get I2C related timing parameters from firmware"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1936
msgid "The device to scan for I2C timing properties"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1938
msgid "``struct i2c_timings *t``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1937
msgid "the i2c_timings struct to be filled with values"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1939
msgid "``bool use_defaults``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1938
msgid ""
"bool to use sane defaults derived from the I2C specification when properties "
"are not found, otherwise don't update"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:1940
msgid ""
"Scan the device for the generic I2C properties describing timing parameters "
"for the signal and fill the given struct with the results. If a property was "
"not found and use_defaults was true, then maximum timings are assumed which "
"are derived from the I2C specification. If use_defaults is not used, the "
"results will be as before, so drivers can apply their own defaults before "
"calling this helper. The latter is mainly intended for avoiding regressions "
"of existing drivers which want to switch to this function. New drivers "
"almost always should use the defaults."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2040
msgid "unregister I2C driver"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2046
msgid "``struct i2c_driver *driver``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2041
msgid "the driver being unregistered"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2210
msgid "unlocked flavor of i2c_transfer"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2211
#: drivers/i2c/i2c-core-base.c:2283 ../../../driver-api/i2c:47:
#: drivers/i2c/i2c-core-smbus.c:525
msgid "Handle to I2C bus"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2213
#: drivers/i2c/i2c-core-base.c:2285
msgid "``struct i2c_msg *msgs``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2212
#: drivers/i2c/i2c-core-base.c:2284
msgid ""
"One or more messages to execute before STOP is issued to terminate the "
"operation; each message begins with a START."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2215
#: drivers/i2c/i2c-core-base.c:2287
msgid "``int num``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2214
#: drivers/i2c/i2c-core-base.c:2286
msgid "Number of messages to be executed."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2215
#: drivers/i2c/i2c-core-base.c:2287
msgid "Returns negative errno, else the number of messages executed."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2217
msgid ""
"Adapter lock must be held when calling this function. No debug logging takes "
"place."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2282
msgid "execute a single or combined I2C message"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2289
msgid ""
"Note that there is no requirement that each message be sent to the same "
"slave address, although that is the most common model."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2325
msgid "issue a single I2C message transferring data to/from a buffer"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2328
msgid "Where the data is stored"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2329
msgid "How many bytes to transfer, must be less than 64k since msg.len is u16"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2331
msgid "``u16 flags``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2330
msgid "The flags to be used for the message, e.g. I2C_M_RD for reads"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2331
msgid "Returns negative errno, or else the number of bytes transferred."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2356
msgid "get manufacturer, part id and die revision of a device"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2357
msgid "The device to query"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2359
msgid "``struct i2c_device_identity *id``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2358
msgid "The queried information"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2359
msgid "Returns negative errno on error, zero on success."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2387
msgid "get the driver match table entry of a device"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2388
msgid "the device to query. The device must be bound to a driver"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2389
msgid "Returns a pointer to the matching entry if found, NULL otherwise."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2634
msgid "get a DMA safe buffer for the given i2c_msg"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2640
#: drivers/i2c/i2c-core-base.c:2671
msgid "``struct i2c_msg *msg``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2635
msgid "the message to be checked"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2637
msgid "``unsigned int threshold``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2636
msgid ""
"the minimum number of bytes for which using DMA makes sense. Should at least "
"be 1."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2639
msgid ""
"NULL if a DMA safe buffer was not obtained. Use msg->buf with PIO. Or a "
"valid pointer to be used with DMA. After use, release it by calling "
"i2c_put_dma_safe_msg_buf()."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2642
msgid "This function must only be called from process context!"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2668
msgid "release DMA safe buffer and sync with i2c_msg"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2674
msgid "``u8 *buf``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2669
msgid "the buffer obtained from i2c_get_dma_safe_msg_buf(). May be NULL."
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2670
msgid "the message which the buffer corresponds to"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2672
msgid "``bool xferred``"
msgstr ""

#: ../../../driver-api/i2c:44: drivers/i2c/i2c-core-base.c:2671
msgid "bool saying if the message was transferred"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:43
msgid "Incremental CRC8 over the given input data array"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:49
msgid "``u8 crc``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:44
msgid "previous return crc8 value"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:46
msgid "``u8 *p``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:45
msgid "pointer to data buffer."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:47
msgid "``size_t count``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:46
msgid "number of bytes in data buffer."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:47
msgid "Incremental CRC8 over count bytes in the array pointed to by p"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:97
msgid "SMBus \"receive byte\" protocol"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:99
msgid ""
"This executes the SMBus \"receive byte\" protocol, returning negative errno "
"else the byte received from the device."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:116
msgid "SMBus \"send byte\" protocol"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:119
#: drivers/i2c/i2c-core-smbus.c:155
msgid "``u8 value``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:118
msgid "Byte to be sent"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:119
msgid ""
"This executes the SMBus \"send byte\" protocol, returning negative errno "
"else zero on success."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:131
msgid "SMBus \"read byte\" protocol"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:134
#: drivers/i2c/i2c-core-smbus.c:154 drivers/i2c/i2c-core-smbus.c:174
#: drivers/i2c/i2c-core-smbus.c:194 drivers/i2c/i2c-core-smbus.c:214
#: drivers/i2c/i2c-core-smbus.c:246 drivers/i2c/i2c-core-smbus.c:530
#: drivers/i2c/i2c-core-smbus.c:626
msgid "``u8 command``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:133
#: drivers/i2c/i2c-core-smbus.c:153 drivers/i2c/i2c-core-smbus.c:173
#: drivers/i2c/i2c-core-smbus.c:193 drivers/i2c/i2c-core-smbus.c:213
#: drivers/i2c/i2c-core-smbus.c:245 drivers/i2c/i2c-core-smbus.c:625
msgid "Byte interpreted by slave"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:134
msgid ""
"This executes the SMBus \"read byte\" protocol, returning negative errno "
"else a data byte received from the device."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:151
msgid "SMBus \"write byte\" protocol"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:154
msgid "Byte being written"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:155
msgid ""
"This executes the SMBus \"write byte\" protocol, returning negative errno "
"else zero on success."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:171
msgid "SMBus \"read word\" protocol"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:174
msgid ""
"This executes the SMBus \"read word\" protocol, returning negative errno "
"else a 16-bit unsigned \"word\" received from the device."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:191
msgid "SMBus \"write word\" protocol"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:195
msgid "``u16 value``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:194
msgid "16-bit \"word\" being written"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:195
msgid ""
"This executes the SMBus \"write word\" protocol, returning negative errno "
"else zero on success."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:211
msgid "SMBus \"block read\" protocol"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:215
#: drivers/i2c/i2c-core-smbus.c:628
msgid "``u8 *values``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:214
msgid ""
"Byte array into which data will be read; big enough to hold the data "
"returned by the slave.  SMBus allows at most 32 bytes."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:216
msgid ""
"This executes the SMBus \"block read\" protocol, returning negative errno "
"else the number of data bytes in the slave's response."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:219
msgid ""
"Note that using this function requires that the client's adapter support the "
"I2C_FUNC_SMBUS_READ_BLOCK_DATA functionality.  Not all adapter drivers "
"support this; its emulation through I2C messaging relies on a specific "
"mechanism (I2C_M_RECV_LEN) which may not be implemented."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:243
msgid "SMBus \"block write\" protocol"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:247
#: drivers/i2c/i2c-core-smbus.c:627
msgid "``u8 length``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:246
msgid "Size of data block; SMBus allows at most 32 bytes"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:248
msgid "``const u8 *values``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:247
msgid "Byte array which will be written."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:248
msgid ""
"This executes the SMBus \"block write\" protocol, returning negative errno "
"else zero on success."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:524
msgid "execute SMBus protocol operations"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:527
msgid "``u16 addr``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:526
msgid "Address of SMBus slave on that bus"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:528
msgid "``unsigned short flags``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:527
msgid "I2C_CLIENT_* flags (usually zero or I2C_CLIENT_PEC)"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:529
msgid "``char read_write``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:528
msgid "I2C_SMBUS_READ or I2C_SMBUS_WRITE"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:529
msgid "Byte interpreted by slave, for protocols which use such bytes"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:531
msgid "``int protocol``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:530
msgid "SMBus protocol operation to execute, such as I2C_SMBUS_PROC_CALL"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:532
msgid "``union i2c_smbus_data *data``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:531
msgid "Data to be read or written"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:532
msgid ""
"This executes an SMBus protocol operation, and returns a negative errno code "
"else zero on success."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:623
msgid "read block or emulate"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:626
msgid "Size of data block; SMBus allows at most I2C_SMBUS_BLOCK_MAX bytes"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:627
msgid ""
"Byte array into which data will be read; big enough to hold the data "
"returned by the slave.  SMBus allows at most I2C_SMBUS_BLOCK_MAX bytes."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:630
msgid ""
"This executes the SMBus \"block read\" protocol if supported by the adapter. "
"If block read is not supported, it emulates it using either word or byte "
"read protocols depending on availability."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:634
msgid ""
"The addresses of the I2C slave device that are accessed with this function "
"must be mapped to a linear region, so that a block read will have the same "
"effect as a byte read. Before using this function you must double-check if "
"the I2C slave does support exchanging a block transfer with a byte transfer."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:680
msgid "get ara client for SMBus alert support"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:681
msgid "the target adapter"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:683
msgid "``struct i2c_smbus_alert_setup *setup``"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:682
msgid "setup data for the SMBus alert handler"
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:684
msgid "Setup handling of the SMBus alert protocol on a given I2C bus segment."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:686
msgid ""
"Handling can be done either through our IRQ handler, or by the adapter (from "
"its handler, periodic polling, or whatever)."
msgstr ""

#: ../../../driver-api/i2c:47: drivers/i2c/i2c-core-smbus.c:689
msgid ""
"This returns the ara client, which should be saved for later use with "
"i2c_handle_smbus_alert() and ultimately i2c_unregister_device(); or an "
"ERRPTR to indicate an error."
msgstr ""
