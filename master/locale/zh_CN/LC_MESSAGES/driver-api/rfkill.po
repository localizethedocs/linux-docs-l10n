# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/rfkill.rst:3
msgid "rfkill - RF kill switch support"
msgstr ""

#: ../../../driver-api/rfkill.rst:7
msgid "Contents"
msgstr ""

#: ../../../driver-api/rfkill.rst:10
msgid "Introduction"
msgstr ""

#: ../../../driver-api/rfkill.rst:12
msgid ""
"The rfkill subsystem provides a generic interface for disabling any radio "
"transmitter in the system. When a transmitter is blocked, it shall not "
"radiate any power."
msgstr ""

#: ../../../driver-api/rfkill.rst:16
msgid ""
"The subsystem also provides the ability to react on button presses and "
"disable all transmitters of a certain type (or all). This is intended for "
"situations where transmitters need to be turned off, for example on aircraft."
msgstr ""

#: ../../../driver-api/rfkill.rst:21
msgid ""
"The rfkill subsystem has a concept of \"hard\" and \"soft\" block, which "
"differ little in their meaning (block == transmitters off) but rather in "
"whether they can be changed or not:"
msgstr ""

#: ../../../driver-api/rfkill.rst:25
msgid "hard block"
msgstr ""

#: ../../../driver-api/rfkill.rst:26
msgid "read-only radio block that cannot be overridden by software"
msgstr ""

#: ../../../driver-api/rfkill.rst:28
msgid "soft block"
msgstr ""

#: ../../../driver-api/rfkill.rst:29
msgid ""
"writable radio block (need not be readable) that is set by the system "
"software."
msgstr ""

#: ../../../driver-api/rfkill.rst:32
msgid ""
"The rfkill subsystem has two parameters, rfkill.default_state and rfkill."
"master_switch_mode, which are documented in admin-guide/kernel-parameters."
"rst."
msgstr ""

#: ../../../driver-api/rfkill.rst:38
msgid "Implementation details"
msgstr ""

#: ../../../driver-api/rfkill.rst:40
msgid "The rfkill subsystem is composed of three main components:"
msgstr ""

#: ../../../driver-api/rfkill.rst:42
msgid "the rfkill core,"
msgstr ""

#: ../../../driver-api/rfkill.rst:43
msgid ""
"the deprecated rfkill-input module (an input layer handler, being replaced "
"by userspace policy code) and"
msgstr ""

#: ../../../driver-api/rfkill.rst:45
msgid "the rfkill drivers."
msgstr ""

#: ../../../driver-api/rfkill.rst:47
msgid ""
"The rfkill core provides API for kernel drivers to register their radio "
"transmitter with the kernel, methods for turning it on and off, and letting "
"the system know about hardware-disabled states that may be implemented on "
"the device."
msgstr ""

#: ../../../driver-api/rfkill.rst:52
msgid ""
"The rfkill core code also notifies userspace of state changes, and provides "
"ways for userspace to query the current states. See the \"Userspace "
"support\" section below."
msgstr ""

#: ../../../driver-api/rfkill.rst:56
msgid ""
"When the device is hard-blocked (either by a call to rfkill_set_hw_state() "
"or from query_hw_block), set_block() will be invoked for additional software "
"block, but drivers can ignore the method call since they can use the return "
"value of the function rfkill_set_hw_state() to sync the software state "
"instead of keeping track of calls to set_block(). In fact, drivers should "
"use the return value of rfkill_set_hw_state() unless the hardware actually "
"keeps track of soft and hard block separately."
msgstr ""

#: ../../../driver-api/rfkill.rst:66
msgid "Kernel API"
msgstr ""

#: ../../../driver-api/rfkill.rst:68
msgid "Drivers for radio transmitters normally implement an rfkill driver."
msgstr ""

#: ../../../driver-api/rfkill.rst:70
msgid ""
"Platform drivers might implement input devices if the rfkill button is just "
"that, a button. If that button influences the hardware then you need to "
"implement an rfkill driver instead. This also applies if the platform "
"provides a way to turn on/off the transmitter(s)."
msgstr ""

#: ../../../driver-api/rfkill.rst:75
msgid ""
"For some platforms, it is possible that the hardware state changes during "
"suspend/hibernation, in which case it will be necessary to update the rfkill "
"core with the current state at resume time."
msgstr ""

#: ../../../driver-api/rfkill.rst:79
msgid "To create an rfkill driver, driver's Kconfig needs to have::"
msgstr ""

#: ../../../driver-api/rfkill.rst:83
msgid ""
"to ensure the driver cannot be built-in when rfkill is modular. The !RFKILL "
"case allows the driver to be built when rfkill is not configured, in which "
"case all rfkill API can still be used but will be provided by static inlines "
"which compile to almost nothing."
msgstr ""

#: ../../../driver-api/rfkill.rst:88
msgid ""
"Calling rfkill_set_hw_state() when a state change happens is required from "
"rfkill drivers that control devices that can be hard-blocked unless they "
"also assign the poll_hw_block() callback (then the rfkill core will poll the "
"device). Don't do this unless you cannot get the event in any other way."
msgstr ""

#: ../../../driver-api/rfkill.rst:93
msgid ""
"rfkill provides per-switch LED triggers, which can be used to drive LEDs "
"according to the switch state (LED_FULL when blocked, LED_OFF otherwise)."
msgstr ""

#: ../../../driver-api/rfkill.rst:98
msgid "Userspace support"
msgstr ""

#: ../../../driver-api/rfkill.rst:100
msgid ""
"The recommended userspace interface to use is /dev/rfkill, which is a misc "
"character device that allows userspace to obtain and set the state of rfkill "
"devices and sets of devices. It also notifies userspace about device "
"addition and removal. The API is a simple read/write API that is defined in "
"linux/rfkill.h, with one ioctl that allows turning off the deprecated input "
"handler in the kernel for the transition period."
msgstr ""

#: ../../../driver-api/rfkill.rst:107
msgid ""
"Except for the one ioctl, communication with the kernel is done via read() "
"and write() of instances of 'struct rfkill_event'. In this structure, the "
"soft and hard block are properly separated (unlike sysfs, see below) and "
"userspace is able to get a consistent snapshot of all rfkill devices in the "
"system. Also, it is possible to switch all rfkill drivers (or all drivers of "
"a specified type) into a state which also updates the default state for "
"hotplugged devices."
msgstr ""

#: ../../../driver-api/rfkill.rst:115
msgid ""
"After an application opens /dev/rfkill, it can read the current state of all "
"devices. Changes can be obtained by either polling the descriptor for "
"hotplug or state change events or by listening for uevents emitted by the "
"rfkill core framework."
msgstr ""

#: ../../../driver-api/rfkill.rst:120
msgid ""
"Additionally, each rfkill device is registered in sysfs and emits uevents."
msgstr ""

#: ../../../driver-api/rfkill.rst:122
msgid ""
"rfkill devices issue uevents (with an action of \"change\"), with the "
"following environment variables set::"
msgstr ""

#: ../../../driver-api/rfkill.rst:129
msgid ""
"The content of these variables corresponds to the \"name\", \"state\" and "
"\"type\" sysfs files explained above."
msgstr ""

#: ../../../driver-api/rfkill.rst:132
msgid ""
"For further details consult Documentation/ABI/stable/sysfs-class-rfkill."
msgstr ""
