# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-20 11:24+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/serial/serial-rs485.rst:3
msgid "RS485 Serial Communications"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:6
msgid "1. Introduction"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:8
msgid ""
"EIA-485, also known as TIA/EIA-485 or RS-485, is a standard defining the "
"electrical characteristics of drivers and receivers for use in balanced "
"digital multipoint systems. This standard is widely used for communications "
"in industrial automation because it can be used effectively over long "
"distances and in electrically noisy environments."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:16
msgid "2. Hardware-related Considerations"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:18
msgid ""
"Some CPUs/UARTs (e.g., Atmel AT91 or 16C950 UART) contain a built-in half-"
"duplex mode capable of automatically controlling line direction by toggling "
"RTS or DTR signals. That can be used to control external half-duplex "
"hardware like an RS485 transceiver or any RS232-connected half-duplex "
"devices like some modems."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:24
msgid ""
"For these microcontrollers, the Linux driver should be made capable of "
"working in both modes, and proper ioctls (see later) should be made "
"available at user-level to allow switching from one mode to the other, and "
"vice versa."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:30
msgid "3. Data Structures Already Available in the Kernel"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:32
msgid ""
"The Linux kernel provides the struct serial_rs485 to handle RS485 "
"communications. This data structure is used to set and configure RS485 "
"parameters in the platform data and in ioctls."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:36
msgid ""
"The device tree can also provide RS485 boot time parameters [#DT-bindings]_. "
"The serial core fills the struct serial_rs485 from the values given by the "
"device tree when the driver calls uart_get_rs485_mode()."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:41
msgid ""
"Any driver for devices capable of working both as RS232 and RS485 should "
"implement the ``rs485_config`` callback and provide ``rs485_supported`` in "
"the ``struct uart_port``. The serial core calls ``rs485_config`` to do the "
"device specific part in response to TIOCSRS485 ioctl (see below). The "
"``rs485_config`` callback receives a pointer to a sanitizated struct "
"serial_rs485. The struct serial_rs485 userspace provides is sanitized before "
"calling ``rs485_config`` using ``rs485_supported`` that indicates what RS485 "
"features the driver supports for the ``struct uart_port``. TIOCGRS485 ioctl "
"can be used to read back the struct serial_rs485 matching to the current "
"configuration."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:112
msgid "serial interface for controlling RS485 settings."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:116
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:142
msgid "**Members**"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:113
msgid "``flags``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:114
msgid "RS485 feature flags."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:114
msgid "``delay_rts_before_send``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:115
msgid "Delay before send (milliseconds)."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:115
msgid "``delay_rts_after_send``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:116
msgid "Delay after send (milliseconds)."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:122
msgid "``padding``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:123
msgid ""
"Deprecated, use **padding0** and **padding1** instead. Do not use with "
"**addr_recv** and **addr_dest** (due to overlap)."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:1
msgid "``{unnamed_struct}``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:116
msgid "``addr_recv``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:117
msgid ""
"Receive filter for RS485 addressing mode (used only when "
"``SER_RS485_ADDR_RECV`` is set)."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:118
msgid "``addr_dest``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:119
msgid ""
"Destination address for RS485 addressing mode (used only when "
"``SER_RS485_ADDR_DEST`` is set)."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:120
msgid "``padding0``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:121
#: include/uapi/linux/serial.h:122
msgid "Padding (set to zero)."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:121
msgid "``padding1``"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:125
msgid "**Description**"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:125
msgid ""
"Serial interface for controlling RS485 settings on chips with suitable "
"support. Set with TIOCSRS485 and get with TIOCGRS485 if supported by your "
"platform. The set function returns the new state, with any unsupported bits "
"reverted appropriately."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:130
msgid "The flag bits are:"
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:132
msgid "``SER_RS485_ENABLED``         - RS485 enabled."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:133
msgid "``SER_RS485_RTS_ON_SEND``     - Logical level for RTS pin when sending."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:134
msgid "``SER_RS485_RTS_AFTER_SEND``  - Logical level for RTS pin after sent."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:135
msgid "``SER_RS485_RX_DURING_TX``    - Full-duplex RS485 line."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:136
msgid "``SER_RS485_TERMINATE_BUS``   - Enable bus termination (if supported)."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:137
msgid "``SER_RS485_ADDRB``           - Enable RS485 addressing mode."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:138
msgid ""
"``SER_RS485_ADDR_RECV`` - Receive address filter (enables **addr_recv**). "
"Requires ``SER_RS485_ADDRB``."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:139
msgid ""
"``SER_RS485_ADDR_DEST`` - Destination address (enables **addr_dest**). "
"Requires ``SER_RS485_ADDRB``."
msgstr ""

#: ../../../driver-api/serial/serial-rs485:52: include/uapi/linux/serial.h:140
msgid ""
"``SER_RS485_MODE_RS422``      - Enable RS422. Requires ``SER_RS485_ENABLED``."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:56
msgid "4. Usage from user-level"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:58
msgid ""
"From user-level, RS485 configuration can be get/set using the previous "
"ioctls. For instance, to set RS485 you can use the following code::"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:108
msgid "5. Multipoint Addressing"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:110
msgid ""
"The Linux kernel provides addressing mode for multipoint RS-485 serial "
"communications line. The addressing mode is enabled with ``SER_RS485_ADDRB`` "
"flag in struct serial_rs485. The struct serial_rs485 has two additional "
"flags and fields for enabling receive and destination addresses."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:116
msgid "Address mode flags:"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:117
msgid ""
"``SER_RS485_ADDRB``: Enabled addressing mode (sets also ADDRB in termios)."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:118
msgid "``SER_RS485_ADDR_RECV``: Receive (filter) address enabled."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:119
msgid "``SER_RS485_ADDR_DEST``: Set destination address."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:121
msgid "Address fields (enabled with corresponding ``SER_RS485_ADDR_*`` flag):"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:122
msgid "``addr_recv``: Receive address."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:123
msgid "``addr_dest``: Destination address."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:125
msgid ""
"Once a receive address is set, the communication can occur only with the "
"particular device and other peers are filtered out. It is left up to the "
"receiver side to enforce the filtering. Receive address will be cleared if "
"``SER_RS485_ADDR_RECV`` is not set."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:130
msgid "Note: not all devices supporting RS485 support multipoint addressing."
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:133
msgid "6. References"
msgstr ""

#: ../../../driver-api/serial/serial-rs485.rst:135
msgid "Documentation/devicetree/bindings/serial/rs485.txt"
msgstr ""
