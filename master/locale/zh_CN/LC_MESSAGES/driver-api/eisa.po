# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/eisa.rst:3
msgid "EISA bus support"
msgstr ""

#: ../../../driver-api/eisa.rst:0
msgid "Author"
msgstr ""

#: ../../../driver-api/eisa.rst:5
msgid "Marc Zyngier <maz@wild-wind.fr.eu.org>"
msgstr ""

#: ../../../driver-api/eisa.rst:7
msgid ""
"This document groups random notes about porting EISA drivers to the new EISA/"
"sysfs API."
msgstr ""

#: ../../../driver-api/eisa.rst:10
msgid ""
"Starting from version 2.5.59, the EISA bus is almost given the same status "
"as other much more mainstream busses such as PCI or USB. This has been "
"possible through sysfs, which defines a nice enough set of abstractions to "
"manage busses, devices and drivers."
msgstr ""

#: ../../../driver-api/eisa.rst:15
msgid ""
"Although the new API is quite simple to use, converting existing drivers to "
"the new infrastructure is not an easy task (mostly because detection code is "
"generally also used to probe ISA cards). Moreover, most EISA drivers are "
"among the oldest Linux drivers so, as you can imagine, some dust has settled "
"here over the years."
msgstr ""

#: ../../../driver-api/eisa.rst:21
msgid "The EISA infrastructure is made up of three parts:"
msgstr ""

#: ../../../driver-api/eisa.rst:23
msgid ""
"The bus code implements most of the generic code. It is shared among all the "
"architectures that the EISA code runs on. It implements bus probing "
"(detecting EISA cards available on the bus), allocates I/O resources, allows "
"fancy naming through sysfs, and offers interfaces for driver to register."
msgstr ""

#: ../../../driver-api/eisa.rst:29
msgid ""
"The bus root driver implements the glue between the bus hardware and the "
"generic bus code. It is responsible for discovering the device implementing "
"the bus, and setting it up to be latter probed by the bus code. This can go "
"from something as simple as reserving an I/O region on x86, to the rather "
"more complex, like the hppa EISA code. This is the part to implement in "
"order to have EISA running on an \"new\" platform."
msgstr ""

#: ../../../driver-api/eisa.rst:37
msgid ""
"The driver offers the bus a list of devices that it manages, and implements "
"the necessary callbacks to probe and release devices whenever told to."
msgstr ""

#: ../../../driver-api/eisa.rst:41
msgid ""
"Every function/structure below lives in <linux/eisa.h>, which depends "
"heavily on <linux/device.h>."
msgstr ""

#: ../../../driver-api/eisa.rst:45
msgid "Bus root driver"
msgstr ""

#: ../../../driver-api/eisa.rst:51
msgid ""
"The eisa_root_register function is used to declare a device as the root of "
"an EISA bus. The eisa_root_device structure holds a reference to this "
"device, as well as some parameters for probing purposes::"
msgstr ""

#: ../../../driver-api/eisa.rst:67
msgid "node"
msgstr ""

#: ../../../driver-api/eisa.rst:67
msgid "used for eisa_root_register internal purpose"
msgstr ""

#: ../../../driver-api/eisa.rst:68 ../../../driver-api/eisa.rst:155
msgid "dev"
msgstr ""

#: ../../../driver-api/eisa.rst:68
msgid "pointer to the root device"
msgstr ""

#: ../../../driver-api/eisa.rst:69 ../../../driver-api/eisa.rst:153
msgid "res"
msgstr ""

#: ../../../driver-api/eisa.rst:69
msgid "root device I/O resource"
msgstr ""

#: ../../../driver-api/eisa.rst:70
msgid "bus_base_addr"
msgstr ""

#: ../../../driver-api/eisa.rst:70
msgid "slot 0 address on this bus"
msgstr ""

#: ../../../driver-api/eisa.rst:71
msgid "slots"
msgstr ""

#: ../../../driver-api/eisa.rst:71
msgid "max slot number to probe"
msgstr ""

#: ../../../driver-api/eisa.rst:72
msgid "force_probe"
msgstr ""

#: ../../../driver-api/eisa.rst:72
msgid "Probe even when slot 0 is empty (no EISA mainboard)"
msgstr ""

#: ../../../driver-api/eisa.rst:73 ../../../driver-api/eisa.rst:154
msgid "dma_mask"
msgstr ""

#: ../../../driver-api/eisa.rst:73
msgid "Default DMA mask. Usually the bridge device dma_mask."
msgstr ""

#: ../../../driver-api/eisa.rst:74
msgid "bus_nr"
msgstr ""

#: ../../../driver-api/eisa.rst:74
msgid "unique bus id, set by eisa_root_register"
msgstr ""

#: ../../../driver-api/eisa.rst:78
msgid "Driver"
msgstr ""

#: ../../../driver-api/eisa.rst:85
msgid "Clear enough ?"
msgstr ""

#: ../../../driver-api/eisa.rst:100
msgid "id_table"
msgstr ""

#: ../../../driver-api/eisa.rst:100
msgid ""
"an array of NULL terminated EISA id strings, followed by an empty string. "
"Each string can optionally be paired with a driver-dependent value "
"(driver_data)."
msgstr ""

#: ../../../driver-api/eisa.rst:105
msgid "driver"
msgstr ""

#: ../../../driver-api/eisa.rst:105
msgid ""
"a generic driver, such as described in Documentation/driver-api/driver-model/"
"driver.rst. Only .name, .probe and .remove members are mandatory."
msgstr ""

#: ../../../driver-api/eisa.rst:110
msgid "An example is the 3c59x driver::"
msgstr ""

#: ../../../driver-api/eisa.rst:128
msgid "Device"
msgstr ""

#: ../../../driver-api/eisa.rst:130
msgid ""
"The sysfs framework calls .probe and .remove functions upon device discovery "
"and removal (note that the .remove function is only called when driver is "
"built as a module)."
msgstr ""

#: ../../../driver-api/eisa.rst:134
msgid ""
"Both functions are passed a pointer to a 'struct device', which is "
"encapsulated in a 'struct eisa_device' described as follows::"
msgstr ""

#: ../../../driver-api/eisa.rst:148
msgid "id"
msgstr ""

#: ../../../driver-api/eisa.rst:148
msgid ""
"EISA id, as read from device. id.driver_data is set from the matching driver "
"EISA id."
msgstr ""

#: ../../../driver-api/eisa.rst:150
msgid "slot"
msgstr ""

#: ../../../driver-api/eisa.rst:150
msgid "slot number which the device was detected on"
msgstr ""

#: ../../../driver-api/eisa.rst:151
msgid "state"
msgstr ""

#: ../../../driver-api/eisa.rst:151
msgid ""
"set of flags indicating the state of the device. Current flags are "
"EISA_CONFIG_ENABLED and EISA_CONFIG_FORCED."
msgstr ""

#: ../../../driver-api/eisa.rst:153
msgid "set of four 256 bytes I/O regions allocated to this device"
msgstr ""

#: ../../../driver-api/eisa.rst:154
msgid "DMA mask set from the parent device."
msgstr ""

#: ../../../driver-api/eisa.rst:155
msgid "generic device (see Documentation/driver-api/driver-model/device.rst)"
msgstr ""

#: ../../../driver-api/eisa.rst:158
msgid ""
"You can get the 'struct eisa_device' from 'struct device' using the "
"'to_eisa_device' macro."
msgstr ""

#: ../../../driver-api/eisa.rst:162
msgid "Misc stuff"
msgstr ""

#: ../../../driver-api/eisa.rst:168
msgid "Stores data into the device's driver_data area."
msgstr ""

#: ../../../driver-api/eisa.rst:174
msgid "Gets the pointer previously stored into the device's driver_data area."
msgstr ""

#: ../../../driver-api/eisa.rst:180
msgid ""
"Returns the region number (0 <= x < EISA_MAX_RESOURCES) of a given address."
msgstr ""

#: ../../../driver-api/eisa.rst:184
msgid "Kernel parameters"
msgstr ""

#: ../../../driver-api/eisa.rst:186
msgid "eisa_bus.enable_dev"
msgstr ""

#: ../../../driver-api/eisa.rst:187
msgid ""
"A comma-separated list of slots to be enabled, even if the firmware set the "
"card as disabled. The driver must be able to properly initialize the device "
"in such conditions."
msgstr ""

#: ../../../driver-api/eisa.rst:191
msgid "eisa_bus.disable_dev"
msgstr ""

#: ../../../driver-api/eisa.rst:192
msgid ""
"A comma-separated list of slots to be disabled, even if the firmware set the "
"card as enabled. The driver won't be called to handle this device."
msgstr ""

#: ../../../driver-api/eisa.rst:196
msgid "virtual_root.force_probe"
msgstr ""

#: ../../../driver-api/eisa.rst:197
msgid ""
"Force the probing code to probe EISA slots even when it cannot find an EISA "
"compliant mainboard (nothing appears on slot 0). Defaults to 0 (don't "
"force), and set to 1 (force probing) when CONFIG_EISA_VLB_PRIMING is set."
msgstr ""

#: ../../../driver-api/eisa.rst:203
msgid "Random notes"
msgstr ""

#: ../../../driver-api/eisa.rst:205
msgid ""
"Converting an EISA driver to the new API mostly involves *deleting* code "
"(since probing is now in the core EISA code). Unfortunately, most drivers "
"share their probing routine between ISA, and EISA. Special care must be "
"taken when ripping out the EISA code, so other busses won't suffer from "
"these surgical strikes..."
msgstr ""

#: ../../../driver-api/eisa.rst:211
msgid ""
"You *must not* expect any EISA device to be detected when returning from "
"eisa_driver_register, since the chances are that the bus has not yet been "
"probed. In fact, that's what happens most of the time (the bus root driver "
"usually kicks in rather late in the boot process). Unfortunately, most "
"drivers are doing the probing by themselves, and expect to have explored the "
"whole machine when they exit their probe routine."
msgstr ""

#: ../../../driver-api/eisa.rst:219
msgid ""
"For example, switching your favorite EISA SCSI card to the \"hotplug\" model "
"is \"the right thing\"(tm)."
msgstr ""

#: ../../../driver-api/eisa.rst:223
msgid "Thanks"
msgstr ""

#: ../../../driver-api/eisa.rst:225
msgid "I'd like to thank the following people for their help:"
msgstr ""

#: ../../../driver-api/eisa.rst:227
msgid "Xavier Benigni for lending me a wonderful Alpha Jensen,"
msgstr ""

#: ../../../driver-api/eisa.rst:228
msgid "James Bottomley, Jeff Garzik for getting this stuff into the kernel,"
msgstr ""

#: ../../../driver-api/eisa.rst:229
msgid "Andries Brouwer for contributing numerous EISA ids,"
msgstr ""

#: ../../../driver-api/eisa.rst:230
msgid "Catrin Jones for coping with far too many machines at home."
msgstr ""
