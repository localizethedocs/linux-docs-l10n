# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/libata.rst:3
msgid "libATA Developer's Guide"
msgstr ""

#: ../../../driver-api/libata.rst:0
msgid "Author"
msgstr ""

#: ../../../driver-api/libata.rst:5
msgid "Jeff Garzik"
msgstr ""

#: ../../../driver-api/libata.rst:8
msgid "Introduction"
msgstr ""

#: ../../../driver-api/libata.rst:10
msgid ""
"libATA is a library used inside the Linux kernel to support ATA host "
"controllers and devices. libATA provides an ATA driver API, class transports "
"for ATA and ATAPI devices, and SCSI<->ATA translation for ATA devices "
"according to the T10 SAT specification."
msgstr ""

#: ../../../driver-api/libata.rst:15
msgid ""
"This Guide documents the libATA driver API, library functions, library "
"internals, and a couple sample ATA low-level drivers."
msgstr ""

#: ../../../driver-api/libata.rst:19
msgid "libata Driver API"
msgstr ""

#: ../../../driver-api/libata.rst:21
msgid ""
":c:type:`struct ata_port_operations <ata_port_operations>` is defined for "
"every low-level libata hardware driver, and it controls how the low-level "
"driver interfaces with the ATA and SCSI layers."
msgstr ""

#: ../../../driver-api/libata.rst:26
msgid ""
"FIS-based drivers will hook into the system with ``->qc_prep()`` and ``-"
">qc_issue()`` high-level hooks. Hardware which behaves in a manner similar "
"to PCI IDE hardware may utilize several generic helpers, defining at a bare "
"minimum the bus I/O addresses of the ATA shadow register blocks."
msgstr ""

#: ../../../driver-api/libata.rst:33
msgid ":c:type:`struct ata_port_operations <ata_port_operations>`"
msgstr ""

#: ../../../driver-api/libata.rst:36
msgid "Post-IDENTIFY device configuration"
msgstr ""

#: ../../../driver-api/libata.rst:43
msgid ""
"Called after IDENTIFY [PACKET] DEVICE is issued to each device found. "
"Typically used to apply device-specific fixups prior to issue of SET "
"FEATURES - XFER MODE, and prior to operation."
msgstr ""

#: ../../../driver-api/libata.rst:47
msgid "This entry may be specified as NULL in ata_port_operations."
msgstr ""

#: ../../../driver-api/libata.rst:50
msgid "Set PIO/DMA mode"
msgstr ""

#: ../../../driver-api/libata.rst:60
msgid ""
"Hooks called prior to the issue of SET FEATURES - XFER MODE command. The "
"optional ``->mode_filter()`` hook is called when libata has built a mask of "
"the possible modes. This is passed to the ``->mode_filter()`` function which "
"should return a mask of valid modes after filtering those unsuitable due to "
"hardware limits. It is not valid to use this interface to add modes."
msgstr ""

#: ../../../driver-api/libata.rst:67
msgid ""
"``dev->pio_mode`` and ``dev->dma_mode`` are guaranteed to be valid when ``-"
">set_piomode()`` and when ``->set_dmamode()`` is called. The timings for any "
"other drive sharing the cable will also be valid at this point. That is the "
"library records the decisions for the modes of each drive on a channel "
"before it attempts to set any of them."
msgstr ""

#: ../../../driver-api/libata.rst:73
msgid ""
"``->post_set_mode()`` is called unconditionally, after the SET FEATURES - "
"XFER MODE command completes successfully."
msgstr ""

#: ../../../driver-api/libata.rst:76
msgid ""
"``->set_piomode()`` is always called (if present), but ``->set_dma_mode()`` "
"is only called if DMA is possible."
msgstr ""

#: ../../../driver-api/libata.rst:80
msgid "Taskfile read/write"
msgstr ""

#: ../../../driver-api/libata.rst:88
msgid ""
"``->tf_load()`` is called to load the given taskfile into hardware "
"registers / DMA buffers. ``->tf_read()`` is called to read the hardware "
"registers / DMA buffers, to obtain the current set of taskfile register "
"values. Most drivers for taskfile-based hardware (PIO or MMIO) use :c:func:"
"`ata_sff_tf_load` and :c:func:`ata_sff_tf_read` for these hooks."
msgstr ""

#: ../../../driver-api/libata.rst:95
msgid "PIO data read/write"
msgstr ""

#: ../../../driver-api/libata.rst:102
msgid ""
"All bmdma-style drivers must implement this hook. This is the low-level "
"operation that actually copies the data bytes during a PIO data transfer. "
"Typically the driver will choose one of :c:func:`ata_sff_data_xfer`, or :c:"
"func:`ata_sff_data_xfer32`."
msgstr ""

#: ../../../driver-api/libata.rst:108
msgid "ATA command execute"
msgstr ""

#: ../../../driver-api/libata.rst:115
msgid ""
"causes an ATA command, previously loaded with ``->tf_load()``, to be "
"initiated in hardware. Most drivers for taskfile-based hardware use :c:func:"
"`ata_sff_exec_command` for this hook."
msgstr ""

#: ../../../driver-api/libata.rst:120
msgid "Per-cmd ATAPI DMA capabilities filter"
msgstr ""

#: ../../../driver-api/libata.rst:127 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:4741
msgid ""
"Allow low-level driver to filter ATA PACKET commands, returning a status "
"indicating whether or not it is OK to use DMA for the supplied PACKET "
"command."
msgstr ""

#: ../../../driver-api/libata.rst:131
msgid ""
"This hook may be specified as NULL, in which case libata will assume that "
"atapi dma can be supported."
msgstr ""

#: ../../../driver-api/libata.rst:135
msgid "Read specific ATA shadow registers"
msgstr ""

#: ../../../driver-api/libata.rst:143
msgid ""
"Reads the Status/AltStatus ATA shadow register from hardware. On some "
"hardware, reading the Status register has the side effect of clearing the "
"interrupt condition. Most drivers for taskfile-based hardware use :c:func:"
"`ata_sff_check_status` for this hook."
msgstr ""

#: ../../../driver-api/libata.rst:149
msgid "Write specific ATA shadow register"
msgstr ""

#: ../../../driver-api/libata.rst:156
msgid ""
"Write the device control ATA shadow register to the hardware. Most drivers "
"don't need to define this."
msgstr ""

#: ../../../driver-api/libata.rst:160
msgid "Select ATA device on bus"
msgstr ""

#: ../../../driver-api/libata.rst:167
msgid ""
"Issues the low-level hardware command(s) that causes one of N hardware "
"devices to be considered 'selected' (active and available for use) on the "
"ATA bus. This generally has no meaning on FIS-based devices."
msgstr ""

#: ../../../driver-api/libata.rst:171
msgid ""
"Most drivers for taskfile-based hardware use :c:func:`ata_sff_dev_select` "
"for this hook."
msgstr ""

#: ../../../driver-api/libata.rst:175
msgid "Private tuning method"
msgstr ""

#: ../../../driver-api/libata.rst:182
msgid ""
"By default libata performs drive and controller tuning in accordance with "
"the ATA timing rules and also applies blacklists and cable limits. Some "
"controllers need special handling and have custom tuning rules, typically "
"raid controllers that use ATA commands but do not actually do drive timing."
msgstr ""

#: ../../../driver-api/libata.rst:188
msgid "**Warning**"
msgstr ""

#: ../../../driver-api/libata.rst:190
msgid ""
"This hook should not be used to replace the standard controller tuning logic "
"when a controller has quirks. Replacing the default tuning logic in that "
"case would bypass handling for drive and bridge quirks that may be important "
"to data reliability. If a controller needs to filter the mode selection it "
"should use the mode_filter hook instead."
msgstr ""

#: ../../../driver-api/libata.rst:198
msgid "Control PCI IDE BMDMA engine"
msgstr ""

#: ../../../driver-api/libata.rst:208
msgid ""
"When setting up an IDE BMDMA transaction, these hooks arm (``-"
">bmdma_setup``), fire (``->bmdma_start``), and halt (``->bmdma_stop``) the "
"hardware's DMA engine. ``->bmdma_status`` is used to read the standard PCI "
"IDE DMA Status register."
msgstr ""

#: ../../../driver-api/libata.rst:213
msgid ""
"These hooks are typically either no-ops, or simply not implemented, in FIS-"
"based drivers."
msgstr ""

#: ../../../driver-api/libata.rst:216
msgid ""
"Most legacy IDE drivers use :c:func:`ata_bmdma_setup` for the :c:func:"
"`bmdma_setup` hook. :c:func:`ata_bmdma_setup` will write the pointer to the "
"PRD table to the IDE PRD Table Address register, enable DMA in the DMA "
"Command register, and call :c:func:`exec_command` to begin the transfer."
msgstr ""

#: ../../../driver-api/libata.rst:221
msgid ""
"Most legacy IDE drivers use :c:func:`ata_bmdma_start` for the :c:func:"
"`bmdma_start` hook. :c:func:`ata_bmdma_start` will write the ATA_DMA_START "
"flag to the DMA Command register."
msgstr ""

#: ../../../driver-api/libata.rst:225
msgid ""
"Many legacy IDE drivers use :c:func:`ata_bmdma_stop` for the :c:func:"
"`bmdma_stop` hook. :c:func:`ata_bmdma_stop` clears the ATA_DMA_START flag in "
"the DMA command register."
msgstr ""

#: ../../../driver-api/libata.rst:229
msgid ""
"Many legacy IDE drivers use :c:func:`ata_bmdma_status` as the :c:func:"
"`bmdma_status` hook."
msgstr ""

#: ../../../driver-api/libata.rst:233
msgid "High-level taskfile hooks"
msgstr ""

#: ../../../driver-api/libata.rst:241
msgid ""
"Higher-level hooks, these two hooks can potentially supersede several of the "
"above taskfile/DMA engine hooks. ``->qc_prep`` is called after the buffers "
"have been DMA-mapped, and is typically used to populate the hardware's DMA "
"scatter-gather table. Some drivers use the standard :c:func:"
"`ata_bmdma_qc_prep` and :c:func:`ata_bmdma_dumb_qc_prep` helper functions, "
"but more advanced drivers roll their own."
msgstr ""

#: ../../../driver-api/libata.rst:248
msgid ""
"``->qc_issue`` is used to make a command active, once the hardware and S/G "
"tables have been prepared. IDE BMDMA drivers use the helper function :c:func:"
"`ata_sff_qc_issue` for taskfile protocol-based dispatch. More advanced "
"drivers implement their own ``->qc_issue``."
msgstr ""

#: ../../../driver-api/libata.rst:253
msgid ""
":c:func:`ata_sff_qc_issue` calls ``->sff_tf_load()``, ``->bmdma_setup()``, "
"and ``->bmdma_start()`` as necessary to initiate a transfer."
msgstr ""

#: ../../../driver-api/libata.rst:257
msgid "Exception and probe handling (EH)"
msgstr ""

#: ../../../driver-api/libata.rst:265
msgid ""
":c:func:`ata_port_freeze` is called when HSM violations or some other "
"condition disrupts normal operation of the port. A frozen port is not "
"allowed to perform any operation until the port is thawed, which usually "
"follows a successful reset."
msgstr ""

#: ../../../driver-api/libata.rst:270
msgid ""
"The optional ``->freeze()`` callback can be used for freezing the port "
"hardware-wise (e.g. mask interrupt and stop DMA engine). If a port cannot be "
"frozen hardware-wise, the interrupt handler must ack and clear interrupts "
"unconditionally while the port is frozen."
msgstr ""

#: ../../../driver-api/libata.rst:275
msgid ""
"The optional ``->thaw()`` callback is called to perform the opposite of ``-"
">freeze()``: prepare the port for normal operation once again. Unmask "
"interrupts, start DMA engine, etc."
msgstr ""

#: ../../../driver-api/libata.rst:284
msgid ""
"``->error_handler()`` is a driver's hook into probe, hotplug, and recovery "
"and other exceptional conditions. The primary responsibility of an "
"implementation is to call :c:func:`ata_std_error_handler`."
msgstr ""

#: ../../../driver-api/libata.rst:288
msgid ""
":c:func:`ata_std_error_handler` will perform a standard error handling "
"sequence to resurect failed devices, detach lost devices and add new devices "
"(if any). This function will call the various reset operations for a port, "
"as needed. These operations are as follows."
msgstr ""

#: ../../../driver-api/libata.rst:293
msgid ""
"The 'prereset' operation (which may be NULL) is called during an EH reset, "
"before any other action is taken."
msgstr ""

#: ../../../driver-api/libata.rst:296
msgid ""
"The 'postreset' hook (which may be NULL) is called after the EH reset is "
"performed. Based on existing conditions, severity of the problem, and "
"hardware capabilities,"
msgstr ""

#: ../../../driver-api/libata.rst:300
msgid ""
"Either the 'softreset' operation or the 'hardreset' operation will be called "
"to perform the low-level EH reset. If both operations are defined, "
"'hardreset' is preferred and used. If both are not defined, no low-level "
"reset is performed and EH assumes that an ATA class device is connected "
"through the link."
msgstr ""

#: ../../../driver-api/libata.rst:311
msgid ""
"Perform any hardware-specific actions necessary to finish processing after "
"executing a probe-time or EH-time command via :c:func:`ata_exec_internal`."
msgstr ""

#: ../../../driver-api/libata.rst:316
msgid "Hardware interrupt handling"
msgstr ""

#: ../../../driver-api/libata.rst:324
msgid ""
"``->irq_handler`` is the interrupt handling routine registered with the "
"system, by libata. ``->irq_clear`` is called during probe just before the "
"interrupt handler is registered, to be sure hardware is quiet."
msgstr ""

#: ../../../driver-api/libata.rst:328
msgid ""
"The second argument, dev_instance, should be cast to a pointer to :c:type:"
"`struct ata_host_set <ata_host_set>`."
msgstr ""

#: ../../../driver-api/libata.rst:331
msgid ""
"Most legacy IDE drivers use :c:func:`ata_sff_interrupt` for the irq_handler "
"hook, which scans all ports in the host_set, determines which queued command "
"was active (if any), and calls ata_sff_host_intr(ap,qc)."
msgstr ""

#: ../../../driver-api/libata.rst:335
msgid ""
"Most legacy IDE drivers use :c:func:`ata_sff_irq_clear` for the :c:func:"
"`irq_clear` hook, which simply clears the interrupt and error flags in the "
"DMA status register."
msgstr ""

#: ../../../driver-api/libata.rst:340
msgid "SATA phy read/write"
msgstr ""

#: ../../../driver-api/libata.rst:350
msgid ""
"Read and write standard SATA phy registers. sc_reg is one of SCR_STATUS, "
"SCR_CONTROL, SCR_ERROR, or SCR_ACTIVE."
msgstr ""

#: ../../../driver-api/libata.rst:354
msgid "Init and shutdown"
msgstr ""

#: ../../../driver-api/libata.rst:363
msgid ""
"``->port_start()`` is called just after the data structures for each port "
"are initialized. Typically this is used to alloc per-port DMA buffers / "
"tables / rings, enable DMA engines, and similar tasks. Some drivers also use "
"this entry point as a chance to allocate driver-private memory for ``ap-"
">private_data``."
msgstr ""

#: ../../../driver-api/libata.rst:369
msgid ""
"Many drivers use :c:func:`ata_port_start` as this hook or call it from their "
"own :c:func:`port_start` hooks. :c:func:`ata_port_start` allocates space for "
"a legacy IDE PRD table and returns."
msgstr ""

#: ../../../driver-api/libata.rst:373
msgid ""
"``->port_stop()`` is called after ``->host_stop()``. Its sole function is to "
"release DMA/memory resources, now that they are no longer actively being "
"used. Many drivers also free driver-private data from port at this time."
msgstr ""

#: ../../../driver-api/libata.rst:377
msgid ""
"``->host_stop()`` is called after all ``->port_stop()`` calls have "
"completed. The hook must finalize hardware shutdown, release DMA and other "
"resources, etc. This hook may be specified as NULL, in which case it is not "
"called."
msgstr ""

#: ../../../driver-api/libata.rst:383
msgid "Error handling"
msgstr ""

#: ../../../driver-api/libata.rst:385
msgid ""
"This chapter describes how errors are handled under libata. Readers are "
"advised to read SCSI EH (Documentation/scsi/scsi_eh.rst) and ATA exceptions "
"doc first."
msgstr ""

#: ../../../driver-api/libata.rst:390
msgid "Origins of commands"
msgstr ""

#: ../../../driver-api/libata.rst:392
msgid ""
"In libata, a command is represented with :c:type:`struct ata_queued_cmd "
"<ata_queued_cmd>` or qc. qc's are preallocated during port initialization "
"and repetitively used for command executions. Currently only one qc is "
"allocated per port but yet-to-be-merged NCQ branch allocates one for each "
"tag and maps each qc to NCQ tag 1-to-1."
msgstr ""

#: ../../../driver-api/libata.rst:399
msgid ""
"libata commands can originate from two sources - libata itself and SCSI "
"midlayer. libata internal commands are used for initialization and error "
"handling. All normal blk requests and commands for SCSI emulation are passed "
"as SCSI commands through queuecommand callback of SCSI host template."
msgstr ""

#: ../../../driver-api/libata.rst:406
msgid "How commands are issued"
msgstr ""

#: ../../../driver-api/libata.rst:408
msgid "Internal commands"
msgstr ""

#: ../../../driver-api/libata.rst:409
msgid ""
"Once allocated qc's taskfile is initialized for the command to be executed. "
"qc currently has two mechanisms to notify completion. One is via ``qc-"
">complete_fn()`` callback and the other is completion ``qc->waiting``. ``qc-"
">complete_fn()`` callback is the asynchronous path used by normal SCSI "
"translated commands and ``qc->waiting`` is the synchronous (issuer sleeps in "
"process context) path used by internal commands."
msgstr ""

#: ../../../driver-api/libata.rst:417
msgid ""
"Once initialization is complete, host_set lock is acquired and the qc is "
"issued."
msgstr ""

#: ../../../driver-api/libata.rst:420
msgid "SCSI commands"
msgstr ""

#: ../../../driver-api/libata.rst:421
msgid ""
"All libata drivers use :c:func:`ata_scsi_queuecmd` as ``hostt-"
">queuecommand`` callback. scmds can either be simulated or translated. No qc "
"is involved in processing a simulated scmd. The result is computed right "
"away and the scmd is completed."
msgstr ""

#: ../../../driver-api/libata.rst:426
msgid ""
"``qc->complete_fn()`` callback is used for completion notification. ATA "
"commands use :c:func:`ata_scsi_qc_complete` while ATAPI commands use :c:func:"
"`atapi_qc_complete`. Both functions end up calling ``qc->scsidone`` to "
"notify upper layer when the qc is finished. After translation is completed, "
"the qc is issued with :c:func:`ata_qc_issue`."
msgstr ""

#: ../../../driver-api/libata.rst:432
msgid ""
"Note that SCSI midlayer invokes hostt->queuecommand while holding host_set "
"lock, so all above occur while holding host_set lock."
msgstr ""

#: ../../../driver-api/libata.rst:436
msgid "How commands are processed"
msgstr ""

#: ../../../driver-api/libata.rst:438
msgid ""
"Depending on which protocol and which controller are used, commands are "
"processed differently. For the purpose of discussion, a controller which "
"uses taskfile interface and all standard callbacks is assumed."
msgstr ""

#: ../../../driver-api/libata.rst:442
msgid ""
"Currently 6 ATA command protocols are used. They can be sorted into the "
"following four categories according to how they are processed."
msgstr ""

#: ../../../driver-api/libata.rst:445
msgid "ATA NO DATA or DMA"
msgstr ""

#: ../../../driver-api/libata.rst:446
msgid ""
"ATA_PROT_NODATA and ATA_PROT_DMA fall into this category. These types of "
"commands don't require any software intervention once issued. Device will "
"raise interrupt on completion."
msgstr ""

#: ../../../driver-api/libata.rst:450
msgid "ATA PIO"
msgstr ""

#: ../../../driver-api/libata.rst:451
msgid ""
"ATA_PROT_PIO is in this category. libata currently implements PIO with "
"polling. ATA_NIEN bit is set to turn off interrupt and pio_task on ata_wq "
"performs polling and IO."
msgstr ""

#: ../../../driver-api/libata.rst:455
msgid "ATAPI NODATA or DMA"
msgstr ""

#: ../../../driver-api/libata.rst:456
msgid ""
"ATA_PROT_ATAPI_NODATA and ATA_PROT_ATAPI_DMA are in this category. "
"packet_task is used to poll BSY bit after issuing PACKET command. Once BSY "
"is turned off by the device, packet_task transfers CDB and hands off "
"processing to interrupt handler."
msgstr ""

#: ../../../driver-api/libata.rst:461
msgid "ATAPI PIO"
msgstr ""

#: ../../../driver-api/libata.rst:462
msgid ""
"ATA_PROT_ATAPI is in this category. ATA_NIEN bit is set and, as in ATAPI "
"NODATA or DMA, packet_task submits cdb. However, after submitting cdb, "
"further processing (data transfer) is handed off to pio_task."
msgstr ""

#: ../../../driver-api/libata.rst:468
msgid "How commands are completed"
msgstr ""

#: ../../../driver-api/libata.rst:470
msgid ""
"Once issued, all qc's are either completed with :c:func:`ata_qc_complete` or "
"time out. For commands which are handled by interrupts, :c:func:"
"`ata_host_intr` invokes :c:func:`ata_qc_complete`, and, for PIO tasks, "
"pio_task invokes :c:func:`ata_qc_complete`. In error cases, packet_task may "
"also complete commands."
msgstr ""

#: ../../../driver-api/libata.rst:476
msgid ":c:func:`ata_qc_complete` does the following."
msgstr ""

#: ../../../driver-api/libata.rst:478
msgid "DMA memory is unmapped."
msgstr ""

#: ../../../driver-api/libata.rst:480
msgid "ATA_QCFLAG_ACTIVE is cleared from qc->flags."
msgstr ""

#: ../../../driver-api/libata.rst:482
msgid ""
":c:expr:`qc->complete_fn` callback is invoked. If the return value of the "
"callback is not zero. Completion is short circuited and :c:func:"
"`ata_qc_complete` returns."
msgstr ""

#: ../../../driver-api/libata.rst:486
msgid ":c:func:`__ata_qc_complete` is called, which does"
msgstr ""

#: ../../../driver-api/libata.rst:488
msgid "``qc->flags`` is cleared to zero."
msgstr ""

#: ../../../driver-api/libata.rst:490
msgid "``ap->active_tag`` and ``qc->tag`` are poisoned."
msgstr ""

#: ../../../driver-api/libata.rst:492
msgid "``qc->waiting`` is cleared & completed (in that order)."
msgstr ""

#: ../../../driver-api/libata.rst:494
msgid "qc is deallocated by clearing appropriate bit in ``ap->qactive``."
msgstr ""

#: ../../../driver-api/libata.rst:496
msgid ""
"So, it basically notifies upper layer and deallocates qc. One exception is "
"short-circuit path in #3 which is used by :c:func:`atapi_qc_complete`."
msgstr ""

#: ../../../driver-api/libata.rst:499
msgid ""
"For all non-ATAPI commands, whether it fails or not, almost the same code "
"path is taken and very little error handling takes place. A qc is completed "
"with success status if it succeeded, with failed status otherwise."
msgstr ""

#: ../../../driver-api/libata.rst:504
msgid ""
"However, failed ATAPI commands require more handling as REQUEST SENSE is "
"needed to acquire sense data. If an ATAPI command fails, :c:func:"
"`ata_qc_complete` is invoked with error status, which in turn invokes :c:"
"func:`atapi_qc_complete` via ``qc->complete_fn()`` callback."
msgstr ""

#: ../../../driver-api/libata.rst:509
msgid ""
"This makes :c:func:`atapi_qc_complete` set ``scmd->result`` to "
"SAM_STAT_CHECK_CONDITION, complete the scmd and return 1. As the sense data "
"is empty but ``scmd->result`` is CHECK CONDITION, SCSI midlayer will invoke "
"EH for the scmd, and returning 1 makes :c:func:`ata_qc_complete` to return "
"without deallocating the qc. This leads us to :c:func:`ata_scsi_error` with "
"partially completed qc."
msgstr ""

#: ../../../driver-api/libata.rst:517
msgid ":c:func:`ata_scsi_error`"
msgstr ""

#: ../../../driver-api/libata.rst:519
msgid ""
":c:func:`ata_scsi_error` is the current ``transportt-"
">eh_strategy_handler()`` for libata. As discussed above, this will be "
"entered in two cases - timeout and ATAPI error completion. This function "
"will check if a qc is active and has not failed yet. Such a qc will be "
"marked with AC_ERR_TIMEOUT such that EH will know to handle it later. Then "
"it calls low level libata driver's :c:func:`error_handler` callback."
msgstr ""

#: ../../../driver-api/libata.rst:526
msgid ""
"When the :c:func:`error_handler` callback is invoked it stops BMDMA and "
"completes the qc. Note that as we're currently in EH, we cannot call "
"scsi_done. As described in SCSI EH doc, a recovered scmd should be either "
"retried with :c:func:`scsi_queue_insert` or finished with :c:func:"
"`scsi_finish_command`. Here, we override ``qc->scsidone`` with :c:func:"
"`scsi_finish_command` and calls :c:func:`ata_qc_complete`."
msgstr ""

#: ../../../driver-api/libata.rst:533
msgid ""
"If EH is invoked due to a failed ATAPI qc, the qc here is completed but not "
"deallocated. The purpose of this half-completion is to use the qc as place "
"holder to make EH code reach this place. This is a bit hackish, but it works."
msgstr ""

#: ../../../driver-api/libata.rst:538
msgid ""
"Once control reaches here, the qc is deallocated by invoking :c:func:"
"`__ata_qc_complete` explicitly. Then, internal qc for REQUEST SENSE is "
"issued. Once sense data is acquired, scmd is finished by directly invoking :"
"c:func:`scsi_finish_command` on the scmd. Note that as we already have "
"completed and deallocated the qc which was associated with the scmd, we "
"don't need to/cannot call :c:func:`ata_qc_complete` again."
msgstr ""

#: ../../../driver-api/libata.rst:546
msgid "Problems with the current EH"
msgstr ""

#: ../../../driver-api/libata.rst:548
msgid ""
"Error representation is too crude. Currently any and all error conditions "
"are represented with ATA STATUS and ERROR registers. Errors which aren't ATA "
"device errors are treated as ATA device errors by setting ATA_ERR bit. "
"Better error descriptor which can properly represent ATA and other errors/"
"exceptions is needed."
msgstr ""

#: ../../../driver-api/libata.rst:554
msgid ""
"When handling timeouts, no action is taken to make device forget about the "
"timed out command and ready for new commands."
msgstr ""

#: ../../../driver-api/libata.rst:557
msgid ""
"EH handling via :c:func:`ata_scsi_error` is not properly protected from "
"usual command processing. On EH entrance, the device is not in quiescent "
"state. Timed out commands may succeed or fail any time. pio_task and "
"atapi_task may still be running."
msgstr ""

#: ../../../driver-api/libata.rst:562
msgid ""
"Too weak error recovery. Devices / controllers causing HSM mismatch errors "
"and other errors quite often require reset to return to known state. Also, "
"advanced error handling is necessary to support features like NCQ and "
"hotplug."
msgstr ""

#: ../../../driver-api/libata.rst:567
msgid ""
"ATA errors are directly handled in the interrupt handler and PIO errors in "
"pio_task. This is problematic for advanced error handling for the following "
"reasons."
msgstr ""

#: ../../../driver-api/libata.rst:571
msgid ""
"First, advanced error handling often requires context and internal qc "
"execution."
msgstr ""

#: ../../../driver-api/libata.rst:574
msgid ""
"Second, even a simple failure (say, CRC error) needs information gathering "
"and could trigger complex error handling (say, resetting & reconfiguring). "
"Having multiple code paths to gather information, enter EH and trigger "
"actions makes life painful."
msgstr ""

#: ../../../driver-api/libata.rst:579
msgid ""
"Third, scattered EH code makes implementing low level drivers difficult. Low "
"level drivers override libata callbacks. If EH is scattered over several "
"places, each affected callbacks should perform its part of error handling. "
"This can be error prone and painful."
msgstr ""

#: ../../../driver-api/libata.rst:585
msgid "libata Library"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:166
msgid "link iteration helper"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:170
#: ../drivers/ata/libata-core.c:230 ../drivers/ata/libata-core.c:544
#: ../drivers/ata/libata-core.c:862 ../drivers/ata/libata-core.c:918
#: ../drivers/ata/libata-core.c:943 ../drivers/ata/libata-core.c:967
#: ../drivers/ata/libata-core.c:990 ../drivers/ata/libata-core.c:1050
#: ../drivers/ata/libata-core.c:1107 ../drivers/ata/libata-core.c:1144
#: ../drivers/ata/libata-core.c:1442 ../drivers/ata/libata-core.c:1686
#: ../drivers/ata/libata-core.c:1743 ../drivers/ata/libata-core.c:3221
#: ../drivers/ata/libata-core.c:3235 ../drivers/ata/libata-core.c:3249
#: ../drivers/ata/libata-core.c:3262 ../drivers/ata/libata-core.c:3275
#: ../drivers/ata/libata-core.c:3316 ../drivers/ata/libata-core.c:3559
#: ../drivers/ata/libata-core.c:3746 ../drivers/ata/libata-core.c:3769
#: ../drivers/ata/libata-core.c:3815 ../drivers/ata/libata-core.c:4664
#: ../drivers/ata/libata-core.c:4774 ../drivers/ata/libata-core.c:4997
#: ../drivers/ata/libata-core.c:5112 ../drivers/ata/libata-core.c:5266
#: ../drivers/ata/libata-core.c:5293 ../drivers/ata/libata-core.c:5491
#: ../drivers/ata/libata-core.c:5504 ../drivers/ata/libata-core.c:5629
#: ../drivers/ata/libata-core.c:5742 ../drivers/ata/libata-core.c:5811
#: ../drivers/ata/libata-core.c:5928 ../drivers/ata/libata-core.c:6009
#: ../drivers/ata/libata-core.c:6073 ../drivers/ata/libata-core.c:6159
#: ../drivers/ata/libata-core.c:6310 ../drivers/ata/libata-core.c:6333
#: ../drivers/ata/libata-core.c:6464 ../drivers/ata/libata-core.c:6811
#: ../drivers/ata/libata-core.c:6844 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:284 ../drivers/ata/libata-core.c:310
#: ../drivers/ata/libata-core.c:342 ../drivers/ata/libata-core.c:371
#: ../drivers/ata/libata-core.c:429 ../drivers/ata/libata-core.c:510
#: ../drivers/ata/libata-core.c:613 ../drivers/ata/libata-core.c:656
#: ../drivers/ata/libata-core.c:725 ../drivers/ata/libata-core.c:887
#: ../drivers/ata/libata-core.c:1215 ../drivers/ata/libata-core.c:1266
#: ../drivers/ata/libata-core.c:1324 ../drivers/ata/libata-core.c:1420
#: ../drivers/ata/libata-core.c:1519 ../drivers/ata/libata-core.c:1720
#: ../drivers/ata/libata-core.c:1761 ../drivers/ata/libata-core.c:2024
#: ../drivers/ata/libata-core.c:2070 ../drivers/ata/libata-core.c:2108
#: ../drivers/ata/libata-core.c:2930 ../drivers/ata/libata-core.c:3288
#: ../drivers/ata/libata-core.c:3335 ../drivers/ata/libata-core.c:3387
#: ../drivers/ata/libata-core.c:3659 ../drivers/ata/libata-core.c:3840
#: ../drivers/ata/libata-core.c:3889 ../drivers/ata/libata-core.c:3922
#: ../drivers/ata/libata-core.c:4476 ../drivers/ata/libata-core.c:4491
#: ../drivers/ata/libata-core.c:4542 ../drivers/ata/libata-core.c:4619
#: ../drivers/ata/libata-core.c:4701 ../drivers/ata/libata-core.c:4743
#: ../drivers/ata/libata-core.c:4805 ../drivers/ata/libata-core.c:4828
#: ../drivers/ata/libata-core.c:4852 ../drivers/ata/libata-core.c:4888
#: ../drivers/ata/libata-core.c:4910 ../drivers/ata/libata-core.c:5136
#: ../drivers/ata/libata-core.c:5218 ../drivers/ata/libata-core.c:5242
#: ../drivers/ata/libata-core.c:5524 ../drivers/ata/libata-core.c:5559
#: ../drivers/ata/libata-core.c:5596 ../drivers/ata/libata-core.c:5878
#: ../drivers/ata/libata-core.c:6222 ../drivers/ata/libata-core.c:6239
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:180
#: ../drivers/ata/libata-eh.c:200 ../drivers/ata/libata-eh.c:224
#: ../drivers/ata/libata-eh.c:240 ../drivers/ata/libata-eh.c:269
#: ../drivers/ata/libata-eh.c:323 ../drivers/ata/libata-eh.c:349
#: ../drivers/ata/libata-eh.c:465 ../drivers/ata/libata-eh.c:483
#: ../drivers/ata/libata-eh.c:552 ../drivers/ata/libata-eh.c:585
#: ../drivers/ata/libata-eh.c:689 ../drivers/ata/libata-eh.c:815
#: ../drivers/ata/libata-eh.c:904 ../drivers/ata/libata-eh.c:947
#: ../drivers/ata/libata-eh.c:972 ../drivers/ata/libata-eh.c:991
#: ../drivers/ata/libata-eh.c:1012 ../drivers/ata/libata-eh.c:1052
#: ../drivers/ata/libata-eh.c:1070 ../drivers/ata/libata-eh.c:1088
#: ../drivers/ata/libata-eh.c:1116 ../drivers/ata/libata-eh.c:1138
#: ../drivers/ata/libata-eh.c:1157 ../drivers/ata/libata-eh.c:1202
#: ../drivers/ata/libata-eh.c:1216 ../drivers/ata/libata-eh.c:1235
#: ../drivers/ata/libata-eh.c:1255 ../drivers/ata/libata-eh.c:1298
#: ../drivers/ata/libata-eh.c:1334 ../drivers/ata/libata-eh.c:1356
#: ../drivers/ata/libata-eh.c:1395 ../drivers/ata/libata-eh.c:1426
#: ../drivers/ata/libata-eh.c:1463 ../drivers/ata/libata-eh.c:1518
#: ../drivers/ata/libata-eh.c:1576 ../drivers/ata/libata-eh.c:1625
#: ../drivers/ata/libata-eh.c:1769 ../drivers/ata/libata-eh.c:1869
#: ../drivers/ata/libata-eh.c:1960 ../drivers/ata/libata-eh.c:1980
#: ../drivers/ata/libata-eh.c:2118 ../drivers/ata/libata-eh.c:2268
#: ../drivers/ata/libata-eh.c:2408 ../drivers/ata/libata-eh.c:2454
#: ../drivers/ata/libata-eh.c:2576 ../drivers/ata/libata-eh.c:2771
#: ../drivers/ata/libata-eh.c:3430 ../drivers/ata/libata-eh.c:3483
#: ../drivers/ata/libata-eh.c:3531 ../drivers/ata/libata-eh.c:3776
#: ../drivers/ata/libata-eh.c:4024 ../drivers/ata/libata-eh.c:4083
#: ../drivers/ata/libata-eh.c:4120 ../drivers/ata/libata-eh.c:4197
#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:356
#: ../drivers/ata/libata-scsi.c:386 ../drivers/ata/libata-scsi.c:1046
#: ../drivers/ata/libata-scsi.c:1143 ../drivers/ata/libata-scsi.c:1179
#: ../drivers/ata/libata-scsi.c:1204 ../drivers/ata/libata-scsi.c:4487
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:242
#: ../drivers/ata/libata-scsi.c:416 ../drivers/ata/libata-scsi.c:456
#: ../drivers/ata/libata-scsi.c:564 ../drivers/ata/libata-scsi.c:728
#: ../drivers/ata/libata-scsi.c:802 ../drivers/ata/libata-scsi.c:977
#: ../drivers/ata/libata-scsi.c:1240 ../drivers/ata/libata-scsi.c:1301
#: ../drivers/ata/libata-scsi.c:1332 ../drivers/ata/libata-scsi.c:1348
#: ../drivers/ata/libata-scsi.c:1364 ../drivers/ata/libata-scsi.c:1380
#: ../drivers/ata/libata-scsi.c:1392 ../drivers/ata/libata-scsi.c:1535
#: ../drivers/ata/libata-scsi.c:1828 ../drivers/ata/libata-scsi.c:1896
#: ../drivers/ata/libata-scsi.c:1934 ../drivers/ata/libata-scsi.c:2023
#: ../drivers/ata/libata-scsi.c:2061 ../drivers/ata/libata-scsi.c:2089
#: ../drivers/ata/libata-scsi.c:2151 ../drivers/ata/libata-scsi.c:2189
#: ../drivers/ata/libata-scsi.c:2240 ../drivers/ata/libata-scsi.c:2270
#: ../drivers/ata/libata-scsi.c:2293 ../drivers/ata/libata-scsi.c:2331
#: ../drivers/ata/libata-scsi.c:2369 ../drivers/ata/libata-scsi.c:2420
#: ../drivers/ata/libata-scsi.c:2443 ../drivers/ata/libata-scsi.c:2585
#: ../drivers/ata/libata-scsi.c:2621 ../drivers/ata/libata-scsi.c:2638
#: ../drivers/ata/libata-scsi.c:2770 ../drivers/ata/libata-scsi.c:2858
#: ../drivers/ata/libata-scsi.c:2936 ../drivers/ata/libata-scsi.c:3081
#: ../drivers/ata/libata-scsi.c:3150 ../drivers/ata/libata-scsi.c:3416
#: ../drivers/ata/libata-scsi.c:3470 ../drivers/ata/libata-scsi.c:3583
#: ../drivers/ata/libata-scsi.c:3684 ../drivers/ata/libata-scsi.c:3915
#: ../drivers/ata/libata-scsi.c:4067 ../drivers/ata/libata-scsi.c:4093
#: ../drivers/ata/libata-scsi.c:4336 ../drivers/ata/libata-scsi.c:4364
#: ../drivers/ata/libata-scsi.c:4533 ../drivers/ata/libata-scsi.c:4757
#: ../drivers/ata/libata-scsi.c:4780 ../drivers/ata/libata-scsi.c:4860
#: ../drivers/ata/libata-scsi.c:4877 ../drivers/ata/libata-scsi.c:4915
#: ../drivers/ata/libata-scsi.c:4982 ../../../driver-api/libata:979:
#: ../drivers/ata/ata_piix.c:500 ../drivers/ata/ata_piix.c:535
#: ../drivers/ata/ata_piix.c:641 ../drivers/ata/ata_piix.c:657
#: ../drivers/ata/ata_piix.c:736 ../drivers/ata/ata_piix.c:752
#: ../drivers/ata/ata_piix.c:1312 ../drivers/ata/ata_piix.c:1633
#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:341
#: ../drivers/ata/sata_sil.c:588
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:172
#: ../drivers/ata/libata-core.c:229 ../drivers/ata/libata-core.c:3561
#: ../drivers/ata/libata-core.c:3748 ../drivers/ata/libata-core.c:3771
#: ../drivers/ata/libata-core.c:3817 ../drivers/ata/libata-core.c:5268
#: ../drivers/ata/libata-core.c:5295 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:373 ../drivers/ata/libata-core.c:3290
#: ../drivers/ata/libata-core.c:3661 ../drivers/ata/libata-core.c:5220
#: ../drivers/ata/libata-core.c:5244 ../drivers/ata/libata-core.c:5558
#: ../drivers/ata/libata-core.c:5598 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:1054 ../drivers/ata/libata-eh.c:1300
#: ../drivers/ata/libata-eh.c:1336 ../drivers/ata/libata-eh.c:1578
#: ../drivers/ata/libata-eh.c:2120 ../drivers/ata/libata-eh.c:2270
#: ../drivers/ata/libata-eh.c:2578 ../drivers/ata/libata-eh.c:3432
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:537
#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:343
msgid "``struct ata_link *link``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:167
msgid "the previous link, NULL to start"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:169
#: ../drivers/ata/libata-core.c:3223 ../drivers/ata/libata-core.c:3237
#: ../drivers/ata/libata-core.c:3251 ../drivers/ata/libata-core.c:3264
#: ../drivers/ata/libata-core.c:3277 ../drivers/ata/libata-core.c:5114
#: ../drivers/ata/libata-core.c:6813 ../drivers/ata/libata-core.c:6846
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:312
#: ../drivers/ata/libata-core.c:344 ../drivers/ata/libata-core.c:4493
#: ../drivers/ata/libata-core.c:5561 ../drivers/ata/libata-core.c:6241
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:242
#: ../drivers/ata/libata-eh.c:271 ../drivers/ata/libata-eh.c:467
#: ../drivers/ata/libata-eh.c:485 ../drivers/ata/libata-eh.c:584
#: ../drivers/ata/libata-eh.c:688 ../drivers/ata/libata-eh.c:817
#: ../drivers/ata/libata-eh.c:906 ../drivers/ata/libata-eh.c:974
#: ../drivers/ata/libata-eh.c:993 ../drivers/ata/libata-eh.c:1014
#: ../drivers/ata/libata-eh.c:1072 ../drivers/ata/libata-eh.c:1090
#: ../drivers/ata/libata-eh.c:1118 ../drivers/ata/libata-eh.c:1140
#: ../drivers/ata/libata-eh.c:1159 ../drivers/ata/libata-eh.c:2410
#: ../drivers/ata/libata-eh.c:2773 ../drivers/ata/libata-eh.c:3778
#: ../drivers/ata/libata-eh.c:4026 ../drivers/ata/libata-eh.c:4085
#: ../drivers/ata/libata-eh.c:4122 ../drivers/ata/libata-eh.c:4199
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:418
#: ../drivers/ata/libata-scsi.c:3083 ../../../driver-api/libata:979:
#: ../drivers/ata/ata_piix.c:502 ../drivers/ata/ata_piix.c:643
#: ../drivers/ata/ata_piix.c:659 ../drivers/ata/ata_piix.c:738
#: ../drivers/ata/ata_piix.c:754
msgid "``struct ata_port *ap``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:168
msgid "ATA port containing links to iterate"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:170
msgid "``enum ata_link_iter_mode mode``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:169
msgid "iteration mode, one of ATA_LITER_*"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:171
#: ../drivers/ata/libata-core.c:231 ../drivers/ata/libata-core.c:543
#: ../drivers/ata/libata-core.c:863 ../drivers/ata/libata-core.c:917
#: ../drivers/ata/libata-core.c:942 ../drivers/ata/libata-core.c:966
#: ../drivers/ata/libata-core.c:989 ../drivers/ata/libata-core.c:1049
#: ../drivers/ata/libata-core.c:1109 ../drivers/ata/libata-core.c:1146
#: ../drivers/ata/libata-core.c:1441 ../drivers/ata/libata-core.c:1685
#: ../drivers/ata/libata-core.c:1744 ../drivers/ata/libata-core.c:3220
#: ../drivers/ata/libata-core.c:3234 ../drivers/ata/libata-core.c:3248
#: ../drivers/ata/libata-core.c:3261 ../drivers/ata/libata-core.c:3274
#: ../drivers/ata/libata-core.c:3315 ../drivers/ata/libata-core.c:3559
#: ../drivers/ata/libata-core.c:3747 ../drivers/ata/libata-core.c:3769
#: ../drivers/ata/libata-core.c:3815 ../drivers/ata/libata-core.c:4665
#: ../drivers/ata/libata-core.c:4773 ../drivers/ata/libata-core.c:4996
#: ../drivers/ata/libata-core.c:5111 ../drivers/ata/libata-core.c:5265
#: ../drivers/ata/libata-core.c:5292 ../drivers/ata/libata-core.c:5491
#: ../drivers/ata/libata-core.c:5503 ../drivers/ata/libata-core.c:5628
#: ../drivers/ata/libata-core.c:5742 ../drivers/ata/libata-core.c:5812
#: ../drivers/ata/libata-core.c:5927 ../drivers/ata/libata-core.c:6073
#: ../drivers/ata/libata-core.c:6162 ../drivers/ata/libata-core.c:6309
#: ../drivers/ata/libata-core.c:6332 ../drivers/ata/libata-core.c:6463
#: ../drivers/ata/libata-core.c:6811 ../drivers/ata/libata-core.c:6848
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:283
#: ../drivers/ata/libata-core.c:309 ../drivers/ata/libata-core.c:341
#: ../drivers/ata/libata-core.c:370 ../drivers/ata/libata-core.c:428
#: ../drivers/ata/libata-core.c:509 ../drivers/ata/libata-core.c:613
#: ../drivers/ata/libata-core.c:656 ../drivers/ata/libata-core.c:729
#: ../drivers/ata/libata-core.c:889 ../drivers/ata/libata-core.c:1215
#: ../drivers/ata/libata-core.c:1266 ../drivers/ata/libata-core.c:1323
#: ../drivers/ata/libata-core.c:1420 ../drivers/ata/libata-core.c:1524
#: ../drivers/ata/libata-core.c:1719 ../drivers/ata/libata-core.c:1763
#: ../drivers/ata/libata-core.c:2023 ../drivers/ata/libata-core.c:2069
#: ../drivers/ata/libata-core.c:2111 ../drivers/ata/libata-core.c:2929
#: ../drivers/ata/libata-core.c:3287 ../drivers/ata/libata-core.c:3335
#: ../drivers/ata/libata-core.c:3387 ../drivers/ata/libata-core.c:3660
#: ../drivers/ata/libata-core.c:3841 ../drivers/ata/libata-core.c:3889
#: ../drivers/ata/libata-core.c:3923 ../drivers/ata/libata-core.c:4475
#: ../drivers/ata/libata-core.c:4490 ../drivers/ata/libata-core.c:4541
#: ../drivers/ata/libata-core.c:4618 ../drivers/ata/libata-core.c:4702
#: ../drivers/ata/libata-core.c:4742 ../drivers/ata/libata-core.c:4806
#: ../drivers/ata/libata-core.c:4827 ../drivers/ata/libata-core.c:4851
#: ../drivers/ata/libata-core.c:4888 ../drivers/ata/libata-core.c:4909
#: ../drivers/ata/libata-core.c:5135 ../drivers/ata/libata-core.c:5217
#: ../drivers/ata/libata-core.c:5241 ../drivers/ata/libata-core.c:5523
#: ../drivers/ata/libata-core.c:5560 ../drivers/ata/libata-core.c:5595
#: ../drivers/ata/libata-core.c:5877 ../drivers/ata/libata-core.c:6221
#: ../drivers/ata/libata-core.c:6238 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:3 ../drivers/ata/libata-eh.c:223
#: ../drivers/ata/libata-eh.c:271 ../drivers/ata/libata-eh.c:323
#: ../drivers/ata/libata-eh.c:349 ../drivers/ata/libata-eh.c:464
#: ../drivers/ata/libata-eh.c:482 ../drivers/ata/libata-eh.c:551
#: ../drivers/ata/libata-eh.c:586 ../drivers/ata/libata-eh.c:689
#: ../drivers/ata/libata-eh.c:814 ../drivers/ata/libata-eh.c:904
#: ../drivers/ata/libata-eh.c:946 ../drivers/ata/libata-eh.c:971
#: ../drivers/ata/libata-eh.c:990 ../drivers/ata/libata-eh.c:1011
#: ../drivers/ata/libata-eh.c:1051 ../drivers/ata/libata-eh.c:1069
#: ../drivers/ata/libata-eh.c:1087 ../drivers/ata/libata-eh.c:1115
#: ../drivers/ata/libata-eh.c:1137 ../drivers/ata/libata-eh.c:1156
#: ../drivers/ata/libata-eh.c:1201 ../drivers/ata/libata-eh.c:1215
#: ../drivers/ata/libata-eh.c:1234 ../drivers/ata/libata-eh.c:1254
#: ../drivers/ata/libata-eh.c:1299 ../drivers/ata/libata-eh.c:1335
#: ../drivers/ata/libata-eh.c:1355 ../drivers/ata/libata-eh.c:1395
#: ../drivers/ata/libata-eh.c:1425 ../drivers/ata/libata-eh.c:1462
#: ../drivers/ata/libata-eh.c:1519 ../drivers/ata/libata-eh.c:1575
#: ../drivers/ata/libata-eh.c:1624 ../drivers/ata/libata-eh.c:1768
#: ../drivers/ata/libata-eh.c:1870 ../drivers/ata/libata-eh.c:1959
#: ../drivers/ata/libata-eh.c:1979 ../drivers/ata/libata-eh.c:2119
#: ../drivers/ata/libata-eh.c:2267 ../drivers/ata/libata-eh.c:2407
#: ../drivers/ata/libata-eh.c:2453 ../drivers/ata/libata-eh.c:2575
#: ../drivers/ata/libata-eh.c:2770 ../drivers/ata/libata-eh.c:3430
#: ../drivers/ata/libata-eh.c:3482 ../drivers/ata/libata-eh.c:3530
#: ../drivers/ata/libata-eh.c:3777 ../drivers/ata/libata-eh.c:4023
#: ../drivers/ata/libata-eh.c:4082 ../drivers/ata/libata-eh.c:4119
#: ../drivers/ata/libata-eh.c:4196 ../../../driver-api/libata:601:
#: ../drivers/ata/libata-scsi.c:358 ../drivers/ata/libata-scsi.c:385
#: ../drivers/ata/libata-scsi.c:1045 ../drivers/ata/libata-scsi.c:1142
#: ../drivers/ata/libata-scsi.c:1179 ../drivers/ata/libata-scsi.c:1203
#: ../drivers/ata/libata-scsi.c:4487 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:241 ../drivers/ata/libata-scsi.c:417
#: ../drivers/ata/libata-scsi.c:456 ../drivers/ata/libata-scsi.c:564
#: ../drivers/ata/libata-scsi.c:728 ../drivers/ata/libata-scsi.c:805
#: ../drivers/ata/libata-scsi.c:976 ../drivers/ata/libata-scsi.c:1239
#: ../drivers/ata/libata-scsi.c:1300 ../drivers/ata/libata-scsi.c:1337
#: ../drivers/ata/libata-scsi.c:1353 ../drivers/ata/libata-scsi.c:1369
#: ../drivers/ata/libata-scsi.c:1379 ../drivers/ata/libata-scsi.c:1391
#: ../drivers/ata/libata-scsi.c:1534 ../drivers/ata/libata-scsi.c:1829
#: ../drivers/ata/libata-scsi.c:1897 ../drivers/ata/libata-scsi.c:1935
#: ../drivers/ata/libata-scsi.c:2024 ../drivers/ata/libata-scsi.c:2062
#: ../drivers/ata/libata-scsi.c:2090 ../drivers/ata/libata-scsi.c:2152
#: ../drivers/ata/libata-scsi.c:2190 ../drivers/ata/libata-scsi.c:2242
#: ../drivers/ata/libata-scsi.c:2272 ../drivers/ata/libata-scsi.c:2295
#: ../drivers/ata/libata-scsi.c:2333 ../drivers/ata/libata-scsi.c:2370
#: ../drivers/ata/libata-scsi.c:2422 ../drivers/ata/libata-scsi.c:2444
#: ../drivers/ata/libata-scsi.c:2587 ../drivers/ata/libata-scsi.c:2621
#: ../drivers/ata/libata-scsi.c:2639 ../drivers/ata/libata-scsi.c:2771
#: ../drivers/ata/libata-scsi.c:2859 ../drivers/ata/libata-scsi.c:2935
#: ../drivers/ata/libata-scsi.c:3081 ../drivers/ata/libata-scsi.c:3149
#: ../drivers/ata/libata-scsi.c:3418 ../drivers/ata/libata-scsi.c:3469
#: ../drivers/ata/libata-scsi.c:3584 ../drivers/ata/libata-scsi.c:3683
#: ../drivers/ata/libata-scsi.c:3917 ../drivers/ata/libata-scsi.c:4070
#: ../drivers/ata/libata-scsi.c:4092 ../drivers/ata/libata-scsi.c:4335
#: ../drivers/ata/libata-scsi.c:4364 ../drivers/ata/libata-scsi.c:4533
#: ../drivers/ata/libata-scsi.c:4756 ../drivers/ata/libata-scsi.c:4779
#: ../drivers/ata/libata-scsi.c:4859 ../drivers/ata/libata-scsi.c:4876
#: ../drivers/ata/libata-scsi.c:4917 ../drivers/ata/libata-scsi.c:4981
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:499
#: ../drivers/ata/ata_piix.c:535 ../drivers/ata/ata_piix.c:641
#: ../drivers/ata/ata_piix.c:658 ../drivers/ata/ata_piix.c:736
#: ../drivers/ata/ata_piix.c:752 ../drivers/ata/ata_piix.c:1311
#: ../drivers/ata/ata_piix.c:1633 ../../../driver-api/libata:985:
#: ../drivers/ata/sata_sil.c:341 ../drivers/ata/sata_sil.c:587
msgid "**Description**"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:170
#: ../drivers/ata/libata-core.c:230
msgid "LOCKING: Host lock or EH context."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:173
#: ../drivers/ata/libata-core.c:233 ../drivers/ata/libata-core.c:547
#: ../drivers/ata/libata-core.c:868 ../drivers/ata/libata-core.c:922
#: ../drivers/ata/libata-core.c:946 ../drivers/ata/libata-core.c:970
#: ../drivers/ata/libata-core.c:994 ../drivers/ata/libata-core.c:1055
#: ../drivers/ata/libata-core.c:1448 ../drivers/ata/libata-core.c:3566
#: ../drivers/ata/libata-core.c:3751 ../drivers/ata/libata-core.c:3777
#: ../drivers/ata/libata-core.c:4669 ../drivers/ata/libata-core.c:4780
#: ../drivers/ata/libata-core.c:5113 ../drivers/ata/libata-core.c:5273
#: ../drivers/ata/libata-core.c:5300 ../drivers/ata/libata-core.c:5633
#: ../drivers/ata/libata-core.c:5749 ../drivers/ata/libata-core.c:5819
#: ../drivers/ata/libata-core.c:5935 ../drivers/ata/libata-core.c:6080
#: ../drivers/ata/libata-core.c:6173 ../drivers/ata/libata-core.c:6859
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:289
#: ../drivers/ata/libata-core.c:662 ../drivers/ata/libata-core.c:1217
#: ../drivers/ata/libata-core.c:1267 ../drivers/ata/libata-core.c:1326
#: ../drivers/ata/libata-core.c:1532 ../drivers/ata/libata-core.c:1773
#: ../drivers/ata/libata-core.c:2115 ../drivers/ata/libata-core.c:2934
#: ../drivers/ata/libata-core.c:3342 ../drivers/ata/libata-core.c:3393
#: ../drivers/ata/libata-core.c:3670 ../drivers/ata/libata-core.c:3847
#: ../drivers/ata/libata-core.c:3894 ../drivers/ata/libata-core.c:3928
#: ../drivers/ata/libata-core.c:4623 ../drivers/ata/libata-core.c:4704
#: ../drivers/ata/libata-core.c:4748 ../drivers/ata/libata-core.c:4855
#: ../drivers/ata/libata-core.c:5223 ../drivers/ata/libata-core.c:5247
#: ../drivers/ata/libata-core.c:5600 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:327 ../drivers/ata/libata-eh.c:555
#: ../drivers/ata/libata-eh.c:1055 ../drivers/ata/libata-eh.c:1073
#: ../drivers/ata/libata-eh.c:1121 ../drivers/ata/libata-eh.c:1361
#: ../drivers/ata/libata-eh.c:1399 ../drivers/ata/libata-eh.c:1449
#: ../drivers/ata/libata-eh.c:1467 ../drivers/ata/libata-eh.c:1524
#: ../drivers/ata/libata-eh.c:1630 ../drivers/ata/libata-eh.c:1817
#: ../drivers/ata/libata-eh.c:1877 ../drivers/ata/libata-eh.c:2126
#: ../drivers/ata/libata-eh.c:3436 ../drivers/ata/libata-eh.c:3488
#: ../drivers/ata/libata-eh.c:3539 ../drivers/ata/libata-eh.c:3786
#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:365
#: ../drivers/ata/libata-scsi.c:1052 ../drivers/ata/libata-scsi.c:4496
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:419
#: ../drivers/ata/libata-scsi.c:458 ../drivers/ata/libata-scsi.c:566
#: ../drivers/ata/libata-scsi.c:738 ../drivers/ata/libata-scsi.c:1246
#: ../drivers/ata/libata-scsi.c:1305 ../drivers/ata/libata-scsi.c:1395
#: ../drivers/ata/libata-scsi.c:1544 ../drivers/ata/libata-scsi.c:1844
#: ../drivers/ata/libata-scsi.c:2937 ../drivers/ata/libata-scsi.c:3088
#: ../drivers/ata/libata-scsi.c:3150 ../drivers/ata/libata-scsi.c:3430
#: ../drivers/ata/libata-scsi.c:4337 ../drivers/ata/libata-scsi.c:4366
#: ../drivers/ata/libata-scsi.c:4762 ../drivers/ata/libata-scsi.c:4922
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1638
msgid "**Return**"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:174
msgid "Pointer to the next link."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:226
msgid "device iteration helper"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:232
#: ../drivers/ata/libata-core.c:1745 ../drivers/ata/libata-core.c:4666
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:286
#: ../drivers/ata/libata-core.c:431 ../drivers/ata/libata-core.c:512
#: ../drivers/ata/libata-core.c:615 ../drivers/ata/libata-core.c:655
#: ../drivers/ata/libata-core.c:1217 ../drivers/ata/libata-core.c:1268
#: ../drivers/ata/libata-core.c:1326 ../drivers/ata/libata-core.c:1422
#: ../drivers/ata/libata-core.c:1521 ../drivers/ata/libata-core.c:1763
#: ../drivers/ata/libata-core.c:2026 ../drivers/ata/libata-core.c:2072
#: ../drivers/ata/libata-core.c:2110 ../drivers/ata/libata-core.c:2932
#: ../drivers/ata/libata-core.c:3389 ../drivers/ata/libata-core.c:3842
#: ../drivers/ata/libata-core.c:3891 ../drivers/ata/libata-core.c:3924
#: ../drivers/ata/libata-core.c:4478 ../drivers/ata/libata-core.c:4544
#: ../drivers/ata/libata-core.c:4621 ../drivers/ata/libata-core.c:4703
#: ../drivers/ata/libata-core.c:5526 ../drivers/ata/libata-core.c:6224
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:325
#: ../drivers/ata/libata-eh.c:351 ../drivers/ata/libata-eh.c:1237
#: ../drivers/ata/libata-eh.c:1257 ../drivers/ata/libata-eh.c:1297
#: ../drivers/ata/libata-eh.c:1333 ../drivers/ata/libata-eh.c:1397
#: ../drivers/ata/libata-eh.c:1520 ../drivers/ata/libata-eh.c:1771
#: ../drivers/ata/libata-eh.c:1871 ../drivers/ata/libata-eh.c:3485
#: ../drivers/ata/libata-eh.c:3533 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:730 ../drivers/ata/libata-scsi.c:1830
#: ../drivers/ata/libata-scsi.c:1898 ../drivers/ata/libata-scsi.c:1936
#: ../drivers/ata/libata-scsi.c:2025 ../drivers/ata/libata-scsi.c:2063
#: ../drivers/ata/libata-scsi.c:2091 ../drivers/ata/libata-scsi.c:2153
#: ../drivers/ata/libata-scsi.c:2191 ../drivers/ata/libata-scsi.c:2242
#: ../drivers/ata/libata-scsi.c:2272 ../drivers/ata/libata-scsi.c:2295
#: ../drivers/ata/libata-scsi.c:2333 ../drivers/ata/libata-scsi.c:2371
#: ../drivers/ata/libata-scsi.c:2587 ../drivers/ata/libata-scsi.c:2640
#: ../drivers/ata/libata-scsi.c:2772 ../drivers/ata/libata-scsi.c:2860
#: ../drivers/ata/libata-scsi.c:3585 ../drivers/ata/libata-scsi.c:4366
#: ../drivers/ata/libata-scsi.c:4535 ../drivers/ata/libata-scsi.c:4759
#: ../drivers/ata/libata-scsi.c:4782 ../drivers/ata/libata-scsi.c:4862
#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:590
msgid "``struct ata_device *dev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:227
msgid "the previous device, NULL to start"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:228
msgid "ATA link containing devices to iterate"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:230
msgid "``enum ata_dev_iter_mode mode``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:229
msgid "iteration mode, one of ATA_DITER_*"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:234
msgid "Pointer to the next device."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:540
msgid "Determine ATAPI command type from SCSI opcode"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:546
msgid "``u8 opcode``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:541
msgid "SCSI opcode"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:542
msgid "Determine ATAPI command type from **opcode**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:544
#: ../drivers/ata/libata-core.c:865 ../drivers/ata/libata-core.c:919
#: ../drivers/ata/libata-core.c:943 ../drivers/ata/libata-core.c:967
#: ../drivers/ata/libata-core.c:991 ../drivers/ata/libata-core.c:1052
#: ../drivers/ata/libata-core.c:1445 ../drivers/ata/libata-core.c:5270
#: ../drivers/ata/libata-core.c:5297 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:655 ../drivers/ata/libata-core.c:728
#: ../drivers/ata/libata-core.c:3288 ../drivers/ata/libata-core.c:3339
#: ../drivers/ata/libata-core.c:3844 ../drivers/ata/libata-core.c:4544
#: ../drivers/ata/libata-core.c:5220 ../drivers/ata/libata-core.c:5244
#: ../drivers/ata/libata-core.c:5889 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:244 ../drivers/ata/libata-eh.c:275
#: ../drivers/ata/libata-eh.c:1138 ../drivers/ata/libata-eh.c:1157
#: ../drivers/ata/libata-eh.c:1255 ../drivers/ata/libata-eh.c:1302
#: ../drivers/ata/libata-eh.c:1337 ../drivers/ata/libata-eh.c:1358
#: ../drivers/ata/libata-eh.c:1577 ../drivers/ata/libata-eh.c:2576
#: ../drivers/ata/libata-eh.c:2771 ../drivers/ata/libata-eh.c:4025
#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1049
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:243
#: ../drivers/ata/libata-scsi.c:977 ../drivers/ata/libata-scsi.c:2424
#: ../drivers/ata/libata-scsi.c:2447 ../drivers/ata/libata-scsi.c:2588
#: ../drivers/ata/libata-scsi.c:2622 ../drivers/ata/libata-scsi.c:2772
#: ../drivers/ata/libata-scsi.c:3918 ../drivers/ata/libata-scsi.c:4071
msgid "LOCKING: None."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:548
msgid "ATAPI_{READ|WRITE|READ_CD|PASS_THRU|MISC}"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:858
msgid "Pack pio, mwdma and udma masks into xfer_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:864
msgid "``unsigned int pio_mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:859
msgid "pio_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:861
msgid "``unsigned int mwdma_mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:860
msgid "mwdma_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:862
msgid "``unsigned int udma_mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:861
msgid "udma_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:862
msgid ""
"Pack **pio_mask**, **mwdma_mask** and **udma_mask** into a single unsigned "
"int xfer_mask."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:869
msgid "Packed xfer_mask."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:914
msgid "Find matching XFER_* for the given xfer_mask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:920
#: ../drivers/ata/libata-core.c:992 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:889
msgid "``unsigned int xfer_mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:915
msgid "xfer_mask of interest"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:916
msgid ""
"Return matching XFER_* value for **xfer_mask**.  Only the highest bit of "
"**xfer_mask** is considered."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:923
msgid "Matching XFER_* value, 0xff if no match found."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:939
msgid "Find matching xfer_mask for XFER_*"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:945
#: ../drivers/ata/libata-core.c:969
msgid "``u8 xfer_mode``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:940
#: ../drivers/ata/libata-core.c:964
msgid "XFER_* of interest"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:941
msgid "Return matching xfer_mask for **xfer_mode**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:947
msgid "Matching xfer_mask, 0 if no match found."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:963
msgid "Find matching xfer_shift for XFER_*"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:965
msgid "Return matching xfer_shift for **xfer_mode**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:971
msgid "Matching xfer_shift, -1 if no match found."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:986
msgid "convert xfer_mask to string"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:987
msgid "mask of bits supported; only highest bit counts."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:988
msgid ""
"Determine string which represents the highest speed (highest bit in "
"**modemask**)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:995
msgid ""
"Constant C string representing highest speed listed in **mode_mask**, or the "
"constant C string \"<n/a>\"."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1046
msgid "determine device type based on ATA-spec signature"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1052
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:658
msgid "``const struct ata_taskfile *tf``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1047
msgid "ATA taskfile register set for device to be identified"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1048
msgid ""
"Determine from taskfile register contents whether a device is ATA or ATAPI, "
"as per \"Signature and persistence\" section of ATA/PI spec (volume 1, sect "
"5.14)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1056
msgid ""
"Device type, ``ATA_DEV_ATA``, ``ATA_DEV_ATAPI``, ``ATA_DEV_PMP``, "
"``ATA_DEV_ZAC``, or ``ATA_DEV_UNKNOWN`` the event of failure."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1103
msgid "Convert IDENTIFY DEVICE page into string"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1109
#: ../drivers/ata/libata-core.c:1146 ../drivers/ata/libata-core.c:1444
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1419
msgid "``const u16 *id``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1104
#: ../drivers/ata/libata-core.c:1141
msgid "IDENTIFY DEVICE results we will examine"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1106
#: ../drivers/ata/libata-core.c:1143
msgid "``unsigned char *s``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1105
#: ../drivers/ata/libata-core.c:1142
msgid "string into which data is output"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1107
#: ../drivers/ata/libata-core.c:1144
msgid "``unsigned int ofs``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1106
#: ../drivers/ata/libata-core.c:1143
msgid "offset into identify device page"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1108
#: ../drivers/ata/libata-core.c:1145
msgid "``unsigned int len``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1107
msgid "length of string to return. must be an even number."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1108
msgid ""
"The strings in the IDENTIFY DEVICE page are broken up into 16-bit chunks.  "
"Run through the string, and output each 8-bit chunk linearly, regardless of "
"platform."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1112
#: ../drivers/ata/libata-core.c:1149 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:615 ../drivers/ata/libata-core.c:1422
msgid "LOCKING: caller."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1140
msgid "Convert IDENTIFY DEVICE page into C string"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1144
msgid "length of string to return. must be an odd number."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1145
msgid ""
"This function is identical to ata_id_string except that it trims trailing "
"spaces and terminates the resulting string with null.  **len** must be "
"actual maximum length (even number) + 1."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1438
msgid "Compute xfermask from the given IDENTIFY data"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1439
msgid "IDENTIFY data to compute xfer mask from"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1440
msgid ""
"Compute the xfermask for this device. This is not as trivial as it seems if "
"we must consider early devices correctly."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1443
msgid "FIXME: pre IDE drive timing (do we care ?)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1449
msgid "Computed xfermask"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1682
msgid "check if iordy needed"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1688
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1722
msgid "``const struct ata_device *adev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1683
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1717
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4361
msgid "ATA device"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1684
msgid ""
"Check if the current speed of the device requires IORDY. Used by various "
"controllers for chip configuration."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1739
msgid "default ID read method"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1740
#: ../drivers/ata/libata-core.c:3313 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:4473
msgid "device"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1742
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:612
#: ../drivers/ata/libata-core.c:1518
msgid "``struct ata_taskfile *tf``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1741
msgid "proposed taskfile"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1743
msgid "``__le16 *id``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1742
msgid "data buffer"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:1743
msgid ""
"Issue the identify taskfile and hand back the buffer containing identify "
"data. For some RAID controllers and for pre ATA devices this function is "
"wrapped or replaced by the driver"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3217
msgid "return 40 wire cable type"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3218
#: ../drivers/ata/libata-core.c:3232 ../drivers/ata/libata-core.c:3246
#: ../drivers/ata/libata-core.c:3259 ../drivers/ata/libata-core.c:3272
msgid "port"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3219
msgid ""
"Helper method for drivers which want to hardwire 40 wire cable detection."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3231
msgid "return 80 wire cable type"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3233
msgid ""
"Helper method for drivers which want to hardwire 80 wire cable detection."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3245
msgid "return unknown PATA cable."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3247
msgid "Helper method for drivers which have no PATA cable detection."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3258
msgid "return ignored PATA cable."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3260
msgid ""
"Helper method for drivers which don't use cable type to limit transfer mode."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3271
msgid "return SATA cable type"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3273
msgid "Helper method for drivers which have SATA cables"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3312
msgid "return other device on cable"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3318
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:640
#: ../drivers/ata/ata_piix.c:656 ../drivers/ata/ata_piix.c:735
#: ../drivers/ata/ata_piix.c:751
msgid "``struct ata_device *adev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3314
msgid ""
"Obtain the other device on the same cable, or if none is present NULL is "
"returned"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3555
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3426
msgid "Program timings and issue SET FEATURES - XFER"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3556
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3427
msgid "link on which timings will be programmed"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3558
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2118
#: ../drivers/ata/libata-eh.c:3429
msgid "``struct ata_device **r_failed_dev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3557
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2117
#: ../drivers/ata/libata-eh.c:3428
msgid "out parameter for failed device"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3558
msgid ""
"Standard implementation of the function used to tune and set ATA device disk "
"transfer mode (PIO3, UDMA6, etc.).  If ata_dev_set_mode() fails, pointer to "
"the failing device is returned in **r_failed_dev**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3563
#: ../drivers/ata/libata-core.c:4666 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:4620 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:3433
msgid "LOCKING: PCI/etc. bus probe sem."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3567
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3895
#: ../drivers/ata/libata-core.c:3929 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:3437
msgid "0 on success, negative errno otherwise"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3742
msgid "wait for link to become ready after reset"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3743
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3656
msgid "link to be waited on"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3745
#: ../drivers/ata/libata-core.c:3768 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:3658 ../../../driver-api/libata:979:
#: ../drivers/ata/ata_piix.c:534
msgid "``unsigned long deadline``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3744
#: ../drivers/ata/libata-core.c:3767 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:3657 ../../../driver-api/libata:979:
#: ../drivers/ata/ata_piix.c:533
msgid "deadline jiffies for the operation"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3746
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3659
msgid "``int (*check_ready)(struct ata_link *link)``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3745
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3658
msgid "callback to check link readiness"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3746
msgid "Wait for **link** to become ready after reset."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3748
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:314
#: ../drivers/ata/libata-core.c:342 ../drivers/ata/libata-core.c:378
#: ../drivers/ata/libata-core.c:431 ../drivers/ata/libata-core.c:512
#: ../drivers/ata/libata-core.c:3667 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:324 ../drivers/ata/libata-eh.c:352
#: ../drivers/ata/libata-eh.c:467 ../drivers/ata/libata-eh.c:484
#: ../drivers/ata/libata-eh.c:1446 ../drivers/ata/libata-eh.c:2123
msgid "LOCKING: EH context."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3752
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3671
msgid "0 if **link** is ready before **deadline**; otherwise, -errno."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3765
msgid "prepare for reset"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3766
msgid "ATA link to be reset"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3768
msgid ""
"**link** is about to be reset.  Initialize it.  Failure from prereset makes "
"libata abort whole reset sequence and give up that port, so prereset should "
"be best-effort.  It does its best to prepare for reset sequence but if "
"things go wrong, it should just whine, not fail."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3774
#: ../drivers/ata/libata-core.c:3818 ../drivers/ata/libata-core.c:6856
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1770
#: ../drivers/ata/libata-core.c:2931 ../drivers/ata/libata-core.c:3891
#: ../drivers/ata/libata-core.c:3925 ../drivers/ata/libata-core.c:4701
#: ../drivers/ata/libata-core.c:5561
msgid "LOCKING: Kernel thread context (may sleep)"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3778
msgid "Always 0."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3811
msgid "standard postreset callback"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3812
msgid "the target ata_link"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3814
msgid "``unsigned int *classes``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3813
msgid "classes of attached devices"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:3814
msgid ""
"This function is invoked after a successful reset.  Note that the device "
"might have been reset more than once using different reset methods before "
"postreset is invoked."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4660
msgid "Issue SET FEATURES"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4661
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4616
#: ../drivers/ata/libata-core.c:4698
msgid "Device to which command will be sent"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4663
msgid "``u8 subcmd``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4662
msgid "The SET FEATURES subcommand to be sent"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4664
msgid "``u8 action``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4663
msgid "The sector count represents a subcommand specific action"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4664
msgid ""
"Issue SET FEATURES command to device **dev** on port **ap** with sector count"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4670
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2116
#: ../drivers/ata/libata-core.c:4624 ../drivers/ata/libata-core.c:4705
msgid "0 on success, AC_ERR_* mask otherwise."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4770
msgid "Check whether a qc needs to be deferred"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4776
#: ../drivers/ata/libata-core.c:4999 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:727 ../drivers/ata/libata-core.c:4745
#: ../drivers/ata/libata-core.c:4807 ../drivers/ata/libata-core.c:4830
#: ../drivers/ata/libata-core.c:4854 ../drivers/ata/libata-core.c:4912
#: ../drivers/ata/libata-core.c:5138 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:949 ../drivers/ata/libata-eh.c:1204
#: ../drivers/ata/libata-eh.c:1218 ../drivers/ata/libata-eh.c:1428
#: ../drivers/ata/libata-eh.c:1465 ../drivers/ata/libata-eh.c:1627
#: ../drivers/ata/libata-eh.c:1962 ../drivers/ata/libata-eh.c:1982
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:244
#: ../drivers/ata/libata-scsi.c:979 ../drivers/ata/libata-scsi.c:1242
#: ../drivers/ata/libata-scsi.c:1303 ../drivers/ata/libata-scsi.c:1394
#: ../drivers/ata/libata-scsi.c:1537 ../drivers/ata/libata-scsi.c:2938
#: ../drivers/ata/libata-scsi.c:3152 ../drivers/ata/libata-scsi.c:3472
#: ../drivers/ata/libata-scsi.c:3686 ../drivers/ata/libata-scsi.c:3917
#: ../drivers/ata/libata-scsi.c:4069 ../drivers/ata/libata-scsi.c:4095
#: ../drivers/ata/libata-scsi.c:4338
msgid "``struct ata_queued_cmd *qc``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4771
msgid "ATA command in question"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4772
msgid ""
"Non-NCQ commands cannot run with any other command, NCQ or not.  As upper "
"layer only knows the queue depth, we are responsible for maintaining "
"exclusion.  This function checks whether a new command **qc** can be issued."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4777
#: ../drivers/ata/libata-core.c:5003 ../drivers/ata/libata-core.c:5110
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4745
#: ../drivers/ata/libata-core.c:4809 ../drivers/ata/libata-core.c:4828
#: ../drivers/ata/libata-core.c:4852 ../drivers/ata/libata-core.c:4911
#: ../drivers/ata/libata-core.c:5139 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:181 ../drivers/ata/libata-eh.c:202
#: ../drivers/ata/libata-eh.c:224 ../drivers/ata/libata-eh.c:907
#: ../drivers/ata/libata-eh.c:948 ../drivers/ata/libata-eh.c:994
#: ../drivers/ata/libata-eh.c:1013 ../drivers/ata/libata-eh.c:1052
#: ../drivers/ata/libata-eh.c:1097 ../drivers/ata/libata-eh.c:1118
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:735
#: ../drivers/ata/libata-scsi.c:808 ../drivers/ata/libata-scsi.c:1243
#: ../drivers/ata/libata-scsi.c:1302 ../drivers/ata/libata-scsi.c:1392
#: ../drivers/ata/libata-scsi.c:1541 ../drivers/ata/libata-scsi.c:1841
#: ../drivers/ata/libata-scsi.c:1903 ../drivers/ata/libata-scsi.c:1937
#: ../drivers/ata/libata-scsi.c:2025 ../drivers/ata/libata-scsi.c:2063
#: ../drivers/ata/libata-scsi.c:2094 ../drivers/ata/libata-scsi.c:2153
#: ../drivers/ata/libata-scsi.c:2191 ../drivers/ata/libata-scsi.c:2243
#: ../drivers/ata/libata-scsi.c:2273 ../drivers/ata/libata-scsi.c:2296
#: ../drivers/ata/libata-scsi.c:2334 ../drivers/ata/libata-scsi.c:2371
#: ../drivers/ata/libata-scsi.c:2642 ../drivers/ata/libata-scsi.c:2860
#: ../drivers/ata/libata-scsi.c:2934 ../drivers/ata/libata-scsi.c:3085
#: ../drivers/ata/libata-scsi.c:3585 ../drivers/ata/libata-scsi.c:4095
#: ../drivers/ata/libata-scsi.c:4535 ../drivers/ata/libata-scsi.c:4759
#: ../drivers/ata/libata-scsi.c:4861
msgid "LOCKING: spin_lock_irqsave(host lock)"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4781
msgid "ATA_DEFER_* if deferring is needed, 0 otherwise."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4993
msgid "Complete an active ATA command"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4994
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4907
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1199
msgid "Command to complete"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4995
msgid ""
"Indicate to the mid and upper layers that an ATA command has completed, with "
"either an ok or not-ok status."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:4998
msgid ""
"Refrain from calling this function multiple times when successfully "
"completing multiple NCQ commands. ata_qc_complete_multiple() should be used "
"instead, which will properly update IRQ expect state."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5108
msgid "get bitmask of active qcs"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5109
msgid "port in question"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5114
msgid "Bitmask of active qcs"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5262
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5214
msgid "test whether the given link is online"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5263
#: ../drivers/ata/libata-core.c:5290 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:5215 ../drivers/ata/libata-core.c:5239
msgid "ATA link to test"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5264
msgid ""
"Test whether **link** is online.  This is identical to "
"ata_phys_link_online() when there's no slave link.  When there's a slave "
"link, this function should only be called on the master link and will return "
"true if any of M/S links is online."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5274
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5224
msgid "True if the port online status is available and online."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5289
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5238
msgid "test whether the given link is offline"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5291
msgid ""
"Test whether **link** is offline.  This is identical to "
"ata_phys_link_offline() when there's no slave link.  When there's a slave "
"link, this function should only be called on the master link and will return "
"true if both M/S links are offline."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5301
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5248
msgid "True if the port offline status is available and offline."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5487
msgid "suspend host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5493
#: ../drivers/ata/libata-core.c:5506 ../drivers/ata/libata-core.c:5631
#: ../drivers/ata/libata-core.c:5930 ../drivers/ata/libata-core.c:6011
#: ../drivers/ata/libata-core.c:6075 ../drivers/ata/libata-core.c:6161
#: ../drivers/ata/libata-core.c:6312
msgid "``struct ata_host *host``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5488
msgid "host to suspend"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5490
msgid "``pm_message_t mesg``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5489
msgid "PM message"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5490
msgid "Suspend **host**.  Actual operation is performed by port suspend."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5500
msgid "resume host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5501
msgid "host to resume"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5502
msgid "Resume **host**.  Actual operation is performed by port resume."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5625
msgid "allocate and initialize basic ATA port resources"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5626
msgid "ATA host this allocated port belongs to"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5627
msgid "Allocate and initialize basic ATA port resources."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5630
#: ../drivers/ata/libata-core.c:5746 ../drivers/ata/libata-core.c:5816
#: ../drivers/ata/libata-core.c:5932 ../drivers/ata/libata-core.c:6077
#: ../drivers/ata/libata-core.c:6170
msgid "LOCKING: Inherited from calling layer (may sleep)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5630
msgid "Allocate ATA port on success, NULL on failure."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5738
msgid "allocate and init basic ATA host resources"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5744
#: ../drivers/ata/libata-core.c:5813 ../drivers/ata/libata-core.c:6008
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5739
#: ../drivers/ata/libata-core.c:5808
msgid "generic device this host is associated with"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5741
#: ../drivers/ata/libata-core.c:5811
msgid "``int n_ports``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5740
msgid "the number of ATA ports associated with this host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5741
msgid ""
"Allocate and initialize basic ATA host resources.  LLD calls this function "
"to allocate a host, initializes it fully and attaches it using "
"ata_host_register()."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5746
#: ../drivers/ata/libata-core.c:5816
msgid "Allocate ATA host on success, NULL on failure."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5807
msgid "alloc host and init with port_info array"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5810
msgid "``const struct ata_port_info * const * ppi``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5809
msgid "array of ATA port_info to initialize host with"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5810
msgid "number of ATA ports attached to this host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5811
msgid ""
"Allocate ATA host and initialize with info from **ppi**.  If NULL "
"terminated, **ppi** may contain fewer entries than **n_ports**.  The last "
"entry will be used for the remaining ports."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5924
msgid "start and freeze ports of an ATA host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5925
msgid "ATA host to start ports for"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5926
msgid ""
"Start and then freeze ports of **host**.  Started status is recorded in host-"
">flags, so this function can be called multiple times.  Ports are guaranteed "
"to get started only once.  If host->ops is not initialized yet, it is set to "
"the first non-dummy port ops."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:5936
msgid "0 if all ports are started successfully, -errno otherwise."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6005
msgid "Initialize a host struct for sas (ipr, libsas)"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6006
msgid "host to initialize"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6007
msgid "device host is attached to"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6009
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5880
msgid "``struct ata_port_operations *ops``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6008
msgid "port_ops"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6069
msgid "register initialized ATA host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6070
msgid "ATA host to register"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6072
#: ../drivers/ata/libata-core.c:6161
msgid "``const struct scsi_host_template *sht``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6071
msgid "template for SCSI host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6072
msgid ""
"Register initialized ATA host.  **host** is allocated using ata_host_alloc() "
"and fully initialized by LLD.  This function starts ports, registers "
"**host** with ATA and SCSI layers and probe registered devices."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6081
#: ../drivers/ata/libata-core.c:6174 ../../../driver-api/libata:593:
#: ../drivers/ata/libata-core.c:1774
msgid "0 on success, -errno otherwise."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6155
msgid "start host, request IRQ and register it"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6156
msgid "target ATA host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6158
msgid "``int irq``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6157
msgid "IRQ to request"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6159
msgid "``irq_handler_t irq_handler``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6158
msgid "irq_handler used when requesting IRQ"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6160
msgid "``unsigned long irq_flags``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6159
msgid "irq_flags used when requesting IRQ"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6160
msgid "scsi_host_template to use when registering the host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6161
msgid ""
"After allocating an ATA host and initializing it, most libata LLDs perform "
"three steps to activate the host - start host, request IRQ and register it.  "
"This helper takes necessary arguments and performs the three steps in one go."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6166
msgid ""
"An invalid IRQ skips the IRQ registration and expects the host to have set "
"polling mode on the port. In this case, **irq_handler** should be NULL."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6306
msgid "Detach all ports of an ATA host"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6307
msgid "Host to detach"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6308
msgid "Detach all ports of **host**."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6310
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2025
#: ../drivers/ata/libata-core.c:2072 ../drivers/ata/libata-core.c:2112
#: ../drivers/ata/libata-core.c:5597 ../drivers/ata/libata-core.c:6222
#: ../drivers/ata/libata-core.c:6241 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:815 ../drivers/ata/libata-eh.c:1464
#: ../drivers/ata/libata-eh.c:1521 ../drivers/ata/libata-eh.c:1627
#: ../drivers/ata/libata-eh.c:1874 ../drivers/ata/libata-eh.c:2270
#: ../drivers/ata/libata-eh.c:2409 ../drivers/ata/libata-eh.c:3783
#: ../drivers/ata/libata-eh.c:4083 ../drivers/ata/libata-eh.c:4120
#: ../drivers/ata/libata-eh.c:4197 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:4781 ../drivers/ata/libata-scsi.c:4880
#: ../drivers/ata/libata-scsi.c:4983
msgid "LOCKING: Kernel thread context (may sleep)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6329
msgid "PCI layer callback for device removal"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6335
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1635
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6330
msgid "PCI device that was removed"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6331
msgid ""
"PCI layer indicates to libata via this hook that hot-unplug or module unload "
"event has occurred.  Detach all ports.  Resource release is handled via "
"devres."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6335
#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1635
msgid "LOCKING: Inherited from PCI layer (may sleep)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6460
msgid "Platform layer callback for device removal"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6466
msgid "``struct platform_device *pdev``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6461
msgid "Platform device that was removed"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6462
msgid ""
"Platform layer indicates to libata via this hook that hot-unplug or module "
"unload event has occurred.  Detach all ports.  Resource release is handled "
"via devres."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6466
msgid "LOCKING: Inherited from platform layer (may sleep)."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6807
msgid "ATA EH owner aware msleep"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6808
msgid "ATA port to attribute the sleep to"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6810
msgid "``unsigned int msecs``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6809
msgid "duration to sleep in milliseconds"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6810
msgid ""
"Sleeps **msecs**.  If the current task is owner of **ap**'s EH, the "
"ownership is released before going to sleep and reacquired after the sleep "
"is complete.  IOW, other ports sharing the **ap->host** will be allowed to "
"own the EH while this task is sleeping."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6816
msgid "LOCKING: Might sleep."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6840
msgid "wait until register value changes"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6841
msgid "ATA port to wait register for, can be NULL"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6843
msgid "``void __iomem *reg``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6842
msgid "IO-mapped register"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6844
msgid "``u32 mask``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6843
msgid "Mask to apply to read register value"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6845
msgid "``u32 val``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6844
msgid "Wait condition"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6846
msgid "``unsigned int interval``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6845
msgid "polling interval in milliseconds"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6847
#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1523
msgid "``unsigned int timeout``"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6846
msgid "timeout in milliseconds"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6847
msgid ""
"Waiting for some bits of register to change is a common operation for ATA "
"controllers.  This function reads 32bit LE IO-mapped register **reg** and "
"tests for the following condition."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6851
msgid "(***reg** & mask) != val"
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6853
msgid ""
"If the condition is met, it returns; otherwise, the process is repeated "
"after **interval_msec** until timeout."
msgstr ""

#: ../../../driver-api/libata:587: ../drivers/ata/libata-core.c:6860
msgid "The final register value."
msgstr ""

#: ../../../driver-api/libata.rst:591
msgid "libata Core Internals"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:280
msgid "find physical link for a device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:281
msgid "ATA device to look up physical link for"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:282
msgid ""
"Look up physical link which **dev** is attached to.  Note that this is "
"different from **dev->link** only when **dev** is on slave link.  For all "
"other cases, it's the same as **dev->link**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:286
msgid "LOCKING: Don't care."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:290
msgid "Pointer to the found physical link."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:306
msgid "force cable type according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:307
#: ../drivers/ata/libata-core.c:339
msgid "ATA port of interest"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:308
msgid ""
"Force cable type according to libata.force and whine about it. The last "
"entry which has matching port number is used, so it can be specified as part "
"of device force parameters.  For example, both \"a:40c,1.00:udma4\" and "
"\"1.00:40c,udma4\" have the same effect."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:338
msgid "force port flags according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:340
msgid "Force port flags according to libata.force and whine about it."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:367
msgid "force link limits according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:368
msgid "ATA link of interest"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:369
msgid ""
"Force link flags and SATA spd limit according to libata.force and whine "
"about it.  When only the port part is specified (e.g. 1:), the limit applies "
"to all links connected to both the host link and all fan-out ports connected "
"via PMP.  If the device part is specified as 0 (e.g. 1.00:), it specifies "
"the first fan-out link not the host link.  Device number 15 always points to "
"the host link whether PMP is attached or not.  If the controller has slave "
"link, device number 16 points to it."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:425
msgid "force xfermask according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:426
#: ../drivers/ata/libata-core.c:507 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:2582
msgid "ATA device of interest"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:427
msgid ""
"Force xfer_mask according to libata.force and whine about it. For "
"consistency with link selection, device number 15 selects the first device "
"connected to the host link."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:506
msgid "force quirks according to libata.force"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:508
msgid ""
"Force quirks according to libata.force and whine about it. For consistency "
"with link selection, device number 15 selects the first device connected to "
"the host link."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:609
msgid "set taskfile r/w command and protocol"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:610
msgid "target device for the taskfile"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:611
msgid "taskfile to examine and configure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:612
msgid ""
"Examine the device configuration and tf->flags to determine the proper read/"
"write command and protocol to use for **tf**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:652
msgid "Read block address from ATA taskfile"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:653
msgid "ATA taskfile of interest"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:654
msgid "ATA device **tf** belongs to"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:658
msgid ""
"Read block address from **tf**.  This function can handle all three address "
"formats - LBA, LBA48 and CHS.  tf->protocol and flags select the address "
"format to use."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:663
msgid "Block address read from **tf**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:721
msgid "Build ATA taskfile for given read/write request"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:722
msgid "Metadata associated with the taskfile to build"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:724
msgid "``u64 block``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:723
msgid "Block address"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:725
msgid "``u32 n_block``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:724
msgid "Number of blocks"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:726
msgid "``unsigned int tf_flags``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:725
msgid "RW/FUA etc..."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:727
msgid "``int cdl``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:726
msgid "Command duration limit index"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:728
msgid "``int class``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:727
msgid "IO priority class"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:731
msgid ""
"Build ATA taskfile for the command **qc** for read/write request described "
"by **block**, **n_block**, **tf_flags** and **class**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:735
msgid ""
"0 on success, -ERANGE if the request is too large for **dev**, -EINVAL if "
"the request is invalid."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:883
msgid "Unpack xfer_mask into pio, mwdma and udma masks"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:884
msgid "xfer_mask to unpack"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:886
msgid "``unsigned int *pio_mask``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:885
msgid "resulting pio_mask"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:887
msgid "``unsigned int *mwdma_mask``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:886
msgid "resulting mwdma_mask"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:888
msgid "``unsigned int *udma_mask``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:887
msgid "resulting udma_mask"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:888
msgid ""
"Unpack **xfer_mask** into **pio_mask**, **mwdma_mask** and **udma_mask**. "
"Any NULL destination masks will be ignored."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1211
msgid "Read native max address"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1212
#: ../drivers/ata/libata-core.c:1263 ../drivers/ata/libata-core.c:1758
#: ../drivers/ata/libata-core.c:2021 ../drivers/ata/libata-core.c:2067
#: ../drivers/ata/libata-core.c:2105 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:320 ../drivers/ata/libata-eh.c:346
msgid "target device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1214
msgid "``u64 *max_sectors``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1213
msgid "out parameter for the result native max address"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1214
msgid ""
"Perform an LBA48 or LBA28 native size query upon the device in question."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1218
msgid ""
"0 on success, -EACCES if command is aborted by the drive. -EIO on other "
"errors."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1262
msgid "Set max sectors"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1265
msgid "``u64 new_sectors``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1264
msgid "new max sectors value to set for the device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1265
msgid "Set max sectors of **dev** to **new_sectors**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1268
msgid ""
"0 on success, -EACCES if command is aborted or denied (due to previous non-"
"volatile SET_MAX) by the drive.  -EIO on other errors."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1320
msgid "Resize a device with an HPA set"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1321
msgid "Device to resize"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1322
msgid ""
"Read the size of an LBA28 or LBA48 disk with HPA features and resize it if "
"required to the full size of the media. The caller must check the drive has "
"the HPA feature set enabled."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1327
#: ../drivers/ata/libata-core.c:5601 ../../../driver-api/libata:596:
#: ../drivers/ata/libata-eh.c:2127 ../drivers/ata/libata-eh.c:3489
#: ../drivers/ata/libata-eh.c:3787
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1416
msgid "IDENTIFY DEVICE info debugging output"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1417
msgid "device from which the information is fetched"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1418
msgid "IDENTIFY DEVICE page to dump"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1419
msgid "Dump selected 16-bit words from the given IDENTIFY DEVICE page."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1515
msgid "execute libata internal command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1516
msgid "Device to which the command is sent"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1517
msgid "Taskfile registers for the command and the result"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1519
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1334
#: ../drivers/ata/libata-scsi.c:1350 ../drivers/ata/libata-scsi.c:1366
#: ../drivers/ata/libata-scsi.c:1382
msgid "``const u8 *cdb``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1518
msgid "CDB for packet command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1520
msgid "``enum dma_data_direction dma_dir``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1519
msgid "Data transfer direction of the command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1521
#: ../drivers/ata/libata-core.c:2109
msgid "``void *buf``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1520
msgid "Data buffer of the command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1522
msgid "``unsigned int buflen``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1521
msgid "Length of data buffer"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1522
msgid "Timeout in msecs (0 for default)"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1523
msgid ""
"Executes libata internal command with timeout. **tf** contains the command "
"on entry and the result on return. Timeout and error conditions are reported "
"via the return value. No recovery action is taken after a command times out. "
"It is the caller's duty to clean up after timeout."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1529
msgid "LOCKING: None.  Should be called with kernel context, might sleep."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1533
msgid "Zero on success, AC_ERR_* mask on failure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1716
msgid "Return the non IORDY mask"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1718
msgid ""
"Compute the highest mode possible if we are not using iordy. Return -1 if no "
"iordy mode is available."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1757
msgid "Read ID data from the specified device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1760
msgid "``unsigned int *p_class``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1759
msgid "pointer to class of the target device (may be changed)"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1761
msgid "``unsigned int flags``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1760
msgid "ATA_READID_* flags"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1762
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2445
msgid "``u16 *id``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1761
msgid "buffer to read IDENTIFY data into"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1762
msgid ""
"Read ID data from the specified device.  ATA_CMD_ID_ATA is performed on ATA "
"devices and ATA_CMD_ID_ATAPI on ATAPI devices.  This function also issues "
"ATA_CMD_INIT_DEV_PARAMS for pre-ATA4 drives."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:1767
msgid ""
"FIXME: ATA_CMD_ID_ATA is optional for early drives and right now we abort if "
"we hit that case."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2020
msgid "Set a device power mode to standby"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2022
msgid ""
"Issue a STANDBY IMMEDIATE command to set a device power mode to standby. For "
"an HDD device, this spins down the disks."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2066
msgid "Set a device power mode to active"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2068
msgid ""
"Issue a VERIFY command to enter to ensure that the device is in the active "
"power mode. For a spun-down HDD (standby or idle power mode), the VERIFY "
"command will complete after the disk spins up."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2104
msgid "read a specific log page"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2107
msgid "``u8 log``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2106
msgid "log to read"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2108
msgid "``u8 page``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2107
msgid "page to read"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2108
msgid "buffer to store read page"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2110
msgid "``unsigned int sectors``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2109
msgid "number of sectors to read"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2110
msgid "Read log page using READ_LOG_EXT command."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2926
msgid "Configure the specified ATA/ATAPI device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2927
msgid "Target device to configure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2928
msgid ""
"Configure **dev** according to **dev->id**.  Generic and low-level driver "
"specific fixups are also applied."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:2935
msgid "0 on success, -errno otherwise"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3284
msgid "Print SATA link status"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3285
msgid "SATA link to printk link status about"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3286
msgid "This function prints link speed and status of a SATA link."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3331
msgid "find xfer mode for the specified cycle duration"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3337
msgid "``unsigned int xfer_shift``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3332
msgid "ATA_SHIFT_* value for transfer type to examine."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3334
msgid "``int cycle``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3333
msgid "cycle duration in ns"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3334
msgid ""
"Return matching xfer mode for **cycle**.  The returned mode is of the "
"transfer type specified by **xfer_shift**.  If **cycle** is too slow for "
"**xfer_shift**, 0xff is returned.  If **cycle** is faster than the fastest "
"known mode, the fasted mode is returned."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3343
msgid "Matching xfer_mode, 0xff if no match found."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3383
msgid "adjust dev xfer masks downward"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3384
msgid "Device to adjust xfer masks"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3386
msgid "``unsigned int sel``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3385
msgid "ATA_DNXFER_* selector"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3386
msgid ""
"Adjust xfer masks of **dev** downward.  Note that this function does not "
"apply the change.  Invoking ata_set_mode() afterwards will apply the limit."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3390
#: ../drivers/ata/libata-core.c:4891 ../drivers/ata/libata-core.c:5524
#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1814
msgid "LOCKING: Inherited from caller."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3394
msgid "0 on success, negative errno on failure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3655
msgid "wait for link to become ready"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3659
msgid ""
"Wait for **link** to become ready.  **check_ready** should return positive "
"number if **link** is ready, 0 if it isn't, -ENODEV if link doesn't seem to "
"be occupied, other errno for other error conditions."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3664
msgid "Transient -ENODEV conditions are allowed for ATA_TMOUT_FF_WAIT."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3836
msgid "Determine whether new ID matches configured device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3837
msgid "device to compare against"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3839
#: ../drivers/ata/libata-core.c:3921
msgid "``unsigned int new_class``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3838
msgid "class of the new device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3840
msgid "``const u16 *new_id``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3839
msgid "IDENTIFY page of the new device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3840
msgid ""
"Compare **new_class** and **new_id** against **dev** and determine whether "
"**dev** is the device indicated by **new_class** and **new_id**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3848
msgid "1 if **dev** matches **new_class** and **new_id**, 0 otherwise."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3885
msgid "Re-read IDENTIFY data"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3886
msgid "target ATA device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3888
#: ../drivers/ata/libata-core.c:3922
msgid "``unsigned int readid_flags``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3887
#: ../drivers/ata/libata-core.c:3921
msgid "read ID flags"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3888
msgid ""
"Re-read IDENTIFY page and make sure **dev** is still attached to the port."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3918
msgid "Revalidate ATA device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3919
msgid "device to revalidate"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3920
msgid "new class code"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:3922
msgid ""
"Re-read IDENTIFY page, make sure **dev** is still attached to the port and "
"reconfigure it according to the new IDENTIFY page."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4472
msgid "check drive side detection"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4474
msgid ""
"Perform drive side detection decoding, allowing for device vendors who can't "
"follow the documentation."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4487
msgid "40/80/SATA decider"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4488
msgid "port to consider"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4489
msgid ""
"This function encapsulates the policy for speed management in one place. At "
"the moment we don't cache the result but there is a good case for setting ap-"
">cbl to the result when we are called with unknown cables (and figuring out "
"if it impacts hotplug at all)."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4495
msgid "Return 1 if the cable appears to be 40 wire."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4538
msgid "Compute supported xfermask of the given device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4539
msgid "Device to compute xfermask for"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4540
msgid ""
"Compute supported xfermask of **dev** and store it in dev->*_mask.  This "
"function is responsible for applying all known limits including host "
"controller limits, device quirks, etc..."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4615
msgid "Issue SET FEATURES - XFER MODE command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4617
msgid ""
"Issue SET FEATURES - XFER MODE command to device **dev** on port **ap**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4697
msgid "Issue INIT DEV PARAMS command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4700
msgid "``u16 heads``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4699
msgid "Number of heads (taskfile parameter)"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4701
msgid "``u16 sectors``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4700
msgid "Number of sectors (taskfile parameter)"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4739
msgid "Check whether ATAPI DMA can be supported"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4740
msgid "Metadata associated with taskfile to check"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4749
msgid "0 when ATAPI DMA can be used nonzero otherwise"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4801
msgid "Associate command with scatter-gather table."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4802
msgid "Command to be associated"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4804
msgid "``struct scatterlist *sg``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4803
msgid "Scatter-gather table."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4805
msgid "``unsigned int n_elem``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4804
msgid "Number of elements in s/g table."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4805
msgid ""
"Initialize the data-related elements of queued_cmd **qc** to point to a "
"scatter-gather table **sg**, containing **n_elem** elements."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4824
msgid "Unmap DMA memory associated with command"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4825
msgid "Command containing DMA memory to be released"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4826
msgid "Unmap all mapped DMA memory associated with this command."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4848
msgid "DMA-map the scatter-gather table associated with a command."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4849
msgid "Command with scatter-gather table to be mapped."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4850
msgid "DMA-map the scatter-gather table associated with queued_cmd **qc**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4856
msgid "Zero on success, negative on error."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4884
msgid "swap halves of 16-bit words in place"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4890
msgid "``u16 *buf``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4885
msgid "Buffer to swap"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4887
msgid "``unsigned int buf_words``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4886
msgid "Number of 16-bit words in buffer."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4887
msgid ""
"Swap halves of 16-bit words if needed to convert from little-endian byte "
"order to native cpu byte order, or vice-versa."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4906
msgid "free unused ata_queued_cmd"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:4908
msgid ""
"Designed to free unused ata_queued_cmd object in case something prevents "
"using it."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5132
msgid "issue taskfile to device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5133
msgid "command to issue to device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5134
msgid ""
"Prepare an ATA command to submission to device. This includes mapping the "
"data into a DMA-able area, filling in the S/G table, and finally writing the "
"taskfile to hardware, starting the command."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5216
msgid ""
"Test whether **link** is online.  Note that this function returns 0 if "
"online status of **link** cannot be obtained, so ata_link_online(link) != !"
"ata_link_offline(link)."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5240
msgid ""
"Test whether **link** is offline.  Note that this function returns 0 if "
"offline status of **link** cannot be obtained, so ata_link_online(link) != !"
"ata_link_offline(link)."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5520
msgid "Initialize an ata_device structure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5521
msgid "Device structure to initialize"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5522
msgid "Initialize **dev** in preparation for probing."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5555
msgid "Initialize an ata_link structure"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5556
msgid "ATA port link is attached to"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5557
msgid "Link structure to initialize"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5559
msgid "``int pmp``"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5558
msgid "Port multiplier port number"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5559
msgid "Initialize **link**."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5592
msgid "Initialize link->sata_spd_limit"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5593
msgid "Link to configure sata_spd_limit for"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5594
msgid ""
"Initialize ``link->[hw_]sata_spd_limit`` to the currently configured value."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5874
msgid "finalize ata_port_operations"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5875
msgid "ata_port_operations to finalize"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5876
msgid ""
"An ata_port_operations can inherit from another ops and that ops can again "
"inherit from another.  This can go on as many times as necessary as long as "
"there is no loop in the inheritance chain."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5881
msgid ""
"Ops tables are finalized when the host is started.  NULL or unspecified "
"entries are inherited from the closet ancestor which has the method and the "
"entry is populated with it. After finalization, the ops table directly "
"points to all the methods and ->inherits is no longer necessary and cleared."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:5887
msgid "Using ATA_OP_NULL, inheriting ops can force a method to NULL."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6218
msgid "Free a device resources"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6219
msgid "Target ATA device"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6220
msgid "Free resources allocated to support a device features."
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6235
msgid "Detach ATA port in preparation of device removal"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6236
msgid "ATA port to be detached"
msgstr ""

#: ../../../driver-api/libata:593: ../drivers/ata/libata-core.c:6237
msgid ""
"Detach all ATA devices and the associated SCSI devices of **ap**; then, "
"remove the associated SCSI host.  **ap** is guaranteed to be quiescent on "
"return from this function."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:176
msgid "push error description without adding separator"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:182
#: ../drivers/ata/libata-eh.c:202 ../drivers/ata/libata-eh.c:226
msgid "``struct ata_eh_info *ehi``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:177
#: ../drivers/ata/libata-eh.c:197 ../drivers/ata/libata-eh.c:221
msgid "target EHI"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:179
#: ../drivers/ata/libata-eh.c:199 ../drivers/ata/libata-eh.c:239
msgid "``const char *fmt``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:178
#: ../drivers/ata/libata-eh.c:198 ../drivers/ata/libata-eh.c:238
msgid "printf format string"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:180
#: ../drivers/ata/libata-eh.c:200 ../drivers/ata/libata-eh.c:240
msgid "``...``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:179
msgid "Format string according to **fmt** and append it to **ehi->desc**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:196
msgid "push error description with separator"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:199
msgid ""
"Format string according to **fmt** and append it to **ehi->desc**. If **ehi-"
">desc** is not empty, \", \" is added in-between."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:220
msgid "clean error description"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:222
msgid "Clear **ehi->desc**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:236
msgid "append port description"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:237
#: ../drivers/ata/libata-eh.c:266 ../drivers/ata/libata-eh.c:901
msgid "target ATA port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:239
msgid ""
"Format string according to **fmt** and append it to port description.  If "
"port description is not empty, \" \" is added in-between.  This function is "
"to be used while initializing ata_host.  The description is printed on host "
"registration."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:265
msgid "append PCI BAR description"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:268
msgid "``int bar``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:267
msgid "target PCI BAR"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:269
msgid "``ssize_t offset``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:268
msgid "offset into PCI BAR"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:270
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:269
msgid "name of the area"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:270
msgid ""
"If **offset** is negative, this function formats a string which contains the "
"name, address, size and type of the BAR and appends it to the port "
"description.  If **offset** is zero or positive, only name and offsetted "
"address is appended."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:319
msgid "determine timeout for an internal command"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:322
#: ../drivers/ata/libata-eh.c:348 ../../../driver-api/libata:604:
#: ../drivers/ata/libata-scsi.c:4363
msgid "``u8 cmd``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:321
msgid "internal command to be issued"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:322
msgid "Determine timeout for internal command **cmd** for **dev**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:328
msgid "Determined timeout."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:345
msgid "notification for internal command timeout"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:347
msgid "internal command which timed out"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:348
msgid ""
"Notify EH that internal command **cmd** for **dev** timed out.  This "
"function should be called only for commands whose timeouts are determined "
"using ata_internal_cmd_timeout()."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:461
msgid "acquire EH ownership"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:462
msgid "ATA port to acquire EH ownership for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:463
msgid ""
"Acquire EH ownership for **ap**.  This is the basic exclusion mechanism for "
"ports sharing a host.  Only one port hanging off the same host can claim the "
"ownership of EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:479
msgid "release EH ownership"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:480
msgid "ATA port to release EH ownership for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:481
msgid ""
"Release EH ownership for **ap** if the caller.  The caller must have "
"acquired EH ownership using ata_eh_acquire() previously."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:548
msgid "SCSI layer error handler callback"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:554
#: ../drivers/ata/libata-eh.c:587 ../drivers/ata/libata-eh.c:691
msgid "``struct Scsi_Host *host``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:549
msgid "SCSI host on which error occurred"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:550
msgid "Handles SCSI-layer-thrown error events."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:552
msgid "LOCKING: Inherited from SCSI layer (none, can sleep)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:556
#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:366
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4923
msgid "Zero."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:581
msgid "error callback for a list of commands"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:582
msgid "scsi host containing the port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:583
msgid "ATA port within the host"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:585
msgid "``struct list_head *eh_work_q``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:584
msgid "list of commands to process"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:585
msgid ""
"process the given list of commands and return those finished to the ap-"
">eh_done_q.  This function is the first part of the libata error handler "
"which processes a given list of failed commands."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:685
msgid "recover the port after the commands"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:686
msgid "SCSI host containing the port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:687
msgid "the ATA port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:688
msgid ""
"Handle the recovery of the port **ap** after all the commands have been "
"recovered."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:811
msgid "Wait for the currently pending EH to complete"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:812
msgid "Port to wait EH for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:813
msgid "Wait until the currently pending EH is complete."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:900
msgid "set ATA_PFLAG_EH_PENDING and activate fast drain"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:903
msgid "``bool fastdrain``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:902
msgid "activate fast drain"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:903
msgid ""
"Set ATA_PFLAG_EH_PENDING and activate fast drain if **fastdrain** is non-"
"zero and EH wasn't pending before.  Fast drain ensures that EH kicks in in "
"timely manner."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:943
msgid "schedule qc for error handling"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:944
msgid "command to schedule error handling for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:945
msgid ""
"Schedule error handling for **qc**.  EH will kick in as soon as other "
"commands are drained."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:968
msgid "non-libsas ata_ports issue eh with this common routine"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:969
#: ../drivers/ata/libata-eh.c:1009
msgid "ATA port to schedule EH for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:970
msgid ""
"LOCKING: inherited from ata_port_schedule_eh spin_lock_irqsave(host lock)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:987
msgid "non-libsas ata_ports complete eh with this common routine"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:988
msgid "ATA port to end EH for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:989
msgid ""
"In the libata object model there is a 1:1 mapping of ata_port to shost, so "
"host fields can be directly manipulated under ap->lock, in the libsas case "
"we need to hold a lock at the ha->level to coordinate these events."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1008
msgid "schedule error handling without a qc"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1010
msgid ""
"Schedule error handling for **ap**.  EH will kick in as soon as all commands "
"are drained."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1048
msgid "abort all qc's on the link"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1049
msgid "ATA link to abort qc's for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1050
msgid "Abort all active qc's active on **link** and schedule EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1056
#: ../drivers/ata/libata-eh.c:1074
msgid "Number of aborted qc's."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1066
msgid "abort all qc's on the port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1067
msgid "ATA port to abort qc's for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1068
msgid "Abort all active qc's of **ap** and schedule EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1070
msgid "LOCKING: spin_lock_irqsave(host_set lock)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1084
msgid "freeze port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1085
#: ../drivers/ata/libata-eh.c:1113 ../drivers/ata/libata-eh.c:1135
msgid "ATA port to freeze"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1086
msgid ""
"This function is called when HSM violation or some other condition disrupts "
"normal operation of the port.  Frozen port is not allowed to perform any "
"operation until the port is thawed, which usually follows a successful reset."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1091
msgid ""
"ap->ops->freeze() callback can be used for freezing the port hardware-wise "
"(e.g. mask interrupt and stop DMA engine).  If a port cannot be frozen "
"hardware-wise, the interrupt handler must ack and clear interrupts "
"unconditionally while the port is frozen."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1112
msgid "abort & freeze port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1114
msgid ""
"Abort and freeze **ap**.  The freeze operation must be called first, because "
"some hardware requires special operations before the taskfile registers are "
"accessible."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1122
msgid "Number of aborted commands."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1134
msgid "EH helper to freeze port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1136
msgid "Freeze **ap**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1153
msgid "EH helper to thaw port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1154
msgid "ATA port to thaw"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1155
msgid "Thaw frozen port **ap**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1198
msgid "Complete an active ATA command from EH"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1200
msgid ""
"Indicate to the mid and upper layers that an ATA command has completed.  To "
"be used from EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1212
msgid "Tell midlayer to retry an ATA command after EH"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1213
msgid "Command to retry"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1214
msgid ""
"Indicate to the mid and upper layers that an ATA command should be retried.  "
"To be used from EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1217
msgid ""
"SCSI midlayer limits the number of retries to scmd->allowed. scmd->allowed "
"is incremented for commands which get retried due to unrelated failures (qc-"
">err_mask is zero)."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1231
msgid "disable ATA device"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1232
msgid "ATA device to disable"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1233
msgid "Disable **dev**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1235
msgid "Locking: EH context."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1251
msgid "detach ATA device"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1252
msgid "ATA device to detach"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1253
msgid "Detach **dev**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1294
msgid "about to perform eh_action"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1295
msgid "target ATA link"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1296
#: ../drivers/ata/libata-eh.c:1332
msgid "target ATA dev for per-dev action (can be NULL)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1298
#: ../drivers/ata/libata-eh.c:1334
msgid "``unsigned int action``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1297
msgid "action about to be performed"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1298
msgid ""
"Called just before performing EH actions to clear related bits in **link-"
">eh_info** such that eh actions are not unnecessarily repeated."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1330
msgid "EH action complete"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1331
msgid "ATA link for which EH actions are complete"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1333
msgid "action just completed"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1334
msgid ""
"Called right after performing EH actions to clear related bits in **link-"
">eh_context**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1352
msgid "convert err_mask to descriptive string"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1358
#: ../drivers/ata/libata-eh.c:1869
msgid "``unsigned int err_mask``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1353
msgid "error mask to convert to string"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1354
msgid ""
"Convert **err_mask** to descriptive string.  Errors are prioritized "
"according to severity and only the most severe error is reported."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1362
msgid "Descriptive string for **err_mask**"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1391
msgid "perform ATAPI TEST_UNIT_READY"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1392
msgid "target ATAPI device"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1394
msgid "``u8 *r_sense_key``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1393
msgid "out parameter for sense_key"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1394
msgid "Perform ATAPI TEST_UNIT_READY."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1396
#: ../drivers/ata/libata-eh.c:3485
msgid "LOCKING: EH context (may sleep)."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1400
msgid "0 on success, AC_ERR_* mask on failure."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1422
msgid "Disposition a qc based on sense data"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1423
msgid "qc to examine"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1424
msgid ""
"For a regular SCSI command, the SCSI completion callback (scsi_done()) will "
"call scsi_complete(), which will call scsi_decide_disposition(), which will "
"call scsi_check_sense(). scsi_complete() finally calls "
"scsi_finish_command(). This is fine for SCSI, since any eventual sense data "
"is usually returned in the completion itself (without invoking SCSI EH). "
"However, for a QC, we always need to fetch the sense data explicitly using "
"SCSI EH."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1432
msgid ""
"A command that is completed via SCSI EH will instead be completed using "
"scsi_eh_flush_done_q(), which will call scsi_finish_command() directly "
"(without ever calling scsi_check_sense())."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1436
msgid ""
"For a command that went through SCSI EH, it is the responsibility of the "
"SCSI EH strategy handler to call scsi_decide_disposition(), see e.g. how "
"scsi_eh_get_sense() calls scsi_decide_disposition() for SCSI LLDDs that do "
"not get the sense data as part of the completion."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1441
msgid ""
"Thus, for QC commands that went via SCSI EH, we need to call "
"scsi_check_sense() ourselves, similar to how scsi_eh_get_sense() calls "
"scsi_decide_disposition(), which calls scsi_check_sense(), in order to set "
"the correct SCSI ML byte (if any)."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1450
msgid "SUCCESS or FAILED or NEEDS_RETRY or ADD_TO_MLQUEUE"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1459
msgid "perform REQUEST_SENSE_DATA_EXT"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1460
msgid "qc to perform REQUEST_SENSE_SENSE_DATA_EXT to"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1461
msgid ""
"Perform REQUEST_SENSE_DATA_EXT after the device reported CHECK SENSE.  This "
"function is an EH helper."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1468
msgid "true if sense data could be fetched, false otherwise."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1514
msgid "perform ATAPI REQUEST_SENSE"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1515
msgid "device to perform REQUEST_SENSE to"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1517
msgid "``u8 *sense_buf``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1516
msgid "result sense data buffer (SCSI_SENSE_BUFFERSIZE bytes long)"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1518
msgid "``u8 dfl_sense_key``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1517
msgid "default sense key to use"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1518
msgid ""
"Perform ATAPI REQUEST_SENSE after the device reported CHECK SENSE.  This "
"function is EH helper."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1525
msgid "0 on success, AC_ERR_* mask on failure"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1572
msgid "analyze SError for a failed port"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1573
msgid "ATA link to analyze SError for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1574
msgid "Analyze SError if available and further determine cause of failure."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1621
msgid "analyze taskfile of a failed qc"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1622
msgid "qc to analyze"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1623
msgid ""
"Analyze taskfile of **qc** and further determine cause of failure.  This "
"function also requests ATAPI sense data if available."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1631
msgid "Determined recovery action"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1765
msgid "Determine speed down verdict"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1766
msgid "Device of interest"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1767
msgid ""
"This function examines error ring of **dev** and determines whether NCQ "
"needs to be turned off, transfer speed should be stepped down, or falling "
"back to PIO is necessary."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1771
msgid "ECAT_ATA_BUS    : ATA_BUS error for any command"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1773
msgid "ECAT_TOUT_HSM"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:-1
msgid "TIMEOUT for any command or HSM violation for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1774
msgid "IO commands"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1776
msgid "ECAT_UNK_DEV    : Unknown DEV error for IO commands"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1778
msgid "ECAT_DUBIOUS_*"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:-1
msgid "Identical to above three but occurred while"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1779
msgid "data transfer hasn't been verified."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1781
msgid "Verdicts are"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1783
msgid "NCQ_OFF         : Turn off NCQ."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1785
msgid "SPEED_DOWN"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:-1
msgid "Speed down transfer speed but don't fall back"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1786
msgid "to PIO."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1788
msgid "FALLBACK_TO_PIO : Fall back to PIO."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1790
msgid ""
"Even if multiple verdicts are returned, only one action is taken per error.  "
"An action triggered by non-DUBIOUS errors clears ering, while one triggered "
"by DUBIOUS_* errors doesn't. This is to expedite speed down decisions right "
"after device is initially configured."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1796
msgid ""
"The following are speed down rules.  #1 and #2 deal with DUBIOUS errors."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1799
msgid ""
"If more than one DUBIOUS_ATA_BUS or DUBIOUS_TOUT_HSM errors occurred during "
"last 5 mins, SPEED_DOWN and FALLBACK_TO_PIO."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1802
msgid ""
"If more than one DUBIOUS_TOUT_HSM or DUBIOUS_UNK_DEV errors occurred during "
"last 5 mins, NCQ_OFF."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1805
msgid ""
"If more than 8 ATA_BUS, TOUT_HSM or UNK_DEV errors occurred during last 5 "
"mins, FALLBACK_TO_PIO"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1808
msgid ""
"If more than 3 TOUT_HSM or UNK_DEV errors occurred during last 10 mins, "
"NCQ_OFF."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1811
msgid ""
"If more than 3 ATA_BUS or TOUT_HSM errors, or more than 6 UNK_DEV errors "
"occurred during last 10 mins, SPEED_DOWN."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1818
msgid "OR of ATA_EH_SPDN_* flags."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1865
msgid "record error and speed down if necessary"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1866
msgid "Failed device"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1868
msgid "``unsigned int eflags``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1867
msgid "mask of ATA_EFLAG_* flags"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1868
msgid "err_mask of the error"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1869
msgid ""
"Record error and examine error history to determine whether adjusting "
"transmission speed is necessary.  It also sets transmission limits "
"appropriately if such adjustment is necessary."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1878
msgid "Determined recovery action."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1956
msgid "analyze error and decide whether to retry"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1957
msgid "qc to possibly retry"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1958
msgid ""
"Look at the cause of the error and decide if a retry might be useful or "
"not.  We don't want to retry media errors because the drive itself has "
"probably already taken 10-30 seconds doing its own internal retries before "
"reporting the failure."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1976
msgid "check if we need to be quiet about a command error"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1977
msgid "qc to check"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:1978
msgid ""
"Look at the qc flags anbd its scsi command request flags to determine if we "
"need to be quiet about the command failure."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2114
msgid "configure SATA interface power management"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2115
msgid "link to configure"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2117
msgid "``enum ata_lpm_policy policy``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2116
msgid "the link power management policy"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2118
msgid ""
"Enable SATA Interface power management.  This will enable Device Interface "
"Power Management (DIPM) for min_power and medium_power_with_dipm policies, "
"and then call driver specific callbacks for enabling Host Initiated Power "
"management."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2264
#: ../drivers/ata/libata-eh.c:2404
msgid "analyze error and determine recovery action"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2265
msgid "host link to perform autopsy on"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2266
msgid ""
"Analyze why **link** failed and determine which recovery actions are "
"needed.  This function also sets more detailed AC_ERR_* values and fills "
"sense data for ATAPI CHECK SENSE."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2405
msgid "host port to perform autopsy on"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2406
msgid ""
"Analyze all links of **ap** and determine why they failed and which recovery "
"actions are needed."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2450
msgid "get name for ATA command"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2456
msgid "``u8 command``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2451
msgid "ATA command code to get name for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2452
msgid "Return a textual name of the given command or \"unknown\""
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2454
msgid "LOCKING: None"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2572
#: ../drivers/ata/libata-eh.c:2767
msgid "report error handling to user"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2573
msgid "ATA link EH is going on"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2574
#: ../drivers/ata/libata-eh.c:2769
msgid "Report EH to user."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:2768
msgid "ATA port to report EH about"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3429
msgid ""
"Set ATA device disk transfer mode (PIO3, UDMA6, etc.).  If ata_eh_set_mode() "
"fails, pointer to the failing device is returned in **r_failed_dev**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3479
msgid "Clear ATAPI UNIT ATTENTION after reset"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3480
msgid "ATAPI device to clear UA for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3481
msgid ""
"Resets and other operations can make an ATAPI device raise UNIT ATTENTION "
"which causes the next operation to fail.  This function clears UA."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3527
msgid "Retry FLUSH if necessary"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3528
msgid "ATA device which may need FLUSH retry"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3529
msgid ""
"If **dev** failed FLUSH, it needs to be reported upper layer immediately as "
"it means that **dev** failed to remap and already lost at least a sector and "
"further FLUSH retrials won't make any difference to the lost sector.  "
"However, if FLUSH failed for other reasons, for example transmission error, "
"FLUSH needs to be retried."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3536
msgid ""
"This function determines whether FLUSH failure retry is necessary and "
"performs it if so."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3540
msgid "0 if EH can continue, -errno if EH needs to be repeated."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3772
msgid "recover host port after error"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3773
msgid "host port to recover"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3775
msgid "``struct ata_reset_operations *reset_ops``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3774
msgid "The set of reset operations to use"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3776
msgid "``struct ata_link **r_failed_link``"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3775
msgid "out parameter for failed link"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:3776
msgid ""
"This is the alpha and omega, eum and yang, heart and soul of libata "
"exception handling.  On entry, actions required to recover each link and "
"hotplug requests are recorded in the link's eh_context.  This function "
"executes all the operations with appropriate retrials and fallbacks to "
"resurrect failed devices, detach goners and greet newcomers."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4020
msgid "finish up EH"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4021
msgid "host port to finish EH for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4022
msgid ""
"Recovery is complete.  Clean up EH states and retry or finish failed qcs."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4079
msgid "standard error handler"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4080
msgid "host port to handle error for"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4081
msgid "Perform standard error handling sequence."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4116
msgid "perform port suspend operation"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4117
msgid "port to suspend"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4118
msgid "Suspend **ap**."
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4193
msgid "perform port resume operation"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4194
msgid "port to resume"
msgstr ""

#: ../../../driver-api/libata:596: ../drivers/ata/libata-eh.c:4195
msgid "Resume **ap**."
msgstr ""

#: ../../../driver-api/libata.rst:599
msgid "libata SCSI translation/emulation"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:352
msgid "generic bios head/sector/cylinder calculator used by sd."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:358
#: ../drivers/ata/libata-scsi.c:388 ../drivers/ata/libata-scsi.c:1145
#: ../drivers/ata/libata-scsi.c:1181 ../drivers/ata/libata-scsi.c:1206
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:415
msgid "``struct scsi_device *sdev``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:353
msgid "SCSI device for which BIOS geometry is to be determined"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:355
msgid "``struct gendisk *unused``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:354
msgid "gendisk associated with **sdev**"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:356
msgid "``sector_t capacity``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:355
msgid "capacity of SCSI device"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:357
msgid "``int geom[]``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:356
msgid "location to which geometry will be output"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:357
msgid ""
"Generic bios head/sector/cylinder calculator used by sd. Most BIOSes "
"nowadays expect a XXX/255/16  (CHS) mapping. Some situations may arise where "
"the disk is not bootable if this is not used."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:362
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:416
#: ../drivers/ata/libata-scsi.c:455 ../drivers/ata/libata-scsi.c:563
msgid "LOCKING: Defined by the SCSI layer.  We don't really care."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:382
msgid "unlock native capacity"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:383
msgid "SCSI device to adjust device capacity for"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:384
msgid ""
"This function is called if a partition on **sdev** extends beyond the end of "
"the device.  It requests EH to unlock HPA."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:387
msgid "LOCKING: Defined by the SCSI layer.  Might sleep."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1042
msgid "Check whether data transfer may overflow"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1048
msgid "``struct request *rq``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1043
msgid "request to be checked"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1044
msgid ""
"ATAPI commands which transfer variable length data to host might overflow "
"due to application error or hardware bug.  This function checks whether "
"overflow should be drained and ignored for **request**."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1053
msgid "1 if ; otherwise, 0."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1139
msgid "Early setup of SCSI device"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1140
#: ../drivers/ata/libata-scsi.c:1176
msgid "SCSI device to examine"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1141
msgid ""
"This is called from scsi_alloc_sdev() when the scsi device associated with "
"an ATA device is scanned on a port."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1144
#: ../drivers/ata/libata-scsi.c:1182 ../drivers/ata/libata-scsi.c:1209
msgid "LOCKING: Defined by SCSI layer.  We don't really care."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1175
msgid "Set SCSI device attributes"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1178
msgid "``struct queue_limits *lim``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1177
msgid "queue limits"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1178
msgid ""
"This is called before we actually start reading and writing to the device, "
"to configure certain SCSI mid-layer behaviors."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1200
msgid "SCSI device is about to be destroyed"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1201
msgid "SCSI device to be destroyed"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:1202
msgid ""
"**sdev** is about to be destroyed for hot/warm unplugging.  If this "
"unplugging was initiated by libata as indicated by NULL dev->sdev, this "
"function doesn't have to do anything. Otherwise, SCSI layer initiated warm-"
"unplug is in progress. Clear dev->sdev, schedule the device for ATA detach "
"and invoke EH."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4483
msgid "Issue SCSI cdb to libata-managed device"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4489
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4917
msgid "``struct Scsi_Host *shost``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4484
msgid "SCSI host of command to be sent"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4486
#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:727
#: ../drivers/ata/libata-scsi.c:1827 ../drivers/ata/libata-scsi.c:1895
#: ../drivers/ata/libata-scsi.c:1933 ../drivers/ata/libata-scsi.c:2022
#: ../drivers/ata/libata-scsi.c:2060 ../drivers/ata/libata-scsi.c:2088
#: ../drivers/ata/libata-scsi.c:2150 ../drivers/ata/libata-scsi.c:2188
#: ../drivers/ata/libata-scsi.c:2240 ../drivers/ata/libata-scsi.c:2270
#: ../drivers/ata/libata-scsi.c:2293 ../drivers/ata/libata-scsi.c:2331
#: ../drivers/ata/libata-scsi.c:2368 ../drivers/ata/libata-scsi.c:2637
#: ../drivers/ata/libata-scsi.c:2769 ../drivers/ata/libata-scsi.c:2857
#: ../drivers/ata/libata-scsi.c:3418 ../drivers/ata/libata-scsi.c:3582
#: ../drivers/ata/libata-scsi.c:4532
msgid "``struct scsi_cmnd *cmd``"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4485
msgid "SCSI command to be sent"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4486
msgid ""
"In some cases, this function translates SCSI commands into ATA taskfiles, "
"and queues the taskfiles to be sent to hardware.  In other cases, this "
"function simulates a SCSI device by evaluating and responding to certain "
"SCSI commands.  This creates the overall effect of ATA and ATAPI devices "
"appearing as SCSI devices."
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4493
msgid "LOCKING: ATA host lock"
msgstr ""

#: ../../../driver-api/libata:601: ../drivers/ata/libata-scsi.c:4497
msgid ""
"Return value from __ata_scsi_queuecmd() if **cmd** can be queued, 0 "
"otherwise."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:238
msgid "Set ATA fields in sense buffer"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:239
msgid "ATA PASS-THROUGH command."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:240
msgid ""
"Populates \"ATA Status Return sense data descriptor\" / \"Fixed format sense "
"data\" with ATA taskfile fields."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:412
msgid "Handler for HDIO_GET_IDENTITY ioctl"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:413
msgid "target port"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:414
msgid "SCSI device to get identify data for"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:416
#: ../drivers/ata/libata-scsi.c:455 ../drivers/ata/libata-scsi.c:563
msgid "``void __user *arg``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:415
msgid "User buffer area for identify data"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:420
#: ../drivers/ata/libata-scsi.c:459 ../drivers/ata/libata-scsi.c:567
msgid "Zero on success, negative errno on error."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:452
msgid "Handler for HDIO_DRIVE_CMD ioctl"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:458
#: ../drivers/ata/libata-scsi.c:566
msgid "``struct scsi_device *scsidev``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:453
#: ../drivers/ata/libata-scsi.c:561
msgid "Device to which we are issuing command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:454
#: ../drivers/ata/libata-scsi.c:562
msgid "User provided data for issuing command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:560
msgid "Handler for HDIO_DRIVE_TASK ioctl"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:724
msgid "acquire new ata_queued_cmd reference"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:725
msgid "ATA device to which the new command is attached"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:726
msgid "SCSI command that originated this ATA command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:727
msgid ""
"Obtain a reference to an unused ata_queued_cmd structure, which is the basic "
"libata structure representing a single ATA command sent to the hardware."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:731
msgid ""
"If a command was available, fill in the SCSI-specific portions of the "
"structure with information on the current command."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:739
msgid "Command allocated, or ``NULL`` if none available."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:798
msgid "convert ATA error to SCSI error"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:804
msgid "``u8 drv_stat``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:799
msgid "value contained in ATA status register"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:801
msgid "``u8 drv_err``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:800
msgid "value contained in ATA error register"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:802
msgid "``u8 *sk``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:801
msgid "the sense key we'll fill out"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:803
msgid "``u8 *asc``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:802
msgid "the additional sense code we'll fill out"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:804
msgid "``u8 *ascq``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:803
msgid "the additional sense code qualifier we'll fill out"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:804
msgid ""
"Converts an ATA error into a SCSI error.  Fill out pointers to SK, ASC, and "
"ASCQ bytes for later use in fixed or descriptor format sense blocks."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:973
msgid "generate a SCSI fixed sense block"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:974
msgid "Command that we are erroring out"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:975
msgid "Generate sense block for a failed ATA command **qc**."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1236
msgid "Translate SCSI START STOP UNIT command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1237
#: ../drivers/ata/libata-scsi.c:1298 ../drivers/ata/libata-scsi.c:1389
#: ../drivers/ata/libata-scsi.c:1532 ../drivers/ata/libata-scsi.c:3912
#: ../drivers/ata/libata-scsi.c:4064 ../drivers/ata/libata-scsi.c:4090
msgid "Storage for translated ATA taskfile"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1238
msgid ""
"Sets up an ATA taskfile to issue STANDBY (to stop) or READ VERIFY (to "
"start). Perhaps these commands should be preceded by CHECK POWER MODE to see "
"what power mode the device is already in. [See SAT revision 5 at www.t10.org]"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1247
#: ../drivers/ata/libata-scsi.c:1306 ../drivers/ata/libata-scsi.c:1396
#: ../drivers/ata/libata-scsi.c:1545
msgid "Zero on success, non-zero on error."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1297
msgid "Translate SCSI SYNCHRONIZE CACHE command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1299
msgid "Sets up an ATA taskfile to issue FLUSH CACHE or FLUSH CACHE EXT."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1328
#: ../drivers/ata/libata-scsi.c:1344 ../drivers/ata/libata-scsi.c:1360
msgid "Get LBA and transfer length"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1329
#: ../drivers/ata/libata-scsi.c:1345 ../drivers/ata/libata-scsi.c:1361
#: ../drivers/ata/libata-scsi.c:1377
msgid "SCSI command to translate"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1331
#: ../drivers/ata/libata-scsi.c:1347 ../drivers/ata/libata-scsi.c:1363
msgid "``u64 *plba``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1334
#: ../drivers/ata/libata-scsi.c:1350 ../drivers/ata/libata-scsi.c:1366
msgid "the LBA"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1336
#: ../drivers/ata/libata-scsi.c:1352 ../drivers/ata/libata-scsi.c:1368
msgid "``u32 *plen``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1335
#: ../drivers/ata/libata-scsi.c:1351 ../drivers/ata/libata-scsi.c:1367
msgid "the transfer length"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1330
msgid "Calculate LBA and transfer length for 6-byte commands."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1346
msgid "Calculate LBA and transfer length for 10-byte commands."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1362
msgid "Calculate LBA and transfer length for 16-byte commands."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1376
msgid "Get duration limit descriptor index"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1378
msgid ""
"Returns the dld bits indicating the index of a command duration limit "
"descriptor."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1388
msgid "Translate SCSI VERIFY command into an ATA one"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1390
msgid "Converts SCSI VERIFY command to an ATA READ VERIFY command."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1531
msgid "Translate SCSI r/w command into an ATA one"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1533
msgid ""
"Converts any of six SCSI read/write commands into the ATA counterpart, "
"including starting sector (LBA), sector count, and taking into account the "
"device's LBA48 support."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1538
msgid ""
"Commands ``READ_6``, ``READ_10``, ``READ_16``, ``WRITE_6``, ``WRITE_10``, "
"and ``WRITE_16`` are currently supported."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1824
msgid "Translate then issue SCSI command to ATA device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1825
msgid "ATA device to which the command is addressed"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1826
msgid "SCSI command to execute"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1828
msgid "``ata_xlat_func_t xlat_func``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1827
msgid "Actor which translates **cmd** to an ATA taskfile"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1828
msgid ""
"Our ->queuecommand() function has decided that the SCSI command issued can "
"be directly translated into an ATA command, rather than handled internally."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1832
msgid ""
"This function sets up an ata_queued_cmd structure for the SCSI command, and "
"sends that ata_queued_cmd to the hardware."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1835
msgid ""
"The xlat_func argument (actor) returns 0 if ready to execute ATA command, "
"else 1 to finish translation. If 1 is returned then cmd->result (and "
"possibly cmd->sense_buffer) are assumed to be set reflecting an error "
"condition or clean (early) termination."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1845
msgid ""
"0 on success, SCSI_ML_QUEUE_DEVICE_BUSY or SCSI_MLQUEUE_HOST_BUSY if the "
"command needs to be deferred."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1892
msgid "wrapper for SCSI command simulators"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1893
#: ../drivers/ata/libata-scsi.c:1931 ../drivers/ata/libata-scsi.c:2020
#: ../drivers/ata/libata-scsi.c:2058 ../drivers/ata/libata-scsi.c:2086
#: ../drivers/ata/libata-scsi.c:2148 ../drivers/ata/libata-scsi.c:2186
#: ../drivers/ata/libata-scsi.c:2238 ../drivers/ata/libata-scsi.c:2268
#: ../drivers/ata/libata-scsi.c:2291 ../drivers/ata/libata-scsi.c:2329
#: ../drivers/ata/libata-scsi.c:2366 ../drivers/ata/libata-scsi.c:2635
#: ../drivers/ata/libata-scsi.c:2767 ../drivers/ata/libata-scsi.c:2855
#: ../drivers/ata/libata-scsi.c:3580
msgid "Target device."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1894
#: ../drivers/ata/libata-scsi.c:1932 ../drivers/ata/libata-scsi.c:2021
#: ../drivers/ata/libata-scsi.c:2059 ../drivers/ata/libata-scsi.c:2087
#: ../drivers/ata/libata-scsi.c:2149 ../drivers/ata/libata-scsi.c:2187
#: ../drivers/ata/libata-scsi.c:2239 ../drivers/ata/libata-scsi.c:2269
#: ../drivers/ata/libata-scsi.c:2292 ../drivers/ata/libata-scsi.c:2330
#: ../drivers/ata/libata-scsi.c:2367 ../drivers/ata/libata-scsi.c:2636
#: ../drivers/ata/libata-scsi.c:2768 ../drivers/ata/libata-scsi.c:2856
#: ../drivers/ata/libata-scsi.c:3581
msgid "SCSI command of interest."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1896
msgid ""
"``unsigned int (*actor)(struct ata_device *dev, struct scsi_cmnd *cmd, u8 "
"*rbuf)``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1895
msgid "Callback hook for desired SCSI command simulator"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1896
msgid ""
"Takes care of the hard work of simulating a SCSI command... Mapping the "
"response buffer, calling the command's handler, and handling the handler's "
"return value.  This return value indicates whether the handler wishes the "
"SCSI command to be completed successfully (0), or not (in which case cmd-"
">result and sense buffer are assumed to be set)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1930
msgid "Simulate standard INQUIRY command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1934
#: ../drivers/ata/libata-scsi.c:2023 ../drivers/ata/libata-scsi.c:2061
#: ../drivers/ata/libata-scsi.c:2089 ../drivers/ata/libata-scsi.c:2151
#: ../drivers/ata/libata-scsi.c:2189 ../drivers/ata/libata-scsi.c:2241
#: ../drivers/ata/libata-scsi.c:2271 ../drivers/ata/libata-scsi.c:2294
#: ../drivers/ata/libata-scsi.c:2332 ../drivers/ata/libata-scsi.c:2369
#: ../drivers/ata/libata-scsi.c:2638 ../drivers/ata/libata-scsi.c:2770
#: ../drivers/ata/libata-scsi.c:2858 ../drivers/ata/libata-scsi.c:3583
msgid "``u8 *rbuf``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1933
#: ../drivers/ata/libata-scsi.c:2022 ../drivers/ata/libata-scsi.c:2060
#: ../drivers/ata/libata-scsi.c:2088 ../drivers/ata/libata-scsi.c:2150
#: ../drivers/ata/libata-scsi.c:2188 ../drivers/ata/libata-scsi.c:2240
#: ../drivers/ata/libata-scsi.c:2270 ../drivers/ata/libata-scsi.c:2293
#: ../drivers/ata/libata-scsi.c:2331 ../drivers/ata/libata-scsi.c:2368
#: ../drivers/ata/libata-scsi.c:2637 ../drivers/ata/libata-scsi.c:2769
#: ../drivers/ata/libata-scsi.c:2857 ../drivers/ata/libata-scsi.c:3582
msgid "Response buffer, to which simulated SCSI cmd output is sent."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:1934
msgid ""
"Returns standard device identification data associated with non-VPD INQUIRY "
"command output."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2019
msgid "Simulate INQUIRY VPD page 0, list of pages"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2023
msgid "Returns list of inquiry VPD pages available."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2057
msgid "Simulate INQUIRY VPD page 80, device serial number"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2061
msgid "Returns ATA device serial number."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2085
msgid "Simulate INQUIRY VPD page 83, device identity"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2089
msgid "Yields two logical unit device identification designators:"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2090
msgid "vendor specific ASCII containing the ATA serial number"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2091
msgid ""
"SAT defined \"t10 vendor id based\" containing ASCII vendor name (\"ATA     "
"\"), model and serial numbers."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2147
msgid "Simulate INQUIRY VPD page 89, ATA info"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2151
msgid "Yields SAT-specified ATA VPD page."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2185
msgid "Simulate INQUIRY VPD page B0, Block Limits"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2189
msgid "Return data for the VPD page B0h (Block Limits)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2236
msgid "Simulate INQUIRY VPD page B1, Block Device Characteristics"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2241
msgid "Return data for the VPD page B1h (Block Device Characteristics)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2266
msgid "Simulate INQUIRY VPD page B2, Logical Block Provisioning"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2271
msgid "Return data for the VPD page B2h (Logical Block Provisioning)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2289
msgid "Simulate INQUIRY VPD page B6, Zoned Block Device Characteristics"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2294
msgid "Return data for the VPD page B2h (Zoned Block Device Characteristics)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2327
msgid "Simulate INQUIRY VPD page B9, Concurrent Positioning Ranges"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2332
msgid "Return data for the VPD page B9h (Concurrent Positioning Ranges)."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2365
msgid "Simulate INQUIRY command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2369
msgid "Returns data associated with an INQUIRY command output."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2416
msgid "Prepare response for MODE SENSE"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2422
msgid "``u8 *dest``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2417
#: ../drivers/ata/libata-scsi.c:2441 ../drivers/ata/libata-scsi.c:2583
#: ../drivers/ata/libata-scsi.c:2618
msgid "output buffer"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2419
msgid "``const u8 *src``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2418
msgid "data being copied"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2420
msgid "``int n``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2419
msgid "length of mode page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2421
#: ../drivers/ata/libata-scsi.c:2443 ../drivers/ata/libata-scsi.c:2586
#: ../drivers/ata/libata-scsi.c:2620
msgid "``bool changeable``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2420
#: ../drivers/ata/libata-scsi.c:2442 ../drivers/ata/libata-scsi.c:2585
#: ../drivers/ata/libata-scsi.c:2619
msgid "whether changeable parameters are requested"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2421
msgid ""
"Generate a generic MODE SENSE page for either current or changeable "
"parameters."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2439
msgid "Simulate MODE SENSE caching info page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2440
msgid "device IDENTIFY data"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2442
#: ../drivers/ata/libata-scsi.c:2584 ../drivers/ata/libata-scsi.c:2623
msgid "``u8 *buf``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2443
msgid ""
"Generate a caching info page, which conditionally indicates write caching to "
"the SCSI layer, depending on device capabilities."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2581
msgid "Simulate MODE SENSE control mode page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2585
#: ../drivers/ata/libata-scsi.c:4066
msgid "``u8 spg``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2584
msgid "sub-page code"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2586
msgid "Generate a generic MODE SENSE control mode page."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2617
msgid "Simulate MODE SENSE r/w error recovery page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2620
msgid "Generate a generic MODE SENSE r/w error recovery page."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2634
msgid "Simulate MODE SENSE 6, 10 commands"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2638
msgid ""
"Simulate MODE SENSE commands. Assume this is invoked for direct access "
"devices (e.g. disks) only. There should be no block descriptor for other "
"device types."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2766
msgid "Simulate READ CAPACITY[ 16] commands"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2770
msgid "Simulate READ CAPACITY commands."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2854
msgid "Simulate REPORT LUNS command"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2858
msgid "Simulate REPORT LUNS command."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2932
msgid "Initialize PACKET taskfile"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2933
#: ../drivers/ata/libata-scsi.c:3147
msgid "command structure to be initialized"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:2938
#: ../drivers/ata/libata-scsi.c:3151
msgid "Zero on success, non-zero on failure."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3077
msgid "lookup ata_device from scsi_cmnd"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3078
msgid "ATA port to which the device is attached"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3080
msgid "``const struct scsi_device *scsidev``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3079
msgid "SCSI device from which we derive the ATA device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3080
msgid ""
"Given various information provided in struct scsi_cmnd, map that onto an ATA "
"bus, and using that mapping determine which ata_device is associated with "
"the SCSI command to be sent."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3089
msgid "Associated ATA device, or ``NULL`` if not found."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3146
msgid "convert ATA pass-thru CDB to taskfile"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3148
msgid "Handles either 12, 16, or 32-byte versions of the CDB."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3412
msgid "SATL Write Same to DSM Trim"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3413
msgid "SCSI command being translated"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3415
msgid "``u32 trmax``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3414
msgid "Maximum number of entries that will fit in sector_size bytes."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3416
msgid "``u64 sector``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3415
msgid "Starting sector"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3417
msgid "``u32 count``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3416
msgid "Total Range of request in logical sectors"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3417
msgid ""
"Rewrite the WRITE SAME descriptor to be a DSM TRIM little-endian formatted "
"descriptor."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3420
msgid "Upto 64 entries of the format:"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3421
msgid "63:48 Range Length 47:0  LBA"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3424
msgid ""
"Range Length of 0 is ignored. LBA's should be sorted order and not overlap."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3427
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3428
msgid "this is the same format as ADD LBA(S) TO NV CACHE PINNED SET"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3430
msgid "Number of bytes copied into sglist."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3466
msgid "SATL Write Same to ATA SCT Write Same"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3467
#: ../drivers/ata/libata-scsi.c:4333
msgid "Command to be translated"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3468
msgid ""
"Translate a SCSI WRITE SAME command to be either a DSM TRIM command or an "
"SCT Write Same command. Based on WRITE SAME has the UNMAP flag:"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3472
msgid "When set translate to DSM TRIM"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3473
msgid "When clear translate to SCT Write Same"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3579
msgid "Simulate a subset of MAINTENANCE_IN"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3583
msgid "Yields a subset to satisfy scsi_report_opcode()"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3680
msgid "convert ATA output"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3681
msgid "command structure returning the data"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3682
msgid ""
"Convert T-13 little-endian field representation into T-10 big-endian field "
"representation. What a mess."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3911
msgid "Simulate MODE SELECT for caching info page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3914
#: ../drivers/ata/libata-scsi.c:4067
msgid "``const u8 *buf``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3913
#: ../drivers/ata/libata-scsi.c:4066
msgid "input buffer"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3915
#: ../drivers/ata/libata-scsi.c:4068
msgid "``int len``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3914
#: ../drivers/ata/libata-scsi.c:4067
msgid "number of valid bytes in the input buffer"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3916
#: ../drivers/ata/libata-scsi.c:4069
msgid "``u16 *fp``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3915
#: ../drivers/ata/libata-scsi.c:4068
msgid "out parameter for the failed field on error"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:3916
#: ../drivers/ata/libata-scsi.c:4069
msgid "Prepare a taskfile to modify caching information for the device."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4063
msgid "Simulate MODE SELECT for control page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4065
msgid "target sub-page of the control page"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4089
msgid "Simulate MODE SELECT 6, 10 commands"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4091
msgid ""
"Converts a MODE SELECT command to an ATA SET FEATURES taskfile. Assume this "
"is invoked for direct access devices (e.g. disks) only. There should be no "
"block descriptor for other device types."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4332
msgid "SATL variable length CDB to Handler"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4334
msgid ""
"Translate a SCSI variable length CDB to specified commands. It checks a "
"service action value in CDB to call corresponding handler."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4338
msgid "Zero on success, non-zero on failure"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4360
msgid "check if SCSI to ATA translation is possible"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4362
msgid "SCSI command opcode to consider"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4363
msgid ""
"Look up the SCSI command given, and determine whether the SCSI command is to "
"be translated or simulated."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4367
msgid "Pointer to translation function if possible, ``NULL`` if not."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4529
msgid "simulate SCSI command on ATA device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4530
msgid "the target device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4531
msgid "SCSI command being sent to device."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4532
msgid ""
"Interprets and directly executes a select list of SCSI commands that can be "
"handled internally."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4753
msgid "offline attached SCSI device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4754
msgid "ATA device to offline attached SCSI device for"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4755
msgid ""
"This function is called from ata_eh_detach_dev() and is responsible for "
"taking the SCSI device attached to **dev** offline.  This function is called "
"with host lock which protects dev->sdev against clearing."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4763
msgid "true if attached SCSI device exists, false otherwise."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4776
msgid "remove attached SCSI device"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4777
msgid "ATA device to remove attached SCSI device for"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4778
msgid ""
"This function is called from ata_eh_scsi_hotplug() and responsible for "
"removing the SCSI device attached to **dev**."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4856
msgid "send media change event"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4857
msgid "Pointer to the disk device with media change event"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4858
msgid "Tell the block layer to send a media change notification event."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4873
msgid "SCSI part of hotplug"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4879
#: ../drivers/ata/libata-scsi.c:4984
msgid "``struct work_struct *work``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4874
msgid "Pointer to ATA port to perform SCSI hotplug on"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4875
msgid ""
"Perform SCSI part of hotplug.  It's executed from a separate workqueue after "
"EH completes.  This is necessary because SCSI hot plugging requires working "
"EH and hot unplugging is synchronized with hot plugging with a mutex."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4911
msgid "indication for user-initiated bus scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4912
msgid "SCSI host to scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4914
msgid "``unsigned int channel``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4913
msgid "Channel to scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4915
msgid "``unsigned int id``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4914
msgid "ID to scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4916
msgid "``u64 lun``"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4915
msgid "LUN to scan"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4916
msgid ""
"This function is called when user explicitly requests bus scan.  Set probe "
"pending flag and invoke EH."
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4919
msgid "LOCKING: SCSI layer (we don't care)"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4978
msgid "initiate scsi_rescan_device()"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4979
msgid "Pointer to ATA port to perform scsi_rescan_device()"
msgstr ""

#: ../../../driver-api/libata:604: ../drivers/ata/libata-scsi.c:4980
msgid ""
"After ATA pass thru (SAT) commands are executed successfully, libata need to "
"propagate the changes to SCSI layer."
msgstr ""

#: ../../../driver-api/libata.rst:608
msgid "ATA errors and exceptions"
msgstr ""

#: ../../../driver-api/libata.rst:610
msgid ""
"This chapter tries to identify what error/exception conditions exist for ATA/"
"ATAPI devices and describe how they should be handled in implementation-"
"neutral way."
msgstr ""

#: ../../../driver-api/libata.rst:614
msgid ""
"The term 'error' is used to describe conditions where either an explicit "
"error condition is reported from device or a command has timed out."
msgstr ""

#: ../../../driver-api/libata.rst:617
msgid ""
"The term 'exception' is either used to describe exceptional conditions which "
"are not errors (say, power or hotplug events), or to describe both errors "
"and non-error exceptional conditions. Where explicit distinction between "
"error and exception is necessary, the term 'non-error exception' is used."
msgstr ""

#: ../../../driver-api/libata.rst:624
msgid "Exception categories"
msgstr ""

#: ../../../driver-api/libata.rst:626
msgid ""
"Exceptions are described primarily with respect to legacy taskfile + bus "
"master IDE interface. If a controller provides other better mechanism for "
"error reporting, mapping those into categories described below shouldn't be "
"difficult."
msgstr ""

#: ../../../driver-api/libata.rst:631
msgid ""
"In the following sections, two recovery actions - reset and reconfiguring "
"transport - are mentioned. These are described further in `EH recovery "
"actions <#exrec>`__."
msgstr ""

#: ../../../driver-api/libata.rst:636
msgid "HSM violation"
msgstr ""

#: ../../../driver-api/libata.rst:638
msgid ""
"This error is indicated when STATUS value doesn't match HSM requirement "
"during issuing or execution any ATA/ATAPI command."
msgstr ""

#: ../../../driver-api/libata.rst:641
msgid ""
"ATA_STATUS doesn't contain !BSY && DRDY && !DRQ while trying to issue a "
"command."
msgstr ""

#: ../../../driver-api/libata.rst:644
msgid "!BSY && !DRQ during PIO data transfer."
msgstr ""

#: ../../../driver-api/libata.rst:646
msgid "DRQ on command completion."
msgstr ""

#: ../../../driver-api/libata.rst:648
msgid ""
"!BSY && ERR after CDB transfer starts but before the last byte of CDB is "
"transferred. ATA/ATAPI standard states that \"The device shall not terminate "
"the PACKET command with an error before the last byte of the command packet "
"has been written\" in the error outputs description of PACKET command and "
"the state diagram doesn't include such transitions."
msgstr ""

#: ../../../driver-api/libata.rst:655
msgid ""
"In these cases, HSM is violated and not much information regarding the error "
"can be acquired from STATUS or ERROR register. IOW, this error can be "
"anything - driver bug, faulty device, controller and/or cable."
msgstr ""

#: ../../../driver-api/libata.rst:659
msgid ""
"As HSM is violated, reset is necessary to restore known state. Reconfiguring "
"transport for lower speed might be helpful too as transmission errors "
"sometimes cause this kind of errors."
msgstr ""

#: ../../../driver-api/libata.rst:664
msgid "ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)"
msgstr ""

#: ../../../driver-api/libata.rst:666
msgid ""
"These are errors detected and reported by ATA/ATAPI devices indicating "
"device problems. For this type of errors, STATUS and ERROR register values "
"are valid and describe error condition. Note that some of ATA bus errors are "
"detected by ATA/ATAPI devices and reported using the same mechanism as "
"device errors. Those cases are described later in this section."
msgstr ""

#: ../../../driver-api/libata.rst:673
msgid ""
"For ATA commands, this type of errors are indicated by !BSY && ERR during "
"command execution and on completion."
msgstr ""

#: ../../../driver-api/libata.rst:676
msgid "For ATAPI commands,"
msgstr ""

#: ../../../driver-api/libata.rst:678
msgid ""
"!BSY && ERR && ABRT right after issuing PACKET indicates that PACKET command "
"is not supported and falls in this category."
msgstr ""

#: ../../../driver-api/libata.rst:681
msgid ""
"!BSY && ERR(==CHK) && !ABRT after the last byte of CDB is transferred "
"indicates CHECK CONDITION and doesn't fall in this category."
msgstr ""

#: ../../../driver-api/libata.rst:684
msgid ""
"!BSY && ERR(==CHK) && ABRT after the last byte of CDB is transferred "
"\\*probably\\* indicates CHECK CONDITION and doesn't fall in this category."
msgstr ""

#: ../../../driver-api/libata.rst:688
msgid ""
"Of errors detected as above, the following are not ATA/ATAPI device errors "
"but ATA bus errors and should be handled according to `ATA bus error "
"<#excatATAbusErr>`__."
msgstr ""

#: ../../../driver-api/libata.rst:692
msgid "CRC error during data transfer"
msgstr ""

#: ../../../driver-api/libata.rst:693
msgid ""
"This is indicated by ICRC bit in the ERROR register and means that "
"corruption occurred during data transfer. Up to ATA/ATAPI-7, the standard "
"specifies that this bit is only applicable to UDMA transfers but ATA/ATAPI-8 "
"draft revision 1f says that the bit may be applicable to multiword DMA and "
"PIO."
msgstr ""

#: ../../../driver-api/libata.rst:699
msgid "ABRT error during data transfer or on completion"
msgstr ""

#: ../../../driver-api/libata.rst:700
msgid ""
"Up to ATA/ATAPI-7, the standard specifies that ABRT could be set on ICRC "
"errors and on cases where a device is not able to complete a command. "
"Combined with the fact that MWDMA and PIO transfer errors aren't allowed to "
"use ICRC bit up to ATA/ATAPI-7, it seems to imply that ABRT bit alone could "
"indicate transfer errors."
msgstr ""

#: ../../../driver-api/libata.rst:706
msgid ""
"However, ATA/ATAPI-8 draft revision 1f removes the part that ICRC errors can "
"turn on ABRT. So, this is kind of gray area. Some heuristics are needed here."
msgstr ""

#: ../../../driver-api/libata.rst:710
msgid "ATA/ATAPI device errors can be further categorized as follows."
msgstr ""

#: ../../../driver-api/libata.rst:712
msgid "Media errors"
msgstr ""

#: ../../../driver-api/libata.rst:713
msgid ""
"This is indicated by UNC bit in the ERROR register. ATA devices reports UNC "
"error only after certain number of retries cannot recover the data, so "
"there's nothing much else to do other than notifying upper layer."
msgstr ""

#: ../../../driver-api/libata.rst:718
msgid ""
"READ and WRITE commands report CHS or LBA of the first failed sector but ATA/"
"ATAPI standard specifies that the amount of transferred data on error "
"completion is indeterminate, so we cannot assume that sectors preceding the "
"failed sector have been transferred and thus cannot complete those sectors "
"successfully as SCSI does."
msgstr ""

#: ../../../driver-api/libata.rst:724
msgid "Media changed / media change requested error"
msgstr ""

#: ../../../driver-api/libata.rst:725 ../../../driver-api/libata.rst:850
msgid "<<TODO: fill here>>"
msgstr ""

#: ../../../driver-api/libata.rst:727
msgid "Address error"
msgstr ""

#: ../../../driver-api/libata.rst:728
msgid ""
"This is indicated by IDNF bit in the ERROR register. Report to upper layer."
msgstr ""

#: ../../../driver-api/libata.rst:731
msgid "Other errors"
msgstr ""

#: ../../../driver-api/libata.rst:732
msgid ""
"This can be invalid command or parameter indicated by ABRT ERROR bit or some "
"other error condition. Note that ABRT bit can indicate a lot of things "
"including ICRC and Address errors. Heuristics needed."
msgstr ""

#: ../../../driver-api/libata.rst:736
msgid ""
"Depending on commands, not all STATUS/ERROR bits are applicable. These non-"
"applicable bits are marked with \"na\" in the output descriptions but up to "
"ATA/ATAPI-7 no definition of \"na\" can be found. However, ATA/ATAPI-8 draft "
"revision 1f describes \"N/A\" as follows."
msgstr ""

#: ../../../driver-api/libata.rst:741
msgid "3.2.3.3a N/A"
msgstr ""

#: ../../../driver-api/libata.rst:742
msgid ""
"A keyword the indicates a field has no defined value in this standard and "
"should not be checked by the host or device. N/A fields should be cleared to "
"zero."
msgstr ""

#: ../../../driver-api/libata.rst:746
msgid ""
"So, it seems reasonable to assume that \"na\" bits are cleared to zero by "
"devices and thus need no explicit masking."
msgstr ""

#: ../../../driver-api/libata.rst:750
msgid "ATAPI device CHECK CONDITION"
msgstr ""

#: ../../../driver-api/libata.rst:752
msgid ""
"ATAPI device CHECK CONDITION error is indicated by set CHK bit (ERR bit) in "
"the STATUS register after the last byte of CDB is transferred for a PACKET "
"command. For this kind of errors, sense data should be acquired to gather "
"information regarding the errors. REQUEST SENSE packet command should be "
"used to acquire sense data."
msgstr ""

#: ../../../driver-api/libata.rst:758
msgid ""
"Once sense data is acquired, this type of errors can be handled similarly to "
"other SCSI errors. Note that sense data may indicate ATA bus error (e.g. "
"Sense Key 04h HARDWARE ERROR && ASC/ASCQ 47h/00h SCSI PARITY ERROR). In such "
"cases, the error should be considered as an ATA bus error and handled "
"according to `ATA bus error <#excatATAbusErr>`__."
msgstr ""

#: ../../../driver-api/libata.rst:765
msgid "ATA device error (NCQ)"
msgstr ""

#: ../../../driver-api/libata.rst:767
msgid ""
"NCQ command error is indicated by cleared BSY and set ERR bit during NCQ "
"command phase (one or more NCQ commands outstanding). Although STATUS and "
"ERROR registers will contain valid values describing the error, READ LOG EXT "
"is required to clear the error condition, determine which command has failed "
"and acquire more information."
msgstr ""

#: ../../../driver-api/libata.rst:773
msgid ""
"READ LOG EXT Log Page 10h reports which tag has failed and taskfile register "
"values describing the error. With this information the failed command can be "
"handled as a normal ATA command error as in `ATA/ATAPI device error (non-"
"NCQ / non-CHECK CONDITION) <#excatDevErr>`__ and all other in-flight "
"commands must be retried. Note that this retry should not be counted - it's "
"likely that commands retried this way would have completed normally if it "
"were not for the failed command."
msgstr ""

#: ../../../driver-api/libata.rst:781
msgid ""
"Note that ATA bus errors can be reported as ATA device NCQ errors. This "
"should be handled as described in `ATA bus error <#excatATAbusErr>`__."
msgstr ""

#: ../../../driver-api/libata.rst:784
msgid ""
"If READ LOG EXT Log Page 10h fails or reports NQ, we're thoroughly screwed. "
"This condition should be treated according to `HSM violation "
"<#excatHSMviolation>`__."
msgstr ""

#: ../../../driver-api/libata.rst:789
msgid "ATA bus error"
msgstr ""

#: ../../../driver-api/libata.rst:791
msgid ""
"ATA bus error means that data corruption occurred during transmission over "
"ATA bus (SATA or PATA). This type of errors can be indicated by"
msgstr ""

#: ../../../driver-api/libata.rst:794
msgid ""
"ICRC or ABRT error as described in `ATA/ATAPI device error (non-NCQ / non-"
"CHECK CONDITION) <#excatDevErr>`__."
msgstr ""

#: ../../../driver-api/libata.rst:797
msgid ""
"Controller-specific error completion with error information indicating "
"transmission error."
msgstr ""

#: ../../../driver-api/libata.rst:800
msgid ""
"On some controllers, command timeout. In this case, there may be a mechanism "
"to determine that the timeout is due to transmission error."
msgstr ""

#: ../../../driver-api/libata.rst:803
msgid "Unknown/random errors, timeouts and all sorts of weirdities."
msgstr ""

#: ../../../driver-api/libata.rst:805
msgid ""
"As described above, transmission errors can cause wide variety of symptoms "
"ranging from device ICRC error to random device lockup, and, for many cases, "
"there is no way to tell if an error condition is due to transmission error "
"or not; therefore, it's necessary to employ some kind of heuristic when "
"dealing with errors and timeouts. For example, encountering repetitive ABRT "
"errors for known supported command is likely to indicate ATA bus error."
msgstr ""

#: ../../../driver-api/libata.rst:813
msgid ""
"Once it's determined that ATA bus errors have possibly occurred, lowering "
"ATA bus transmission speed is one of actions which may alleviate the "
"problem. See `Reconfigure transport <#exrecReconf>`__ for more information."
msgstr ""

#: ../../../driver-api/libata.rst:819
msgid "PCI bus error"
msgstr ""

#: ../../../driver-api/libata.rst:821
msgid ""
"Data corruption or other failures during transmission over PCI (or other "
"system bus). For standard BMDMA, this is indicated by Error bit in the BMDMA "
"Status register. This type of errors must be logged as it indicates "
"something is very wrong with the system. Resetting host controller is "
"recommended."
msgstr ""

#: ../../../driver-api/libata.rst:828
msgid "Late completion"
msgstr ""

#: ../../../driver-api/libata.rst:830
msgid ""
"This occurs when timeout occurs and the timeout handler finds out that the "
"timed out command has completed successfully or with error. This is usually "
"caused by lost interrupts. This type of errors must be logged. Resetting "
"host controller is recommended."
msgstr ""

#: ../../../driver-api/libata.rst:836
msgid "Unknown error (timeout)"
msgstr ""

#: ../../../driver-api/libata.rst:838
msgid ""
"This is when timeout occurs and the command is still processing or the host "
"and device are in unknown state. When this occurs, HSM could be in any valid "
"or invalid state. To bring the device to known state and make it forget "
"about the timed out command, resetting is necessary. The timed out command "
"may be retried."
msgstr ""

#: ../../../driver-api/libata.rst:844
msgid ""
"Timeouts can also be caused by transmission errors. Refer to `ATA bus error "
"<#excatATAbusErr>`__ for more details."
msgstr ""

#: ../../../driver-api/libata.rst:848
msgid "Hotplug and power management exceptions"
msgstr ""

#: ../../../driver-api/libata.rst:853
msgid "EH recovery actions"
msgstr ""

#: ../../../driver-api/libata.rst:855
msgid "This section discusses several important recovery actions."
msgstr ""

#: ../../../driver-api/libata.rst:858
msgid "Clearing error condition"
msgstr ""

#: ../../../driver-api/libata.rst:860
msgid ""
"Many controllers require its error registers to be cleared by error handler. "
"Different controllers may have different requirements."
msgstr ""

#: ../../../driver-api/libata.rst:863
msgid ""
"For SATA, it's strongly recommended to clear at least SError register during "
"error handling."
msgstr ""

#: ../../../driver-api/libata.rst:867
msgid "Reset"
msgstr ""

#: ../../../driver-api/libata.rst:869
msgid "During EH, resetting is necessary in the following cases."
msgstr ""

#: ../../../driver-api/libata.rst:871
msgid "HSM is in unknown or invalid state"
msgstr ""

#: ../../../driver-api/libata.rst:873
msgid "HBA is in unknown or invalid state"
msgstr ""

#: ../../../driver-api/libata.rst:875
msgid "EH needs to make HBA/device forget about in-flight commands"
msgstr ""

#: ../../../driver-api/libata.rst:877
msgid "HBA/device behaves weirdly"
msgstr ""

#: ../../../driver-api/libata.rst:879
msgid ""
"Resetting during EH might be a good idea regardless of error condition to "
"improve EH robustness. Whether to reset both or either one of HBA and device "
"depends on situation but the following scheme is recommended."
msgstr ""

#: ../../../driver-api/libata.rst:883
msgid ""
"When it's known that HBA is in ready state but ATA/ATAPI device is in "
"unknown state, reset only device."
msgstr ""

#: ../../../driver-api/libata.rst:886
msgid "If HBA is in unknown state, reset both HBA and device."
msgstr ""

#: ../../../driver-api/libata.rst:888
msgid ""
"HBA resetting is implementation specific. For a controller complying to "
"taskfile/BMDMA PCI IDE, stopping active DMA transaction may be sufficient "
"iff BMDMA state is the only HBA context. But even mostly taskfile/BMDMA PCI "
"IDE complying controllers may have implementation specific requirements and "
"mechanism to reset themselves. This must be addressed by specific drivers."
msgstr ""

#: ../../../driver-api/libata.rst:895
msgid ""
"OTOH, ATA/ATAPI standard describes in detail ways to reset ATA/ATAPI devices."
msgstr ""

#: ../../../driver-api/libata.rst:898
msgid "PATA hardware reset"
msgstr ""

#: ../../../driver-api/libata.rst:899
msgid ""
"This is hardware initiated device reset signalled with asserted PATA RESET- "
"signal. There is no standard way to initiate hardware reset from software "
"although some hardware provides registers that allow driver to directly "
"tweak the RESET- signal."
msgstr ""

#: ../../../driver-api/libata.rst:904
msgid "Software reset"
msgstr ""

#: ../../../driver-api/libata.rst:905
msgid ""
"This is achieved by turning CONTROL SRST bit on for at least 5us. Both PATA "
"and SATA support it but, in case of SATA, this may require controller-"
"specific support as the second Register FIS to clear SRST should be "
"transmitted while BSY bit is still set. Note that on PATA, this resets both "
"master and slave devices on a channel."
msgstr ""

#: ../../../driver-api/libata.rst:911
msgid "EXECUTE DEVICE DIAGNOSTIC command"
msgstr ""

#: ../../../driver-api/libata.rst:912
msgid ""
"Although ATA/ATAPI standard doesn't describe exactly, EDD implies some level "
"of resetting, possibly similar level with software reset. Host-side EDD "
"protocol can be handled with normal command processing and most SATA "
"controllers should be able to handle EDD's just like other commands. As in "
"software reset, EDD affects both devices on a PATA bus."
msgstr ""

#: ../../../driver-api/libata.rst:919
msgid ""
"Although EDD does reset devices, this doesn't suit error handling as EDD "
"cannot be issued while BSY is set and it's unclear how it will act when "
"device is in unknown/weird state."
msgstr ""

#: ../../../driver-api/libata.rst:923
msgid "ATAPI DEVICE RESET command"
msgstr ""

#: ../../../driver-api/libata.rst:924
msgid ""
"This is very similar to software reset except that reset can be restricted "
"to the selected device without affecting the other device sharing the cable."
msgstr ""

#: ../../../driver-api/libata.rst:928
msgid "SATA phy reset"
msgstr ""

#: ../../../driver-api/libata.rst:929
msgid ""
"This is the preferred way of resetting a SATA device. In effect, it's "
"identical to PATA hardware reset. Note that this can be done with the "
"standard SCR Control register. As such, it's usually easier to implement "
"than software reset."
msgstr ""

#: ../../../driver-api/libata.rst:934
msgid ""
"One more thing to consider when resetting devices is that resetting clears "
"certain configuration parameters and they need to be set to their previous "
"or newly adjusted values after reset."
msgstr ""

#: ../../../driver-api/libata.rst:938
msgid "Parameters affected are."
msgstr ""

#: ../../../driver-api/libata.rst:940
msgid "CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)"
msgstr ""

#: ../../../driver-api/libata.rst:942
msgid "Parameters set with SET FEATURES including transfer mode setting"
msgstr ""

#: ../../../driver-api/libata.rst:944
msgid "Block count set with SET MULTIPLE MODE"
msgstr ""

#: ../../../driver-api/libata.rst:946
msgid "Other parameters (SET MAX, MEDIA LOCK...)"
msgstr ""

#: ../../../driver-api/libata.rst:948
msgid ""
"ATA/ATAPI standard specifies that some parameters must be maintained across "
"hardware or software reset, but doesn't strictly specify all of them. Always "
"reconfiguring needed parameters after reset is required for robustness. Note "
"that this also applies when resuming from deep sleep (power-off)."
msgstr ""

#: ../../../driver-api/libata.rst:954
msgid ""
"Also, ATA/ATAPI standard requires that IDENTIFY DEVICE / IDENTIFY PACKET "
"DEVICE is issued after any configuration parameter is updated or a hardware "
"reset and the result used for further operation. OS driver is required to "
"implement revalidation mechanism to support this."
msgstr ""

#: ../../../driver-api/libata.rst:960
msgid "Reconfigure transport"
msgstr ""

#: ../../../driver-api/libata.rst:962
msgid ""
"For both PATA and SATA, a lot of corners are cut for cheap connectors, "
"cables or controllers and it's quite common to see high transmission error "
"rate. This can be mitigated by lowering transmission speed."
msgstr ""

#: ../../../driver-api/libata.rst:966
msgid "The following is a possible scheme Jeff Garzik suggested."
msgstr ""

#: ../../../driver-api/libata.rst:968
msgid "If more than $N (3?) transmission errors happen in 15 minutes,"
msgstr ""

#: ../../../driver-api/libata.rst:970
msgid "if SATA, decrease SATA PHY speed. if speed cannot be decreased,"
msgstr ""

#: ../../../driver-api/libata.rst:972
msgid "decrease UDMA xfer speed. if at UDMA0, switch to PIO4,"
msgstr ""

#: ../../../driver-api/libata.rst:974
msgid "decrease PIO xfer speed. if at PIO3, complain, but continue"
msgstr ""

#: ../../../driver-api/libata.rst:977
msgid "ata_piix Internals"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:496
msgid "Probe host controller cable detect info"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:497
msgid "Port for which cable detect info is desired"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:498
msgid ""
"Read 80c cable indicator from ATA PCI device's PCI config register.  This "
"register is normally set by firmware (BIOS)."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:501
#: ../drivers/ata/ata_piix.c:534 ../drivers/ata/ata_piix.c:642
#: ../drivers/ata/ata_piix.c:659 ../drivers/ata/ata_piix.c:737
#: ../drivers/ata/ata_piix.c:753
msgid "LOCKING: None (inherited from caller)."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:531
msgid "prereset for PATA host controller"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:532
msgid "Target link"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:637
#: ../drivers/ata/ata_piix.c:653
msgid "Initialize host controller PATA PIO timings"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:638
#: ../drivers/ata/ata_piix.c:654 ../drivers/ata/ata_piix.c:733
#: ../drivers/ata/ata_piix.c:749
msgid "Port whose timings we are configuring"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:639
#: ../drivers/ata/ata_piix.c:655
msgid "Drive in question"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:640
msgid "Set PIO mode for device, in host controller PCI config space."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:657
msgid "``int isich``"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:656
msgid "set if the chip is an ICH device"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:657
msgid "Set UDMA mode for device, in host controller PCI config space."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:732
#: ../drivers/ata/ata_piix.c:748
msgid "Initialize host controller PATA DMA timings"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:734
#: ../drivers/ata/ata_piix.c:750
msgid "um"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:735
#: ../drivers/ata/ata_piix.c:751
msgid "Set MW/UDMA mode for device, in host controller PCI config space."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1308
msgid "Check for problem 450NX setup"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1314
msgid "``struct pci_dev *ata_dev``"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1309
msgid "the PCI device to check"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1310
msgid ""
"Check for the present of 450NX errata #19 and errata #25. If they are found "
"return an error code so we can turn off DMA"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1629
msgid "Register PIIX ATA PCI device with kernel services"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1630
msgid "PCI device to register"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1632
msgid "``const struct pci_device_id *ent``"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1631
msgid "Entry in piix_pci_tbl matching with **pdev**"
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1632
msgid ""
"Called from kernel PCI layer.  We probe for combined mode (sigh), and then "
"hand over control to libata, for it to do the rest."
msgstr ""

#: ../../../driver-api/libata:979: ../drivers/ata/ata_piix.c:1639
msgid "Zero on success, or -ERRNO value."
msgstr ""

#: ../../../driver-api/libata.rst:983
msgid "sata_sil Internals"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:337
msgid "wrap set_mode functions"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:338
msgid "link to set up"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:340
msgid "``struct ata_device **r_failed``"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:339
msgid "returned device when we fail"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:340
msgid ""
"Wrap the libata method for device setup as after the setup we need to "
"inspect the results and do some configuration work"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:584
msgid "Apply device/host-specific errata fixups"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:585
msgid "Device to be examined"
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:586
msgid ""
"After the IDENTIFY [PACKET] DEVICE step is complete, and a device is known "
"to be present, this function is called. We apply two errata fixups which are "
"specific to Silicon Image, a Seagate and a Maxtor fixup."
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:591
msgid ""
"For certain Seagate devices, we must limit the maximum sectors to under 8K."
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:594
msgid "For certain Maxtor devices, we must not program the drive beyond udma5."
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:597
msgid ""
"Both fixups are unfairly pessimistic.  As soon as I get more information on "
"these errata, I will create a more exhaustive list, and apply the fixups to "
"only the specific devices/hosts/firmwares that need it."
msgstr ""

#: ../../../driver-api/libata:985: ../drivers/ata/sata_sil.c:602
msgid ""
"20040111 - Seagate drives affected by the Mod15Write bug are quirked The "
"Maxtor quirk is in sil_quirks, but I'm keeping the original pessimistic fix "
"for the following reasons... - There seems to be less info on it, only one "
"device gleaned off the Windows driver, maybe only one is affected.  More "
"info would be greatly appreciated. - But then again UDMA5 is hardly anything "
"to complain about"
msgstr ""

#: ../../../driver-api/libata.rst:989
msgid "Thanks"
msgstr ""

#: ../../../driver-api/libata.rst:991
msgid ""
"The bulk of the ATA knowledge comes thanks to long conversations with Andre "
"Hedrick (www.linux-ide.org), and long hours pondering the ATA and SCSI "
"specifications."
msgstr ""

#: ../../../driver-api/libata.rst:995
msgid ""
"Thanks to Alan Cox for pointing out similarities between SATA and SCSI, and "
"in general for motivation to hack on libata."
msgstr ""

#: ../../../driver-api/libata.rst:998
msgid ""
"libata's device detection method, ata_pio_devchk, and in general all the "
"early probing was based on extensive study of Hale Landis's probe/reset code "
"in his ATADRVR driver (www.ata-atapi.com)."
msgstr ""
