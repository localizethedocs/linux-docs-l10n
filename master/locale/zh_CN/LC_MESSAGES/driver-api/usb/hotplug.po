# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/usb/hotplug.rst:2
msgid "USB hotplugging"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:5
msgid "Linux Hotplugging"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:8
msgid ""
"In hotpluggable busses like USB (and Cardbus PCI), end-users plug devices "
"into the bus with power on.  In most cases, users expect the devices to "
"become immediately usable.  That means the system must do many things, "
"including:"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:12
msgid ""
"Find a driver that can handle the device.  That may involve loading a kernel "
"module; newer drivers can use module-init-tools to publish their device (and "
"class) support to user utilities."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:16
msgid ""
"Bind a driver to that device.  Bus frameworks do that using a device "
"driver's probe() routine."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:19
msgid ""
"Tell other subsystems to configure the new device.  Print queues may need to "
"be enabled, networks brought up, disk partitions mounted, and so on.  In "
"some cases these will be driver-specific actions."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:24
msgid ""
"This involves a mix of kernel mode and user mode actions.  Making devices be "
"immediately usable means that any user mode actions can't wait for an "
"administrator to do them:  the kernel must trigger them, either passively "
"(triggering some monitoring daemon to invoke a helper program) or actively "
"(calling such a user mode helper program directly)."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:30
msgid ""
"Those triggered actions must support a system's administrative policies; "
"such programs are called \"policy agents\" here.  Typically they involve "
"shell scripts that dispatch to more familiar administration tools."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:34
msgid ""
"Because some of those actions rely on information about drivers (metadata) "
"that is currently available only when the drivers are dynamically linked, "
"you get the best hotplugging when you configure a highly modular system."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:39
msgid "Kernel Hotplug Helper (``/sbin/hotplug``)"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:41
msgid ""
"There is a kernel parameter: ``/proc/sys/kernel/hotplug``, which normally "
"holds the pathname ``/sbin/hotplug``.  That parameter names a program which "
"the kernel may invoke at various times."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:45
msgid ""
"The /sbin/hotplug program can be invoked by any subsystem as part of its "
"reaction to a configuration change, from a thread in that subsystem. Only "
"one parameter is required: the name of a subsystem being notified of some "
"kernel event.  That name is used as the first key for further event "
"dispatch; any other argument and environment parameters are specified by the "
"subsystem making that invocation."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:52
msgid "Hotplug software and other resources is available at:"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:54
msgid "http://linux-hotplug.sourceforge.net"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:56
msgid "Mailing list information is also available at that site."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:60
msgid "USB Policy Agent"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:62
msgid ""
"The USB subsystem currently invokes ``/sbin/hotplug`` when USB devices are "
"added or removed from system.  The invocation is done by the kernel hub "
"workqueue [hub_wq], or else as part of root hub initialization (done by "
"init, modprobe, kapmd, etc).  Its single command line parameter is the "
"string \"usb\", and it passes these environment variables:"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:69
msgid "ACTION"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:69
msgid "``add``, ``remove``"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:70
msgid "PRODUCT"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:70
msgid "USB vendor, product, and version codes (hex)"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:71
msgid "TYPE"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:71
msgid "device class codes (decimal)"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:72
msgid "INTERFACE"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:72
msgid "interface 0 class codes (decimal)"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:75
msgid ""
"If \"usbdevfs\" is configured, DEVICE and DEVFS are also passed.  DEVICE is "
"the pathname of the device, and is useful for devices with multiple and/or "
"alternate interfaces that complicate driver selection.  By design, USB "
"hotplugging is independent of ``usbdevfs``:  you can do most essential parts "
"of USB device setup without using that filesystem, and without running a "
"user mode daemon to detect changes in system configuration."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:82
msgid ""
"Currently available policy agent implementations can load drivers for "
"modules, and can invoke driver-specific setup scripts.  The newest ones "
"leverage USB module-init-tools support.  Later agents might unload drivers."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:88
msgid "USB Modutils Support"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:90
msgid ""
"Current versions of module-init-tools will create a ``modules.usbmap`` file "
"which contains the entries from each driver's ``MODULE_DEVICE_TABLE``.  Such "
"files can be used by various user mode policy agents to make sure all the "
"right driver modules get loaded, either at boot time or later."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:95
msgid ""
"See ``linux/usb.h`` for full information about such table entries; or look "
"at existing drivers.  Each table entry describes one or more criteria to be "
"used when matching a driver to a device or class of devices.  The specific "
"criteria are identified by bits set in \"match_flags\", paired with field "
"values.  You can construct the criteria directly, or with macros such as "
"these, and use driver_info to store more information::"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:111
msgid ""
"A short example, for a driver that supports several specific USB devices and "
"their quirks, might have a MODULE_DEVICE_TABLE like this::"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:122
msgid ""
"Most USB device drivers should pass these tables to the USB subsystem as "
"well as to the module management subsystem.  Not all, though: some driver "
"frameworks connect using interfaces layered over USB, and so they won't need "
"such a struct usb_driver."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:127
msgid ""
"Drivers that connect directly to the USB subsystem should be declared "
"something like this::"
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:145
msgid ""
"When the USB subsystem knows about a driver's device ID table, it's used "
"when choosing drivers to probe().  The thread doing new device processing "
"checks drivers' device ID entries from the ``MODULE_DEVICE_TABLE`` against "
"interface and device descriptors for the device.  It will only call "
"``probe()`` if there is a match, and the third argument to ``probe()`` will "
"be the entry that matched."
msgstr ""

#: ../../../driver-api/usb/hotplug.rst:152
msgid ""
"If you don't provide an ``id_table`` for your driver, then your driver may "
"get probed for each new device; the third parameter to ``probe()`` will be "
"``NULL``."
msgstr ""
