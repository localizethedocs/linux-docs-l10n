# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/usb/usb.rst:5
msgid "The Linux-USB Host Side API"
msgstr ""

#: ../../../driver-api/usb/usb.rst:8
msgid "Introduction to USB on Linux"
msgstr ""

#: ../../../driver-api/usb/usb.rst:10
msgid ""
"A Universal Serial Bus (USB) is used to connect a host, such as a PC or "
"workstation, to a number of peripheral devices. USB uses a tree structure, "
"with the host as the root (the system's master), hubs as interior nodes, and "
"peripherals as leaves (and slaves). Modern PCs support several such trees of "
"USB devices, usually a few USB 3.0 (5 GBit/s) or USB 3.1 (10 GBit/s) and "
"some legacy USB 2.0 (480 MBit/s) buses just in case."
msgstr ""

#: ../../../driver-api/usb/usb.rst:18
msgid ""
"That master/slave asymmetry was designed-in for a number of reasons, one "
"being ease of use. It is not physically possible to mistake upstream and "
"downstream or it does not matter with a type C plug (or they are built into "
"the peripheral). Also, the host software doesn't need to deal with "
"distributed auto-configuration since the pre-designated master node manages "
"all that."
msgstr ""

#: ../../../driver-api/usb/usb.rst:25
msgid ""
"Kernel developers added USB support to Linux early in the 2.2 kernel series "
"and have been developing it further since then. Besides support for each new "
"generation of USB, various host controllers gained support, new drivers for "
"peripherals have been added and advanced features for latency measurement "
"and improved power management introduced."
msgstr ""

#: ../../../driver-api/usb/usb.rst:31
msgid ""
"Linux can run inside USB devices as well as on the hosts that control the "
"devices. But USB device drivers running inside those peripherals don't do "
"the same things as the ones running inside hosts, so they've been given a "
"different name: *gadget drivers*. This document does not cover gadget "
"drivers."
msgstr ""

#: ../../../driver-api/usb/usb.rst:38
msgid "USB Host-Side API Model"
msgstr ""

#: ../../../driver-api/usb/usb.rst:40
msgid ""
"Host-side drivers for USB devices talk to the \"usbcore\" APIs. There are "
"two. One is intended for *general-purpose* drivers (exposed through driver "
"frameworks), and the other is for drivers that are *part of the core*. Such "
"core drivers include the *hub* driver (which manages trees of USB devices) "
"and several different kinds of *host controller drivers*, which control "
"individual buses."
msgstr ""

#: ../../../driver-api/usb/usb.rst:47
msgid "The device model seen by USB drivers is relatively complex."
msgstr ""

#: ../../../driver-api/usb/usb.rst:49
msgid ""
"USB supports four kinds of data transfers (control, bulk, interrupt, and "
"isochronous). Two of them (control and bulk) use bandwidth as it's "
"available, while the other two (interrupt and isochronous) are scheduled to "
"provide guaranteed bandwidth."
msgstr ""

#: ../../../driver-api/usb/usb.rst:54
msgid ""
"The device description model includes one or more \"configurations\" per "
"device, only one of which is active at a time. Devices are supposed to be "
"capable of operating at lower than their top speeds and may provide a BOS "
"descriptor showing the lowest speed they remain fully operational at."
msgstr ""

#: ../../../driver-api/usb/usb.rst:60
msgid ""
"From USB 3.0 on configurations have one or more \"functions\", which provide "
"a common functionality and are grouped together for purposes of power "
"management."
msgstr ""

#: ../../../driver-api/usb/usb.rst:64
msgid ""
"Configurations or functions have one or more \"interfaces\", each of which "
"may have \"alternate settings\". Interfaces may be standardized by USB "
"\"Class\" specifications, or may be specific to a vendor or device."
msgstr ""

#: ../../../driver-api/usb/usb.rst:68
msgid ""
"USB device drivers actually bind to interfaces, not devices. Think of them "
"as \"interface drivers\", though you may not see many devices where the "
"distinction is important. *Most USB devices are simple, with only one "
"function, one configuration, one interface, and one alternate setting.*"
msgstr ""

#: ../../../driver-api/usb/usb.rst:74
msgid ""
"Interfaces have one or more \"endpoints\", each of which supports one type "
"and direction of data transfer such as \"bulk out\" or \"interrupt in\". The "
"entire configuration may have up to sixteen endpoints in each direction, "
"allocated as needed among all the interfaces."
msgstr ""

#: ../../../driver-api/usb/usb.rst:79
msgid ""
"Data transfer on USB is packetized; each endpoint has a maximum packet size. "
"Drivers must often be aware of conventions such as flagging the end of bulk "
"transfers using \"short\" (including zero length) packets."
msgstr ""

#: ../../../driver-api/usb/usb.rst:84
msgid ""
"The Linux USB API supports synchronous calls for control and bulk messages. "
"It also supports asynchronous calls for all kinds of data transfer, using "
"request structures called \"URBs\" (USB Request Blocks)."
msgstr ""

#: ../../../driver-api/usb/usb.rst:89
msgid ""
"Accordingly, the USB Core API exposed to device drivers covers quite a lot "
"of territory. You'll probably need to consult the USB 3.0 specification, "
"available online from www.usb.org at no cost, as well as class or device "
"specifications."
msgstr ""

#: ../../../driver-api/usb/usb.rst:94
msgid ""
"The only host-side drivers that actually touch hardware (reading/writing "
"registers, handling IRQs, and so on) are the HCDs. In theory, all HCDs "
"provide the same functionality through the same API. In practice, that's "
"becoming more true, but there are still differences that crop up especially "
"with fault handling on the less common controllers. Different controllers "
"don't necessarily report the same aspects of failures, and recovery from "
"faults (including software-induced ones like unlinking an URB) isn't yet "
"fully consistent. Device driver authors should make a point of doing "
"disconnect testing (while the device is active) with each different host "
"controller driver, to make sure drivers don't have bugs of their own as well "
"as to make sure they aren't relying on some HCD-specific behavior."
msgstr ""

#: ../../../driver-api/usb/usb.rst:110
msgid "USB-Standard Types"
msgstr ""

#: ../../../driver-api/usb/usb.rst:112
msgid ""
"In ``include/uapi/linux/usb/ch9.h`` you will find the USB data types defined "
"in chapter 9 of the USB specification. These data types are used throughout "
"USB, and in APIs including this host side API, gadget APIs, usb character "
"devices and debugfs interfaces. That file is itself included by ``include/"
"linux/usb/ch9.h``, which also contains declarations of a few utility "
"routines for manipulating these data types; the implementations are in "
"``drivers/usb/common/common.c``."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:30
msgid "Returns human readable-name of the endpoint type."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:34
#: drivers/usb/common/common.c:49 drivers/usb/common/common.c:97
#: drivers/usb/common/common.c:111 drivers/usb/common/common.c:136
#: drivers/usb/common/common.c:159 drivers/usb/common/common.c:222
#: drivers/usb/common/common.c:242 drivers/usb/common/common.c:284
#: drivers/usb/common/common.c:339 drivers/usb/common/common.c:352
#: drivers/usb/common/common.c:407 ../../../driver-api/usb/usb:136:
#: include/linux/usb.h:287 include/linux/usb.h:770 include/linux/usb.h:908
#: include/linux/usb.h:955 include/linux/usb.h:1005 include/linux/usb.h:1017
#: include/linux/usb.h:1034 include/linux/usb.h:1050 include/linux/usb.h:1066
#: include/linux/usb.h:1082 include/linux/usb.h:1097 include/linux/usb.h:1112
#: include/linux/usb.h:1135 include/linux/usb.h:1358 include/linux/usb.h:1671
#: include/linux/usb.h:1714 include/linux/usb.h:1747 include/linux/usb.h:1825
#: include/linux/usb.h:1837 ../../../driver-api/usb/usb:161:
#: drivers/usb/core/urb.c:35 drivers/usb/core/urb.c:60
#: drivers/usb/core/urb.c:89 drivers/usb/core/urb.c:106
#: drivers/usb/core/urb.c:124 drivers/usb/core/urb.c:164
#: drivers/usb/core/urb.c:200 drivers/usb/core/urb.c:222
#: drivers/usb/core/urb.c:236 drivers/usb/core/urb.c:598
#: drivers/usb/core/urb.c:682 drivers/usb/core/urb.c:729
#: drivers/usb/core/urb.c:786 drivers/usb/core/urb.c:807
#: drivers/usb/core/urb.c:845 drivers/usb/core/urb.c:883
#: drivers/usb/core/urb.c:904 drivers/usb/core/urb.c:919
#: drivers/usb/core/urb.c:937 drivers/usb/core/urb.c:956
#: drivers/usb/core/urb.c:987 drivers/usb/core/urb.c:1015
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:115
#: drivers/usb/core/message.c:171 drivers/usb/core/message.c:230
#: drivers/usb/core/message.c:304 drivers/usb/core/message.c:337
#: drivers/usb/core/message.c:480 drivers/usb/core/message.c:611
#: drivers/usb/core/message.c:718 drivers/usb/core/message.c:763
#: drivers/usb/core/message.c:955 drivers/usb/core/message.c:1016
#: drivers/usb/core/message.c:1105 drivers/usb/core/message.c:1186
#: drivers/usb/core/message.c:1313 drivers/usb/core/message.c:1492
#: drivers/usb/core/message.c:1672 drivers/usb/core/message.c:1931
#: drivers/usb/core/message.c:2273 drivers/usb/core/message.c:2314
#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:96
#: drivers/usb/core/file.c:168 ../../../driver-api/usb/usb:171:
#: drivers/usb/core/driver.c:535 drivers/usb/core/driver.c:613
#: drivers/usb/core/driver.c:747 drivers/usb/core/driver.c:987
#: drivers/usb/core/driver.c:1033 drivers/usb/core/driver.c:1049
#: drivers/usb/core/driver.c:1105 drivers/usb/core/driver.c:1683
#: drivers/usb/core/driver.c:1699 drivers/usb/core/driver.c:1772
#: drivers/usb/core/driver.c:1800 drivers/usb/core/driver.c:1828
#: drivers/usb/core/driver.c:1846 drivers/usb/core/driver.c:1877
#: drivers/usb/core/driver.c:1910 ../../../driver-api/usb/usb:174:
#: drivers/usb/core/usb.c:123 drivers/usb/core/usb.c:169
#: drivers/usb/core/usb.c:240 drivers/usb/core/usb.c:265
#: drivers/usb/core/usb.c:291 drivers/usb/core/usb.c:332
#: drivers/usb/core/usb.c:370 drivers/usb/core/usb.c:422
#: drivers/usb/core/usb.c:466 drivers/usb/core/usb.c:632
#: drivers/usb/core/usb.c:758 drivers/usb/core/usb.c:782
#: drivers/usb/core/usb.c:796 drivers/usb/core/usb.c:820
#: drivers/usb/core/usb.c:835 drivers/usb/core/usb.c:883
#: drivers/usb/core/usb.c:930 drivers/usb/core/usb.c:985
#: drivers/usb/core/usb.c:1017 drivers/usb/core/usb.c:1039
#: drivers/usb/core/usb.c:1090 drivers/usb/core/usb.c:1119
#: drivers/usb/core/usb.c:1150 ../../../driver-api/usb/usb:177:
#: drivers/usb/core/hub.c:915 drivers/usb/core/hub.c:2170
#: drivers/usb/core/hub.c:4076 drivers/usb/core/hub.c:6327
#: drivers/usb/core/hub.c:6448 drivers/usb/core/hub.c:6483
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1063
#: drivers/usb/core/hcd.c:1120 drivers/usb/core/hcd.c:1174
#: drivers/usb/core/hcd.c:1216 drivers/usb/core/hcd.c:1719
#: drivers/usb/core/hcd.c:2017 drivers/usb/core/hcd.c:2070
#: drivers/usb/core/hcd.c:2398 drivers/usb/core/hcd.c:2427
#: drivers/usb/core/hcd.c:2466 drivers/usb/core/hcd.c:2507
#: drivers/usb/core/hcd.c:2630 drivers/usb/core/hcd.c:2655
#: drivers/usb/core/hcd.c:2803 drivers/usb/core/hcd.c:3030
#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:162
#: drivers/usb/core/hcd-pci.c:304 drivers/usb/core/hcd-pci.c:360
#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:56
#: drivers/usb/core/buffer.c:94
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:36
msgid "``int ep_type``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:31
msgid ""
"The endpoint type to return human-readable name for.  If it's not any of the "
"types: USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT}, usually got by "
"usb_endpoint_type(), the string 'unknown' will be returned."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:45
msgid "returns human readable name of OTG state."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:51
msgid "``enum usb_otg_state state``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:46
msgid ""
"the OTG state to return the human readable name of. If it's not any of the "
"states defined in usb_otg_state enum, 'UNDEFINED' will be returned."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:93
msgid "Returns human readable-name of the speed."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:99
#: drivers/usb/common/common.c:241
msgid "``enum usb_device_speed speed``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:94
msgid ""
"The speed to return human-readable name for.  If it's not any of the speeds "
"defined in usb_device_speed enum, string for USB_SPEED_UNKNOWN will be "
"returned."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:107
msgid "Get maximum requested speed for a given USB controller."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:113
#: drivers/usb/common/common.c:138 drivers/usb/common/common.c:224
#: drivers/usb/common/common.c:409 ../../../driver-api/usb/usb:206:
#: drivers/usb/core/hcd.c:2629 drivers/usb/core/hcd.c:2654
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:109
#: drivers/usb/common/common.c:134
msgid "Pointer to the given USB controller device"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:111
#: drivers/usb/common/common.c:136 drivers/usb/common/common.c:221
#: drivers/usb/common/common.c:242 drivers/usb/common/common.c:286
#: drivers/usb/common/common.c:339 drivers/usb/common/common.c:353
#: drivers/usb/common/common.c:406 ../../../driver-api/usb/usb:136:
#: include/linux/usb.h:66 include/linux/usb.h:218 include/linux/usb.h:287
#: include/linux/usb.h:348 include/linux/usb.h:385 include/linux/usb.h:1005
#: include/linux/usb.h:1019 include/linux/usb.h:1035 include/linux/usb.h:1051
#: include/linux/usb.h:1067 include/linux/usb.h:1083 include/linux/usb.h:1098
#: include/linux/usb.h:1115 include/linux/usb.h:1137 include/linux/usb.h:1222
#: include/linux/usb.h:1300 include/linux/usb.h:1331 include/linux/usb.h:1357
#: include/linux/usb.h:1515 include/linux/usb.h:1679 include/linux/usb.h:1720
#: include/linux/usb.h:1755 include/linux/usb.h:1936
#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:34
#: drivers/usb/core/urb.c:61 drivers/usb/core/urb.c:88
#: drivers/usb/core/urb.c:105 drivers/usb/core/urb.c:124
#: drivers/usb/core/urb.c:163 drivers/usb/core/urb.c:200
#: drivers/usb/core/urb.c:221 drivers/usb/core/urb.c:237
#: drivers/usb/core/urb.c:598 drivers/usb/core/urb.c:682
#: drivers/usb/core/urb.c:729 drivers/usb/core/urb.c:785
#: drivers/usb/core/urb.c:806 drivers/usb/core/urb.c:844
#: drivers/usb/core/urb.c:882 drivers/usb/core/urb.c:903
#: drivers/usb/core/urb.c:918 drivers/usb/core/urb.c:937
#: drivers/usb/core/urb.c:955 drivers/usb/core/urb.c:986
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:125
#: drivers/usb/core/message.c:182 drivers/usb/core/message.c:241
#: drivers/usb/core/message.c:312 drivers/usb/core/message.c:345
#: drivers/usb/core/message.c:489 drivers/usb/core/message.c:613
#: drivers/usb/core/message.c:717 drivers/usb/core/message.c:768
#: drivers/usb/core/message.c:959 drivers/usb/core/message.c:1110
#: drivers/usb/core/message.c:1188 drivers/usb/core/message.c:1314
#: drivers/usb/core/message.c:1495 drivers/usb/core/message.c:1671
#: drivers/usb/core/message.c:1931 drivers/usb/core/message.c:2274
#: drivers/usb/core/message.c:2316 ../../../driver-api/usb/usb:168:
#: drivers/usb/core/file.c:96 drivers/usb/core/file.c:168
#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:537
#: drivers/usb/core/driver.c:613 drivers/usb/core/driver.c:747
#: drivers/usb/core/driver.c:987 drivers/usb/core/driver.c:1033
#: drivers/usb/core/driver.c:1050 drivers/usb/core/driver.c:1105
#: drivers/usb/core/driver.c:1682 drivers/usb/core/driver.c:1698
#: drivers/usb/core/driver.c:1771 drivers/usb/core/driver.c:1799
#: drivers/usb/core/driver.c:1827 drivers/usb/core/driver.c:1845
#: drivers/usb/core/driver.c:1876 drivers/usb/core/driver.c:1909
#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:126
#: drivers/usb/core/usb.c:172 drivers/usb/core/usb.c:242
#: drivers/usb/core/usb.c:267 drivers/usb/core/usb.c:293
#: drivers/usb/core/usb.c:332 drivers/usb/core/usb.c:370
#: drivers/usb/core/usb.c:422 drivers/usb/core/usb.c:466
#: drivers/usb/core/usb.c:635 drivers/usb/core/usb.c:757
#: drivers/usb/core/usb.c:781 drivers/usb/core/usb.c:795
#: drivers/usb/core/usb.c:819 drivers/usb/core/usb.c:834
#: drivers/usb/core/usb.c:883 drivers/usb/core/usb.c:1019
#: drivers/usb/core/usb.c:1043 drivers/usb/core/usb.c:1093
#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:914
#: drivers/usb/core/hub.c:2170 drivers/usb/core/hub.c:4075
#: drivers/usb/core/hub.c:6326 drivers/usb/core/hub.c:6447
#: drivers/usb/core/hub.c:6485 ../../../driver-api/usb/usb:206:
#: drivers/usb/core/hcd.c:1120 drivers/usb/core/hcd.c:1175
#: drivers/usb/core/hcd.c:1216 drivers/usb/core/hcd.c:1725
#: drivers/usb/core/hcd.c:2020 drivers/usb/core/hcd.c:2072
#: drivers/usb/core/hcd.c:2397 drivers/usb/core/hcd.c:2428
#: drivers/usb/core/hcd.c:2466 drivers/usb/core/hcd.c:2506
#: drivers/usb/core/hcd.c:2635 drivers/usb/core/hcd.c:2658
#: drivers/usb/core/hcd.c:2804 drivers/usb/core/hcd.c:3031
#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:164
#: drivers/usb/core/hcd-pci.c:305 ../../../driver-api/usb/usb:212:
#: drivers/usb/core/buffer.c:57 drivers/usb/core/buffer.c:95
msgid "**Description**"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:110
msgid ""
"The function gets the maximum speed string from property \"maximum-speed\", "
"and returns the corresponding enum usb_device_speed."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:132
msgid ""
"Get the signaling rate generation and lane count of a SuperSpeed Plus "
"capable device."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:135
msgid ""
"If the string from \"maximum-speed\" property is super-speed-plus-genXxY "
"where 'X' is the generation number and 'Y' is the number of lanes, then this "
"function returns the corresponding enum usb_ssp_rate."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:155
msgid "Returns human readable name for the state."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:161
msgid "``enum usb_device_state state``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:156
msgid ""
"The state to return a human-readable name for. If it's not any of the states "
"devices in usb_device_state_string enum, the string UNKNOWN will be returned."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:218
msgid "Get default mode for given device"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:219
msgid "Pointer to the given device"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:220
msgid ""
"The function gets string from property 'role-switch-default-mode', and "
"returns the corresponding enum usb_dr_mode."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:238
msgid "Decode bInterval into the time expressed in 1us unit"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:244
msgid "``const struct usb_endpoint_descriptor *epd``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:239
msgid "The descriptor of the endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:240
msgid "The speed that the endpoint works as"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:241
msgid ""
"Function returns the interval expressed in 1us unit for servicing endpoint "
"for data transfers."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:280
msgid ""
"Get dual role mode for the controller device which is associated with the "
"given phy device_node"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:286
#: drivers/usb/common/common.c:341 drivers/usb/common/common.c:354
msgid "``struct device_node *np``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:282
msgid "Pointer to the given phy device_node"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:284
msgid "``int arg0``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:283
msgid ""
"phandle args[0] for phy's with #phy-cells >= 1, or -1 for phys which do not "
"have phy-cells"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:285
msgid ""
"In dts a usb controller associates with phy devices.  The function gets the "
"string from property 'dr_mode' of the controller associated with the given "
"phy device node, and returns the correspondig enum usb_dr_mode."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:335
msgid ""
"to get if Targeted Peripheral List is supported for given targeted hosts "
"(non-PC hosts)"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:337
#: drivers/usb/common/common.c:350
msgid "Pointer to the given device_node"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:338
msgid "The function gets if the targeted hosts support TPL or not"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:348
msgid ""
"to update usb otg capabilities according to the passed properties in DT."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:352
msgid "``struct usb_otg_caps *otg_caps``"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:351
msgid "Pointer to the target usb_otg_caps to be set"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:352
msgid "The function updates the otg capabilities"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:403
msgid "Find the companion device"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:404
msgid "the device pointer to find a companion"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:405
msgid "Find the companion device from platform bus."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:407
msgid ""
"Takes a reference to the returned struct device which needs to be dropped "
"after use."
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:410
#: ../../../driver-api/usb/usb:136: include/linux/usb.h:907
#: include/linux/usb.h:956 include/linux/usb.h:1824 include/linux/usb.h:1836
#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:68
#: drivers/usb/core/urb.c:108 drivers/usb/core/urb.c:364
#: drivers/usb/core/urb.c:662 drivers/usb/core/urb.c:939
#: drivers/usb/core/urb.c:957 drivers/usb/core/urb.c:1014
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:133
#: drivers/usb/core/message.c:196 drivers/usb/core/message.c:261
#: drivers/usb/core/message.c:320 drivers/usb/core/message.c:358
#: drivers/usb/core/message.c:499 drivers/usb/core/message.c:777
#: drivers/usb/core/message.c:965 drivers/usb/core/message.c:1016
#: drivers/usb/core/message.c:1203 drivers/usb/core/message.c:1523
#: drivers/usb/core/message.c:1690 drivers/usb/core/message.c:1933
#: drivers/usb/core/message.c:2283 drivers/usb/core/message.c:2319
#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:106
#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:545
#: drivers/usb/core/driver.c:813 drivers/usb/core/driver.c:990
#: drivers/usb/core/driver.c:1053 drivers/usb/core/driver.c:1857
#: drivers/usb/core/driver.c:1886 ../../../driver-api/usb/usb:174:
#: drivers/usb/core/usb.c:132 drivers/usb/core/usb.c:178
#: drivers/usb/core/usb.c:243 drivers/usb/core/usb.c:268
#: drivers/usb/core/usb.c:294 drivers/usb/core/usb.c:344
#: drivers/usb/core/usb.c:380 drivers/usb/core/usb.c:425
#: drivers/usb/core/usb.c:639 drivers/usb/core/usb.c:766
#: drivers/usb/core/usb.c:804 drivers/usb/core/usb.c:840
#: drivers/usb/core/usb.c:889 drivers/usb/core/usb.c:929
#: drivers/usb/core/usb.c:987 drivers/usb/core/usb.c:1048
#: drivers/usb/core/usb.c:1120 drivers/usb/core/usb.c:1151
#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:921
#: drivers/usb/core/hub.c:6329 drivers/usb/core/hub.c:6487
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1065
#: drivers/usb/core/hcd.c:1124 drivers/usb/core/hcd.c:1185
#: drivers/usb/core/hcd.c:2023 drivers/usb/core/hcd.c:2074
#: drivers/usb/core/hcd.c:2432 drivers/usb/core/hcd.c:2468
#: drivers/usb/core/hcd.c:2638 drivers/usb/core/hcd.c:2661
#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:169
#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:62
msgid "**Return**"
msgstr ""

#: ../../../driver-api/usb/usb:120: drivers/usb/common/common.c:411
msgid "On success, a pointer to the companion device, ``NULL`` on failure."
msgstr ""

#: ../../../driver-api/usb/usb.rst:123
msgid ""
"In addition, some functions useful for creating debugging output are defined "
"in ``drivers/usb/common/debug.c``."
msgstr ""

#: ../../../driver-api/usb/usb.rst:129
msgid "Host-Side Data Types and Macros"
msgstr ""

#: ../../../driver-api/usb/usb.rst:131
msgid ""
"The host side API exposes several layers to drivers, some of which are more "
"necessary than others. These support lifecycle models for host side drivers "
"and devices, and support passing buffers through usbcore to some HCD that "
"performs the I/O for the device driver."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:50
msgid "host-side endpoint descriptor and queue"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:54
#: include/linux/usb.h:185 include/linux/usb.h:343 include/linux/usb.h:370
#: include/linux/usb.h:583 include/linux/usb.h:1176 include/linux/usb.h:1275
#: include/linux/usb.h:1326 include/linux/usb.h:1442 include/linux/usb.h:1934
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:70
#: include/linux/usb.h:209 include/linux/usb.h:351 include/linux/usb.h:382
#: include/linux/usb.h:652 include/linux/usb.h:1199 include/linux/usb.h:1292
#: include/linux/usb.h:1335 include/linux/usb.h:1473 include/linux/usb.h:1941
msgid "**Members**"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:51
#: include/linux/usb.h:367
msgid "``desc``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:52
msgid "descriptor for this endpoint, wMaxPacketSize in native byteorder"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:52
msgid "``ss_ep_comp``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:53
msgid "SuperSpeed companion descriptor for this endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:53
msgid "``ssp_isoc_ep_comp``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:54
msgid "SuperSpeedPlus isoc companion descriptor for this endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:54
msgid "``eusb2_isoc_ep_comp``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:55
msgid "eUSB2 isoc companion descriptor for this endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:55
#: include/linux/usb.h:1439
msgid "``urb_list``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:56
msgid "urbs queued to this endpoint; maintained by usbcore"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:56
msgid "``hcpriv``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:57
msgid ""
"for use by HCD; typically holds hardware dma queue head (QH) with one or "
"more transfer descriptors (TDs) per urb"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:58
msgid "``ep_dev``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:59
msgid "ep_device for sysfs info"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:59
#: include/linux/usb.h:378
msgid "``extra``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:60
msgid "descriptors following this endpoint in the configuration"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:60
#: include/linux/usb.h:381
msgid "``extralen``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:61
msgid "how many bytes of \"extra\" are valid"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:61
msgid "``enabled``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:62
msgid "URBs may be submitted to this endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:62
msgid "``streams``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:63
msgid "number of USB-3 streams allocated on the endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:63
msgid ""
"USB requests are always queued to a given endpoint, identified by a "
"descriptor within an active interface in a given USB configuration."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:181
msgid "what usb device drivers talk to"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:182
#: include/linux/usb.h:342
msgid "``altsetting``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:183
msgid ""
"array of interface structures, one for each alternate setting that may be "
"selected.  Each one includes a set of endpoint configurations.  They will be "
"in no particular order."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:185
msgid "``cur_altsetting``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:186
msgid "the current altsetting."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:186
#: include/linux/usb.h:340
msgid "``num_altsetting``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:187
#: include/linux/usb.h:341
msgid "number of altsettings defined."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:187
#: include/linux/usb.h:370
msgid "``intf_assoc``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:188
msgid "interface association descriptor"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:188
msgid "``minor``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:189
msgid ""
"the minor number assigned to this interface, if this interface is bound to a "
"driver that uses the USB major number. If this interface does not use the "
"USB major, this field should be unused.  The driver should set this value in "
"the probe() function of the driver, after it has been assigned a minor "
"number from the USB core by calling usb_register_dev()."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:194
msgid "``condition``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:195
msgid ""
"binding state of the interface: not bound, binding (in probe()), bound to a "
"driver, or unbinding (in disconnect())"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:196
msgid "``sysfs_files_created``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:197
msgid "sysfs attributes exist"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:197
msgid "``ep_devs_created``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:198
msgid "endpoint child pseudo-devices exist"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:198
msgid "``unregistering``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:199
msgid "flag set when the interface is being unregistered"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:199
msgid "``needs_remote_wakeup``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:200
msgid ""
"flag set when the driver requires remote-wakeup capability during "
"autosuspend."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:201
msgid "``needs_altsetting0``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:202
msgid ""
"flag set when a set-interface request for altsetting 0 has been deferred."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:203
msgid "``needs_binding``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:204
msgid ""
"flag set when the driver should be re-probed or unbound following a reset or "
"suspend operation it doesn't support."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:215
msgid "``resetting_device``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:216
msgid ""
"USB core reset the device, so use alt setting 0 as current; needs bandwidth "
"alloc after reset."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:205
#: include/linux/usb.h:610
msgid "``authorized``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:206
msgid ""
"This allows to (de)authorize individual interfaces instead a whole device in "
"contrast to the device authorization."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:207
msgid "``wireless_status``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:208
msgid ""
"if the USB device uses a receiver/emitter combo, whether the emitter is "
"connected."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:209
msgid "``wireless_status_work``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:210
msgid "Used for scheduling wireless status changes from atomic context."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:211
#: include/linux/usb.h:594 include/linux/usb.h:1454
msgid "``dev``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:212
msgid "driver model's view of this device"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:212
msgid "``usb_dev``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:213
msgid ""
"if an interface is bound to the USB major, this will point to the sysfs "
"representation for that device."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:214
msgid "``reset_ws``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:215
msgid "Used for scheduling resets from atomic context."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:217
msgid ""
"USB device drivers attach to interfaces on a physical device.  Each "
"interface encapsulates a single high level function, such as feeding an "
"audio stream to a speaker or reporting a change in a volume control. Many "
"USB devices only have one interface.  The protocol used to talk to an "
"interface's endpoints can be defined in a usb \"class\" specification, or by "
"a product's vendor.  The (default) control endpoint is part of every "
"interface, but is never listed among the interface's descriptors."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:225
msgid ""
"The driver that is bound to the interface can use standard driver model "
"calls such as dev_get_drvdata() on the dev member of this structure."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:228
msgid ""
"Each interface may have alternate settings.  The initial configuration of a "
"device sets altsetting 0, but the device driver can change that setting "
"using usb_set_interface().  Alternate settings are often used to control the "
"use of periodic endpoints, such as by having different endpoints use "
"different amounts of reserved USB bandwidth. All standards-conformant USB "
"devices that use isochronous endpoints will use them in non-default settings."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:236
msgid ""
"The USB specification says that alternate setting numbers must run from 0 to "
"one less than the total number of alternate settings.  But some devices "
"manage to mess this up, and the structures aren't necessarily stored in "
"numerical order anyhow.  Use usb_altnum_to_altsetting() to look up an "
"alternate setting in the altsetting array based on its number."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:283
msgid "associate driver-specific data with an interface"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:289
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2313
#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:98
#: drivers/usb/core/file.c:170 ../../../driver-api/usb/usb:171:
#: drivers/usb/core/driver.c:1774 drivers/usb/core/driver.c:1802
#: drivers/usb/core/driver.c:1830 drivers/usb/core/driver.c:1848
#: drivers/usb/core/driver.c:1879 drivers/usb/core/driver.c:1912
#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:798
#: drivers/usb/core/usb.c:822 drivers/usb/core/usb.c:837
msgid "``struct usb_interface *intf``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:284
msgid "USB interface"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:286
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:119
#: drivers/usb/core/message.c:304 drivers/usb/core/message.c:337
#: drivers/usb/core/message.c:1107 ../../../driver-api/usb/usb:171:
#: drivers/usb/core/driver.c:536 ../../../driver-api/usb/usb:174:
#: drivers/usb/core/usb.c:468
msgid "``void *data``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:285
msgid "driver data"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:286
msgid ""
"Drivers can use this function in their probe() callbacks to associate driver-"
"specific data with an interface."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:289
msgid ""
"Note that there is generally no need to clear the driver-data pointer even "
"if some drivers do so for historical or implementation-specific reasons."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:339
msgid "long-term representation of a device interface"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:341
msgid "``ref``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:342
msgid "reference counter."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:343
msgid ""
"variable-length array of interface structures, one for each alternate "
"setting that may be selected.  Each one includes a set of endpoint "
"configurations.  They will be in no particular order."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:345
msgid ""
"These structures persist for the lifetime of a usb_device, unlike struct "
"usb_interface (which persists only as long as its configuration is "
"installed).  The altsetting arrays can be accessed through these structures "
"at any time, permitting comparison of configurations and providing support "
"for the /sys/kernel/debug/usb/devices pseudo-file."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:366
msgid "representation of a device's configuration"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:368
msgid "the device's configuration descriptor."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:368
msgid "``string``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:369
msgid ""
"pointer to the cached version of the iConfiguration string, if present for "
"this configuration."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:371
msgid "list of any interface association descriptors in this config"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:371
msgid "``interface``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:372
msgid ""
"array of pointers to usb_interface structures, one for each interface in the "
"configuration.  The number of interfaces is stored in desc.bNumInterfaces.  "
"These pointers are valid only while the configuration is active."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:375
msgid "``intf_cache``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:376
msgid ""
"array of pointers to usb_interface_cache structures, one for each interface "
"in the configuration.  These structures exist for the entire life of the "
"device."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:379
msgid ""
"pointer to buffer containing all extra descriptors associated with this "
"configuration (those preceding the first interface descriptor)."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:382
msgid "length of the extra descriptors buffer."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:382
msgid ""
"USB devices may have multiple configurations, but only one can be active at "
"any time.  Each encapsulates a different operational environment; for "
"example, a dual-speed device would have separate configurations for full-"
"speed and high-speed operation.  The number of configurations available is "
"stored in the device descriptor as bNumConfigurations."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:388
msgid ""
"A configuration can contain multiple interfaces.  Each corresponds to a "
"different function of the USB device, and all are available whenever the "
"configuration is active.  The USB standard says that interfaces are supposed "
"to be numbered from 0 to desc.bNumInterfaces-1, but a lot of devices get "
"this wrong.  In addition, the interface array is not guaranteed to be sorted "
"in numerical order.  Use usb_ifnum_to_if() to look up an interface entry "
"based on its number."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:396
msgid ""
"Device drivers should not attempt to activate configurations.  The choice of "
"which configuration to install is a policy decision based on such "
"considerations as available power, functionality provided, and the user's "
"desires (expressed through userspace tools).  However, drivers can call "
"usb_reset_configuration() to reinitialize the current configuration and all "
"its interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:579
msgid "kernel's representation of a USB device"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:580
msgid "``devnum``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:581
msgid "device number; address on a USB bus"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:581
msgid "``devpath``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:582
msgid "device ID string for use in messages (e.g., /port/...)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:582
msgid "``route``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:583
msgid "tree topology hex string for use with xHCI"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:583
msgid "``state``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:584
msgid "device state: configured, not attached, etc."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:584
msgid "``speed``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:585
msgid "device speed: high/full/low (or error)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:585
msgid "``rx_lanes``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:586
msgid "number of rx lanes in use, USB 3.2 adds dual-lane support"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:586
msgid "``tx_lanes``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:587
msgid "number of tx lanes in use, USB 3.2 adds dual-lane support"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:587
msgid "``ssp_rate``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:588
msgid "SuperSpeed Plus phy signaling rate and lane count"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:588
msgid "``tt``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:589
msgid ""
"Transaction Translator info; used with low/full speed dev, highspeed hub"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:589
msgid "``ttport``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:590
msgid "device port on that tt hub"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:590
msgid "``toggle``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:591
msgid "one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:591
msgid "``parent``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:592
msgid "our hub, unless we're the root"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:592
msgid "``bus``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:593
msgid "bus we're part of"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:593
msgid "``ep0``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:594
msgid "endpoint 0 data (default control pipe)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:595
msgid "generic device interface"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:595
msgid "``descriptor``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:596
msgid "USB device descriptor"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:596
msgid "``bos``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:597
msgid "USB device BOS descriptor set"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:597
msgid "``config``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:598
msgid "all of the device's configs"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:598
msgid "``actconfig``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:599
msgid "the active configuration"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:599
msgid "``ep_in``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:600
msgid "array of IN endpoints"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:600
msgid "``ep_out``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:601
msgid "array of OUT endpoints"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:601
msgid "``rawdescriptors``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:602
msgid "raw descriptors for each config"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:602
msgid "``bus_mA``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:603
msgid "Current available from the bus"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:603
msgid "``portnum``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:604
msgid "parent port number (origin 1)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:604
msgid "``level``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:605
msgid "number of USB hub ancestors"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:605
msgid "``devaddr``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:606
msgid "device address, XHCI: assigned by HW, others: same as devnum"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:606
msgid "``can_submit``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:607
msgid "URBs may be submitted"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:607
msgid "``persist_enabled``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:608
msgid "USB_PERSIST enabled for this device"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:608
msgid "``reset_in_progress``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:609
msgid "the device is being reset"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:609
msgid "``have_langid``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:610
msgid "whether string_langid is valid"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:611
msgid ""
"policy has said we can use it; (user space) policy determines if we "
"authorize this device to be used or not. By default, wired USB devices are "
"authorized. WUSB devices are not, until we authorize them from user space. "
"FIXME -- complete doc"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:615
msgid "``authenticated``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:616
msgid "Crypto authentication passed"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:618
msgid "``lpm_capable``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:619
msgid "device supports LPM"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:619
msgid "``lpm_devinit_allow``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:620
msgid "Allow USB3 device initiated LPM, exit latency is in range"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:620
msgid "``usb2_hw_lpm_capable``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:621
msgid "device can perform USB2 hardware LPM"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:621
msgid "``usb2_hw_lpm_besl_capable``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:622
msgid "device can perform USB2 hardware BESL LPM"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:622
msgid "``usb2_hw_lpm_enabled``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:623
msgid "USB2 hardware LPM is enabled"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:623
msgid "``usb2_hw_lpm_allowed``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:624
msgid "Userspace allows USB 2.0 LPM to be enabled"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:624
msgid "``usb3_lpm_u1_enabled``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:625
msgid "USB3 hardware U1 LPM enabled"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:625
msgid "``usb3_lpm_u2_enabled``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:626
msgid "USB3 hardware U2 LPM enabled"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:626
msgid "``string_langid``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:627
msgid "language ID for strings"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:627
msgid "``product``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:628
msgid "iProduct string, if present (static)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:628
msgid "``manufacturer``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:629
msgid "iManufacturer string, if present (static)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:629
msgid "``serial``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:630
msgid "iSerialNumber string, if present (static)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:630
msgid "``filelist``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:631
msgid "usbfs files that are open to this device"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:631
msgid "``maxchild``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:632
msgid "number of ports if hub"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:632
msgid "``quirks``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:633
msgid "quirks of the whole device"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:633
msgid "``urbnum``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:634
msgid "number of URBs submitted for the whole device"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:634
msgid "``active_duration``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:635
msgid "total time device is not suspended"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:635
msgid "``connect_time``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:636
msgid "time device was first connected"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:636
msgid "``do_remote_wakeup``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:637
msgid "remote wakeup should be enabled"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:637
#: include/linux/usb.h:1196
msgid "``reset_resume``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:638
msgid "needs reset instead of resume"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:638
msgid "``port_is_suspended``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:639
msgid "the upstream port is suspended (L2 or U3)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:639
msgid "``offload_at_suspend``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:640
msgid "offload activities during suspend is enabled."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:640
msgid "``offload_usage``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:641
msgid "number of offload activities happening on this usb device."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:616
msgid "``tunnel_mode``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:617
msgid "Connection native or tunneled over USB4"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:617
msgid "``usb4_link``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:618
msgid "device link to the USB4 host interface"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:641
msgid "``slot_id``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:642
msgid "Slot ID assigned by xHCI"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:642
msgid "``l1_params``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:643
msgid "best effor service latency for USB2 L1 LPM state, and L1 timeout."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:643
msgid "``u1_params``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:644
msgid "exit latencies for USB3 U1 LPM state, and hub-initiated timeout."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:644
msgid "``u2_params``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:645
msgid "exit latencies for USB3 U2 LPM state, and hub-initiated timeout."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:645
msgid "``lpm_disable_count``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:646
msgid ""
"Ref count used by usb_disable_lpm() and usb_enable_lpm() to keep track of "
"the number of functions that require USB 3.0 Link Power Management to be "
"disabled for this usb_device.  This count should only be manipulated by "
"those functions, with the bandwidth_mutex is held."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:649
msgid "``hub_delay``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:650
msgid ""
"cached value consisting of: parent->hub_delay + wHubDelay + "
"tTPTransmissionDelay (40ns) Will be used as wValue for SetIsochDelay "
"requests."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:652
msgid "``use_generic_driver``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:653
msgid "ask driver core to reprobe using the generic driver."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:656
msgid "**Notes**"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:654
msgid ""
"Usbcore drivers should not set usbdev->state directly.  Instead use "
"usb_set_device_state()."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:768
msgid "``usb_hub_for_each_child (hdev, port1, child)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:766
msgid "iterate over all child devices on the hub"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:772
msgid "``hdev``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:767
#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6481
msgid "USB device belonging to the usb hub"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:769
msgid "``port1``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:768
msgid "portnum associated with child device"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:770
msgid "``child``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:769
msgid "child device pointer"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:904
msgid "returns true iff an interface is claimed"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:910
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1933
#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:534
#: drivers/usb/core/driver.c:612 ../../../driver-api/usb/usb:177:
#: drivers/usb/core/hub.c:6450
msgid "``struct usb_interface *iface``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:905
msgid "the interface being checked"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:907
msgid "``true`` (nonzero) iff the interface is claimed, else ``false`` (zero)."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:910
#: include/linux/usb.h:958 ../../../driver-api/usb/usb:161:
#: drivers/usb/core/urb.c:90 ../../../driver-api/usb/usb:174:
#: drivers/usb/core/usb.c:933 drivers/usb/core/usb.c:992
#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6337
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1067
msgid "**Note**"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:910
msgid ""
"Callers must own the driver model's usb bus readlock.  So driver probe() "
"entries don't need extra locking, but other call contexts may need to "
"explicitly claim that lock."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:951
msgid "returns stable device path in the usb tree"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:957
#: include/linux/usb.h:1670 include/linux/usb.h:1713 include/linux/usb.h:1746
#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:202
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:117
#: drivers/usb/core/message.c:173 drivers/usb/core/message.c:232
#: drivers/usb/core/message.c:480 drivers/usb/core/message.c:765
#: drivers/usb/core/message.c:957 drivers/usb/core/message.c:1107
#: drivers/usb/core/message.c:1188 drivers/usb/core/message.c:1315
#: drivers/usb/core/message.c:1494 drivers/usb/core/message.c:1674
#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:760
#: drivers/usb/core/usb.c:784 drivers/usb/core/usb.c:932
#: drivers/usb/core/usb.c:987 drivers/usb/core/usb.c:1019
#: drivers/usb/core/usb.c:1041 drivers/usb/core/usb.c:1092
msgid "``struct usb_device *dev``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:952
msgid "the device whose path is being constructed"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:954
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:955
msgid "``char *buf``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:953
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:954
msgid "where to put the string"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:955
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:956
#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:984
#: drivers/usb/core/usb.c:1016 drivers/usb/core/usb.c:1038
#: drivers/usb/core/usb.c:1089
msgid "``size_t size``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:954
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:764
#: drivers/usb/core/message.c:955
msgid "how big is \"buf\"?"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:956
msgid "Length of the string (> 0) or negative if size was too small."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:958
msgid ""
"This identifier is intended to be \"stable\", reflecting physical paths in "
"hardware such as physical bus addresses for host controllers or ports on USB "
"hubs.  That makes it stay the same until systems are physically "
"reconfigured, by re-cabling a tree of USB devices or by moving USB host "
"controllers.  Adding and removing devices, including virtual root hubs in "
"host controller driver modules, does not change these path identifiers; "
"neither does rebooting or re-enumerating.  These are more useful identifiers "
"than changeable (\"unstable\") ones like bus numbers or device addresses."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:967
msgid ""
"With a partial exception for devices connected to USB 2.0 root hubs, these "
"identifiers are also predictable.  So long as the device tree isn't changed, "
"plugging any USB device into a given hub port always gives it the same path. "
"Because of the use of \"companion\" controllers, devices connected to ports "
"on USB 2.0 root hubs (EHCI host controllers) will get one path ID if they "
"are high speed, and a different one if they are full or low speed."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1003
msgid "``USB_DEVICE (vend, prod)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1001
msgid "macro used to describe a specific usb device"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1007
#: include/linux/usb.h:1019 include/linux/usb.h:1036 include/linux/usb.h:1052
#: include/linux/usb.h:1068 include/linux/usb.h:1114 include/linux/usb.h:1137
msgid "``vend``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1002
#: include/linux/usb.h:1014 include/linux/usb.h:1031 include/linux/usb.h:1047
#: include/linux/usb.h:1063 include/linux/usb.h:1109 include/linux/usb.h:1132
msgid "the 16 bit USB Vendor ID"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1004
#: include/linux/usb.h:1016 include/linux/usb.h:1033 include/linux/usb.h:1049
#: include/linux/usb.h:1065 include/linux/usb.h:1111
msgid "``prod``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1003
#: include/linux/usb.h:1015 include/linux/usb.h:1032 include/linux/usb.h:1048
#: include/linux/usb.h:1064 include/linux/usb.h:1110
msgid "the 16 bit USB Product ID"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1004
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"device."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1015
msgid "``USB_DEVICE_VER (vend, prod, lo, hi)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1013
msgid "describe a specific usb device with a version range"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1017
msgid "``lo``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1016
msgid "the bcdDevice_lo value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1018
msgid "``hi``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1017
msgid "the bcdDevice_hi value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1018
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"device, with a version range."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1032
msgid "``USB_DEVICE_INTERFACE_CLASS (vend, prod, cl)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1030
msgid "describe a usb device with a specific interface class"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1034
#: include/linux/usb.h:1084 include/linux/usb.h:1099 include/linux/usb.h:1112
#: include/linux/usb.h:1134
msgid "``cl``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1033
#: include/linux/usb.h:1094 include/linux/usb.h:1111 include/linux/usb.h:1133
msgid "bInterfaceClass value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1034
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"interface class of devices."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1048
msgid "``USB_DEVICE_INTERFACE_PROTOCOL (vend, prod, pr)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1046
msgid "describe a usb device with a specific interface protocol"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1050
#: include/linux/usb.h:1082 include/linux/usb.h:1097 include/linux/usb.h:1114
#: include/linux/usb.h:1136
msgid "``pr``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1049
#: include/linux/usb.h:1096 include/linux/usb.h:1113 include/linux/usb.h:1135
msgid "bInterfaceProtocol value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1050
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"interface protocol of devices."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1064
msgid "``USB_DEVICE_INTERFACE_NUMBER (vend, prod, num)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1062
msgid "describe a usb device with a specific interface number"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1066
msgid "``num``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1065
msgid "bInterfaceNumber value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1066
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"interface number of devices."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1080
msgid "``USB_DEVICE_INFO (cl, sc, pr)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1078
msgid "macro used to describe a class of usb devices"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1079
msgid "bDeviceClass value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1081
#: include/linux/usb.h:1096 include/linux/usb.h:1113 include/linux/usb.h:1135
msgid "``sc``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1080
msgid "bDeviceSubClass value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1081
msgid "bDeviceProtocol value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1082
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"class of devices."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1095
msgid "``USB_INTERFACE_INFO (cl, sc, pr)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1093
msgid "macro used to describe a class of usb interfaces"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1095
#: include/linux/usb.h:1112 include/linux/usb.h:1134
msgid "bInterfaceSubClass value"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1097
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"class of interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1110
msgid "``USB_DEVICE_AND_INTERFACE_INFO (vend, prod, cl, sc, pr)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1108
msgid "describe a specific usb device with a class of usb interfaces"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1114
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"device with a specific class of interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1117
#: include/linux/usb.h:1139
msgid ""
"This is especially useful when explicitly matching devices that have vendor "
"specific bDeviceClass values, but standards-compliant interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1133
msgid "``USB_VENDOR_AND_INTERFACE_INFO (vend, cl, sc, pr)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1131
msgid "describe a specific usb vendor with a class of usb interfaces"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1136
msgid ""
"This macro is used to create a struct usb_device_id that matches a specific "
"vendor with a specific class of interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1172
msgid "identifies USB interface driver to usbcore"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1173
#: include/linux/usb.h:1272 include/linux/usb.h:1323
msgid "``name``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1174
#: include/linux/usb.h:1273
msgid ""
"The driver name should be unique among USB drivers, and should normally be "
"the same as the module name."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1175
#: include/linux/usb.h:1275
msgid "``probe``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1176
msgid ""
"Called to see if the driver is willing to manage a particular interface on a "
"device.  If it is, probe returns zero and uses usb_set_intfdata() to "
"associate driver-specific data with the interface.  It may also use "
"usb_set_interface() to specify the appropriate altsetting.  If unwilling to "
"manage the interface, return -ENODEV, if genuine IO errors occurred, an "
"appropriate negative errno value."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1182
#: include/linux/usb.h:1279
msgid "``disconnect``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1183
msgid ""
"Called when the interface is no longer accessible, usually because its "
"device has been (or is being) disconnected or the driver module is being "
"unloaded."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1185
msgid "``unlocked_ioctl``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1186
msgid ""
"Used for drivers that want to talk to userspace through the \"usbfs\" "
"filesystem.  This lets devices provide ways to expose information to user "
"space regardless of where they do (or don't) show up otherwise in the "
"filesystem."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1189
#: include/linux/usb.h:1282
msgid "``suspend``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1190
msgid ""
"Called when the device is going to be suspended by the system either from "
"system sleep or runtime suspend context. The return value will be ignored in "
"system sleep context, so do NOT try to continue using the device if suspend "
"fails in this case. Instead, let the resume or reset-resume routine recover "
"from the failure."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1195
#: include/linux/usb.h:1283
msgid "``resume``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1196
#: include/linux/usb.h:1284
msgid "Called when the device is being resumed by the system."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1197
msgid ""
"Called when the suspended device has been reset instead of being resumed."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1198
msgid "``pre_reset``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1199
msgid ""
"Called by usb_reset_device() when the device is about to be reset.  This "
"routine must not return until the driver has no active URBs for the device, "
"and no more URBs may be submitted until the post_reset method is called."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1202
msgid "``post_reset``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1203
msgid "Called by usb_reset_device() after the device has been reset"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1204
msgid "``shutdown``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1205
msgid "Called at shut-down time to quiesce the device."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1205
#: include/linux/usb.h:1290
msgid "``id_table``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1206
msgid ""
"USB drivers use ID table to support hotplugging. Export this with "
"MODULE_DEVICE_TABLE(usb,...).  This must be set or your driver's probe "
"function will never get called."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1208
#: include/linux/usb.h:1287
msgid "``dev_groups``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1209
#: include/linux/usb.h:1288
msgid ""
"Attributes attached to the device that will be created once it is bound to "
"the driver."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1210
msgid "``dynids``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1211
msgid ""
"used internally to hold the list of dynamically added device ids for this "
"driver."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1212
#: include/linux/usb.h:1289
msgid "``driver``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1213
#: include/linux/usb.h:1290
msgid "The driver-model core driver structure."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1213
msgid "``no_dynamic_id``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1214
msgid ""
"if set to 1, the USB core will not allow dynamic ids to be added to this "
"driver by preventing the sysfs file from being created."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1215
#: include/linux/usb.h:1292
msgid "``supports_autosuspend``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1216
msgid ""
"if set to 0, the USB core will not allow autosuspend for interfaces bound to "
"this driver."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1219
msgid "``disable_hub_initiated_lpm``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1220
msgid ""
"if set to 1, the USB core will not allow hubs to initiate lower power link "
"state transitions when an idle timeout occurs.  Device-initiated USB 3.0 "
"link PM will still be allowed."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1217
msgid "``soft_unbind``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1218
msgid ""
"if set to 1, the USB core will not kill URBs and disable endpoints before "
"calling the driver's disconnect method."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1222
msgid ""
"USB interface drivers must provide a name, probe() and disconnect() methods, "
"and an id_table.  Other driver fields are optional."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1225
msgid ""
"The id_table is used in hotplugging.  It holds a set of descriptors, and "
"specialized data may be associated with each entry.  That table is used by "
"both user and kernel mode hotplugging support."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1229
msgid ""
"The probe() and disconnect() methods are called in a context where they can "
"sleep, but they should avoid abusing the privilege.  Most work to connect to "
"a device should be done when the device is opened, and undone at the last "
"close.  The disconnect code needs to address concurrency issues with respect "
"to open() and close() methods, as well as forcing all pending I/O requests "
"to complete (by unlinking them as necessary, and blocking until the unlinks "
"complete)."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1271
msgid "identifies USB device driver to usbcore"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1274
msgid "``match``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1275
msgid "If set, used for better device/driver matching."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1276
msgid ""
"Called to see if the driver is willing to manage a particular device.  If it "
"is, probe returns zero and uses dev_set_drvdata() to associate driver-"
"specific data with the device.  If unwilling to manage the device, return a "
"negative errno value."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1280
msgid ""
"Called when the device is no longer accessible, usually because it has been "
"(or is being) disconnected or the driver's module is being unloaded."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1283
msgid "Called when the device is going to be suspended by the system."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1284
msgid "``choose_configuration``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1285
msgid ""
"If non-NULL, called instead of the default usb_choose_configuration(). If "
"this returns an error then we'll go on to call the normal "
"usb_choose_configuration()."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1291
msgid ""
"used with **match\\(\\)** to select better matching driver at probe() time."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1293
msgid ""
"if set to 0, the USB core will not allow autosuspend for devices bound to "
"this driver."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1294
msgid "``generic_subclass``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1295
msgid ""
"if set to 1, the generic USB driver's probe, disconnect, resume and suspend "
"functions will be called in addition to the driver's own, so this part of "
"the setup does not need to be replicated."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1297
msgid ""
"USB drivers must provide all the fields listed above except driver, match, "
"and id_table."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1322
msgid "identifies a USB driver that wants to use the USB major number"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1324
msgid "the usb class device name for this driver.  Will show up in sysfs."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1324
msgid "``devnode``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1325
msgid "Callback to provide a naming hint for a possible device node to create."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1326
msgid "``fops``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1327
msgid "pointer to the struct file_operations of this driver."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1327
msgid "``minor_base``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1328
msgid "the start of the minor range for this driver."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1328
msgid ""
"This structure is used for the usb_register_dev() and usb_deregister_dev() "
"functions, to consolidate a number of the parameters used for them."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1356
msgid "``module_usb_driver (__usb_driver)``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1354
msgid "Helper macro for registering a USB driver"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1360
msgid "``__usb_driver``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1355
msgid "usb_driver struct"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1356
msgid ""
"Helper macro for USB drivers which do not do anything special in module init/"
"exit. This eliminates a lot of boilerplate. Each module may only use this "
"macro once, and calling it replaces module_init() and module_exit()"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1438
msgid "USB Request Block"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1440
msgid "For use by current owner of the URB."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1440
msgid "``anchor_list``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1441
msgid "membership in the list of an anchor"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1441
msgid "``anchor``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1442
msgid "to anchor URBs to a common mooring"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1455
msgid "Identifies the USB device to perform the request."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1442
msgid "``ep``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1443
msgid ""
"Points to the endpoint's data structure.  Will eventually replace **pipe**."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1444
msgid "``pipe``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1445
msgid ""
"Holds endpoint number, direction, type, and more. Create these values with "
"the eight macros available; usb_{snd,rcv}TYPEpipe(dev,endpoint), where the "
"TYPE is \"ctrl\" (control), \"bulk\", \"int\" (interrupt), or "
"\"iso\" (isochronous). For example usb_sndbulkpipe() or usb_rcvintpipe().  "
"Endpoint numbers range from zero to fifteen.  Note that \"in\" endpoint two "
"is a different endpoint (and pipe) from \"out\" endpoint two. The current "
"configuration controls the existence, type, and maximum packet size of any "
"given endpoint."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1453
msgid "``stream_id``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1454
msgid "the endpoint's stream ID for bulk streams"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1455
#: include/linux/usb.h:1931
msgid "``status``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1456
msgid ""
"This is read in non-iso completion functions to get the status of the "
"particular request.  ISO requests only use it to tell whether the URB was "
"unlinked; detailed status for each frame is in the fields of the iso_frame-"
"desc."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1459
msgid "``transfer_flags``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1460
msgid ""
"A variety of flags may be used to affect how URB submission, unlinking, or "
"operation are handled.  Different kinds of URB can use different flags."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1462
msgid "``transfer_buffer``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1463
msgid ""
"This identifies the buffer to (or from) which the I/O request will be "
"performed unless URB_NO_TRANSFER_DMA_MAP is set (however, do not leave "
"garbage in transfer_buffer even then). This buffer must be suitable for DMA; "
"allocate it with kmalloc() or equivalent.  For transfers to \"in\" "
"endpoints, contents of this buffer will be modified.  This buffer is used "
"for the data stage of control transfers."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1469
msgid "``transfer_dma``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1470
msgid ""
"When transfer_flags includes URB_NO_TRANSFER_DMA_MAP, the device driver is "
"saying that it provided this DMA address, which the host controller driver "
"should use in preference to the transfer_buffer."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1473
msgid "``sg``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1474
msgid ""
"scatter gather buffer list, the buffer size of each element in the list "
"(except the last) must be divisible by the endpoint's max packet size if "
"no_sg_constraint isn't set in 'struct usb_bus'"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1476
msgid "``sgt``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1477
msgid ""
"used to hold a scatter gather table returned by usb_alloc_noncoherent(), "
"which describes the allocated non-coherent and possibly non-contiguous "
"memory and is guaranteed to have 1 single DMA mapped segment. The allocated "
"memory needs to be freed by usb_free_noncoherent()."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1480
msgid "``num_mapped_sgs``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1481
msgid "(internal) number of mapped sg entries"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1481
msgid "``num_sgs``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1482
msgid "number of entries in the sg list"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1482
msgid "``transfer_buffer_length``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1483
msgid ""
"How big is transfer_buffer.  The transfer may be broken up into chunks "
"according to the current maximum packet size for the endpoint, which is a "
"function of the configuration and is encoded in the pipe.  When the length "
"is zero, neither transfer_buffer nor transfer_dma is used."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1487
msgid "``actual_length``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1488
msgid ""
"This is read in non-iso completion functions, and it tells how many bytes "
"(out of transfer_buffer_length) were transferred.  It will normally be the "
"same as requested, unless either an error was reported or a short read was "
"performed. The URB_SHORT_NOT_OK transfer flag may be used to make such short "
"reads be reported as errors."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1493
msgid "``setup_packet``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1494
msgid ""
"Only used for control transfers, this points to eight bytes of setup data.  "
"Control transfers always start by sending this data to the device.  Then "
"transfer_buffer is read or written, if needed."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1496
msgid "``setup_dma``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1497
msgid ""
"DMA pointer for the setup packet.  The caller must not use this field; "
"setup_packet must point to a valid buffer."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1498
msgid "``start_frame``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1499
msgid "Returns the initial frame for isochronous transfers."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1499
msgid "``number_of_packets``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1500
msgid "Lists the number of ISO transfer buffers."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1500
msgid "``interval``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1501
msgid ""
"Specifies the polling interval for interrupt or isochronous transfers.  The "
"units are frames (milliseconds) for full and low speed devices, and "
"microframes (1/8 millisecond) for highspeed and SuperSpeed devices."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1504
msgid "``error_count``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1505
msgid "Returns the number of ISO transfers that reported errors."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1505
msgid "``context``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1506
msgid ""
"For use in completion functions.  This normally points to request-specific "
"driver context."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1507
msgid "``complete``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1508
msgid ""
"Completion handler. This URB is passed as the parameter to the completion "
"function.  The completion function may then do what it likes with the URB, "
"including resubmitting or freeing it."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1510
msgid "``iso_frame_desc``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1511
msgid ""
"Used to provide arrays of ISO transfer buffers and to collect the transfer "
"status for each buffer."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1512
msgid ""
"This structure identifies USB transfer requests.  URBs must be allocated by "
"calling usb_alloc_urb() and freed with a call to usb_free_urb(). "
"Initialization may be done using various usb_fill_*_urb() functions.  URBs "
"are submitted using usb_submit_urb(), and pending requests may be canceled "
"using usb_unlink_urb() or usb_kill_urb()."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1518
msgid "Data Transfer Buffers:"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1520
msgid ""
"Normally drivers provide I/O buffers allocated with kmalloc() or otherwise "
"taken from the general page pool.  That is provided by transfer_buffer "
"(control requests also use setup_packet), and host controller drivers "
"perform a dma mapping (and unmapping) for each buffer transferred.  Those "
"mapping operations can be expensive on some platforms (perhaps using a dma "
"bounce buffer or talking to an IOMMU), although they're cheap on commodity "
"x86 and ppc hardware."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1528
msgid ""
"Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag, "
"which tells the host controller driver that no such mapping is needed for "
"the transfer_buffer since the device driver is DMA-aware.  For example, a "
"device driver might allocate a DMA buffer with usb_alloc_coherent() or call "
"usb_buffer_map(). When this transfer flag is provided, host controller "
"drivers will attempt to use the dma address found in the transfer_dma field "
"rather than determining a dma address themselves."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1537
msgid ""
"Note that transfer_buffer must still be set if the controller does not "
"support DMA (as indicated by hcd_uses_dma()) and when talking to root hub. "
"If you have to transfer between highmem zone and the device on such "
"controller, create a bounce buffer or bail out with an error. If "
"transfer_buffer cannot be set (is in highmem) and the controller is DMA "
"capable, assign NULL to it, so that usbmon knows not to use the value. The "
"setup_packet must always be set, so it cannot be located in highmem."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1545
msgid "Initialization:"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1547
msgid ""
"All URBs submitted must initialize the dev, pipe, transfer_flags (may be "
"zero), and complete fields.  All URBs must also initialize transfer_buffer "
"and transfer_buffer_length.  They may provide the URB_SHORT_NOT_OK transfer "
"flag, indicating that short reads are to be treated as errors; that flag is "
"invalid for write requests."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1553
msgid ""
"Bulk URBs may use the URB_ZERO_PACKET transfer flag, indicating that bulk "
"OUT transfers should always terminate with a short packet, even if it means "
"adding an extra zero length packet."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1558
msgid ""
"Control URBs must provide a valid pointer in the setup_packet field. Unlike "
"the transfer_buffer, the setup_packet may not be mapped for DMA beforehand."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1562
msgid ""
"Interrupt URBs must provide an interval, saying how often (in milliseconds "
"or, for highspeed devices, 125 microsecond units) to poll for transfers.  "
"After the URB has been submitted, the interval field reflects how the "
"transfer was actually scheduled. The polling interval may be more frequent "
"than requested. For example, some controllers have a maximum interval of 32 "
"milliseconds, while others support intervals of up to 1024 milliseconds. "
"Isochronous URBs also have transfer intervals.  (Note that for isochronous "
"endpoints, as well as high speed interrupt endpoints, the encoding of the "
"transfer interval in the endpoint descriptor is logarithmic. Device drivers "
"must convert that value to linear units themselves.)"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1574
msgid ""
"If an isochronous endpoint queue isn't already running, the host controller "
"will schedule a new URB to start as soon as bandwidth utilization allows.  "
"If the queue is running then a new URB will be scheduled to start in the "
"first transfer slot following the end of the preceding URB, if that slot has "
"not already expired.  If the slot has expired (which can happen when IRQ "
"delivery is delayed for a long time), the scheduling behavior depends on the "
"URB_ISO_ASAP flag.  If the flag is clear then the URB will be scheduled to "
"start in the expired slot, implying that some of its packets will not be "
"transferred; if the flag is set then the URB will be scheduled in the first "
"unexpired slot, breaking the queue's synchronization.  Upon URB completion, "
"the start_frame field will be set to the (micro)frame number in which the "
"transfer was scheduled.  Ranges for frame counter values are HC-specific and "
"can go from as low as 256 to as high as 65536 frames."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1589
msgid ""
"Isochronous URBs have a different data transfer model, in part because the "
"quality of service is only \"best effort\".  Callers provide specially "
"allocated URBs, with number_of_packets worth of iso_frame_desc structures at "
"the end.  Each such packet is an individual ISO transfer.  Isochronous URBs "
"are normally queued, submitted by drivers to arrange that transfers are at "
"least double buffered, and then explicitly resubmitted in completion "
"handlers, so that data (such as audio or video) streams at as constant a "
"rate as the host controller scheduler can support."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1599
msgid "Completion Callbacks:"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1601
msgid ""
"The completion callback is made in_interrupt(), and one of the first things "
"that a completion handler should do is check the status field. The status "
"field is provided for all URBs.  It is used to report unlinked URBs, and "
"status for all non-ISO transfers.  It should not be examined before the URB "
"is returned to the completion handler."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1607
msgid ""
"The context field is normally used to link URBs back to the relevant driver "
"or request state."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1610
msgid ""
"When the completion callback is invoked for non-isochronous URBs, the "
"actual_length field tells how many bytes were transferred.  This field is "
"updated even when the URB terminated with an error or was unlinked."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1614
msgid ""
"ISO transfer status is reported in the status and actual_length fields of "
"the iso_frame_desc array, and the number of errors is reported in "
"error_count.  Completion callbacks for ISO transfers will normally "
"(re)submit URBs to ensure a constant transfer rate."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1619
msgid ""
"Note that even fields marked \"public\" should not be touched by the driver "
"when the urb is owned by the hcd, that is, since the call to "
"usb_submit_urb() till the entry into the completion routine."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1667
msgid "initializes a control urb"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1673
#: include/linux/usb.h:1716 include/linux/usb.h:1749 include/linux/usb.h:1827
#: include/linux/usb.h:1839 ../../../driver-api/usb/usb:161:
#: drivers/usb/core/urb.c:37 drivers/usb/core/urb.c:91
#: drivers/usb/core/urb.c:108 drivers/usb/core/urb.c:126
#: drivers/usb/core/urb.c:166 drivers/usb/core/urb.c:238
#: drivers/usb/core/urb.c:600 drivers/usb/core/urb.c:684
#: drivers/usb/core/urb.c:731 drivers/usb/core/urb.c:788
#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:917
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1119
#: drivers/usb/core/hcd.c:1173 drivers/usb/core/hcd.c:1215
#: drivers/usb/core/hcd.c:1718
msgid "``struct urb *urb``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1668
#: include/linux/usb.h:1711 include/linux/usb.h:1744
msgid "pointer to the urb to initialize."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1669
#: include/linux/usb.h:1712 include/linux/usb.h:1745
msgid "pointer to the struct usb_device for this urb."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1671
#: include/linux/usb.h:1714 include/linux/usb.h:1747
#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:199
#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:114
#: drivers/usb/core/message.c:303 drivers/usb/core/message.c:336
msgid "``unsigned int pipe``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1670
#: include/linux/usb.h:1713 include/linux/usb.h:1746
msgid "the endpoint pipe"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1672
msgid "``unsigned char *setup_packet``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1671
msgid ""
"pointer to the setup_packet buffer. The buffer must be suitable for DMA."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1674
#: include/linux/usb.h:1715 include/linux/usb.h:1748
msgid "``void *transfer_buffer``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1673
#: include/linux/usb.h:1714 include/linux/usb.h:1747
msgid "pointer to the transfer buffer. The buffer must be suitable for DMA."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1676
#: include/linux/usb.h:1717 include/linux/usb.h:1750
msgid "``int buffer_length``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1675
#: include/linux/usb.h:1716 include/linux/usb.h:1749
msgid "length of the transfer buffer"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1677
#: include/linux/usb.h:1718 include/linux/usb.h:1751
msgid "``usb_complete_t complete_fn``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1676
#: include/linux/usb.h:1717 include/linux/usb.h:1750
msgid "pointer to the usb_complete_t function"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1678
#: include/linux/usb.h:1719 include/linux/usb.h:1752
msgid "``void *context``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1677
#: include/linux/usb.h:1718 include/linux/usb.h:1751
msgid "what to set the urb context to."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1678
msgid ""
"Initializes a control urb with the proper information needed to submit it to "
"a device."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1681
msgid ""
"The transfer buffer and the setup_packet buffer will most likely be filled "
"or read via DMA. The simplest way to get a buffer that can be DMAed to is "
"allocating it via kmalloc() or equivalent, even for very small buffers. If "
"the buffers are embedded in a bigger structure, there is a risk that the "
"buffer itself, the previous fields and/or the next fields are corrupted due "
"to cache incoherencies; or slowed down if they are evicted from the cache. "
"For more information, check :c:type:`struct urb <urb>`."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1710
msgid "macro to help initialize a bulk urb"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1719
msgid ""
"Initializes a bulk urb with the proper information needed to submit it to a "
"device."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1722
#: include/linux/usb.h:1757
msgid ""
"Refer to usb_fill_control_urb() for a description of the requirements for "
"transfer_buffer."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1743
msgid "macro to help initialize a interrupt urb"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1753
msgid "``int interval``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1752
msgid ""
"what to set the urb interval to, encoded like the endpoint descriptor's "
"bInterval value."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1754
msgid ""
"Initializes a interrupt urb with the proper information needed to submit it "
"to a device."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1760
msgid ""
"Note that High Speed and SuperSpeed(+) interrupt endpoints use a logarithmic "
"encoding of the endpoint interval, and express polling intervals in "
"microframes (eight per millisecond) rather than in frames (one per "
"millisecond)."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1821
msgid "check if an URB describes an IN transfer"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1822
#: include/linux/usb.h:1834
msgid "URB to be checked"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1824
msgid "1 if **urb** describes an IN transfer (device-to-host), otherwise 0."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1833
msgid "check if an URB describes an OUT transfer"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1836
msgid "1 if **urb** describes an OUT transfer (host-to-device), otherwise 0."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1930
msgid "support for scatter/gather I/O"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1932
msgid "zero indicates success, else negative errno"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1932
msgid "``bytes``"
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1933
msgid "counts bytes transferred."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1933
msgid ""
"These requests are initialized using usb_sg_init(), and then are used as "
"request handles passed to usb_sg_wait() or usb_sg_cancel().  Most members of "
"the request object aren't for driver access."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1937
msgid ""
"The status and bytecount values are valid only after usb_sg_wait() returns.  "
"If the status is zero, then the bytecount matches the total from the request."
msgstr ""

#: ../../../driver-api/usb/usb:136: include/linux/usb.h:1941
msgid ""
"After an error completion, drivers may need to clear a halt condition on the "
"endpoint."
msgstr ""

#: ../../../driver-api/usb/usb.rst:140
msgid "USB Core APIs"
msgstr ""

#: ../../../driver-api/usb/usb.rst:142
msgid ""
"There are two basic I/O models in the USB API. The most elemental one is "
"asynchronous: drivers submit requests in the form of an URB, and the URB's "
"completion callback handles the next step. All USB transfer types support "
"that model, although there are special cases for control URBs (which always "
"have setup and status stages, but may not have a data stage) and isochronous "
"URBs (which allow large packets and include per-packet fault reports). Built "
"on top of that is synchronous API support, where a driver calls a routine "
"that allocates one or more URBs, submits them, and waits until they "
"complete. There are synchronous wrappers for single-buffer control and bulk "
"transfers (which are awkward to use in some driver disconnect scenarios), "
"and for scatterlist based streaming i/o (bulk or interrupt)."
msgstr ""

#: ../../../driver-api/usb/usb.rst:155
msgid ""
"USB drivers need to provide buffers that can be used for DMA, although they "
"don't necessarily need to provide the DMA mapping themselves. There are APIs "
"to use used when allocating DMA buffers, which can prevent use of bounce "
"buffers on some systems. In some cases, drivers may be able to rely on 64bit "
"DMA to eliminate another kind of bounce buffer."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:31
msgid "initializes a urb so that it can be used by a USB driver"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:32
msgid "pointer to the urb to initialize"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:33
msgid "Initializes a urb so that the USB subsystem can use it properly."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:35
msgid ""
"If a urb is created with a call to usb_alloc_urb() it is not necessary to "
"call this function.  Only use this if you allocate the space for a struct "
"urb on your own.  If you call this function, be careful when freeing the "
"memory for your urb that it is no longer in use by the USB core."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:41
msgid "Only use this function if you _really_ understand what you are doing."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:56
msgid "creates a new urb for a USB driver to use"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:62
msgid "``int iso_packets``"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:57
msgid "number of iso packets for this urb"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:59
#: drivers/usb/core/urb.c:235 ../../../driver-api/usb/usb:165:
#: drivers/usb/core/message.c:488 ../../../driver-api/usb/usb:174:
#: drivers/usb/core/usb.c:985 drivers/usb/core/usb.c:1039
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2019
#: drivers/usb/core/hcd.c:2071
msgid "``gfp_t mem_flags``"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:58
#: drivers/usb/core/urb.c:234
msgid ""
"the type of memory to allocate, see kmalloc() for a list of valid options "
"for this."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:60
msgid ""
"Creates an urb for the USB driver to use, initializes a few internal "
"structures, increments the usage counter, and returns a pointer to it."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:63
msgid ""
"If the driver want to use this urb for interrupt, control, or bulk "
"endpoints, pass '0' as the number of iso packets."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:66
msgid "The driver must call usb_free_urb() when it is finished with the urb."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:69
msgid "A pointer to the new urb, or ``NULL`` if no memory is available."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:85
msgid "frees the memory used by a urb when all users of it are finished"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:86
msgid "pointer to the urb to free, may be NULL"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:87
msgid ""
"Must be called when a user of a urb is finished with it.  When the last user "
"of the urb calls this function, the memory of the urb is freed."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:91
msgid ""
"The transfer buffer associated with the urb is not freed unless the "
"URB_FREE_BUFFER transfer flag is set."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:102
msgid "increments the reference count of the urb"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:103
msgid "pointer to the urb to modify, may be NULL"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:104
msgid ""
"This must be  called whenever a urb is transferred from a device driver to a "
"host controller driver.  This allows proper reference counting to happen for "
"urbs."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:109
msgid "A pointer to the urb with the incremented reference counter."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:120
msgid "anchors an URB while it is processed"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:121
#: drivers/usb/core/urb.c:161
msgid "pointer to the urb to anchor"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:123
#: drivers/usb/core/urb.c:809 drivers/usb/core/urb.c:847
#: drivers/usb/core/urb.c:885 drivers/usb/core/urb.c:906
#: drivers/usb/core/urb.c:921 drivers/usb/core/urb.c:939
#: drivers/usb/core/urb.c:958 drivers/usb/core/urb.c:989
#: drivers/usb/core/urb.c:1017
msgid "``struct usb_anchor *anchor``"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:122
msgid "pointer to the anchor"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:123
msgid ""
"This can be called to have access to URBs which are to be executed without "
"bothering to track them"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:160
msgid "unanchors an URB"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:162
msgid "Call this to stop the system keeping track of this URB"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:196
msgid "sanity check of a specific pipe for a usb device"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:197
msgid "struct usb_device to be checked"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:198
msgid "pipe to check"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:199
msgid ""
"This performs a light-weight sanity check for the endpoint in the given usb "
"device.  It returns 0 if the pipe is valid for the specific usb device, "
"otherwise a negative error code."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:218
msgid "sanity check of endpoint in the given urb"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:224
msgid "``const struct urb *urb``"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:219
msgid "urb to be checked"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:220
msgid ""
"This performs a light-weight sanity check for the endpoint in the given "
"urb.  It returns 0 if the urb contains a valid endpoint, otherwise a "
"negative error code."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:232
msgid "issue an asynchronous transfer request for an endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:233
msgid "pointer to the urb describing the request"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:236
msgid ""
"This submits a transfer request, and transfers control of the URB describing "
"that request to the USB subsystem.  Request completion will be indicated "
"later, asynchronously, by calling the completion handler. The three types of "
"completion are success, error, and unlink (a software-induced fault, also "
"called \"request cancellation\")."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:242
msgid "URBs may be submitted in interrupt context."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:244
msgid ""
"The caller must have correctly initialized the URB before submitting it.  "
"Functions such as usb_fill_bulk_urb() and usb_fill_control_urb() are "
"available to ensure that most fields are correctly initialized, for the "
"particular kind of transfer, although they will not initialize any transfer "
"flags."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:250
msgid ""
"If the submission is successful, the complete() callback from the URB will "
"be called exactly once, when the USB core and Host Controller Driver (HCD) "
"are finished with the URB.  When the completion function is called, control "
"of the URB is returned to the device driver which issued the request.  The "
"completion handler may then immediately free or reuse that URB."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:257
msgid ""
"With few exceptions, USB device drivers should never access URB fields "
"provided by usbcore or the HCD until its complete() is called. The "
"exceptions relate to periodic transfer scheduling.  For both interrupt and "
"isochronous urbs, as part of successful URB submission urb->interval is "
"modified to reflect the actual transfer period used (normally some power of "
"two units).  And for isochronous urbs, urb->start_frame is modified to "
"reflect when the URB's transfers were scheduled to start."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:266
msgid ""
"Not all isochronous transfer scheduling policies will work, but most host "
"controller drivers should easily handle ISO queues going from now until "
"10-200 msec into the future.  Drivers should try to keep at least one or two "
"msec of data in the queue; many controllers require that new transfers start "
"at least 1 msec in the future when they are added.  If the driver is unable "
"to keep up and the queue empties out, the behavior for new submissions is "
"governed by the URB_ISO_ASAP flag. If the flag is set, or if the queue is "
"idle, then the URB is always assigned to the first available (and not yet "
"expired) slot in the endpoint's schedule.  If the flag is not set and the "
"queue is active then the URB is always assigned to the next slot in the "
"schedule following the end of the endpoint's previous URB, even if that slot "
"is in the past.  When a packet is assigned in this way to a slot that has "
"already expired, the packet is not transmitted and the corresponding "
"usb_iso_packet_descriptor's status field will return -EXDEV.  If this would "
"happen to all the packets in the URB, submission fails with a -EXDEV error "
"code."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:284
msgid ""
"For control endpoints, the synchronous usb_control_msg() call is often used "
"(in non-interrupt context) instead of this call. That is often used through "
"convenience wrappers, for the requests that are standardized in the USB 2.0 "
"specification.  For bulk endpoints, a synchronous usb_bulk_msg() call is "
"available."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:291
msgid "Request Queuing:"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:293
msgid ""
"URBs may be submitted to endpoints before previous ones complete, to "
"minimize the impact of interrupt latencies and system overhead on data "
"throughput.  With that queuing policy, an endpoint's queue would never be "
"empty.  This is required for continuous isochronous data streams, and may "
"also be required for some kinds of interrupt transfers. Such queuing also "
"maximizes bandwidth utilization by letting USB controllers start work on "
"later requests before driver software has finished the completion processing "
"for earlier (successful) requests."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:302
msgid ""
"As of Linux 2.6, all USB endpoint transfer queues support depths greater "
"than one.  This was previously a HCD-specific behavior, except for ISO "
"transfers.  Non-isochronous endpoint queues are inactive during cleanup "
"after faults (transfer errors or cancellation)."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:307
msgid "Reserved Bandwidth Transfers:"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:309
msgid ""
"Periodic transfers (interrupt or isochronous) are performed repeatedly, "
"using the interval specified in the urb.  Submitting the first urb to the "
"endpoint reserves the bandwidth necessary to make those transfers. If the "
"USB subsystem can't allocate sufficient bandwidth to perform the periodic "
"request, submitting such a periodic request should fail."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:315
msgid ""
"For devices under xHCI, the bandwidth is reserved at configuration time, or "
"when the alt setting is selected.  If there is not enough bus bandwidth, the "
"configuration/alt setting request will fail.  Therefore, submissions to "
"periodic endpoints on devices under xHCI should never fail due to bandwidth "
"constraints."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:321
msgid ""
"Device drivers must explicitly request that repetition, by ensuring that "
"some URB is always on the endpoint's queue (except possibly for short "
"periods during completion callbacks).  When there is no longer an urb "
"queued, the endpoint's bandwidth reservation is canceled.  This means "
"drivers can use their completion handlers to ensure they keep bandwidth they "
"need, by reinitializing and resubmitting the just-completed urb until the "
"driver longer needs that periodic bandwidth."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:329
msgid "Memory Flags:"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:331
msgid ""
"The general rules for how to decide which mem_flags to use are the same as "
"for kmalloc.  There are four different possible values; GFP_KERNEL, "
"GFP_NOFS, GFP_NOIO and GFP_ATOMIC."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:336
msgid "GFP_NOFS is not ever used, as it has not been implemented yet."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:338
msgid "GFP_ATOMIC is used when"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:339
msgid ""
"you are inside a completion handler, an interrupt, bottom half, tasklet or "
"timer, or"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:341
msgid "you are holding a spinlock or rwlock (does not apply to semaphores), or"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:343
msgid ""
"current->state != TASK_RUNNING, this is the case only after you've changed "
"it."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:346
msgid ""
"GFP_NOIO is used in the block io path and error handling of storage devices."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:349
msgid "All other situations use GFP_KERNEL."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:351
msgid "Some more specific rules for mem_flags can be inferred, such as"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:352
msgid ""
"start_xmit, timeout, and receive methods of network drivers must use "
"GFP_ATOMIC (they are called with a spinlock held);"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:354
msgid ""
"queuecommand methods of scsi drivers must use GFP_ATOMIC (also called with a "
"spinlock held);"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:356
msgid ""
"If you use a kernel thread with a network driver you must use GFP_NOIO, "
"unless (b) or (c) apply;"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:358
msgid ""
"after you have done a down() you can use GFP_KERNEL, unless (b) or (c) apply "
"or your are in a storage driver's block io path;"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:360
msgid ""
"USB probe and disconnect can use GFP_KERNEL unless (b) or (c) apply; and"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:361
msgid ""
"changing firmware on a running storage or net device uses GFP_NOIO, unless "
"b) or c) apply"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:291
msgid "0 on successful submissions. A negative error number otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:594
msgid "abort/cancel a transfer request for an endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:595
msgid "pointer to urb describing a previously submitted request, may be NULL"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:597
msgid ""
"This routine cancels an in-progress request.  URBs complete only once per "
"submission, and may be canceled only once per submission. Successful "
"cancellation means termination of **urb** will be expedited and the "
"completion handler will be called with a status code indicating that the "
"request has been canceled (rather than any other code)."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:604
msgid ""
"Drivers should not call this routine or related routines, such as "
"usb_kill_urb(), after their disconnect method has returned. The disconnect "
"function should synchronize with a driver's I/O routines to insure that all "
"URB-related activity has completed before it returns."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:609
msgid ""
"This request is asynchronous, however the HCD might call the ->complete() "
"callback during unlink. Therefore when drivers call usb_unlink_urb(), they "
"must not hold any locks that may be taken by the completion function. "
"Success is indicated by returning -EINPROGRESS, at which time the URB will "
"probably not yet have been given back to the device driver. When it is "
"eventually called, the completion function will see **urb->status** == -"
"ECONNRESET. Failure is indicated by usb_unlink_urb() returning any other "
"value. Unlinking will fail when **urb** is not currently \"linked\" (i.e., "
"it was never submitted, or it was unlinked before, or the hardware is "
"already finished with it), even if the completion handler has not yet run."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:621
#: drivers/usb/core/urb.c:692 drivers/usb/core/urb.c:739
#: drivers/usb/core/urb.c:788
msgid ""
"The URB must not be deallocated while this routine is running.  In "
"particular, when a driver calls this routine, it must insure that the "
"completion handler cannot deallocate the URB."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:626
msgid "Unlinking and Endpoint Queues:"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:628
msgid ""
"[The behaviors and guarantees described below do not apply to virtual root "
"hubs but only to endpoint queues for physical USB devices.]"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:631
msgid ""
"Host Controller Drivers (HCDs) place all the URBs for a particular endpoint "
"in a queue.  Normally the queue advances as the controller hardware "
"processes each request.  But when an URB terminates with an error its queue "
"generally stops (see below), at least until that URB's completion routine "
"returns.  It is guaranteed that a stopped queue will not restart until all "
"its unlinked URBs have been fully retired, with their completion routines "
"run, even if that's not until some time after the original completion "
"handler returns.  The same behavior and guarantee apply when an URB "
"terminates because it was unlinked."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:641
msgid ""
"Bulk and interrupt endpoint queues are guaranteed to stop whenever an URB "
"terminates with any sort of error, including -ECONNRESET, -ENOENT, and -"
"EREMOTEIO.  Control endpoint queues behave the same way except that they are "
"not guaranteed to stop for -EREMOTEIO errors.  Queues for isochronous "
"endpoints are treated differently, because they must advance at fixed "
"rates.  Such queues do not stop when an URB encounters an error or is "
"unlinked.  An unlinked isochronous URB may leave a gap in the stream of "
"packets; it is undefined whether such gaps can be filled in."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:651
msgid ""
"Note that early termination of an URB because a short packet was received "
"will generate a -EREMOTEIO error if and only if the URB_SHORT_NOT_OK flag is "
"set.  By setting this flag, USB device drivers can build deep queues for "
"large or complex bulk transfers and clean them up reliably after any sort of "
"aborted transfer by unlinking all pending URBs at the first fault."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:658
msgid ""
"When a control URB terminates with an error other than -EREMOTEIO, it is "
"quite likely that the status stage of the transfer will not take place."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:626
msgid "-EINPROGRESS on success. See description for other values on failure."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:678
msgid "cancel a transfer request and wait for it to finish"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:679
#: drivers/usb/core/urb.c:726
msgid "pointer to URB describing a previously submitted request, may be NULL"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:681
msgid ""
"This routine cancels an in-progress request.  It is guaranteed that upon "
"return all completion handlers will have finished and the URB will be "
"totally idle and available for reuse.  These features make this an ideal way "
"to stop I/O in a disconnect() callback or close() function.  If the request "
"has not already finished or been unlinked the completion handler will see "
"urb->status == -ENOENT."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:688
msgid ""
"While the routine is running, attempts to resubmit the URB will fail with "
"error -EPERM.  Thus even if the URB's completion handler always tries to "
"resubmit, it will not succeed and the URB will become idle."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:696
#: drivers/usb/core/urb.c:743
msgid ""
"This routine may not be used in an interrupt context (such as a bottom half "
"or a completion handler), or when holding a spinlock, or in other situations "
"where the caller can't schedule()."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:700
#: drivers/usb/core/urb.c:747 drivers/usb/core/urb.c:809
#: drivers/usb/core/urb.c:847
msgid ""
"This routine should not be called by a driver after its disconnect method "
"has returned."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:725
msgid "reliably kill a transfer and prevent further use of an URB"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:728
msgid ""
"This routine cancels an in-progress request.  It is guaranteed that upon "
"return all completion handlers will have finished and the URB will be "
"totally idle and cannot be reused.  These features make this an ideal way to "
"stop I/O in a disconnect() callback. If the request has not already finished "
"or been unlinked the completion handler will see urb->status == -ENOENT."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:735
msgid ""
"After and while the routine runs, attempts to resubmit the URB will fail "
"with error -EPERM.  Thus even if the URB's completion handler always tries "
"to resubmit, it will not succeed and the URB will become idle."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:782
msgid "reliably prevent further use of an URB"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:783
msgid "pointer to URB to be blocked, may be NULL"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:784
msgid ""
"After the routine has run, attempts to resubmit the URB will fail with error "
"-EPERM.  Thus even if the URB's completion handler always tries to resubmit, "
"it will not succeed and the URB will become idle."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:803
msgid "kill all URBs associated with an anchor"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:804
#: drivers/usb/core/urb.c:842 drivers/usb/core/urb.c:880
msgid "anchor the requests are bound to"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:805
msgid ""
"This kills all outstanding URBs starting from the back of the queue, with "
"guarantee that no completer callbacks will take place from the anchor after "
"this function returns."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:841
msgid "cease all traffic from an anchor"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:843
msgid ""
"this allows all outstanding URBs to be poisoned starting from the back of "
"the queue. Newly added URBs will also be poisoned"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:879
msgid "let an anchor be used successfully again"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:881
msgid ""
"Reverses the effect of usb_poison_anchored_urbs the anchor can be used "
"normally after it returns"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:901
msgid "the anchor you want to suspend wakeups on"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:902
msgid ""
"Call this to stop the last urb being unanchored from waking up any "
"usb_wait_anchor_empty_timeout waiters. This is used in the hcd urb give- "
"back path to delay waking up until after the completion handler has run."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:916
msgid "the anchor you want to resume wakeups on"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:917
msgid ""
"Allow usb_wait_anchor_empty_timeout waiters to be woken up again, and wake "
"up any current waiters if the anchor is empty."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:933
msgid "wait for an anchor to be unused"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:934
msgid "the anchor you want to become unused"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:936
msgid "``unsigned int timeout``"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:935
msgid "how long you are willing to wait in milliseconds"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:936
msgid "Call this is you want to be sure all an anchor's URBs have finished"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:940
msgid "Non-zero if the anchor became unused. Zero on timeout."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:952
msgid "get an anchor's oldest urb"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:953
msgid "the anchor whose urb you want"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:954
msgid "This will take the oldest urb from an anchor, unanchor and return it"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:958
msgid ""
"The oldest urb from **anchor**, or ``NULL`` if **anchor** has no urbs "
"associated with it."
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:983
msgid "unanchor all an anchor's urbs"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:984
msgid "the anchor whose urbs you want to unanchor"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:985
msgid "use this to get rid of all an anchor's urbs"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:1011
msgid "is an anchor empty"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:1012
msgid "the anchor you want to query"
msgstr ""

#: ../../../driver-api/usb/usb:161: drivers/usb/core/urb.c:1014
msgid "1 if the anchor has no urbs associated with it."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:111
msgid "Builds a control urb, sends it off and waits for completion"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:112
#: drivers/usb/core/message.c:168 drivers/usb/core/message.c:227
#: drivers/usb/core/message.c:301 drivers/usb/core/message.c:334
msgid "pointer to the usb device to send the message to"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:113
#: drivers/usb/core/message.c:302 drivers/usb/core/message.c:335
msgid "endpoint \"pipe\" to send the message to"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:115
#: drivers/usb/core/message.c:171 drivers/usb/core/message.c:230
msgid "``__u8 request``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:114
#: drivers/usb/core/message.c:170 drivers/usb/core/message.c:229
msgid "USB message request value"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:116
#: drivers/usb/core/message.c:172 drivers/usb/core/message.c:231
msgid "``__u8 requesttype``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:115
#: drivers/usb/core/message.c:171 drivers/usb/core/message.c:230
msgid "USB message request type value"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:117
#: drivers/usb/core/message.c:173 drivers/usb/core/message.c:232
msgid "``__u16 value``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:116
#: drivers/usb/core/message.c:172 drivers/usb/core/message.c:231
msgid "USB message value"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:118
#: drivers/usb/core/message.c:174 drivers/usb/core/message.c:233
msgid "``__u16 index``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:117
#: drivers/usb/core/message.c:173 drivers/usb/core/message.c:232
msgid "USB message index value"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:118
#: drivers/usb/core/message.c:174 drivers/usb/core/message.c:303
#: drivers/usb/core/message.c:336
msgid "pointer to the data to send"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:120
#: drivers/usb/core/message.c:176 drivers/usb/core/message.c:235
msgid "``__u16 size``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:119
#: drivers/usb/core/message.c:175 drivers/usb/core/message.c:304
#: drivers/usb/core/message.c:337
msgid "length in bytes of the data to send"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:121
#: drivers/usb/core/message.c:177 drivers/usb/core/message.c:236
#: drivers/usb/core/message.c:308 drivers/usb/core/message.c:341
msgid "``int timeout``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:120
#: drivers/usb/core/message.c:176 drivers/usb/core/message.c:235
#: drivers/usb/core/message.c:307 drivers/usb/core/message.c:340
msgid ""
"time in msecs to wait for the message to complete before timing out (if 0 "
"the wait is forever)"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:123
#: drivers/usb/core/message.c:180 drivers/usb/core/message.c:239
#: drivers/usb/core/message.c:310 drivers/usb/core/message.c:343
#: drivers/usb/core/message.c:611 drivers/usb/core/message.c:766
#: drivers/usb/core/message.c:957 drivers/usb/core/message.c:1108
#: drivers/usb/core/message.c:1186 drivers/usb/core/message.c:1493
#: drivers/usb/core/message.c:2273 ../../../driver-api/usb/usb:171:
#: drivers/usb/core/driver.c:1032 drivers/usb/core/driver.c:1104
#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:633
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1720
#: drivers/usb/core/hcd.c:2427 drivers/usb/core/hcd.c:2633
#: drivers/usb/core/hcd.c:2656 drivers/usb/core/hcd.c:3029
#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:162
#: drivers/usb/core/hcd-pci.c:303 ../../../driver-api/usb/usb:212:
#: drivers/usb/core/buffer.c:55 drivers/usb/core/buffer.c:93
msgid "**Context**"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:123
#: drivers/usb/core/message.c:310 drivers/usb/core/message.c:343
#: drivers/usb/core/message.c:611 drivers/usb/core/message.c:766
#: drivers/usb/core/message.c:957 drivers/usb/core/message.c:1108
#: drivers/usb/core/message.c:1186 drivers/usb/core/message.c:1493
#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:633
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2633
#: drivers/usb/core/hcd.c:2656 drivers/usb/core/hcd.c:3029
msgid "task context, might sleep."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:124
msgid ""
"This function sends a simple control message to a specified endpoint and "
"waits for the message to complete, or timeout."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:127
msgid ""
"Don't use this function from within an interrupt context. If you need an "
"asynchronous message, or need to send a message from within interrupt "
"context, use usb_submit_urb(). If a thread in your driver uses this call, "
"make sure your disconnect() method can wait for it to complete. Since you "
"don't have a handle on the URB used, you can't cancel the request."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:134
msgid ""
"If successful, the number of bytes transferred. Otherwise, a negative error "
"number."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:167
msgid ""
"Builds a control \"send\" message, sends it off and waits for completion"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:170
#: drivers/usb/core/message.c:229
msgid "``__u8 endpoint``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:169
#: drivers/usb/core/message.c:228
msgid "endpoint to send the message to"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:175
msgid "``const void *driver_data``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:179
#: drivers/usb/core/message.c:238
msgid "``gfp_t memflags``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:178
#: drivers/usb/core/message.c:237
msgid "the flags for memory allocation for buffers"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:180
#: drivers/usb/core/message.c:239
msgid "!in_interrupt ()"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:181
msgid ""
"This function sends a control message to a specified endpoint that is not "
"expected to fill in a response (i.e. a \"send message\") and waits for the "
"message to complete, or timeout."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:185
#: drivers/usb/core/message.c:244
msgid ""
"Do not use this function from within an interrupt context. If you need an "
"asynchronous message, or need to send a message from within interrupt "
"context, use usb_submit_urb(). If a thread in your driver uses this call, "
"make sure your disconnect() method can wait for it to complete. Since you "
"don't have a handle on the URB used, you can't cancel the request."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:191
msgid ""
"The data pointer can be made to a reference on the stack, or anywhere else, "
"as it will not be modified at all.  This does not have the restriction that "
"usb_control_msg() has where the data pointer must be to dynamically "
"allocated memory (i.e. memory that can be successfully DMAed to a device)."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:197
#: drivers/usb/core/message.c:262
msgid "If successful, 0 is returned, Otherwise, a negative error number."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:226
msgid ""
"Builds a control \"receive\" message, sends it off and waits for completion"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:234
msgid "``void *driver_data``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:233
msgid "pointer to the data to be filled in by the message"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:234
msgid "length in bytes of the data to be received"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:240
msgid ""
"This function sends a control message to a specified endpoint that is "
"expected to fill in a response (i.e. a \"receive message\") and waits for "
"the message to complete, or timeout."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:250
msgid ""
"The data pointer can be made to a reference on the stack, or anywhere else "
"that can be successfully written to.  This function does not have the "
"restriction that usb_control_msg() has where the data pointer must be to "
"dynamically allocated memory (i.e. memory that can be successfully DMAed to "
"a device)."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:256
msgid ""
"The \"whole\" message must be properly received from the device in order for "
"this function to be successful.  If a device returns less than the expected "
"amount of data, then the function will fail.  Do not use this for messages "
"where a variable amount of data might be returned."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:300
msgid "Builds an interrupt urb, sends it off and waits for completion"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:306
#: drivers/usb/core/message.c:339
msgid "``struct usb_device *usb_dev``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:305
#: drivers/usb/core/message.c:338
msgid "``int len``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:306
#: drivers/usb/core/message.c:339
msgid "``int *actual_length``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:305
#: drivers/usb/core/message.c:338
msgid "pointer to a location to put the actual length transferred in bytes"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:311
msgid ""
"This function sends a simple interrupt message to a specified endpoint and "
"waits for the message to complete, or timeout."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:314
#: drivers/usb/core/message.c:347
msgid ""
"Don't use this function from within an interrupt context. If you need an "
"asynchronous message, or need to send a message from within interrupt "
"context, use usb_submit_urb() If a thread in your driver uses this call, "
"make sure your disconnect() method can wait for it to complete. Since you "
"don't have a handle on the URB used, you can't cancel the request."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:321
#: drivers/usb/core/message.c:359
msgid ""
"If successful, 0. Otherwise a negative error number. The number of actual "
"bytes transferred will be stored in the **actual_length** parameter."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:333
msgid "Builds a bulk urb, sends it off and waits for completion"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:344
msgid ""
"This function sends a simple bulk message to a specified endpoint and waits "
"for the message to complete, or timeout."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:353
msgid ""
"Because there is no usb_interrupt_msg() and no USBDEVFS_INTERRUPT ioctl, "
"users are forced to abuse this routine by using it to submit URBs for "
"interrupt endpoints.  We will take the liberty of creating an interrupt URB "
"(with the default interval) if the target is an interrupt endpoint."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:476
msgid "initializes scatterlist-based bulk/interrupt I/O request"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:482
#: drivers/usb/core/message.c:613 drivers/usb/core/message.c:720
msgid "``struct usb_sg_request *io``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:477
msgid ""
"request block being initialized.  until usb_sg_wait() returns, treat this as "
"a pointer to an opaque block of memory,"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:479
msgid "the usb device that will send or receive the data"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:481
msgid "``unsigned pipe``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:480
msgid "endpoint \"pipe\" used to transfer the data"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:482
msgid "``unsigned period``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:481
msgid ""
"polling rate for interrupt endpoints, in frames or (for high speed "
"endpoints) microframes; ignored for bulk"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:484
msgid "``struct scatterlist *sg``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:483
msgid "scatterlist entries"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:485
msgid "``int nents``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:484
msgid "how many entries in the scatterlist"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:486
msgid "``size_t length``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:485
msgid ""
"how many bytes to send from the scatterlist, or zero to send every byte "
"identified in the list."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:487
msgid "SLAB_* flags affecting memory allocations in this call"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:488
msgid ""
"This initializes a scatter/gather request, allocating resources such as I/O "
"mappings and urb memory (except maybe memory used by USB controller drivers)."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:492
msgid ""
"The request must be issued using usb_sg_wait(), which waits for the I/O to "
"complete (or to be canceled) and then cleans up all resources allocated by "
"usb_sg_init()."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:496
msgid ""
"The request may be canceled with usb_sg_cancel(), either before or after "
"usb_sg_wait() is called."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:500
msgid "Zero for success, else a negative errno value."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:607
msgid "synchronously execute scatter/gather request"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:608
msgid ""
"request block handle, as initialized with usb_sg_init(). some fields become "
"accessible when this call returns."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:612
msgid ""
"This function blocks until the specified I/O operation completes.  It "
"leverages the grouping of the related I/O requests to get good transfer "
"rates, by queueing the requests.  At higher speeds, such queuing can "
"significantly improve USB throughput."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:617
msgid "There are three kinds of completion for this function."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:619
msgid ""
"success, where io->status is zero.  The number of io->bytes transferred is "
"as requested."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:621
msgid ""
"error, where io->status is a negative errno value.  The number of io->bytes "
"transferred before the error is usually less than requested, and can be "
"nonzero."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:624
msgid ""
"cancellation, a type of error with status -ECONNRESET that is initiated by "
"usb_sg_cancel()."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:627
msgid ""
"When this function returns, all memory allocated through usb_sg_init() or "
"this call will have been freed.  The request block parameter may still be "
"passed to usb_sg_cancel(), or it may be freed.  It could also be "
"reinitialized and then reused."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:632
msgid "Data Transfer Rates:"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:634
msgid ""
"Bulk transfers are valid for full or high speed endpoints. The best full "
"speed data rate is 19 packets of 64 bytes each per frame, or 1216 bytes per "
"millisecond. The best high speed data rate is 13 packets of 512 bytes each "
"per microframe, or 52 KBytes per millisecond."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:640
msgid ""
"The reason to use interrupt transfers through this API would most likely be "
"to reserve high speed bandwidth, where up to 24 KBytes per millisecond could "
"be transferred.  That capability is less useful for low or full speed "
"interrupt endpoints, which allow at most one packet per millisecond, of at "
"most 8 or 64 bytes (respectively)."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:646
msgid ""
"It is not necessary to call this function to reserve bandwidth for devices "
"under an xHCI host controller, as the bandwidth is reserved when the "
"configuration or interface alt setting is selected."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:714
msgid "stop scatter/gather i/o issued by usb_sg_wait()"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:715
msgid "request block, initialized with usb_sg_init()"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:716
msgid ""
"This stops a request after it has been started by usb_sg_wait(). It can also "
"prevents one initialized by usb_sg_init() from starting, so that call just "
"frees resources allocated to the request."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:759
msgid "issues a generic GET_DESCRIPTOR request"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:760
msgid "the device whose descriptor is being retrieved"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:762
msgid "``unsigned char type``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:761
msgid "the descriptor type (USB_DT_*)"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:763
msgid "``unsigned char index``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:762
#: drivers/usb/core/message.c:953
msgid "the number of the descriptor"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:764
msgid "``void *buf``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:763
msgid "where to put the descriptor"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:765
msgid "``int size``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:767
msgid ""
"Gets a USB descriptor.  Convenience functions exist to simplify getting some "
"types of descriptors.  Use usb_get_string() or usb_string() for "
"USB_DT_STRING. Device (USB_DT_DEVICE) and configuration descriptors "
"(USB_DT_CONFIG) are part of the device structure. In addition to a number of "
"USB-standard descriptors, some devices also use class-specific or vendor-"
"specific descriptors."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:775
#: drivers/usb/core/message.c:963 drivers/usb/core/message.c:1118
msgid "This call is synchronous, and may not be used in an interrupt context."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:778
msgid ""
"The number of bytes received on success, or else the status code returned by "
"the underlying usb_control_msg() call."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:951
msgid "returns UTF-8 version of a string descriptor"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:952
msgid "the device whose string descriptor is being retrieved"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:954
#: drivers/usb/core/message.c:1015
msgid "``int index``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:958
msgid ""
"This converts the UTF-16LE encoded strings returned by devices, from "
"usb_get_string_descriptor(), to null-terminated UTF-8 encoded ones that are "
"more usable in most kernel contexts.  Note that this function chooses "
"strings in the first language supported by the device."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:966
msgid "length of the string (>= 0) or usb_control_msg status (< 0)."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1012
msgid "read a string descriptor and cache it for later use"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1018
#: drivers/usb/core/message.c:2275 ../../../driver-api/usb/usb:171:
#: drivers/usb/core/driver.c:1685 drivers/usb/core/driver.c:1701
#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:885
#: drivers/usb/core/usb.c:1121 drivers/usb/core/usb.c:1152
#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:2172
#: drivers/usb/core/hub.c:6329
msgid "``struct usb_device *udev``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1013
msgid "the device whose string descriptor is being read"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1014
msgid "the descriptor index"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1016
msgid ""
"A pointer to a kmalloc'ed buffer containing the descriptor string, or "
"``NULL`` if the index is 0 or the string could not be read."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1101
msgid "issues a GET_STATUS call"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1102
msgid "the device whose status is being checked"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1104
msgid "``int recip``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1103
msgid "USB_RECIP_*; for device, interface, or endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1105
msgid "``int type``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1104
msgid "USB_STATUS_TYPE_*; for standard or PTM status types"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1106
msgid "``int target``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1105
msgid "zero (for device), else interface or endpoint number"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1106
msgid "pointer to two bytes of bitmap data"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1109
msgid ""
"Returns device, interface, or endpoint status.  Normally only of interest to "
"see if the device is self powered, or has enabled the remote wakeup "
"facility; or whether a bulk or interrupt endpoint is halted (\"stalled\")."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1114
msgid ""
"Bits in these status bitmaps are set using the SET_FEATURE request, and "
"cleared using the CLEAR_FEATURE request.  The usb_clear_halt() function "
"should be used to clear halt (\"stall\") status."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1120
msgid ""
"Returns 0 and the status value in ***data** (in host byte order) on success, "
"or else the status code from the underlying usb_control_msg() call."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1182
msgid "tells device to clear endpoint halt/stall condition"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1183
msgid "device whose endpoint is halted"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1185
msgid "``int pipe``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1184
msgid "endpoint \"pipe\" being cleared"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1187
msgid ""
"This is used to clear halt conditions for bulk and interrupt endpoints, as "
"reported by URB completion status.  Endpoints that are halted are sometimes "
"referred to as being \"stalled\".  Such endpoints are unable to transmit or "
"receive data until the halt status is cleared.  Any URBs queued for such an "
"endpoint should normally be unlinked by the driver before clearing the halt "
"condition, as described in sections 5.7.5 and 5.8.5 of the USB 2.0 spec."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1195
msgid ""
"Note that control and isochronous endpoints don't halt, although control "
"endpoints report \"protocol stall\" (for unsupported requests) using the "
"same status code used to report a true stall."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1199
msgid ""
"This call is synchronous, and may not be used in an interrupt context. If a "
"thread in your driver uses this call, make sure your disconnect() method can "
"wait for it to complete."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1204
#: drivers/usb/core/message.c:1524
msgid ""
"Zero on success, or else the status code returned by the underlying "
"usb_control_msg() call."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1309
msgid "Reset an endpoint's state."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1310
msgid "the device whose endpoint is to be reset"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1312
msgid "``unsigned int epaddr``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1311
msgid ""
"the endpoint's address.  Endpoint number for output, endpoint number + "
"USB_DIR_IN for input"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1313
msgid ""
"Resets any host-side endpoint state such as the toggle bit, sequence number "
"or current window."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1488
msgid "Makes a particular alternate setting be current"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1489
msgid "the device whose interface is being updated"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1491
msgid "``int interface``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1490
msgid "the interface being updated"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1492
msgid "``int alternate``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1491
msgid "the setting being chosen."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1494
msgid ""
"This is used to enable data transfers on interfaces that may not be enabled "
"by default.  Not all devices support such configurability. Only the driver "
"bound to an interface may change its setting."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1498
msgid ""
"Within any given configuration, each interface may have several alternative "
"settings.  These are often used to control levels of bandwidth consumption.  "
"For example, the default setting for a high speed interrupt endpoint may not "
"send more than 64 bytes per microframe, while interrupt transfers of up to "
"3KBytes per microframe are legal. Also, isochronous endpoints may never be "
"part of an interface's default setting.  To access such bandwidth, alternate "
"interface settings must be made current."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1507
msgid ""
"Note that in the Linux USB subsystem, bandwidth associated with an endpoint "
"in a given alternate setting is not reserved until an URB is submitted that "
"needs that bandwidth.  Some other operating systems allocate bandwidth "
"early, when a configuration is chosen."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1512
msgid ""
"xHCI reserves bandwidth and configures the alternate setting in "
"usb_hcd_alloc_bandwidth(). If it fails the original interface altsetting may "
"be disabled. Drivers cannot rely on any particular alternate setting being "
"in effect after a failure."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1517
msgid ""
"This call is synchronous, and may not be used in an interrupt context. Also, "
"drivers must not change altsettings while urbs are scheduled for endpoints "
"in that interface; all such urbs must first be completed (perhaps forced by "
"unlinking). If a thread in your driver uses this call, make sure your "
"disconnect() method can wait for it to complete."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1668
msgid "lightweight device reset"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1669
msgid "the device whose configuration is being reset"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1670
msgid ""
"This issues a standard SET_CONFIGURATION request to the device using the "
"current configuration.  The effect is to reset most USB-related state in the "
"device, including interface altsettings (reset to zero), endpoint halts "
"(cleared), and endpoint state (only for bulk and interrupt endpoints).  "
"Other usbcore state is unchanged, including bindings of usb device drivers "
"to interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1677
msgid ""
"Because this affects multiple interfaces, avoid using this with composite "
"(multi-interface) devices.  Instead, the driver for each interface may use "
"usb_set_interface() on the interfaces it claims.  Be careful though; some "
"devices don't support the SET_INTERFACE request, and others won't reset all "
"the interface state (notably endpoint state).  Resetting the whole "
"configuration would affect other drivers' interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1684
msgid "The caller must own the device lock."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1687
msgid ""
"If this routine fails the device will probably be in an unusable state with "
"endpoints disabled, and interfaces only partially enabled."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1687
msgid "Zero on success, else a negative error code."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1927
msgid "sets the wireless_status struct member"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1928
msgid "the interface to modify"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1930
msgid "``enum usb_wireless_status status``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1929
msgid "the new wireless status"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1930
msgid ""
"Set the wireless_status struct member to the new value, and emit sysfs "
"changes as necessary."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:1934
msgid "0 on success, -EALREADY if already set."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2269
msgid "Provide a way for drivers to change device configurations"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2270
msgid "the device whose configuration is being updated"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2272
msgid "``int config``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2271
msgid "the configuration being chosen."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2272
msgid "In process context, must be able to sleep"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2273
msgid ""
"Device interface drivers are not allowed to change device configurations. "
"This is because changing configurations will destroy the interface the "
"driver is bound to and create new ones; it would be like a floppy-disk "
"driver telling the computer to replace the floppy-disk drive with a tape "
"drive!"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2279
msgid ""
"Still, in certain specialized circumstances the need may arise.  This "
"routine gets around the normal restrictions by using a work thread to submit "
"the change-config request."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2284
msgid ""
"0 if the request was successfully queued, error code otherwise. The caller "
"has no way to know whether the queued request will eventually succeed."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2310
msgid "parse the extra headers present in CDC devices"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2316
msgid "``struct usb_cdc_parsed_header *hdr``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2311
msgid "the place to put the results of the parsing"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2312
msgid "the interface for which parsing is requested"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2314
msgid "``u8 *buffer``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2313
msgid "pointer to the extra headers to be parsed"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2315
msgid "``int buflen``"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2314
msgid "length of the extra headers"
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2315
msgid ""
"This evaluates the extra headers present in CDC devices which bind the "
"interfaces for data and control and provide details about the capabilities "
"of the device."
msgstr ""

#: ../../../driver-api/usb/usb:165: drivers/usb/core/message.c:2320
msgid ""
"number of descriptors parsed or -EINVAL if the header is contradictory "
"beyond salvage"
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:92
msgid "register a USB device, and ask for a minor number"
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:93
msgid "pointer to the usb_interface that is being registered"
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:95
#: drivers/usb/core/file.c:167
msgid "``struct usb_class_driver *class_driver``"
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:94
#: drivers/usb/core/file.c:166
msgid "pointer to the usb_class_driver for this device"
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:95
msgid ""
"This should be called by all USB drivers that use the USB major number. If "
"CONFIG_USB_DYNAMIC_MINORS is enabled, the minor number will be dynamically "
"allocated out of the list of available ones.  If it is not enabled, the "
"minor number will be based on the next available free minor, starting at the "
"class_driver->minor_base."
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:101
msgid "This function also creates a usb class device in the sysfs tree."
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:103
msgid ""
"usb_deregister_dev() must be called when the driver is done with the minor "
"numbers given out by this function."
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:107
msgid ""
"-EINVAL if something bad happens with trying to register a device, and 0 on "
"success."
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:164
msgid "deregister a USB device's dynamic minor."
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:165
msgid "pointer to the usb_interface that is being deregistered"
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:167
msgid ""
"Used in conjunction with usb_register_dev().  This function is called when "
"the USB driver is finished with the minor numbers gotten from a call to "
"usb_register_dev() (usually when the device is disconnected from the system.)"
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:172
msgid "This function also removes the usb class device from the sysfs tree."
msgstr ""

#: ../../../driver-api/usb/usb:168: drivers/usb/core/file.c:174
msgid "This should be called by all drivers that use the USB major number."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:531
msgid "bind a driver to an interface"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:537
#: drivers/usb/core/driver.c:615 drivers/usb/core/driver.c:1107
msgid "``struct usb_driver *driver``"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:532
msgid "the driver to be bound"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:533
msgid ""
"the interface to which it will be bound; must be in the usb device's active "
"configuration"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:535
msgid "driver data associated with that interface"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:536
msgid ""
"This is used by usb device drivers that need to claim more than one "
"interface on a device when probing (audio and acm are current examples). No "
"device driver should directly modify internal usb_interface or usb_device "
"structure members."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:541
msgid ""
"Callers must own the device lock, so driver probe() entries don't need extra "
"locking, but other call contexts may need to explicitly claim that lock."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:546
#: drivers/usb/core/driver.c:1858
msgid "0 on success."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:609
msgid "unbind a driver from an interface"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:610
msgid "the driver to be unbound"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:611
msgid "the interface from which it will be unbound"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:612
msgid ""
"This can be used by drivers to release an interface without waiting for "
"their disconnect() methods to be called.  In typical cases this also causes "
"the driver disconnect() method to be called."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:616
msgid ""
"This call is synchronous, and may not be used in an interrupt context. "
"Callers must own the device lock, so driver disconnect() entries don't need "
"extra locking, but other call contexts may need to explicitly claim that "
"lock."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:743
msgid "find first usb_device_id matching device or interface"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:749
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2019
#: drivers/usb/core/hcd.c:2072
msgid "``struct usb_interface *interface``"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:744
msgid "the interface of interest"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:746
msgid "``const struct usb_device_id *id``"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:745
msgid "array of usb_device_id structures, terminated by zero entry"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:746
msgid ""
"usb_match_id searches an array of usb_device_id's and returns the first one "
"matching the device or interface, or null. This is used when binding (or "
"rebinding) a driver to an interface. Most USB device drivers will use this "
"indirectly, through the usb core, but some layered driver frameworks use it "
"directly. These device tables are exported with MODULE_DEVICE_TABLE, through "
"modutils, to support the driver loading functionality of USB hotplugging."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:755
msgid "What Matches:"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:757
msgid ""
"The \"match_flags\" element in a usb_device_id controls which members are "
"used.  If the corresponding bit is set, the value in the device_id must "
"match its corresponding member in the device or interface descriptor, or "
"else the device_id does not match."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:763
msgid ""
"\"driver_info\" is normally used only by device drivers, but you can create "
"a wildcard \"matches anything\" usb_device_id as a driver's \"modules."
"usbmap\" entry if you provide an id with only a nonzero \"driver_info\" "
"field.  If you do this, the USB device driver's probe() routine should use "
"additional intelligence to decide whether to bind to the specified interface."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:770
msgid "What Makes Good usb_device_id Tables:"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:772
msgid ""
"The match algorithm is very simple, so that intelligence in driver selection "
"must come from smart driver id records. Unless you have good reasons to use "
"another selection policy, provide match elements only in related groups, and "
"order match specifiers from specific to general.  Use the macros provided "
"for that purpose if you can."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:779
msgid ""
"The most specific match specifiers use device descriptor data.  These are "
"commonly used with product-specific matches; the USB_DEVICE macro lets you "
"provide vendor and product IDs, and you can also match against ranges of "
"product revisions. These are widely used for devices with application or "
"vendor specific bDeviceClass values."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:786
msgid ""
"Matches based on device class/subclass/protocol specifications are slightly "
"more general; use the USB_DEVICE_INFO macro, or its siblings.  These are "
"used with single-function devices where bDeviceClass doesn't specify that "
"each interface has its own class."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:792
msgid ""
"Matches based on interface class/subclass/protocol are the most general; "
"they let drivers bind to any interface on a multiple-function device.  Use "
"the USB_INTERFACE_INFO macro, or its siblings, to match class-per-interface "
"style devices (as recorded in bInterfaceClass)."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:798
msgid ""
"Note that an entry created by USB_INTERFACE_INFO won't match any interface "
"if the device class is set to Vendor-Specific. This is deliberate; according "
"to the USB spec the meanings of the interface class/subclass/protocol for "
"these devices are also vendor-specific, and hence matching against a "
"standard product class wouldn't work anyway.  If you really want to use an "
"interface-based match for such a device, create a match record that also "
"specifies the vendor ID.  (Unforunately there isn't a standard macro for "
"creating records like this.)"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:808
msgid ""
"Within those groups, remember that not all combinations are meaningful.  For "
"example, don't give a product version range without vendor and product IDs; "
"or specify a protocol without its associated class and subclass."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:755
msgid "The first matching usb_device_id, or ``NULL``."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:983
msgid "register a USB device (not interface) driver"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:989
msgid "``struct usb_device_driver *new_udriver``"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:984
msgid "USB operations for the device driver"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:986
#: drivers/usb/core/driver.c:1048
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:985
#: drivers/usb/core/driver.c:1047
msgid "module owner of this driver."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:986
msgid ""
"Registers a USB device driver with the USB core.  The list of unattached "
"devices will be rescanned whenever a new driver is added, allowing the new "
"driver to attach to any recognized devices."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:991
#: drivers/usb/core/driver.c:1054
msgid "A negative error code on failure and 0 on success."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1029
msgid "unregister a USB device (not interface) driver"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1035
msgid "``struct usb_device_driver *udriver``"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1030
msgid "USB operations of the device driver to unregister"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1031
#: drivers/usb/core/driver.c:1103
msgid "must be able to sleep"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1032
#: drivers/usb/core/driver.c:1104
msgid "Unlinks the specified driver from the internal USB driver list."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1045
msgid "register a USB interface driver"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1051
msgid "``struct usb_driver *new_driver``"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1046
msgid "USB operations for the interface driver"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1049
msgid "``const char *mod_name``"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1048
msgid "module name string"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1049
msgid ""
"Registers a USB interface driver with the USB core.  The list of unattached "
"interfaces will be rescanned whenever a new driver is added, allowing the "
"new driver to attach to any recognized interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1056
#: drivers/usb/core/driver.c:1106
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1056
msgid ""
"if you want your driver to use the USB major number, you must call "
"usb_register_dev() to enable that functionality.  This function no longer "
"takes care of that."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1101
msgid "unregister a USB interface driver"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1102
msgid "USB operations of the interface driver to unregister"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1107
msgid ""
"If you called usb_register_dev(), you still need to call "
"usb_deregister_dev() to clean up your driver's allocated minor numbers, this "
"* call will no longer do it for you."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1679
msgid "allow a USB device to be autosuspended"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1680
msgid "the USB device which may be autosuspended"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1681
msgid ""
"This routine allows **udev** to be autosuspended.  An autosuspend won't take "
"place until the autosuspend_delay has elapsed and all the other necessary "
"conditions are satisfied."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1685
#: drivers/usb/core/driver.c:1700
msgid "The caller must hold **udev**'s device lock."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1695
msgid "prevent a USB device from being autosuspended"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1696
msgid "the USB device which may not be autosuspended"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1697
msgid ""
"This routine prevents **udev** from being autosuspended and wakes it up if "
"it is already autosuspended."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1768
#: drivers/usb/core/driver.c:1796 drivers/usb/core/driver.c:1824
msgid "decrement a USB interface's PM-usage counter"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1769
#: drivers/usb/core/driver.c:1797 drivers/usb/core/driver.c:1825
msgid "the usb_interface whose counter should be decremented"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1770
msgid ""
"This routine should be called by an interface driver when it is finished "
"using **intf** and wants to allow it to autosuspend.  A typical example "
"would be a character-device driver when its device file is closed."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1775
msgid ""
"The routine decrements **intf**'s usage counter.  When the counter reaches "
"0, a delayed autosuspend request for **intf**'s device is attempted.  The "
"attempt may fail (see autosuspend_check())."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1779
#: drivers/usb/core/driver.c:1855
msgid "This routine can run only in process context."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1798
msgid ""
"This routine does much the same thing as usb_autopm_put_interface(): It "
"decrements **intf**'s usage counter and schedules a delayed autosuspend "
"request if the counter is <= 0.  The difference is that it does not perform "
"any synchronization; callers should hold a private lock and handle all "
"synchronization issues themselves."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1804
msgid ""
"Typically a driver would call this routine during an URB's completion "
"handler, if no more URBs were pending."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1807
#: drivers/usb/core/driver.c:1829 drivers/usb/core/driver.c:1884
#: drivers/usb/core/driver.c:1911
msgid "This routine can run in atomic context."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1826
msgid ""
"This routine decrements **intf**'s usage counter but does not carry out an "
"autosuspend."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1842
#: drivers/usb/core/driver.c:1873 drivers/usb/core/driver.c:1906
msgid "increment a USB interface's PM-usage counter"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1843
#: drivers/usb/core/driver.c:1874 drivers/usb/core/driver.c:1907
msgid "the usb_interface whose counter should be incremented"
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1844
msgid ""
"This routine should be called by an interface driver when it wants to use "
"**intf** and needs to guarantee that it is not suspended.  In addition, the "
"routine prevents **intf** from being autosuspended subsequently.  (Note that "
"this will not prevent suspend events originating in the PM core.) This "
"prevention will persist until usb_autopm_put_interface() is called or "
"**intf** is unbound.  A typical example would be a character-device driver "
"when its device file is opened."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1852
msgid ""
"**intf**'s usage counter is incremented to prevent subsequent autosuspends. "
"However if the autoresume fails then the counter is re-decremented."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1875
msgid ""
"This routine does much the same thing as usb_autopm_get_interface(): It "
"increments **intf**'s usage counter and queues an autoresume request if the "
"device is suspended.  The differences are that it does not perform any "
"synchronization (callers should hold a private lock and handle all "
"synchronization issues themselves), and it does not autoresume the device "
"directly (it only queues a request).  After a successful call, the device "
"may not yet be resumed."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1887
msgid "0 on success. A negative error code otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:171: drivers/usb/core/driver.c:1908
msgid ""
"This routine increments **intf**'s usage counter but does not carry out an "
"autoresume."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:119
#: drivers/usb/core/usb.c:165
msgid "look up common endpoint descriptors"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:125
#: drivers/usb/core/usb.c:171
msgid "``struct usb_host_interface *alt``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:120
#: drivers/usb/core/usb.c:166
msgid "alternate setting to search"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:122
#: drivers/usb/core/usb.c:168
msgid "``struct usb_endpoint_descriptor **bulk_in``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:121
#: drivers/usb/core/usb.c:122 drivers/usb/core/usb.c:123
#: drivers/usb/core/usb.c:124 drivers/usb/core/usb.c:167
#: drivers/usb/core/usb.c:168 drivers/usb/core/usb.c:169
#: drivers/usb/core/usb.c:170
msgid "pointer to descriptor pointer, or NULL"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:123
#: drivers/usb/core/usb.c:169
msgid "``struct usb_endpoint_descriptor **bulk_out``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:124
#: drivers/usb/core/usb.c:170
msgid "``struct usb_endpoint_descriptor **int_in``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:125
#: drivers/usb/core/usb.c:171
msgid "``struct usb_endpoint_descriptor **int_out``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:125
msgid ""
"Search the alternate setting's endpoint descriptors for the first bulk-in, "
"bulk-out, interrupt-in and interrupt-out endpoints and return them in the "
"provided pointers (unless they are NULL)."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:129
#: drivers/usb/core/usb.c:175
msgid ""
"If a requested endpoint is not found, the corresponding pointer is set to "
"NULL."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:133
#: drivers/usb/core/usb.c:179
msgid "Zero if all requested descriptors were found, or -ENXIO otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:171
msgid ""
"Search the alternate setting's endpoint descriptors for the last bulk-in, "
"bulk-out, interrupt-in and interrupt-out endpoints and return them in the "
"provided pointers (unless they are NULL)."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:236
msgid ""
"Check whether an interface's current altsetting contains a set of bulk "
"endpoints with the given addresses."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:242
#: drivers/usb/core/usb.c:267 drivers/usb/core/usb.c:372
msgid "``const struct usb_interface *intf``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:238
#: drivers/usb/core/usb.c:263
msgid "the interface whose current altsetting should be searched"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:240
#: drivers/usb/core/usb.c:265
msgid "``const u8 *ep_addrs``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:239
#: drivers/usb/core/usb.c:264
msgid ""
"0-terminated array of the endpoint addresses (number and direction) to look "
"for"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:241
#: drivers/usb/core/usb.c:266
msgid ""
"Search for endpoints with the specified addresses and check their types."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:244
msgid ""
"``true`` if all the endpoints are found and are bulk, ``false`` otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:261
msgid ""
"Check whether an interface's current altsetting contains a set of interrupt "
"endpoints with the given addresses."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:269
msgid ""
"``true`` if all the endpoints are found and are interrupt, ``false`` "
"otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:287
msgid ""
"Given a configuration, find the alternate setting for the given interface."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:293
msgid "``struct usb_host_config *config``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:289
msgid "the configuration to search (not necessarily the current config)."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:291
msgid "``unsigned int iface_num``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:290
msgid "interface number to search in"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:292
msgid "``unsigned int alt_num``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:291
msgid "alternate interface setting number to search for."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:292
msgid "Search the configuration's interface cache for the given alt setting."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:295
msgid "The alternate setting, if found. ``NULL`` otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:328
msgid "get the interface object with a given interface number"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:334
msgid "``const struct usb_device *dev``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:329
msgid "the device whose current configuration is considered"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:331
msgid "``unsigned ifnum``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:330
msgid "the desired interface"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:331
msgid ""
"This walks the device descriptor for the currently active configuration to "
"find the interface object with the particular interface number."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:334
msgid ""
"Note that configuration descriptors are not required to assign interface "
"numbers sequentially, so that it would be incorrect to assume that the first "
"interface in that descriptor corresponds to interface zero. This routine "
"helps device drivers avoid such mistakes. However, you should make sure that "
"you do the right thing with any alternate settings available for this "
"interfaces."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:341
msgid ""
"Don't call this function unless you are bound to one of the interfaces on "
"this device or you have locked the device!"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:345
msgid ""
"A pointer to the interface that has **ifnum** as interface number, if found. "
"``NULL`` otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:366
msgid "get the altsetting structure with a given alternate setting number."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:367
msgid "the interface containing the altsetting in question"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:369
msgid "``unsigned int altnum``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:368
msgid "the desired alternate setting number"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:369
msgid ""
"This searches the altsetting array of the specified interface for an entry "
"with the correct bAlternateSetting value."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:372
msgid ""
"Note that altsettings need not be stored sequentially by number, so it would "
"be incorrect to assume that the first altsetting entry in the array "
"corresponds to altsetting zero.  This routine helps device drivers avoid "
"such mistakes."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:377
msgid ""
"Don't call this function unless you are bound to the intf interface or you "
"have locked the device!"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:381
msgid ""
"A pointer to the entry of the altsetting array of **intf** that has "
"**altnum** as the alternate setting number. ``NULL`` if not found."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:418
msgid "find usb_interface pointer for driver and device"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:424
msgid "``struct usb_driver *drv``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:419
msgid "the driver whose current configuration is considered"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:421
msgid "``int minor``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:420
msgid "the minor number of the desired device"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:421
msgid ""
"This walks the bus device list and returns a pointer to the interface with "
"the matching minor and driver.  Note, this only works for devices that share "
"the USB major number."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:426
msgid "A pointer to the interface with the matching major and **minor**."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:462
msgid "iterate over all USB devices in the system"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:463
msgid "data pointer that will be handed to the callback function"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:465
msgid "``int (*fn)(struct usb_device *, void *)``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:464
msgid "callback function to be called for each USB device"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:465
msgid ""
"Iterate over all USB devices and call **fn** for each, passing it **data**. "
"If it returns anything other than 0, we break the iteration prematurely and "
"return that value."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:628
msgid "usb device constructor (usbcore-internal)"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:634
msgid "``struct usb_device *parent``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:629
msgid "hub to which device is connected; null to allocate a root hub"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:631
#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2429
msgid "``struct usb_bus *bus``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:630
msgid "bus used to access the device"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:632
msgid "``unsigned port1``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:631
msgid "one-based index of port; ignored for root hubs"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:634
msgid ""
"Only hub drivers (including virtual root hub drivers for host controllers) "
"should ever call this."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:637
msgid "This call may not be used in a non-sleeping context."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:640
msgid "On success, a pointer to the allocated usb device. ``NULL`` on failure."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:754
msgid "increments the reference count of the usb device structure"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:755
msgid "the device being referenced"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:756
msgid "Each live reference to a device should be refcounted."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:758
msgid ""
"Drivers for USB interfaces should normally record such references in their "
"probe() methods, when they bind to an interface, and release them by calling "
"usb_put_dev(), in their disconnect() methods. However, if a driver does not "
"access the usb_device structure after its disconnect() method returns then "
"refcounting is not necessary, because the USB core guarantees that a "
"usb_device will not be deallocated until after all of its interface drivers "
"have been unbound."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:767
msgid "A pointer to the device with the incremented reference counter."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:778
msgid "release a use of the usb device structure"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:779
msgid "device that's been disconnected"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:780
msgid ""
"Must be called when a user of a device is finished with it.  When the last "
"user of the device calls this function, the memory of the device is freed."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:792
msgid "increments the reference count of the usb interface structure"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:793
msgid "the interface being referenced"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:794
msgid "Each live reference to a interface must be refcounted."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:796
msgid ""
"Drivers for USB interfaces should normally record such references in their "
"probe() methods, when they bind to an interface, and release them by calling "
"usb_put_intf(), in their disconnect() methods. However, if a driver does not "
"access the usb_interface structure after its disconnect() method returns "
"then refcounting is not necessary, because the USB core guarantees that a "
"usb_interface will not be deallocated until after its driver has been "
"unbound."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:805
msgid "A pointer to the interface with the incremented reference counter."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:816
msgid "release a use of the usb interface structure"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:817
msgid "interface that's been decremented"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:818
msgid ""
"Must be called when a user of an interface is finished with it.  When the "
"last user of the interface calls this function, the memory of the interface "
"is freed."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:831
msgid "acquire a reference on the usb interface's DMA endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:832
msgid "the usb interface"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:833
msgid ""
"While a USB device cannot perform DMA operations by itself, many USB "
"controllers can. A call to usb_intf_get_dma_device() returns the DMA "
"endpoint for the given USB interface, if any. The returned device structure "
"must be released with put_device()."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:838
msgid "See also usb_get_dma_device()."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:841
msgid ""
"A reference to the usb interface's DMA endpoint; or NULL if none exists."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:879
msgid "cautiously acquire the lock for a usb device structure"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:880
msgid "device that's being locked"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:882
msgid "``const struct usb_interface *iface``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:881
msgid "interface bound to the driver making the request (optional)"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:882
msgid ""
"Attempts to acquire the device lock, but fails if the device is NOTATTACHED "
"or SUSPENDED, or if iface is specified and the interface is neither BINDING "
"nor BOUND.  Rather than sleeping to wait for the lock, the routine polls "
"repeatedly.  This is to prevent deadlock with disconnect; in some drivers "
"(such as usb-storage) the disconnect() or suspend() method will block "
"waiting for a device reset to complete."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:890
msgid "A negative error code for failure, otherwise 0."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:926
msgid "return current bus frame number"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:927
msgid "the device whose bus is being queried"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:929
msgid ""
"The current frame number for the USB host controller used with the given USB "
"device. This can be used when scheduling isochronous requests."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:933
msgid ""
"Different kinds of host controller have different \"scheduling horizons\". "
"While one type might support scheduling only 32 frames into the future, "
"others could support scheduling up to 1024 frames into the future."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:981
msgid "allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:982
#: drivers/usb/core/usb.c:1036
msgid "device the buffer will be used with"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:983
#: drivers/usb/core/usb.c:1015 drivers/usb/core/usb.c:1037
#: drivers/usb/core/usb.c:1088
msgid "requested buffer size"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:984
#: drivers/usb/core/usb.c:1038
msgid "affect whether allocation may block"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:986
#: drivers/usb/core/usb.c:1040
msgid "``dma_addr_t *dma``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:985
#: drivers/usb/core/usb.c:1039
msgid "used to return DMA address of buffer"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:987
#: drivers/usb/core/usb.c:1049
msgid ""
"Either null (indicating no buffer could be allocated), or the cpu-space "
"pointer to a buffer that may be used to perform DMA to the specified "
"device.  Such cpu-space buffers are returned along with the DMA address "
"(through the pointer provided)."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:992
msgid ""
"These buffers are used with URB_NO_xxx_DMA_MAP set in urb->transfer_flags to "
"avoid behaviors like using \"DMA bounce buffers\", or thrashing IOMMU "
"hardware during URB completion/resubmit.  The implementation varies between "
"platforms, depending on details of how DMA will work to this device. Using "
"these buffers also eliminates cacheline sharing problems on architectures "
"where CPU caches are not DMA-coherent.  On systems without bus-snooping "
"caches, these buffers are uncached."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1000
msgid "When the buffer is no longer used, free it with usb_free_coherent()."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1013
msgid "free memory allocated with usb_alloc_coherent()"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1014
#: drivers/usb/core/usb.c:1087
msgid "device the buffer was used with"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1017
#: drivers/usb/core/usb.c:1090
msgid "``void *addr``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1016
#: drivers/usb/core/usb.c:1089
msgid "CPU address of buffer"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1018
msgid "``dma_addr_t dma``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1017
msgid "DMA address of buffer"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1018
msgid ""
"This reclaims an I/O buffer, letting it be reused.  The memory must have "
"been allocated using usb_alloc_coherent(), and the parameters must match "
"those provided in that allocation request."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1035
msgid "allocate dma-noncoherent buffer for URB_NO_xxx_DMA_MAP"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1041
#: drivers/usb/core/usb.c:1091
msgid "``enum dma_data_direction dir``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1040
#: drivers/usb/core/usb.c:1090
msgid "DMA transfer direction"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1042
msgid "``struct sg_table **table``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1041
msgid "used to return sg_table of allocated memory"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1042
msgid ""
"To explicit manage the memory ownership for the kernel vs the device by USB "
"core, the user needs save sg_table to urb->sgt. Then USB core will do DMA "
"sync for CPU and device properly."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1046
msgid "When the buffer is no longer used, free it with usb_free_noncoherent()."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1086
msgid "free memory allocated with usb_alloc_noncoherent()"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1092
msgid "``struct sg_table *table``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1091
msgid "describe the allocated and DMA mapped memory,"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1092
msgid ""
"This reclaims an I/O buffer, letting it be reused.  The memory must have "
"been allocated using usb_alloc_noncoherent(), and the parameters must match "
"those provided in that allocation request."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1115
msgid "Get maximum payload bytes per service interval"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1117
#: drivers/usb/core/usb.c:1148
msgid "The USB device"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1119
#: drivers/usb/core/usb.c:1150
msgid "``const struct usb_host_endpoint *ep``"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1118
#: drivers/usb/core/usb.c:1149
msgid "The endpoint"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1120
msgid ""
"the maximum number of bytes isochronous or interrupt endpoint **ep** can "
"transfer during a service interval, or 0 for other endpoints."
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1146
msgid "Tell whether an endpoint uses USB 2 Isochronous Double IN Bandwidth"
msgstr ""

#: ../../../driver-api/usb/usb:174: drivers/usb/core/usb.c:1151
msgid ""
"true if an endpoint **ep** conforms to USB 2 Isochronous Double IN Bandwidth "
"ECN, false otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:911
msgid "clear control/bulk TT state in high speed hub"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:912
msgid "an URB associated with the failed or incomplete split transaction"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:913
msgid ""
"High speed HCDs use this to tell the hub driver that some split control or "
"bulk transaction failed in a way that requires clearing internal state of a "
"transaction translator.  This is normally detected (and reported) from "
"interrupt context."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:918
msgid ""
"It may not be possible for that hub to handle additional full (or low) speed "
"transactions until that state is fully cleared out."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:922
msgid "0 if successful. A negative error code otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:2166
msgid "change a device's current state (usbcore, hcds)"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:2167
msgid "pointer to device whose state should be changed"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:2169
msgid "``enum usb_device_state new_state``"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:2168
msgid "new state value to be stored"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:2169
msgid ""
"udev->state is _not_ fully protected by the device lock.  Although most "
"transitions are made only while holding the lock, the state can can change "
"to USB_STATE_NOTATTACHED at almost any time.  This is so that devices can be "
"marked as disconnected as soon as possible, without having to wait for any "
"semaphores to be released.  As a result, all changes to any device's state "
"must be protected by the device_state_lock spinlock."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:2177
msgid ""
"Once a device has been added to the device tree, all changes to its state "
"should be made using this routine.  The state should _not_ be set directly."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:2180
msgid ""
"If udev->state is already USB_STATE_NOTATTACHED then no change is made. "
"Otherwise udev->state is set to new_state, and if new_state is "
"USB_STATE_NOTATTACHED then all of udev's descendants' states are also set to "
"USB_STATE_NOTATTACHED."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:4072
msgid "called by HCD if the root hub lost Vbus power"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:4078
msgid "``struct usb_device *rhdev``"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:4073
msgid "struct usb_device for the root hub"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:4074
msgid ""
"The USB host controller driver calls this function when its root hub is "
"resumed and Vbus power has been interrupted or the controller has been "
"reset.  The routine marks **rhdev** as having lost power. When the hub "
"driver is resumed it will take notice and carry out power-session recovery "
"for all the \"USB-PERSIST\"-enabled child devices; the others will be "
"disconnected."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6323
msgid "warn interface drivers and perform a USB port reset"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6324
msgid "device to reset (not in NOTATTACHED state)"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6325
msgid ""
"Warns all drivers bound to registered interfaces (using their pre_reset "
"method), performs the port reset, and then lets the drivers know that the "
"reset is over (using their post_reset method)."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6330
msgid ""
"The same as for usb_reset_and_verify_device(). However, if a reset is "
"already in progress (for instance, if a driver doesn't have pre_reset() or "
"post_reset() callbacks, and while being unbound or re-bound during the "
"ongoing reset its disconnect() or probe() routine tries to perform a second, "
"nested reset), the routine returns -EINPROGRESS."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6337
msgid ""
"The caller must own the device lock.  For example, it's safe to use this "
"from a driver probe() routine after downloading new firmware. For calls that "
"might not occur during probe(), drivers should lock the device using "
"usb_lock_device_for_reset()."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6342
msgid ""
"If an interface is currently being probed or disconnected, we assume its "
"driver knows how to handle resets.  For all other interfaces, if the driver "
"doesn't have pre_reset and post_reset methods then we attempt to unbind it "
"and rebind afterward."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6444
msgid "Reset a USB device from an atomic context"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6445
msgid "USB interface belonging to the device to reset"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6446
msgid ""
"This function can be used to reset a USB device from an atomic context, "
"where usb_reset_device() won't work (as it blocks)."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6449
msgid ""
"Doing a reset via this method is functionally equivalent to calling "
"usb_reset_device(), except for the fact that it is delayed to a workqueue. "
"This means that any drivers bound to other interfaces might be unbound, as "
"well as users from usbfs in user space."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6454
msgid "Corner cases:"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6456
msgid ""
"Scheduling two resets at the same time from two different drivers attached "
"to two different interfaces of the same device is possible; depending on how "
"the driver attached to each interface handles ->pre_reset(), the second "
"reset might happen or not."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6461
msgid ""
"If the reset is delayed so long that the interface is unbound from its "
"driver, the reset will be skipped."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6464
msgid ""
"This function can be called during .probe().  It can also be called during ."
"disconnect(), but doing so is pointless because the reset will not occur.  "
"If you really want to reset the device during .disconnect(), call "
"usb_reset_device() directly -- but watch out for nested unbinding issues!"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6479
msgid ""
"Get the pointer of child device attached to the port which is specified by "
"**port1**."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6485
msgid "``struct usb_device *hdev``"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6483
msgid "``int port1``"
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6482
msgid "port num to indicate which port the child device is attached to."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6484
msgid "USB drivers call this function to get hub's child device pointer."
msgstr ""

#: ../../../driver-api/usb/usb:177: drivers/usb/core/hub.c:6488
msgid ""
"``NULL`` if input param is invalid and child's usb_device pointer if non-"
"NULL."
msgstr ""

#: ../../../driver-api/usb/usb.rst:181
msgid "Host Controller APIs"
msgstr ""

#: ../../../driver-api/usb/usb.rst:183
msgid ""
"These APIs are only for use by host controller drivers, most of which "
"implement standard register interfaces such as XHCI, EHCI, OHCI, or UHCI. "
"UHCI was one of the first interfaces, designed by Intel and also used by "
"VIA; it doesn't do much in hardware. OHCI was designed later, to have the "
"hardware do more work (bigger transfers, tracking protocol state, and so "
"on). EHCI was designed with USB 2.0; its design has features that resemble "
"OHCI (hardware does much more work) as well as UHCI (some parts of ISO "
"support, TD list processing). XHCI was designed with USB 3.0. It continues "
"to shift support for functionality into hardware."
msgstr ""

#: ../../../driver-api/usb/usb.rst:193
msgid ""
"There are host controllers other than the \"big three\", although most PCI "
"based controllers (and a few non-PCI based ones) use one of those "
"interfaces. Not all host controllers use DMA; some use PIO, and there is "
"also a simulator and a virtual host controller to pipe USB over the network."
msgstr ""

#: ../../../driver-api/usb/usb.rst:198
msgid ""
"The same basic APIs are available to drivers for all those controllers. For "
"historical reasons they are in two layers: :c:type:`struct usb_bus "
"<usb_bus>` is a rather thin layer that became available in the 2.2 kernels, "
"while :c:type:`struct usb_hcd <usb_hcd>` is a more featureful layer that "
"lets HCDs share common code, to shrink driver size and significantly reduce "
"hcd-specific behaviors."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1059
msgid "approximate periodic transaction time in nanoseconds"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1065
msgid "``int speed``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1060
msgid "from dev->speed; USB_SPEED_{LOW,FULL,HIGH}"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1062
msgid "``int is_input``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1061
msgid "true iff the transaction sends data to the host"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1063
msgid "``int isoc``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1062
msgid "true for isochronous transactions, false for interrupt ones"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1064
msgid "``int bytecount``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1063
msgid "how many bytes in the transaction."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1065
msgid "Approximate bus time in nanoseconds for a periodic transaction."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1067
msgid ""
"See USB 2.0 spec section 5.11.3; only periodic transfers need to be "
"scheduled in software, this function is only used for such scheduling."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1116
msgid "add an URB to its endpoint queue"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1122
#: drivers/usb/core/hcd.c:1176 drivers/usb/core/hcd.c:1218
#: drivers/usb/core/hcd.c:1721 drivers/usb/core/hcd.c:2400
#: drivers/usb/core/hcd.c:2509 drivers/usb/core/hcd.c:2805
#: drivers/usb/core/hcd.c:3032 ../../../driver-api/usb/usb:212:
#: drivers/usb/core/buffer.c:58 drivers/usb/core/buffer.c:96
msgid "``struct usb_hcd *hcd``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1117
#: drivers/usb/core/hcd.c:1171 drivers/usb/core/hcd.c:1213
msgid "host controller to which **urb** was submitted"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1118
msgid "URB being submitted"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1119
msgid ""
"Host controller drivers should call this routine in their enqueue() method.  "
"The HCD's private spinlock must be held and interrupts must be disabled.  "
"The actions carried out here are required for URB submission, as well as for "
"endpoint shutdown and for usb_kill_urb."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1125
msgid ""
"0 for no error, otherwise a negative error code (in which case the enqueue() "
"method must fail).  If no error occurs but enqueue() fails anyway, it must "
"call usb_hcd_unlink_urb_from_ep() before releasing the private spinlock and "
"returning."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1170
msgid "check whether an URB may be unlinked"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1172
msgid "URB being checked for unlinkability"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1174
#: drivers/usb/core/hcd.c:1719
msgid "``int status``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1173
msgid "error code to store in **urb** if the unlink succeeds"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1174
msgid ""
"Host controller drivers should call this routine in their dequeue() method.  "
"The HCD's private spinlock must be held and interrupts must be disabled.  "
"The actions carried out here are required for making sure than an unlink is "
"valid."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1180
msgid "-EIDRM: **urb** was not submitted or has already completed."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1181
msgid "The completion function may not have been called yet."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1183
msgid "-EBUSY: **urb** has already been unlinked."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1180
msgid ""
"0 for no error, otherwise a negative error code (in which case the dequeue() "
"method must fail).  The possible error codes are:"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1212
msgid "remove an URB from its endpoint queue"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1214
msgid "URB being unlinked"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1215
msgid ""
"Host controller drivers should call this routine before calling "
"usb_hcd_giveback_urb().  The HCD's private spinlock must be held and "
"interrupts must be disabled.  The actions carried out here are required for "
"URB completion."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1715
msgid "return URB from HCD to device driver"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1716
msgid "host controller returning the URB"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1717
msgid "urb being returned to the USB device driver."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1718
msgid "completion status code for the URB."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1720
msgid ""
"atomic. The completion callback is invoked either in a work queue (BH) "
"context or in the caller's context, depending on whether the HCD_BH flag is "
"set in the **hcd** structure, except that URBs submitted to the root hub "
"always complete in BH context."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1724
msgid ""
"This hands the URB from HCD to its USB device driver, using its completion "
"function.  The HCD has freed all per-urb resources (and is done using urb-"
">hcpriv).  It also released all HCD locks; the device driver won't cause "
"problems if it frees, modifies, or resubmits this URB."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:1730
msgid ""
"If **urb** was unlinked, the value of **status** will be overridden by **urb-"
">unlinked**.  Erroneous short transfers are detected in case the HCD hasn't "
"checked for them."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2013
msgid "allocate bulk endpoint stream IDs."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2014
#: drivers/usb/core/hcd.c:2067
msgid "alternate setting that includes all endpoints."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2016
#: drivers/usb/core/hcd.c:2069
msgid "``struct usb_host_endpoint **eps``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2015
msgid "array of endpoints that need streams."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2017
#: drivers/usb/core/hcd.c:2070
msgid "``unsigned int num_eps``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2016
#: drivers/usb/core/hcd.c:2069
msgid "number of endpoints in the array."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2018
msgid "``unsigned int num_streams``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2017
msgid "number of streams to allocate."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2018
#: drivers/usb/core/hcd.c:2070
msgid "flags hcd should use to allocate memory."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2019
msgid ""
"Sets up a group of bulk endpoints to have **num_streams** stream IDs "
"available. Drivers may queue multiple transfers to different stream IDs, "
"which may complete in a different order than they were queued."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2024
msgid ""
"On success, the number of allocated streams. On failure, a negative error "
"code."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2066
msgid "free bulk endpoint stream IDs."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2068
msgid "array of endpoints to remove streams from."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2071
msgid ""
"Reverts a group of bulk endpoints back to not using stream IDs. Can fail if "
"we are given bad arguments, or HCD is broken."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2075
msgid "0 on success. On failure, a negative error code."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2394
msgid "called by HCD to resume its root hub"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2395
msgid "host controller for this root hub"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2396
msgid ""
"The USB host controller calls this function when its root hub is suspended "
"(with the remote wakeup feature enabled) and a remote wakeup request is "
"received.  The routine submits a workqueue request to resume the root hub "
"(that is, manage its downstream ports again)."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2423
msgid "start immediate enumeration (for OTG)"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2424
msgid "the bus (must use hcd framework)"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2426
msgid "``unsigned port_num``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2425
msgid "1-based number of port; usually bus->otg_port"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2426
msgid "atomic"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2427
msgid ""
"Starts enumeration, with an immediate reset followed later by hub_wq "
"identifying and possibly configuring the device. This is needed by OTG "
"controller drivers, where it helps meet HNP protocol timing requirements for "
"starting a port reset."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2433
#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:170
msgid "0 if successful."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2462
msgid "hook IRQs to HCD framework (bus glue)"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2468
msgid "``int irq``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2463
msgid "the IRQ being raised"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2465
msgid "``void *__hcd``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2464
msgid "pointer to the HCD whose IRQ is being signaled"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2465
msgid ""
"If the controller isn't HALTed, calls the driver's irq handler. Checks "
"whether the controller is now dead."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2469
msgid "``IRQ_HANDLED`` if the IRQ was handled. ``IRQ_NONE`` otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2503
msgid "report abnormal shutdown of a host controller (bus glue)"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2504
msgid "pointer to the HCD representing the controller"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2505
msgid ""
"This is called by bus glue to report a USB host controller that died while "
"operations may still have been pending.  It's called automatically by the "
"PCI glue, so only glue for non-PCI busses should need to call it."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2509
msgid "Only call this function with the primary HCD."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2626
#: drivers/usb/core/hcd.c:2651
msgid "create and initialize an HCD structure"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2632
#: drivers/usb/core/hcd.c:2657 ../../../driver-api/usb/usb:209:
#: drivers/usb/core/hcd-pci.c:161
msgid "``const struct hc_driver *driver``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2627
#: drivers/usb/core/hcd.c:2652
msgid "HC driver that will use this hcd"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2628
#: drivers/usb/core/hcd.c:2653
msgid "device for this HC, stored in hcd->self.controller"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2630
#: drivers/usb/core/hcd.c:2655
msgid "``const char *bus_name``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2629
#: drivers/usb/core/hcd.c:2654
msgid "value to store in hcd->self.bus_name"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2631
msgid "``struct usb_hcd *primary_hcd``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2630
msgid ""
"a pointer to the usb_hcd structure that is sharing the PCI device.  Only "
"allocate certain resources for the primary HCD"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2634
#: drivers/usb/core/hcd.c:2657
msgid ""
"Allocate a struct usb_hcd, with extra space at the end for the HC driver's "
"private data.  Initialize the generic members of the hcd structure."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2639
#: drivers/usb/core/hcd.c:2662
msgid ""
"On success, a pointer to the created and initialized HCD structure. On "
"failure (e.g. if memory is unavailable), ``NULL``."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2799
msgid "finish generic HCD structure initialization and register"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2800
msgid "the usb_hcd structure to initialize"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2802
msgid "``unsigned int irqnum``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2801
msgid "Interrupt line to allocate"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2803
msgid "``unsigned long irqflags``"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2802
msgid "Interrupt type flags"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:2803
msgid ""
"Finish the remaining parts of generic HCD initialization: allocate the "
"buffers of consistent memory, register the bus, request the IRQ line, and "
"call the driver's reset() and start() routines."
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:3026
msgid "shutdown processing for generic HCDs"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:3027
msgid "the usb_hcd structure to remove"
msgstr ""

#: ../../../driver-api/usb/usb:206: drivers/usb/core/hcd.c:3030
msgid ""
"Disconnects the root hub, then reverses the effects of usb_add_hcd(), "
"invoking the HCD's stop() method."
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:158
msgid "initialize PCI-based HCDs"
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:164
#: drivers/usb/core/hcd-pci.c:306 drivers/usb/core/hcd-pci.c:362
msgid "``struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:159
msgid "USB Host Controller being probed"
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:160
msgid "USB HC driver handle"
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:162
#: drivers/usb/core/hcd-pci.c:303 ../../../driver-api/usb/usb:212:
#: drivers/usb/core/buffer.c:55 drivers/usb/core/buffer.c:93
msgid "task context, might sleep"
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:163
msgid ""
"Allocates basic PCI resources for this USB host controller, and then invokes "
"the start() method for the HCD associated with it through the hotplug "
"entry's driver_data."
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:167
msgid "Store this function in the HCD's struct pci_driver as probe()."
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:300
msgid "shutdown processing for PCI-based HCDs"
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:301
msgid "USB Host Controller being removed"
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:304
msgid ""
"Reverses the effect of usb_hcd_pci_probe(), first invoking the HCD's stop() "
"method.  It is always called from a thread context, normally \"rmmod\", "
"\"apmd\", or something similar."
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:308
msgid "Store this function in the HCD's struct pci_driver as remove()."
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:356
msgid "shutdown host controller"
msgstr ""

#: ../../../driver-api/usb/usb:209: drivers/usb/core/hcd-pci.c:357
msgid "USB Host Controller being shutdown"
msgstr ""

#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:52
msgid "initialize buffer pools"
msgstr ""

#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:53
msgid "the bus whose buffer pools are to be initialized"
msgstr ""

#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:56
msgid ""
"Call this as part of initializing a host controller that uses the dma memory "
"allocators.  It initializes some pools of dma-coherent memory that will be "
"shared by all drivers using that controller."
msgstr ""

#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:60
msgid "Call hcd_buffer_destroy() to clean up after using those pools."
msgstr ""

#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:63
msgid "0 if successful. A negative errno value otherwise."
msgstr ""

#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:90
msgid "deallocate buffer pools"
msgstr ""

#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:91
msgid "the bus whose buffer pools are to be destroyed"
msgstr ""

#: ../../../driver-api/usb/usb:212: drivers/usb/core/buffer.c:94
msgid "This frees the buffer pools created by hcd_buffer_create()."
msgstr ""

#: ../../../driver-api/usb/usb.rst:216
msgid "The USB character device nodes"
msgstr ""

#: ../../../driver-api/usb/usb.rst:218
msgid ""
"This chapter presents the Linux character device nodes. You may prefer to "
"avoid writing new kernel code for your USB driver. User mode device drivers "
"are usually packaged as applications or libraries, and may use character "
"devices through some programming library that wraps it. Such libraries "
"include:"
msgstr ""

#: ../../../driver-api/usb/usb.rst:224
msgid "`libusb <http://libusb.sourceforge.net>`__ for C/C++, and"
msgstr ""

#: ../../../driver-api/usb/usb.rst:225
msgid "`jUSB <http://jUSB.sourceforge.net>`__ for Java."
msgstr ""

#: ../../../driver-api/usb/usb.rst:227
msgid ""
"Some old information about it can be seen at the \"USB Device Filesystem\" "
"section of the USB Guide. The latest copy of the USB Guide can be found at "
"http://www.linux-usb.org/"
msgstr ""

#: ../../../driver-api/usb/usb.rst:233
msgid ""
"They were used to be implemented via *usbfs*, but this is not part of the "
"sysfs debug interface."
msgstr ""

#: ../../../driver-api/usb/usb.rst:236
msgid ""
"This particular documentation is incomplete, especially with respect to the "
"asynchronous mode. As of kernel 2.5.66 the code and this (new) documentation "
"need to be cross-reviewed."
msgstr ""

#: ../../../driver-api/usb/usb.rst:241
msgid "What files are in \"devtmpfs\"?"
msgstr ""

#: ../../../driver-api/usb/usb.rst:243
msgid "Conventionally mounted at ``/dev/bus/usb/``, usbfs features include:"
msgstr ""

#: ../../../driver-api/usb/usb.rst:245
msgid ""
"``/dev/bus/usb/BBB/DDD`` ... magic files exposing the each device's "
"configuration descriptors, and supporting a series of ioctls for making "
"device requests, including I/O to devices. (Purely for access by programs.)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:250
msgid ""
"Each bus is given a number (``BBB``) based on when it was enumerated; within "
"each bus, each device is given a similar number (``DDD``). Those ``BBB/DDD`` "
"paths are not \"stable\" identifiers; expect them to change even if you "
"always leave the devices plugged in to the same hub port. *Don't even think "
"of saving these in application configuration files.* Stable identifiers are "
"available, for user mode applications that want to use them. HID and "
"networking devices expose these stable IDs, so that for example you can be "
"sure that you told the right UPS to power down its second server. Pleast "
"note that it doesn't (yet) expose those IDs."
msgstr ""

#: ../../../driver-api/usb/usb.rst:261
msgid "/dev/bus/usb/BBB/DDD"
msgstr ""

#: ../../../driver-api/usb/usb.rst:263
msgid "Use these files in one of these basic ways:"
msgstr ""

#: ../../../driver-api/usb/usb.rst:265
msgid ""
"*They can be read,* producing first the device descriptor (18 bytes) and "
"then the descriptors for the current configuration. See the USB 2.0 spec for "
"details about those binary data formats. You'll need to convert most "
"multibyte values from little endian format to your native host byte order, "
"although a few of the fields in the device descriptor (both of the BCD-"
"encoded fields, and the vendor and product IDs) will be byteswapped for you. "
"Note that configuration descriptors include descriptors for interfaces, "
"altsettings, endpoints, and maybe additional class descriptors."
msgstr ""

#: ../../../driver-api/usb/usb.rst:275
msgid ""
"*Perform USB operations* using *ioctl()* requests to make endpoint I/O "
"requests (synchronously or asynchronously) or manage the device. These "
"requests need the ``CAP_SYS_RAWIO`` capability, as well as filesystem access "
"permissions. Only one ioctl request can be made on one of these device files "
"at a time. This means that if you are synchronously reading an endpoint from "
"one thread, you won't be able to write to a different endpoint from another "
"thread until the read completes. This works for *half duplex* protocols, but "
"otherwise you'd use asynchronous i/o requests."
msgstr ""

#: ../../../driver-api/usb/usb.rst:285
msgid ""
"Each connected USB device has one file.  The ``BBB`` indicates the bus "
"number.  The ``DDD`` indicates the device address on that bus.  Both of "
"these numbers are assigned sequentially, and can be reused, so you can't "
"rely on them for stable access to devices.  For example, it's relatively "
"common for devices to re-enumerate while they are still connected (perhaps "
"someone jostled their power supply, hub, or USB cable), so a device might be "
"``002/027`` when you first connect it and ``002/048`` sometime later."
msgstr ""

#: ../../../driver-api/usb/usb.rst:294
msgid ""
"These files can be read as binary data.  The binary data consists of first "
"the device descriptor, then the descriptors for each configuration of the "
"device.  Multi-byte fields in the device descriptor are converted to host "
"endianness by the kernel.  The configuration descriptors are in bus endian "
"format! The configuration descriptor are wTotalLength bytes apart. If a "
"device returns less configuration descriptor data than indicated by "
"wTotalLength there will be a hole in the file for the missing bytes.  This "
"information is also shown in text form by the ``/sys/kernel/debug/usb/"
"devices`` file, described later."
msgstr ""

#: ../../../driver-api/usb/usb.rst:304
msgid ""
"These files may also be used to write user-level drivers for the USB "
"devices.  You would open the ``/dev/bus/usb/BBB/DDD`` file read/write, read "
"its descriptors to make sure it's the device you expect, and then bind to an "
"interface (or perhaps several) using an ioctl call.  You would issue more "
"ioctls to the device to communicate to it using control, bulk, or other "
"kinds of USB transfers.  The IOCTLs are listed in the ``<linux/usbdevice_fs."
"h>`` file, and at this writing the source code (``linux/drivers/usb/core/"
"devio.c``) is the primary reference for how to access devices through those "
"files."
msgstr ""

#: ../../../driver-api/usb/usb.rst:314
msgid ""
"Note that since by default these ``BBB/DDD`` files are writable only by "
"root, only root can write such user mode drivers.  You can selectively grant "
"read/write permissions to other users by using ``chmod``.  Also, usbfs mount "
"options such as ``devmode=0666`` may be helpful."
msgstr ""

#: ../../../driver-api/usb/usb.rst:321
msgid "Life Cycle of User Mode Drivers"
msgstr ""

#: ../../../driver-api/usb/usb.rst:323
msgid ""
"Such a driver first needs to find a device file for a device it knows how to "
"handle. Maybe it was told about it because a ``/sbin/hotplug`` event "
"handling agent chose that driver to handle the new device. Or maybe it's an "
"application that scans all the ``/dev/bus/usb`` device files, and ignores "
"most devices. In either case, it should :c:func:`read()` all the descriptors "
"from the device file, and check them against what it knows how to handle. It "
"might just reject everything except a particular vendor and product ID, or "
"need a more complex policy."
msgstr ""

#: ../../../driver-api/usb/usb.rst:332
msgid ""
"Never assume there will only be one such device on the system at a time! If "
"your code can't handle more than one device at a time, at least detect when "
"there's more than one, and have your users choose which device to use."
msgstr ""

#: ../../../driver-api/usb/usb.rst:337
msgid ""
"Once your user mode driver knows what device to use, it interacts with it in "
"either of two styles. The simple style is to make only control requests; "
"some devices don't need more complex interactions than those. (An example "
"might be software using vendor-specific control requests for some "
"initialization or configuration tasks, with a kernel driver for the rest.)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:344
msgid ""
"More likely, you need a more complex style driver: one using non-control "
"endpoints, reading or writing data and claiming exclusive use of an "
"interface. *Bulk* transfers are easiest to use, but only their sibling "
"*interrupt* transfers work with low speed devices. Both interrupt and "
"*isochronous* transfers offer service guarantees because their bandwidth is "
"reserved. Such \"periodic\" transfers are awkward to use through usbfs, "
"unless you're using the asynchronous calls. However, interrupt transfers can "
"also be used in a synchronous \"one shot\" style."
msgstr ""

#: ../../../driver-api/usb/usb.rst:353
msgid ""
"Your user-mode driver should never need to worry about cleaning up request "
"state when the device is disconnected, although it should close its open "
"file descriptors as soon as it starts seeing the ENODEV errors."
msgstr ""

#: ../../../driver-api/usb/usb.rst:358
msgid "The ioctl() Requests"
msgstr ""

#: ../../../driver-api/usb/usb.rst:360
msgid ""
"To use these ioctls, you need to include the following headers in your "
"userspace program::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:367
msgid ""
"The standard USB device model requests, from \"Chapter 9\" of the USB 2.0 "
"specification, are automatically included from the ``<linux/usb/ch9.h>`` "
"header."
msgstr ""

#: ../../../driver-api/usb/usb.rst:371
msgid ""
"Unless noted otherwise, the ioctl requests described here will update the "
"modification time on the usbfs file to which they are applied (unless they "
"fail). A return of zero indicates success; otherwise, a standard USB error "
"code is returned (These are documented in :ref:`usb-error-codes`)."
msgstr ""

#: ../../../driver-api/usb/usb.rst:377
msgid ""
"Each of these files multiplexes access to several I/O streams, one per "
"endpoint. Each device has one control endpoint (endpoint zero) which "
"supports a limited RPC style RPC access. Devices are configured by hub_wq "
"(in the kernel) setting a device-wide *configuration* that affects things "
"like power consumption and basic functionality. The endpoints are part of "
"USB *interfaces*, which may have *altsettings* affecting things like which "
"endpoints are available. Many devices only have a single configuration and "
"interface, so drivers for them will ignore configurations and altsettings."
msgstr ""

#: ../../../driver-api/usb/usb.rst:388
msgid "Management/Status Requests"
msgstr ""

#: ../../../driver-api/usb/usb.rst:390
msgid ""
"A number of usbfs requests don't deal very directly with device I/O. They "
"mostly relate to device management and status. These are all synchronous "
"requests."
msgstr ""

#: ../../../driver-api/usb/usb.rst:394
msgid "USBDEVFS_CLAIMINTERFACE"
msgstr ""

#: ../../../driver-api/usb/usb.rst:395
msgid ""
"This is used to force usbfs to claim a specific interface, which has not "
"previously been claimed by usbfs or any other kernel driver. The ioctl "
"parameter is an integer holding the number of the interface "
"(bInterfaceNumber from descriptor)."
msgstr ""

#: ../../../driver-api/usb/usb.rst:400
msgid ""
"Note that if your driver doesn't claim an interface before trying to use one "
"of its endpoints, and no other driver has bound to it, then the interface is "
"automatically claimed by usbfs."
msgstr ""

#: ../../../driver-api/usb/usb.rst:404
msgid ""
"This claim will be released by a RELEASEINTERFACE ioctl, or by closing the "
"file descriptor. File modification time is not updated by this request."
msgstr ""

#: ../../../driver-api/usb/usb.rst:408
msgid "USBDEVFS_CONNECTINFO"
msgstr ""

#: ../../../driver-api/usb/usb.rst:409
msgid ""
"Says whether the device is lowspeed. The ioctl parameter points to a "
"structure like this::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:417 ../../../driver-api/usb/usb.rst:428
#: ../../../driver-api/usb/usb.rst:440 ../../../driver-api/usb/usb.rst:469
#: ../../../driver-api/usb/usb.rst:601
msgid "File modification time is not updated by this request."
msgstr ""

#: ../../../driver-api/usb/usb.rst:419
msgid ""
"*You can't tell whether a \"not slow\" device is connected at high speed "
"(480 MBit/sec) or just full speed (12 MBit/sec).* You should know the devnum "
"value already, it's the DDD value of the device file name."
msgstr ""

#: ../../../driver-api/usb/usb.rst:424
msgid "USBDEVFS_GET_SPEED"
msgstr ""

#: ../../../driver-api/usb/usb.rst:425
msgid ""
"Returns the speed of the device. The speed is returned as a numerical value "
"in accordance with enum usb_device_speed"
msgstr ""

#: ../../../driver-api/usb/usb.rst:430
msgid "USBDEVFS_GETDRIVER"
msgstr ""

#: ../../../driver-api/usb/usb.rst:431
msgid ""
"Returns the name of the kernel driver bound to a given interface (a string). "
"Parameter is a pointer to this structure, which is modified::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:442
msgid "USBDEVFS_IOCTL"
msgstr ""

#: ../../../driver-api/usb/usb.rst:443
msgid ""
"Passes a request from userspace through to a kernel driver that has an ioctl "
"entry in the *struct usb_driver* it registered::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:471
msgid ""
"This request lets kernel drivers talk to user mode code through filesystem "
"operations even when they don't create a character or block special device. "
"It's also been used to do things like ask devices what device special file "
"should be used. Two pre-defined ioctls are used to disconnect and reconnect "
"kernel drivers, so that user mode code can completely manage binding and "
"configuration of devices."
msgstr ""

#: ../../../driver-api/usb/usb.rst:479
msgid "USBDEVFS_RELEASEINTERFACE"
msgstr ""

#: ../../../driver-api/usb/usb.rst:480
msgid ""
"This is used to release the claim usbfs made on interface, either implicitly "
"or because of a USBDEVFS_CLAIMINTERFACE call, before the file descriptor is "
"closed. The ioctl parameter is an integer holding the number of the "
"interface (bInterfaceNumber from descriptor); File modification time is not "
"updated by this request."
msgstr ""

#: ../../../driver-api/usb/usb.rst:488
msgid ""
"*No security check is made to ensure that the task which made the claim is "
"the one which is releasing it. This means that user mode driver may "
"interfere other ones.*"
msgstr ""

#: ../../../driver-api/usb/usb.rst:492
msgid "USBDEVFS_RESETEP"
msgstr ""

#: ../../../driver-api/usb/usb.rst:493
msgid ""
"Resets the data toggle value for an endpoint (bulk or interrupt) to DATA0. "
"The ioctl parameter is an integer endpoint number (1 to 15, as identified in "
"the endpoint descriptor), with USB_DIR_IN added if the device's endpoint "
"sends data to the host."
msgstr ""

#: ../../../driver-api/usb/usb.rst:500
msgid ""
"*Avoid using this request. It should probably be removed.* Using it "
"typically means the device and driver will lose toggle synchronization. If "
"you really lost synchronization, you likely need to completely handshake "
"with the device, using a request like CLEAR_HALT or SET_INTERFACE."
msgstr ""

#: ../../../driver-api/usb/usb.rst:506
msgid "USBDEVFS_DROP_PRIVILEGES"
msgstr ""

#: ../../../driver-api/usb/usb.rst:507
msgid ""
"This is used to relinquish the ability to do certain operations which are "
"considered to be privileged on a usbfs file descriptor. This includes "
"claiming arbitrary interfaces, resetting a device on which there are "
"currently claimed interfaces from other users, and issuing USBDEVFS_IOCTL "
"calls. The ioctl parameter is a 32 bit mask of interfaces the user is "
"allowed to claim on this file descriptor. You may issue this ioctl more than "
"one time to narrow said mask."
msgstr ""

#: ../../../driver-api/usb/usb.rst:516
msgid "Synchronous I/O Support"
msgstr ""

#: ../../../driver-api/usb/usb.rst:518
msgid ""
"Synchronous requests involve the kernel blocking until the user mode request "
"completes, either by finishing successfully or by reporting an error. In "
"most cases this is the simplest way to use usbfs, although as noted above it "
"does prevent performing I/O to more than one endpoint at a time."
msgstr ""

#: ../../../driver-api/usb/usb.rst:524
msgid "USBDEVFS_BULK"
msgstr ""

#: ../../../driver-api/usb/usb.rst:525
msgid ""
"Issues a bulk read or write request to the device. The ioctl parameter is a "
"pointer to this structure::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:535
msgid ""
"The ``ep`` value identifies a bulk endpoint number (1 to 15, as identified "
"in an endpoint descriptor), masked with USB_DIR_IN when referring to an "
"endpoint which sends data to the host from the device. The length of the "
"data buffer is identified by ``len``; Recent kernels support requests up to "
"about 128KBytes. *FIXME say how read length is returned, and how short reads "
"are handled.*."
msgstr ""

#: ../../../driver-api/usb/usb.rst:542
msgid "USBDEVFS_CLEAR_HALT"
msgstr ""

#: ../../../driver-api/usb/usb.rst:543
msgid ""
"Clears endpoint halt (stall) and resets the endpoint toggle. This is only "
"meaningful for bulk or interrupt endpoints. The ioctl parameter is an "
"integer endpoint number (1 to 15, as identified in an endpoint descriptor), "
"masked with USB_DIR_IN when referring to an endpoint which sends data to the "
"host from the device."
msgstr ""

#: ../../../driver-api/usb/usb.rst:549
msgid ""
"Use this on bulk or interrupt endpoints which have stalled, returning ``-"
"EPIPE`` status to a data transfer request. Do not issue the control request "
"directly, since that could invalidate the host's record of the data toggle."
msgstr ""

#: ../../../driver-api/usb/usb.rst:554
msgid "USBDEVFS_CONTROL"
msgstr ""

#: ../../../driver-api/usb/usb.rst:555
msgid ""
"Issues a control request to the device. The ioctl parameter points to a "
"structure like this::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:568
msgid ""
"The first eight bytes of this structure are the contents of the SETUP packet "
"to be sent to the device; see the USB 2.0 specification for details. The "
"bRequestType value is composed by combining a ``USB_TYPE_*`` value, a "
"``USB_DIR_*`` value, and a ``USB_RECIP_*`` value (from ``linux/usb.h``). If "
"wLength is nonzero, it describes the length of the data buffer, which is "
"either written to the device (USB_DIR_OUT) or read from the device "
"(USB_DIR_IN)."
msgstr ""

#: ../../../driver-api/usb/usb.rst:576
msgid ""
"At this writing, you can't transfer more than 4 KBytes of data to or from a "
"device; usbfs has a limit, and some host controller drivers have a limit. "
"(That's not usually a problem.) *Also* there's no way to say it's not OK to "
"get a short read back from the device."
msgstr ""

#: ../../../driver-api/usb/usb.rst:581
msgid "USBDEVFS_RESET"
msgstr ""

#: ../../../driver-api/usb/usb.rst:582
msgid ""
"Does a USB level device reset. The ioctl parameter is ignored. After the "
"reset, this rebinds all device interfaces. File modification time is not "
"updated by this request."
msgstr ""

#: ../../../driver-api/usb/usb.rst:588 ../../../driver-api/usb/usb.rst:617
msgid ""
"*Avoid using this call* until some usbcore bugs get fixed, since it does not "
"fully synchronize device, interface, and driver (not just usbfs) state."
msgstr ""

#: ../../../driver-api/usb/usb.rst:592
msgid "USBDEVFS_SETINTERFACE"
msgstr ""

#: ../../../driver-api/usb/usb.rst:593
msgid ""
"Sets the alternate setting for an interface. The ioctl parameter is a "
"pointer to a structure like this::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:603
msgid ""
"Those struct members are from some interface descriptor applying to the "
"current configuration. The interface number is the bInterfaceNumber value, "
"and the altsetting number is the bAlternateSetting value. (This resets each "
"endpoint in the interface.)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:609
msgid "USBDEVFS_SETCONFIGURATION"
msgstr ""

#: ../../../driver-api/usb/usb.rst:610
msgid ""
"Issues the :c:func:`usb_set_configuration()` call for the device. The "
"parameter is an integer holding the number of a configuration "
"(bConfigurationValue from descriptor). File modification time is not updated "
"by this request."
msgstr ""

#: ../../../driver-api/usb/usb.rst:622
msgid "Asynchronous I/O Support"
msgstr ""

#: ../../../driver-api/usb/usb.rst:624
msgid ""
"As mentioned above, there are situations where it may be important to "
"initiate concurrent operations from user mode code. This is particularly "
"important for periodic transfers (interrupt and isochronous), but it can be "
"used for other kinds of USB requests too. In such cases, the asynchronous "
"requests described here are essential. Rather than submitting one request "
"and having the kernel block until it completes, the blocking is separate."
msgstr ""

#: ../../../driver-api/usb/usb.rst:632
msgid ""
"These requests are packaged into a structure that resembles the URB used by "
"kernel device drivers. (No POSIX Async I/O support here, sorry.) It "
"identifies the endpoint type (``USBDEVFS_URB_TYPE_*``), endpoint (number, "
"masked with USB_DIR_IN as appropriate), buffer and length, and a user "
"\"context\" value serving to uniquely identify each request. (It's usually a "
"pointer to per-request data.) Flags can modify requests (not as many as "
"supported for kernel drivers)."
msgstr ""

#: ../../../driver-api/usb/usb.rst:640
msgid ""
"Each request can specify a realtime signal number (between SIGRTMIN and "
"SIGRTMAX, inclusive) to request a signal be sent when the request completes."
msgstr ""

#: ../../../driver-api/usb/usb.rst:644
msgid ""
"When usbfs returns these urbs, the status value is updated, and the buffer "
"may have been modified. Except for isochronous transfers, the actual_length "
"is updated to say how many bytes were transferred; if the "
"USBDEVFS_URB_DISABLE_SPD flag is set (\"short packets are not OK\"), if "
"fewer bytes were read than were requested then you get an error report::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:672
msgid ""
"For these asynchronous requests, the file modification time reflects when "
"the request was initiated. This contrasts with their use with the "
"synchronous requests, where it reflects when requests complete."
msgstr ""

#: ../../../driver-api/usb/usb.rst:676
msgid "USBDEVFS_DISCARDURB"
msgstr ""

#: ../../../driver-api/usb/usb.rst:677 ../../../driver-api/usb/usb.rst:680
#: ../../../driver-api/usb/usb.rst:683 ../../../driver-api/usb/usb.rst:686
msgid "*TBS* File modification time is not updated by this request."
msgstr ""

#: ../../../driver-api/usb/usb.rst:679
msgid "USBDEVFS_DISCSIGNAL"
msgstr ""

#: ../../../driver-api/usb/usb.rst:682
msgid "USBDEVFS_REAPURB"
msgstr ""

#: ../../../driver-api/usb/usb.rst:685
msgid "USBDEVFS_REAPURBNDELAY"
msgstr ""

#: ../../../driver-api/usb/usb.rst:688
msgid "USBDEVFS_SUBMITURB"
msgstr ""

#: ../../../driver-api/usb/usb.rst:689
msgid "*TBS*"
msgstr ""

#: ../../../driver-api/usb/usb.rst:692
msgid "The USB devices"
msgstr ""

#: ../../../driver-api/usb/usb.rst:694
msgid "The USB devices are now exported via debugfs:"
msgstr ""

#: ../../../driver-api/usb/usb.rst:696
msgid ""
"``/sys/kernel/debug/usb/devices`` ... a text file showing each of the USB "
"devices on known to the kernel, and their configuration descriptors. You can "
"also poll() this to learn about new devices."
msgstr ""

#: ../../../driver-api/usb/usb.rst:701
msgid "/sys/kernel/debug/usb/devices"
msgstr ""

#: ../../../driver-api/usb/usb.rst:703
msgid ""
"This file is handy for status viewing tools in user mode, which can scan the "
"text format and ignore most of it. More detailed device status (including "
"class and vendor status) is available from device-specific files. For "
"information about the current format of this file, see below."
msgstr ""

#: ../../../driver-api/usb/usb.rst:708
msgid ""
"This file, in combination with the poll() system call, can also be used to "
"detect when devices are added or removed::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:724
msgid ""
"Note that this behavior is intended to be used for informational and debug "
"purposes. It would be more appropriate to use programs such as udev or HAL "
"to initialize a device or start a user-mode helper program, for instance."
msgstr ""

#: ../../../driver-api/usb/usb.rst:729
msgid "In this file, each device's output has multiple lines of ASCII output."
msgstr ""

#: ../../../driver-api/usb/usb.rst:731
msgid ""
"I made it ASCII instead of binary on purpose, so that someone can obtain "
"some useful data from it without the use of an auxiliary program.  However, "
"with an auxiliary program, the numbers in the first 4 columns of each ``T:`` "
"line (topology info: Lev, Prnt, Port, Cnt) can be used to build a USB "
"topology diagram."
msgstr ""

#: ../../../driver-api/usb/usb.rst:737
msgid "Each line is tagged with a one-character ID for that line::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:751
msgid "/sys/kernel/debug/usb/devices output format"
msgstr ""

#: ../../../driver-api/usb/usb.rst:753
msgid "Legend::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:754
msgid ""
"d = decimal number (may have leading spaces or 0's) x = hexadecimal number "
"(may have leading spaces or 0's) s = string"
msgstr ""

#: ../../../driver-api/usb/usb.rst:761
msgid "Topology info"
msgstr ""

#: ../../../driver-api/usb/usb.rst:776
msgid "Speed may be:"
msgstr ""

#: ../../../driver-api/usb/usb.rst:779
msgid "1.5"
msgstr ""

#: ../../../driver-api/usb/usb.rst:779
msgid "Mbit/s for low speed USB"
msgstr ""

#: ../../../driver-api/usb/usb.rst:780
msgid "12"
msgstr ""

#: ../../../driver-api/usb/usb.rst:780
msgid "Mbit/s for full speed USB"
msgstr ""

#: ../../../driver-api/usb/usb.rst:781
msgid "480"
msgstr ""

#: ../../../driver-api/usb/usb.rst:781
msgid "Mbit/s for high speed USB (added for USB 2.0)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:782
msgid "5000"
msgstr ""

#: ../../../driver-api/usb/usb.rst:782
msgid "Mbit/s for SuperSpeed USB (added for USB 3.0)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:785
msgid ""
"For reasons lost in the mists of time, the Port number is always too low by "
"1.  For example, a device plugged into port 4 will show up with ``Port=03``."
msgstr ""

#: ../../../driver-api/usb/usb.rst:790
msgid "Bandwidth info"
msgstr ""

#: ../../../driver-api/usb/usb.rst:800
msgid ""
"Bandwidth allocation is an approximation of how much of one frame "
"(millisecond) is in use.  It reflects only periodic transfers, which are the "
"only transfers that reserve bandwidth.  Control and bulk transfers use all "
"other bandwidth, including reserved bandwidth that is not used for transfers "
"(such as for short packets)."
msgstr ""

#: ../../../driver-api/usb/usb.rst:806
msgid ""
"The percentage is how much of the \"reserved\" bandwidth is scheduled by "
"those transfers.  For a low or full speed bus (loosely, \"USB 1.1\"), 90% of "
"the bus bandwidth is reserved.  For a high speed bus (loosely, \"USB 2.0\") "
"80% is reserved."
msgstr ""

#: ../../../driver-api/usb/usb.rst:813
msgid "Device descriptor info & Product ID info"
msgstr ""

#: ../../../driver-api/usb/usb.rst:820 ../../../driver-api/usb/usb.rst:831
msgid "where::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:841
msgid "String descriptor info"
msgstr ""

#: ../../../driver-api/usb/usb.rst:868
msgid "Configuration descriptor info"
msgstr ""

#: ../../../driver-api/usb/usb.rst:879
msgid ""
"USB devices may have multiple configurations, each of which act rather "
"differently.  For example, a bus-powered configuration might be much less "
"capable than one that is self-powered.  Only one device configuration can be "
"active at a time; most devices have only one configuration."
msgstr ""

#: ../../../driver-api/usb/usb.rst:885
msgid ""
"Each configuration consists of one or more interfaces.  Each interface "
"serves a distinct \"function\", which is typically bound to a different USB "
"device driver.  One common example is a USB speaker with an audio interface "
"for playback, and a HID interface for use with software volume control."
msgstr ""

#: ../../../driver-api/usb/usb.rst:892
msgid "Interface descriptor info (can be multiple per Config)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:907
msgid ""
"A given interface may have one or more \"alternate\" settings. For example, "
"default settings may not use more than a small amount of periodic "
"bandwidth.  To use significant fractions of bus bandwidth, drivers must "
"select a non-default altsetting."
msgstr ""

#: ../../../driver-api/usb/usb.rst:912
msgid ""
"Only one setting for an interface may be active at a time, and only one "
"driver may bind to an interface at a time.  Most devices have only one "
"alternate setting per interface."
msgstr ""

#: ../../../driver-api/usb/usb.rst:918
msgid "Endpoint descriptor info (can be multiple per Interface)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:929
msgid ""
"The interval is nonzero for all periodic (interrupt or isochronous) "
"endpoints.  For high speed endpoints the transfer interval may be measured "
"in microseconds rather than milliseconds."
msgstr ""

#: ../../../driver-api/usb/usb.rst:933
msgid ""
"For high speed periodic endpoints, the ``EndpointMaxPacketSize`` reflects "
"the per-microframe data transfer size.  For \"high bandwidth\" endpoints, "
"that can reflect two or three packets (for up to 3KBytes every 125 usec) per "
"endpoint."
msgstr ""

#: ../../../driver-api/usb/usb.rst:938
msgid ""
"With the Linux-USB stack, periodic bandwidth reservations use the transfer "
"intervals and sizes provided by URBs, which can be less than those found in "
"endpoint descriptor."
msgstr ""

#: ../../../driver-api/usb/usb.rst:943
msgid "Usage examples"
msgstr ""

#: ../../../driver-api/usb/usb.rst:945
msgid ""
"If a user or script is interested only in Topology info, for example, use "
"something like ``grep ^T: /sys/kernel/debug/usb/devices`` for only the "
"Topology lines.  A command like ``grep -i ^[tdp]: /sys/kernel/debug/usb/"
"devices`` can be used to list only the lines that begin with the characters "
"in square brackets, where the valid characters are TDPCIE.  With a slightly "
"more able script, it can display any selected lines (for example, only T, D, "
"and P lines) and change their output format.  (The ``procusb`` Perl script "
"is the beginning of this idea.  It will list only selected lines [selected "
"from TBDPSCIE] or \"All\" lines from ``/sys/kernel/debug/usb/devices``.)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:957
msgid ""
"The Topology lines can be used to generate a graphic/pictorial of the USB "
"devices on a system's root hub.  (See more below on how to do this.)"
msgstr ""

#: ../../../driver-api/usb/usb.rst:961
msgid ""
"The Interface lines can be used to determine what driver is being used for "
"each device, and which altsetting it activated."
msgstr ""

#: ../../../driver-api/usb/usb.rst:964
msgid ""
"The Configuration lines could be used to list maximum power (in milliamps) "
"that a system's USB devices are using. For example, ``grep ^C: /sys/kernel/"
"debug/usb/devices``."
msgstr ""

#: ../../../driver-api/usb/usb.rst:969
msgid ""
"Here's an example, from a system which has a UHCI root hub, an external hub "
"connected to the root hub, and a mouse and a serial converter connected to "
"the external hub."
msgstr ""

#: ../../../driver-api/usb/usb.rst:1011
msgid ""
"Selecting only the ``T:`` and ``I:`` lines from this (for example, by using "
"``procusb ti``), we have"
msgstr ""

#: ../../../driver-api/usb/usb.rst:1025
msgid "Physically this looks like (or could be converted to)::"
msgstr ""

#: ../../../driver-api/usb/usb.rst:1048
msgid ""
"Or, in a more tree-like structure (ports [Connectors] without connections "
"could be omitted)::"
msgstr ""
