# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../virt/kvm/x86/msr.rst:5
msgid "KVM-specific MSRs"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:0
msgid "Author"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:7
msgid "Glauber Costa <glommer@redhat.com>, Red Hat Inc, 2010"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:9
msgid "KVM makes use of some custom MSRs to service some requests."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:11
msgid ""
"Custom MSRs have a range reserved for them, that goes from 0x4b564d00 to "
"0x4b564dff. There are MSRs outside this area, but they are deprecated and "
"their use is discouraged."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:16
msgid "Custom MSR list"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:18
msgid "The current supported Custom MSR list is:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:20
msgid "MSR_KVM_WALL_CLOCK_NEW:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:21
msgid "0x4b564d00"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:23 ../../../virt/kvm/x86/msr.rst:62
#: ../../../virt/kvm/x86/msr.rst:192 ../../../virt/kvm/x86/msr.rst:262
#: ../../../virt/kvm/x86/msr.rst:309 ../../../virt/kvm/x86/msr.rst:347
#: ../../../virt/kvm/x86/msr.rst:356 ../../../virt/kvm/x86/msr.rst:370
#: ../../../virt/kvm/x86/msr.rst:382
msgid "data:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:24
msgid ""
"4-byte alignment physical address of a memory area which must be in guest "
"RAM. This memory is expected to hold a copy of the following structure::"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:34
msgid ""
"whose data will be filled in by the hypervisor. The hypervisor is only "
"guaranteed to update this data at the moment of MSR write. Users that want "
"to reliably query this information more than once have to write more than "
"once to this MSR. Fields have the following meanings:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:39 ../../../virt/kvm/x86/msr.rst:86
#: ../../../virt/kvm/x86/msr.rst:285
msgid "version:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:40 ../../../virt/kvm/x86/msr.rst:87
msgid ""
"guest has to check version before and after grabbing time information and "
"check that they are both equal and even. An odd version indicates an in-"
"progress update."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:44
msgid "sec:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:45
msgid "number of seconds for wallclock at time of boot."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:47
msgid "nsec:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:48
msgid "number of nanoseconds for wallclock at time of boot."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:50
msgid ""
"In order to get the current wallclock time, the system_time from "
"MSR_KVM_SYSTEM_TIME_NEW needs to be added."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:53
msgid ""
"Note that although MSRs are per-CPU entities, the effect of this particular "
"MSR is global."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:56 ../../../virt/kvm/x86/msr.rst:144
msgid ""
"Availability of this MSR must be checked via bit 3 in 0x4000001 cpuid leaf "
"prior to usage."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:59
msgid "MSR_KVM_SYSTEM_TIME_NEW:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:60
msgid "0x4b564d01"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:63
msgid ""
"4-byte aligned physical address of a memory area which must be in guest RAM, "
"plus an enable bit in bit 0. This memory is expected to hold a copy of the "
"following structure::"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:78
msgid ""
"whose data will be filled in by the hypervisor periodically. Only one write, "
"or registration, is needed for each VCPU. The interval between updates of "
"this structure is arbitrary and implementation-dependent. The hypervisor may "
"update this structure at any time it sees fit until anything with bit0 == 0 "
"is written to it."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:84 ../../../virt/kvm/x86/msr.rst:283
msgid "Fields have the following meanings:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:91
msgid "tsc_timestamp:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:92
msgid ""
"the tsc value at the current VCPU at the time of the update of this "
"structure. Guests can subtract this value from current tsc to derive a "
"notion of elapsed time since the structure update."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:97
msgid "system_time:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:98
msgid ""
"a host notion of monotonic time, including sleep time at the time this "
"structure was last updated. Unit is nanoseconds."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:102
msgid "tsc_to_system_mul:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:103
msgid ""
"multiplier to be used when converting tsc-related quantity to nanoseconds"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:106
msgid "tsc_shift:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:107
msgid ""
"shift to be used when converting tsc-related quantity to nanoseconds. This "
"shift will ensure that multiplication with tsc_to_system_mul does not "
"overflow. A positive value denotes a left shift, a negative value a right "
"shift."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:113
msgid ""
"The conversion from tsc to nanoseconds involves an additional right shift by "
"32 bits. With this information, guests can derive per-CPU time by doing::"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:125 ../../../virt/kvm/x86/msr.rst:291
msgid "flags:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:126
msgid ""
"bits in this field indicate extended capabilities coordinated between the "
"guest and the hypervisor. Availability of specific flags has to be checked "
"in 0x40000001 cpuid leaf. Current flags are:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:133
msgid "flag bit"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:133
msgid "cpuid bit"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:133
msgid "meaning"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:136
msgid "0"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:136
msgid "24"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:135
msgid "time measures taken across multiple cpus are guaranteed to be monotonic"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:140
msgid "1"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:140
msgid "N/A"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:139
msgid "guest vcpu has been paused by the host See 4.70 in api.txt"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:148
msgid "MSR_KVM_WALL_CLOCK:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:149
msgid "0x11"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:151 ../../../virt/kvm/x86/msr.rst:163
msgid "data and functioning:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:152
msgid "same as MSR_KVM_WALL_CLOCK_NEW. Use that instead."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:154 ../../../virt/kvm/x86/msr.rst:166
msgid ""
"This MSR falls outside the reserved KVM range and may be removed in the "
"future. Its usage is deprecated."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:157 ../../../virt/kvm/x86/msr.rst:169
msgid ""
"Availability of this MSR must be checked via bit 0 in 0x4000001 cpuid leaf "
"prior to usage."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:160
msgid "MSR_KVM_SYSTEM_TIME:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:161
msgid "0x12"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:164
msgid "same as MSR_KVM_SYSTEM_TIME_NEW. Use that instead."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:172
msgid "The suggested algorithm for detecting kvmclock presence is then::"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:189
msgid "MSR_KVM_ASYNC_PF_EN:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:190
msgid "0x4b564d02"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:193
msgid "Asynchronous page fault (APF) control MSR."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:195
msgid ""
"Bits 63-6 hold 64-byte aligned physical address of a 64 byte memory area "
"which must be in guest RAM. This memory is expected to hold the following "
"structure::"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:209
msgid ""
"Bits 5-4 of the MSR are reserved and should be zero. Bit 0 is set to 1 when "
"asynchronous page faults are enabled on the vcpu, 0 when disabled. Bit 1 is "
"1 if asynchronous page faults can be injected when vcpu is in cpl == 0. Bit "
"2 is 1 if asynchronous page faults are delivered to L1 as #PF vmexits.  Bit "
"2 can be set only if KVM_FEATURE_ASYNC_PF_VMEXIT is present in CPUID. Bit 3 "
"enables interrupt based delivery of 'page ready' events. Bit 3 can only be "
"set if KVM_FEATURE_ASYNC_PF_INT is present in CPUID."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:218
msgid ""
"'Page not present' events are currently always delivered as synthetic #PF "
"exception. During delivery of these events APF CR2 register contains a token "
"that will be used to notify the guest when missing page becomes available. "
"Also, to make it possible to distinguish between real #PF and APF, first 4 "
"bytes of 64 byte memory location ('flags') will be written to by the "
"hypervisor at the time of injection. Only first bit of 'flags' is currently "
"supported, when set, it indicates that the guest is dealing with "
"asynchronous 'page not present' event. If during a page fault APF 'flags' is "
"'0' it means that this is regular page fault. Guest is supposed to clear "
"'flags' when it is done handling #PF exception so the next event can be "
"delivered."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:230
msgid ""
"Note, since APF 'page not present' events use the same exception vector as "
"regular page fault, guest must reset 'flags' to '0' before it does something "
"that can generate normal page fault."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:234
msgid ""
"Bytes 4-7 of 64 byte memory location ('token') will be written to by the "
"hypervisor at the time of APF 'page ready' event injection. The content of "
"these bytes is a token which was previously delivered in CR2 as 'page not "
"present' event. The event indicates the page is now available. Guest is "
"supposed to write '0' to 'token' when it is done handling 'page ready' event "
"and to write '1' to MSR_KVM_ASYNC_PF_ACK after clearing the location; "
"writing to the MSR forces KVM to re-scan its queue and deliver the next "
"pending notification."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:243
msgid ""
"Note, MSR_KVM_ASYNC_PF_INT MSR specifying the interrupt vector for 'page "
"ready' APF delivery needs to be written to before enabling APF mechanism in "
"MSR_KVM_ASYNC_PF_EN or interrupt #0 can get injected. The MSR is available "
"if KVM_FEATURE_ASYNC_PF_INT is present in CPUID."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:248
msgid ""
"Note, previously, 'page ready' events were delivered via the same #PF "
"exception as 'page not present' events but this is now deprecated. If bit 3 "
"(interrupt based delivery) is not set APF events are not delivered."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:252
msgid ""
"If APF is disabled while there are outstanding APFs, they will not be "
"delivered."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:255
msgid ""
"Currently 'page ready' APF events will be always delivered on the same vcpu "
"as 'page not present' event was, but guest should not rely on that."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:259
msgid "MSR_KVM_STEAL_TIME:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:260
msgid "0x4b564d03"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:263
msgid ""
"64-byte alignment physical address of a memory area which must be in guest "
"RAM, plus an enable bit in bit 0. This memory is expected to hold a copy of "
"the following structure::"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:276
msgid ""
"whose data will be filled in by the hypervisor periodically. Only one write, "
"or registration, is needed for each VCPU. The interval between updates of "
"this structure is arbitrary and implementation-dependent. The hypervisor may "
"update this structure at any time it sees fit until anything with bit0 == 0 "
"is written to it. Guest is required to make sure this structure is "
"initialized to zero."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:286
msgid ""
"a sequence counter. In other words, guest has to check this field before and "
"after grabbing time information and make sure they are both equal and even. "
"An odd version indicates an in-progress update."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:292
msgid ""
"At this point, always zero. May be used to indicate changes in this "
"structure in the future."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:295
msgid "steal:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:296
msgid ""
"the amount of time in which this vCPU did not run, in nanoseconds. Time "
"during which the vcpu is idle, will not be reported as steal time."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:300
msgid "preempted:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:301
msgid ""
"indicate the vCPU who owns this struct is running or not. Non-zero values "
"mean the vCPU has been preempted. Zero means the vCPU is not preempted. "
"NOTE, it is always zero if the the hypervisor doesn't support this field."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:306
msgid "MSR_KVM_EOI_EN:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:307
msgid "0x4b564d04"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:310
msgid ""
"Bit 0 is 1 when PV end of interrupt is enabled on the vcpu; 0 when "
"disabled.  Bit 1 is reserved and must be zero.  When PV end of interrupt is "
"enabled (bit 0 set), bits 63-2 hold a 4-byte aligned physical address of a 4 "
"byte memory area which must be in guest RAM and must be zeroed."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:316
msgid ""
"The first, least significant bit of 4 byte memory location will be written "
"to by the hypervisor, typically at the time of interrupt injection.  Value "
"of 1 means that guest can skip writing EOI to the apic (using MSR or MMIO "
"write); instead, it is sufficient to signal EOI by clearing the bit in guest "
"memory - this location will later be polled by the hypervisor. Value of 0 "
"means that the EOI write is required."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:324
msgid ""
"It is always safe for the guest to ignore the optimization and perform the "
"APIC EOI write anyway."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:327
msgid ""
"Hypervisor is guaranteed to only modify this least significant bit while in "
"the current VCPU context, this means that guest does not need to use either "
"lock prefix or memory ordering primitives to synchronise with the hypervisor."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:332
msgid ""
"However, hypervisor can set and clear this memory bit at any time: therefore "
"to make sure hypervisor does not interrupt the guest and clear the least "
"significant bit in the memory area in the window between guest testing it to "
"detect whether it can skip EOI apic write and between guest clearing it to "
"signal EOI to the hypervisor, guest must both read the least significant bit "
"in the memory area and clear it using a single CPU instruction, such as test "
"and clear, or compare and exchange."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:342
msgid "MSR_KVM_POLL_CONTROL:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:343
msgid "0x4b564d05"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:345
msgid "Control host-side polling."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:348
msgid "Bit 0 enables (1) or disables (0) host-side HLT polling logic."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:350
msgid ""
"KVM guests can request the host not to poll on HLT, for example if they are "
"performing polling themselves."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:353
msgid "MSR_KVM_ASYNC_PF_INT:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:354
msgid "0x4b564d06"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:357
msgid "Second asynchronous page fault (APF) control MSR."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:359
msgid ""
"Bits 0-7: APIC vector for delivery of 'page ready' APF events. Bits 8-63: "
"Reserved"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:362
msgid ""
"Interrupt vector for asynchnonous 'page ready' notifications delivery. The "
"vector has to be set up before asynchronous page fault mechanism is enabled "
"in MSR_KVM_ASYNC_PF_EN.  The MSR is only available if "
"KVM_FEATURE_ASYNC_PF_INT is present in CPUID."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:367
msgid "MSR_KVM_ASYNC_PF_ACK:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:368
msgid "0x4b564d07"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:371
msgid "Asynchronous page fault (APF) acknowledgment."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:373
msgid ""
"When the guest is done processing 'page ready' APF event and 'token' field "
"in 'struct kvm_vcpu_pv_apf_data' is cleared it is supposed to write '1' to "
"bit 0 of the MSR, this causes the host to re-scan its queue and check if "
"there are more notifications pending. The MSR is available if "
"KVM_FEATURE_ASYNC_PF_INT is present in CPUID."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:379
msgid "MSR_KVM_MIGRATION_CONTROL:"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:380
msgid "0x4b564d08"
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:383
msgid ""
"This MSR is available if KVM_FEATURE_MIGRATION_CONTROL is present in CPUID.  "
"Bit 0 represents whether live migration of the guest is allowed."
msgstr ""

#: ../../../virt/kvm/x86/msr.rst:386
msgid ""
"When a guest is started, bit 0 will be 0 if the guest has encrypted memory "
"and 1 if the guest does not have encrypted memory.  If the guest is "
"communicating page encryption status to the host using the "
"``KVM_HC_MAP_GPA_RANGE`` hypercall, it can set bit 0 in this MSR to allow "
"live migration of the guest."
msgstr ""
