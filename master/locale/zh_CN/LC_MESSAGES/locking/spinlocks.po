# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../locking/spinlocks.rst:3
msgid "Locking lessons"
msgstr ""

#: ../../../locking/spinlocks.rst:6
msgid "Lesson 1: Spin locks"
msgstr ""

#: ../../../locking/spinlocks.rst:8
msgid "The most basic primitive for locking is spinlock::"
msgstr ""

#: ../../../locking/spinlocks.rst:18
msgid ""
"The above is always safe. It will disable interrupts _locally_, but the "
"spinlock itself will guarantee the global lock, so it will guarantee that "
"there is only one thread-of-control within the region(s) protected by that "
"lock. This works well even under UP also, so the code does _not_ need to "
"worry about UP vs SMP issues: the spinlocks work correctly under both."
msgstr ""

#: ../../../locking/spinlocks.rst:24
msgid "NOTE! Implications of spin_locks for memory are further described in:"
msgstr ""

#: ../../../locking/spinlocks.rst:26
msgid "Documentation/memory-barriers.txt"
msgstr ""

#: ../../../locking/spinlocks.rst:28
msgid "ACQUIRE operations."
msgstr ""

#: ../../../locking/spinlocks.rst:30
msgid "RELEASE operations."
msgstr ""

#: ../../../locking/spinlocks.rst:32
msgid ""
"The above is usually pretty simple (you usually need and want only one "
"spinlock for most things - using more than one spinlock can make things a "
"lot more complex and even slower and is usually worth it only for sequences "
"that you **know** need to be split up: avoid it at all cost if you aren't "
"sure)."
msgstr ""

#: ../../../locking/spinlocks.rst:38
msgid ""
"This is really the only really hard part about spinlocks: once you start "
"using spinlocks they tend to expand to areas you might not have noticed "
"before, because you have to make sure the spinlocks correctly protect the "
"shared data structures **everywhere** they are used. The spinlocks are most "
"easily added to places that are completely independent of other code (for "
"example, internal driver data structures that nobody else ever touches)."
msgstr ""

#: ../../../locking/spinlocks.rst:45
msgid ""
"NOTE! The spin-lock is safe only when you **also** use the lock itself to do "
"locking across CPU's, which implies that EVERYTHING that touches a shared "
"variable has to agree about the spinlock they want to use."
msgstr ""

#: ../../../locking/spinlocks.rst:53
msgid "Lesson 2: reader-writer spinlocks."
msgstr ""

#: ../../../locking/spinlocks.rst:55
msgid ""
"If your data accesses have a very natural pattern where you usually tend to "
"mostly read from the shared variables, the reader-writer locks (rw_lock) "
"versions of the spinlocks are sometimes useful. They allow multiple readers "
"to be in the same critical region at once, but if somebody wants to change "
"the variables it has to get an exclusive write lock."
msgstr ""

#: ../../../locking/spinlocks.rst:61
msgid ""
"NOTE! reader-writer locks require more atomic memory operations than simple "
"spinlocks.  Unless the reader critical section is long, you are better off "
"just using spinlocks."
msgstr ""

#: ../../../locking/spinlocks.rst:65
msgid "The routines look the same as above::"
msgstr ""

#: ../../../locking/spinlocks.rst:79
msgid ""
"The above kind of lock may be useful for complex data structures like linked "
"lists, especially searching for entries without changing the list itself.  "
"The read lock allows many concurrent readers.  Anything that **changes** the "
"list will have to get the write lock."
msgstr ""

#: ../../../locking/spinlocks.rst:84
msgid ""
"NOTE! RCU is better for list traversal, but requires careful attention to "
"design detail (see Documentation/RCU/listRCU.rst)."
msgstr ""

#: ../../../locking/spinlocks.rst:87
msgid ""
"Also, you cannot \"upgrade\" a read-lock to a write-lock, so if you at _any_ "
"time need to do any changes (even if you don't do it every time), you have "
"to get the write-lock at the very beginning."
msgstr ""

#: ../../../locking/spinlocks.rst:91
msgid ""
"NOTE! We are working hard to remove reader-writer spinlocks in most cases, "
"so please don't add a new one without consensus.  (Instead, see "
"Documentation/RCU/rcu.rst for complete information.)"
msgstr ""

#: ../../../locking/spinlocks.rst:98
msgid "Lesson 3: spinlocks revisited."
msgstr ""

#: ../../../locking/spinlocks.rst:100
msgid ""
"The single spin-lock primitives above are by no means the only ones. They "
"are the most safe ones, and the ones that work under all circumstances, but "
"partly **because** they are safe they are also fairly slow. They are slower "
"than they'd need to be, because they do have to disable interrupts (which is "
"just a single instruction on a x86, but it's an expensive one - and on other "
"architectures it can be worse)."
msgstr ""

#: ../../../locking/spinlocks.rst:107
msgid ""
"If you have a case where you have to protect a data structure across several "
"CPU's and you want to use spinlocks you can potentially use cheaper versions "
"of the spinlocks. IFF you know that the spinlocks are never used in "
"interrupt handlers, you can use the non-irq versions::"
msgstr ""

#: ../../../locking/spinlocks.rst:116
msgid ""
"(and the equivalent read-write versions too, of course). The spinlock will "
"guarantee the same kind of exclusive access, and it will be much faster. "
"This is useful if you know that the data in question is only ever "
"manipulated from a \"process context\", ie no interrupts involved."
msgstr ""

#: ../../../locking/spinlocks.rst:121
msgid ""
"The reasons you mustn't use these versions if you have interrupts that play "
"with the spinlock is that you can get deadlocks::"
msgstr ""

#: ../../../locking/spinlocks.rst:129
msgid ""
"where an interrupt tries to lock an already locked variable. This is ok if "
"the other interrupt happens on another CPU, but it is _not_ ok if the "
"interrupt happens on the same CPU that already holds the lock, because the "
"lock will obviously never be released (because the interrupt is waiting for "
"the lock, and the lock-holder is interrupted by the interrupt and will not "
"continue until the interrupt has been processed)."
msgstr ""

#: ../../../locking/spinlocks.rst:136
msgid ""
"(This is also the reason why the irq-versions of the spinlocks only need to "
"disable the _local_ interrupts - it's ok to use spinlocks in interrupts on "
"other CPU's, because an interrupt on another CPU doesn't interrupt the CPU "
"that holds the lock, so the lock-holder can continue and eventually releases "
"the lock)."
msgstr ""

#: ../../../locking/spinlocks.rst:142
msgid "Linus"
msgstr ""

#: ../../../locking/spinlocks.rst:147
msgid "Reference information:"
msgstr ""

#: ../../../locking/spinlocks.rst:149
msgid ""
"For dynamic initialization, use spin_lock_init() or rwlock_init() as "
"appropriate::"
msgstr ""

#: ../../../locking/spinlocks.rst:164
msgid ""
"For static initialization, use DEFINE_SPINLOCK() / DEFINE_RWLOCK() or "
"__SPIN_LOCK_UNLOCKED() / __RW_LOCK_UNLOCKED() as appropriate."
msgstr ""
