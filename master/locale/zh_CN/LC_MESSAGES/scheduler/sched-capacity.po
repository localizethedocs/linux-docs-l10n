# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scheduler/sched-capacity.rst:3
msgid "Capacity Aware Scheduling"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:6
msgid "1. CPU Capacity"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:9
msgid "1.1 Introduction"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:11
msgid ""
"Conventional, homogeneous SMP platforms are composed of purely identical "
"CPUs. Heterogeneous platforms on the other hand are composed of CPUs with "
"different performance characteristics - on such platforms, not all CPUs can "
"be considered equal."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:16
msgid ""
"CPU capacity is a measure of the performance a CPU can reach, normalized "
"against the most performant CPU in the system. Heterogeneous systems are "
"also called asymmetric CPU capacity systems, as they contain CPUs of "
"different capacities."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:20
msgid ""
"Disparity in maximum attainable performance (IOW in maximum CPU capacity) "
"stems from two factors:"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:23
msgid "not all CPUs may have the same microarchitecture (µarch)."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:24
msgid ""
"with Dynamic Voltage and Frequency Scaling (DVFS), not all CPUs may be "
"physically able to attain the higher Operating Performance Points (OPP)."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:27
msgid ""
"Arm big.LITTLE systems are an example of both. The big CPUs are more "
"performance-oriented than the LITTLE ones (more pipeline stages, bigger "
"caches, smarter predictors, etc), and can usually reach higher OPPs than the "
"LITTLE ones can."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:32
msgid ""
"CPU performance is usually expressed in Millions of Instructions Per Second "
"(MIPS), which can also be expressed as a given amount of instructions "
"attainable per Hz, leading to::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:39
msgid "1.2 Scheduler terms"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:41
msgid ""
"Two different capacity values are used within the scheduler. A CPU's "
"``original capacity`` is its maximum attainable capacity, i.e. its maximum "
"attainable performance level. This original capacity is returned by the "
"function arch_scale_cpu_capacity(). A CPU's ``capacity`` is its ``original "
"capacity`` to which some loss of available performance (e.g. time spent "
"handling IRQs) is subtracted."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:48
msgid ""
"Note that a CPU's ``capacity`` is solely intended to be used by the CFS "
"class, while ``original capacity`` is class-agnostic. The rest of this "
"document will use the term ``capacity`` interchangeably with ``original "
"capacity`` for the sake of brevity."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:54
msgid "1.3 Platform examples"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:57
msgid "1.3.1 Identical OPPs"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:59
msgid "Consider an hypothetical dual-core asymmetric CPU capacity system where"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:61
msgid "work_per_hz(CPU0) = W"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:62
msgid "work_per_hz(CPU1) = W/2"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:63
msgid "all CPUs are running at the same fixed frequency"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:65
msgid "By the above definition of capacity:"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:67
#: ../../../scheduler/sched-capacity.rst:101
msgid "capacity(CPU0) = C"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:68
msgid "capacity(CPU1) = C/2"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:70
msgid ""
"To draw the parallel with Arm big.LITTLE, CPU0 would be a big while CPU1 "
"would be a LITTLE."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:73
msgid ""
"With a workload that periodically does a fixed amount of work, you will get "
"an execution trace like so::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:86
msgid ""
"CPU0 has the highest capacity in the system (C), and completes a fixed "
"amount of work W in T units of time. On the other hand, CPU1 has half the "
"capacity of CPU0, and thus only completes W/2 in T."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:91
msgid "1.3.2 Different max OPPs"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:93
msgid ""
"Usually, CPUs of different capacity values also have different maximum OPPs. "
"Consider the same CPUs as above (i.e. same work_per_hz()) with:"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:96
msgid "max_freq(CPU0) = F"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:97
msgid "max_freq(CPU1) = 2/3 * F"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:99
msgid "This yields:"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:102
msgid "capacity(CPU1) = C/3"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:104
msgid ""
"Executing the same workload as described in 1.3.1, which each CPU running at "
"its maximum frequency results in::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:119
msgid "1.4 Representation caveat"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:121
msgid ""
"It should be noted that having a *single* value to represent differences in "
"CPU performance is somewhat of a contentious point. The relative performance "
"difference between two different µarchs could be X% on integer operations, "
"Y% on floating point operations, Z% on branches, and so on. Still, results "
"using this simple approach have been satisfactory for now."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:128
msgid "2. Task utilization"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:131
msgid "2.1 Introduction"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:133
msgid ""
"Capacity aware scheduling requires an expression of a task's requirements "
"with regards to CPU capacity. Each scheduler class can express this "
"differently, and while task utilization is specific to CFS, it is convenient "
"to describe it here in order to introduce more generic concepts."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:138
msgid ""
"Task utilization is a percentage meant to represent the throughput "
"requirements of a task. A simple approximation of it is the task's duty "
"cycle, i.e.::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:143
msgid ""
"On an SMP system with fixed frequencies, 100% utilization suggests the task "
"is a busy loop. Conversely, 10% utilization hints it is a small periodic "
"task that spends more time sleeping than executing. Variable CPU frequencies "
"and asymmetric CPU capacities complexify this somewhat; the following "
"sections will expand on these."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:150
msgid "2.2 Frequency invariance"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:152
msgid ""
"One issue that needs to be taken into account is that a workload's duty "
"cycle is directly impacted by the current OPP the CPU is running at. "
"Consider running a periodic workload at a given frequency F::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:161
msgid "This yields duty_cycle(p) == 25%."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:163
msgid "Now, consider running the *same* workload at frequency F/2::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:170
msgid ""
"This yields duty_cycle(p) == 50%, despite the task having the exact same "
"behaviour (i.e. executing the same amount of work) in both executions."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:173
msgid ""
"The task utilization signal can be made frequency invariant using the "
"following formula::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:178
msgid ""
"Applying this formula to the two examples above yields a frequency invariant "
"task utilization of 25%."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:182
msgid "2.3 CPU invariance"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:184
msgid ""
"CPU capacity has a similar effect on task utilization in that running an "
"identical workload on CPUs of different capacity values will yield different "
"duty cycles."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:188
msgid "Consider the system described in 1.3.2., i.e.::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:193
msgid ""
"Executing a given periodic workload on each CPU at their maximum frequency "
"would result in::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:206
msgid "IOW,"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:208
msgid "duty_cycle(p) == 25% if p runs on CPU0 at its maximum frequency"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:209
msgid "duty_cycle(p) == 75% if p runs on CPU1 at its maximum frequency"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:211
msgid ""
"The task utilization signal can be made CPU invariant using the following "
"formula::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:216
msgid ""
"with ``max_capacity`` being the highest CPU capacity value in the system. "
"Applying this formula to the above example above yields a CPU invariant task "
"utilization of 25%."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:221
msgid "2.4 Invariant task utilization"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:223
msgid ""
"Both frequency and CPU invariance need to be applied to task utilization in "
"order to obtain a truly invariant signal. The pseudo-formula for a task "
"utilization that is both CPU and frequency invariant is thus, for a given "
"task p::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:232
msgid ""
"In other words, invariant task utilization describes the behaviour of a task "
"as if it were running on the highest-capacity CPU in the system, running at "
"its maximum frequency."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:236
msgid ""
"Any mention of task utilization in the following sections will imply its "
"invariant form."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:240
msgid "2.5 Utilization estimation"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:242
msgid ""
"Without a crystal ball, task behaviour (and thus task utilization) cannot "
"accurately be predicted the moment a task first becomes runnable. The CFS "
"class maintains a handful of CPU and task signals based on the Per-Entity "
"Load Tracking (PELT) mechanism, one of those yielding an *average* "
"utilization (as opposed to instantaneous)."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:248
msgid ""
"This means that while the capacity aware scheduling criteria will be written "
"considering a \"true\" task utilization (using a crystal ball), the "
"implementation will only ever be able to use an estimator thereof."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:253
msgid "3. Capacity aware scheduling requirements"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:256
msgid "3.1 CPU capacity"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:258
msgid ""
"Linux cannot currently figure out CPU capacity on its own, this information "
"thus needs to be handed to it. Architectures must define "
"arch_scale_cpu_capacity() for that purpose."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:262
msgid ""
"The arm, arm64, and RISC-V architectures directly map this to the "
"arch_topology driver CPU scaling data, which is derived from the capacity-"
"dmips-mhz CPU binding; see Documentation/devicetree/bindings/cpu/cpu-"
"capacity.txt."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:267
msgid "3.2 Frequency invariance"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:269
msgid ""
"As stated in 2.2, capacity-aware scheduling requires a frequency-invariant "
"task utilization. Architectures must define arch_scale_freq_capacity(cpu) "
"for that purpose."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:273
msgid ""
"Implementing this function requires figuring out at which frequency each CPU "
"have been running at. One way to implement this is to leverage hardware "
"counters whose increment rate scale with a CPU's current frequency (APERF/"
"MPERF on x86, AMU on arm64). Another is to directly hook into cpufreq "
"frequency transitions, when the kernel is aware of the switched-to frequency "
"(also employed by arm/arm64)."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:281
msgid "4. Scheduler topology"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:283
msgid ""
"During the construction of the sched domains, the scheduler will figure out "
"whether the system exhibits asymmetric CPU capacities. Should that be the "
"case:"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:287
msgid "The sched_asym_cpucapacity static key will be enabled."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:288
msgid ""
"The SD_ASYM_CPUCAPACITY_FULL flag will be set at the lowest sched_domain "
"level that spans all unique CPU capacity values."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:290
msgid ""
"The SD_ASYM_CPUCAPACITY flag will be set for any sched_domain that spans "
"CPUs with any range of asymmetry."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:293
msgid ""
"The sched_asym_cpucapacity static key is intended to guard sections of code "
"that cater to asymmetric CPU capacity systems. Do note however that said key "
"is *system-wide*. Imagine the following setup using cpusets::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:304
msgid "Which could be created via:"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:318
msgid ""
"Since there *is* CPU capacity asymmetry in the system, the "
"sched_asym_cpucapacity static key will be enabled. However, the sched_domain "
"hierarchy of CPUs 0-1 spans a single capacity value: SD_ASYM_CPUCAPACITY "
"isn't set in that hierarchy, it describes an SMP island and should be "
"treated as such."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:323
msgid ""
"Therefore, the 'canonical' pattern for protecting codepaths that cater to "
"asymmetric CPU capacities is to:"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:326
msgid "Check the sched_asym_cpucapacity static key"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:327
msgid ""
"If it is enabled, then also check for the presence of SD_ASYM_CPUCAPACITY in "
"the sched_domain hierarchy (if relevant, i.e. the codepath targets a "
"specific CPU or group thereof)"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:332
msgid "5. Capacity aware scheduling implementation"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:335
msgid "5.1 CFS"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:338
msgid "5.1.1 Capacity fitness"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:340
msgid "The main capacity scheduling criterion of CFS is::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:344
msgid ""
"This is commonly called the capacity fitness criterion, i.e. CFS must ensure "
"a task \"fits\" on its CPU. If it is violated, the task will need to achieve "
"more work than what its CPU can provide: it will be CPU-bound."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:348
msgid ""
"Furthermore, uclamp lets userspace specify a minimum and a maximum "
"utilization value for a task, either via sched_setattr() or via the cgroup "
"interface (see Documentation/admin-guide/cgroup-v2.rst). As its name imply, "
"this can be used to clamp task_util() in the previous criterion."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:354
msgid "5.1.2 Wakeup CPU selection"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:356
msgid ""
"CFS task wakeup CPU selection follows the capacity fitness criterion "
"described above. On top of that, uclamp is used to clamp the task "
"utilization values, which lets userspace have more leverage over the CPU "
"selection of CFS tasks. IOW, CFS wakeup CPU selection searches for a CPU "
"that satisfies::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:363
msgid ""
"By using uclamp, userspace can e.g. allow a busy loop (100% utilization) to "
"run on any CPU by giving it a low uclamp.max value. Conversely, it can force "
"a small periodic task (e.g. 10% utilization) to run on the highest-"
"performance CPUs by giving it a high uclamp.min value."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:370
msgid ""
"Wakeup CPU selection in CFS can be eclipsed by Energy Aware Scheduling "
"(EAS), which is described in Documentation/scheduler/sched-energy.rst."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:374
msgid "5.1.3 Load balancing"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:376
msgid ""
"A pathological case in the wakeup CPU selection occurs when a task rarely "
"sleeps, if at all - it thus rarely wakes up, if at all. Consider::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:398
msgid "This workload should run on CPU0, but if the task either:"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:400
msgid ""
"was improperly scheduled from the start (inaccurate initial utilization "
"estimation)"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:402
msgid ""
"was properly scheduled from the start, but suddenly needs more processing "
"power"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:405
msgid ""
"then it might become CPU-bound, IOW ``task_util(p) > "
"capacity(task_cpu(p))``; the CPU capacity scheduling criterion is violated, "
"and there may not be any more wakeup event to fix this up via wakeup CPU "
"selection."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:409
msgid ""
"Tasks that are in this situation are dubbed \"misfit\" tasks, and the "
"mechanism put in place to handle this shares the same name. Misfit task "
"migration leverages the CFS load balancer, more specifically the active load "
"balance part (which caters to migrating currently running tasks). When load "
"balance happens, a misfit active load balance will be triggered if a misfit "
"task can be migrated to a CPU with more capacity than its current one."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:417
msgid "5.2 RT"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:420
msgid "5.2.1 Wakeup CPU selection"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:422
msgid "RT task wakeup CPU selection searches for a CPU that satisfies::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:426
msgid ""
"while still following the usual priority constraints. If none of the "
"candidate CPUs can satisfy this capacity criterion, then strict priority "
"based scheduling is followed and CPU capacities are ignored."
msgstr ""

#: ../../../scheduler/sched-capacity.rst:431
msgid "5.3 DL"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:434
msgid "5.3.1 Wakeup CPU selection"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:436
msgid "DL task wakeup CPU selection searches for a CPU that satisfies::"
msgstr ""

#: ../../../scheduler/sched-capacity.rst:440
msgid ""
"while still respecting the usual bandwidth and deadline constraints. If none "
"of the candidate CPUs can satisfy this capacity criterion, then the task "
"will remain on its current CPU."
msgstr ""
