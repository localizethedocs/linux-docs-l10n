# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-24 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../PCI/msi-howto.rst:6
msgid "The MSI Driver Guide HOWTO"
msgstr ""

#: ../../../PCI/msi-howto.rst:0
msgid "Authors"
msgstr ""

#: ../../../PCI/msi-howto.rst:8
msgid "Tom L Nguyen; Martine Silbermann; Matthew Wilcox"
msgstr ""

#: ../../../PCI/msi-howto.rst:0
msgid "Copyright"
msgstr ""

#: ../../../PCI/msi-howto.rst:10
msgid "2003, 2008 Intel Corporation"
msgstr ""

#: ../../../PCI/msi-howto.rst:13
msgid "About this guide"
msgstr ""

#: ../../../PCI/msi-howto.rst:15
msgid ""
"This guide describes the basics of Message Signaled Interrupts (MSIs), the "
"advantages of using MSI over traditional interrupt mechanisms, how to change "
"your driver to use MSI or MSI-X and some basic diagnostics to try if a "
"device doesn't support MSIs."
msgstr ""

#: ../../../PCI/msi-howto.rst:22
msgid "What are MSIs?"
msgstr ""

#: ../../../PCI/msi-howto.rst:24
msgid ""
"A Message Signaled Interrupt is a write from the device to a special address "
"which causes an interrupt to be received by the CPU."
msgstr ""

#: ../../../PCI/msi-howto.rst:27
msgid ""
"The MSI capability was first specified in PCI 2.2 and was later enhanced in "
"PCI 3.0 to allow each interrupt to be masked individually.  The MSI-X "
"capability was also introduced with PCI 3.0.  It supports more interrupts "
"per device than MSI and allows interrupts to be independently configured."
msgstr ""

#: ../../../PCI/msi-howto.rst:32
msgid ""
"Devices may support both MSI and MSI-X, but only one can be enabled at a "
"time."
msgstr ""

#: ../../../PCI/msi-howto.rst:37
msgid "Why use MSIs?"
msgstr ""

#: ../../../PCI/msi-howto.rst:39
msgid ""
"There are three reasons why using MSIs can give an advantage over "
"traditional pin-based interrupts."
msgstr ""

#: ../../../PCI/msi-howto.rst:42
msgid ""
"Pin-based PCI interrupts are often shared amongst several devices. To "
"support this, the kernel must call each interrupt handler associated with an "
"interrupt, which leads to reduced performance for the system as a whole.  "
"MSIs are never shared, so this problem cannot arise."
msgstr ""

#: ../../../PCI/msi-howto.rst:47
msgid ""
"When a device writes data to memory, then raises a pin-based interrupt, it "
"is possible that the interrupt may arrive before all the data has arrived in "
"memory (this becomes more likely with devices behind PCI-PCI bridges).  In "
"order to ensure that all the data has arrived in memory, the interrupt "
"handler must read a register on the device which raised the interrupt.  PCI "
"transaction ordering rules require that all the data arrive in memory before "
"the value may be returned from the register. Using MSIs avoids this problem "
"as the interrupt-generating write cannot pass the data writes, so by the "
"time the interrupt is raised, the driver knows that all the data has arrived "
"in memory."
msgstr ""

#: ../../../PCI/msi-howto.rst:58
msgid ""
"PCI devices can only support a single pin-based interrupt per function. "
"Often drivers have to query the device to find out what event has occurred, "
"slowing down interrupt handling for the common case.  With MSIs, a device "
"can support more interrupts, allowing each interrupt to be specialised to a "
"different purpose.  One possible design gives infrequent conditions (such as "
"errors) their own interrupt which allows the driver to handle the normal "
"interrupt handling path more efficiently. Other possible designs include "
"giving one interrupt to each packet queue in a network card or each port in "
"a storage controller."
msgstr ""

#: ../../../PCI/msi-howto.rst:70
msgid "How to use MSIs"
msgstr ""

#: ../../../PCI/msi-howto.rst:72
msgid ""
"PCI devices are initialised to use pin-based interrupts.  The device driver "
"has to set up the device to use MSI or MSI-X.  Not all machines support MSIs "
"correctly, and for those machines, the APIs described below will simply fail "
"and the device will continue to use pin-based interrupts."
msgstr ""

#: ../../../PCI/msi-howto.rst:78
msgid "Include kernel support for MSIs"
msgstr ""

#: ../../../PCI/msi-howto.rst:80
msgid ""
"To support MSI or MSI-X, the kernel must be built with the CONFIG_PCI_MSI "
"option enabled.  This option is only available on some architectures, and it "
"may depend on some other options also being set.  For example, on x86, you "
"must also enable X86_UP_APIC or SMP in order to see the CONFIG_PCI_MSI "
"option."
msgstr ""

#: ../../../PCI/msi-howto.rst:87
msgid "Using MSI"
msgstr ""

#: ../../../PCI/msi-howto.rst:89
msgid ""
"Most of the hard work is done for the driver in the PCI layer.  The driver "
"simply has to request that the PCI layer set up the MSI capability for this "
"device."
msgstr ""

#: ../../../PCI/msi-howto.rst:93
msgid ""
"To automatically use MSI or MSI-X interrupt vectors, use the following "
"function::"
msgstr ""

#: ../../../PCI/msi-howto.rst:99
msgid ""
"which allocates up to max_vecs interrupt vectors for a PCI device.  It "
"returns the number of vectors allocated or a negative error.  If the device "
"has a requirements for a minimum number of vectors the driver can pass a "
"min_vecs argument set to this limit, and the PCI core will return -ENOSPC if "
"it can't meet the minimum number of vectors."
msgstr ""

#: ../../../PCI/msi-howto.rst:105
msgid ""
"The flags argument is used to specify which type of interrupt can be used by "
"the device and the driver (PCI_IRQ_INTX, PCI_IRQ_MSI, PCI_IRQ_MSIX). A "
"convenient short-hand (PCI_IRQ_ALL_TYPES) is also available to ask for any "
"possible kind of interrupt.  If the PCI_IRQ_AFFINITY flag is set, "
"pci_alloc_irq_vectors() will spread the interrupts around the available CPUs."
msgstr ""

#: ../../../PCI/msi-howto.rst:111
msgid ""
"To get the Linux IRQ numbers passed to request_irq() and free_irq() and the "
"vectors, use the following function::"
msgstr ""

#: ../../../PCI/msi-howto.rst:116
msgid ""
"Any allocated resources should be freed before removing the device using the "
"following function::"
msgstr ""

#: ../../../PCI/msi-howto.rst:121
msgid ""
"If a device supports both MSI-X and MSI capabilities, this API will use the "
"MSI-X facilities in preference to the MSI facilities.  MSI-X supports any "
"number of interrupts between 1 and 2048.  In contrast, MSI is restricted to "
"a maximum of 32 interrupts (and must be a power of two).  In addition, the "
"MSI interrupt vectors must be allocated consecutively, so the system might "
"not be able to allocate as many vectors for MSI as it could for MSI-X.  On "
"some platforms, MSI interrupts must all be targeted at the same set of CPUs "
"whereas MSI-X interrupts can all be targeted at different CPUs."
msgstr ""

#: ../../../PCI/msi-howto.rst:130
msgid ""
"If a device supports neither MSI-X or MSI it will fall back to a single "
"legacy IRQ vector."
msgstr ""

#: ../../../PCI/msi-howto.rst:133
msgid ""
"The typical usage of MSI or MSI-X interrupts is to allocate as many vectors "
"as possible, likely up to the limit supported by the device.  If nvec is "
"larger than the number supported by the device it will automatically be "
"capped to the supported limit, so there is no need to query the number of "
"vectors supported beforehand::"
msgstr ""

#: ../../../PCI/msi-howto.rst:143
msgid ""
"If a driver is unable or unwilling to deal with a variable number of MSI "
"interrupts it can request a particular number of interrupts by passing that "
"number to pci_alloc_irq_vectors() function as both 'min_vecs' and 'max_vecs' "
"parameters::"
msgstr ""

#: ../../../PCI/msi-howto.rst:152
msgid ""
"The most notorious example of the request type described above is enabling "
"the single MSI mode for a device.  It could be done by passing two 1s as "
"'min_vecs' and 'max_vecs'::"
msgstr ""

#: ../../../PCI/msi-howto.rst:160
msgid ""
"Some devices might not support using legacy line interrupts, in which case "
"the driver can specify that only MSI or MSI-X is acceptable::"
msgstr ""

#: ../../../PCI/msi-howto.rst:168
msgid "Legacy APIs"
msgstr ""

#: ../../../PCI/msi-howto.rst:170
msgid ""
"The following old APIs to enable and disable MSI or MSI-X interrupts should "
"not be used in new code::"
msgstr ""

#: ../../../PCI/msi-howto.rst:179
msgid ""
"Additionally there are APIs to provide the number of supported MSI or MSI-X "
"vectors: pci_msi_vec_count() and pci_msix_vec_count().  In general these "
"should be avoided in favor of letting pci_alloc_irq_vectors() cap the number "
"of vectors.  If you have a legitimate special use case for the count of "
"vectors we might have to revisit that decision and add a "
"pci_nr_irq_vectors() helper that handles MSI and MSI-X transparently."
msgstr ""

#: ../../../PCI/msi-howto.rst:187
msgid "Considerations when using MSIs"
msgstr ""

#: ../../../PCI/msi-howto.rst:190
msgid "Spinlocks"
msgstr ""

#: ../../../PCI/msi-howto.rst:192
msgid ""
"Most device drivers have a per-device spinlock which is taken in the "
"interrupt handler.  With pin-based interrupts or a single MSI, it is not "
"necessary to disable interrupts (Linux guarantees the same interrupt will "
"not be re-entered).  If a device uses multiple interrupts, the driver must "
"disable interrupts while the lock is held.  If the device sends a different "
"interrupt, the driver will deadlock trying to recursively acquire the "
"spinlock.  Such deadlocks can be avoided by using spin_lock_irqsave() or "
"spin_lock_irq() which disable local interrupts and acquire the lock (see "
"Documentation/kernel-hacking/locking.rst)."
msgstr ""

#: ../../../PCI/msi-howto.rst:203
msgid "How to tell whether MSI/MSI-X is enabled on a device"
msgstr ""

#: ../../../PCI/msi-howto.rst:205
msgid ""
"Using 'lspci -v' (as root) may show some devices with \"MSI\", \"Message "
"Signalled Interrupts\" or \"MSI-X\" capabilities.  Each of these "
"capabilities has an 'Enable' flag which is followed with either \"+"
"\" (enabled) or \"-\" (disabled)."
msgstr ""

#: ../../../PCI/msi-howto.rst:212
msgid "MSI quirks"
msgstr ""

#: ../../../PCI/msi-howto.rst:214
msgid ""
"Several PCI chipsets or devices are known not to support MSIs. The PCI stack "
"provides three ways to disable MSIs:"
msgstr ""

#: ../../../PCI/msi-howto.rst:217
msgid "globally"
msgstr ""

#: ../../../PCI/msi-howto.rst:218
msgid "on all devices behind a specific bridge"
msgstr ""

#: ../../../PCI/msi-howto.rst:219
msgid "on a single device"
msgstr ""

#: ../../../PCI/msi-howto.rst:222
msgid "Disabling MSIs globally"
msgstr ""

#: ../../../PCI/msi-howto.rst:224
msgid ""
"Some host chipsets simply don't support MSIs properly.  If we're lucky, the "
"manufacturer knows this and has indicated it in the ACPI FADT table.  In "
"this case, Linux automatically disables MSIs. Some boards don't include this "
"information in the table and so we have to detect them ourselves.  The "
"complete list of these is found near the quirk_disable_all_msi() function in "
"drivers/pci/quirks.c."
msgstr ""

#: ../../../PCI/msi-howto.rst:231
msgid ""
"If you have a board which has problems with MSIs, you can pass pci=nomsi on "
"the kernel command line to disable MSIs on all devices.  It would be in your "
"best interests to report the problem to linux-pci@vger.kernel.org including "
"a full 'lspci -v' so we can add the quirks to the kernel."
msgstr ""

#: ../../../PCI/msi-howto.rst:237
msgid "Disabling MSIs below a bridge"
msgstr ""

#: ../../../PCI/msi-howto.rst:239
msgid ""
"Some PCI bridges are not able to route MSIs between buses properly. In this "
"case, MSIs must be disabled on all devices behind the bridge."
msgstr ""

#: ../../../PCI/msi-howto.rst:242
msgid ""
"Some bridges allow you to enable MSIs by changing some bits in their PCI "
"configuration space (especially the Hypertransport chipsets such as the "
"nVidia nForce and Serverworks HT2000).  As with host chipsets, Linux mostly "
"knows about them and automatically enables MSIs if it can. If you have a "
"bridge unknown to Linux, you can enable MSIs in configuration space using "
"whatever method you know works, then enable MSIs on that bridge by doing::"
msgstr ""

#: ../../../PCI/msi-howto.rst:252
msgid ""
"where $bridge is the PCI address of the bridge you've enabled (eg "
"0000:00:0e.0)."
msgstr ""

#: ../../../PCI/msi-howto.rst:255
msgid ""
"To disable MSIs, echo 0 instead of 1.  Changing this value should be done "
"with caution as it could break interrupt handling for all devices below this "
"bridge."
msgstr ""

#: ../../../PCI/msi-howto.rst:259
msgid ""
"Again, please notify linux-pci@vger.kernel.org of any bridges that need "
"special handling."
msgstr ""

#: ../../../PCI/msi-howto.rst:263
msgid "Disabling MSIs on a single device"
msgstr ""

#: ../../../PCI/msi-howto.rst:265
msgid ""
"Some devices are known to have faulty MSI implementations.  Usually this is "
"handled in the individual device driver, but occasionally it's necessary to "
"handle this with a quirk.  Some drivers have an option to disable use of "
"MSI.  While this is a convenient workaround for the driver author, it is not "
"good practice, and should not be emulated."
msgstr ""

#: ../../../PCI/msi-howto.rst:272
msgid "Finding why MSIs are disabled on a device"
msgstr ""

#: ../../../PCI/msi-howto.rst:274
msgid ""
"From the above three sections, you can see that there are many reasons why "
"MSIs may not be enabled for a given device.  Your first step should be to "
"examine your dmesg carefully to determine whether MSIs are enabled for your "
"machine.  You should also check your .config to be sure you have enabled "
"CONFIG_PCI_MSI."
msgstr ""

#: ../../../PCI/msi-howto.rst:280
msgid ""
"Then, 'lspci -t' gives the list of bridges above a device. Reading `/sys/bus/"
"pci/devices/*/msi_bus` will tell you whether MSIs are enabled (1) or "
"disabled (0).  If 0 is found in any of the msi_bus files belonging to "
"bridges between the PCI root and the device, MSIs are disabled."
msgstr ""

#: ../../../PCI/msi-howto.rst:285
msgid ""
"It is also worth checking the device driver to see whether it supports MSIs. "
"For example, it may contain calls to pci_alloc_irq_vectors() with the "
"PCI_IRQ_MSI or PCI_IRQ_MSIX flags."
msgstr ""

#: ../../../PCI/msi-howto.rst:291
msgid "List of device drivers MSI(-X) APIs"
msgstr ""

#: ../../../PCI/msi-howto.rst:293
msgid ""
"The PCI/MSI subsystem has a dedicated C file for its exported device driver "
"APIs â€” `drivers/pci/msi/api.c`. The following functions are exported:"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:17
msgid "Enable MSI interrupt mode on device"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:21
#: drivers/pci/msi/api.c:44 drivers/pci/msi/api.c:67 drivers/pci/msi/api.c:87
#: drivers/pci/msi/api.c:119 drivers/pci/msi/api.c:136
#: drivers/pci/msi/api.c:168 drivers/pci/msi/api.c:186
#: drivers/pci/msi/api.c:209 drivers/pci/msi/api.c:245
#: drivers/pci/msi/api.c:304 drivers/pci/msi/api.c:328
#: drivers/pci/msi/api.c:371 drivers/pci/msi/api.c:386
#: drivers/pci/msi/api.c:401
msgid "**Parameters**"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:23
#: drivers/pci/msi/api.c:46 drivers/pci/msi/api.c:69 drivers/pci/msi/api.c:89
#: drivers/pci/msi/api.c:121 drivers/pci/msi/api.c:138
#: drivers/pci/msi/api.c:170 drivers/pci/msi/api.c:188
#: drivers/pci/msi/api.c:211 drivers/pci/msi/api.c:247
#: drivers/pci/msi/api.c:306 drivers/pci/msi/api.c:330
#: drivers/pci/msi/api.c:373 drivers/pci/msi/api.c:388
msgid "``struct pci_dev *dev``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:18
#: drivers/pci/msi/api.c:41 drivers/pci/msi/api.c:64 drivers/pci/msi/api.c:84
#: drivers/pci/msi/api.c:183 drivers/pci/msi/api.c:206
#: drivers/pci/msi/api.c:243 drivers/pci/msi/api.c:301
#: drivers/pci/msi/api.c:325 drivers/pci/msi/api.c:368
#: drivers/pci/msi/api.c:383
msgid "the PCI device to operate on"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:20
#: drivers/pci/msi/api.c:43 drivers/pci/msi/api.c:89 drivers/pci/msi/api.c:142
#: drivers/pci/msi/api.c:169 drivers/pci/msi/api.c:185
#: drivers/pci/msi/api.c:211 drivers/pci/msi/api.c:249
#: drivers/pci/msi/api.c:305 drivers/pci/msi/api.c:329
#: drivers/pci/msi/api.c:370 drivers/pci/msi/api.c:385
msgid "**Description**"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:19
msgid ""
"Legacy device driver API to enable MSI interrupts mode on device and "
"allocate a single interrupt vector. On success, the allocated vector Linux "
"IRQ will be saved at **dev->irq**. The driver must invoke pci_disable_msi() "
"on cleanup."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:24
#: drivers/pci/msi/api.c:47 drivers/pci/msi/api.c:95 drivers/pci/msi/api.c:189
msgid "**NOTE**"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:25
#: drivers/pci/msi/api.c:48 drivers/pci/msi/api.c:96 drivers/pci/msi/api.c:190
msgid ""
"The newer pci_alloc_irq_vectors() / pci_free_irq_vectors() API pair should, "
"in general, be used instead."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:3 drivers/pci/msi/api.c:28
#: drivers/pci/msi/api.c:66 drivers/pci/msi/api.c:99 drivers/pci/msi/api.c:120
#: drivers/pci/msi/api.c:140 drivers/pci/msi/api.c:227
#: drivers/pci/msi/api.c:308 drivers/pci/msi/api.c:332
msgid "**Return**"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:28
msgid "0 on success, errno otherwise"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:40
msgid "Disable MSI interrupt mode on device"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:42
msgid ""
"Legacy device driver API to disable MSI interrupt mode on device, free "
"earlier allocated interrupt vectors, and restore INTx emulation. The PCI "
"device Linux IRQ (**dev->irq**) is restored to its default pin-assertion "
"IRQ. This is the cleanup pair of pci_enable_msi()."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:63
msgid "Get number of MSI-X interrupt vectors on device"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:66
msgid ""
"number of MSI-X interrupt vectors available on this device (i.e., the "
"device's MSI-X capability structure \"table size\"), -EINVAL if the device "
"is not MSI-X capable, other errnos otherwise."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:83
msgid "Enable MSI-X interrupt mode on device"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:86
msgid "``struct msix_entry *entries``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:85
msgid "input/output parameter, array of MSI-X configuration entries"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:87
msgid "``int minvec``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:86
msgid "minimum required number of MSI-X vectors"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:88
msgid "``int maxvec``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:87
msgid "maximum desired number of MSI-X vectors"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:88
msgid ""
"Legacy device driver API to enable MSI-X interrupt mode on device and "
"configure its MSI-X capability structure as appropriate.  The passed "
"**entries** array must have each of its members \"entry\" field set to a "
"desired (valid) MSI-X vector number, where the range of valid MSI-X vector "
"numbers can be queried through pci_msix_vec_count().  If successful, the "
"driver must invoke pci_disable_msix() on cleanup."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:99
msgid ""
"number of MSI-X vectors allocated (which might be smaller than **maxvecs**), "
"where Linux IRQ numbers for such allocated vectors are saved back in the "
"**entries** array elements' \"vector\" field. Return -ENOSPC if less than "
"**minvecs** interrupt vectors are available. Return -EINVAL if one of the "
"passed **entries** members \"entry\" field was invalid or a duplicate, or if "
"plain MSI interrupts mode was earlier enabled on device. Return other errnos "
"otherwise."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:115
msgid "Query whether dynamic allocation after enabling MSI-X is supported"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:118
#: drivers/pci/msi/api.c:135
msgid "PCI device to operate on"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:120
msgid "True if supported, false otherwise"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:132
msgid ""
"Allocate an MSI-X interrupt after enabling MSI-X at a given MSI-X vector "
"index or any free vector index"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:137
msgid "``unsigned int index``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:136
msgid ""
"Index to allocate. If **index** == MSI_ANY_INDEX this allocates the next "
"free index in the MSI-X table"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:139
msgid "``const struct irq_affinity_desc *affdesc``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:138
msgid "Optional pointer to an affinity descriptor structure. NULL otherwise"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:140
msgid "A struct msi_map"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:141
msgid ""
"On success msi_map::index contains the allocated index (>= 0) and msi_map::"
"virq contains the allocated Linux interrupt number (> 0)."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:144
msgid ""
"On fail msi_map::index contains the error code and msi_map::virq is set to 0."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:164
msgid "Free an interrupt on a PCI/MSI-X interrupt domain"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:166
msgid "The PCI device to operate on"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:168
msgid "``struct msi_map map``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:167
msgid "A struct msi_map describing the interrupt to free"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:168
msgid "Undo an interrupt vector allocation. Does not disable MSI-X."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:182
msgid "Disable MSI-X interrupt mode on device"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:184
msgid ""
"Legacy device driver API to disable MSI-X interrupt mode on device, free "
"earlier-allocated interrupt vectors, and restore INTx. The PCI device Linux "
"IRQ (**dev->irq**) is restored to its default pin assertion IRQ. This is the "
"cleanup pair of pci_enable_msix_range()."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:205
msgid "Allocate multiple device interrupt vectors"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:208
#: drivers/pci/msi/api.c:245
msgid "``unsigned int min_vecs``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:207
#: drivers/pci/msi/api.c:244
msgid "minimum required number of vectors (must be >= 1)"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:209
#: drivers/pci/msi/api.c:246
msgid "``unsigned int max_vecs``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:208
#: drivers/pci/msi/api.c:245
msgid "maximum desired number of vectors"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:210
#: drivers/pci/msi/api.c:247
msgid "``unsigned int flags``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:209
msgid "One or more of:"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:210
msgid "``PCI_IRQ_MSIX``      Allow trying MSI-X vector allocations"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:211
msgid "``PCI_IRQ_MSI``       Allow trying MSI vector allocations"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:213
msgid ""
"``PCI_IRQ_INTX``      Allow trying INTx interrupts, if and only if "
"**min_vecs** == 1"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:216
msgid ""
"``PCI_IRQ_AFFINITY``  Auto-manage IRQs affinity by spreading the vectors "
"around available CPUs"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:219
msgid ""
"Allocate up to **max_vecs** interrupt vectors on device. MSI-X irq vector "
"allocation has a higher precedence over plain MSI, which has a higher "
"precedence over legacy INTx emulation."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:223
msgid ""
"Upon a successful allocation, the caller should use pci_irq_vector() to get "
"the Linux IRQ number to be passed to request_threaded_irq(). The driver must "
"call pci_free_irq_vectors() on cleanup."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:228
msgid ""
"number of allocated vectors (which might be smaller than **max_vecs**), -"
"ENOSPC if less than **min_vecs** interrupt vectors are available, other "
"errnos otherwise."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:241
msgid "Allocate multiple device interrupt vectors with affinity requirements"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:246
msgid "allocation flags, as in pci_alloc_irq_vectors()"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:248
msgid "``struct irq_affinity *affd``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:247
msgid "affinity requirements (can be ``NULL``)."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:248
msgid ""
"Same as pci_alloc_irq_vectors(), but with the extra **affd** parameter. "
"Check that function docs, and :c:type:`struct irq_affinity <irq_affinity>`, "
"for more details."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:300
msgid "Get Linux IRQ number of a device interrupt vector"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:303
msgid "``unsigned int nr``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:302
#: drivers/pci/msi/api.c:326
msgid ""
"device-relative interrupt vector index (0-based); has different meanings, "
"depending on interrupt mode:"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:304
#: drivers/pci/msi/api.c:328
msgid "MSI-X     the index in the MSI-X vector table"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:305
#: drivers/pci/msi/api.c:329
msgid "MSI       the index of the enabled MSI vectors"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:306
#: drivers/pci/msi/api.c:330
msgid "INTx      must be 0"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:309
msgid "the Linux IRQ number, or -EINVAL if **nr** is out of range"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:324
msgid "Get a device interrupt vector affinity"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:327
msgid "``int nr``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:333
msgid ""
"MSI/MSI-X vector affinity, NULL if **nr** is out of range or if the MSI(-X) "
"vector was allocated without explicit affinity requirements (e.g., by "
"pci_enable_msi(), pci_enable_msix_range(), or pci_alloc_irq_vectors() "
"without the ``PCI_IRQ_AFFINITY`` flag). Return a generic set of CPU IDs "
"representing all possible CPUs available during system boot if the device is "
"in legacy INTx mode."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:367
msgid "Free previously allocated IRQs for a device"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:369
msgid ""
"Undo the interrupt vector allocations and possible device MSI/MSI-X "
"enablement earlier done through pci_alloc_irq_vectors_affinity() or "
"pci_alloc_irq_vectors()."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:382
msgid "Restore cached MSI(-X) state on device"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:384
msgid ""
"Write the Linux-cached MSI(-X) state back on device. This is typically "
"useful upon system resume, or after an error-recovery PCI adapter reset."
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:397
msgid "Are MSI(-X) interrupts enabled system-wide?"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:403
msgid "``void``"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:1
msgid "no arguments"
msgstr ""

#: ../../../PCI/msi-howto:382: drivers/pci/msi/api.c:399
msgid ""
"true if MSI has not been globally disabled through ACPI FADT, PCI bridge "
"quirks, or the \"pci=nomsi\" kernel command-line option."
msgstr ""
