# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/kfuncs.rst:7
msgid "BPF Kernel Functions (kfuncs)"
msgstr ""

#: ../../../bpf/kfuncs.rst:10
msgid "1. Introduction"
msgstr ""

#: ../../../bpf/kfuncs.rst:12
msgid ""
"BPF Kernel Functions or more commonly known as kfuncs are functions in the "
"Linux kernel which are exposed for use by BPF programs. Unlike normal BPF "
"helpers, kfuncs do not have a stable interface and can change from one "
"kernel release to another. Hence, BPF programs need to be updated in "
"response to changes in the kernel. See :ref:"
"`BPF_kfunc_lifecycle_expectations` for more information."
msgstr ""

#: ../../../bpf/kfuncs.rst:19
msgid "2. Defining a kfunc"
msgstr ""

#: ../../../bpf/kfuncs.rst:21
msgid ""
"There are two ways to expose a kernel function to BPF programs, either make "
"an existing function in the kernel visible, or add a new wrapper for BPF. In "
"both cases, care must be taken that BPF program can only call such function "
"in a valid context. To enforce this, visibility of a kfunc can be per "
"program type."
msgstr ""

#: ../../../bpf/kfuncs.rst:26
msgid ""
"If you are not creating a BPF wrapper for existing kernel function, skip "
"ahead to :ref:`BPF_kfunc_nodef`."
msgstr ""

#: ../../../bpf/kfuncs.rst:30
msgid "2.1 Creating a wrapper kfunc"
msgstr ""

#: ../../../bpf/kfuncs.rst:32
msgid ""
"When defining a wrapper kfunc, the wrapper function should have extern "
"linkage. This prevents the compiler from optimizing away dead code, as this "
"wrapper kfunc is not invoked anywhere in the kernel itself. It is not "
"necessary to provide a prototype in a header for the wrapper kfunc."
msgstr ""

#: ../../../bpf/kfuncs.rst:37 ../../../bpf/kfuncs.rst:85
#: ../../../bpf/kfuncs.rst:107 ../../../bpf/kfuncs.rst:126
#: ../../../bpf/kfuncs.rst:142 ../../../bpf/kfuncs.rst:169
msgid "An example is given below::"
msgstr ""

#: ../../../bpf/kfuncs.rst:49
msgid ""
"A wrapper kfunc is often needed when we need to annotate parameters of the "
"kfunc. Otherwise one may directly make the kfunc visible to the BPF program "
"by registering it with the BPF subsystem. See :ref:`BPF_kfunc_nodef`."
msgstr ""

#: ../../../bpf/kfuncs.rst:54
msgid "2.2 Annotating kfunc parameters"
msgstr ""

#: ../../../bpf/kfuncs.rst:56
msgid ""
"Similar to BPF helpers, there is sometime need for additional context "
"required by the verifier to make the usage of kernel functions safer and "
"more useful. Hence, we can annotate a parameter by suffixing the name of the "
"argument of the kfunc with a __tag, where tag may be one of the supported "
"annotations."
msgstr ""

#: ../../../bpf/kfuncs.rst:62
msgid "2.2.1 __sz Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:64
msgid ""
"This annotation is used to indicate a memory and size pair in the argument "
"list. An example is given below::"
msgstr ""

#: ../../../bpf/kfuncs.rst:72
msgid ""
"Here, the verifier will treat first argument as a PTR_TO_MEM, and second "
"argument as its size. By default, without __sz annotation, the size of the "
"type of the pointer is used. Without __sz annotation, a kfunc cannot accept "
"a void pointer."
msgstr ""

#: ../../../bpf/kfuncs.rst:78
msgid "2.2.2 __k Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:80
msgid ""
"This annotation is only understood for scalar arguments, where it indicates "
"that the verifier must check the scalar argument to be a known constant, "
"which does not indicate a size parameter, and the value of the constant is "
"relevant to the safety of the program."
msgstr ""

#: ../../../bpf/kfuncs.rst:92
msgid ""
"Here, bpf_obj_new uses local_type_id argument to find out the size of that "
"type ID in program's BTF and return a sized pointer to it. Each type ID will "
"have a distinct size, hence it is crucial to treat each such call as "
"distinct when values don't match during verifier state pruning checks."
msgstr ""

#: ../../../bpf/kfuncs.rst:97
msgid ""
"Hence, whenever a constant scalar argument is accepted by a kfunc which is "
"not a size parameter, and the value of the constant matters for program "
"safety, __k suffix should be used."
msgstr ""

#: ../../../bpf/kfuncs.rst:102
msgid "2.2.3 __uninit Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:104
msgid ""
"This annotation is used to indicate that the argument will be treated as "
"uninitialized."
msgstr ""

#: ../../../bpf/kfuncs.rst:114
msgid ""
"Here, the dynptr will be treated as an uninitialized dynptr. Without this "
"annotation, the verifier will reject the program if the dynptr passed in is "
"not initialized."
msgstr ""

#: ../../../bpf/kfuncs.rst:119
msgid "2.2.4 __opt Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:121
msgid ""
"This annotation is used to indicate that the buffer associated with an __sz "
"or __szk argument may be null. If the function is passed a nullptr in place "
"of the buffer, the verifier will not check that length is appropriate for "
"the buffer. The kfunc is responsible for checking if this buffer is null "
"before using it."
msgstr ""

#: ../../../bpf/kfuncs.rst:133
msgid ""
"Here, the buffer may be null. If buffer is not null, it at least of size "
"buffer_szk. Either way, the returned buffer is either NULL, or of size "
"buffer_szk. Without this annotation, the verifier will reject the program if "
"a null pointer is passed in with a nonzero size."
msgstr ""

#: ../../../bpf/kfuncs.rst:139
msgid "2.2.5 __str Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:140
msgid ""
"This annotation is used to indicate that the argument is a constant string."
msgstr ""

#: ../../../bpf/kfuncs.rst:149
msgid "In this case, ``bpf_get_file_xattr()`` can be called as::"
msgstr ""

#: ../../../bpf/kfuncs.rst:153
msgid "Or::"
msgstr ""

#: ../../../bpf/kfuncs.rst:164
msgid "2.2.6 __prog Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:165
msgid ""
"This annotation is used to indicate that the argument needs to be fixed up "
"to the bpf_prog_aux of the caller BPF program. Any value passed into this "
"argument is ignored, and rewritten by the verifier."
msgstr ""

#: ../../../bpf/kfuncs.rst:183
msgid "2.3 Using an existing kernel function"
msgstr ""

#: ../../../bpf/kfuncs.rst:185
msgid ""
"When an existing function in the kernel is fit for consumption by BPF "
"programs, it can be directly registered with the BPF subsystem. However, "
"care must still be taken to review the context in which it will be invoked "
"by the BPF program and whether it is safe to do so."
msgstr ""

#: ../../../bpf/kfuncs.rst:191
msgid "2.4 Annotating kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:193
msgid ""
"In addition to kfuncs' arguments, verifier may need more information about "
"the type of kfunc(s) being registered with the BPF subsystem. To do so, we "
"define flags on a set of kfuncs as follows::"
msgstr ""

#: ../../../bpf/kfuncs.rst:202
msgid ""
"This set encodes the BTF ID of each kfunc listed above, and encodes the "
"flags along with it. Ofcourse, it is also allowed to specify no flags."
msgstr ""

#: ../../../bpf/kfuncs.rst:205
msgid ""
"kfunc definitions should also always be annotated with the ``__bpf_kfunc`` "
"macro. This prevents issues such as the compiler inlining the kfunc if it's "
"a static kernel function, or the function being elided in an LTO build as "
"it's not used in the rest of the kernel. Developers should not manually add "
"annotations to their kfunc to prevent these issues. If an annotation is "
"required to prevent such an issue with your kfunc, it is a bug and should be "
"added to the definition of the macro so that other kfuncs are similarly "
"protected. An example is given below::"
msgstr ""

#: ../../../bpf/kfuncs.rst:220
msgid "2.4.1 KF_ACQUIRE flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:222
msgid ""
"The KF_ACQUIRE flag is used to indicate that the kfunc returns a pointer to "
"a refcounted object. The verifier will then ensure that the pointer to the "
"object is eventually released using a release kfunc, or transferred to a map "
"using a referenced kptr (by invoking bpf_kptr_xchg). If not, the verifier "
"fails the loading of the BPF program until no lingering references remain in "
"all possible explored states of the program."
msgstr ""

#: ../../../bpf/kfuncs.rst:230
msgid "2.4.2 KF_RET_NULL flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:232
msgid ""
"The KF_RET_NULL flag is used to indicate that the pointer returned by the "
"kfunc may be NULL. Hence, it forces the user to do a NULL check on the "
"pointer returned from the kfunc before making use of it (dereferencing or "
"passing to another helper). This flag is often used in pairing with "
"KF_ACQUIRE flag, but both are orthogonal to each other."
msgstr ""

#: ../../../bpf/kfuncs.rst:239
msgid "2.4.3 KF_RELEASE flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:241
msgid ""
"The KF_RELEASE flag is used to indicate that the kfunc releases the pointer "
"passed in to it. There can be only one referenced pointer that can be passed "
"in. All copies of the pointer being released are invalidated as a result of "
"invoking kfunc with this flag. KF_RELEASE kfuncs automatically receive the "
"protection afforded by the KF_TRUSTED_ARGS flag described below."
msgstr ""

#: ../../../bpf/kfuncs.rst:248
msgid "2.4.4 KF_TRUSTED_ARGS flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:250
msgid ""
"The KF_TRUSTED_ARGS flag is used for kfuncs taking pointer arguments. It "
"indicates that the all pointer arguments are valid, and that all pointers to "
"BTF objects have been passed in their unmodified form (that is, at a zero "
"offset, and without having been obtained from walking another pointer, with "
"one exception described below)."
msgstr ""

#: ../../../bpf/kfuncs.rst:256
msgid ""
"There are two types of pointers to kernel objects which are considered "
"\"valid\":"
msgstr ""

#: ../../../bpf/kfuncs.rst:258
msgid ""
"Pointers which are passed as tracepoint or struct_ops callback arguments."
msgstr ""

#: ../../../bpf/kfuncs.rst:259
msgid "Pointers which were returned from a KF_ACQUIRE kfunc."
msgstr ""

#: ../../../bpf/kfuncs.rst:261
msgid ""
"Pointers to non-BTF objects (e.g. scalar pointers) may also be passed to "
"KF_TRUSTED_ARGS kfuncs, and may have a non-zero offset."
msgstr ""

#: ../../../bpf/kfuncs.rst:264
msgid ""
"The definition of \"valid\" pointers is subject to change at any time, and "
"has absolutely no ABI stability guarantees."
msgstr ""

#: ../../../bpf/kfuncs.rst:267
msgid ""
"As mentioned above, a nested pointer obtained from walking a trusted pointer "
"is no longer trusted, with one exception. If a struct type has a field that "
"is guaranteed to be valid (trusted or rcu, as in KF_RCU description below) "
"as long as its parent pointer is valid, the following macros can be used to "
"express that to the verifier:"
msgstr ""

#: ../../../bpf/kfuncs.rst:273
msgid "``BTF_TYPE_SAFE_TRUSTED``"
msgstr ""

#: ../../../bpf/kfuncs.rst:274
msgid "``BTF_TYPE_SAFE_RCU``"
msgstr ""

#: ../../../bpf/kfuncs.rst:275
msgid "``BTF_TYPE_SAFE_RCU_OR_NULL``"
msgstr ""

#: ../../../bpf/kfuncs.rst:277
msgid "For example,"
msgstr ""

#: ../../../bpf/kfuncs.rst:285
msgid "or"
msgstr ""

#: ../../../bpf/kfuncs.rst:296
msgid "In other words, you must:"
msgstr ""

#: ../../../bpf/kfuncs.rst:298
msgid "Wrap the valid pointer type in a ``BTF_TYPE_SAFE_*`` macro."
msgstr ""

#: ../../../bpf/kfuncs.rst:300
msgid ""
"Specify the type and name of the valid nested field. This field must match "
"the field in the original type definition exactly."
msgstr ""

#: ../../../bpf/kfuncs.rst:303
msgid ""
"A new type declared by a ``BTF_TYPE_SAFE_*`` macro also needs to be emitted "
"so that it appears in BTF. For example, ``BTF_TYPE_SAFE_TRUSTED(struct "
"socket)`` is emitted in the ``type_is_trusted()`` function as follows:"
msgstr ""

#: ../../../bpf/kfuncs.rst:313
msgid "2.4.5 KF_SLEEPABLE flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:315
msgid ""
"The KF_SLEEPABLE flag is used for kfuncs that may sleep. Such kfuncs can "
"only be called by sleepable BPF programs (BPF_F_SLEEPABLE)."
msgstr ""

#: ../../../bpf/kfuncs.rst:319
msgid "2.4.6 KF_DESTRUCTIVE flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:321
msgid ""
"The KF_DESTRUCTIVE flag is used to indicate functions calling which is "
"destructive to the system. For example such a call can result in system "
"rebooting or panicking. Due to this additional restrictions apply to these "
"calls. At the moment they only require CAP_SYS_BOOT capability, but more can "
"be added later."
msgstr ""

#: ../../../bpf/kfuncs.rst:328
msgid "2.4.7 KF_RCU flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:330
msgid ""
"The KF_RCU flag is a weaker version of KF_TRUSTED_ARGS. The kfuncs marked "
"with KF_RCU expect either PTR_TRUSTED or MEM_RCU arguments. The verifier "
"guarantees that the objects are valid and there is no use-after-free. The "
"pointers are not NULL, but the object's refcount could have reached zero. "
"The kfuncs need to consider doing refcnt != 0 check, especially when "
"returning a KF_ACQUIRE pointer. Note as well that a KF_ACQUIRE kfunc that is "
"KF_RCU should very likely also be KF_RET_NULL."
msgstr ""

#: ../../../bpf/kfuncs.rst:341
msgid "2.4.8 KF_DEPRECATED flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:343
msgid ""
"The KF_DEPRECATED flag is used for kfuncs which are scheduled to be changed "
"or removed in a subsequent kernel release. A kfunc that is marked with "
"KF_DEPRECATED should also have any relevant information captured in its "
"kernel doc. Such information typically includes the kfunc's expected "
"remaining lifespan, a recommendation for new functionality that can replace "
"it if any is available, and possibly a rationale for why it is being removed."
msgstr ""

#: ../../../bpf/kfuncs.rst:351
msgid ""
"Note that while on some occasions, a KF_DEPRECATED kfunc may continue to be "
"supported and have its KF_DEPRECATED flag removed, it is likely to be far "
"more difficult to remove a KF_DEPRECATED flag after it's been added than it "
"is to prevent it from being added in the first place. As described in :ref:"
"`BPF_kfunc_lifecycle_expectations`, users that rely on specific kfuncs are "
"encouraged to make their use-cases known as early as possible, and "
"participate in upstream discussions regarding whether to keep, change, "
"deprecate, or remove those kfuncs if and when such discussions occur."
msgstr ""

#: ../../../bpf/kfuncs.rst:361
msgid "2.5 Registering the kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:363
msgid ""
"Once the kfunc is prepared for use, the final step to making it visible is "
"registering it with the BPF subsystem. Registration is done per BPF program "
"type. An example is shown below::"
msgstr ""

#: ../../../bpf/kfuncs.rst:384
msgid "2.6  Specifying no-cast aliases with ___init"
msgstr ""

#: ../../../bpf/kfuncs.rst:386
msgid ""
"The verifier will always enforce that the BTF type of a pointer passed to a "
"kfunc by a BPF program, matches the type of pointer specified in the kfunc "
"definition. The verifier, does, however, allow types that are equivalent "
"according to the C standard to be passed to the same kfunc arg, even if "
"their BTF_IDs differ."
msgstr ""

#: ../../../bpf/kfuncs.rst:392
msgid "For example, for the following type definition:"
msgstr ""

#: ../../../bpf/kfuncs.rst:401
msgid ""
"The verifier would allow a ``struct bpf_cpumask *`` to be passed to a kfunc "
"taking a ``cpumask_t *`` (which is a typedef of ``struct cpumask *``). For "
"instance, both ``struct cpumask *`` and ``struct bpf_cpmuask *`` can be "
"passed to bpf_cpumask_test_cpu()."
msgstr ""

#: ../../../bpf/kfuncs.rst:406
msgid ""
"In some cases, this type-aliasing behavior is not desired. ``struct "
"nf_conn___init`` is one such example:"
msgstr ""

#: ../../../bpf/kfuncs.rst:415
msgid ""
"The C standard would consider these types to be equivalent, but it would not "
"always be safe to pass either type to a trusted kfunc. ``struct "
"nf_conn___init`` represents an allocated ``struct nf_conn`` object that has "
"*not yet been initialized*, so it would therefore be unsafe to pass a "
"``struct nf_conn___init *`` to a kfunc that's expecting a fully initialized "
"``struct nf_conn *`` (e.g. ``bpf_ct_change_timeout()``)."
msgstr ""

#: ../../../bpf/kfuncs.rst:422
msgid ""
"In order to accommodate such requirements, the verifier will enforce strict "
"PTR_TO_BTF_ID type matching if two types have the exact same name, with one "
"being suffixed with ``___init``."
msgstr ""

#: ../../../bpf/kfuncs.rst:429
msgid "3. kfunc lifecycle expectations"
msgstr ""

#: ../../../bpf/kfuncs.rst:431
msgid ""
"kfuncs provide a kernel <-> kernel API, and thus are not bound by any of the "
"strict stability restrictions associated with kernel <-> user UAPIs. This "
"means they can be thought of as similar to EXPORT_SYMBOL_GPL, and can "
"therefore be modified or removed by a maintainer of the subsystem they're "
"defined in when it's deemed necessary."
msgstr ""

#: ../../../bpf/kfuncs.rst:437
msgid ""
"Like any other change to the kernel, maintainers will not change or remove a "
"kfunc without having a reasonable justification.  Whether or not they'll "
"choose to change a kfunc will ultimately depend on a variety of factors, "
"such as how widely used the kfunc is, how long the kfunc has been in the "
"kernel, whether an alternative kfunc exists, what the norm is in terms of "
"stability for the subsystem in question, and of course what the technical "
"cost is of continuing to support the kfunc."
msgstr ""

#: ../../../bpf/kfuncs.rst:445
msgid "There are several implications of this:"
msgstr ""

#: ../../../bpf/kfuncs.rst:447
msgid ""
"kfuncs that are widely used or have been in the kernel for a long time will "
"be more difficult to justify being changed or removed by a maintainer. In "
"other words, kfuncs that are known to have a lot of users and provide "
"significant value provide stronger incentives for maintainers to invest the "
"time and complexity in supporting them. It is therefore important for "
"developers that are using kfuncs in their BPF programs to communicate and "
"explain how and why those kfuncs are being used, and to participate in "
"discussions regarding those kfuncs when they occur upstream."
msgstr ""

#: ../../../bpf/kfuncs.rst:456
msgid ""
"Unlike regular kernel symbols marked with EXPORT_SYMBOL_GPL, BPF programs "
"that call kfuncs are generally not part of the kernel tree. This means that "
"refactoring cannot typically change callers in-place when a kfunc changes, "
"as is done for e.g. an upstreamed driver being updated in place when a "
"kernel symbol is changed."
msgstr ""

#: ../../../bpf/kfuncs.rst:462
msgid ""
"Unlike with regular kernel symbols, this is expected behavior for BPF "
"symbols, and out-of-tree BPF programs that use kfuncs should be considered "
"relevant to discussions and decisions around modifying and removing those "
"kfuncs. The BPF community will take an active role in participating in "
"upstream discussions when necessary to ensure that the perspectives of such "
"users are taken into account."
msgstr ""

#: ../../../bpf/kfuncs.rst:469
msgid ""
"A kfunc will never have any hard stability guarantees. BPF APIs cannot and "
"will not ever hard-block a change in the kernel purely for stability "
"reasons. That being said, kfuncs are features that are meant to solve "
"problems and provide value to users. The decision of whether to change or "
"remove a kfunc is a multivariate technical decision that is made on a case-"
"by-case basis, and which is informed by data points such as those mentioned "
"above. It is expected that a kfunc being removed or changed with no warning "
"will not be a common occurrence or take place without sound justification, "
"but it is a possibility that must be accepted if one is to use kfuncs."
msgstr ""

#: ../../../bpf/kfuncs.rst:481
msgid "3.1 kfunc deprecation"
msgstr ""

#: ../../../bpf/kfuncs.rst:483
msgid ""
"As described above, while sometimes a maintainer may find that a kfunc must "
"be changed or removed immediately to accommodate some changes in their "
"subsystem, usually kfuncs will be able to accommodate a longer and more "
"measured deprecation process. For example, if a new kfunc comes along which "
"provides superior functionality to an existing kfunc, the existing kfunc may "
"be deprecated for some period of time to allow users to migrate their BPF "
"programs to use the new one. Or, if a kfunc has no known users, a decision "
"may be made to remove the kfunc (without providing an alternative API) after "
"some deprecation period so as to provide users with a window to notify the "
"kfunc maintainer if it turns out that the kfunc is actually being used."
msgstr ""

#: ../../../bpf/kfuncs.rst:494
msgid ""
"It's expected that the common case will be that kfuncs will go through a "
"deprecation period rather than being changed or removed without warning. As "
"described in :ref:`KF_deprecated_flag`, the kfunc framework provides the "
"KF_DEPRECATED flag to kfunc developers to signal to users that a kfunc has "
"been deprecated. Once a kfunc has been marked with KF_DEPRECATED, the "
"following procedure is followed for removal:"
msgstr ""

#: ../../../bpf/kfuncs.rst:501
msgid ""
"Any relevant information for deprecated kfuncs is documented in the kfunc's "
"kernel docs. This documentation will typically include the kfunc's expected "
"remaining lifespan, a recommendation for new functionality that can replace "
"the usage of the deprecated function (or an explanation as to why no such "
"replacement exists), etc."
msgstr ""

#: ../../../bpf/kfuncs.rst:507
msgid ""
"The deprecated kfunc is kept in the kernel for some period of time after it "
"was first marked as deprecated. This time period will be chosen on a case-by-"
"case basis, and will typically depend on how widespread the use of the kfunc "
"is, how long it has been in the kernel, and how hard it is to move to "
"alternatives. This deprecation time period is \"best effort\", and as "
"described :ref:`above<BPF_kfunc_lifecycle_expectations>`, circumstances may "
"sometimes dictate that the kfunc be removed before the full intended "
"deprecation period has elapsed."
msgstr ""

#: ../../../bpf/kfuncs.rst:516
msgid ""
"After the deprecation period the kfunc will be removed. At this point, BPF "
"programs calling the kfunc will be rejected by the verifier."
msgstr ""

#: ../../../bpf/kfuncs.rst:520
msgid "4. Core kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:522
msgid ""
"The BPF subsystem provides a number of \"core\" kfuncs that are potentially "
"applicable to a wide variety of different possible use cases and programs. "
"Those kfuncs are documented here."
msgstr ""

#: ../../../bpf/kfuncs.rst:527
msgid "4.1 struct task_struct * kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:529
msgid ""
"There are a number of kfuncs that allow ``struct task_struct *`` objects to "
"be used as kptrs:"
msgstr ""

#: ../../../bpf/kfuncs:532: kernel/bpf/helpers.c:2455
msgid ""
"Acquire a reference to a task. A task acquired by this kfunc which is not "
"stored in a map as a kptr, must be released by calling bpf_task_release()."
msgstr ""

#: ../../../bpf/kfuncs:532: kernel/bpf/helpers.c:2459 kernel/bpf/helpers.c:2472
#: ../../../bpf/kfuncs:604: kernel/bpf/helpers.c:2618 ../../../bpf/kfuncs:644:
#: kernel/bpf/helpers.c:2488 kernel/bpf/helpers.c:2499 ../../../bpf/kfuncs:657:
#: kernel/bpf/helpers.c:2517 ../../../bpf/kfuncs:660: kernel/bpf/helpers.c:2538
msgid "**Parameters**"
msgstr ""

#: ../../../bpf/kfuncs:532: kernel/bpf/helpers.c:2461 kernel/bpf/helpers.c:2474
msgid "``struct task_struct *p``"
msgstr ""

#: ../../../bpf/kfuncs:532: kernel/bpf/helpers.c:2458
msgid "The task on which a reference is being acquired."
msgstr ""

#: ../../../bpf/kfuncs:532: kernel/bpf/helpers.c:2468
msgid "Release the reference acquired on a task."
msgstr ""

#: ../../../bpf/kfuncs:532: kernel/bpf/helpers.c:2469
msgid "The task on which a reference is being released."
msgstr ""

#: ../../../bpf/kfuncs.rst:535
msgid ""
"These kfuncs are useful when you want to acquire or release a reference to a "
"``struct task_struct *`` that was passed as e.g. a tracepoint arg, or a "
"struct_ops callback arg. For example:"
msgstr ""

#: ../../../bpf/kfuncs.rst:562
msgid ""
"References acquired on ``struct task_struct *`` objects are RCU protected. "
"Therefore, when in an RCU read region, you can obtain a pointer to a task "
"embedded in a map value without having to acquire a reference:"
msgstr ""

#: ../../../bpf/kfuncs.rst:600
msgid ""
"A BPF program can also look up a task from a pid. This can be useful if the "
"caller doesn't have a trusted pointer to a ``struct task_struct *`` object "
"that it can acquire a reference on with bpf_task_acquire()."
msgstr ""

#: ../../../bpf/kfuncs:604: kernel/bpf/helpers.c:2614
msgid ""
"Find a struct task_struct from its pid by looking it up in the root pid "
"namespace idr. If a task is returned, it must either be stored in a map, or "
"released with bpf_task_release()."
msgstr ""

#: ../../../bpf/kfuncs:604: kernel/bpf/helpers.c:2620
msgid "``s32 pid``"
msgstr ""

#: ../../../bpf/kfuncs:604: kernel/bpf/helpers.c:2617
msgid "The pid of the task being looked up."
msgstr ""

#: ../../../bpf/kfuncs.rst:607
msgid "Here is an example of it being used:"
msgstr ""

#: ../../../bpf/kfuncs.rst:640
msgid "4.2 struct cgroup * kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:642
msgid "``struct cgroup *`` objects also have acquire and release functions:"
msgstr ""

#: ../../../bpf/kfuncs:644: kernel/bpf/helpers.c:2484
msgid ""
"Acquire a reference to a cgroup. A cgroup acquired by this kfunc which is "
"not stored in a map as a kptr, must be released by calling "
"bpf_cgroup_release()."
msgstr ""

#: ../../../bpf/kfuncs:644: kernel/bpf/helpers.c:2490 kernel/bpf/helpers.c:2501
#: ../../../bpf/kfuncs:657: kernel/bpf/helpers.c:2519
msgid "``struct cgroup *cgrp``"
msgstr ""

#: ../../../bpf/kfuncs:644: kernel/bpf/helpers.c:2487
msgid "The cgroup on which a reference is being acquired."
msgstr ""

#: ../../../bpf/kfuncs:644: kernel/bpf/helpers.c:2495
msgid ""
"Release the reference acquired on a cgroup. If this kfunc is invoked in an "
"RCU read region, the cgroup is guaranteed to not be freed until the current "
"grace period has ended, even if its refcount drops to 0."
msgstr ""

#: ../../../bpf/kfuncs:644: kernel/bpf/helpers.c:2499
msgid "The cgroup on which a reference is being released."
msgstr ""

#: ../../../bpf/kfuncs.rst:647
msgid ""
"These kfuncs are used in exactly the same manner as bpf_task_acquire() and "
"bpf_task_release() respectively, so we won't provide examples for them."
msgstr ""

#: ../../../bpf/kfuncs.rst:652
msgid ""
"Other kfuncs available for interacting with ``struct cgroup *`` objects are "
"bpf_cgroup_ancestor() and bpf_cgroup_from_id(), allowing callers to access "
"the ancestor of a cgroup and find a cgroup by its ID, respectively. Both "
"return a cgroup kptr."
msgstr ""

#: ../../../bpf/kfuncs:657: kernel/bpf/helpers.c:2513
msgid ""
"Perform a lookup on an entry in a cgroup's ancestor array. A cgroup returned "
"by this kfunc which is not subsequently stored in a map, must be released by "
"calling bpf_cgroup_release()."
msgstr ""

#: ../../../bpf/kfuncs:657: kernel/bpf/helpers.c:2516
msgid "The cgroup for which we're performing a lookup."
msgstr ""

#: ../../../bpf/kfuncs:657: kernel/bpf/helpers.c:2518
msgid "``int level``"
msgstr ""

#: ../../../bpf/kfuncs:657: kernel/bpf/helpers.c:2517
msgid "The level of ancestor to look up."
msgstr ""

#: ../../../bpf/kfuncs:660: kernel/bpf/helpers.c:2534
msgid ""
"Find a cgroup from its ID. A cgroup returned by this kfunc which is not "
"subsequently stored in a map, must be released by calling "
"bpf_cgroup_release()."
msgstr ""

#: ../../../bpf/kfuncs:660: kernel/bpf/helpers.c:2540
msgid "``u64 cgid``"
msgstr ""

#: ../../../bpf/kfuncs:660: kernel/bpf/helpers.c:2537
msgid "cgroup id."
msgstr ""

#: ../../../bpf/kfuncs.rst:663
msgid ""
"Eventually, BPF should be updated to allow this to happen with a normal "
"memory load in the program itself. This is currently not possible without "
"more work in the verifier. bpf_cgroup_ancestor() can be used as follows:"
msgstr ""

#: ../../../bpf/kfuncs.rst:691
msgid "4.3 struct cpumask * kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:693
msgid ""
"BPF provides a set of kfuncs that can be used to query, allocate, mutate, "
"and destroy struct cpumask * objects. Please refer to :ref:`cpumasks-header-"
"label` for more details."
msgstr ""
