# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-20 11:24+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/dma-api.rst:3
msgid "Dynamic DMA mapping using the generic device"
msgstr ""

#: ../../../core-api/dma-api.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/dma-api.rst:5
msgid "James E.J. Bottomley <James.Bottomley@HansenPartnership.com>"
msgstr ""

#: ../../../core-api/dma-api.rst:7
msgid ""
"This document describes the DMA API.  For a more gentle introduction of the "
"API (and actual examples), see Documentation/core-api/dma-api-howto.rst."
msgstr ""

#: ../../../core-api/dma-api.rst:10
msgid ""
"This API is split into two pieces.  Part I describes the basic API. Part II "
"describes extensions for supporting non-coherent memory machines.  Unless "
"you know that your driver absolutely has to support non-coherent platforms "
"(this is usually only legacy platforms) you should only use the API "
"described in part I."
msgstr ""

#: ../../../core-api/dma-api.rst:17
msgid "Part I - DMA API"
msgstr ""

#: ../../../core-api/dma-api.rst:19
msgid ""
"To get the DMA API, you must #include <linux/dma-mapping.h>.  This provides "
"dma_addr_t and the interfaces described below."
msgstr ""

#: ../../../core-api/dma-api.rst:22
msgid ""
"A dma_addr_t can hold any valid DMA address for the platform.  It can be "
"given to a device to use as a DMA source or target.  A CPU cannot reference "
"a dma_addr_t directly because there may be translation between its physical "
"address space and the DMA address space."
msgstr ""

#: ../../../core-api/dma-api.rst:28
msgid "Part Ia - Using large DMA-coherent buffers"
msgstr ""

#: ../../../core-api/dma-api.rst:36
msgid ""
"Coherent memory is memory for which a write by either the device or the "
"processor can immediately be read by the processor or device without having "
"to worry about caching effects.  (You may however need to make sure to flush "
"the processor's write buffers before telling devices to read that memory.)"
msgstr ""

#: ../../../core-api/dma-api.rst:42
msgid "This routine allocates a region of <size> bytes of coherent memory."
msgstr ""

#: ../../../core-api/dma-api.rst:44
msgid ""
"It returns a pointer to the allocated region (in the processor's virtual "
"address space) or NULL if the allocation failed."
msgstr ""

#: ../../../core-api/dma-api.rst:47 ../../../core-api/dma-api.rst:571
msgid ""
"It also returns a <dma_handle> which may be cast to an unsigned integer the "
"same width as the bus and given to the device as the DMA address base of the "
"region."
msgstr ""

#: ../../../core-api/dma-api.rst:51
msgid ""
"Note: coherent memory can be expensive on some platforms, and the minimum "
"allocation length may be as big as a page, so you should consolidate your "
"requests for coherent memory as much as possible. The simplest way to do "
"that is to use the dma_pool calls (see below)."
msgstr ""

#: ../../../core-api/dma-api.rst:56
msgid ""
"The flag parameter allows the caller to specify the ``GFP_`` flags (see "
"kmalloc()) for the allocation (the implementation may ignore flags that "
"affect the location of the returned memory, like GFP_DMA)."
msgstr ""

#: ../../../core-api/dma-api.rst:66
msgid ""
"Free a previously allocated region of coherent memory.  dev, size and "
"dma_handle must all be the same as those passed into dma_alloc_coherent().  "
"cpu_addr must be the virtual address returned by dma_alloc_coherent()."
msgstr ""

#: ../../../core-api/dma-api.rst:70
msgid ""
"Note that unlike the sibling allocation call, this routine may only be "
"called with IRQs enabled."
msgstr ""

#: ../../../core-api/dma-api.rst:75
msgid "Part Ib - Using small DMA-coherent buffers"
msgstr ""

#: ../../../core-api/dma-api.rst:77
msgid "To get this part of the DMA API, you must #include <linux/dmapool.h>"
msgstr ""

#: ../../../core-api/dma-api.rst:79
msgid ""
"Many drivers need lots of small DMA-coherent memory regions for DMA "
"descriptors or I/O buffers.  Rather than allocating in units of a page or "
"more using dma_alloc_coherent(), you can use DMA pools.  These work much "
"like a struct kmem_cache, except that they use the DMA-coherent allocator, "
"not __get_free_pages().  Also, they understand common hardware constraints "
"for alignment, like queue heads needing to be aligned on N-byte boundaries."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:203
msgid "Creates a pool of coherent DMA memory blocks."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:102
#: include/linux/scatterlist.h:124 include/linux/scatterlist.h:149
#: include/linux/scatterlist.h:172 include/linux/scatterlist.h:204
#: include/linux/scatterlist.h:256 include/linux/scatterlist.h:272
#: include/linux/scatterlist.h:290 include/linux/scatterlist.h:314
#: include/linux/scatterlist.h:328 include/linux/scatterlist.h:343
#: include/linux/scatterlist.h:355 include/linux/scatterlist.h:370
#: include/linux/scatterlist.h:405 include/linux/scatterlist.h:420
#: include/linux/scatterlist.h:435 include/linux/scatterlist.h:478
#: include/linux/scatterlist.h:603 include/linux/scatterlist.h:612
#: include/linux/scatterlist.h:624 include/linux/scatterlist.h:638
#: include/linux/scatterlist.h:654 include/linux/scatterlist.h:667
#: ../../../core-api/dma-api:868: lib/scatterlist.c:21 lib/scatterlist.c:39
#: lib/scatterlist.c:72 lib/scatterlist.c:99 lib/scatterlist.c:116
#: lib/scatterlist.c:163 lib/scatterlist.c:221 lib/scatterlist.c:234
#: lib/scatterlist.c:246 lib/scatterlist.c:346 lib/scatterlist.c:408
#: lib/scatterlist.c:538 lib/scatterlist.c:583 lib/scatterlist.c:640
#: lib/scatterlist.c:655 lib/scatterlist.c:685 lib/scatterlist.c:696
#: lib/scatterlist.c:770 lib/scatterlist.c:817 lib/scatterlist.c:854
#: lib/scatterlist.c:895 lib/scatterlist.c:936 lib/scatterlist.c:985
#: lib/scatterlist.c:1002 lib/scatterlist.c:1019 lib/scatterlist.c:1037
#: lib/scatterlist.c:1055 lib/scatterlist.c:1361 ../../../core-api/dma-api:86:
#: mm/dmapool.c:207 mm/dmapool.c:360 mm/dmapool.c:402 mm/dmapool.c:449
#: mm/dmapool.c:487 mm/dmapool.c:520 ../../../core-api/dma-api:89:
#: include/linux/dmapool.h:68
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:209 mm/dmapool.c:489
msgid "``const char *name``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:204 mm/dmapool.c:484
msgid "name of pool, for diagnostics"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:206 mm/dmapool.c:486
msgid "``struct device *dev``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:205 mm/dmapool.c:485
msgid "device that will be doing the DMA"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:207 mm/dmapool.c:487
msgid "``size_t size``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:206 mm/dmapool.c:486
msgid "size of the blocks in this pool."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:208 mm/dmapool.c:488
msgid "``size_t align``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:207 mm/dmapool.c:487
msgid "alignment requirement for blocks; must be a power of two"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:209
msgid "``size_t boundary``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:208
msgid "returned blocks won't cross this power of two boundary"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:210
msgid "``int node``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:209
msgid "optional NUMA node to allocate structs 'dma_pool' and 'dma_page' on"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:774 lib/scatterlist.c:821
#: lib/scatterlist.c:857 lib/scatterlist.c:899 ../../../core-api/dma-api:86:
#: mm/dmapool.c:211 mm/dmapool.c:359
msgid "**Context**"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:210
msgid "not in_interrupt()"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:101
#: include/linux/scatterlist.h:124 include/linux/scatterlist.h:151
#: include/linux/scatterlist.h:174 include/linux/scatterlist.h:257
#: include/linux/scatterlist.h:271 include/linux/scatterlist.h:289
#: include/linux/scatterlist.h:314 include/linux/scatterlist.h:327
#: include/linux/scatterlist.h:342 include/linux/scatterlist.h:355
#: include/linux/scatterlist.h:369 include/linux/scatterlist.h:404
#: include/linux/scatterlist.h:419 include/linux/scatterlist.h:483
#: include/linux/scatterlist.h:626 include/linux/scatterlist.h:641
#: include/linux/scatterlist.h:655 include/linux/scatterlist.h:668
#: ../../../core-api/dma-api:868: lib/scatterlist.c:20 lib/scatterlist.c:40
#: lib/scatterlist.c:72 lib/scatterlist.c:167 lib/scatterlist.c:252
#: lib/scatterlist.c:347 lib/scatterlist.c:415 lib/scatterlist.c:545
#: lib/scatterlist.c:772 lib/scatterlist.c:817 lib/scatterlist.c:853
#: lib/scatterlist.c:894 lib/scatterlist.c:941 lib/scatterlist.c:987
#: lib/scatterlist.c:1004 lib/scatterlist.c:1022 lib/scatterlist.c:1040
#: lib/scatterlist.c:1057 lib/scatterlist.c:1364 ../../../core-api/dma-api:86:
#: mm/dmapool.c:212 mm/dmapool.c:360 mm/dmapool.c:450 mm/dmapool.c:490
#: mm/dmapool.c:519 ../../../core-api/dma-api:89: include/linux/dmapool.h:69
msgid "**Description**"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:211
msgid ""
"Given one of these pools, dma_pool_alloc() may be used to allocate memory.  "
"Such memory will all have coherent DMA mappings, accessible by the device "
"and its driver without using cache flushing primitives.  The actual size of "
"blocks allocated may be larger than requested because of alignment."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:217
msgid ""
"If **boundary** is nonzero, objects returned from dma_pool_alloc() won't "
"cross that size boundary.  This is useful for devices which have addressing "
"restrictions on individual DMA transfers, such as not crossing boundaries of "
"4KBytes."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:489
#: ../../../core-api/dma-api:868: lib/scatterlist.c:43 lib/scatterlist.c:422
#: lib/scatterlist.c:552 lib/scatterlist.c:587 lib/scatterlist.c:641
#: lib/scatterlist.c:824 lib/scatterlist.c:860 ../../../core-api/dma-api:86:
#: mm/dmapool.c:222 mm/dmapool.c:403 mm/dmapool.c:492
msgid "**Return**"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:223
msgid ""
"a dma allocation pool with the requested characteristics, or ``NULL`` if one "
"can't be created."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:356
msgid "destroys a pool of dma memory blocks."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:362 mm/dmapool.c:404
#: mm/dmapool.c:451 mm/dmapool.c:522 ../../../core-api/dma-api:89:
#: include/linux/dmapool.h:70
msgid "``struct dma_pool *pool``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:357 mm/dmapool.c:517
msgid "dma pool that will be destroyed"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:358
msgid "!in_interrupt()"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:359
msgid ""
"Caller guarantees that no more memory from the pool is in use, and that "
"nothing will try to use the pool after this call."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:398
msgid "get a block of coherent memory"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:399 ../../../core-api/dma-api:89:
#: include/linux/dmapool.h:65
msgid "dma pool that will produce the block"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:401 ../../../core-api/dma-api:89:
#: include/linux/dmapool.h:67
msgid "``gfp_t mem_flags``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:400 ../../../core-api/dma-api:89:
#: include/linux/dmapool.h:66
msgid "GFP_* bitmask"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:402 ../../../core-api/dma-api:89:
#: include/linux/dmapool.h:68
msgid "``dma_addr_t *handle``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:401 ../../../core-api/dma-api:89:
#: include/linux/dmapool.h:67
msgid "pointer to dma address of block"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:403
msgid ""
"the kernel virtual address of a currently unused block, and reports its dma "
"address through the handle. If such a memory block can't be allocated, "
"``NULL`` is returned."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:445
msgid "put block back into dma pool"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:446
msgid "the dma pool holding the block"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:448
msgid "``void *vaddr``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:447
msgid "virtual address of block"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:449
msgid "``dma_addr_t dma``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:448
msgid "dma address of block"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:449
msgid ""
"Caller promises neither device nor driver will again touch this block unless "
"it is first re-allocated."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:483
msgid "Managed dma_pool_create()"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:489
msgid "``size_t allocation``"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:488
msgid "returned blocks won't cross this boundary (or zero)"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:489
msgid ""
"Managed dma_pool_create().  DMA pool created with this function is "
"automatically destroyed on driver detach."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:493
msgid ""
"a managed dma allocation pool with the requested characteristics, or "
"``NULL`` if one can't be created."
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:516
msgid "Managed dma_pool_destroy()"
msgstr ""

#: ../../../core-api/dma-api:86: mm/dmapool.c:518
msgid "Managed dma_pool_destroy()."
msgstr ""

#: ../../../core-api/dma-api:89: include/linux/dmapool.h:64
msgid "Get a zero-initialized block of DMA coherent memory."
msgstr ""

#: ../../../core-api/dma-api:89: include/linux/dmapool.h:68
msgid "Same as dma_pool_alloc(), but the returned memory is zeroed."
msgstr ""

#: ../../../core-api/dma-api.rst:93
msgid "Part Ic - DMA addressing limitations"
msgstr ""

#: ../../../core-api/dma-api.rst:95
msgid ""
"DMA mask is a bit mask of the addressable region for the device. In other "
"words, if applying the DMA mask (a bitwise AND operation) to the DMA address "
"of a memory region does not clear any bits in the address, then the device "
"can perform DMA to that memory region."
msgstr ""

#: ../../../core-api/dma-api.rst:100
msgid ""
"All the below functions which set a DMA mask may fail if the requested mask "
"cannot be used with the device, or if the device is not capable of doing DMA."
msgstr ""

#: ../../../core-api/dma-api.rst:108
msgid "Updates both streaming and coherent DMA masks."
msgstr ""

#: ../../../core-api/dma-api.rst:110 ../../../core-api/dma-api.rst:119
#: ../../../core-api/dma-api.rst:128
msgid "Returns: 0 if successful and a negative error if not."
msgstr ""

#: ../../../core-api/dma-api.rst:117
msgid "Updates only the streaming DMA mask."
msgstr ""

#: ../../../core-api/dma-api.rst:126
msgid "Updates only the coherent DMA mask."
msgstr ""

#: ../../../core-api/dma-api.rst:135
msgid ""
"This API returns the mask that the platform requires to operate "
"efficiently.  Usually this means the returned mask is the minimum required "
"to cover all of memory.  Examining the required mask gives drivers with "
"variable descriptor sizes the opportunity to use smaller descriptors as "
"necessary."
msgstr ""

#: ../../../core-api/dma-api.rst:141
msgid ""
"Requesting the required mask does not alter the current mask.  If you wish "
"to take advantage of it, you should issue a dma_set_mask() call to set the "
"mask to the value returned."
msgstr ""

#: ../../../core-api/dma-api.rst:150
msgid ""
"Returns the maximum size of a mapping for the device. The size parameter of "
"the mapping functions like dma_map_single(), dma_map_page() and others "
"should not be larger than the returned value."
msgstr ""

#: ../../../core-api/dma-api.rst:159
msgid "Returns the maximum optimal size of a mapping for the device."
msgstr ""

#: ../../../core-api/dma-api.rst:161
msgid ""
"Mapping larger buffers may take much longer in certain scenarios. In "
"addition, for high-rate short-lived streaming mappings, the upfront time "
"spent on the mapping may account for an appreciable part of the total "
"request lifetime. As such, if splitting larger requests incurs no "
"significant performance penalty, then device drivers are advised to limit "
"total DMA streaming mappings length to the returned value."
msgstr ""

#: ../../../core-api/dma-api.rst:173
msgid ""
"Returns %true if dma_sync_single_for_{device,cpu} calls are required to "
"transfer memory ownership.  Returns %false if those calls can be skipped."
msgstr ""

#: ../../../core-api/dma-api.rst:181
msgid ""
"Returns the DMA merge boundary. If the device cannot merge any DMA address "
"segments, the function returns 0."
msgstr ""

#: ../../../core-api/dma-api.rst:185
msgid "Part Id - Streaming DMA mappings"
msgstr ""

#: ../../../core-api/dma-api.rst:187
msgid ""
"Streaming DMA allows to map an existing buffer for DMA transfers and then "
"unmap it when finished.  Map functions are not guaranteed to succeed, so the "
"return value must be checked."
msgstr ""

#: ../../../core-api/dma-api.rst:193
msgid ""
"In particular, mapping may fail for memory not addressable by the device, e."
"g. if it is not within the DMA mask of the device and/or a connecting bus "
"bridge.  Streaming DMA functions try to overcome such addressing "
"constraints, either by using an IOMMU (a device which maps I/O DMA addresses "
"to physical memory addresses), or by copying the data to/from a bounce "
"buffer if the kernel is configured with a :doc:`SWIOTLB <swiotlb>`.  "
"However, these methods are not always available, and even if they are, they "
"may still fail for a number of reasons."
msgstr ""

#: ../../../core-api/dma-api.rst:203
msgid ""
"In short, a device driver may need to be wary of where buffers are located "
"in physical memory, especially if the DMA mask is less than 32 bits."
msgstr ""

#: ../../../core-api/dma-api.rst:213
msgid ""
"Maps a piece of processor virtual memory so it can be accessed by the device "
"and returns the DMA address of the memory."
msgstr ""

#: ../../../core-api/dma-api.rst:216
msgid "The DMA API uses a strongly typed enumerator for its direction:"
msgstr ""

#: ../../../core-api/dma-api.rst:219
msgid "DMA_NONE"
msgstr ""

#: ../../../core-api/dma-api.rst:219
msgid "no direction (used for debugging)"
msgstr ""

#: ../../../core-api/dma-api.rst:220
msgid "DMA_TO_DEVICE"
msgstr ""

#: ../../../core-api/dma-api.rst:220
msgid "data is going from the memory to the device"
msgstr ""

#: ../../../core-api/dma-api.rst:221
msgid "DMA_FROM_DEVICE"
msgstr ""

#: ../../../core-api/dma-api.rst:221
msgid "data is coming from the device to the memory"
msgstr ""

#: ../../../core-api/dma-api.rst:222
msgid "DMA_BIDIRECTIONAL"
msgstr ""

#: ../../../core-api/dma-api.rst:222
msgid "direction isn't known"
msgstr ""

#: ../../../core-api/dma-api.rst:227
msgid ""
"Contiguous kernel virtual space may not be contiguous as physical memory.  "
"Since this API does not provide any scatter/gather capability, it will fail "
"if the user tries to map a non-physically contiguous piece of memory.  For "
"this reason, memory to be mapped by this API should be obtained from sources "
"which guarantee it to be physically contiguous (like kmalloc)."
msgstr ""

#: ../../../core-api/dma-api.rst:236
msgid ""
"Memory coherency operates at a granularity called the cache line width.  In "
"order for memory mapped by this API to operate correctly, the mapped region "
"must begin exactly on a cache line boundary and end exactly on one (to "
"prevent two separately mapped regions from sharing a single cache line).  "
"Since the cache line size may not be known at compile time, the API will not "
"enforce this requirement.  Therefore, it is recommended that driver writers "
"who don't take special care to determine the cache line size at run time "
"only map virtual regions that begin and end on page boundaries (which are "
"guaranteed also to be cache line boundaries)."
msgstr ""

#: ../../../core-api/dma-api.rst:247
msgid ""
"DMA_TO_DEVICE synchronisation must be done after the last modification of "
"the memory region by the software and before it is handed off to the "
"device.  Once this primitive is used, memory covered by this primitive "
"should be treated as read-only by the device.  If the device may write to it "
"at any point, it should be DMA_BIDIRECTIONAL (see below)."
msgstr ""

#: ../../../core-api/dma-api.rst:254
msgid ""
"DMA_FROM_DEVICE synchronisation must be done before the driver accesses data "
"that may be changed by the device.  This memory should be treated as read-"
"only by the driver.  If the driver needs to write to it at any point, it "
"should be DMA_BIDIRECTIONAL (see below)."
msgstr ""

#: ../../../core-api/dma-api.rst:259
msgid ""
"DMA_BIDIRECTIONAL requires special handling: it means that the driver isn't "
"sure if the memory was modified before being handed off to the device and "
"also isn't sure if the device will also modify it.  Thus, you must always "
"sync bidirectional memory twice: once before the memory is handed off to the "
"device (to make sure all memory changes are flushed from the processor) and "
"once before the data may be accessed after being used by the device (to make "
"sure any processor cache lines are updated with data that the device may "
"have changed)."
msgstr ""

#: ../../../core-api/dma-api.rst:274
msgid ""
"Unmaps the region previously mapped.  All the parameters passed in must be "
"identical to those passed to (and returned by) dma_map_single()."
msgstr ""

#: ../../../core-api/dma-api.rst:288
msgid ""
"API for mapping and unmapping for pages.  All the notes and warnings for the "
"other mapping APIs apply here.  Also, although the <offset> and <size> "
"parameters are provided to do partial page mapping, it is recommended that "
"you never use these unless you really know what the cache width is."
msgstr ""

#: ../../../core-api/dma-api.rst:304
msgid ""
"API for mapping and unmapping for MMIO resources. All the notes and warnings "
"for the other mapping APIs apply here. The API should only be used to map "
"device MMIO resources, mapping of RAM is not permitted."
msgstr ""

#: ../../../core-api/dma-api.rst:313
msgid ""
"In some circumstances dma_map_single(), dma_map_page() and "
"dma_map_resource() will fail to create a mapping. A driver can check for "
"these errors by testing the returned DMA address with dma_mapping_error(). A "
"non-zero return value means the mapping could not be created and the driver "
"should take appropriate action (e.g. reduce current DMA mapping usage or "
"delay and try again later)."
msgstr ""

#: ../../../core-api/dma-api.rst:325
msgid ""
"Maps a scatter/gather list for DMA. Returns the number of DMA address "
"segments mapped, which may be smaller than <nents> passed in if several "
"consecutive sglist entries are merged (e.g. with an IOMMU, or if some "
"adjacent segments just happen to be physically contiguous)."
msgstr ""

#: ../../../core-api/dma-api.rst:330
msgid ""
"Please note that the sg cannot be mapped again if it has been mapped once. "
"The mapping process is allowed to destroy information in the sg."
msgstr ""

#: ../../../core-api/dma-api.rst:333
msgid ""
"As with the other mapping interfaces, dma_map_sg() can fail. When it does, 0 "
"is returned and a driver must take appropriate action. It is critical that "
"the driver do something, in the case of a block driver aborting the request "
"or even oopsing is better than doing nothing and corrupting the filesystem."
msgstr ""

#: ../../../core-api/dma-api.rst:339
msgid "With scatterlists, you use the resulting mapping like this::"
msgstr ""

#: ../../../core-api/dma-api.rst:349
msgid "where nents is the number of entries in the sglist."
msgstr ""

#: ../../../core-api/dma-api.rst:351
msgid ""
"The implementation is free to merge several consecutive sglist entries into "
"one.  The returned number is the actual number of sg entries it mapped them "
"to. On failure, 0 is returned."
msgstr ""

#: ../../../core-api/dma-api.rst:355
msgid ""
"Then you should loop count times (note: this can be less than nents times) "
"and use sg_dma_address() and sg_dma_len() macros where you previously "
"accessed sg->address and sg->length as shown above."
msgstr ""

#: ../../../core-api/dma-api.rst:365
msgid ""
"Unmap the previously mapped scatter/gather list.  All the parameters must be "
"the same as those and passed in to the scatter/gather mapping API."
msgstr ""

#: ../../../core-api/dma-api.rst:369
msgid ""
"Note: <nents> must be the number you passed in, *not* the number of DMA "
"address entries returned."
msgstr ""

#: ../../../core-api/dma-api.rst:394
msgid ""
"Synchronise a single contiguous or scatter/gather mapping for the CPU and "
"device. With the sync_sg API, all the parameters must be the same as those "
"passed into the sg mapping API. With the sync_single API, you can use "
"dma_handle and size parameters that aren't identical to those passed into "
"the single mapping API to do a partial sync."
msgstr ""

#: ../../../core-api/dma-api.rst:403
msgid "You must do this:"
msgstr ""

#: ../../../core-api/dma-api.rst:405
msgid ""
"Before reading values that have been written by DMA from the device (use the "
"DMA_FROM_DEVICE direction)"
msgstr ""

#: ../../../core-api/dma-api.rst:407
msgid ""
"After writing values that will be written to the device using DMA (use the "
"DMA_TO_DEVICE) direction"
msgstr ""

#: ../../../core-api/dma-api.rst:409
msgid ""
"before *and* after handing memory to the device if the memory is "
"DMA_BIDIRECTIONAL"
msgstr ""

#: ../../../core-api/dma-api.rst:412
msgid "See also dma_map_single()."
msgstr ""

#: ../../../core-api/dma-api.rst:436
msgid ""
"The four functions above are just like the counterpart functions without the "
"_attrs suffixes, except that they pass an optional dma_attrs."
msgstr ""

#: ../../../core-api/dma-api.rst:440
msgid ""
"The interpretation of DMA attributes is architecture-specific, and each "
"attribute should be documented in Documentation/core-api/dma-attributes.rst."
msgstr ""

#: ../../../core-api/dma-api.rst:444
msgid ""
"If dma_attrs are 0, the semantics of each of these functions is identical to "
"those of the corresponding function without the _attrs suffix. As a result "
"dma_map_single_attrs() can generally replace dma_map_single(), etc."
msgstr ""

#: ../../../core-api/dma-api.rst:449
msgid ""
"As an example of the use of the ``*_attrs`` functions, here's how you could "
"pass an attribute DMA_ATTR_FOO when mapping memory for DMA::"
msgstr ""

#: ../../../core-api/dma-api.rst:464
msgid ""
"Architectures that care about DMA_ATTR_FOO would check for its presence in "
"their implementations of the mapping and unmapping routines, e.g.:::"
msgstr ""

#: ../../../core-api/dma-api.rst:479
msgid "Part Ie - IOVA-based DMA mappings"
msgstr ""

#: ../../../core-api/dma-api.rst:481
msgid ""
"These APIs allow a very efficient mapping when using an IOMMU.  They are an "
"optional path that requires extra code and are only recommended for drivers "
"where DMA mapping performance, or the space usage for storing the DMA "
"addresses matter.  All the considerations from the previous section apply "
"here as well."
msgstr ""

#: ../../../core-api/dma-api.rst:491
msgid ""
"Is used to try to allocate IOVA space for mapping operation.  If it returns "
"false this API can't be used for the given device and the normal streaming "
"DMA mapping API should be used.  The ``struct dma_iova_state`` is allocated "
"by the driver and must be kept around until unmap time."
msgstr ""

#: ../../../core-api/dma-api.rst:500
msgid ""
"Can be used by the driver to check if the IOVA-based API is used after a "
"call to dma_iova_try_alloc.  This can be useful in the unmap path."
msgstr ""

#: ../../../core-api/dma-api.rst:509
msgid ""
"Is used to link ranges to the IOVA previously allocated.  The start of all "
"but the first call to dma_iova_link for a given state must be aligned to the "
"DMA merge boundary returned by ``dma_get_merge_boundary())``, and the size "
"of all but the last range must be aligned to the DMA merge boundary as well."
msgstr ""

#: ../../../core-api/dma-api.rst:520
msgid ""
"Must be called to sync the IOMMU page tables for IOVA-range mapped by one or "
"more calls to ``dma_iova_link()``."
msgstr ""

#: ../../../core-api/dma-api.rst:523
msgid ""
"For drivers that use a one-shot mapping, all ranges can be unmapped and the "
"IOVA freed by calling:"
msgstr ""

#: ../../../core-api/dma-api.rst:532
msgid ""
"Alternatively drivers can dynamically manage the IOVA space by unmapping and "
"mapping individual regions.  In that case"
msgstr ""

#: ../../../core-api/dma-api.rst:541
msgid "is used to unmap a range previously mapped, and"
msgstr ""

#: ../../../core-api/dma-api.rst:547
msgid ""
"is used to free the IOVA space.  All regions must have been unmapped using "
"``dma_iova_unlink()`` before calling ``dma_iova_free()``."
msgstr ""

#: ../../../core-api/dma-api.rst:551
msgid "Part II - Non-coherent DMA allocations"
msgstr ""

#: ../../../core-api/dma-api.rst:553
msgid ""
"These APIs allow to allocate pages that are guaranteed to be DMA addressable "
"by the passed in device, but which need explicit management of memory "
"ownership for the kernel vs the device."
msgstr ""

#: ../../../core-api/dma-api.rst:557
msgid ""
"If you don't understand how cache line coherency works between a processor "
"and an I/O device, you should not be using this part of the API."
msgstr ""

#: ../../../core-api/dma-api.rst:566
msgid ""
"This routine allocates a region of <size> bytes of non-coherent memory.  It "
"returns a pointer to first struct page for the region, or NULL if the "
"allocation failed. The resulting struct page can be used for everything a "
"struct page is suitable for."
msgstr ""

#: ../../../core-api/dma-api.rst:575 ../../../core-api/dma-api.rst:644
msgid ""
"The dir parameter specified if data is read and/or written by the device, "
"see dma_map_single() for details."
msgstr ""

#: ../../../core-api/dma-api.rst:578 ../../../core-api/dma-api.rst:647
msgid ""
"The gfp parameter allows the caller to specify the ``GFP_`` flags (see "
"kmalloc()) for the allocation, but rejects flags used to specify a memory "
"zone such as GFP_DMA or GFP_HIGHMEM."
msgstr ""

#: ../../../core-api/dma-api.rst:582
msgid ""
"Before giving the memory to the device, dma_sync_single_for_device() needs "
"to be called, and before reading memory written by the device, "
"dma_sync_single_for_cpu(), just like for streaming DMA mappings that are "
"reused."
msgstr ""

#: ../../../core-api/dma-api.rst:593
msgid ""
"Free a region of memory previously allocated using dma_alloc_pages(). dev, "
"size, dma_handle and dir must all be the same as those passed into "
"dma_alloc_pages().  page must be the pointer returned by dma_alloc_pages()."
msgstr ""

#: ../../../core-api/dma-api.rst:603
msgid ""
"Map an allocation returned from dma_alloc_pages() into a user address space. "
"dev and size must be the same as those passed into dma_alloc_pages(). page "
"must be the pointer returned by dma_alloc_pages()."
msgstr ""

#: ../../../core-api/dma-api.rst:614
msgid ""
"This routine is a convenient wrapper around dma_alloc_pages that returns the "
"kernel virtual address for the allocated memory instead of the page "
"structure."
msgstr ""

#: ../../../core-api/dma-api.rst:623
msgid ""
"Free a region of memory previously allocated using dma_alloc_noncoherent(). "
"dev, size, dma_handle and dir must all be the same as those passed into "
"dma_alloc_noncoherent().  cpu_addr must be the virtual address returned by "
"dma_alloc_noncoherent()."
msgstr ""

#: ../../../core-api/dma-api.rst:635
msgid ""
"This routine allocates  <size> bytes of non-coherent and possibly non-"
"contiguous memory.  It returns a pointer to struct sg_table that describes "
"the allocated and DMA mapped memory, or NULL if the allocation failed. The "
"resulting memory can be used for struct page mapped into a scatterlist are "
"suitable for."
msgstr ""

#: ../../../core-api/dma-api.rst:640
msgid ""
"The return sg_table is guaranteed to have 1 single DMA mapped segment as "
"indicated by sgt->nents, but it might have multiple CPU side segments as "
"indicated by sgt->orig_nents."
msgstr ""

#: ../../../core-api/dma-api.rst:651
msgid "The attrs argument must be either 0 or DMA_ATTR_ALLOC_SINGLE_PAGES."
msgstr ""

#: ../../../core-api/dma-api.rst:653
msgid ""
"Before giving the memory to the device, dma_sync_sgtable_for_device() needs "
"to be called, and before reading memory written by the device, "
"dma_sync_sgtable_for_cpu(), just like for streaming DMA mappings that are "
"reused."
msgstr ""

#: ../../../core-api/dma-api.rst:665
msgid ""
"Free memory previously allocated using dma_alloc_noncontiguous().  dev, "
"size, and dir must all be the same as those passed into "
"dma_alloc_noncontiguous(). sgt must be the pointer returned by "
"dma_alloc_noncontiguous()."
msgstr ""

#: ../../../core-api/dma-api.rst:675
msgid ""
"Return a contiguous kernel mapping for an allocation returned from "
"dma_alloc_noncontiguous().  dev and size must be the same as those passed "
"into dma_alloc_noncontiguous().  sgt must be the pointer returned by "
"dma_alloc_noncontiguous()."
msgstr ""

#: ../../../core-api/dma-api.rst:680
msgid ""
"Once a non-contiguous allocation is mapped using this function, the "
"flush_kernel_vmap_range() and invalidate_kernel_vmap_range() APIs must be "
"used to manage the coherency between the kernel mapping, the device and user "
"space mappings (if any)."
msgstr ""

#: ../../../core-api/dma-api.rst:690
msgid ""
"Unmap a kernel mapping returned by dma_vmap_noncontiguous().  dev must be "
"the same the one passed into dma_alloc_noncontiguous().  vaddr must be the "
"pointer returned by dma_vmap_noncontiguous()."
msgstr ""

#: ../../../core-api/dma-api.rst:701
msgid ""
"Map an allocation returned from dma_alloc_noncontiguous() into a user "
"address space.  dev and size must be the same as those passed into "
"dma_alloc_noncontiguous().  sgt must be the pointer returned by "
"dma_alloc_noncontiguous()."
msgstr ""

#: ../../../core-api/dma-api.rst:711
msgid ""
"Returns the processor cache alignment.  This is the absolute minimum "
"alignment *and* width that you must observe when either mapping memory or "
"doing partial flushes."
msgstr ""

#: ../../../core-api/dma-api.rst:717
msgid ""
"This API may return a number *larger* than the actual cache line, but it "
"will guarantee that one or more cache lines fit exactly into the width "
"returned by this call.  It will also always be a power of two for easy "
"alignment."
msgstr ""

#: ../../../core-api/dma-api.rst:724
msgid "Part III - Debug drivers use of the DMA API"
msgstr ""

#: ../../../core-api/dma-api.rst:726
msgid ""
"The DMA API as described above has some constraints. DMA addresses must be "
"released with the corresponding function with the same size for example. "
"With the advent of hardware IOMMUs it becomes more and more important that "
"drivers do not violate those constraints. In the worst case such a violation "
"can result in data corruption up to destroyed filesystems."
msgstr ""

#: ../../../core-api/dma-api.rst:732
msgid ""
"To debug drivers and find bugs in the usage of the DMA API checking code can "
"be compiled into the kernel which will tell the developer about those "
"violations. If your architecture supports it you can select the \"Enable "
"debugging of DMA API usage\" option in your kernel configuration. Enabling "
"this option has a performance impact. Do not enable it in production kernels."
msgstr ""

#: ../../../core-api/dma-api.rst:738
msgid ""
"If you boot the resulting kernel will contain code which does some "
"bookkeeping about what DMA memory was allocated for which device. If this "
"code detects an error it prints a warning message with some details into "
"your kernel log. An example warning message may look like this::"
msgstr ""

#: ../../../core-api/dma-api.rst:773
msgid ""
"The driver developer can find the driver and the device including a "
"stacktrace of the DMA API call which caused this warning."
msgstr ""

#: ../../../core-api/dma-api.rst:776
msgid ""
"Per default only the first error will result in a warning message. All other "
"errors will only silently counted. This limitation exist to prevent the code "
"from flooding your kernel log. To support debugging a device driver this can "
"be disabled via debugfs. See the debugfs interface documentation below for "
"details."
msgstr ""

#: ../../../core-api/dma-api.rst:782
msgid ""
"The debugfs directory for the DMA API debugging code is called dma-api/. In "
"this directory the following files can currently be found:"
msgstr ""

#: ../../../core-api/dma-api.rst:786
msgid "dma-api/all_errors"
msgstr ""

#: ../../../core-api/dma-api.rst:786
msgid ""
"This file contains a numeric value. If this value is not equal to zero the "
"debugging code will print a warning for every error it finds into the kernel "
"log. Be careful with this option, as it can easily flood your logs."
msgstr ""

#: ../../../core-api/dma-api.rst:792
msgid "dma-api/disabled"
msgstr ""

#: ../../../core-api/dma-api.rst:792
msgid ""
"This read-only file contains the character 'Y' if the debugging code is "
"disabled. This can happen when it runs out of memory or if it was disabled "
"at boot time"
msgstr ""

#: ../../../core-api/dma-api.rst:797
msgid "dma-api/dump"
msgstr ""

#: ../../../core-api/dma-api.rst:797
msgid "This read-only file contains current DMA mappings."
msgstr ""

#: ../../../core-api/dma-api.rst:800
msgid "dma-api/error_count"
msgstr ""

#: ../../../core-api/dma-api.rst:800
msgid "This file is read-only and shows the total numbers of errors found."
msgstr ""

#: ../../../core-api/dma-api.rst:803
msgid "dma-api/num_errors"
msgstr ""

#: ../../../core-api/dma-api.rst:803
msgid ""
"The number in this file shows how many warnings will be printed to the "
"kernel log before it stops. This number is initialized to one at system boot "
"and be set by writing into this file"
msgstr ""

#: ../../../core-api/dma-api.rst:809
msgid "dma-api/min_free_entries"
msgstr ""

#: ../../../core-api/dma-api.rst:809
msgid ""
"This read-only file can be read to get the minimum number of free "
"dma_debug_entries the allocator has ever seen. If this value goes down to "
"zero the code will attempt to increase nr_total_entries to compensate."
msgstr ""

#: ../../../core-api/dma-api.rst:815
msgid "dma-api/num_free_entries"
msgstr ""

#: ../../../core-api/dma-api.rst:815
msgid "The current number of free dma_debug_entries in the allocator."
msgstr ""

#: ../../../core-api/dma-api.rst:818
msgid "dma-api/nr_total_entries"
msgstr ""

#: ../../../core-api/dma-api.rst:818
msgid ""
"The total number of dma_debug_entries in the allocator, both free and used."
msgstr ""

#: ../../../core-api/dma-api.rst:821
msgid "dma-api/driver_filter"
msgstr ""

#: ../../../core-api/dma-api.rst:821
msgid ""
"You can write a name of a driver into this file to limit the debug output to "
"requests from that particular driver. Write an empty string to that file to "
"disable the filter and see all errors again."
msgstr ""

#: ../../../core-api/dma-api.rst:828
msgid ""
"If you have this code compiled into your kernel it will be enabled by "
"default. If you want to boot without the bookkeeping anyway you can provide "
"'dma_debug=off' as a boot parameter. This will disable DMA API debugging. "
"Notice that you can not enable it again at runtime. You have to reboot to do "
"so."
msgstr ""

#: ../../../core-api/dma-api.rst:834
msgid ""
"If you want to see debug messages only for a special device driver you can "
"specify the dma_debug_driver=<drivername> parameter. This will enable the "
"driver filter at boot time. The debug code will only print errors for that "
"driver afterwards. This filter can be disabled or changed later using "
"debugfs."
msgstr ""

#: ../../../core-api/dma-api.rst:839
msgid ""
"When the code disables itself at runtime this is most likely because it ran "
"out of dma_debug_entries and was unable to allocate more on-demand. 65536 "
"entries are preallocated at boot - if this is too low for you boot with "
"'dma_debug_entries=<your_desired_number>' to overwrite the default. Note "
"that the code allocates entries in batches, so the exact number of "
"preallocated entries may be greater than the actual number requested. The "
"code will print to the kernel log each time it has dynamically allocated as "
"many entries as were initially preallocated. This is to indicate that a "
"larger preallocation size may be appropriate, or if it happens continually "
"that a driver may be leaking mappings."
msgstr ""

#: ../../../core-api/dma-api.rst:855
msgid ""
"dma-debug interface debug_dma_mapping_error() to debug drivers that fail to "
"check DMA mapping errors on addresses returned by dma_map_single() and "
"dma_map_page() interfaces. This interface clears a flag set by "
"debug_dma_map_phys() to indicate that dma_mapping_error() has been called by "
"the driver. When driver does unmap, debug_dma_unmap() checks the flag and if "
"this flag is still set, prints warning message that includes call trace that "
"leads up to the unmap. This interface can be called from dma_mapping_error() "
"routines to enable DMA mapping error check debugging."
msgstr ""

#: ../../../core-api/dma-api.rst:865
msgid "Functions and structures"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:98
msgid "return the next scatterlist entry in a list"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:104
#: include/linux/scatterlist.h:126 include/linux/scatterlist.h:151
#: include/linux/scatterlist.h:174 include/linux/scatterlist.h:206
#: include/linux/scatterlist.h:274 include/linux/scatterlist.h:292
#: include/linux/scatterlist.h:316 include/linux/scatterlist.h:330
#: include/linux/scatterlist.h:345 include/linux/scatterlist.h:357
#: include/linux/scatterlist.h:372 include/linux/scatterlist.h:407
#: include/linux/scatterlist.h:422 ../../../core-api/dma-api:868:
#: lib/scatterlist.c:23 lib/scatterlist.c:41 lib/scatterlist.c:118
msgid "``struct scatterlist *sg``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:99
msgid "The current sg entry"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:101
msgid ""
"Usually the next entry will be **sg** + 1, but if this sg element is part of "
"a chained scatterlist, it could jump to the start of a new scatterlist array."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:120
msgid "Assign a given page to an SG entry"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:121
#: include/linux/scatterlist.h:146 include/linux/scatterlist.h:169
#: include/linux/scatterlist.h:201 include/linux/scatterlist.h:312
#: include/linux/scatterlist.h:325 include/linux/scatterlist.h:340
#: include/linux/scatterlist.h:353 include/linux/scatterlist.h:367
#: include/linux/scatterlist.h:402 include/linux/scatterlist.h:417
#: ../../../core-api/dma-api:868: lib/scatterlist.c:113
msgid "SG entry"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:123
#: include/linux/scatterlist.h:148
msgid "``struct page *page``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:122
#: include/linux/scatterlist.h:147
msgid "The page"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:124
msgid ""
"Assign page to sg entry. Also see sg_set_page(), the most commonly used "
"variant."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:145
msgid "Set sg entry to point at given page"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:149
msgid "``unsigned int len``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:148
#: include/linux/scatterlist.h:171
msgid "Length of data"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:150
#: include/linux/scatterlist.h:480 ../../../core-api/dma-api:868:
#: lib/scatterlist.c:410 lib/scatterlist.c:541
msgid "``unsigned int offset``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:149
msgid "Offset into page"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:151
msgid ""
"Use this function to set an sg entry pointing at a page, never assign the "
"page directly. We encode sg table information in the lower bits of the page "
"pointer. See sg_page() for looking up the page belonging to an sg entry."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:168
msgid "Set sg entry to point at given folio"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:171
msgid "``struct folio *folio``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:170
msgid "The folio"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:172
msgid "``size_t len``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:173
msgid "``size_t offset``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:172
msgid "Offset into folio"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:174
msgid ""
"Use this function to set an sg entry pointing at a folio, never assign the "
"folio directly. We encode sg table information in the lower bits of the "
"folio pointer. See sg_page() for looking up the page belonging to an sg "
"entry."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:200
msgid "Set sg entry to point at given data"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:203
#: ../../../core-api/dma-api:868: lib/scatterlist.c:115 lib/scatterlist.c:985
#: lib/scatterlist.c:1019
msgid "``const void *buf``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:202
msgid "Data"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:204
#: ../../../core-api/dma-api:868: lib/scatterlist.c:116
msgid "``unsigned int buflen``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:203
msgid "Data length"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:252
msgid "Chain two sglists together"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:258
msgid "``struct scatterlist *prv``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:253
msgid "First scatterlist"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:255
msgid "``unsigned int prv_nents``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:254
msgid "Number of entries in prv"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:256
#: include/linux/scatterlist.h:437 ../../../core-api/dma-api:868:
#: lib/scatterlist.c:74 lib/scatterlist.c:101 lib/scatterlist.c:657
#: lib/scatterlist.c:687 lib/scatterlist.c:698 lib/scatterlist.c:769
#: lib/scatterlist.c:938 lib/scatterlist.c:987 lib/scatterlist.c:1004
#: lib/scatterlist.c:1021 lib/scatterlist.c:1039 lib/scatterlist.c:1057
msgid "``struct scatterlist *sgl``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:255
msgid "Second scatterlist"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:257
msgid "Links **prv** and **sgl** together, to form a longer scatterlist."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:268
msgid "Mark the end of the scatterlist"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:269
#: include/linux/scatterlist.h:287
msgid "SG entryScatterlist"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:271
msgid ""
"Marks the passed in sg entry as the termination point for the sg table. A "
"call to sg_next() on this entry will return NULL."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:286
msgid "Undo setting the end of the scatterlist"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:289
msgid "Removes the termination marker from the given entry of the scatterlist."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:310
msgid "Return whether a given segment was marked as a bus address"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:314
msgid ""
"Returns true if sg_dma_mark_bus_address() has been called on this segment."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:324
msgid "Mark the scatterlist entry as a bus address"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:327
msgid ""
"Marks the passed in sg entry to indicate that the dma_address is a bus "
"address and doesn't need to be unmapped. This should only be used by "
"dma_map_sg() implementations to mark bus addresses so they can be properly "
"cleaned up in dma_unmap_sg()."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:339
msgid "Unmark the scatterlist entry as a bus address"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:342
msgid "Clears the bus address mark."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:351
msgid "Return whether the scatterlist was marked for SWIOTLB bouncing"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:355
msgid ""
"Returns true if the scatterlist was marked for SWIOTLB bouncing. Not all "
"elements may have been bounced, so the caller would have to check individual "
"SG entries with swiotlb_find_pool()."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:366
msgid "Mark the scatterlist for SWIOTLB bouncing"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:369
msgid ""
"Marks a a scatterlist for SWIOTLB bounce. Not all SG entries may be bounced."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:401
msgid "Return physical address of an sg entry"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:404
msgid ""
"This calls page_to_phys() on the page in this sg entry, and adds the sg "
"offset. The caller must know that it is legal to call page_to_phys() on the "
"sg page."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:416
msgid "Return virtual address of an sg entry"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:419
msgid ""
"This calls page_address() on the page in this sg entry, and adds the sg "
"offset. The caller must know that the sg page has a valid virtual mapping."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:431
msgid "Initialize markers in sg table"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:432
#: ../../../core-api/dma-api:868: lib/scatterlist.c:96
msgid "The SG table"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:434
#: ../../../core-api/dma-api:868: lib/scatterlist.c:71 lib/scatterlist.c:98
#: lib/scatterlist.c:245 lib/scatterlist.c:345 lib/scatterlist.c:770
#: lib/scatterlist.c:935 lib/scatterlist.c:984 lib/scatterlist.c:1001
#: lib/scatterlist.c:1018 lib/scatterlist.c:1036 lib/scatterlist.c:1054
msgid "``unsigned int nents``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:433
#: ../../../core-api/dma-api:868: lib/scatterlist.c:97
msgid "Number of entries in table"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:474
msgid "Allocate and initialize an sg table from an array of pages"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:480
#: ../../../core-api/dma-api:868: lib/scatterlist.c:540
msgid "``struct sg_table *sgt``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:476
#: ../../../core-api/dma-api:868: lib/scatterlist.c:160 lib/scatterlist.c:243
#: lib/scatterlist.c:343 lib/scatterlist.c:537
msgid "The sg table header to use"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:478
#: ../../../core-api/dma-api:868: lib/scatterlist.c:408 lib/scatterlist.c:539
msgid "``struct page **pages``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:477
#: ../../../core-api/dma-api:868: lib/scatterlist.c:407 lib/scatterlist.c:538
msgid "Pointer to an array of page pointers"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:479
#: ../../../core-api/dma-api:868: lib/scatterlist.c:409 lib/scatterlist.c:540
msgid "``unsigned int n_pages``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:478
#: ../../../core-api/dma-api:868: lib/scatterlist.c:408 lib/scatterlist.c:539
msgid "Number of pages in the pages array"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:479
#: ../../../core-api/dma-api:868: lib/scatterlist.c:409 lib/scatterlist.c:540
msgid "Offset from start of the first page to the start of a buffer"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:481
#: ../../../core-api/dma-api:868: lib/scatterlist.c:411 lib/scatterlist.c:542
msgid "``unsigned long size``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:480
#: ../../../core-api/dma-api:868: lib/scatterlist.c:410 lib/scatterlist.c:541
msgid "Number of valid bytes in the buffer (after offset)"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:482
#: ../../../core-api/dma-api:868: lib/scatterlist.c:250 lib/scatterlist.c:346
#: lib/scatterlist.c:414 lib/scatterlist.c:544
msgid "``gfp_t gfp_mask``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:481
#: ../../../core-api/dma-api:868: lib/scatterlist.c:249 lib/scatterlist.c:345
#: lib/scatterlist.c:413 lib/scatterlist.c:543
msgid "GFP allocation mask"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:483
msgid ""
"Allocate and initialize an sg table from a list of pages. Contiguous ranges "
"of the pages are squashed into a single scatterlist node. A user may provide "
"an offset at a start and a size of valid data in a buffer specified by the "
"page array. The returned sg table is released by sg_free_table."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:490
#: ../../../core-api/dma-api:868: lib/scatterlist.c:423 lib/scatterlist.c:553
msgid "0 on success, negative error on failure"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:599
msgid "get the current page held by the page iterator"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:605
msgid "``struct sg_page_iter *piter``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:600
#: include/linux/scatterlist.h:610
msgid "page iterator holding the page"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:608
msgid "get the dma address of the current page held by the page iterator."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:614
msgid "``struct sg_dma_page_iter *dma_iter``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:622
msgid "``for_each_sg_page (sglist, piter, nents, pgoffset)``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:620
#: include/linux/scatterlist.h:634
msgid "iterate over the pages of the given sg list"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:626
#: include/linux/scatterlist.h:640
msgid "``sglist``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:621
#: include/linux/scatterlist.h:635
msgid "sglist to iterate over"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:623
#: include/linux/scatterlist.h:653
msgid "``piter``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:622
msgid "page iterator to hold current page, sg, sg_pgoffset"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:624
msgid "``nents``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:623
msgid "maximum number of sg entries to iterate over"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:625
#: include/linux/scatterlist.h:640 include/linux/scatterlist.h:654
#: include/linux/scatterlist.h:667
msgid "``pgoffset``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:624
#: include/linux/scatterlist.h:639 include/linux/scatterlist.h:653
#: include/linux/scatterlist.h:666
msgid "starting page offset (in pages)"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:625
msgid ""
"Callers may use sg_page_iter_page() to get each page pointer. In each loop "
"it operates on PAGE_SIZE unit."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:636
msgid "``for_each_sg_dma_page (sglist, dma_iter, dma_nents, pgoffset)``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:637
#: include/linux/scatterlist.h:666
msgid "``dma_iter``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:636
#: include/linux/scatterlist.h:665
msgid "DMA page iterator to hold current page"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:638
msgid "``dma_nents``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:637
msgid ""
"maximum number of sg entries to iterate over, this is the value returned "
"from dma_map_sg"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:640
msgid ""
"Callers may use sg_page_iter_dma_address() to get each page's DMA address. "
"In each loop it operates on PAGE_SIZE unit."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:652
msgid "``for_each_sgtable_page (sgt, piter, pgoffset)``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:650
msgid "iterate over all pages in the sg_table object"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:656
#: include/linux/scatterlist.h:669
msgid "``sgt``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:651
#: include/linux/scatterlist.h:664
msgid "sg_table object to iterate over"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:652
msgid "page iterator to hold current page"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:654
msgid ""
"Iterates over the all memory pages in the buffer described by a scatterlist "
"stored in the given sg_table object. See also for_each_sg_page(). In each "
"loop it operates on PAGE_SIZE unit."
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:665
msgid "``for_each_sgtable_dma_page (sgt, dma_iter, pgoffset)``"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:663
msgid "iterate over the DMA mapped sg_table object"
msgstr ""

#: ../../../core-api/dma-api:867: include/linux/scatterlist.h:667
msgid ""
"Iterates over the all DMA mapped pages in the buffer described by a "
"scatterlist stored in the given sg_table object. See also "
"for_each_sg_dma_page(). In each loop it operates on PAGE_SIZE unit."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:17
msgid "return total count of entries in scatterlist"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:18 lib/scatterlist.c:37
msgid "The scatterlist"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:20
msgid ""
"Allows to know how many entries are in sg, taking into account chaining as "
"well"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:35
msgid ""
"return total count of entries in scatterlist needed to satisfy the supplied "
"length"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:39
msgid "``u64 len``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:38
msgid "The total required length"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:40
msgid ""
"Determines the number of entries in sg that are required to meet the "
"supplied length, taking into account chaining as well"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:44
msgid "the number of sg entries needed, negative error on failure"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:68
msgid "return the last scatterlist entry in a list"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:69
msgid "First entry in the scatterlist"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:70
msgid "Number of entries in the scatterlist"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:72
msgid ""
"Should only be used casually, it (currently) scans the entire list to get "
"the last entry."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:75
msgid ""
"Note that the **sgl** pointer passed in need not be the first one, the "
"important bit is that **nents** denotes the number of entries that exist "
"from **sgl**."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:95
msgid "Initialize SG table"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:99 lib/scatterlist.c:257
#: lib/scatterlist.c:425 lib/scatterlist.c:656
msgid "**Notes**"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:99
msgid ""
"If this is part of a chained sg table, sg_mark_end() should be used only on "
"the last table part."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:112
msgid "Initialize a single entry sg list"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:114
msgid "Virtual address for IO"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:115
msgid "IO length"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:159
msgid "Free a previously mapped sg table"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:165 lib/scatterlist.c:236
#: lib/scatterlist.c:248 lib/scatterlist.c:348
msgid "``struct sg_table *table``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:162 lib/scatterlist.c:246
msgid "``unsigned int max_ents``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:161
msgid "The maximum number of entries per single scatterlist"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:163 lib/scatterlist.c:248
msgid "``unsigned int nents_first_chunk``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:162
msgid ""
"Number of entries int the (preallocated) first scatterlist chunk, 0 means no "
"such preallocated first chunk"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:165
msgid "``sg_free_fn *free_fn``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:164
msgid "Free function"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:166
msgid "``unsigned int num_ents``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:165
msgid "Number of entries in the table"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:167
msgid ""
"Free an sg table previously allocated and setup with __sg_alloc_table().  "
"The **max_ents** value must be identical to that previously used with "
"__sg_alloc_table()."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:217
msgid "Free a previously allocated append sg table."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:223
msgid "``struct sg_append_table *table``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:218
msgid "The mapped sg append table header"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:230
msgid "Free a previously allocated sg table"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:231
msgid "The mapped sg table header"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:242
msgid "Allocate and initialize an sg table with given allocator"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:244 lib/scatterlist.c:344
msgid "Number of entries in sg list"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:245
msgid "The maximum number of entries the allocator returns per call"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:247
msgid "``struct scatterlist *first_chunk``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:246
msgid "first SGL if preallocated (may be ``NULL``)"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:247
msgid ""
"Number of entries in the (preallocated) first scatterlist chunk, 0 means no "
"such preallocated chunk provided by user"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:251
msgid "``sg_alloc_fn *alloc_fn``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:250
msgid "Allocator to use"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:252
msgid ""
"This function returns a **table** **nents** long. The allocator is defined "
"to return scatterlist chunks of maximum size **max_ents**. Thus if **nents** "
"is bigger than **max_ents**, the scatterlists will be chained in units of "
"**max_ents**."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:258
msgid ""
"If this function returns non-0 (eg failure), the caller must call "
"__sg_free_table() to cleanup any leftover allocations."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:342
msgid "Allocate and initialize an sg table"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:347
msgid ""
"Allocate and initialize an sg table. If **nents** is larger than "
"SG_MAX_SINGLE_ALLOC a chained sg table will be setup."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:404
msgid "Allocate and initialize an append sg table from an array of pages"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:410
msgid "``struct sg_append_table *sgt_append``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:406
msgid "The sg append table to use"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:412 lib/scatterlist.c:543
msgid "``unsigned int max_segment``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:411 lib/scatterlist.c:542
msgid "Maximum size of a scatterlist element in bytes"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:413
msgid "``unsigned int left_pages``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:412
msgid "Left pages caller have to set after this call"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:415
msgid ""
"In the first call it allocate and initialize an sg table from a list of "
"pages, else reuse the scatterlist from sgt_append. Contiguous ranges of the "
"pages are squashed into a single scatterlist entry up to the maximum size "
"specified in **max_segment**.  A user may provide an offset at a start and a "
"size of valid data in a buffer specified by the page array. The returned sg "
"table is released by sg_free_append_table"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:426
msgid ""
"If this function returns non-0 (eg failure), the caller must call "
"sg_free_append_table() to cleanup any leftover allocations."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:429
msgid "In the fist call, sgt_append must by initialized."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:534
msgid ""
"Allocate and initialize an sg table from an array of pages and given maximum "
"segment."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:545
msgid ""
"Allocate and initialize an sg table from a list of pages. Contiguous ranges "
"of the pages are squashed into a single scatterlist node up to the maximum "
"size specified in **max_segment**. A user may provide an offset at a start "
"and a size of valid data in a buffer specified by the page array."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:550
msgid "The returned sg table is released by sg_free_table."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:579 lib/scatterlist.c:636
msgid "allocate a scatterlist and its pages"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:585 lib/scatterlist.c:642
msgid "``unsigned long long length``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:580
msgid "Length in bytes of the scatterlist. Must be at least one"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:582
msgid "``unsigned int order``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:581
msgid "Second argument for alloc_pages()"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:583
msgid "``bool chainable``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:582
msgid ""
"Whether or not to allocate an extra element in the scatterlist for "
"scatterlist chaining purposes"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:585 lib/scatterlist.c:639
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:584 lib/scatterlist.c:638
msgid "Memory allocation flags"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:586 lib/scatterlist.c:640
msgid "``unsigned int *nent_p``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:585
msgid "[out] Number of entries in the scatterlist that have pages"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:587 lib/scatterlist.c:641
msgid "A pointer to an initialized scatterlist or ``NULL`` upon failure."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:637
msgid "Length in bytes of the scatterlist"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:639
msgid "[out] Number of entries in the scatterlist"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:651 lib/scatterlist.c:681
#: lib/scatterlist.c:692
msgid "free a scatterlist and its pages"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:652 lib/scatterlist.c:682
#: lib/scatterlist.c:693
msgid "Scatterlist with one or more elements"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:654
msgid "``int nents``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:653
msgid "Maximum number of elements to free"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:655 lib/scatterlist.c:684
msgid "``int order``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:654 lib/scatterlist.c:683
msgid "Second argument for __free_pages()"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:656
msgid ""
"If several scatterlists have been chained and each chain element is freed "
"separately then it's essential to set nents correctly to avoid that a page "
"would get freed twice."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:659
msgid ""
"All pages in a chained scatterlist can be freed at once by setting **nents** "
"to a high number."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:766
msgid "start mapping iteration over a sg list"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:772 lib/scatterlist.c:819
#: lib/scatterlist.c:856 lib/scatterlist.c:897
msgid "``struct sg_mapping_iter *miter``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:767
msgid "sg mapping iter to be started"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:768
msgid "sg list to iterate over"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:769
msgid "number of sg entries"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:771
msgid "``unsigned int flags``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:770
msgid "sg iterator flags"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:772
msgid "Starts mapping iterator **miter**."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:775 lib/scatterlist.c:822
msgid "Don't care."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:813
msgid "reposition mapping iterator"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:814
msgid "sg mapping iter to be skipped"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:816
msgid "``off_t offset``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:815
msgid "number of bytes to plus the current location"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:817
msgid ""
"Sets the offset of **miter** to its current location plus **offset** bytes. "
"If mapping iterator **miter** has been proceeded by sg_miter_next(), this "
"stops **miter**."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:825
msgid ""
"true if **miter** contains the valid mapping.  false if end of sg list is "
"reached."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:850
msgid "proceed mapping iterator to the next mapping"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:851
msgid "sg mapping iter to proceed"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:853
msgid ""
"Proceeds **miter** to the next mapping.  **miter** should have been started "
"using sg_miter_start().  On successful return, **miter->page**, **miter-"
">addr** and **miter->length** point to the current mapping."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:858
msgid "May sleep if !SG_MITER_ATOMIC && !SG_MITER_LOCAL."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:861
msgid ""
"true if **miter** contains the next mapping.  false if end of sg list is "
"reached."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:891
msgid "stop mapping iteration"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:892
msgid "sg mapping iter to be stopped"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:894
msgid ""
"Stops mapping iterator **miter**.  **miter** should have been started using "
"sg_miter_start().  A stopped iteration can be resumed by calling "
"sg_miter_next() on it.  This is useful when resources (kmap) need to be "
"released during iteration."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:900
msgid "Don't care otherwise."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:932
msgid "Copy data between a linear buffer and an SG list"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:933 lib/scatterlist.c:982
#: lib/scatterlist.c:999 lib/scatterlist.c:1016 lib/scatterlist.c:1034
#: lib/scatterlist.c:1052
msgid "The SG list"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:934 lib/scatterlist.c:983
#: lib/scatterlist.c:1000 lib/scatterlist.c:1017 lib/scatterlist.c:1035
#: lib/scatterlist.c:1053
msgid "Number of SG entries"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:936 lib/scatterlist.c:1002
#: lib/scatterlist.c:1037
msgid "``void *buf``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:935 lib/scatterlist.c:984
#: lib/scatterlist.c:1018
msgid "Where to copy from"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:937 lib/scatterlist.c:986
#: lib/scatterlist.c:1003 lib/scatterlist.c:1020 lib/scatterlist.c:1038
#: lib/scatterlist.c:1055
msgid "``size_t buflen``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:936 lib/scatterlist.c:985
#: lib/scatterlist.c:1002 lib/scatterlist.c:1019 lib/scatterlist.c:1037
msgid "The number of bytes to copy"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:938 lib/scatterlist.c:1021
#: lib/scatterlist.c:1039 lib/scatterlist.c:1056
msgid "``off_t skip``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:937 lib/scatterlist.c:1020
#: lib/scatterlist.c:1038
msgid "Number of bytes to skip before copying"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:939
msgid "``bool to_buffer``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:938
msgid ""
"transfer direction (true == from an sg list to a buffer, false == from a "
"buffer to an sg list)"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:940 lib/scatterlist.c:986
#: lib/scatterlist.c:1003 lib/scatterlist.c:1021 lib/scatterlist.c:1039
msgid "Returns the number of copied bytes."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:981 lib/scatterlist.c:1015
msgid "Copy from a linear buffer to an SG list"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:998 lib/scatterlist.c:1033
msgid "Copy from an SG list to a linear buffer"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1001 lib/scatterlist.c:1036
msgid "Where to copy to"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1051
msgid "Zero-out a part of a SG list"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1054
msgid "The number of bytes to zero out"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1055
msgid "Number of bytes to skip before zeroing"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1056
msgid "Returns the number of bytes zeroed."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1357
msgid "Extract pages from an iterator and add to an sglist"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1363
msgid "``struct iov_iter *iter``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1358
msgid "The iterator to extract from"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1360
msgid "``size_t maxsize``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1359
msgid "The amount of iterator to copy"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1361
msgid "``struct sg_table *sgtable``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1360
msgid "The scatterlist table to fill in"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1362
msgid "``unsigned int sg_max``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1361
msgid "Maximum number of elements in **sgtable** that may be filled"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1363
msgid "``iov_iter_extraction_t extraction_flags``"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1362
msgid "Flags to qualify the request"
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1363
msgid ""
"Extract the page fragments from the given amount of the source iterator and "
"add them to a scatterlist that refers to all of those bits, to a maximum "
"addition of **sg_max** elements."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1367
msgid ""
"The pages referred to by UBUF- and IOVEC-type iterators are extracted and "
"pinned; BVEC-, KVEC-, FOLIOQ- and XARRAY-type are extracted but aren't "
"pinned; DISCARD-type is not supported."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1371
msgid "No end mark is placed on the scatterlist; that's left to the caller."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1373
msgid ""
"**extraction_flags** can have ITER_ALLOW_P2PDMA set to request peer-to-peer "
"DMA be allowed on the pages extracted."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1376
msgid ""
"If successful, **sgtable->nents** is updated to include the number of "
"elements added and the number of bytes added is returned.  **sgtable-"
">orig_nents** is left unaltered."
msgstr ""

#: ../../../core-api/dma-api:868: lib/scatterlist.c:1380
msgid ""
"The iov_iter_extract_mode() function should be used to query how cleanup "
"should be performed."
msgstr ""
