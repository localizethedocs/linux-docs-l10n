# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/asm-annotations.rst:2
msgid "Assembler Annotations"
msgstr ""

#: ../../../core-api/asm-annotations.rst:4
msgid "Copyright (c) 2017-2019 Jiri Slaby"
msgstr ""

#: ../../../core-api/asm-annotations.rst:6
msgid ""
"This document describes the new macros for annotation of data and code in "
"assembly. In particular, it contains information about ``SYM_FUNC_START``, "
"``SYM_FUNC_END``, ``SYM_CODE_START``, and similar."
msgstr ""

#: ../../../core-api/asm-annotations.rst:11
msgid "Rationale"
msgstr ""

#: ../../../core-api/asm-annotations.rst:12
msgid ""
"Some code like entries, trampolines, or boot code needs to be written in "
"assembly. The same as in C, such code is grouped into functions and "
"accompanied with data. Standard assemblers do not force users into precisely "
"marking these pieces as code, data, or even specifying their length. "
"Nevertheless, assemblers provide developers with such annotations to aid "
"debuggers throughout assembly. On top of that, developers also want to mark "
"some functions as *global* in order to be visible outside of their "
"translation units."
msgstr ""

#: ../../../core-api/asm-annotations.rst:21
msgid ""
"Over time, the Linux kernel has adopted macros from various projects (like "
"``binutils``) to facilitate such annotations. So for historic reasons, "
"developers have been using ``ENTRY``, ``END``, ``ENDPROC``, and other "
"annotations in assembly.  Due to the lack of their documentation, the macros "
"are used in rather wrong contexts at some locations. Clearly, ``ENTRY`` was "
"intended to denote the beginning of global symbols (be it data or code). "
"``END`` used to mark the end of data or end of special functions with *non-"
"standard* calling convention. In contrast, ``ENDPROC`` should annotate only "
"ends of *standard* functions."
msgstr ""

#: ../../../core-api/asm-annotations.rst:31
msgid ""
"When these macros are used correctly, they help assemblers generate a nice "
"object with both sizes and types set correctly. For example, the result of "
"``arch/x86/lib/putuser.S``::"
msgstr ""

#: ../../../core-api/asm-annotations.rst:41
msgid ""
"This is not only important for debugging purposes. When there are properly "
"annotated objects like this, tools can be run on them to generate more "
"useful information. In particular, on properly annotated objects, "
"``objtool`` can be run to check and fix the object if needed. Currently, "
"``objtool`` can report missing frame pointer setup/destruction in functions. "
"It can also automatically generate annotations for the ORC unwinder "
"(Documentation/arch/x86/orc-unwinder.rst) for most code. Both of these are "
"especially important to support reliable stack traces which are in turn "
"necessary for kernel live patching (Documentation/livepatch/livepatch.rst)."
msgstr ""

#: ../../../core-api/asm-annotations.rst:53
msgid "Caveat and Discussion"
msgstr ""

#: ../../../core-api/asm-annotations.rst:54
msgid ""
"As one might realize, there were only three macros previously. That is "
"indeed insufficient to cover all the combinations of cases:"
msgstr ""

#: ../../../core-api/asm-annotations.rst:57
msgid "standard/non-standard function"
msgstr ""

#: ../../../core-api/asm-annotations.rst:58
msgid "code/data"
msgstr ""

#: ../../../core-api/asm-annotations.rst:59
msgid "global/local symbol"
msgstr ""

#: ../../../core-api/asm-annotations.rst:61
msgid ""
"There was a discussion_ and instead of extending the current ``ENTRY/END*`` "
"macros, it was decided that brand new macros should be introduced instead::"
msgstr ""

#: ../../../core-api/asm-annotations.rst:71
msgid "Macros Description"
msgstr ""

#: ../../../core-api/asm-annotations.rst:73
msgid ""
"The new macros are prefixed with the ``SYM_`` prefix and can be divided into "
"three main groups:"
msgstr ""

#: ../../../core-api/asm-annotations.rst:76
msgid ""
"``SYM_FUNC_*`` -- to annotate C-like functions. This means functions with "
"standard C calling conventions. For example, on x86, this means that the "
"stack contains a return address at the predefined place and a return from "
"the function can happen in a standard way. When frame pointers are enabled, "
"save/restore of frame pointer shall happen at the start/end of a function, "
"respectively, too."
msgstr ""

#: ../../../core-api/asm-annotations.rst:83
msgid ""
"Checking tools like ``objtool`` should ensure such marked functions conform "
"to these rules. The tools can also easily annotate these functions with "
"debugging information (like *ORC data*) automatically."
msgstr ""

#: ../../../core-api/asm-annotations.rst:87
msgid ""
"``SYM_CODE_*`` -- special functions called with special stack. Be it "
"interrupt handlers with special stack content, trampolines, or startup "
"functions."
msgstr ""

#: ../../../core-api/asm-annotations.rst:91
msgid ""
"Checking tools mostly ignore checking of these functions. But some debug "
"information still can be generated automatically. For correct debug data, "
"this code needs hints like ``UNWIND_HINT_REGS`` provided by developers."
msgstr ""

#: ../../../core-api/asm-annotations.rst:95
msgid ""
"``SYM_DATA*`` -- obviously data belonging to ``.data`` sections and not to "
"``.text``. Data do not contain instructions, so they have to be treated "
"specially by the tools: they should not treat the bytes as instructions, nor "
"assign any debug information to them."
msgstr ""

#: ../../../core-api/asm-annotations.rst:101
msgid "Instruction Macros"
msgstr ""

#: ../../../core-api/asm-annotations.rst:102
msgid "This section covers ``SYM_FUNC_*`` and ``SYM_CODE_*`` enumerated above."
msgstr ""

#: ../../../core-api/asm-annotations.rst:104
msgid ""
"``objtool`` requires that all code must be contained in an ELF symbol. "
"Symbol names that have a ``.L`` prefix do not emit symbol table entries. ``."
"L`` prefixed symbols can be used within a code region, but should be avoided "
"for denoting a range of code via ``SYM_*_START/END`` annotations."
msgstr ""

#: ../../../core-api/asm-annotations.rst:109
msgid ""
"``SYM_FUNC_START`` and ``SYM_FUNC_START_LOCAL`` are supposed to be **the "
"most frequent markings**. They are used for functions with standard calling "
"conventions -- global and local. Like in C, they both align the functions to "
"architecture specific ``__ALIGN`` bytes. There are also ``_NOALIGN`` "
"variants for special cases where developers do not want this implicit "
"alignment."
msgstr ""

#: ../../../core-api/asm-annotations.rst:115
msgid ""
"``SYM_FUNC_START_WEAK`` and ``SYM_FUNC_START_WEAK_NOALIGN`` markings are "
"also offered as an assembler counterpart to the *weak* attribute known from "
"C."
msgstr ""

#: ../../../core-api/asm-annotations.rst:119
msgid ""
"All of these **shall** be coupled with ``SYM_FUNC_END``. First, it marks the "
"sequence of instructions as a function and computes its size to the "
"generated object file. Second, it also eases checking and processing such "
"object files as the tools can trivially find exact function boundaries."
msgstr ""

#: ../../../core-api/asm-annotations.rst:124
msgid ""
"So in most cases, developers should write something like in the following "
"example, having some asm instructions in between the macros, of course::"
msgstr ""

#: ../../../core-api/asm-annotations.rst:131
msgid ""
"In fact, this kind of annotation corresponds to the now deprecated ``ENTRY`` "
"and ``ENDPROC`` macros."
msgstr ""

#: ../../../core-api/asm-annotations.rst:134
msgid ""
"``SYM_FUNC_ALIAS``, ``SYM_FUNC_ALIAS_LOCAL``, and ``SYM_FUNC_ALIAS_WEAK`` "
"can be used to define multiple names for a function. The typical use is::"
msgstr ""

#: ../../../core-api/asm-annotations.rst:142
msgid ""
"In this example, one can call ``__memset`` or ``memset`` with the same "
"result, except the debug information for the instructions is generated to "
"the object file only once -- for the non-``ALIAS`` case."
msgstr ""

#: ../../../core-api/asm-annotations.rst:146
msgid ""
"``SYM_CODE_START`` and ``SYM_CODE_START_LOCAL`` should be used only in "
"special cases -- if you know what you are doing. This is used exclusively "
"for interrupt handlers and similar where the calling convention is not the C "
"one. ``_NOALIGN`` variants exist too. The use is the same as for the "
"``FUNC`` category above::"
msgstr ""

#: ../../../core-api/asm-annotations.rst:156
msgid ""
"Again, every ``SYM_CODE_START*`` **shall** be coupled by ``SYM_CODE_END``."
msgstr ""

#: ../../../core-api/asm-annotations.rst:158
msgid ""
"To some extent, this category corresponds to deprecated ``ENTRY`` and "
"``END``. Except ``END`` had several other meanings too."
msgstr ""

#: ../../../core-api/asm-annotations.rst:161
msgid ""
"``SYM_INNER_LABEL*`` is used to denote a label inside some ``SYM_{CODE,FUNC}"
"_START`` and ``SYM_{CODE,FUNC}_END``.  They are very similar to C labels, "
"except they can be made global. An example of use::"
msgstr ""

#: ../../../core-api/asm-annotations.rst:180
msgid "Data Macros"
msgstr ""

#: ../../../core-api/asm-annotations.rst:181
msgid ""
"Similar to instructions, there is a couple of macros to describe data in the "
"assembly."
msgstr ""

#: ../../../core-api/asm-annotations.rst:184
msgid ""
"``SYM_DATA_START`` and ``SYM_DATA_START_LOCAL`` mark the start of some data "
"and shall be used in conjunction with either ``SYM_DATA_END``, or "
"``SYM_DATA_END_LABEL``. The latter adds also a label to the end, so that "
"people can use ``lstack`` and (local) ``lstack_end`` in the following "
"example::"
msgstr ""

#: ../../../core-api/asm-annotations.rst:194
msgid ""
"``SYM_DATA`` and ``SYM_DATA_LOCAL`` are variants for simple, mostly one-line "
"data::"
msgstr ""

#: ../../../core-api/asm-annotations.rst:200
msgid ""
"In the end, they expand to ``SYM_DATA_START`` with ``SYM_DATA_END`` "
"internally."
msgstr ""

#: ../../../core-api/asm-annotations.rst:204
msgid "Support Macros"
msgstr ""

#: ../../../core-api/asm-annotations.rst:205
msgid ""
"All the above reduce themselves to some invocation of ``SYM_START``, "
"``SYM_END``, or ``SYM_ENTRY`` at last. Normally, developers should avoid "
"using these."
msgstr ""

#: ../../../core-api/asm-annotations.rst:209
msgid ""
"Further, in the above examples, one could see ``SYM_L_LOCAL``. There are "
"also ``SYM_L_GLOBAL`` and ``SYM_L_WEAK``. All are intended to denote linkage "
"of a symbol marked by them. They are used either in ``_LABEL`` variants of "
"the earlier macros, or in ``SYM_START``."
msgstr ""

#: ../../../core-api/asm-annotations.rst:216
msgid "Overriding Macros"
msgstr ""

#: ../../../core-api/asm-annotations.rst:217
msgid ""
"Architecture can also override any of the macros in their own ``asm/linkage."
"h``, including macros specifying the type of a symbol (``SYM_T_FUNC``, "
"``SYM_T_OBJECT``, and ``SYM_T_NONE``).  As every macro described in this "
"file is surrounded by ``#ifdef`` + ``#endif``, it is enough to define the "
"macros differently in the aforementioned architecture-dependent header."
msgstr ""
