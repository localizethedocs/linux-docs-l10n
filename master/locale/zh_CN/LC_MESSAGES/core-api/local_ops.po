# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/local_ops.rst:6
msgid "Semantics and Behavior of Local Atomic Operations"
msgstr ""

#: ../../../core-api/local_ops.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/local_ops.rst:8
msgid "Mathieu Desnoyers"
msgstr ""

#: ../../../core-api/local_ops.rst:11
msgid ""
"This document explains the purpose of the local atomic operations, how to "
"implement them for any given architecture and shows how they can be used "
"properly. It also stresses on the precautions that must be taken when "
"reading those local variables across CPUs when the order of memory writes "
"matters."
msgstr ""

#: ../../../core-api/local_ops.rst:18
msgid ""
"Note that ``local_t`` based operations are not recommended for general "
"kernel use. Please use the ``this_cpu`` operations instead unless there is "
"really a special purpose. Most uses of ``local_t`` in the kernel have been "
"replaced by ``this_cpu`` operations. ``this_cpu`` operations combine the "
"relocation with the ``local_t`` like semantics in a single instruction and "
"yield more compact and faster executing code."
msgstr ""

#: ../../../core-api/local_ops.rst:27
msgid "Purpose of local atomic operations"
msgstr ""

#: ../../../core-api/local_ops.rst:29
msgid ""
"Local atomic operations are meant to provide fast and highly reentrant per "
"CPU counters. They minimize the performance cost of standard atomic "
"operations by removing the LOCK prefix and memory barriers normally required "
"to synchronize across CPUs."
msgstr ""

#: ../../../core-api/local_ops.rst:34
msgid ""
"Having fast per CPU atomic counters is interesting in many cases: it does "
"not require disabling interrupts to protect from interrupt handlers and it "
"permits coherent counters in NMI handlers. It is especially useful for "
"tracing purposes and for various performance monitoring counters."
msgstr ""

#: ../../../core-api/local_ops.rst:39
msgid ""
"Local atomic operations only guarantee variable modification atomicity wrt "
"the CPU which owns the data. Therefore, care must taken to make sure that "
"only one CPU writes to the ``local_t`` data. This is done by using per cpu "
"data and making sure that we modify it from within a preemption safe "
"context. It is however permitted to read ``local_t`` data from any CPU: it "
"will then appear to be written out of order wrt other memory writes by the "
"owner CPU."
msgstr ""

#: ../../../core-api/local_ops.rst:48
msgid "Implementation for a given architecture"
msgstr ""

#: ../../../core-api/local_ops.rst:50
msgid ""
"It can be done by slightly modifying the standard atomic operations: only "
"their UP variant must be kept. It typically means removing LOCK prefix (on "
"i386 and x86_64) and any SMP synchronization barrier. If the architecture "
"does not have a different behavior between SMP and UP, including ``asm-"
"generic/local.h`` in your architecture's ``local.h`` is sufficient."
msgstr ""

#: ../../../core-api/local_ops.rst:56
msgid ""
"The ``local_t`` type is defined as an opaque ``signed long`` by embedding an "
"``atomic_long_t`` inside a structure. This is made so a cast from this type "
"to a ``long`` fails. The definition looks like::"
msgstr ""

#: ../../../core-api/local_ops.rst:64
msgid "Rules to follow when using local atomic operations"
msgstr ""

#: ../../../core-api/local_ops.rst:66
msgid "Variables touched by local ops must be per cpu variables."
msgstr ""

#: ../../../core-api/local_ops.rst:67
msgid "*Only* the CPU owner of these variables must write to them."
msgstr ""

#: ../../../core-api/local_ops.rst:68
msgid ""
"This CPU can use local ops from any context (process, irq, softirq, "
"nmi, ...) to update its ``local_t`` variables."
msgstr ""

#: ../../../core-api/local_ops.rst:70
msgid ""
"Preemption (or interrupts) must be disabled when using local ops in process "
"context to make sure the process won't be migrated to a different CPU "
"between getting the per-cpu variable and doing the actual local op."
msgstr ""

#: ../../../core-api/local_ops.rst:74
msgid ""
"When using local ops in interrupt context, no special care must be taken on "
"a mainline kernel, since they will run on the local CPU with preemption "
"already disabled. I suggest, however, to explicitly disable preemption "
"anyway to make sure it will still work correctly on -rt kernels."
msgstr ""

#: ../../../core-api/local_ops.rst:79
msgid ""
"Reading the local cpu variable will provide the current copy of the variable."
msgstr ""

#: ../../../core-api/local_ops.rst:81
msgid ""
"Reads of these variables can be done from any CPU, because updates to "
"\"``long``\", aligned, variables are always atomic. Since no memory "
"synchronization is done by the writer CPU, an outdated copy of the variable "
"can be read when reading some *other* cpu's variables."
msgstr ""

#: ../../../core-api/local_ops.rst:88
msgid "How to use local atomic operations"
msgstr ""

#: ../../../core-api/local_ops.rst:99
msgid "Counting"
msgstr ""

#: ../../../core-api/local_ops.rst:101
msgid "Counting is done on all the bits of a signed long."
msgstr ""

#: ../../../core-api/local_ops.rst:103
msgid ""
"In preemptible context, use ``get_cpu_var()`` and ``put_cpu_var()`` around "
"local atomic operations: it makes sure that preemption is disabled around "
"write access to the per cpu variable. For instance::"
msgstr ""

#: ../../../core-api/local_ops.rst:110
msgid ""
"If you are already in a preemption-safe context, you can use "
"``this_cpu_ptr()`` instead::"
msgstr ""

#: ../../../core-api/local_ops.rst:118
msgid "Reading the counters"
msgstr ""

#: ../../../core-api/local_ops.rst:120
msgid ""
"Those local counters can be read from foreign CPUs to sum the count. Note "
"that the data seen by local_read across CPUs must be considered to be out of "
"order relatively to other memory writes happening on the CPU that owns the "
"data::"
msgstr ""

#: ../../../core-api/local_ops.rst:128
msgid ""
"If you want to use a remote local_read to synchronize access to a resource "
"between CPUs, explicit ``smp_wmb()`` and ``smp_rmb()`` memory barriers must "
"be used respectively on the writer and the reader CPUs. It would be the case "
"if you use the ``local_t`` variable as a counter of bytes written in a "
"buffer: there should be a ``smp_wmb()`` between the buffer write and the "
"counter increment and also a ``smp_rmb()`` between the counter read and the "
"buffer read."
msgstr ""

#: ../../../core-api/local_ops.rst:136
msgid ""
"Here is a sample module which implements a basic per cpu counter using "
"``local.h``::"
msgstr ""
