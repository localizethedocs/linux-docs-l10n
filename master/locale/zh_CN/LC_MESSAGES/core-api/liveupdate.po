# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/liveupdate.rst:5
msgid "Live Update Orchestrator"
msgstr ""

#: ../../../core-api/liveupdate.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/liveupdate.rst:6
msgid "Pasha Tatashin <pasha.tatashin@soleen.com>"
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:9
msgid ""
"Live Update is a specialized, kexec-based reboot process that allows a "
"running kernel to be updated from one version to another while preserving "
"the state of selected resources and keeping designated hardware devices "
"operational. For these devices, DMA activity may continue throughout the "
"kernel transition."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:15
msgid ""
"While the primary use case driving this work is supporting live updates of "
"the Linux kernel when it is used as a hypervisor in cloud environments, the "
"LUO framework itself is designed to be workload-agnostic. Live Update "
"facilitates a full kernel version upgrade for any type of system."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:20
msgid ""
"For example, a non-hypervisor system running an in-memory cache like "
"memcached with many gigabytes of data can use LUO. The userspace service can "
"place its cache into a memfd, have its state preserved by LUO, and restore "
"it immediately after the kernel kexec."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:25
msgid ""
"Whether the system is running virtual machines, containers, a high-"
"performance database, or networking services, LUO's primary goal is to "
"enable a full kernel update by preserving critical userspace state and "
"keeping essential devices operational."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:30
msgid ""
"The core of LUO is a mechanism that tracks the progress of a live update, "
"along with a callback API that allows other kernel subsystems to participate "
"in the process. Example subsystems that can hook into LUO include: kvm, "
"iommu, interrupts, vfio, participating filesystems, and memory management."
msgstr ""

#: ../../../core-api/liveupdate:8: ../kernel/liveupdate/luo_core.c:35
msgid ""
"LUO uses Kexec Handover to transfer memory state from the current kernel to "
"the next kernel. For more details see Documentation/core-api/kho/index.rst."
msgstr ""

#: ../../../core-api/liveupdate.rst:12
msgid "LUO Sessions"
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:9
msgid ""
"LUO Sessions provide the core mechanism for grouping and managing `struct "
"file *` instances that need to be preserved across a kexec-based live "
"update. Each session acts as a named container for a set of file objects, "
"allowing a userspace agent to manage the lifecycle of resources critical to "
"a workload."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:15
msgid "Core Concepts:"
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:17
msgid ""
"Named Containers: Sessions are identified by a unique, user-provided name, "
"which is used for both creation in the current kernel and retrieval in the "
"next kernel."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:21
msgid ""
"Userspace Interface: Session management is driven from userspace via ioctls "
"on /dev/liveupdate."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:24
msgid ""
"Serialization: Session metadata is preserved using the KHO framework. When a "
"live update is triggered via kexec, an array of `struct luo_session_ser` is "
"populated and placed in a preserved memory region. An FDT node is also "
"created, containing the count of sessions and the physical address of this "
"array."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:30
msgid "Session Lifecycle:"
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:32
msgid ""
"Creation: A userspace agent calls `luo_session_create()` to create a new, "
"empty session and receives a file descriptor for it."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:35
msgid ""
"Serialization: When the `reboot(LINUX_REBOOT_CMD_KEXEC)` syscall is made, "
"`luo_session_serialize()` is called. It iterates through all active sessions "
"and writes their metadata into a memory area preserved by KHO."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:40
msgid ""
"Deserialization (in new kernel): After kexec, `luo_session_deserialize()` "
"runs, reading the serialized data and creating a list of `struct "
"luo_session` objects representing the preserved sessions."
msgstr ""

#: ../../../core-api/liveupdate:13: ../kernel/liveupdate/luo_session.c:44
msgid ""
"Retrieval: A userspace agent in the new kernel can then call "
"`luo_session_retrieve()` with a session name to get a new file descriptor "
"and access the preserved state."
msgstr ""

#: ../../../core-api/liveupdate.rst:17
msgid "LUO Preserving File Descriptors"
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:9
msgid ""
"LUO provides the infrastructure to preserve specific, stateful file "
"descriptors across a kexec-based live update. The primary goal is to allow "
"workloads, such as virtual machines using vfio, memfd, or iommufd, to retain "
"access to their essential resources without interruption."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:14
msgid ""
"The framework is built around a callback-based handler model and a well- "
"defined lifecycle for each preserved file."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:17
msgid ""
"Handler Registration: Kernel modules responsible for a specific file type (e."
"g., memfd, vfio) register a :c:type:`struct liveupdate_file_handler "
"<liveupdate_file_handler>`. This handler provides a set of callbacks that "
"LUO invokes at different stages of the update process, most notably:"
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:23
msgid ""
"can_preserve(): A lightweight check to determine if the handler is "
"compatible with a given 'struct file'."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:25
msgid ""
"preserve(): The heavyweight operation that saves the file's state and "
"returns an opaque u64 handle. This is typically performed while the workload "
"is still active to minimize the downtime during the actual reboot transition."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:29
msgid ""
"unpreserve(): Cleans up any resources allocated by .preserve(), called if "
"the preservation process is aborted before the reboot (i.e. session is "
"closed)."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:32
msgid ""
"freeze(): A final pre-reboot opportunity to prepare the state for kexec. We "
"are already in reboot syscall, and therefore userspace cannot mutate the "
"file anymore."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:35
msgid ""
"unfreeze(): Undoes the actions of .freeze(), called if the live update is "
"aborted after the freeze phase."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:37
msgid ""
"retrieve(): Reconstructs the file in the new kernel from the preserved "
"handle."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:39
msgid ""
"finish(): Performs final check and cleanup in the new kernel. After succesul "
"finish call, LUO gives up ownership to this file."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:42
msgid "File Preservation Lifecycle happy path:"
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:44
msgid ""
"Preserve (Normal Operation): A userspace agent preserves files one by one "
"via an ioctl. For each file, luo_preserve_file() finds a compatible handler, "
"calls its .preserve() operation, and creates an internal :c:type:`struct "
"luo_file <luo_file>` to track the live state."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:49
msgid ""
"Freeze (Pre-Reboot): Just before the kexec, luo_file_freeze() is called. It "
"iterates through all preserved files, calls their respective .freeze() "
"operation, and serializes their final metadata (compatible string, token, "
"and data handle) into a contiguous memory block for KHO."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:54
msgid ""
"Deserialize: After kexec, luo_file_deserialize() runs when session gets "
"deserialized (which is when /dev/liveupdate is first opened). It reads the "
"serialized data from the KHO memory region and reconstructs the in-memory "
"list of :c:type:`struct luo_file <luo_file>` instances for the new kernel, "
"linking them to their corresponding handlers."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:60
msgid ""
"Retrieve (New Kernel - Userspace Ready): The userspace agent can now restore "
"file descriptors by providing a token. luo_retrieve_file() searches for the "
"matching token, calls the handler's .retrieve() op to re-create the 'struct "
"file', and returns a new FD. Files can be retrieved in ANY order."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:66
msgid ""
"Finish (New Kernel - Cleanup): Once a session retrival is complete, "
"luo_file_finish() is called. It iterates through all files, invokes their ."
"finish() operations for final cleanup, and releases all associated kernel "
"resources."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:71
msgid "File Preservation Lifecycle unhappy paths:"
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:73
msgid ""
"Abort Before Reboot: If the userspace agent aborts the live update process "
"before calling reboot (e.g., by closing the session file descriptor), the "
"session's release handler calls luo_file_unpreserve_files(). This invokes "
"the .unpreserve() callback on all preserved files, ensuring all allocated "
"resources are cleaned up and returning the system to a clean state."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:80
msgid ""
"Freeze Failure: During the reboot() syscall, if any handler's .freeze() op "
"fails, the .unfreeze() op is invoked on all previously *successful* freezes "
"to roll back their state. The reboot() syscall then returns an error to "
"userspace, canceling the live update."
msgstr ""

#: ../../../core-api/liveupdate:18: ../kernel/liveupdate/luo_file.c:85
msgid ""
"Finish Failure: In the new kernel, if a handler's .finish() op fails, the "
"luo_file_finish() operation is aborted. LUO retains ownership of all files "
"within that session, including those that were not yet processed. The "
"userspace agent can attempt to call the finish operation again later. If the "
"issue cannot be resolved, these resources will be held by LUO until the next "
"live update cycle, at which point they will be discarded."
msgstr ""

#: ../../../core-api/liveupdate.rst:22
msgid "LUO File Lifecycle Bound Global Data"
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:9
msgid ""
"File-Lifecycle-Bound (FLB) objects provide a mechanism for managing global "
"state that is shared across multiple live-updatable files. The lifecycle of "
"this shared state is tied to the preservation of the files that depend on it."
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:13
msgid ""
"An FLB represents a global resource, such as the IOMMU core state, that is "
"required by multiple file descriptors (e.g., all VFIO fds)."
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:16
msgid ""
"The preservation of the FLB's state is triggered when the *first* file "
"depending on it is preserved. The cleanup of this state (unpreserve or "
"finish) is triggered when the *last* file depending on it is unpreserved or "
"finished."
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:21
msgid ""
"Handler Dependency: A file handler declares its dependency on one or more "
"FLBs by registering them via liveupdate_register_flb()."
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:24
msgid ""
"Callback Model: Each FLB is defined by a set of operations (:c:type:`struct "
"liveupdate_flb_ops <liveupdate_flb_ops>`) that LUO invokes at key points:"
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:27
msgid ".preserve(): Called for the first file. Saves global state."
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:28
msgid ".unpreserve(): Called for the last file (if aborted pre-reboot)."
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:29
msgid ".retrieve(): Called on-demand in the new kernel to restore the state."
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:30
msgid ".finish(): Called for the last file in the new kernel for cleanup."
msgstr ""

#: ../../../core-api/liveupdate:23: ../kernel/liveupdate/luo_flb.c:32
msgid ""
"This reference-counted approach ensures that shared state is saved exactly "
"once and restored exactly once, regardless of how many files depend on it, "
"and that its lifecycle is correctly managed across the kexec transition."
msgstr ""

#: ../../../core-api/liveupdate.rst:27
msgid "Live Update Orchestrator ABI"
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:9
msgid ""
"Live Update Orchestrator uses the stable Application Binary Interface "
"defined below to pass state from a pre-update kernel to a post-update "
"kernel. The ABI is built upon the Kexec HandOver framework and uses a "
"Flattened Device Tree to describe the preserved data."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:14
msgid ""
"This interface is a contract. Any modification to the FDT structure, node "
"properties, compatible strings, or the layout of the `__packed` "
"serialization structures defined here constitutes a breaking change. Such "
"changes require incrementing the version number in the relevant "
"`_COMPATIBLE` string to prevent a new kernel from misinterpreting data from "
"an old kernel."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:20
msgid ""
"Changes are allowed provided the compatibility version is incremented; "
"however, backward/forward compatibility is only guaranteed for kernels "
"supporting the same ABI version."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:24
msgid "FDT Structure Overview:"
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:25
msgid ""
"The entire LUO state is encapsulated within a single KHO entry named "
"\"LUO\". This entry contains an FDT with the following layout:"
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:45
msgid "Main LUO Node (/):"
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:47
msgid "compatible: \"luo-v1\" Identifies the overall LUO ABI version."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:49
msgid ""
"liveupdate-number: u64 A counter tracking the number of successful live "
"updates performed."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:52
msgid "Session Node (luo-session):"
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:53
msgid "This node describes all preserved user-space sessions."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:55
msgid "compatible: \"luo-session-v1\" Identifies the session ABI version."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:57
msgid ""
"luo-session-header: u64 The physical address of a `struct "
"luo_session_header_ser`. This structure is the header for a contiguous block "
"of memory containing an array of `struct luo_session_ser`, one for each "
"preserved session."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:62
msgid "File-Lifecycle-Bound Node (luo-flb):"
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:63
msgid ""
"This node describes all preserved global objects whose lifecycle is bound to "
"that of the preserved files (e.g., shared IOMMU state)."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:66
msgid "compatible: \"luo-flb-v1\" Identifies the FLB ABI version."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:68
msgid ""
"luo-flb-header: u64 The physical address of a `struct luo_flb_header_ser`. "
"This structure is the header for a contiguous block of memory containing an "
"array of `struct luo_flb_ser`, one for each preserved global object."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:73
msgid "Serialization Structures:"
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:74
msgid ""
"The FDT properties point to memory regions containing arrays of simple, "
"`__packed` structures. These structures contain the actual preserved state."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:77
msgid ""
"struct luo_session_header_ser: Header for the session array. Contains the "
"total page count of the preserved memory block and the number of `struct "
"luo_session_ser` entries that follow."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:82
msgid ""
"struct luo_session_ser: Metadata for a single session, including its name "
"and a physical pointer to another preserved memory block containing an array "
"of `struct luo_file_ser` for all files in that session."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:87
msgid ""
"struct luo_file_ser: Metadata for a single preserved file. Contains the "
"`compatible` string to find the correct handler in the new kernel, a user-"
"provided `token` for identification, and an opaque `data` handle for the "
"handler to use."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:92
msgid ""
"struct luo_flb_header_ser: Header for the FLB array. Contains the total page "
"count of the preserved memory block and the number of `struct luo_flb_ser` "
"entries that follow."
msgstr ""

#: ../../../core-api/liveupdate:28: ../include/linux/kho/abi/luo.h:97
msgid ""
"struct luo_flb_ser: Metadata for a single preserved global object. Contains "
"its `name` (compatible string), an opaque `data` handle, and the `count` "
"number of files depending on it."
msgstr ""

#: ../../../core-api/liveupdate.rst:31
msgid "The following types of file descriptors can be preserved"
msgstr ""

#: ../../../core-api/liveupdate.rst:39
msgid "Public API"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:24
msgid "Arguments for file operation callbacks."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:28
#: ../include/linux/liveupdate.h:54 ../include/linux/liveupdate.h:86
#: ../include/linux/liveupdate.h:114 ../include/linux/liveupdate.h:132
#: ../include/linux/liveupdate.h:203 ../../../core-api/liveupdate:42:
#: ../include/linux/kho/abi/luo.h:127 ../include/linux/kho/abi/luo.h:141
#: ../include/linux/kho/abi/luo.h:164 ../include/linux/kho/abi/luo.h:179
#: ../include/linux/kho/abi/luo.h:204 ../include/linux/kho/abi/luo.h:224
#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:83
#: ../kernel/liveupdate/luo_session.c:104 ../../../core-api/liveupdate:65:
#: ../kernel/liveupdate/luo_file.c:127
msgid "**Definition**::"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:38
#: ../include/linux/liveupdate.h:68 ../include/linux/liveupdate.h:93
#: ../include/linux/liveupdate.h:122 ../include/linux/liveupdate.h:142
#: ../include/linux/liveupdate.h:210 ../../../core-api/liveupdate:42:
#: ../include/linux/kho/abi/luo.h:135 ../include/linux/kho/abi/luo.h:148
#: ../include/linux/kho/abi/luo.h:170 ../include/linux/kho/abi/luo.h:186
#: ../include/linux/kho/abi/luo.h:211 ../include/linux/kho/abi/luo.h:232
#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:94
#: ../kernel/liveupdate/luo_session.c:111 ../../../core-api/liveupdate:65:
#: ../kernel/liveupdate/luo_file.c:140
msgid "**Members**"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:25
msgid "``handler``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:26
msgid "The file handler being called."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:26
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:137
msgid "``retrieved``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:27
msgid "The retrieve status for the 'can_finish / finish' operation."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:28
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:126
msgid "``file``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:29
msgid ""
"The file object. For retrieve: [OUT] The callback sets this to the new file. "
"For other ops: [IN] The caller sets this to the file being operated on."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:31
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:129
msgid "``serialized_data``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:32
msgid "The opaque u64 handle, preserve/prepare/freeze may update this field."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:33
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:133
msgid "``private_data``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:34
msgid ""
"Private data for the file used to hold runtime state that is not preserved. "
"Set by the handler's .preserve() callback, and must be freed in the "
"handler's .unpreserve() callback."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:40
#: ../include/linux/liveupdate.h:67 ../include/linux/liveupdate.h:91
#: ../include/linux/liveupdate.h:121 ../include/linux/liveupdate.h:148
#: ../include/linux/liveupdate.h:209 ../../../core-api/liveupdate:42:
#: ../include/linux/kho/abi/luo.h:130 ../include/linux/kho/abi/luo.h:166
#: ../include/linux/kho/abi/luo.h:182 ../include/linux/kho/abi/luo.h:209
#: ../include/linux/kho/abi/luo.h:232 ../../../core-api/liveupdate:56:
#: ../kernel/liveupdate/luo_core.c:3 ../../../core-api/liveupdate:59:
#: ../kernel/liveupdate/luo_flb.c:3 ../kernel/liveupdate/luo_flb.c:226
#: ../kernel/liveupdate/luo_flb.c:262 ../kernel/liveupdate/luo_flb.c:283
#: ../kernel/liveupdate/luo_flb.c:304 ../kernel/liveupdate/luo_flb.c:413
#: ../kernel/liveupdate/luo_flb.c:485 ../kernel/liveupdate/luo_flb.c:522
#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:3
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:149
#: ../kernel/liveupdate/luo_file.c:221 ../kernel/liveupdate/luo_file.c:333
#: ../kernel/liveupdate/luo_file.c:436 ../kernel/liveupdate/luo_file.c:512
#: ../kernel/liveupdate/luo_file.c:540 ../kernel/liveupdate/luo_file.c:645
#: ../kernel/liveupdate/luo_file.c:715 ../kernel/liveupdate/luo_file.c:878
msgid "**Description**"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:37
msgid ""
"This structure bundles all parameters for the file operation callbacks. The "
"'data' and 'file' fields are used for both input and output."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:50
msgid "Callbacks for live-updatable files."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:51
msgid "``can_preserve``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:52
msgid ""
"Required. Lightweight check to see if this handler is compatible with the "
"given file."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:53
#: ../include/linux/liveupdate.h:129
msgid "``preserve``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:54
msgid "Required. Performs state-saving for the file."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:54
#: ../include/linux/liveupdate.h:133
msgid "``unpreserve``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:55
msgid "Required. Cleans up any resources allocated by **preserve**."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:55
msgid "``freeze``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:56
msgid "Optional. Final actions just before kernel transition."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:56
msgid "``unfreeze``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:57
msgid "Optional. Undo freeze operations."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:57
#: ../include/linux/liveupdate.h:136
msgid "``retrieve``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:58
msgid "Required. Restores the file in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:58
msgid "``can_finish``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:59
msgid ""
"Optional. Check if this FD can finish, i.e. all restoration pre-requirements "
"for this FD are satisfied. Called prior to finish, in order to do successful "
"finish calls for all resources in the session."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:62
#: ../include/linux/liveupdate.h:141
msgid "``finish``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:63
msgid "Required. Final cleanup in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:63
#: ../include/linux/liveupdate.h:144
msgid "``owner``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:64
#: ../include/linux/liveupdate.h:145
msgid "Module reference"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:64
msgid ""
"All operations (except can_preserve) receive a pointer to a 'struct "
"liveupdate_file_op_args' containing the necessary context."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:82
msgid "Represents a handler for a live-updatable file type."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:83
#: ../include/linux/liveupdate.h:200
msgid "``ops``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:84
#: ../include/linux/liveupdate.h:201
msgid "Callback functions"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:84
#: ../include/linux/liveupdate.h:201 ../../../core-api/liveupdate:42:
#: ../include/linux/kho/abi/luo.h:124
msgid "``compatible``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:85
msgid ""
"The compatibility string (e.g., \"memfd-v1\", \"vfiofd-v1\") that uniquely "
"identifies the file type this handler supports. This is matched against the "
"compatible string associated with individual :c:type:`struct file <file>` "
"instances."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:88
msgid ""
"Modules that want to support live update for specific file types should "
"register an instance of this structure. LUO uses this registration to "
"determine if a given file can be preserved and to find the appropriate "
"operations to manage its state across the update."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:110
msgid "Arguments for FLB operation callbacks."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:111
msgid "``flb``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:112
msgid "The global FLB instance for which this call is performed."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:112
#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:125
#: ../include/linux/kho/abi/luo.h:223
msgid "``data``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:113
msgid ""
"For .preserve():    [OUT] The callback sets this field. For .unpreserve():  "
"[IN]  The handle from .preserve(). For .retrieve():    [IN]  The handle "
"from .preserve()."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:115
msgid "``obj``"
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:116
msgid ""
"For .preserve():    [OUT] Sets this to the live object. For .retrieve():    "
"[OUT] Sets this to the live object. For .finish():      [IN]  The live "
"object from .retrieve()."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:118
msgid "This structure bundles all parameters for the FLB operation callbacks."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:128
msgid "Callbacks for global File-Lifecycle-Bound data."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:130
msgid ""
"Called when the first file using this FLB is preserved. The callback must "
"save its state and return a single, self-contained u64 handle by setting the "
"'argp->data' field and 'argp->obj'."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:134
msgid ""
"Called when the last file using this FLB is unpreserved (aborted before "
"reboot). Receives the handle via 'argp->data' and live object via 'argp-"
">obj'."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:137
msgid ""
"Called on-demand in the new kernel, the first time a component requests "
"access to the shared object. It receives the preserved handle via 'argp-"
">data' and must reconstruct the live object, returning it by setting the "
"'argp->obj' field."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:142
msgid ""
"Called in the new kernel when the last file using this FLB is finished. "
"Receives the live object via 'argp->obj' for cleanup."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:145
msgid ""
"Operations that manage global shared data with file bound lifecycle, "
"triggered by the first file that uses it and concluded by the last file that "
"uses it, across all sessions."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:199
msgid "A global definition for a shared data object."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:202
msgid ""
"The compatibility string (e.g., \"iommu-core-v1\" that uniquely identifies "
"the FLB type this handler supports. This is matched against the compatible "
"string associated with individual :c:type:`struct liveupdate_flb "
"<liveupdate_flb>` instances."
msgstr ""

#: ../../../core-api/liveupdate:40: ../include/linux/liveupdate.h:206
msgid ""
"This struct is the \"template\" that a driver registers to define a shared, "
"file-lifecycle-bound object. The actual runtime state (the live object, "
"refcount, etc.) is managed privately by the LUO core."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:123
msgid "Represents the serialized preserves files."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:125
msgid "File handler compatible string."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:126
msgid "Private data"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:126
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:145
msgid "``token``"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:127
msgid "User provided token for this file"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:127
msgid "If this structure is modified, LUO_SESSION_COMPATIBLE must be updated."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:137
msgid "Represents the serialized metadata for file set"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:138
msgid "``files``"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:139
msgid ""
"The physical address of a contiguous memory block that holds the serialized "
"state of files (array of luo_file_ser) in this file set."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:141
#: ../include/linux/kho/abi/luo.h:161 ../include/linux/kho/abi/luo.h:204
#: ../include/linux/kho/abi/luo.h:226 ../../../core-api/liveupdate:62:
#: ../kernel/liveupdate/luo_session.c:80
msgid "``count``"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:142
msgid ""
"The total number of files that were part of this session during "
"serialization. Used for iteration and validation during restoration."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:160
msgid "Header for the serialized session data block."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:162
msgid ""
"The number of `struct luo_session_ser` entries that immediately follow this "
"header in the memory block."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:163
msgid ""
"This structure is located at the beginning of a contiguous block of physical "
"memory preserved across the kexec. It provides the necessary metadata to "
"interpret the array of session entries that follow."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:167
#: ../include/linux/kho/abi/luo.h:184
msgid ""
"If this structure is modified, `LUO_FDT_SESSION_COMPATIBLE` must be updated."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:175
msgid "Represents the serialized metadata for a LUO session."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:176
#: ../include/linux/kho/abi/luo.h:221
msgid "``name``"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:177
msgid ""
"The unique name of the session, provided by the userspace at the time of "
"session creation."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:178
msgid "``file_set_ser``"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:179
msgid "Serialized files belonging to this session,"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:179
msgid ""
"This structure is used to package session-specific metadata for transfer "
"between kernels via Kexec Handover. An array of these structures (one per "
"session) is created and passed to the new kernel, allowing it to reconstruct "
"the session context."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:200
msgid "Header for the serialized FLB data block."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:201
msgid "``pgcnt``"
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:202
msgid ""
"The total number of pages occupied by the entire preserved memory region, "
"including this header and the subsequent array of :c:type:`struct "
"luo_flb_ser <luo_flb_ser>` entries."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:205
msgid ""
"The number of :c:type:`struct luo_flb_ser <luo_flb_ser>` entries that follow "
"this header in the memory block."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:206
msgid ""
"This structure is located at the physical address specified by the "
"`LUO_FDT_FLB_HEADER` FDT property. It provides the new kernel with the "
"necessary information to find and iterate over the array of preserved File-"
"Lifecycle-Bound objects and to manage the underlying memory."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:211
#: ../include/linux/kho/abi/luo.h:233
msgid "If this structure is modified, LUO_FDT_FLB_COMPATIBLE must be updated."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:220
msgid "Represents the serialized state of a single FLB object."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:222
msgid ""
"The unique compatibility string of the FLB object, used to find the "
"corresponding :c:type:`struct liveupdate_flb <liveupdate_flb>` handler in "
"the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:224
msgid ""
"The opaque u64 handle returned by the FLB's .preserve() operation in the old "
"kernel. This handle encapsulates the entire state needed for restoration."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:227
msgid ""
"The reference count at the time of serialization; i.e., the number of "
"preserved files that depended on this FLB. This is used by the new kernel to "
"correctly manage the FLB's lifecycle."
msgstr ""

#: ../../../core-api/liveupdate:42: ../include/linux/kho/abi/luo.h:229
msgid ""
"An array of these structures is created in a preserved memory region and "
"passed to the new kernel. Each entry allows the LUO core to restore one "
"global, shared object."
msgstr ""

#: ../../../core-api/liveupdate.rst:55
msgid "Internal API"
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:211
msgid "Kernel reboot notifier for live update final serialization."
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:215
#: ../kernel/liveupdate/luo_core.c:251 ../../../core-api/liveupdate:59:
#: ../kernel/liveupdate/luo_flb.c:227 ../kernel/liveupdate/luo_flb.c:263
#: ../kernel/liveupdate/luo_flb.c:284 ../kernel/liveupdate/luo_flb.c:304
#: ../kernel/liveupdate/luo_flb.c:413 ../kernel/liveupdate/luo_flb.c:485
#: ../kernel/liveupdate/luo_flb.c:522 ../kernel/liveupdate/luo_flb.c:626
#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:609
#: ../kernel/liveupdate/luo_session.c:641 ../../../core-api/liveupdate:65:
#: ../kernel/liveupdate/luo_file.c:220 ../kernel/liveupdate/luo_file.c:334
#: ../kernel/liveupdate/luo_file.c:436 ../kernel/liveupdate/luo_file.c:512
#: ../kernel/liveupdate/luo_file.c:538 ../kernel/liveupdate/luo_file.c:646
#: ../kernel/liveupdate/luo_file.c:715 ../kernel/liveupdate/luo_file.c:815
#: ../kernel/liveupdate/luo_file.c:879
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:217
#: ../kernel/liveupdate/luo_core.c:253 ../../../core-api/liveupdate:59:
#: ../kernel/liveupdate/luo_flb.c:628 ../../../core-api/liveupdate:62:
#: ../kernel/liveupdate/luo_session.c:611
#: ../kernel/liveupdate/luo_session.c:643
msgid "``void``"
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:1
#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:1
#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:1
msgid "no arguments"
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:212
msgid ""
"This function is invoked directly from the reboot() syscall pathway if kexec "
"is in progress."
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:215
msgid ""
"If any callback fails, this function aborts KHO, undoes the freeze() "
"callbacks, and returns an error."
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:247
msgid "Check if the live update feature is enabled."
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:248
msgid ""
"This function returns the state of the live update feature flag, which can "
"be controlled via the ``liveupdate`` kernel command-line parameter."
msgstr ""

#: ../../../core-api/liveupdate:56: ../kernel/liveupdate/luo_core.c:251
msgid "**return** true if live update is enabled, false otherwise."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:223
msgid "Notifies FLBs that a file is about to be preserved."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:229
#: ../kernel/liveupdate/luo_flb.c:265 ../kernel/liveupdate/luo_flb.c:286
#: ../kernel/liveupdate/luo_flb.c:306 ../kernel/liveupdate/luo_flb.c:415
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:817
#: ../kernel/liveupdate/luo_file.c:881
msgid "``struct liveupdate_file_handler *fh``"
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:224
msgid "The file handler for the preserved file."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:225
msgid ""
"This function iterates through all FLBs associated with the given file "
"handler. It increments the reference count for each FLB. If the count "
"becomes 1, it triggers the FLB's .preserve() callback to save the global "
"state."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:229
msgid ""
"This operation is atomic. If any FLB's .preserve() op fails, it will roll "
"back by calling .unpreserve() on any FLBs that were successfully preserved "
"during this call."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:233
#: ../kernel/liveupdate/luo_flb.c:266 ../kernel/liveupdate/luo_flb.c:287
#: ../kernel/liveupdate/luo_flb.c:311 ../kernel/liveupdate/luo_flb.c:420
#: ../kernel/liveupdate/luo_flb.c:632 ../../../core-api/liveupdate:65:
#: ../kernel/liveupdate/luo_file.c:244 ../kernel/liveupdate/luo_file.c:460
#: ../kernel/liveupdate/luo_file.c:519 ../kernel/liveupdate/luo_file.c:551
#: ../kernel/liveupdate/luo_file.c:669 ../kernel/liveupdate/luo_file.c:732
#: ../kernel/liveupdate/luo_file.c:817
msgid "**Context**"
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:234
msgid "Called from luo_preserve_file()"
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:236
#: ../kernel/liveupdate/luo_flb.c:315 ../kernel/liveupdate/luo_flb.c:425
#: ../kernel/liveupdate/luo_flb.c:492 ../kernel/liveupdate/luo_flb.c:528
#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:616
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:247
#: ../kernel/liveupdate/luo_file.c:463 ../kernel/liveupdate/luo_file.c:555
#: ../kernel/liveupdate/luo_file.c:672 ../kernel/liveupdate/luo_file.c:820
#: ../kernel/liveupdate/luo_file.c:886
msgid "**Return**"
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:235
#: ../kernel/liveupdate/luo_flb.c:529 ../../../core-api/liveupdate:65:
#: ../kernel/liveupdate/luo_file.c:462 ../kernel/liveupdate/luo_file.c:671
msgid "0 on success, or a negative errno on failure."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:259
msgid "Notifies FLBs that a dependent file was unpreserved."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:260
msgid "The file handler for the unpreserved file."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:261
msgid ""
"This function iterates through all FLBs associated with the given file "
"handler, in reverse order of registration. It decrements the reference count "
"for each FLB. If the count becomes 0, it triggers the FLB's .unpreserve() "
"callback to clean up the global state."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:267
msgid ""
"Called when a preserved file is being cleaned up before reboot (e.g., from "
"luo_file_unpreserve_files())."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:280
msgid "Notifies FLBs that a dependent file has been finished."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:281
msgid "The file handler for the finished file."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:282
msgid ""
"This function iterates through all FLBs associated with the given file "
"handler, in reverse order of registration. It decrements the incoming "
"reference count for each FLB. If the count becomes 0, it triggers the FLB's ."
"finish() callback for final cleanup in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:288
msgid "Called from luo_file_finish() for each file being finished."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:300
msgid "Associate an FLB with a file handler and register it globally."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:301
msgid "The file handler that will now depend on the FLB."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:303
#: ../kernel/liveupdate/luo_flb.c:412 ../kernel/liveupdate/luo_flb.c:487
#: ../kernel/liveupdate/luo_flb.c:524
msgid "``struct liveupdate_flb *flb``"
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:302
msgid "The File-Lifecycle-Bound object to associate."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:303
msgid ""
"Establishes a dependency, informing the LUO core that whenever a file of "
"type **fh** is preserved, the state of **flb** must also be managed."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:306
msgid ""
"On the first registration of a given **flb** object, it is added to a global "
"registry. This function checks for duplicate registrations, both for a "
"specific handler and globally, and ensures the total number of unique FLBs "
"does not exceed the system limit."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:312
msgid ""
"Typically called from a subsystem's module init function after both the "
"handler and the FLB have been defined and initialized."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:314
msgid ""
"0 on success. Returns a negative errno on failure: -EINVAL if arguments are "
"NULL or not initialized. -ENOMEM on memory allocation failure. -EEXIST if "
"this FLB is already registered with this handler. -ENOSPC if the maximum "
"number of global FLBs has been reached. -EOPNOTSUPP if live update is "
"disabled or not configured."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:409
msgid "Remove an FLB dependency from a file handler."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:410
msgid "The file handler that is currently depending on the FLB."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:411
msgid "The File-Lifecycle-Bound object to remove."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:412
msgid ""
"Removes the association between the specified file handler and the FLB "
"previously established by liveupdate_register_flb()."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:415
msgid ""
"This function manages the global lifecycle of the FLB. It decrements the "
"FLB's usage count. If this was the last file handler referencing this FLB, "
"the FLB is removed from the global registry and the reference to its owner "
"module (acquired during registration) is released."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:421
msgid ""
"This function ensures the session is quiesced (no active FDs being created) "
"during the update. It is typically called from a subsystem's module exit "
"function."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:424
msgid ""
"0 on success. -EOPNOTSUPP if live update is disabled. -EBUSY if the live "
"update session is active and cannot be quiesced. -ENOENT if the FLB was not "
"found in the file handler's list."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:481
msgid "Retrieve the incoming FLB object."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:482
#: ../kernel/liveupdate/luo_flb.c:519
msgid "The FLB definition."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:484
#: ../kernel/liveupdate/luo_flb.c:521
msgid "``void **objp``"
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:483
#: ../kernel/liveupdate/luo_flb.c:520
msgid "Output parameter; will be populated with the live shared object."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:484
msgid ""
"Returns a pointer to its shared live object for the incoming (post-reboot) "
"path."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:487
msgid ""
"If this is the first time the object is requested in the new kernel, this "
"function will trigger the FLB's .retrieve() callback to reconstruct the "
"object from its preserved state. Subsequent calls will return the same "
"cached object."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:493
msgid ""
"0 on success, or a negative errno on failure. -ENODATA means no incoming FLB "
"data, -ENOENT means specific flb not found in the incoming data, and -"
"EOPNOTSUPP when live update is disabled or not configured."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:518
msgid "Retrieve the outgoing FLB object."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:521
msgid ""
"Returns a pointer to its shared live object for the outgoing (pre-reboot) "
"path."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:524
msgid ""
"This function assumes the object has already been created by the FLB's ."
"preserve() callback, which is triggered when the first dependent file is "
"preserved."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:622
msgid "Serializes all active FLB objects for KHO."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:623
msgid ""
"This function is called from the reboot path. It iterates through all "
"registered File-Lifecycle-Bound (FLB) objects. For each FLB that has been "
"preserved (i.e., its reference count is greater than zero), it writes its "
"metadata into the memory region designated for Kexec Handover."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:628
msgid ""
"The serialized data includes the FLB's compatibility string, its opaque data "
"handle, and the final reference count. This allows the new kernel to find "
"the appropriate handler and reconstruct the FLB's state."
msgstr ""

#: ../../../core-api/liveupdate:59: ../kernel/liveupdate/luo_flb.c:633
msgid "Called from liveupdate_reboot() just before kho_finalize()."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:79
msgid "Header struct for managing LUO sessions."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:81
msgid "The number of sessions currently tracked in the **list**."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:81
#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:143
msgid "``list``"
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:82
msgid "The head of the linked list of `struct luo_session` instances."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:82
msgid "``rwsem``"
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:83
msgid ""
"A read-write semaphore providing synchronized access to the session list and "
"other fields in this structure."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:84
msgid "``header_ser``"
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:85
msgid "The header data of serialization array."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:85
msgid "``ser``"
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:86
msgid "The serialized session data (an array of `struct luo_session_ser`)."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:87
msgid "``active``"
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:88
msgid ""
"Set to true when first initialized. If previous kernel did not send session "
"data, active stays false for incoming."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:100
msgid "Global container for managing LUO sessions."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:101
msgid "``incoming``"
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:102
msgid "The sessions passed from the previous kernel."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:102
msgid "``outgoing``"
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:103
msgid "The sessions that are going to be passed to the next kernel."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:605
msgid "Ensure no active sessions exist and lock session lists."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:606
msgid ""
"Acquires exclusive write locks on both incoming and outgoing session lists. "
"It then validates no sessions exist in either list."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:609
msgid ""
"This mechanism is used during file handler un/registration to ensure that no "
"sessions are currently using the handler, and no new sessions can be created "
"while un/registration is in progress."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:613
msgid ""
"This prevents registering new handlers while sessions are active or while "
"deserialization is in progress."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:617
msgid ""
"true  - System is quiescent (0 sessions) and locked. false - Active sessions "
"exist. The locks are released internally."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:637
msgid "Unlock session lists and resume normal activity."
msgstr ""

#: ../../../core-api/liveupdate:62: ../kernel/liveupdate/luo_session.c:638
msgid ""
"Releases the exclusive locks acquired by a successful call to "
"luo_session_quiesce()."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:123
msgid "Represents a single preserved file instance."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:124
msgid "``fh``"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:125
msgid ""
"Pointer to the :c:type:`struct liveupdate_file_handler "
"<liveupdate_file_handler>` that manages this type of file."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:127
msgid ""
"Pointer to the kernel's :c:type:`struct file <file>` that is being "
"preserved. This is NULL in the new kernel until the file is successfully "
"retrieved."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:130
msgid ""
"The opaque u64 handle to the serialized state of the file. This handle is "
"passed back to the handler's .freeze(), .retrieve(), and .finish() "
"callbacks, allowing it to track and update its serialized state across "
"phases."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:134
msgid ""
"Pointer to the private data for the file used to hold runtime state that is "
"not preserved. Set by the handler's .preserve() callback, and must be freed "
"in the handler's .unpreserve() callback."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:138
msgid ""
"A flag indicating whether a user/kernel in the new kernel has successfully "
"called retrieve() on this file. This prevents multiple retrieval attempts."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:140
msgid "``mutex``"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:141
msgid ""
"A mutex that protects the fields of this specific instance (e.g., "
"**retrieved**, **file**), ensuring that operations like retrieving or "
"finishing a file are atomic."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:144
msgid ""
"The list_head linking this instance into its parent file_set's list of "
"preserved files."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:146
msgid "The user-provided unique token used to identify this file."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:146
msgid ""
"This structure is the core in-kernel representation of a single file being "
"managed through a live update. An instance is created by luo_preserve_file() "
"to link a 'struct file' to its corresponding handler, a user-provided token, "
"and the serialized state handle returned by the handler's .preserve() "
"operation."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:152
msgid ""
"These instances are tracked in a per-file_set list. The **serialized_data** "
"field, which holds a handle to the file's serialized state, may be updated "
"during the .freeze() callback before being serialized for the next kernel. "
"After reboot, these structures are recreated by luo_file_deserialize() and "
"are finally cleaned up by luo_file_finish()."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:216
msgid "Initiate the preservation of a file descriptor."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:222
#: ../kernel/liveupdate/luo_file.c:336 ../kernel/liveupdate/luo_file.c:438
#: ../kernel/liveupdate/luo_file.c:514 ../kernel/liveupdate/luo_file.c:540
#: ../kernel/liveupdate/luo_file.c:648 ../kernel/liveupdate/luo_file.c:717
msgid "``struct luo_file_set *file_set``"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:217
msgid "The file_set to which the preserved file will be added."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:219
#: ../kernel/liveupdate/luo_file.c:537
msgid "``u64 token``"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:218
msgid "A unique, user-provided identifier for the file."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:220
msgid "``int fd``"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:219
msgid "The file descriptor to be preserved."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:220
msgid ""
"This function orchestrates the first phase of preserving a file. Upon entry, "
"it takes a reference to the 'struct file' via fget(), effectively making LUO "
"a co-owner of the file. This reference is held until the file is either "
"unpreserved or successfully finished in the next kernel, preventing the file "
"from being prematurely destroyed."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:226
msgid ""
"This function orchestrates the first phase of preserving a file. It performs "
"the following steps:"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:229
msgid "Validates that the **token** is not already in use within the file_set."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:230
msgid ""
"Ensures the file_set's memory for files serialization is allocated "
"(allocates if needed)."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:232
msgid ""
"Iterates through registered handlers, calling can_preserve() to find one "
"compatible with the given **fd**."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:234
msgid ""
"Calls the handler's .preserve() operation, which saves the file's state and "
"returns an opaque private data handle."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:236
msgid "Adds the new instance to the file_set's internal list."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:238
msgid ""
"On success, LUO takes a reference to the 'struct file' and considers it "
"under its management until it is unpreserved or finished."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:241
msgid ""
"In case of any failure, all intermediate allocations (file reference, memory "
"for the 'luo_file' struct, etc.) are cleaned up before returning an error."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:245
msgid "Can be called from an ioctl handler during normal system operation."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:246
msgid ""
"0 on success. Returns a negative errno on failure: -EEXIST if the token is "
"already used. -EBADF if the file descriptor is invalid. -ENOSPC if the "
"file_set is full. -ENOENT if no compatible handler is found. -ENOMEM on "
"memory allocation failure. Other erros might be returned by .preserve()."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:330
msgid "Unpreserves all files from a file_set."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:331
msgid "The files to be cleaned up."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:332
msgid ""
"This function serves as the primary cleanup path for a file_set. It is "
"invoked when the userspace agent closes the file_set's file descriptor."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:335
msgid "For each file, it performs the following cleanup actions:"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:336
msgid ""
"Calls the handler's .unpreserve() callback to allow the handler to release "
"any resources it allocated."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:338
msgid "Removes the file from the file_set's internal tracking list."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:339
msgid ""
"Releases the reference to the 'struct file' that was taken by "
"luo_preserve_file() via fput(), returning ownership."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:341
msgid "Frees the memory associated with the internal 'struct luo_file'."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:343
msgid ""
"After all individual files are unpreserved, it frees the contiguous memory "
"block that was allocated to hold their serialization data."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:432
msgid "Freezes all preserved files and serializes their metadata."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:433
msgid "The file_set whose files are to be frozen."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:435
#: ../kernel/liveupdate/luo_file.c:511 ../kernel/liveupdate/luo_file.c:714
msgid "``struct luo_file_set_ser *file_set_ser``"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:434
msgid "Where to put the serialized file_set."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:435
msgid ""
"This function is called from the reboot() syscall path, just before the "
"kernel transitions to the new image via kexec. Its purpose is to perform the "
"final preparation and serialization of all preserved files in the file_set."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:439
msgid ""
"It iterates through each preserved file in FIFO order (the order of "
"preservation) and performs two main actions:"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:442
msgid ""
"Freezes the File: It calls the handler's .freeze() callback for each file. "
"This gives the handler a final opportunity to quiesce the device or prepare "
"its state for the upcoming reboot. The handler may update its private data "
"handle during this step."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:447
msgid ""
"Serializes Metadata: After a successful freeze, it copies the final file "
"metadatathe handler's compatible string, the user token, and the final "
"private data handleinto the pre-allocated contiguous memory buffer "
"(file_set->files) that will be handed over to the next kernel via KHO."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:452
msgid ""
"Error Handling (Rollback): This function is atomic. If any handler's ."
"freeze() operation fails, the entire live update is aborted. The "
"__luo_file_unfreeze() helper is immediately called to invoke the .unfreeze() "
"op on all files that were successfully frozen before the point of failure, "
"rolling them back to a running state. The function then returns an error, "
"causing the reboot() syscall to fail."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:461
msgid "Called only from the liveupdate_reboot() path."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:508
msgid "Unfreezes all files in a file_set and clear serialization"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:509
msgid "The file_set whose files are to be unfrozen."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:510
msgid "Serialized file_set."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:511
msgid ""
"This function rolls back the state of all files in a file_set after the "
"freeze phase has begun but must be aborted. It is the counterpart to "
"luo_file_freeze()."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:515
msgid ""
"It invokes the __luo_file_unfreeze() helper with a NULL argument, which "
"signals the helper to iterate through all files in the file_set and call "
"their respective .unfreeze() handler callbacks."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:520
msgid ""
"This is called when the live update is aborted during the reboot() syscall, "
"after luo_file_freeze() has been called."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:534
msgid "Restores a preserved file from a file_set by its token."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:535
msgid "The file_set from which to retrieve the file."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:536
msgid "The unique token identifying the file to be restored."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:538
msgid "``struct file **filep``"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:537
msgid ""
"Output parameter; on success, this is populated with a pointer to the newly "
"retrieved 'struct file'."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:539
msgid ""
"This function is the primary mechanism for recreating a file in the new "
"kernel after a live update. It searches the file_set's list of deserialized "
"files for an entry matching the provided **token**."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:543
msgid ""
"The operation is idempotent: if a file has already been successfully "
"retrieved, this function will simply return a pointer to the existing "
"'struct file' and report success without re-executing the retrieve "
"operation. This is handled by checking the 'retrieved' flag under a lock."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:548
msgid ""
"File retrieval can happen in any order; it is not bound by the order of "
"preservation."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:552
msgid "Can be called from an ioctl or other in-kernel code in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:554
msgid ""
"0 on success. Returns a negative errno on failure: -ENOENT if no file with "
"the matching token is found. Any error code returned by the handler's ."
"retrieve() op."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:642
msgid "Completes the lifecycle for all files in a file_set."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:643
msgid "The file_set to be finalized."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:644
msgid ""
"This function orchestrates the final teardown of a live update file_set in "
"the new kernel. It should be called after all necessary files have been "
"retrieved and the userspace agent is ready to release the preserved state."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:648
msgid ""
"The function iterates through all tracked files. For each file, it performs "
"the following sequence of cleanup actions:"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:651
msgid ""
"If file is not yet retrieved, retrieves it, and calls can_finish() on every "
"file in the file_set. If all can_finish return true, continue to finish."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:654
msgid ""
"Calls the handler's .finish() callback (via luo_file_finish_one) to allow "
"for final resource cleanup within the handler."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:656
msgid ""
"Releases LUO's ownership reference on the 'struct file' via fput(). This is "
"the counterpart to the get_file() call in luo_retrieve_file()."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:658
msgid "Removes the 'struct luo_file' from the file_set's internal list."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:659
msgid "Frees the memory for the 'struct luo_file' instance itself."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:661
msgid ""
"After successfully finishing all individual files, it frees the contiguous "
"memory block that was used to transfer the serialized metadata from the "
"previous kernel."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:665
msgid ""
"Error Handling (Atomic Failure): This operation is atomic. If any handler's ."
"can_finish() op fails, the entire function aborts immediately and returns an "
"error."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:670
msgid "Can be called from an ioctl handler in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:711
msgid "Reconstructs the list of preserved files in the new kernel."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:712
msgid "The incoming file_set to fill with deserialized data."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:713
msgid "Serialized KHO file_set data from the previous kernel."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:714
msgid ""
"This function is called during the early boot process of the new kernel. It "
"takes the raw, contiguous memory block of 'struct luo_file_ser' entries, "
"provided by the previous kernel, and transforms it back into a live, in-"
"memory linked list of 'struct luo_file' instances."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:719
msgid "For each serialized entry, it performs the following steps:"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:720
msgid "Reads the 'compatible' string."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:721
msgid ""
"Searches the global list of registered file handlers for one that matches "
"the compatible string."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:723
msgid "Allocates a new 'struct luo_file'."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:724
msgid ""
"Populates the new structure with the deserialized data (token, private data "
"handle) and links it to the found handler. The 'file' pointer is initialized "
"to NULL, as the file has not been retrieved yet."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:727
msgid "Adds the new 'struct luo_file' to the file_set's files_list."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:729
msgid ""
"This prepares the file_set for userspace, which can later call "
"luo_retrieve_file() to restore the actual file descriptors."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:733
msgid "Called from session deserialization."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:811
msgid "Register a file handler with LUO."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:812
msgid ""
"Pointer to a caller-allocated :c:type:`struct liveupdate_file_handler "
"<liveupdate_file_handler>`. The caller must initialize this structure, "
"including a unique 'compatible' string and a valid 'fh' callbacks. This "
"function adds the handler to the global list of supported file handlers."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:817
msgid ""
"Typically called during module initialization for file types that support "
"live update preservation."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:820
msgid "0 on success. Negative errno on failure."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:875
msgid "Unregister a liveupdate file handler"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:876
msgid "The file handler to unregister"
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:877
msgid ""
"Unregisters the file handler from the liveupdate core. This function "
"reverses the operations of liveupdate_register_file_handler()."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:880
msgid ""
"It ensures safe removal by checking that: No live update session is "
"currently in progress. No FLB registered with this file handler."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:884
msgid "If the unregistration fails, the internal test state is reverted."
msgstr ""

#: ../../../core-api/liveupdate:65: ../kernel/liveupdate/luo_file.c:887
msgid ""
"0 Success. -EOPNOTSUPP when live update is not enabled. -EBUSY A live update "
"is in progress, can't quiesce live update or FLB is registred with this file "
"handler."
msgstr ""

#: ../../../core-api/liveupdate.rst:69
msgid "See Also"
msgstr ""

#: ../../../core-api/liveupdate.rst:71
msgid ":doc:`Live Update uAPI </userspace-api/liveupdate>`"
msgstr ""

#: ../../../core-api/liveupdate.rst:72
msgid ":doc:`/core-api/kho/index`"
msgstr ""
