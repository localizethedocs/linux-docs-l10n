# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/idr.rst:5
msgid "ID Allocation"
msgstr ""

#: ../../../core-api/idr.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/idr.rst:7
msgid "Matthew Wilcox"
msgstr ""

#: ../../../core-api/idr.rst:10
msgid "Overview"
msgstr ""

#: ../../../core-api/idr.rst:12
msgid ""
"A common problem to solve is allocating identifiers (IDs); generally small "
"numbers which identify a thing.  Examples include file descriptors, process "
"IDs, packet identifiers in networking protocols, SCSI tags and device "
"instance numbers.  The IDR and the IDA provide a reasonable solution to the "
"problem to avoid everybody inventing their own.  The IDR provides the "
"ability to map an ID to a pointer, while the IDA provides only ID "
"allocation, and as a result is much more memory-efficient."
msgstr ""

#: ../../../core-api/idr.rst:20
msgid ""
"The IDR interface is deprecated; please use the :doc:`XArray <xarray>` "
"instead."
msgstr ""

#: ../../../core-api/idr.rst:24
msgid "IDR usage"
msgstr ""

#: ../../../core-api/idr.rst:26
msgid ""
"Start by initialising an IDR, either with DEFINE_IDR() for statically "
"allocated IDRs or idr_init() for dynamically allocated IDRs."
msgstr ""

#: ../../../core-api/idr.rst:30
msgid ""
"You can call idr_alloc() to allocate an unused ID.  Look up the pointer you "
"associated with the ID by calling idr_find() and free the ID by calling "
"idr_remove()."
msgstr ""

#: ../../../core-api/idr.rst:34
msgid ""
"If you need to change the pointer associated with an ID, you can call "
"idr_replace().  One common reason to do this is to reserve an ID by passing "
"a ``NULL`` pointer to the allocation function; initialise the object with "
"the reserved ID and finally insert the initialised object into the IDR."
msgstr ""

#: ../../../core-api/idr.rst:40
msgid ""
"Some users need to allocate IDs larger than ``INT_MAX``.  So far all of "
"these users have been content with a ``UINT_MAX`` limit, and they use "
"idr_alloc_u32().  If you need IDs that will not fit in a u32, we will work "
"with you to address your needs."
msgstr ""

#: ../../../core-api/idr.rst:45
msgid ""
"If you need to allocate IDs sequentially, you can use idr_alloc_cyclic().  "
"The IDR becomes less efficient when dealing with larger IDs, so using this "
"function comes at a slight cost."
msgstr ""

#: ../../../core-api/idr.rst:49
msgid ""
"To perform an action on all pointers used by the IDR, you can either use the "
"callback-based idr_for_each() or the iterator-style idr_for_each_entry().  "
"You may need to use idr_for_each_entry_continue() to continue an iteration.  "
"You can also use idr_get_next() if the iterator doesn't fit your needs."
msgstr ""

#: ../../../core-api/idr.rst:55
msgid ""
"When you have finished using an IDR, you can call idr_destroy() to release "
"the memory used by the IDR.  This will not free the objects pointed to from "
"the IDR; if you want to do that, use one of the iterators to do it."
msgstr ""

#: ../../../core-api/idr.rst:60
msgid ""
"You can use idr_is_empty() to find out whether there are any IDs currently "
"allocated."
msgstr ""

#: ../../../core-api/idr.rst:63
msgid ""
"If you need to take a lock while allocating a new ID from the IDR, you may "
"need to pass a restrictive set of GFP flags, which can lead to the IDR being "
"unable to allocate memory.  To work around this, you can call idr_preload() "
"before taking the lock, and then idr_preload_end() after the allocation."
msgstr ""

#: ../../../core-api/idr:69: include/linux/idr.h:86
msgid "idr synchronization (stolen from radix-tree.h)"
msgstr ""

#: ../../../core-api/idr:69: include/linux/idr.h:88
msgid ""
"idr_find() is able to be called locklessly, using RCU. The caller must "
"ensure calls to this function are made within rcu_read_lock() regions. Other "
"readers (lock-free or otherwise) and modifications may be running "
"concurrently."
msgstr ""

#: ../../../core-api/idr:69: include/linux/idr.h:93
msgid ""
"It is still required that the caller manage the synchronization and "
"lifetimes of the items. So if RCU lock-free lookups are used, typically this "
"would mean that the items have their own locks, or are amenable to lock-free "
"access; and that the items are freed by RCU (or only freed after having been "
"deleted from the idr tree *and* a synchronize_rcu() grace period)."
msgstr ""

#: ../../../core-api/idr.rst:73
msgid "IDA usage"
msgstr ""

#: ../../../core-api/idr:75: lib/idr.c:309
msgid ""
"The IDA is an ID allocator which does not provide the ability to associate "
"an ID with a pointer.  As such, it only needs to store one bit per ID, and "
"so is more space efficient than an IDR.  To use an IDA, define it using "
"DEFINE_IDA() (or embed a :c:type:`struct ida <ida>` in a data structure, "
"then initialise it using ida_init()).  To allocate a new ID, call "
"ida_alloc(), ida_alloc_min(), ida_alloc_max() or ida_alloc_range(). To free "
"an ID, call ida_free()."
msgstr ""

#: ../../../core-api/idr:75: lib/idr.c:317
msgid ""
"ida_destroy() can be used to dispose of an IDA without needing to free the "
"individual IDs in it.  You can use ida_is_empty() to find out whether the "
"IDA has any IDs currently allocated."
msgstr ""

#: ../../../core-api/idr:75: lib/idr.c:321
msgid ""
"The IDA handles its own locking.  It is safe to call any of the IDA "
"functions without synchronisation in your code."
msgstr ""

#: ../../../core-api/idr:75: lib/idr.c:324
msgid ""
"IDs are currently limited to the range [0-INT_MAX].  If this is an awkward "
"limitation, it should be quite straightforward to raise the maximum."
msgstr ""

#: ../../../core-api/idr.rst:79
msgid "Functions and structures"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:45
msgid "``IDR_INIT (name)``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:43 include/linux/idr.h:145
#: include/linux/idr.h:160
msgid "Initialise an IDR."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:47 include/linux/idr.h:55
#: include/linux/idr.h:64 include/linux/idr.h:77 include/linux/idr.h:149
#: include/linux/idr.h:164 include/linux/idr.h:176 include/linux/idr.h:188
#: include/linux/idr.h:199 include/linux/idr.h:212 include/linux/idr.h:228
#: include/linux/idr.h:241 include/linux/idr.h:284 include/linux/idr.h:301
#: include/linux/idr.h:319 ../../../core-api/idr:83: lib/idr.c:15 lib/idr.c:64
#: lib/idr.c:100 lib/idr.c:143 lib/idr.c:163 lib/idr.c:183 lib/idr.c:222
#: lib/idr.c:259 lib/idr.c:281 lib/idr.c:370 lib/idr.c:484 lib/idr.c:551
#: lib/idr.c:601
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:49 include/linux/idr.h:57
msgid "``name``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:44 include/linux/idr.h:52
msgid "Name of IDR."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:3 include/linux/idr.h:46
#: include/linux/idr.h:54 include/linux/idr.h:63 include/linux/idr.h:77
#: include/linux/idr.h:149 include/linux/idr.h:163 include/linux/idr.h:200
#: include/linux/idr.h:214 include/linux/idr.h:229 include/linux/idr.h:243
#: include/linux/idr.h:284 include/linux/idr.h:302 include/linux/idr.h:320
#: ../../../core-api/idr:83: lib/idr.c:18 lib/idr.c:67 lib/idr.c:103
#: lib/idr.c:143 lib/idr.c:163 lib/idr.c:184 lib/idr.c:222 lib/idr.c:259
#: lib/idr.c:282 lib/idr.c:372 lib/idr.c:485 lib/idr.c:600
msgid "**Description**"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:45
msgid "A freshly-initialised IDR contains no IDs."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:53
msgid "``DEFINE_IDR (name)``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:51
msgid "Define a statically-allocated IDR."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:53
msgid ""
"An IDR defined using this macro is ready for use with no additional "
"initialisation required.  It contains no IDs."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:60
msgid "Return the current position of the cyclic allocator"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:66 include/linux/idr.h:178
#: ../../../core-api/idr:83: lib/idr.c:165 lib/idr.c:185
msgid "``const struct idr *idr``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:61 include/linux/idr.h:74
msgid "idr handle"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:62
msgid ""
"The value returned is the value that will be next returned from "
"idr_alloc_cyclic() if it is free (otherwise the search will start from this "
"position)."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:73
msgid "Set the current position of the cyclic allocator"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:79 include/linux/idr.h:151
#: include/linux/idr.h:166 ../../../core-api/idr:83: lib/idr.c:17 lib/idr.c:66
#: lib/idr.c:102 lib/idr.c:145 lib/idr.c:224 lib/idr.c:261 lib/idr.c:283
msgid "``struct idr *idr``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:76
msgid "``unsigned int val``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:75
msgid "new position"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:76
msgid ""
"The next call to idr_alloc_cyclic() will return **val** if it is free "
"(otherwise the search will start from this position)."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:146 include/linux/idr.h:161
#: include/linux/idr.h:173 include/linux/idr.h:196 include/linux/idr.h:209
#: include/linux/idr.h:225 include/linux/idr.h:238 ../../../core-api/idr:83:
#: lib/idr.c:12 lib/idr.c:61 lib/idr.c:97 lib/idr.c:140 lib/idr.c:160
#: lib/idr.c:180 lib/idr.c:219 lib/idr.c:256 lib/idr.c:278
msgid "IDR handle."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:148
msgid "``int base``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:147
msgid "The base value for the IDR."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:148
msgid ""
"This variation of idr_init() creates an IDR which will allocate IDs starting "
"at ``base``."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:162
msgid ""
"Initialise a dynamically allocated IDR.  To initialise a statically "
"allocated IDR, use DEFINE_IDR()."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:172
msgid "Are there any IDs allocated?"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:175 include/linux/idr.h:289
#: include/linux/idr.h:307 include/linux/idr.h:325 ../../../core-api/idr:83:
#: lib/idr.c:28 lib/idr.c:75 lib/idr.c:113 lib/idr.c:149 lib/idr.c:169
#: lib/idr.c:286 lib/idr.c:378 lib/idr.c:490
msgid "**Return**"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:175
msgid "``true`` if any IDs have been allocated from this IDR."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:184
msgid "end preload section started with idr_preload()"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:190
msgid "``void``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:1
msgid "no arguments"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:185
msgid ""
"Each idr_preload() should be matched with an invocation of this function.  "
"See idr_preload() for details."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:197
msgid "``idr_for_each_entry (idr, entry, id)``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:195 include/linux/idr.h:208
msgid "Iterate over an IDR's elements of a given type."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:201 include/linux/idr.h:214
#: include/linux/idr.h:230 include/linux/idr.h:243
msgid "``idr``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:198 include/linux/idr.h:211
#: include/linux/idr.h:227 include/linux/idr.h:240
msgid "``entry``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:197
msgid "The type * to use as cursor"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:199 include/linux/idr.h:213
#: include/linux/idr.h:228 include/linux/idr.h:242
msgid "``id``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:198 include/linux/idr.h:212
#: include/linux/idr.h:227 include/linux/idr.h:241
msgid "Entry ID."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:199 include/linux/idr.h:213
msgid ""
"**entry** and **id** do not need to be initialized before the loop, and "
"after normal termination **entry** is left with the value NULL.  This is "
"convenient for a \"not found\" value."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:210
msgid "``idr_for_each_entry_ul (idr, entry, tmp, id)``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:210
msgid "The type * to use as cursor."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:212 include/linux/idr.h:241
msgid "``tmp``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:211 include/linux/idr.h:240
msgid "A temporary placeholder for ID."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:226
msgid "``idr_for_each_entry_continue (idr, entry, id)``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:224 include/linux/idr.h:237
msgid "Continue iteration over an IDR's elements of a given type"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:226 include/linux/idr.h:239
msgid "The type * to use as a cursor."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:228
msgid ""
"Continue to iterate over entries, continuing after the current position."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:239
msgid "``idr_for_each_entry_continue_ul (idr, entry, tmp, id)``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:242
msgid ""
"Continue to iterate over entries, continuing after the current position. "
"After normal termination **entry** is left with the value NULL.  This is "
"convenient for a \"not found\" value."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:280 include/linux/idr.h:297
#: include/linux/idr.h:315 ../../../core-api/idr:83: lib/idr.c:366
msgid "Allocate an unused ID."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:286 include/linux/idr.h:303
#: include/linux/idr.h:321 ../../../core-api/idr:83: lib/idr.c:372
#: lib/idr.c:486 lib/idr.c:553 lib/idr.c:603
msgid "``struct ida *ida``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:281 include/linux/idr.h:298
#: include/linux/idr.h:316 ../../../core-api/idr:83: lib/idr.c:367
#: lib/idr.c:481 lib/idr.c:548 lib/idr.c:598
msgid "IDA handle."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:283 include/linux/idr.h:301
#: include/linux/idr.h:319 ../../../core-api/idr:83: lib/idr.c:17 lib/idr.c:66
#: lib/idr.c:102 lib/idr.c:371
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:282 include/linux/idr.h:300
#: include/linux/idr.h:318 ../../../core-api/idr:83: lib/idr.c:16 lib/idr.c:65
#: lib/idr.c:101 lib/idr.c:370
msgid "Memory allocation flags."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:283
msgid "Allocate an ID between 0 and ``INT_MAX``, inclusive."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:285 include/linux/idr.h:303
#: include/linux/idr.h:321 ../../../core-api/idr:83: lib/idr.c:374
#: lib/idr.c:487 lib/idr.c:551 lib/idr.c:604
msgid "**Context**"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:286 include/linux/idr.h:304
#: include/linux/idr.h:322 ../../../core-api/idr:83: lib/idr.c:375
#: lib/idr.c:551 lib/idr.c:605
msgid ""
"Any context. It is safe to call this function without locking in your code."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:288 include/linux/idr.h:306
#: include/linux/idr.h:324 ../../../core-api/idr:83: lib/idr.c:377
msgid ""
"The allocated ID, or ``-ENOMEM`` if memory could not be allocated, or ``-"
"ENOSPC`` if there are no free IDs."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:300 ../../../core-api/idr:83:
#: lib/idr.c:369 lib/idr.c:483
msgid "``unsigned int min``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:299 ../../../core-api/idr:83:
#: lib/idr.c:368
msgid "Lowest ID to allocate."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:301
msgid "Allocate an ID between **min** and ``INT_MAX``, inclusive."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:318 ../../../core-api/idr:83:
#: lib/idr.c:370 lib/idr.c:484
msgid "``unsigned int max``"
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:317 ../../../core-api/idr:83:
#: lib/idr.c:369
msgid "Highest ID to allocate."
msgstr ""

#: ../../../core-api/idr:81: include/linux/idr.h:319
msgid "Allocate an ID between 0 and **max**, inclusive."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:11 lib/idr.c:60
msgid "Allocate an ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:14 lib/idr.c:63 lib/idr.c:99
#: lib/idr.c:280
msgid "``void *ptr``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:13 lib/idr.c:62 lib/idr.c:98
msgid "Pointer to be associated with the new ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:15
msgid "``u32 *nextid``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:14 lib/idr.c:220 lib/idr.c:257
msgid "Pointer to an ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:16
msgid "``unsigned long max``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:15
msgid "The maximum ID to allocate (inclusive)."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:17
msgid ""
"Allocates an unused ID in the range specified by **nextid** and **max**. "
"Note that **max** is inclusive whereas the **end** parameter to idr_alloc() "
"is exclusive.  The new ID is assigned to **nextid** before the pointer is "
"inserted into the IDR, so if **nextid** points into the object pointed to by "
"**ptr**, a concurrent lookup will not find an uninitialised ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:23 lib/idr.c:70 lib/idr.c:108
msgid ""
"The caller should provide their own locking to ensure that two concurrent "
"modifications to the IDR are not possible.  Read-only accesses to the IDR "
"may be done under the RCU read lock or may exclude simultaneous writers."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:29
msgid ""
"0 if an ID was allocated, -ENOMEM if memory allocation failed, or -ENOSPC if "
"no free IDs could be found.  If an error occurred, **nextid** is unchanged."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:64 lib/idr.c:100
msgid "``int start``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:63 lib/idr.c:99
msgid "The minimum ID (inclusive)."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:65 lib/idr.c:101
msgid "``int end``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:64 lib/idr.c:100
msgid "The maximum ID (exclusive)."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:66
msgid ""
"Allocates an unused ID in the range specified by **start** and **end**.  If "
"**end** is <= 0, it is treated as one larger than ``INT_MAX``.  This allows "
"callers to use **start** + N as **end** as long as N is within integer range."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:76 lib/idr.c:114
msgid ""
"The newly allocated ID, -ENOMEM if memory allocation failed, or -ENOSPC if "
"no free IDs could be found."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:96
msgid "Allocate an ID cyclically."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:102
msgid ""
"Allocates an unused ID in the range specified by **start** and **end**.  If "
"**end** is <= 0, it is treated as one larger than ``INT_MAX``.  This allows "
"callers to use **start** + N as **end** as long as N is within integer "
"range. The search for an unused ID will start at the last ID allocated and "
"will wrap around to **start** if no free IDs are found before reaching "
"**end**."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:139
msgid "Remove an ID from the IDR."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:142 lib/idr.c:162 lib/idr.c:281
msgid "``unsigned long id``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:141 lib/idr.c:161
msgid "Pointer ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:142
msgid ""
"Removes this ID from the IDR.  If the ID was not previously in the IDR, this "
"function returns ``NULL``."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:145
msgid ""
"Since this function modifies the IDR, the caller should provide their own "
"locking to ensure that concurrent modification of the same IDR is not "
"possible."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:150
msgid "The pointer formerly associated with this ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:159
msgid "Return pointer for given ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:162
msgid ""
"Looks up the pointer associated with this ID.  A ``NULL`` pointer may "
"indicate that **id** is not allocated or that the ``NULL`` pointer was "
"associated with this ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:166
msgid ""
"This function can be called under rcu_read_lock(), given that the leaf "
"pointers lifetimes are correctly managed."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:170
msgid "The pointer associated with this ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:179
msgid "Iterate through all stored pointers."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:182
msgid "``int (*fn)(int id, void *p, void *data)``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:181
msgid "Function to be called for each pointer."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:183
msgid "``void *data``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:182
msgid "Data passed to callback function."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:183
msgid ""
"The callback function will be called for each entry in **idr**, passing the "
"ID, the entry and **data**."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:186
msgid ""
"If **fn** returns anything other than ``0``, the iteration stops and that "
"value is returned from this function."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:189
msgid ""
"idr_for_each() can be called concurrently with idr_alloc() and idr_remove() "
"if protected by RCU.  Newly added entries may not be seen and deleted "
"entries may be seen, but adding and removing entries will not cause other "
"entries to be skipped, nor spurious ones to be seen."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:218 lib/idr.c:255
msgid "Find next populated entry."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:221
msgid "``unsigned long *nextid``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:221 lib/idr.c:258
msgid ""
"Returns the next populated entry in the tree with an ID greater than or "
"equal to the value pointed to by **nextid**.  On exit, **nextid** is updated "
"to the ID of the found value.  To use in a loop, the value pointed to by "
"nextid must be incremented by the user."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:258
msgid "``int *nextid``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:277
msgid "replace pointer for given ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:279
msgid "New pointer to associate with the ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:280
msgid "ID to change."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:281
msgid ""
"Replace the pointer registered with an ID and return the old value. This "
"function can be called under the RCU read lock concurrently with idr_alloc() "
"and idr_remove() (as long as the ID being removed is not the one being "
"replaced!)."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:287
msgid ""
"the old value on success.  ``-ENOENT`` indicates that **id** was not found.  "
"``-EINVAL`` indicates that **ptr** was not valid."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:371
msgid ""
"Allocate an ID between **min** and **max**, inclusive.  The allocated ID "
"will not exceed ``INT_MAX``, even if **max** is larger."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:480
msgid "Get the lowest used ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:482
msgid "Lowest ID to get."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:483
msgid "Highest ID to get."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:484
msgid ""
"Get the lowest used ID between **min** and **max**, inclusive.  The returned "
"ID will not exceed ``INT_MAX``, even if **max** is larger."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:488
msgid "Any context. Takes and releases the xa_lock."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:489
msgid "The lowest used ID, or errno if no used ID is found."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:547
msgid "Release an allocated ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:550
msgid "``unsigned int id``"
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:549
msgid "Previously allocated ID."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:597
msgid "Free all IDs."
msgstr ""

#: ../../../core-api/idr:83: lib/idr.c:599
msgid ""
"Calling this function frees all IDs and releases all resources used by an "
"IDA.  When this call returns, the IDA is empty and can be reused or freed.  "
"If the IDA is already empty, there is no need to call this function."
msgstr ""
