# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../dev-tools/kmsan.rst:6
msgid "Kernel Memory Sanitizer (KMSAN)"
msgstr ""

#: ../../../dev-tools/kmsan.rst:8
msgid ""
"KMSAN is a dynamic error detector aimed at finding uses of uninitialized "
"values. It is based on compiler instrumentation, and is quite similar to the "
"userspace `MemorySanitizer tool`_."
msgstr ""

#: ../../../dev-tools/kmsan.rst:12
msgid ""
"An important note is that KMSAN is not intended for production use, because "
"it drastically increases kernel memory footprint and slows the whole system "
"down."
msgstr ""

#: ../../../dev-tools/kmsan.rst:16
msgid "Usage"
msgstr ""

#: ../../../dev-tools/kmsan.rst:19
msgid "Building the kernel"
msgstr ""

#: ../../../dev-tools/kmsan.rst:21
msgid ""
"In order to build a kernel with KMSAN you will need a fresh Clang (14.0.6+). "
"Please refer to `LLVM documentation`_ for the instructions on how to build "
"Clang."
msgstr ""

#: ../../../dev-tools/kmsan.rst:24
msgid "Now configure and build the kernel with CONFIG_KMSAN enabled."
msgstr ""

#: ../../../dev-tools/kmsan.rst:27
msgid "Example report"
msgstr ""

#: ../../../dev-tools/kmsan.rst:29
msgid "Here is an example of a KMSAN report::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:60
msgid ""
"The report says that the local variable ``uninit`` was created uninitialized "
"in ``do_uninit_local_array()``. The third stack trace corresponds to the "
"place where this variable was created."
msgstr ""

#: ../../../dev-tools/kmsan.rst:64
msgid ""
"The first stack trace shows where the uninit value was used (in "
"``test_uninit_kmsan_check_memory()``). The tool shows the bytes which were "
"left uninitialized in the local variable, as well as the stack where the "
"value was copied to another memory location before use."
msgstr ""

#: ../../../dev-tools/kmsan.rst:69
msgid ""
"A use of uninitialized value ``v`` is reported by KMSAN in the following "
"cases:"
msgstr ""

#: ../../../dev-tools/kmsan.rst:71
msgid "in a condition, e.g. ``if (v) { ... }``;"
msgstr ""

#: ../../../dev-tools/kmsan.rst:72
msgid "in an indexing or pointer dereferencing, e.g. ``array[v]`` or ``*v``;"
msgstr ""

#: ../../../dev-tools/kmsan.rst:73
msgid ""
"when it is copied to userspace or hardware, e.g. ``copy_to_user(..., "
"&v, ...)``;"
msgstr ""

#: ../../../dev-tools/kmsan.rst:74
msgid ""
"when it is passed as an argument to a function, and "
"``CONFIG_KMSAN_CHECK_PARAM_RETVAL`` is enabled (see below)."
msgstr ""

#: ../../../dev-tools/kmsan.rst:77
msgid ""
"The mentioned cases (apart from copying data to userspace or hardware, which "
"is a security issue) are considered undefined behavior from the C11 Standard "
"point of view."
msgstr ""

#: ../../../dev-tools/kmsan.rst:82
msgid "Disabling the instrumentation"
msgstr ""

#: ../../../dev-tools/kmsan.rst:84
msgid ""
"A function can be marked with ``__no_kmsan_checks``. Doing so makes KMSAN "
"ignore uninitialized values in that function and mark its output as "
"initialized. As a result, the user will not get KMSAN reports related to "
"that function."
msgstr ""

#: ../../../dev-tools/kmsan.rst:88
msgid ""
"Another function attribute supported by KMSAN is ``__no_sanitize_memory``. "
"Applying this attribute to a function will result in KMSAN not instrumenting "
"it, which can be helpful if we do not want the compiler to interfere with "
"some low-level code (e.g. that marked with ``noinstr`` which implicitly adds "
"``__no_sanitize_memory``)."
msgstr ""

#: ../../../dev-tools/kmsan.rst:94
msgid ""
"This however comes at a cost: stack allocations from such functions will "
"have incorrect shadow/origin values, likely leading to false positives. "
"Functions called from non-instrumented code may also receive incorrect "
"metadata for their parameters."
msgstr ""

#: ../../../dev-tools/kmsan.rst:99
msgid "As a rule of thumb, avoid using ``__no_sanitize_memory`` explicitly."
msgstr ""

#: ../../../dev-tools/kmsan.rst:101
msgid "It is also possible to disable KMSAN for a single file (e.g. main.o)::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:105
msgid "or for the whole directory::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:109
msgid ""
"in the Makefile. Think of this as applying ``__no_sanitize_memory`` to every "
"function in the file or directory. Most users won't need KMSAN_SANITIZE, "
"unless their code gets broken by KMSAN (e.g. runs at early boot time)."
msgstr ""

#: ../../../dev-tools/kmsan.rst:113
msgid ""
"KMSAN checks can also be temporarily disabled for the current task using "
"``kmsan_disable_current()`` and ``kmsan_enable_current()`` calls. Each "
"``kmsan_enable_current()`` call must be preceded by a "
"``kmsan_disable_current()`` call; these call pairs may be nested. One needs "
"to be careful with these calls, keeping the regions short and preferring "
"other ways to disable instrumentation, where possible."
msgstr ""

#: ../../../dev-tools/kmsan.rst:121
msgid "Support"
msgstr ""

#: ../../../dev-tools/kmsan.rst:123
msgid ""
"In order for KMSAN to work the kernel must be built with Clang, which so far "
"is the only compiler that has KMSAN support. The kernel instrumentation pass "
"is based on the userspace `MemorySanitizer tool`_."
msgstr ""

#: ../../../dev-tools/kmsan.rst:127
msgid "The runtime library only supports x86_64 at the moment."
msgstr ""

#: ../../../dev-tools/kmsan.rst:130
msgid "How KMSAN works"
msgstr ""

#: ../../../dev-tools/kmsan.rst:133
msgid "KMSAN shadow memory"
msgstr ""

#: ../../../dev-tools/kmsan.rst:135
msgid ""
"KMSAN associates a metadata byte (also called shadow byte) with every byte "
"of kernel memory. A bit in the shadow byte is set if the corresponding bit "
"of the kernel memory byte is uninitialized. Marking the memory uninitialized "
"(i.e. setting its shadow bytes to ``0xff``) is called poisoning, marking it "
"initialized (setting the shadow bytes to ``0x00``) is called unpoisoning."
msgstr ""

#: ../../../dev-tools/kmsan.rst:141
msgid ""
"When a new variable is allocated on the stack, it is poisoned by default by "
"instrumentation code inserted by the compiler (unless it is a stack variable "
"that is immediately initialized). Any new heap allocation done without "
"``__GFP_ZERO`` is also poisoned."
msgstr ""

#: ../../../dev-tools/kmsan.rst:146
msgid ""
"Compiler instrumentation also tracks the shadow values as they are used "
"along the code. When needed, instrumentation code invokes the runtime "
"library in ``mm/kmsan/`` to persist shadow values."
msgstr ""

#: ../../../dev-tools/kmsan.rst:150
msgid ""
"The shadow value of a basic or compound type is an array of bytes of the "
"same length. When a constant value is written into memory, that memory is "
"unpoisoned. When a value is read from memory, its shadow memory is also "
"obtained and propagated into all the operations which use that value. For "
"every instruction that takes one or more values the compiler generates code "
"that calculates the shadow of the result depending on those values and their "
"shadows."
msgstr ""

#: ../../../dev-tools/kmsan.rst:157
msgid "Example::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:163
msgid ""
"In this case the shadow of ``a`` is ``0``, shadow of ``b`` is "
"``0xffffffff``, shadow of ``c`` is ``0xffffff00``. This means that the upper "
"three bytes of ``c`` are uninitialized, while the lower byte is initialized."
msgstr ""

#: ../../../dev-tools/kmsan.rst:168
msgid "Origin tracking"
msgstr ""

#: ../../../dev-tools/kmsan.rst:170
msgid ""
"Every four bytes of kernel memory also have a so-called origin mapped to "
"them. This origin describes the point in program execution at which the "
"uninitialized value was created. Every origin is associated with either the "
"full allocation stack (for heap-allocated memory), or the function "
"containing the uninitialized variable (for locals)."
msgstr ""

#: ../../../dev-tools/kmsan.rst:176
msgid ""
"When an uninitialized variable is allocated on stack or heap, a new origin "
"value is created, and that variable's origin is filled with that value. When "
"a value is read from memory, its origin is also read and kept together with "
"the shadow. For every instruction that takes one or more values, the origin "
"of the result is one of the origins corresponding to any of the "
"uninitialized inputs. If a poisoned value is written into memory, its origin "
"is written to the corresponding storage as well."
msgstr ""

#: ../../../dev-tools/kmsan.rst:184
msgid "Example 1::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:190
msgid ""
"In this case the origin of ``b`` is generated upon function entry, and is "
"stored to the origin of ``c`` right before the addition result is written "
"into memory."
msgstr ""

#: ../../../dev-tools/kmsan.rst:194
msgid ""
"Several variables may share the same origin address, if they are stored in "
"the same four-byte chunk. In this case every write to either variable "
"updates the origin for all of them. We have to sacrifice precision in this "
"case, because storing origins for individual bits (and even bytes) would be "
"too costly."
msgstr ""

#: ../../../dev-tools/kmsan.rst:199
msgid "Example 2::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:211
msgid ""
"If ``a`` is initialized and ``b`` is not, the shadow of the result would be "
"0xffff0000, and the origin of the result would be the origin of ``b``. ``ret."
"s[0]`` would have the same origin, but it will never be used, because that "
"variable is initialized."
msgstr ""

#: ../../../dev-tools/kmsan.rst:216
msgid ""
"If both function arguments are uninitialized, only the origin of the second "
"argument is preserved."
msgstr ""

#: ../../../dev-tools/kmsan.rst:220
msgid "Origin chaining"
msgstr ""

#: ../../../dev-tools/kmsan.rst:222
msgid ""
"To ease debugging, KMSAN creates a new origin for every store of an "
"uninitialized value to memory. The new origin references both its creation "
"stack and the previous origin the value had. This may cause increased memory "
"consumption, so we limit the length of origin chains in the runtime."
msgstr ""

#: ../../../dev-tools/kmsan.rst:228
msgid "Clang instrumentation API"
msgstr ""

#: ../../../dev-tools/kmsan.rst:230
msgid ""
"Clang instrumentation pass inserts calls to functions defined in ``mm/kmsan/"
"nstrumentation.c`` into the kernel code."
msgstr ""

#: ../../../dev-tools/kmsan.rst:234
msgid "Shadow manipulation"
msgstr ""

#: ../../../dev-tools/kmsan.rst:236
msgid ""
"For every memory access the compiler emits a call to a function that returns "
"a pair of pointers to the shadow and origin addresses of the given memory::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:248
msgid "The function name depends on the memory access size."
msgstr ""

#: ../../../dev-tools/kmsan.rst:250
msgid ""
"The compiler makes sure that for every loaded value its shadow and origin "
"values are read from memory. When a value is stored to memory, its shadow "
"and origin are also stored using the metadata pointers."
msgstr ""

#: ../../../dev-tools/kmsan.rst:255
msgid "Handling locals"
msgstr ""

#: ../../../dev-tools/kmsan.rst:257
msgid ""
"A special function is used to create a new origin value for a local variable "
"and set the origin of that variable to that value::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:263
msgid "Access to per-task data"
msgstr ""

#: ../../../dev-tools/kmsan.rst:265
msgid ""
"At the beginning of every instrumented function KMSAN inserts a call to "
"``__msan_get_context_state()``::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:270
msgid "``kmsan_context_state`` is declared in ``include/linux/kmsan.h``::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:282
msgid ""
"This structure is used by KMSAN to pass parameter shadows and origins "
"between instrumented functions (unless the parameters are checked "
"immediately by ``CONFIG_KMSAN_CHECK_PARAM_RETVAL``)."
msgstr ""

#: ../../../dev-tools/kmsan.rst:287
msgid "Passing uninitialized values to functions"
msgstr ""

#: ../../../dev-tools/kmsan.rst:289
msgid ""
"Clang's MemorySanitizer instrumentation has an option, ``-fsanitize-memory-"
"param-retval``, which makes the compiler check function parameters passed by "
"value, as well as function return values."
msgstr ""

#: ../../../dev-tools/kmsan.rst:293
msgid ""
"The option is controlled by ``CONFIG_KMSAN_CHECK_PARAM_RETVAL``, which is "
"enabled by default to let KMSAN report uninitialized values earlier. Please "
"refer to the `LKML discussion`_ for more details."
msgstr ""

#: ../../../dev-tools/kmsan.rst:297
msgid ""
"Because of the way the checks are implemented in LLVM (they are only applied "
"to parameters marked as ``noundef``), not all parameters are guaranteed to "
"be checked, so we cannot give up the metadata storage in "
"``kmsan_context_state``."
msgstr ""

#: ../../../dev-tools/kmsan.rst:302
msgid "String functions"
msgstr ""

#: ../../../dev-tools/kmsan.rst:304
msgid ""
"The compiler replaces calls to ``memcpy()``/``memmove()``/``memset()`` with "
"the following functions. These functions are also called when data "
"structures are initialized or copied, making sure shadow and origin values "
"are copied alongside with the data::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:314
msgid "Error reporting"
msgstr ""

#: ../../../dev-tools/kmsan.rst:316
msgid ""
"For each use of a value the compiler emits a shadow check that calls "
"``__msan_warning()`` in the case that value is poisoned::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:321
msgid "``__msan_warning()`` causes KMSAN runtime to print an error report."
msgstr ""

#: ../../../dev-tools/kmsan.rst:324
msgid "Inline assembly instrumentation"
msgstr ""

#: ../../../dev-tools/kmsan.rst:326
msgid "KMSAN instruments every inline assembly output with a call to::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:330
msgid ", which unpoisons the memory region."
msgstr ""

#: ../../../dev-tools/kmsan.rst:332
msgid ""
"This approach may mask certain errors, but it also helps to avoid a lot of "
"false positives in bitwise operations, atomics etc."
msgstr ""

#: ../../../dev-tools/kmsan.rst:335
msgid ""
"Sometimes the pointers passed into inline assembly do not point to valid "
"memory. In such cases they are ignored at runtime."
msgstr ""

#: ../../../dev-tools/kmsan.rst:340
msgid "Runtime library"
msgstr ""

#: ../../../dev-tools/kmsan.rst:342
msgid "The code is located in ``mm/kmsan/``."
msgstr ""

#: ../../../dev-tools/kmsan.rst:345
msgid "Per-task KMSAN state"
msgstr ""

#: ../../../dev-tools/kmsan.rst:347
msgid ""
"Every task_struct has an associated KMSAN task state that holds the KMSAN "
"context (see above) and a per-task counter disallowing KMSAN reports::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:364
msgid "KMSAN contexts"
msgstr ""

#: ../../../dev-tools/kmsan.rst:366
msgid ""
"When running in a kernel task context, KMSAN uses ``current->kmsan.cstate`` "
"to hold the metadata for function parameters and return values."
msgstr ""

#: ../../../dev-tools/kmsan.rst:369
msgid ""
"But in the case the kernel is running in the interrupt, softirq or NMI "
"context, where ``current`` is unavailable, KMSAN switches to per-cpu "
"interrupt state::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:375
msgid "Metadata allocation"
msgstr ""

#: ../../../dev-tools/kmsan.rst:377
msgid ""
"There are several places in the kernel for which the metadata is stored."
msgstr ""

#: ../../../dev-tools/kmsan.rst:379
msgid ""
"1. Each ``struct page`` instance contains two pointers to its shadow and "
"origin pages::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:388
msgid ""
"At boot-time, the kernel allocates shadow and origin pages for every "
"available kernel page. This is done quite late, when the kernel address "
"space is already fragmented, so normal data pages may arbitrarily interleave "
"with the metadata pages."
msgstr ""

#: ../../../dev-tools/kmsan.rst:393
msgid ""
"This means that in general for two contiguous memory pages their shadow/"
"origin pages may not be contiguous. Consequently, if a memory access crosses "
"the boundary of a memory block, accesses to shadow/origin memory may "
"potentially corrupt other pages or read incorrect values from them."
msgstr ""

#: ../../../dev-tools/kmsan.rst:398
msgid ""
"In practice, contiguous memory pages returned by the same ``alloc_pages()`` "
"call will have contiguous metadata, whereas if these pages belong to two "
"different allocations their metadata pages can be fragmented."
msgstr ""

#: ../../../dev-tools/kmsan.rst:402
msgid ""
"For the kernel data (``.data``, ``.bss`` etc.) and percpu memory regions "
"there also are no guarantees on metadata contiguity."
msgstr ""

#: ../../../dev-tools/kmsan.rst:405
msgid ""
"In the case ``__msan_metadata_ptr_for_XXX_YYY()`` hits the border between "
"two pages with non-contiguous metadata, it returns pointers to fake shadow/"
"origin regions::"
msgstr ""

#: ../../../dev-tools/kmsan.rst:411
msgid ""
"``dummy_load_page`` is zero-initialized, so reads from it always yield "
"zeroes. All stores to ``dummy_store_page`` are ignored."
msgstr ""

#: ../../../dev-tools/kmsan.rst:414
msgid ""
"2. For vmalloc memory and modules, there is a direct mapping between the "
"memory range, its shadow and origin. KMSAN reduces the vmalloc area by 3/4, "
"making only the first quarter available to ``vmalloc()``. The second quarter "
"of the vmalloc area contains shadow memory for the first quarter, the third "
"one holds the origins. A small part of the fourth quarter contains shadow "
"and origins for the kernel modules. Please refer to ``arch/x86/include/asm/"
"pgtable_64_types.h`` for more details."
msgstr ""

#: ../../../dev-tools/kmsan.rst:422
msgid ""
"When an array of pages is mapped into a contiguous virtual memory space, "
"their shadow and origin pages are similarly mapped into contiguous regions."
msgstr ""

#: ../../../dev-tools/kmsan.rst:426
msgid "References"
msgstr ""

#: ../../../dev-tools/kmsan.rst:428
msgid ""
"E. Stepanov, K. Serebryany. `MemorySanitizer: fast detector of uninitialized "
"memory use in C++ <https://static.googleusercontent.com/media/research."
"google.com/en//pubs/archive/43308.pdf>`_. In Proceedings of CGO 2015."
msgstr ""
