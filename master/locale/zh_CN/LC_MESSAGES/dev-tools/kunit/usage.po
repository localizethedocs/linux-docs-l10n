# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../dev-tools/kunit/usage.rst:4
msgid "Writing Tests"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:7
msgid "Test Cases"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:9
msgid ""
"The fundamental unit in KUnit is the test case. A test case is a function "
"with the signature ``void (*)(struct kunit *test)``. It calls the function "
"under test and then sets *expectations* for what should happen. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:24
msgid ""
"In the above example, ``example_test_success`` always passes because it does "
"nothing; no expectations are set, and therefore all expectations pass. On "
"the other hand ``example_test_failure`` always fails because it calls "
"``KUNIT_FAIL``, which is a special expectation that logs a message and "
"causes the test case to fail."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:31
msgid "Expectations"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:32
msgid ""
"An *expectation* specifies that we expect a piece of code to do something in "
"a test. An expectation is called like a function. A test is made by setting "
"expectations about the behavior of a piece of code under test. When one or "
"more expectations fail, the test case fails and information about the "
"failure is logged. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:46
msgid ""
"In the above example, ``add_test_basic`` makes a number of assertions about "
"the behavior of a function called ``add``. The first parameter is always of "
"type ``struct kunit *``, which contains information about the current test "
"context. The second parameter, in this case, is what the value is expected "
"to be. The last value is what the value actually is. If ``add`` passes all "
"of these expectations, the test case, ``add_test_basic`` will pass; if any "
"one of these expectations fails, the test case will fail."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:54
msgid ""
"A test case *fails* when any expectation is violated; however, the test will "
"continue to run, and try other expectations until the test case ends or is "
"otherwise terminated. This is as opposed to *assertions* which are discussed "
"later."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:59
msgid ""
"To learn about more KUnit expectations, see Documentation/dev-tools/kunit/"
"api/test.rst."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:62
msgid ""
"A single test case should be short, easy to understand, and focused on a "
"single behavior."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:65
msgid ""
"For example, if we want to rigorously test the ``add`` function above, "
"create additional tests cases which would test each property that an ``add`` "
"function should have as shown below:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:94
msgid "Assertions"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:96
msgid ""
"An assertion is like an expectation, except that the assertion immediately "
"terminates the test case if the condition is not satisfied. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:115
msgid ""
"In this example, we need to be able to allocate an array to test the "
"``sort()`` function. So we use ``KUNIT_ASSERT_NOT_ERR_OR_NULL()`` to abort "
"the test if there's an allocation error."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:120
msgid ""
"In other test frameworks, ``ASSERT`` macros are often implemented by calling "
"``return`` so they only work from the test function. In KUnit, we stop the "
"current kthread on failure, so you can call them from anywhere."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:125
msgid ""
"Warning: There is an exception to the above rule. You shouldn't use "
"assertions in the suite's exit() function, or in the free function for a "
"resource. These run when a test is shutting down, and an assertion here "
"prevents further cleanup code from running, potentially leading to a memory "
"leak."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:131
msgid "Customizing error messages"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:133
msgid ""
"Each of the ``KUNIT_EXPECT`` and ``KUNIT_ASSERT`` macros have a ``_MSG`` "
"variant.  These take a format string and arguments to provide additional "
"context to the automatically generated error messages."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:148
msgid ""
"Alternatively, one can take full control over the error message by using "
"``KUNIT_FAIL()``, e.g."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:162
msgid "Test Suites"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:164
msgid ""
"We need many test cases covering all the unit's behaviors. It is common to "
"have many similar tests. In order to reduce duplication in these closely "
"related tests, most unit testing frameworks (including KUnit) provide the "
"concept of a *test suite*. A test suite is a collection of test cases for a "
"unit of code with optional setup and teardown functions that run before/"
"after the whole suite and/or every test case."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:172
msgid "A test case will only run if it is associated with a test suite."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:174
#: ../../../dev-tools/kunit/usage.rst:629
#: ../../../dev-tools/kunit/usage.rst:863
msgid "For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:195
msgid ""
"In the above example, the test suite ``example_test_suite`` would first run "
"``example_suite_init``, then run the test cases ``example_test_foo``, "
"``example_test_bar``, and ``example_test_baz``. Each would have "
"``example_test_init`` called immediately before it and ``example_test_exit`` "
"called immediately after it. Finally, ``example_suite_exit`` would be called "
"after everything else. ``kunit_test_suite(example_test_suite)`` registers "
"the test suite with the KUnit test framework."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:204
msgid ""
"The ``exit`` and ``suite_exit`` functions will run even if ``init`` or "
"``suite_init`` fail. Make sure that they can handle any inconsistent state "
"which may result from ``init`` or ``suite_init`` encountering errors or "
"exiting early."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:209
msgid ""
"``kunit_test_suite(...)`` is a macro which tells the linker to put the "
"specified test suite in a special linker section so that it can be run by "
"KUnit either after ``late_init``, or when the test module is loaded (if the "
"test was built as a module)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:214
msgid "For more information, see Documentation/dev-tools/kunit/api/test.rst."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:219
msgid "Writing Tests For Other Architectures"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:221
msgid ""
"It is better to write tests that run on UML to tests that only run under a "
"particular architecture. It is better to write tests that run under QEMU or "
"another easy to obtain (and monetarily free) software environment to a "
"specific piece of hardware."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:226
msgid ""
"Nevertheless, there are still valid reasons to write a test that is "
"architecture or hardware specific. For example, we might want to test code "
"that really belongs in ``arch/some-arch/*``. Even so, try to write the test "
"so that it does not depend on physical hardware. Some of our test cases may "
"not need hardware, only few tests actually require the hardware to test it. "
"When hardware is not available, instead of disabling tests, we can skip them."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:233
msgid ""
"Now that we have narrowed down exactly what bits are hardware specific, the "
"actual procedure for writing and running the tests is same as writing normal "
"KUnit tests."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:238
msgid ""
"We may have to reset hardware state. If this is not possible, we may only be "
"able to run one test case per invocation."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:245
msgid "Common Patterns"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:248
msgid "Isolating Behavior"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:250
msgid ""
"Unit testing limits the amount of code under test to a single unit. It "
"controls what code gets run when the unit under test calls a function. Where "
"a function is exposed as part of an API such that the definition of that "
"function can be changed without affecting the rest of the code base. In the "
"kernel, this comes from two constructs: classes, which are structs that "
"contain function pointers provided by the implementer, and architecture-"
"specific functions, which have definitions selected at compile time."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:259
msgid "Classes"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:261
msgid ""
"Classes are not a construct that is built into the C programming language; "
"however, it is an easily derived concept. Accordingly, in most cases, every "
"project that does not use a standardized object oriented library (like "
"GNOME's GObject) has their own slightly different way of doing object "
"oriented programming; the Linux kernel is no exception."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:267
msgid ""
"The central concept in kernel object oriented programming is the class. In "
"the kernel, a *class* is a struct that contains function pointers. This "
"creates a contract between *implementers* and *users* since it forces them "
"to use the same function signature without having to call the function "
"directly. To be a class, the function pointers must specify that a pointer "
"to the class, known as a *class handle*, be one of the parameters. Thus the "
"member functions (also known as *methods*) have access to member variables "
"(also known as *fields*) allowing the same implementation to have multiple "
"*instances*."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:276
msgid ""
"A class can be *overridden* by *child classes* by embedding the *parent "
"class* in the child class. Then when the child class *method* is called, the "
"child implementation knows that the pointer passed to it is of a parent "
"contained within the child. Thus, the child can compute the pointer to "
"itself because the pointer to the parent is always a fixed offset from the "
"pointer to the child. This offset is the offset of the parent contained in "
"the child struct. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:310
msgid ""
"In this example, computing the pointer to the child from the pointer to the "
"parent is done by ``container_of``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:314
msgid "Faking Classes"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:316
msgid ""
"In order to unit test a piece of code that calls a method in a class, the "
"behavior of the method must be controllable, otherwise the test ceases to be "
"a unit test and becomes an integration test."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:320
msgid ""
"A fake class implements a piece of code that is different than what runs in "
"a production instance, but behaves identical from the standpoint of the "
"callers. This is done to replace a dependency that is hard to deal with, or "
"is slow. For example, implementing a fake EEPROM that stores the "
"\"contents\" in an internal buffer. Assume we have a class that represents "
"an EEPROM:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:333
msgid "And we want to test code that buffers writes to the EEPROM:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:346
msgid "We can test this code by *faking out* the underlying EEPROM:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:382
msgid "We can now use it to test ``struct eeprom_buffer``:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:474
msgid "Testing Against Multiple Inputs"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:476
msgid ""
"Testing just a few inputs is not enough to ensure that the code works "
"correctly, for example: testing a hash function."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:479
msgid ""
"We can write a helper macro or function. The function is called for each "
"input. For example, to test ``sha1sum(1)``, we can write:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:492
msgid ""
"Note the use of the ``_MSG`` version of ``KUNIT_EXPECT_STREQ`` to print a "
"more detailed error and make the assertions clearer within the helper macros."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:495
msgid ""
"The ``_MSG`` variants are useful when the same expectation is called "
"multiple times (in a loop or helper function) and thus the line number is "
"not enough to identify what failed, as shown below."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:499
msgid ""
"In complicated cases, we recommend using a *table-driven test* compared to "
"the helper macro variation, for example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:529
msgid "There is more boilerplate code involved, but it can:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:531
msgid ""
"be more readable when there are multiple inputs/outputs (due to field names)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:533
msgid "For example, see ``fs/ext4/inode-test.c``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:535
msgid "reduce duplication if test cases are shared across multiple tests."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:537
msgid ""
"For example: if we want to test ``sha256sum``, we could add a ``sha256`` "
"field and reuse ``cases``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:540
msgid "be converted to a \"parameterized test\"."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:543
msgid "Parameterized Testing"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:545
msgid ""
"The table-driven testing pattern is common enough that KUnit has special "
"support for it."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:548
msgid ""
"By reusing the same ``cases`` array from above, we can write the test as a "
"\"parameterized test\" with the following."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:594
msgid "Allocating Memory"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:596
msgid ""
"Where you might use ``kzalloc``, you can instead use ``kunit_kzalloc`` as "
"KUnit will then ensure that the memory is freed once the test completes."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:599
msgid ""
"This is useful because it lets us use the ``KUNIT_ASSERT_EQ`` macros to exit "
"early from a test without having to worry about remembering to call "
"``kfree``. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:615
msgid "Registering Cleanup Actions"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:617
msgid ""
"If you need to perform some cleanup beyond simple use of ``kunit_kzalloc``, "
"you can register a custom \"deferred action\", which is a cleanup function "
"run when the test exits (whether cleanly, or via a failed assertion)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:621
msgid ""
"Actions are simple functions with no return value, and a single ``void*`` "
"context argument, and fulfill the same role as \"cleanup\" functions in "
"Python and Go tests, \"defer\" statements in languages which support them, "
"and (in some cases) destructors in RAII languages."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:626
msgid ""
"These are very useful for unregistering things from global lists, closing "
"files or other resources, or freeing resources."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:649
msgid ""
"Note that, for functions like device_unregister which only accept a single "
"pointer-sized argument, it's possible to automatically generate a wrapper "
"with the ``KUNIT_DEFINE_ACTION_WRAPPER()`` macro, for example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:658
msgid ""
"You should do this in preference to manually casting to the "
"``kunit_action_t`` type, as casting function pointers will break Control "
"Flow Integrity (CFI)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:661
msgid ""
"``kunit_add_action`` can fail if, for example, the system is out of memory. "
"You can use ``kunit_add_action_or_reset`` instead which runs the action "
"immediately if it cannot be deferred."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:665
msgid ""
"If you need more control over when the cleanup function is called, you can "
"trigger it early using ``kunit_release_action``, or cancel it entirely with "
"``kunit_remove_action``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:671
msgid "Testing Static Functions"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:673
msgid ""
"If you want to test static functions without exposing those functions "
"outside of testing, one option is conditionally export the symbol. When "
"KUnit is enabled, the symbol is exposed but remains static otherwise. To use "
"this method, follow the template below."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:706
msgid ""
"For a full example, see this `patch <https://lore.kernel.org/"
"all/20221207014024.340230-3-rmoar@google.com/>`_ where a test is modified to "
"conditionally expose static functions for testing using the macros above."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:710
msgid ""
"As an **alternative** to the method above, you could conditionally "
"``#include`` the test file at the end of your .c file. This is not "
"recommended but works if needed. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:725
msgid "Injecting Test-Only Code"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:727
msgid "Similar to as shown above, we can add test-specific logic. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:740
msgid ""
"This test-only code can be made more useful by accessing the current "
"``kunit_test`` as shown in next section: *Accessing The Current Test*."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:744
msgid "Accessing The Current Test"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:746
msgid ""
"In some cases, we need to call test-only code from outside the test file.  "
"This is helpful, for example, when providing a fake implementation of a "
"function, or to fail any current test from within an error handler. We can "
"do this via the ``kunit_test`` field in ``task_struct``, which we can access "
"using the ``kunit_get_current_test()`` function in ``kunit/test-bug.h``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:752
msgid ""
"``kunit_get_current_test()`` is safe to call even if KUnit is not enabled. "
"If KUnit is not enabled, or if no test is running in the current task, it "
"will return ``NULL``. This compiles down to either a no-op or a static key "
"check, so will have a negligible performance impact when no test is running."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:757
msgid ""
"The example below uses this to implement a \"mock\" implementation of a "
"function, ``foo``:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:791
msgid ""
"In this example, we are using the ``priv`` member of ``struct kunit`` as a "
"way of passing data to the test from the init function. In general ``priv`` "
"is pointer that can be used for any user data. This is preferred over static "
"variables, as it avoids concurrency issues."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:796
msgid ""
"Had we wanted something more flexible, we could have used a named "
"``kunit_resource``. Each test can have multiple resources which have string "
"names providing the same flexibility as a ``priv`` member, but also, for "
"example, allowing helper functions to create resources without conflicting "
"with each other. It is also possible to define a clean up function for each "
"resource, making it easy to avoid resource leaks. For more information, see "
"Documentation/dev-tools/kunit/api/resource.rst."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:804
msgid "Failing The Current Test"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:806
msgid ""
"If we want to fail the current test, we can use "
"``kunit_fail_current_test(fmt, args...)`` which is defined in ``<kunit/test-"
"bug.h>`` and does not require pulling in ``<kunit/test.h>``. For example, we "
"have an option to enable some extra debug checks on some data structures as "
"shown below:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:829
msgid ""
"``kunit_fail_current_test()`` is safe to call even if KUnit is not enabled. "
"If KUnit is not enabled, or if no test is running in the current task, it "
"will do nothing. This compiles down to either a no-op or a static key check, "
"so will have a negligible performance impact when no test is running."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:835
msgid "Managing Fake Devices and Drivers"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:837
msgid ""
"When testing drivers or code which interacts with drivers, many functions "
"will require a ``struct device`` or ``struct device_driver``. In many cases, "
"setting up a real device is not required to test any given function, so a "
"fake device can be used instead."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:842
msgid ""
"KUnit provides helper functions to create and manage these fake devices, "
"which are internally of type ``struct kunit_device``, and are attached to a "
"special ``kunit_bus``. These devices support managed device resources "
"(devres), as described in Documentation/driver-api/driver-model/devres.rst"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:847
msgid ""
"To create a KUnit-managed ``struct device_driver``, use "
"``kunit_driver_create()``, which will create a driver with the given name, "
"on the ``kunit_bus``. This driver will automatically be destroyed when the "
"corresponding test finishes, but can also be manually destroyed with "
"``driver_unregister()``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:852
msgid ""
"To create a fake device, use the ``kunit_device_register()``, which will "
"create and register a device, using a new KUnit-managed driver created with "
"``kunit_driver_create()``. To provide a specific, non-KUnit-managed driver, "
"use ``kunit_device_register_with_driver()`` instead. Like with managed "
"drivers, KUnit-managed fake devices are automatically cleaned up when the "
"test finishes, but can be manually cleaned up early with "
"``kunit_device_unregister()``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:859
msgid ""
"The KUnit devices should be used in preference to "
"``root_device_register()``, and instead of ``platform_device_register()`` in "
"cases where the device is not otherwise a platform device."
msgstr ""
