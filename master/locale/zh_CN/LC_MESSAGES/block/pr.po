# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../block/pr.rst:3
msgid "Block layer support for Persistent Reservations"
msgstr ""

#: ../../../block/pr.rst:5
msgid ""
"The Linux kernel supports a user space interface for simplified Persistent "
"Reservations which map to block devices that support these (like SCSI). "
"Persistent Reservations allow restricting access to block devices to "
"specific initiators in a shared storage setup."
msgstr ""

#: ../../../block/pr.rst:11
msgid ""
"This document gives a general overview of the support ioctl commands. For a "
"more detailed reference please refer to the SCSI Primary Commands standard, "
"specifically the section on Reservations and the \"PERSISTENT RESERVE IN\" "
"and \"PERSISTENT RESERVE OUT\" commands."
msgstr ""

#: ../../../block/pr.rst:16
msgid ""
"All implementations are expected to ensure the reservations survive a power "
"loss and cover all connections in a multi path environment. These behaviors "
"are optional in SPC but will be automatically applied by Linux."
msgstr ""

#: ../../../block/pr.rst:23
msgid "The following types of reservations are supported:"
msgstr ""

#: ../../../block/pr.rst:25
msgid "PR_WRITE_EXCLUSIVE"
msgstr ""

#: ../../../block/pr.rst:26
msgid ""
"Only the initiator that owns the reservation can write to the device.  Any "
"initiator can read from the device."
msgstr ""

#: ../../../block/pr.rst:29
msgid "PR_EXCLUSIVE_ACCESS"
msgstr ""

#: ../../../block/pr.rst:30
msgid "Only the initiator that owns the reservation can access the device."
msgstr ""

#: ../../../block/pr.rst:33
msgid "PR_WRITE_EXCLUSIVE_REG_ONLY"
msgstr ""

#: ../../../block/pr.rst:34
msgid ""
"Only initiators with a registered key can write to the device, Any initiator "
"can read from the device."
msgstr ""

#: ../../../block/pr.rst:37
msgid "PR_EXCLUSIVE_ACCESS_REG_ONLY"
msgstr ""

#: ../../../block/pr.rst:38
msgid "Only initiators with a registered key can access the device."
msgstr ""

#: ../../../block/pr.rst:40
msgid "PR_WRITE_EXCLUSIVE_ALL_REGS"
msgstr ""

#: ../../../block/pr.rst:42
msgid ""
"Only initiators with a registered key can write to the device, Any initiator "
"can read from the device. All initiators with a registered key are "
"considered reservation holders. Please reference the SPC spec on the meaning "
"of a reservation holder if you want to use this type."
msgstr ""

#: ../../../block/pr.rst:49
msgid "PR_EXCLUSIVE_ACCESS_ALL_REGS"
msgstr ""

#: ../../../block/pr.rst:50
msgid ""
"Only initiators with a registered key can access the device. All initiators "
"with a registered key are considered reservation holders. Please reference "
"the SPC spec on the meaning of a reservation holder if you want to use this "
"type."
msgstr ""

#: ../../../block/pr.rst:58
msgid "The following ioctl are supported:"
msgstr ""

#: ../../../block/pr.rst:61
msgid "1. IOC_PR_REGISTER"
msgstr ""

#: ../../../block/pr.rst:63
msgid ""
"This ioctl command registers a new reservation if the new_key argument is "
"non-null.  If no existing reservation exists old_key must be zero, if an "
"existing reservation should be replaced old_key must contain the old "
"reservation key."
msgstr ""

#: ../../../block/pr.rst:68
msgid ""
"If the new_key argument is 0 it unregisters the existing reservation passed "
"in old_key."
msgstr ""

#: ../../../block/pr.rst:73
msgid "2. IOC_PR_RESERVE"
msgstr ""

#: ../../../block/pr.rst:75
msgid ""
"This ioctl command reserves the device and thus restricts access for other "
"devices based on the type argument.  The key argument must be the existing "
"reservation key for the device as acquired by the IOC_PR_REGISTER, "
"IOC_PR_REGISTER_IGNORE, IOC_PR_PREEMPT or IOC_PR_PREEMPT_ABORT commands."
msgstr ""

#: ../../../block/pr.rst:82
msgid "3. IOC_PR_RELEASE"
msgstr ""

#: ../../../block/pr.rst:84
msgid ""
"This ioctl command releases the reservation specified by key and flags and "
"thus removes any access restriction implied by it."
msgstr ""

#: ../../../block/pr.rst:89
msgid "4. IOC_PR_PREEMPT"
msgstr ""

#: ../../../block/pr.rst:91
msgid ""
"This ioctl command releases the existing reservation referred to by old_key "
"and replaces it with a new reservation of type for the reservation key "
"new_key."
msgstr ""

#: ../../../block/pr.rst:97
msgid "5. IOC_PR_PREEMPT_ABORT"
msgstr ""

#: ../../../block/pr.rst:99
msgid ""
"This ioctl command works like IOC_PR_PREEMPT except that it also aborts any "
"outstanding command sent over a connection identified by old_key."
msgstr ""

#: ../../../block/pr.rst:103
msgid "6. IOC_PR_CLEAR"
msgstr ""

#: ../../../block/pr.rst:105
msgid ""
"This ioctl command unregisters both key and any other reservation key "
"registered with the device and drops any existing reservation."
msgstr ""

#: ../../../block/pr.rst:110
msgid "Flags"
msgstr ""

#: ../../../block/pr.rst:112
msgid ""
"All the ioctls have a flag field.  Currently only one flag is supported:"
msgstr ""

#: ../../../block/pr.rst:114
msgid "PR_FL_IGNORE_KEY"
msgstr ""

#: ../../../block/pr.rst:115
msgid ""
"Ignore the existing reservation key.  This is commonly supported for "
"IOC_PR_REGISTER, and some implementation may support the flag for "
"IOC_PR_RESERVE."
msgstr ""

#: ../../../block/pr.rst:119
msgid "For all unknown flags the kernel will return -EOPNOTSUPP."
msgstr ""
