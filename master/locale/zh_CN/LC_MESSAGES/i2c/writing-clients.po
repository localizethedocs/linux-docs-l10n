# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../i2c/writing-clients.rst:3
msgid "Implementing I2C device drivers"
msgstr ""

#: ../../../i2c/writing-clients.rst:5
msgid ""
"This is a small guide for those who want to write kernel drivers for I2C or "
"SMBus devices, using Linux as the protocol host/master (not slave)."
msgstr ""

#: ../../../i2c/writing-clients.rst:8
msgid ""
"To set up a driver, you need to do several things. Some are optional, and "
"some things can be done slightly or completely different. Use this as a "
"guide, not as a rule book!"
msgstr ""

#: ../../../i2c/writing-clients.rst:14
msgid "General remarks"
msgstr ""

#: ../../../i2c/writing-clients.rst:16
msgid ""
"Try to keep the kernel namespace as clean as possible. The best way to do "
"this is to use a unique prefix for all global symbols. This is especially "
"important for exported symbols, but it is a good idea to do it for non-"
"exported symbols too. We will use the prefix ``foo_`` in this tutorial."
msgstr ""

#: ../../../i2c/writing-clients.rst:24
msgid "The driver structure"
msgstr ""

#: ../../../i2c/writing-clients.rst:26
msgid ""
"Usually, you will implement a single driver structure, and instantiate all "
"clients from it. Remember, a driver structure contains general access "
"routines, and should be zero-initialized except for fields with data you "
"provide.  A client structure holds device-specific information like the "
"driver model device node, and its I2C address."
msgstr ""

#: ../../../i2c/writing-clients.rst:55
msgid ""
"The name field is the driver name, and must not contain spaces.  It should "
"match the module name (if the driver can be compiled as a module), although "
"you can use MODULE_ALIAS (passing \"foo\" in this example) to add another "
"name for the module.  If the driver name doesn't match the module name, the "
"module won't be automatically loaded (hotplug/coldplug)."
msgstr ""

#: ../../../i2c/writing-clients.rst:61
msgid ""
"All other fields are for call-back functions which will be explained below."
msgstr ""

#: ../../../i2c/writing-clients.rst:66
msgid "Extra client data"
msgstr ""

#: ../../../i2c/writing-clients.rst:68
msgid ""
"Each client structure has a special ``data`` field that can point to any "
"structure at all.  You should use this to keep device-specific data."
msgstr ""

#: ../../../i2c/writing-clients.rst:79
msgid ""
"Note that starting with kernel 2.6.34, you don't have to set the ``data`` "
"field to NULL in remove() or if probe() failed anymore. The i2c-core does "
"this automatically on these occasions. Those are also the only times the "
"core will touch this field."
msgstr ""

#: ../../../i2c/writing-clients.rst:86
msgid "Accessing the client"
msgstr ""

#: ../../../i2c/writing-clients.rst:88
msgid ""
"Let's say we have a valid client structure. At some time, we will need to "
"gather information from the client, or write new information to the client."
msgstr ""

#: ../../../i2c/writing-clients.rst:92
msgid ""
"I have found it useful to define foo_read and foo_write functions for this. "
"For some cases, it will be easier to call the I2C functions directly, but "
"many chips have some kind of register-value idea that can easily be "
"encapsulated."
msgstr ""

#: ../../../i2c/writing-clients.rst:97
msgid ""
"The below functions are simple examples, and should not be copied literally::"
msgstr ""

#: ../../../i2c/writing-clients.rst:120
msgid "Probing and attaching"
msgstr ""

#: ../../../i2c/writing-clients.rst:122
msgid ""
"The Linux I2C stack was originally written to support access to hardware "
"monitoring chips on PC motherboards, and thus used to embed some assumptions "
"that were more appropriate to SMBus (and PCs) than to I2C.  One of these "
"assumptions was that most adapters and devices drivers support the "
"SMBUS_QUICK protocol to probe device presence.  Another was that devices and "
"their drivers can be sufficiently configured using only such probe "
"primitives."
msgstr ""

#: ../../../i2c/writing-clients.rst:129
msgid ""
"As Linux and its I2C stack became more widely used in embedded systems and "
"complex components such as DVB adapters, those assumptions became more "
"problematic.  Drivers for I2C devices that issue interrupts need more (and "
"different) configuration information, as do drivers handling chip variants "
"that can't be distinguished by protocol probing, or which need some board "
"specific information to operate correctly."
msgstr ""

#: ../../../i2c/writing-clients.rst:138
msgid "Device/Driver Binding"
msgstr ""

#: ../../../i2c/writing-clients.rst:140
msgid ""
"System infrastructure, typically board-specific initialization code or boot "
"firmware, reports what I2C devices exist.  For example, there may be a "
"table, in the kernel or from the boot loader, identifying I2C devices and "
"linking them to board-specific configuration information about IRQs and "
"other wiring artifacts, chip type, and so on.  That could be used to create "
"i2c_client objects for each I2C device."
msgstr ""

#: ../../../i2c/writing-clients.rst:147
msgid ""
"I2C device drivers using this binding model work just like any other kind of "
"driver in Linux:  they provide a probe() method to bind to those devices, "
"and a remove() method to unbind."
msgstr ""

#: ../../../i2c/writing-clients.rst:156
msgid ""
"Remember that the i2c_driver does not create those client handles.  The "
"handle may be used during foo_probe().  If foo_probe() reports success (zero "
"not a negative status code) it may save the handle and use it until "
"foo_remove() returns.  That binding model is used by most Linux drivers."
msgstr ""

#: ../../../i2c/writing-clients.rst:161
msgid ""
"The probe function is called when an entry in the id_table name field "
"matches the device's name. If the probe function needs that entry, it can "
"retrieve it using"
msgstr ""

#: ../../../i2c/writing-clients.rst:171
msgid "Device Creation"
msgstr ""

#: ../../../i2c/writing-clients.rst:173
msgid ""
"If you know for a fact that an I2C device is connected to a given I2C bus, "
"you can instantiate that device by simply filling an i2c_board_info "
"structure with the device address and driver name, and calling "
"i2c_new_client_device().  This will create the device, then the driver core "
"will take care of finding the right driver and will call its probe() method. "
"If a driver supports different device types, you can specify the type you "
"want using the type field.  You can also specify an IRQ and platform data if "
"needed."
msgstr ""

#: ../../../i2c/writing-clients.rst:182
msgid ""
"Sometimes you know that a device is connected to a given I2C bus, but you "
"don't know the exact address it uses.  This happens on TV adapters for "
"example, where the same driver supports dozens of slightly different models, "
"and I2C device addresses change from one model to the next.  In that case, "
"you can use the i2c_new_scanned_device() variant, which is similar to "
"i2c_new_client_device(), except that it takes an additional list of possible "
"I2C addresses to probe.  A device is created for the first responsive "
"address in the list.  If you expect more than one device to be present in "
"the address range, simply call i2c_new_scanned_device() that many times."
msgstr ""

#: ../../../i2c/writing-clients.rst:193
msgid ""
"The call to i2c_new_client_device() or i2c_new_scanned_device() typically "
"happens in the I2C bus driver. You may want to save the returned i2c_client "
"reference for later use."
msgstr ""

#: ../../../i2c/writing-clients.rst:199
msgid "Device Detection"
msgstr ""

#: ../../../i2c/writing-clients.rst:201
msgid ""
"The device detection mechanism comes with a number of disadvantages. You "
"need some reliable way to identify the supported devices (typically using "
"device-specific, dedicated identification registers), otherwise "
"misdetections are likely to occur and things can get wrong quickly.  Keep in "
"mind that the I2C protocol doesn't include any standard way to detect the "
"presence of a chip at a given address, let alone a standard way to identify "
"devices.  Even worse is the lack of semantics associated to bus transfers, "
"which means that the same transfer can be seen as a read operation by a chip "
"and as a write operation by another chip.  For these reasons, device "
"detection is considered a legacy mechanism and shouldn't be used in new code."
msgstr ""

#: ../../../i2c/writing-clients.rst:215
msgid "Device Deletion"
msgstr ""

#: ../../../i2c/writing-clients.rst:217
msgid ""
"Each I2C device which has been created using i2c_new_client_device() or "
"i2c_new_scanned_device() can be unregistered by calling "
"i2c_unregister_device().  If you don't call it explicitly, it will be called "
"automatically before the underlying I2C bus itself is removed, as a device "
"can't survive its parent in the device driver model."
msgstr ""

#: ../../../i2c/writing-clients.rst:225
msgid "Initializing the driver"
msgstr ""

#: ../../../i2c/writing-clients.rst:227
msgid ""
"When the kernel is booted, or when your foo driver module is inserted, you "
"have to do some initializing. Fortunately, just registering the driver "
"module is usually enough."
msgstr ""

#: ../../../i2c/writing-clients.rst:249
msgid ""
"Note that some functions are marked by ``__init``.  These functions can be "
"removed after kernel booting (or module loading) is completed. Likewise, "
"functions marked by ``__exit`` are dropped by the compiler when the code is "
"built into the kernel, as they would never be called."
msgstr ""

#: ../../../i2c/writing-clients.rst:256
msgid "Driver Information"
msgstr ""

#: ../../../i2c/writing-clients.rst:269
msgid "Power Management"
msgstr ""

#: ../../../i2c/writing-clients.rst:271
msgid ""
"If your I2C device needs special handling when entering a system low power "
"state -- like putting a transceiver into a low power mode, or activating a "
"system wakeup mechanism -- do that by implementing the appropriate callbacks "
"for the dev_pm_ops of the driver (like suspend and resume)."
msgstr ""

#: ../../../i2c/writing-clients.rst:277
msgid ""
"These are standard driver model calls, and they work just like they would "
"for any other driver stack.  The calls can sleep, and can use I2C messaging "
"to the device being suspended or resumed (since their parent I2C adapter is "
"active when these calls are issued, and IRQs are still enabled)."
msgstr ""

#: ../../../i2c/writing-clients.rst:285
msgid "System Shutdown"
msgstr ""

#: ../../../i2c/writing-clients.rst:287
msgid ""
"If your I2C device needs special handling when the system shuts down or "
"reboots (including kexec) -- like turning something off -- use a shutdown() "
"method."
msgstr ""

#: ../../../i2c/writing-clients.rst:291
msgid ""
"Again, this is a standard driver model call, working just like it would for "
"any other driver stack:  the calls can sleep, and can use I2C messaging."
msgstr ""

#: ../../../i2c/writing-clients.rst:297
msgid "Command function"
msgstr ""

#: ../../../i2c/writing-clients.rst:299
msgid ""
"A generic ioctl-like function call back is supported. You will seldom need "
"this, and its use is deprecated anyway, so newer design should not use it."
msgstr ""

#: ../../../i2c/writing-clients.rst:305
msgid "Sending and receiving"
msgstr ""

#: ../../../i2c/writing-clients.rst:307
msgid ""
"If you want to communicate with your device, there are several functions to "
"do this. You can find all of them in <linux/i2c.h>."
msgstr ""

#: ../../../i2c/writing-clients.rst:310
msgid ""
"If you can choose between plain I2C communication and SMBus level "
"communication, please use the latter. All adapters understand SMBus level "
"commands, but only some of them understand plain I2C!"
msgstr ""

#: ../../../i2c/writing-clients.rst:316
msgid "Plain I2C communication"
msgstr ""

#: ../../../i2c/writing-clients.rst:324
msgid ""
"These routines read and write some bytes from/to a client. The client "
"contains the I2C address, so you do not have to include it. The second "
"parameter contains the bytes to read/write, the third the number of bytes to "
"read/write (must be less than the length of the buffer, also should be less "
"than 64k since msg.len is u16.) Returned is the actual number of bytes read/"
"written."
msgstr ""

#: ../../../i2c/writing-clients.rst:336
msgid ""
"This sends a series of messages. Each message can be a read or write, and "
"they can be mixed in any way. The transactions are combined: no stop "
"condition is issued between transaction. The i2c_msg structure contains for "
"each message the client address, the number of bytes of the message and the "
"message data itself."
msgstr ""

#: ../../../i2c/writing-clients.rst:342
msgid ""
"You can read the file i2c-protocol.rst for more information about the actual "
"I2C protocol."
msgstr ""

#: ../../../i2c/writing-clients.rst:347
msgid "SMBus communication"
msgstr ""

#: ../../../i2c/writing-clients.rst:355
msgid ""
"This is the generic SMBus function. All functions below are implemented in "
"terms of it. Never use this function directly!"
msgstr ""

#: ../../../i2c/writing-clients.rst:378
msgid ""
"These ones were removed from i2c-core because they had no users, but could "
"be added back later if needed::"
msgstr ""

#: ../../../i2c/writing-clients.rst:387
msgid ""
"All these transactions return a negative errno value on failure. The 'write' "
"transactions return 0 on success; the 'read' transactions return the read "
"value, except for block transactions, which return the number of values "
"read. The block buffers need not be longer than 32 bytes."
msgstr ""

#: ../../../i2c/writing-clients.rst:392
msgid ""
"You can read the file smbus-protocol.rst for more information about the "
"actual SMBus protocol."
msgstr ""

#: ../../../i2c/writing-clients.rst:397
msgid "General purpose routines"
msgstr ""

#: ../../../i2c/writing-clients.rst:399
msgid ""
"Below all general purpose routines are listed, that were not mentioned "
"before::"
msgstr ""
