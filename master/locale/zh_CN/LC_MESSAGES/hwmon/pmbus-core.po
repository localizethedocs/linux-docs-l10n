# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../hwmon/pmbus-core.rst:3
msgid "PMBus core driver and internal API"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:6
msgid "Introduction"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:8
msgid ""
"[from pmbus.org] The Power Management Bus (PMBus) is an open standard power-"
"management protocol with a fully defined command language that facilitates "
"communication with power converters and other devices in a power system. The "
"protocol is implemented over the industry-standard SMBus serial interface "
"and enables programming, control, and real-time monitoring of compliant "
"power conversion products. This flexible and highly versatile standard "
"allows for communication between devices based on both analog and digital "
"technologies, and provides true interoperability which will reduce design "
"complexity and shorten time to market for power system designers. Pioneered "
"by leading power supply and semiconductor companies, this open power system "
"standard is maintained and promoted by the PMBus Implementers Forum (PMBus-"
"IF), comprising 30+ adopters with the objective to provide support to, and "
"facilitate adoption among, users."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:21
msgid ""
"Unfortunately, while PMBus commands are standardized, there are no mandatory "
"commands, and manufacturers can add as many non-standard commands as they "
"like. Also, different PMBUs devices act differently if non-supported "
"commands are executed. Some devices return an error, some devices return "
"0xff or 0xffff and set a status error flag, and some devices may simply hang "
"up."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:27
msgid ""
"Despite all those difficulties, a generic PMBus device driver is still "
"useful and supported since kernel version 2.6.39. However, it was necessary "
"to support device specific extensions in addition to the core PMBus driver, "
"since it is simply unknown what new device specific functionality PMBus "
"device developers come up with next."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:33
msgid ""
"To make device specific extensions as scalable as possible, and to avoid "
"having to modify the core PMBus driver repeatedly for new devices, the PMBus "
"driver was split into core, generic, and device specific code. The core code "
"(in pmbus_core.c) provides generic functionality. The generic code (in pmbus."
"c) provides support for generic PMBus devices. Device specific code is "
"responsible for device specific initialization and, if needed, maps device "
"specific functionality into generic functionality. This is to some degree "
"comparable to PCI code, where generic code is augmented as needed with "
"quirks for all kinds of devices."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:44
msgid "PMBus device capabilities auto-detection"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:46
msgid ""
"For generic PMBus devices, code in pmbus.c attempts to auto-detect all "
"supported PMBus commands. Auto-detection is somewhat limited, since there "
"are simply too many variables to consider. For example, it is almost "
"impossible to autodetect which PMBus commands are paged and which commands "
"are replicated across all pages (see the PMBus specification for details on "
"multi-page PMBus devices)."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:52
msgid ""
"For this reason, it often makes sense to provide a device specific driver if "
"not all commands can be auto-detected. The data structures in this driver "
"can be used to inform the core driver about functionality supported by "
"individual chips."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:57
msgid ""
"Some commands are always auto-detected. This applies to all limit commands "
"(lcrit, min, max, and crit attributes) as well as associated alarm "
"attributes. Limits and alarm attributes are auto-detected because there are "
"simply too many possible combinations to provide a manual configuration "
"interface."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:63
msgid "PMBus internal API"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:65
msgid ""
"The API between core and device specific PMBus code is defined in drivers/"
"hwmon/pmbus/pmbus.h. In addition to the internal API, pmbus.h defines "
"standard PMBus commands and virtual PMBus commands."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:70
msgid "Standard PMBus commands"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:72
msgid ""
"Standard PMBus commands (commands values 0x00 to 0xff) are defined in the "
"PMBUs specification."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:76
msgid "Virtual PMBus commands"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:78
msgid ""
"Virtual PMBus commands are provided to enable support for non-standard "
"functionality which has been implemented by several chip vendors and is thus "
"desirable to support."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:82
msgid ""
"Virtual PMBus commands start with command value 0x100 and can thus easily be "
"distinguished from standard PMBus commands (which can not have values larger "
"than 0xff). Support for virtual PMBus commands is device specific and thus "
"has to be implemented in device specific code."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:87
msgid ""
"Virtual commands are named PMBUS_VIRT_xxx and start with PMBUS_VIRT_BASE. "
"All virtual commands are word sized."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:90
msgid "There are currently two types of virtual commands."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:92
msgid ""
"READ commands are read-only; writes are either ignored or return an error."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:93
msgid ""
"RESET commands are read/write. Reading reset registers returns zero (used "
"for detection), writing any value causes the associated history to be reset."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:97
msgid ""
"Virtual commands have to be handled in device specific driver code. Chip "
"driver code returns non-negative values if a virtual command is supported, "
"or a negative error code if not. The chip driver may return -ENODATA or any "
"other Linux error code in this case, though an error code other than -"
"ENODATA is handled more efficiently and thus preferred. Either case, the "
"calling PMBus core code will abort if the chip driver returns an error code "
"when reading or writing virtual registers (in other words, the PMBus core "
"code will never send a virtual command to a chip)."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:107
msgid "PMBus driver information"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:109
msgid ""
"PMBus driver information, defined in struct pmbus_driver_info, is the main "
"means for device specific drivers to pass information to the core PMBus "
"driver. Specifically, it provides the following information."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:113
msgid ""
"For devices supporting its data in Direct Data Format, it provides "
"coefficients for converting register values into normalized data. This data "
"is usually provided by chip manufacturers in device datasheets."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:116
msgid ""
"Supported chip functionality can be provided to the core driver. This may be "
"necessary for chips which react badly if non-supported commands are "
"executed, and/or to speed up device detection and initialization."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:119
msgid ""
"Several function entry points are provided to support overriding and/or "
"augmenting generic command execution. This functionality can be used to map "
"non-standard PMBus commands to standard commands, or to augment standard "
"command return values with device specific information."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:125
msgid "PEC Support"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:127
msgid ""
"Many PMBus devices support SMBus PEC (Packet Error Checking). If supported "
"by both the I2C adapter and by the PMBus chip, it is by default enabled. If "
"PEC is supported, the PMBus core driver adds an attribute named 'pec' to the "
"I2C device. This attribute can be used to control PEC support in the "
"communication with the PMBus chip."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:134
msgid "API functions"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:137
msgid "Functions provided by chip driver"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:139
msgid ""
"All functions return the command return value (read) or zero (write) if "
"successful. A return value of -ENODATA indicates that there is no "
"manufacturer specific command, but that a standard PMBus command may exist. "
"Any other negative return value indicates that the commands does not exist "
"for this chip, and that no attempt should be made to read or write the "
"standard command."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:146
msgid ""
"As mentioned above, an exception to this rule applies to virtual commands, "
"which *must* be handled in driver specific code. See \"Virtual PMBus "
"Commands\" above for more details."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:150
msgid "Command execution in the core PMBus driver code is as follows::"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:161
msgid ""
"Chip drivers may provide pointers to the following functions in struct "
"pmbus_driver_info. All functions are optional."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:168
msgid ""
"Read byte from page <page>, register <reg>. <page> may be -1, which means "
"\"current page\"."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:177
msgid ""
"Read word from page <page>, phase <phase>, register <reg>. If the chip does "
"not support multiple phases, the phase parameter can be ignored. If the chip "
"supports multiple phases, a phase value of 0xff indicates all phases."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:186
msgid "Write word to page <page>, register <reg>."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:192
msgid ""
"Write byte to page <page>, register <reg>. <page> may be -1, which means "
"\"current page\"."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:199
msgid ""
"Determine supported PMBus functionality. This function is only necessary if "
"a chip driver supports multiple chips, and the chip functionality is not pre-"
"determined. It is currently only used by the generic pmbus driver (pmbus.c)."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:205
msgid "Functions exported by core driver"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:207
msgid ""
"Chip drivers are expected to use the following functions to read or write "
"PMBus registers. Chip drivers may also use direct I2C commands. If direct "
"I2C commands are used, the chip driver code must not directly modify the "
"current page, since the selected page is cached in the core driver and the "
"core driver will assume that it is selected. Using pmbus_set_page() to "
"select a new page is mandatory."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:218
msgid ""
"Set PMBus page register to <page> and <phase> for subsequent commands. If "
"the chip does not support multiple phases, the phase parameter is ignored. "
"Otherwise, a phase value of 0xff selects all phases."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:227
msgid ""
"Read word data from <page>, <phase>, <reg>. Similar to "
"i2c_smbus_read_word_data(), but selects page and phase first. If the chip "
"does not support multiple phases, the phase parameter is ignored. Otherwise, "
"a phase value of 0xff selects all phases."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:237
msgid ""
"Write word data to <page>, <reg>. Similar to i2c_smbus_write_word_data(), "
"but selects page first."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:244
msgid ""
"Read byte data from <page>, <reg>. Similar to i2c_smbus_read_byte_data(), "
"but selects page first. <page> may be -1, which means \"current page\"."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:251
msgid ""
"Write byte data to <page>, <reg>. Similar to i2c_smbus_write_byte(), but "
"selects page first. <page> may be -1, which means \"current page\"."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:258
msgid ""
"Execute PMBus \"Clear Fault\" command on all chip pages. This function calls "
"the device specific write_byte function if defined. Therefore, it must _not_ "
"be called from that function."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:266
msgid ""
"Check if byte register exists. Return true if the register exists, false "
"otherwise. This function calls the device specific write_byte function if "
"defined to obtain the chip status. Therefore, it must _not_ be called from "
"that function."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:275
msgid ""
"Check if word register exists. Return true if the register exists, false "
"otherwise. This function calls the device specific write_byte function if "
"defined to obtain the chip status. Therefore, it must _not_ be called from "
"that function."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:284
msgid ""
"Execute probe function. Similar to standard probe function for other "
"drivers, with the pointer to struct pmbus_driver_info as additional "
"argument. Calls identify function if supported. Must only be called from "
"device probe function."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:294
msgid ""
"Return pointer to struct pmbus_driver_info as passed to pmbus_do_probe()."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:298
msgid "PMBus driver platform data"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:300
msgid ""
"PMBus platform data is defined in include/linux/pmbus.h. Platform data "
"currently provides a flags field with four bits used::"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:329
msgid "Flags"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:331
msgid "PMBUS_SKIP_STATUS_CHECK"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:333
msgid ""
"During register detection, skip checking the status register for "
"communication or command errors."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:336
msgid ""
"Some PMBus chips respond with valid data when trying to read an unsupported "
"register. For such chips, checking the status register is mandatory when "
"trying to determine if a chip register exists or not. Other PMBus chips "
"don't support the STATUS_CML register, or report communication errors for no "
"explicable reason. For such chips, checking the status register must be "
"disabled."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:343
msgid ""
"Some i2c controllers do not support single-byte commands (write commands "
"with no data, i2c_smbus_write_byte()). With such controllers, clearing the "
"status register is impossible, and the PMBUS_SKIP_STATUS_CHECK flag must be "
"set."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:347
msgid "PMBUS_WRITE_PROTECTED"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:349
msgid ""
"Set if the chip is write protected and write protection is not determined by "
"the standard WRITE_PROTECT command."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:352
msgid "PMBUS_NO_CAPABILITY"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:354
msgid ""
"Some PMBus chips don't respond with valid data when reading the CAPABILITY "
"register. For such chips, this flag should be set so that the PMBus core "
"driver doesn't use CAPABILITY to determine its behavior."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:358
msgid "PMBUS_READ_STATUS_AFTER_FAILED_CHECK"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:360
msgid "Read the STATUS register after each failed register check."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:362
msgid ""
"Some PMBus chips end up in an undefined state when trying to read an "
"unsupported register. For such chips, it is necessary to reset the chip "
"pmbus controller to a known state after a failed register check. This can be "
"done by reading a known register. By setting this flag the driver will try "
"to read the STATUS register after each failed register check. This read may "
"fail, but it will put the chip into a known state."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:370
msgid "PMBUS_NO_WRITE_PROTECT"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:372
msgid ""
"Some PMBus chips respond with invalid data when reading the WRITE_PROTECT "
"register. For such chips, this flag should be set so that the PMBus core "
"driver doesn't use the WRITE_PROTECT command to determine its behavior."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:376
msgid "PMBUS_USE_COEFFICIENTS_CMD"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:378
msgid ""
"When this flag is set the PMBus core driver will use the COEFFICIENTS "
"register to initialize the coefficients for the direct mode format."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:381
msgid "PMBUS_OP_PROTECTED"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:383
msgid ""
"Set if the chip OPERATION command is protected and protection is not "
"determined by the standard WRITE_PROTECT command."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:386
msgid "PMBUS_VOUT_PROTECTED"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:388
msgid ""
"Set if the chip VOUT_COMMAND command is protected and protection is not "
"determined by the standard WRITE_PROTECT command."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:392
msgid "Module parameter"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:394
msgid "pmbus_core.wp: PMBus write protect forced mode"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:396
msgid ""
"PMBus may come up with a variety of write protection configuration. "
"'pmbus_core.wp' may be used if a particular write protection is necessary. "
"The ability to actually alter the protection may also depend on the chip so "
"the actual runtime write protection configuration may differ from the "
"requested one. pmbus_core currently support the following value:"
msgstr ""

#: ../../../hwmon/pmbus-core.rst:402
msgid "0: write protection removed."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:403
msgid ""
"1: Disable all writes except to the WRITE_PROTECT, OPERATION, PAGE, "
"ON_OFF_CONFIG and VOUT_COMMAND commands."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:405
msgid ""
"2: Disable all writes except to the WRITE_PROTECT, OPERATION and PAGE "
"commands."
msgstr ""

#: ../../../hwmon/pmbus-core.rst:407
msgid ""
"3: Disable all writes except to the WRITE_PROTECT command. Note that "
"protection should include the PAGE register. This may be problematic for "
"multi-page chips, if the chips strictly follows the PMBus specification, "
"preventing the chip from changing the active page."
msgstr ""
