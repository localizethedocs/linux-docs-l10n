# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/riscv/zicfilp.rst:8
msgid "Tracking indirect control transfers on RISC-V Linux"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:10
msgid ""
"This document briefly describes the interface provided to userspace by Linux "
"to enable indirect branch tracking for user mode applications on RISC-V."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:14
msgid "1. Feature Overview"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:16
msgid ""
"Memory corruption issues usually result in crashes.  However, in the hands "
"of a creative adversary, these can result in a variety of security issues."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:20
msgid ""
"Some of those security issues can be code re-use attacks, where an adversary "
"can use corrupt function pointers, chaining them together to perform jump "
"oriented programming (JOP) or call oriented programming (COP) and thus "
"compromise control flow integrity (CFI) of the program."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:25
msgid ""
"Function pointers live in read-write memory and thus are susceptible to "
"corruption.  This can allow an adversary to control the program counter (PC) "
"value.  On RISC-V, the zicfilp extension enforces a restriction on such "
"indirect control transfers:"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:30
msgid ""
"Indirect control transfers must land on a landing pad instruction ``lpad``. "
"There are two exceptions to this rule:"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:33
msgid ""
"rs1 = x1 or rs1 = x5, i.e. a return from a function and returns are "
"protected using shadow stack (see zicfiss.rst)"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:36
msgid ""
"rs1 = x7. On RISC-V, the compiler usually does the following to reach a "
"function which is beyond the offset of possible J-type instruction::"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:42
msgid ""
"This form of indirect control transfer is immutable and doesn't rely on "
"memory.  Thus rs1=x7 is exempted from tracking and these are considered "
"software guarded jumps."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:46
msgid ""
"The ``lpad`` instruction is a pseudo-op of ``auipc rd, <imm_20bit>`` with "
"``rd=x0``.  This is a HINT op.  The ``lpad`` instruction must be aligned on "
"a 4 byte boundary.  It compares the 20 bit immediate with x7. If "
"``imm_20bit`` == 0, the CPU doesn't perform any comparison with ``x7``. If "
"``imm_20bit`` != 0, then ``imm_20bit`` must match ``x7`` else CPU will raise "
"``software check exception`` (``cause=18``) with ``*tval = 2``."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:54
msgid ""
"The compiler can generate a hash over function signatures and set them up "
"(truncated to 20 bits) in x7 at callsites.  Function prologues can have "
"``lpad`` instructions encoded with the same function hash. This further "
"reduces the number of valid program counter addresses a call site can reach."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:61
msgid "2. ELF and psABI"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:63
msgid ""
"The toolchain sets up :c:macro:`GNU_PROPERTY_RISCV_FEATURE_1_FCFI` for "
"property :c:macro:`GNU_PROPERTY_RISCV_FEATURE_1_AND` in the notes section of "
"the object file."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:68
msgid "3. Linux enabling"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:70
msgid ""
"User space programs can have multiple shared objects loaded in their address "
"spaces.  It's a difficult task to make sure all the dependencies have been "
"compiled with indirect branch support. Thus it's left to the dynamic loader "
"to enable indirect branch tracking for the program."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:77
msgid "4. prctl() enabling"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:79
msgid ""
":c:macro:`PR_SET_INDIR_BR_LP_STATUS` / :c:macro:"
"`PR_GET_INDIR_BR_LP_STATUS` / :c:macro:`PR_LOCK_INDIR_BR_LP_STATUS` are "
"three prctls added to manage indirect branch tracking.  These prctls are "
"architecture-agnostic and return -EINVAL if the underlying functionality is "
"not supported."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:84
msgid "prctl(PR_SET_INDIR_BR_LP_STATUS, unsigned long arg)"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:86
msgid ""
"If arg1 is :c:macro:`PR_INDIR_BR_LP_ENABLE` and if CPU supports ``zicfilp`` "
"then the kernel will enable indirect branch tracking for the task.  The "
"dynamic loader can issue this :c:macro:`prctl` once it has determined that "
"all the objects loaded in the address space support indirect branch "
"tracking.  Additionally, if there is a `dlopen` to an object which wasn't "
"compiled with ``zicfilp``, the dynamic loader can issue this prctl with arg1 "
"set to 0 (i.e. :c:macro:`PR_INDIR_BR_LP_ENABLE` cleared)."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:95
msgid "prctl(PR_GET_INDIR_BR_LP_STATUS, unsigned long * arg)"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:97
msgid ""
"Returns the current status of indirect branch tracking. If enabled it'll "
"return :c:macro:`PR_INDIR_BR_LP_ENABLE`"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:100
msgid "prctl(PR_LOCK_INDIR_BR_LP_STATUS, unsigned long arg)"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:102
msgid ""
"Locks the current status of indirect branch tracking on the task. User space "
"may want to run with a strict security posture and wouldn't want loading of "
"objects without ``zicfilp`` support in them, to disallow disabling of "
"indirect branch tracking. In this case, user space can use this prctl to "
"lock the current settings."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:109
msgid "5. violations related to indirect branch tracking"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:111
msgid ""
"Pertaining to indirect branch tracking, the CPU raises a software check "
"exception in the following conditions:"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:114
msgid "missing ``lpad`` after indirect call / jmp"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:115
msgid "``lpad`` not on 4 byte boundary"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:116
msgid ""
"``imm_20bit`` embedded in ``lpad`` instruction doesn't match with ``x7``"
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:118
msgid ""
"In all 3 cases, ``*tval = 2`` is captured and software check exception is "
"raised (``cause=18``)."
msgstr ""

#: ../../../arch/riscv/zicfilp.rst:121
msgid ""
"The kernel will treat this as :c:macro:`SIGSEGV` with code = :c:macro:"
"`SEGV_CPERR` and follow the normal course of signal delivery."
msgstr ""
