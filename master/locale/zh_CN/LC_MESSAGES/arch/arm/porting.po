# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm/porting.rst:3
msgid "Porting"
msgstr ""

#: ../../../arch/arm/porting.rst:5
msgid ""
"Taken from list archive at http://lists.arm.linux.org.uk/pipermail/linux-arm-"
"kernel/2001-July/004064.html"
msgstr ""

#: ../../../arch/arm/porting.rst:8
msgid "Initial definitions"
msgstr ""

#: ../../../arch/arm/porting.rst:10
msgid ""
"The following symbol definitions rely on you knowing the translation that "
"__virt_to_phys() does for your machine.  This macro converts the passed "
"virtual address to a physical address.  Normally, it is simply:"
msgstr ""

#: ../../../arch/arm/porting.rst:14
msgid "phys = virt - PAGE_OFFSET + PHYS_OFFSET"
msgstr ""

#: ../../../arch/arm/porting.rst:18
msgid "Decompressor Symbols"
msgstr ""

#: ../../../arch/arm/porting.rst:20
msgid "ZTEXTADDR"
msgstr ""

#: ../../../arch/arm/porting.rst:21
msgid ""
"Start address of decompressor.  There's no point in talking about virtual or "
"physical addresses here, since the MMU will be off at the time when you call "
"the decompressor code.  You normally call the kernel at this address to "
"start it booting.  This doesn't have to be located in RAM, it can be in "
"flash or other read-only or read-write addressable medium."
msgstr ""

#: ../../../arch/arm/porting.rst:28
msgid "ZBSSADDR"
msgstr ""

#: ../../../arch/arm/porting.rst:29
msgid ""
"Start address of zero-initialised work area for the decompressor. This must "
"be pointing at RAM.  The decompressor will zero initialise this for you.  "
"Again, the MMU will be off."
msgstr ""

#: ../../../arch/arm/porting.rst:33
msgid "ZRELADDR"
msgstr ""

#: ../../../arch/arm/porting.rst:34
msgid ""
"This is the address where the decompressed kernel will be written, and "
"eventually executed.  The following constraint must be valid:"
msgstr ""

#: ../../../arch/arm/porting.rst:37
msgid "__virt_to_phys(TEXTADDR) == ZRELADDR"
msgstr ""

#: ../../../arch/arm/porting.rst:39
msgid ""
"The initial part of the kernel is carefully coded to be position independent."
msgstr ""

#: ../../../arch/arm/porting.rst:42
msgid "INITRD_PHYS"
msgstr ""

#: ../../../arch/arm/porting.rst:43
msgid ""
"Physical address to place the initial RAM disk.  Only relevant if you are "
"using the bootpImage stuff (which only works on the old struct param_struct)."
msgstr ""

#: ../../../arch/arm/porting.rst:47
msgid "INITRD_VIRT"
msgstr ""

#: ../../../arch/arm/porting.rst:48
msgid ""
"Virtual address of the initial RAM disk.  The following  constraint must be "
"valid:"
msgstr ""

#: ../../../arch/arm/porting.rst:51
msgid "__virt_to_phys(INITRD_VIRT) == INITRD_PHYS"
msgstr ""

#: ../../../arch/arm/porting.rst:53
msgid "PARAMS_PHYS"
msgstr ""

#: ../../../arch/arm/porting.rst:54
msgid ""
"Physical address of the struct param_struct or tag list, giving the kernel "
"various parameters about its execution environment."
msgstr ""

#: ../../../arch/arm/porting.rst:59
msgid "Kernel Symbols"
msgstr ""

#: ../../../arch/arm/porting.rst:61
msgid "PHYS_OFFSET"
msgstr ""

#: ../../../arch/arm/porting.rst:62
msgid "Physical start address of the first bank of RAM."
msgstr ""

#: ../../../arch/arm/porting.rst:64
msgid "PAGE_OFFSET"
msgstr ""

#: ../../../arch/arm/porting.rst:65
msgid ""
"Virtual start address of the first bank of RAM.  During the kernel boot "
"phase, virtual address PAGE_OFFSET will be mapped to physical address "
"PHYS_OFFSET, along with any other mappings you supply. This should be the "
"same value as TASK_SIZE."
msgstr ""

#: ../../../arch/arm/porting.rst:70
msgid "TASK_SIZE"
msgstr ""

#: ../../../arch/arm/porting.rst:71
msgid ""
"The maximum size of a user process in bytes.  Since user space always starts "
"at zero, this is the maximum address that a user process can access+1.  The "
"user space stack grows down from this address."
msgstr ""

#: ../../../arch/arm/porting.rst:76
msgid ""
"Any virtual address below TASK_SIZE is deemed to be user process area, and "
"therefore managed dynamically on a process by process basis by the kernel.  "
"I'll call this the user segment."
msgstr ""

#: ../../../arch/arm/porting.rst:80
msgid ""
"Anything above TASK_SIZE is common to all processes.  I'll call this the "
"kernel segment."
msgstr ""

#: ../../../arch/arm/porting.rst:83
msgid ""
"(In other words, you can't put IO mappings below TASK_SIZE, and hence "
"PAGE_OFFSET)."
msgstr ""

#: ../../../arch/arm/porting.rst:86
msgid "TEXTADDR"
msgstr ""

#: ../../../arch/arm/porting.rst:87
msgid ""
"Virtual start address of kernel, normally PAGE_OFFSET + 0x8000. This is "
"where the kernel image ends up.  With the latest kernels, it must be located "
"at 32768 bytes into a 128MB region.  Previous kernels placed a restriction "
"of 256MB here."
msgstr ""

#: ../../../arch/arm/porting.rst:92
msgid "DATAADDR"
msgstr ""

#: ../../../arch/arm/porting.rst:93
msgid ""
"Virtual address for the kernel data segment.  Must not be defined when using "
"the decompressor."
msgstr ""

#: ../../../arch/arm/porting.rst:96
msgid "VMALLOC_START / VMALLOC_END"
msgstr ""

#: ../../../arch/arm/porting.rst:97
msgid ""
"Virtual addresses bounding the vmalloc() area.  There must not be any static "
"mappings in this area; vmalloc will overwrite them. The addresses must also "
"be in the kernel segment (see above). Normally, the vmalloc() area starts "
"VMALLOC_OFFSET bytes above the last virtual RAM address (found using "
"variable high_memory)."
msgstr ""

#: ../../../arch/arm/porting.rst:103
msgid "VMALLOC_OFFSET"
msgstr ""

#: ../../../arch/arm/porting.rst:104
msgid ""
"Offset normally incorporated into VMALLOC_START to provide a hole between "
"virtual RAM and the vmalloc area.  We do this to allow out of bounds memory "
"accesses (eg, something writing off the end of the mapped memory map) to be "
"caught.  Normally set to 8MB."
msgstr ""

#: ../../../arch/arm/porting.rst:110
msgid "Architecture Specific Macros"
msgstr ""

#: ../../../arch/arm/porting.rst:112
msgid "BOOT_MEM(pram,pio,vio)"
msgstr ""

#: ../../../arch/arm/porting.rst:113
msgid ""
"`pram` specifies the physical start address of RAM.  Must always be present, "
"and should be the same as PHYS_OFFSET."
msgstr ""

#: ../../../arch/arm/porting.rst:116
msgid ""
"`pio` is the physical address of an 8MB region containing IO for use with "
"the debugging macros in arch/arm/kernel/debug-armv.S."
msgstr ""

#: ../../../arch/arm/porting.rst:119
msgid "`vio` is the virtual address of the 8MB debugging region."
msgstr ""

#: ../../../arch/arm/porting.rst:121
msgid ""
"It is expected that the debugging region will be re-initialised by the "
"architecture specific code later in the code (via the MAPIO function)."
msgstr ""

#: ../../../arch/arm/porting.rst:125
msgid "BOOT_PARAMS"
msgstr ""

#: ../../../arch/arm/porting.rst:126
msgid "Same as, and see PARAMS_PHYS."
msgstr ""

#: ../../../arch/arm/porting.rst:128
msgid "FIXUP(func)"
msgstr ""

#: ../../../arch/arm/porting.rst:129
msgid ""
"Machine specific fixups, run before memory subsystems have been initialised."
msgstr ""

#: ../../../arch/arm/porting.rst:132
msgid "MAPIO(func)"
msgstr ""

#: ../../../arch/arm/porting.rst:133
msgid ""
"Machine specific function to map IO areas (including the debug region above)."
msgstr ""

#: ../../../arch/arm/porting.rst:136
msgid "INITIRQ(func)"
msgstr ""

#: ../../../arch/arm/porting.rst:137
msgid "Machine specific function to initialise interrupts."
msgstr ""
