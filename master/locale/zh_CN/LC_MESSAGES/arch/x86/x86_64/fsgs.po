# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/x86_64/fsgs.rst:4
msgid "Using FS and GS segments in user space applications"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:6
msgid ""
"The x86 architecture supports segmentation. Instructions which access memory "
"can use segment register based addressing mode. The following notation is "
"used to address a byte within a segment:"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:10
msgid "Segment-register:Byte-address"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:12
msgid ""
"The segment base address is added to the Byte-address to compute the "
"resulting virtual address which is accessed. This allows to access multiple "
"instances of data with the identical Byte-address, i.e. the same code. The "
"selection of a particular instance is purely based on the base-address in "
"the segment register."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:18
msgid ""
"In 32-bit mode the CPU provides 6 segments, which also support segment "
"limits. The limits can be used to enforce address space protections."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:21
msgid ""
"In 64-bit mode the CS/SS/DS/ES segments are ignored and the base address is "
"always 0 to provide a full 64bit address space. The FS and GS segments are "
"still functional in 64-bit mode."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:26
msgid "Common FS and GS usage"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:28
msgid ""
"The FS segment is commonly used to address Thread Local Storage (TLS). FS is "
"usually managed by runtime code or a threading library. Variables declared "
"with the '__thread' storage class specifier are instantiated per thread and "
"the compiler emits the FS: address prefix for accesses to these variables. "
"Each thread has its own FS base address so common code can be used without "
"complex address offset calculations to access the per thread instances. "
"Applications should not use FS for other purposes when they use runtimes or "
"threading libraries which manage the per thread FS."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:37
msgid ""
"The GS segment has no common use and can be used freely by applications. GCC "
"and Clang support GS based addressing via address space identifiers."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:42
msgid "Reading and writing the FS/GS base address"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:44
msgid "There exist two mechanisms to read and write the FS/GS base address:"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:46
msgid "the arch_prctl() system call"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:48
msgid "the FSGSBASE instruction family"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:51
msgid "Accessing FS/GS base with arch_prctl()"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:53
msgid ""
"The arch_prctl(2) based mechanism is available on all 64-bit CPUs and all "
"kernel versions."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:56
msgid "Reading the base:"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:58
msgid "arch_prctl(ARCH_GET_FS, &fsbase); arch_prctl(ARCH_GET_GS, &gsbase);"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:61
msgid "Writing the base:"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:63
msgid "arch_prctl(ARCH_SET_FS, fsbase); arch_prctl(ARCH_SET_GS, gsbase);"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:66
msgid ""
"The ARCH_SET_GS prctl may be disabled depending on kernel configuration and "
"security settings."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:70
msgid "Accessing FS/GS base with the FSGSBASE instructions"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:72
msgid ""
"With the Ivy Bridge CPU generation Intel introduced a new set of "
"instructions to access the FS and GS base registers directly from user "
"space. These instructions are also supported on AMD Family 17H CPUs. The "
"following instructions are available:"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:78
msgid "RDFSBASE %reg"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:78 ../../../arch/x86/x86_64/fsgs.rst:132
msgid "Read the FS base register"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:79
msgid "RDGSBASE %reg"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:79 ../../../arch/x86/x86_64/fsgs.rst:133
msgid "Read the GS base register"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:80
msgid "WRFSBASE %reg"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:80 ../../../arch/x86/x86_64/fsgs.rst:134
msgid "Write the FS base register"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:81
msgid "WRGSBASE %reg"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:81 ../../../arch/x86/x86_64/fsgs.rst:135
msgid "Write the GS base register"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:84
msgid ""
"The instructions avoid the overhead of the arch_prctl() syscall and allow "
"more flexible usage of the FS/GS addressing modes in user space "
"applications. This does not prevent conflicts between threading libraries "
"and runtimes which utilize FS and applications which want to use it for "
"their own purpose."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:91
msgid "FSGSBASE instructions enablement"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:92
msgid ""
"The instructions are enumerated in CPUID leaf 7, bit 0 of EBX. If available /"
"proc/cpuinfo shows 'fsgsbase' in the flag entry of the CPUs."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:95
msgid ""
"The availability of the instructions does not enable them automatically. The "
"kernel has to enable them explicitly in CR4. The reason for this is that "
"older kernels make assumptions about the values in the GS register and "
"enforce them when GS base is set via arch_prctl(). Allowing user space to "
"write arbitrary values to GS base would violate these assumptions and cause "
"malfunction."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:102
msgid ""
"On kernels which do not enable FSGSBASE the execution of the FSGSBASE "
"instructions will fault with a #UD exception."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:105
msgid ""
"The kernel provides reliable information about the enabled state in the ELF "
"AUX vector. If the HWCAP2_FSGSBASE bit is set in the AUX vector, the kernel "
"has FSGSBASE instructions enabled and applications can use them. The "
"following code example shows how this detection works::"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:126
msgid "FSGSBASE instructions compiler support"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:128
msgid ""
"GCC version 4.6.4 and newer provide intrinsics for the FSGSBASE "
"instructions. Clang 5 supports them as well."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:132
msgid "_readfsbase_u64()"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:133
msgid "_readgsbase_u64()"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:134
msgid "_writefsbase_u64()"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:135
msgid "_writegsbase_u64()"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:138
msgid ""
"To utilize these intrinsics <immintrin.h> must be included in the source "
"code and the compiler option -mfsgsbase has to be added."
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:142
msgid "Compiler support for FS/GS based addressing"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:144
msgid ""
"GCC version 6 and newer provide support for FS/GS based addressing via Named "
"Address Spaces. GCC implements the following address space identifiers for "
"x86:"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:149
msgid "__seg_fs"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:149 ../../../arch/x86/x86_64/fsgs.rst:186
msgid "Variable is addressed relative to FS"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:150
msgid "__seg_gs"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:150 ../../../arch/x86/x86_64/fsgs.rst:185
msgid "Variable is addressed relative to GS"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:153
msgid ""
"The preprocessor symbols __SEG_FS and __SEG_GS are defined when these "
"address spaces are supported. Code which implements fallback modes should "
"check whether these symbols are defined. Usage example::"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:180
msgid ""
"Clang does not provide the GCC address space identifiers, but it provides "
"address spaces via an attribute based mechanism in Clang 2.6 and newer "
"versions:"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:185
msgid "__attribute__((address_space(256))"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:186
msgid "__attribute__((address_space(257))"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:190
msgid "FS/GS based addressing with inline assembly"
msgstr ""

#: ../../../arch/x86/x86_64/fsgs.rst:192
msgid ""
"In case the compiler does not support address spaces, inline assembly can be "
"used for FS/GS based addressing mode::"
msgstr ""
