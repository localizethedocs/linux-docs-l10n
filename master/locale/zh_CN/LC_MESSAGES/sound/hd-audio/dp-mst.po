# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../sound/hd-audio/dp-mst.rst:3
msgid "HD-Audio DP-MST Support"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:5
msgid ""
"To support DP MST audio, HD Audio hdmi codec driver introduces virtual pin "
"and dynamic pcm assignment."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:8
msgid ""
"Virtual pin is an extension of per_pin. The most difference of DP MST from "
"legacy is that DP MST introduces device entry. Each pin can contain several "
"device entries. Each device entry behaves as a pin."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:12
msgid ""
"As each pin may contain several device entries and each codec may contain "
"several pins, if we use one pcm per per_pin, there will be many PCMs. The "
"new solution is to create a few PCMs and to dynamically bind pcm to per_pin. "
"Driver uses spec->dyn_pcm_assign flag to indicate whether to use the new "
"solution."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:19
msgid "PCM"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:20
msgid "To be added"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:23
msgid "Pin Initialization"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:24
msgid ""
"Each pin may have several device entries (virtual pins). On Intel platform, "
"the device entries number is dynamically changed. If DP MST hub is "
"connected, it is in DP MST mode, and the device entries number is 3. "
"Otherwise, the device entries number is 1."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:29
msgid ""
"To simplify the implementation, all the device entries will be initialized "
"when bootup no matter whether it is in DP MST mode or not."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:33
msgid "Connection list"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:34
msgid ""
"DP MST reuses connection list code. The code can be reused because device "
"entries on the same pin have the same connection list."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:37
msgid ""
"This means DP MST gets the device entry connection list without the device "
"entry setting."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:41
msgid "Jack"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:43
msgid "Presume:"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:44
msgid "MST must be dyn_pcm_assign, and it is acomp (for Intel scenario);"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:45
msgid "NON-MST may or may not be dyn_pcm_assign, it can be acomp or !acomp;"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:47
msgid "So there are the following scenarios:"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:48
msgid "MST (&& dyn_pcm_assign && acomp)"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:49
msgid "NON-MST && dyn_pcm_assign && acomp"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:50
msgid "NON-MST && !dyn_pcm_assign && !acomp"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:52
msgid ""
"Below discussion will ignore MST and NON-MST difference as it doesn't impact "
"on jack handling too much."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:55
msgid ""
"Driver uses struct hdmi_pcm pcm[] array in hdmi_spec and snd_jack is a "
"member of hdmi_pcm. Each pin has one struct hdmi_pcm * pcm pointer."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:58
msgid ""
"For !dyn_pcm_assign, per_pin->pcm will assigned to spec->pcm[n] statically."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:60
msgid ""
"For dyn_pcm_assign, per_pin->pcm will assigned to spec->pcm[n] when monitor "
"is hotplugged."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:65
msgid "Build Jack"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:67
msgid "dyn_pcm_assign"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:69
msgid ""
"Will not use hda_jack but use snd_jack in spec->pcm_rec[pcm_idx].jack "
"directly."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:71
msgid "!dyn_pcm_assign"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:73
msgid ""
"Use hda_jack and assign spec->pcm_rec[pcm_idx].jack = jack->jack statically."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:77
msgid "Unsolicited Event Enabling"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:78
msgid "Enable unsolicited event if !acomp."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:82
msgid "Monitor Hotplug Event Handling"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:83
msgid "acomp"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:85
msgid ""
"pin_eld_notify() -> check_presence_and_report() -> hdmi_present_sense() -> "
"sync_eld_via_acomp()."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:88
msgid ""
"Use directly snd_jack_report() on spec->pcm_rec[pcm_idx].jack for both "
"dyn_pcm_assign and !dyn_pcm_assign"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:91
msgid "!acomp"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:93
msgid ""
"hdmi_unsol_event() -> hdmi_intrinsic_event() -> check_presence_and_report() -"
"> hdmi_present_sense() -> hdmi_prepsent_sense_via_verbs()"
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:96
msgid ""
"Use directly snd_jack_report() on spec->pcm_rec[pcm_idx].jack for "
"dyn_pcm_assign. Use hda_jack mechanism to handle jack events."
msgstr ""

#: ../../../sound/hd-audio/dp-mst.rst:101
msgid "Others to be added later"
msgstr ""
