# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/can.rst:3
msgid "SocketCAN - Controller Area Network"
msgstr ""

#: ../../../networking/can.rst:6
msgid "Overview / What is SocketCAN"
msgstr ""

#: ../../../networking/can.rst:8
msgid ""
"The socketcan package is an implementation of CAN protocols (Controller Area "
"Network) for Linux.  CAN is a networking technology which has widespread use "
"in automation, embedded devices, and automotive fields.  While there have "
"been other CAN implementations for Linux based on character devices, "
"SocketCAN uses the Berkeley socket API, the Linux network stack and "
"implements the CAN device drivers as network interfaces.  The CAN socket API "
"has been designed as similar as possible to the TCP/IP protocols to allow "
"programmers, familiar with network programming, to easily learn how to use "
"CAN sockets."
msgstr ""

#: ../../../networking/can.rst:23
msgid "Motivation / Why Using the Socket API"
msgstr ""

#: ../../../networking/can.rst:25
msgid ""
"There have been CAN implementations for Linux before SocketCAN so the "
"question arises, why we have started another project.  Most existing "
"implementations come as a device driver for some CAN hardware, they are "
"based on character devices and provide comparatively little functionality.  "
"Usually, there is only a hardware-specific device driver which provides a "
"character device interface to send and receive raw CAN frames, directly to/"
"from the controller hardware. Queueing of frames and higher-level transport "
"protocols like ISO-TP have to be implemented in user space applications.  "
"Also, most character-device implementations support only one single process "
"to open the device at a time, similar to a serial interface.  Exchanging the "
"CAN controller requires employment of another device driver and often the "
"need for adaption of large parts of the application to the new driver's API."
msgstr ""

#: ../../../networking/can.rst:40
msgid ""
"SocketCAN was designed to overcome all of these limitations.  A new protocol "
"family has been implemented which provides a socket interface to user space "
"applications and which builds upon the Linux network layer, enabling use all "
"of the provided queueing functionality.  A device driver for CAN controller "
"hardware registers itself with the Linux network layer as a network device, "
"so that CAN frames from the controller can be passed up to the network layer "
"and on to the CAN protocol family module and also vice-versa.  Also, the "
"protocol family module provides an API for transport protocol modules to "
"register, so that any number of transport protocols can be loaded or "
"unloaded dynamically.  In fact, the can core module alone does not provide "
"any protocol and cannot be used without loading at least one additional "
"protocol module.  Multiple sockets can be opened at the same time, on "
"different or the same protocol module and they can listen/send frames on "
"different or the same CAN IDs.  Several sockets listening on the same "
"interface for frames with the same CAN ID are all passed the same received "
"matching CAN frames.  An application wishing to communicate using a specific "
"transport protocol, e.g. ISO-TP, just selects that protocol when opening the "
"socket, and then can read and write application data byte streams, without "
"having to deal with CAN-IDs, frames, etc."
msgstr ""

#: ../../../networking/can.rst:62
msgid ""
"Similar functionality visible from user-space could be provided by a "
"character device, too, but this would lead to a technically inelegant "
"solution for a couple of reasons:"
msgstr ""

#: ../../../networking/can.rst:66
msgid ""
"**Intricate usage:**  Instead of passing a protocol argument to socket(2) "
"and using bind(2) to select a CAN interface and CAN ID, an application would "
"have to do all these operations using ioctl(2)s."
msgstr ""

#: ../../../networking/can.rst:70
msgid ""
"**Code duplication:**  A character device cannot make use of the Linux "
"network queueing code, so all that code would have to be duplicated for CAN "
"networking."
msgstr ""

#: ../../../networking/can.rst:74
msgid ""
"**Abstraction:**  In most existing character-device implementations, the "
"hardware-specific device driver for a CAN controller directly provides the "
"character device for the application to work with. This is at least very "
"unusual in Unix systems for both, char and block devices.  For example you "
"don't have a character device for a certain UART of a serial interface, a "
"certain sound chip in your computer, a SCSI or IDE controller providing "
"access to your hard disk or tape streamer device.  Instead, you have "
"abstraction layers which provide a unified character or block device "
"interface to the application on the one hand, and a interface for hardware-"
"specific device drivers on the other hand.  These abstractions are provided "
"by subsystems like the tty layer, the audio subsystem or the SCSI and IDE "
"subsystems for the devices mentioned above."
msgstr ""

#: ../../../networking/can.rst:88
msgid ""
"The easiest way to implement a CAN device driver is as a character device "
"without such a (complete) abstraction layer, as is done by most existing "
"drivers.  The right way, however, would be to add such a layer with all the "
"functionality like registering for certain CAN IDs, supporting several open "
"file descriptors and (de)multiplexing CAN frames between them, "
"(sophisticated) queueing of CAN frames, and providing an API for device "
"drivers to register with.  However, then it would be no more difficult, or "
"may be even easier, to use the networking framework provided by the Linux "
"kernel, and this is what SocketCAN does."
msgstr ""

#: ../../../networking/can.rst:99
msgid ""
"The use of the networking framework of the Linux kernel is just the natural "
"and most appropriate way to implement CAN for Linux."
msgstr ""

#: ../../../networking/can.rst:106
msgid "SocketCAN Concept"
msgstr ""

#: ../../../networking/can.rst:108
msgid ""
"As described in :ref:`socketcan-motivation` the main goal of SocketCAN is to "
"provide a socket interface to user space applications which builds upon the "
"Linux network layer. In contrast to the commonly known TCP/IP and ethernet "
"networking, the CAN bus is a broadcast-only(!) medium that has no MAC-layer "
"addressing like ethernet. The CAN-identifier (can_id) is used for "
"arbitration on the CAN-bus. Therefore the CAN-IDs have to be chosen uniquely "
"on the bus. When designing a CAN-ECU network the CAN-IDs are mapped to be "
"sent by a specific ECU. For this reason a CAN-ID can be treated best as a "
"kind of source address."
msgstr ""

#: ../../../networking/can.rst:122
msgid "Receive Lists"
msgstr ""

#: ../../../networking/can.rst:124
msgid ""
"The network transparent access of multiple applications leads to the problem "
"that different applications may be interested in the same CAN-IDs from the "
"same CAN network interface. The SocketCAN core module - which implements the "
"protocol family CAN - provides several high efficient receive lists for this "
"reason. If e.g. a user space application opens a CAN RAW socket, the raw "
"protocol module itself requests the (range of) CAN-IDs from the SocketCAN "
"core that are requested by the user. The subscription and unsubscription of "
"CAN-IDs can be done for specific CAN interfaces or for all(!) known CAN "
"interfaces with the can_rx_(un)register() functions provided to CAN protocol "
"modules by the SocketCAN core (see :ref:`socketcan-core-module`). To "
"optimize the CPU usage at runtime the receive lists are split up into "
"several specific lists per device that match the requested filter complexity "
"for a given use-case."
msgstr ""

#: ../../../networking/can.rst:143 ../../../networking/can.rst:1121
msgid "Local Loopback of Sent Frames"
msgstr ""

#: ../../../networking/can.rst:145
msgid ""
"As known from other networking concepts the data exchanging applications may "
"run on the same or different nodes without any change (except for the "
"according addressing information):"
msgstr ""

#: ../../../networking/can.rst:158
msgid ""
"To ensure that application A receives the same information in the example "
"(2) as it would receive in example (1) there is need for some kind of local "
"loopback of the sent CAN frames on the appropriate node."
msgstr ""

#: ../../../networking/can.rst:163
msgid ""
"The Linux network devices (by default) just can handle the transmission and "
"reception of media dependent frames. Due to the arbitration on the CAN bus "
"the transmission of a low prio CAN-ID may be delayed by the reception of a "
"high prio CAN frame. To reflect the correct [#f1]_ traffic on the node the "
"loopback of the sent data has to be performed right after a successful "
"transmission. If the CAN network interface is not capable of performing the "
"loopback for some reason the SocketCAN core can do this task as a fallback "
"solution. See :ref:`socketcan-local-loopback2` for details (recommended)."
msgstr ""

#: ../../../networking/can.rst:173
msgid ""
"The loopback functionality is enabled by default to reflect standard "
"networking behaviour for CAN applications. Due to some requests from the RT-"
"SocketCAN group the loopback optionally may be disabled for each separate "
"socket. See sockopts from the CAN RAW sockets in :ref:`socketcan-raw-"
"sockets`."
msgstr ""

#: ../../../networking/can.rst:178
msgid ""
"you really like to have this when you're running analyser tools like "
"'candump' or 'cansniffer' on the (same) node."
msgstr ""

#: ../../../networking/can.rst:185
msgid "Network Problem Notifications"
msgstr ""

#: ../../../networking/can.rst:187
msgid ""
"The use of the CAN bus may lead to several problems on the physical and "
"media access control layer. Detecting and logging of these lower layer "
"problems is a vital requirement for CAN users to identify hardware issues on "
"the physical transceiver layer as well as arbitration problems and error "
"frames caused by the different ECUs. The occurrence of detected errors are "
"important for diagnosis and have to be logged together with the exact "
"timestamp. For this reason the CAN interface driver can generate so called "
"Error Message Frames that can optionally be passed to the user application "
"in the same way as other CAN frames. Whenever an error on the physical layer "
"or the MAC layer is detected (e.g. by the CAN controller) the driver creates "
"an appropriate error message frame. Error messages frames can be requested "
"by the user application using the common CAN filter mechanisms. Inside this "
"filter definition the (interested) type of errors may be selected. The "
"reception of error messages is disabled by default. The format of the CAN "
"error message frame is briefly described in the Linux header file \"include/"
"uapi/linux/can/error.h\"."
msgstr ""

#: ../../../networking/can.rst:207
msgid "How to use SocketCAN"
msgstr ""

#: ../../../networking/can.rst:209
msgid ""
"Like TCP/IP, you first need to open a socket for communicating over a CAN "
"network. Since SocketCAN implements a new protocol family, you need to pass "
"PF_CAN as the first argument to the socket(2) system call. Currently, there "
"are two CAN protocols to choose from, the raw socket protocol and the "
"broadcast manager (BCM). So to open a socket, you would write::"
msgstr ""

#: ../../../networking/can.rst:218
msgid "and::"
msgstr ""

#: ../../../networking/can.rst:222
msgid ""
"respectively.  After the successful creation of the socket, you would "
"normally use the bind(2) system call to bind the socket to a CAN interface "
"(which is different from TCP/IP due to different addressing - see :ref:"
"`socketcan-concept`). After binding (CAN_RAW) or connecting (CAN_BCM) the "
"socket, you can read(2) and write(2) from/to the socket or use send(2), "
"sendto(2), sendmsg(2) and the recv* counterpart operations on the socket as "
"usual. There are also CAN specific socket options described below."
msgstr ""

#: ../../../networking/can.rst:231
msgid ""
"The Classical CAN frame structure (aka CAN 2.0B), the CAN FD frame structure "
"and the sockaddr structure are defined in include/linux/can.h:"
msgstr ""

#: ../../../networking/can.rst:252
msgid ""
"Remark: The len element contains the payload length in bytes and should be "
"used instead of can_dlc. The deprecated can_dlc was misleadingly named as it "
"always contained the plain payload length in bytes and not the so called "
"'data length code' (DLC)."
msgstr ""

#: ../../../networking/can.rst:257
msgid ""
"To pass the raw DLC from/to a Classical CAN network device the len8_dlc "
"element can contain values 9 .. 15 when the len element is 8 (the real "
"payload length for all DLC values greater or equal to 8)."
msgstr ""

#: ../../../networking/can.rst:261
msgid ""
"The alignment of the (linear) payload data[] to a 64bit boundary allows the "
"user to define their own structs and unions to easily access the CAN "
"payload. There is no given byteorder on the CAN bus by default. A read(2) "
"system call on a CAN_RAW socket transfers a struct can_frame to the user "
"space."
msgstr ""

#: ../../../networking/can.rst:267
msgid ""
"The sockaddr_can structure has an interface index like the PF_PACKET socket, "
"that also binds to a specific interface:"
msgstr ""

#: ../../../networking/can.rst:300
msgid ""
"To determine the interface index an appropriate ioctl() has to be used "
"(example for CAN_RAW sockets without error checking):"
msgstr ""

#: ../../../networking/can.rst:321
msgid ""
"To bind a socket to all(!) CAN interfaces the interface index must be 0 "
"(zero). In this case the socket receives CAN frames from every enabled CAN "
"interface. To determine the originating CAN interface the system call "
"recvfrom(2) may be used instead of read(2). To send on a socket that is "
"bound to 'any' interface sendto(2) is needed to specify the outgoing "
"interface."
msgstr ""

#: ../../../networking/can.rst:328
msgid ""
"Reading CAN frames from a bound CAN_RAW socket (see above) consists of "
"reading a struct can_frame:"
msgstr ""

#: ../../../networking/can.rst:350
msgid ""
"Writing CAN frames can be done similarly, with the write(2) system call::"
msgstr ""

#: ../../../networking/can.rst:354
msgid ""
"When the CAN interface is bound to 'any' existing CAN interface (addr."
"can_ifindex = 0) it is recommended to use recvfrom(2) if the information "
"about the originating CAN interface is needed:"
msgstr ""

#: ../../../networking/can.rst:373
msgid ""
"To write CAN frames on sockets bound to 'any' CAN interface the outgoing "
"interface has to be defined certainly:"
msgstr ""

#: ../../../networking/can.rst:386
msgid ""
"An accurate timestamp can be obtained with an ioctl(2) call after reading a "
"message from the socket:"
msgstr ""

#: ../../../networking/can.rst:394
msgid ""
"The timestamp has a resolution of one microsecond and is set automatically "
"at the reception of a CAN frame."
msgstr ""

#: ../../../networking/can.rst:397
msgid "Remark about CAN FD (flexible data rate) support:"
msgstr ""

#: ../../../networking/can.rst:399
msgid ""
"Generally the handling of CAN FD is very similar to the formerly described "
"examples. The new CAN FD capable CAN controllers support two different "
"bitrates for the arbitration phase and the payload phase of the CAN FD frame "
"and up to 64 bytes of payload. This extended payload length breaks all the "
"kernel interfaces (ABI) which heavily rely on the CAN frame with fixed eight "
"bytes of payload (struct can_frame) like the CAN_RAW socket. Therefore e.g. "
"the CAN_RAW socket supports a new socket option CAN_RAW_FD_FRAMES that "
"switches the socket into a mode that allows the handling of CAN FD frames "
"and Classical CAN frames simultaneously (see :ref:`socketcan-rawfd`)."
msgstr ""

#: ../../../networking/can.rst:409
msgid "The struct canfd_frame is defined in include/linux/can.h:"
msgstr ""

#: ../../../networking/can.rst:422
msgid ""
"The struct canfd_frame and the existing struct can_frame have the can_id, "
"the payload length and the payload data at the same offset inside their "
"structures. This allows to handle the different structures very similar. "
"When the content of a struct can_frame is copied into a struct canfd_frame "
"all structure elements can be used as-is - only the data[] becomes extended."
msgstr ""

#: ../../../networking/can.rst:428
msgid ""
"When introducing the struct canfd_frame it turned out that the data length "
"code (DLC) of the struct can_frame was used as a length information as the "
"length and the DLC has a 1:1 mapping in the range of 0 .. 8. To preserve the "
"easy handling of the length information the canfd_frame.len element contains "
"a plain length value from 0 .. 64. So both canfd_frame.len and can_frame.len "
"are equal and contain a length information and no DLC. For details about the "
"distinction of CAN and CAN FD capable devices and the mapping to the bus-"
"relevant data length code (DLC), see :ref:`socketcan-can-fd-driver`."
msgstr ""

#: ../../../networking/can.rst:437
msgid ""
"The length of the two CAN(FD) frame structures define the maximum transfer "
"unit (MTU) of the CAN(FD) network interface and skbuff data length. Two "
"definitions are specified for CAN specific MTUs in include/linux/can.h:"
msgstr ""

#: ../../../networking/can.rst:448
msgid "Returned Message Flags"
msgstr ""

#: ../../../networking/can.rst:450
msgid ""
"When using the system call recvmsg(2) on a RAW or a BCM socket, the msg-"
">msg_flags field may contain the following flags:"
msgstr ""

#: ../../../networking/can.rst:453
msgid "MSG_DONTROUTE:"
msgstr ""

#: ../../../networking/can.rst:454
msgid "set when the received frame was created on the local host."
msgstr ""

#: ../../../networking/can.rst:456
msgid "MSG_CONFIRM:"
msgstr ""

#: ../../../networking/can.rst:457
msgid ""
"set when the frame was sent via the socket it is received on. This flag can "
"be interpreted as a 'transmission confirmation' when the CAN driver supports "
"the echo of frames on driver level, see :ref:`socketcan-local-loopback1` "
"and :ref:`socketcan-local-loopback2`. (Note: In order to receive such "
"messages on a RAW socket, CAN_RAW_RECV_OWN_MSGS must be set.)"
msgstr ""

#: ../../../networking/can.rst:468
msgid "RAW Protocol Sockets with can_filters (SOCK_RAW)"
msgstr ""

#: ../../../networking/can.rst:470
msgid ""
"Using CAN_RAW sockets is extensively comparable to the commonly known access "
"to CAN character devices. To meet the new possibilities provided by the "
"multi user SocketCAN approach, some reasonable defaults are set at RAW "
"socket binding time:"
msgstr ""

#: ../../../networking/can.rst:475
msgid "The filters are set to exactly one filter receiving everything"
msgstr ""

#: ../../../networking/can.rst:476
msgid "The socket only receives valid data frames (=> no error message frames)"
msgstr ""

#: ../../../networking/can.rst:477
msgid ""
"The loopback of sent CAN frames is enabled (see :ref:`socketcan-local-"
"loopback2`)"
msgstr ""

#: ../../../networking/can.rst:478
msgid "The socket does not receive its own sent frames (in loopback mode)"
msgstr ""

#: ../../../networking/can.rst:480
msgid ""
"These default settings may be changed before or after binding the socket. To "
"use the referenced definitions of the socket options for CAN_RAW sockets, "
"include <linux/can/raw.h>."
msgstr ""

#: ../../../networking/can.rst:488
msgid "RAW socket option CAN_RAW_FILTER"
msgstr ""

#: ../../../networking/can.rst:490
msgid ""
"The reception of CAN frames using CAN_RAW sockets can be controlled by "
"defining 0 .. n filters with the CAN_RAW_FILTER socket option."
msgstr ""

#: ../../../networking/can.rst:493
msgid "The CAN filter structure is defined in include/linux/can.h:"
msgstr ""

#: ../../../networking/can.rst:502
msgid "A filter matches, when:"
msgstr ""

#: ../../../networking/can.rst:508
msgid ""
"which is analogous to known CAN controllers hardware filter semantics. The "
"filter can be inverted in this semantic, when the CAN_INV_FILTER bit is set "
"in can_id element of the can_filter structure. In contrast to CAN controller "
"hardware filters the user may set 0 .. n receive filters for each open "
"socket separately:"
msgstr ""

#: ../../../networking/can.rst:525
msgid "To disable the reception of CAN frames on the selected CAN_RAW socket:"
msgstr ""

#: ../../../networking/can.rst:531
msgid ""
"To set the filters to zero filters is quite obsolete as to not read data "
"causes the raw socket to discard the received CAN frames. But having this "
"'send only' use-case we may remove the receive list in the Kernel to save a "
"little (really a very little!) CPU usage."
msgstr ""

#: ../../../networking/can.rst:537
msgid "CAN Filter Usage Optimisation"
msgstr ""

#: ../../../networking/can.rst:539
msgid ""
"The CAN filters are processed in per-device filter lists at CAN frame "
"reception time. To reduce the number of checks that need to be performed "
"while walking through the filter lists the CAN core provides an optimized "
"filter handling when the filter subscription focusses on a single CAN ID."
msgstr ""

#: ../../../networking/can.rst:544
msgid ""
"For the possible 2048 SFF CAN identifiers the identifier is used as an index "
"to access the corresponding subscription list without any further checks. "
"For the 2^29 possible EFF CAN identifiers a 10 bit XOR folding is used as "
"hash function to retrieve the EFF table index."
msgstr ""

#: ../../../networking/can.rst:549
msgid ""
"To benefit from the optimized filters for single CAN identifiers the "
"CAN_SFF_MASK or CAN_EFF_MASK have to be set into can_filter.mask together "
"with set CAN_EFF_FLAG and CAN_RTR_FLAG bits. A set CAN_EFF_FLAG bit in the "
"can_filter.mask makes clear that it matters whether a SFF or EFF CAN ID is "
"subscribed. E.g. in the example from above:"
msgstr ""

#: ../../../networking/can.rst:560
msgid ""
"both SFF frames with CAN ID 0x123 and EFF frames with 0xXXXXX123 can pass."
msgstr ""

#: ../../../networking/can.rst:562
msgid ""
"To filter for only 0x123 (SFF) and 0x12345678 (EFF) CAN identifiers the "
"filter has to be defined in this way to benefit from the optimized filters:"
msgstr ""

#: ../../../networking/can.rst:578
msgid "RAW Socket Option CAN_RAW_ERR_FILTER"
msgstr ""

#: ../../../networking/can.rst:580
msgid ""
"As described in :ref:`socketcan-network-problem-notifications` the CAN "
"interface driver can generate so called Error Message Frames that can "
"optionally be passed to the user application in the same way as other CAN "
"frames. The possible errors are divided into different error classes that "
"may be filtered using the appropriate error mask. To register for every "
"possible error condition CAN_ERR_MASK can be used as value for the error "
"mask. The values for the error mask are defined in linux/can/error.h:"
msgstr ""

#: ../../../networking/can.rst:597
msgid "RAW Socket Option CAN_RAW_LOOPBACK"
msgstr ""

#: ../../../networking/can.rst:599
msgid ""
"To meet multi user needs the local loopback is enabled by default (see :ref:"
"`socketcan-local-loopback1` for details). But in some embedded use-cases (e."
"g. when only one application uses the CAN bus) this loopback functionality "
"can be disabled (separately for each socket):"
msgstr ""

#: ../../../networking/can.rst:612
msgid "RAW socket option CAN_RAW_RECV_OWN_MSGS"
msgstr ""

#: ../../../networking/can.rst:614
msgid ""
"When the local loopback is enabled, all the sent CAN frames are looped back "
"to the open CAN sockets that registered for the CAN frames' CAN-ID on this "
"given interface to meet the multi user needs. The reception of the CAN "
"frames on the same socket that was sending the CAN frame is assumed to be "
"unwanted and therefore disabled by default. This default behaviour may be "
"changed on demand:"
msgstr ""

#: ../../../networking/can.rst:629
msgid ""
"Note that reception of a socket's own CAN frames are subject to the same "
"filtering as other CAN frames (see :ref:`socketcan-rawfilter`)."
msgstr ""

#: ../../../networking/can.rst:635
msgid "RAW Socket Option CAN_RAW_FD_FRAMES"
msgstr ""

#: ../../../networking/can.rst:637
msgid ""
"CAN FD support in CAN_RAW sockets can be enabled with a new socket option "
"CAN_RAW_FD_FRAMES which is off by default. When the new socket option is not "
"supported by the CAN_RAW socket (e.g. on older kernels), switching the "
"CAN_RAW_FD_FRAMES option returns the error -ENOPROTOOPT."
msgstr ""

#: ../../../networking/can.rst:642
msgid ""
"Once CAN_RAW_FD_FRAMES is enabled the application can send both CAN frames "
"and CAN FD frames. OTOH the application has to handle CAN and CAN FD frames "
"when reading from the socket:"
msgstr ""

#: ../../../networking/can.rst:651
msgid "Example:"
msgstr ""

#: ../../../networking/can.rst:678
msgid ""
"When reading with size CANFD_MTU only returns CAN_MTU bytes that have been "
"received from the socket a Classical CAN frame has been read into the "
"provided CAN FD structure. Note that the canfd_frame.flags data field is not "
"specified in the struct can_frame and therefore it is only valid in "
"CANFD_MTU sized CAN FD frames."
msgstr ""

#: ../../../networking/can.rst:684
msgid "Implementation hint for new CAN applications:"
msgstr ""

#: ../../../networking/can.rst:686
msgid ""
"To build a CAN FD aware application use struct canfd_frame as basic CAN data "
"structure for CAN_RAW based applications. When the application is executed "
"on an older Linux kernel and switching the CAN_RAW_FD_FRAMES socket option "
"returns an error: No problem. You'll get Classical CAN frames or CAN FD "
"frames and can process them the same way."
msgstr ""

#: ../../../networking/can.rst:692
msgid ""
"When sending to CAN devices make sure that the device is capable to handle "
"CAN FD frames by checking if the device maximum transfer unit is CANFD_MTU. "
"The CAN device MTU can be retrieved e.g. with a SIOCGIFMTU ioctl() syscall."
msgstr ""

#: ../../../networking/can.rst:698
msgid "RAW socket option CAN_RAW_JOIN_FILTERS"
msgstr ""

#: ../../../networking/can.rst:700
msgid ""
"The CAN_RAW socket can set multiple CAN identifier specific filters that "
"lead to multiple filters in the af_can.c filter processing. These filters "
"are independent from each other which leads to logical OR'ed filters when "
"applied (see :ref:`socketcan-rawfilter`)."
msgstr ""

#: ../../../networking/can.rst:705
msgid ""
"This socket option joins the given CAN filters in the way that only CAN "
"frames are passed to user space that matched *all* given CAN filters. The "
"semantic for the applied filters is therefore changed to a logical AND."
msgstr ""

#: ../../../networking/can.rst:709
msgid ""
"This is useful especially when the filterset is a combination of filters "
"where the CAN_INV_FILTER flag is set in order to notch single CAN IDs or CAN "
"ID ranges from the incoming traffic."
msgstr ""

#: ../../../networking/can.rst:715
msgid "Broadcast Manager Protocol Sockets (SOCK_DGRAM)"
msgstr ""

#: ../../../networking/can.rst:717
msgid ""
"The Broadcast Manager protocol provides a command based configuration "
"interface to filter and send (e.g. cyclic) CAN messages in kernel space."
msgstr ""

#: ../../../networking/can.rst:720
msgid ""
"Receive filters can be used to down sample frequent messages; detect events "
"such as message contents changes, packet length changes, and do time-out "
"monitoring of received messages."
msgstr ""

#: ../../../networking/can.rst:724
msgid ""
"Periodic transmission tasks of CAN frames or a sequence of CAN frames can be "
"created and modified at runtime; both the message content and the two "
"possible transmit intervals can be altered."
msgstr ""

#: ../../../networking/can.rst:728
msgid ""
"A BCM socket is not intended for sending individual CAN frames using the "
"struct can_frame as known from the CAN_RAW socket. Instead a special BCM "
"configuration message is defined. The basic BCM configuration message used "
"to communicate with the broadcast manager and the available operations are "
"defined in the linux/can/bcm.h include. The BCM message consists of a "
"message header with a command ('opcode') followed by zero or more CAN "
"frames. The broadcast manager sends responses to user space in the same form:"
msgstr ""

#: ../../../networking/can.rst:748
msgid ""
"The aligned payload 'frames' uses the same basic CAN frame structure defined "
"at the beginning of :ref:`socketcan-rawfd` and in the include/linux/can.h "
"include. All messages to the broadcast manager from user space have this "
"structure."
msgstr ""

#: ../../../networking/can.rst:752
msgid ""
"Note a CAN_BCM socket must be connected instead of bound after socket "
"creation (example without error checking):"
msgstr ""

#: ../../../networking/can.rst:773
msgid ""
"The broadcast manager socket is able to handle any number of in flight "
"transmissions or receive filters concurrently. The different RX/TX jobs are "
"distinguished by the unique can_id in each BCM message. However additional "
"CAN_BCM sockets are recommended to communicate on multiple CAN interfaces. "
"When the broadcast manager socket is bound to 'any' CAN interface (=> the "
"interface index is set to zero) the configured receive filters apply to any "
"CAN interface unless the sendto() syscall is used to overrule the 'any' CAN "
"interface index. When using recvfrom() instead of read() to retrieve BCM "
"socket messages the originating CAN interface is provided in can_ifindex."
msgstr ""

#: ../../../networking/can.rst:785
msgid "Broadcast Manager Operations"
msgstr ""

#: ../../../networking/can.rst:787
msgid ""
"The opcode defines the operation for the broadcast manager to carry out, or "
"details the broadcast managers response to several events, including user "
"requests."
msgstr ""

#: ../../../networking/can.rst:791
msgid "Transmit Operations (user space to broadcast manager):"
msgstr ""

#: ../../../networking/can.rst:793
msgid "TX_SETUP:"
msgstr ""

#: ../../../networking/can.rst:794
msgid "Create (cyclic) transmission task."
msgstr ""

#: ../../../networking/can.rst:796
msgid "TX_DELETE:"
msgstr ""

#: ../../../networking/can.rst:797
msgid "Remove (cyclic) transmission task, requires only can_id."
msgstr ""

#: ../../../networking/can.rst:799
msgid "TX_READ:"
msgstr ""

#: ../../../networking/can.rst:800
msgid "Read properties of (cyclic) transmission task for can_id."
msgstr ""

#: ../../../networking/can.rst:802
msgid "TX_SEND:"
msgstr ""

#: ../../../networking/can.rst:803
msgid "Send one CAN frame."
msgstr ""

#: ../../../networking/can.rst:805
msgid "Transmit Responses (broadcast manager to user space):"
msgstr ""

#: ../../../networking/can.rst:807
msgid "TX_STATUS:"
msgstr ""

#: ../../../networking/can.rst:808
msgid "Reply to TX_READ request (transmission task configuration)."
msgstr ""

#: ../../../networking/can.rst:810
msgid "TX_EXPIRED:"
msgstr ""

#: ../../../networking/can.rst:811
msgid ""
"Notification when counter finishes sending at initial interval 'ival1'. "
"Requires the TX_COUNTEVT flag to be set at TX_SETUP."
msgstr ""

#: ../../../networking/can.rst:814
msgid "Receive Operations (user space to broadcast manager):"
msgstr ""

#: ../../../networking/can.rst:816
msgid "RX_SETUP:"
msgstr ""

#: ../../../networking/can.rst:817
msgid "Create RX content filter subscription."
msgstr ""

#: ../../../networking/can.rst:819
msgid "RX_DELETE:"
msgstr ""

#: ../../../networking/can.rst:820
msgid "Remove RX content filter subscription, requires only can_id."
msgstr ""

#: ../../../networking/can.rst:822
msgid "RX_READ:"
msgstr ""

#: ../../../networking/can.rst:823
msgid "Read properties of RX content filter subscription for can_id."
msgstr ""

#: ../../../networking/can.rst:825
msgid "Receive Responses (broadcast manager to user space):"
msgstr ""

#: ../../../networking/can.rst:827
msgid "RX_STATUS:"
msgstr ""

#: ../../../networking/can.rst:828
msgid "Reply to RX_READ request (filter task configuration)."
msgstr ""

#: ../../../networking/can.rst:830
msgid "RX_TIMEOUT:"
msgstr ""

#: ../../../networking/can.rst:831
msgid "Cyclic message is detected to be absent (timer ival1 expired)."
msgstr ""

#: ../../../networking/can.rst:833
msgid "RX_CHANGED:"
msgstr ""

#: ../../../networking/can.rst:834
msgid ""
"BCM message with updated CAN frame (detected content change). Sent on first "
"message received or on receipt of revised CAN messages."
msgstr ""

#: ../../../networking/can.rst:839
msgid "Broadcast Manager Message Flags"
msgstr ""

#: ../../../networking/can.rst:841
msgid ""
"When sending a message to the broadcast manager the 'flags' element may "
"contain the following flag definitions which influence the behaviour:"
msgstr ""

#: ../../../networking/can.rst:844
msgid "SETTIMER:"
msgstr ""

#: ../../../networking/can.rst:845
msgid "Set the values of ival1, ival2 and count"
msgstr ""

#: ../../../networking/can.rst:847
msgid "STARTTIMER:"
msgstr ""

#: ../../../networking/can.rst:848
msgid ""
"Start the timer with the actual values of ival1, ival2 and count. Starting "
"the timer leads simultaneously to emit a CAN frame."
msgstr ""

#: ../../../networking/can.rst:851
msgid "TX_COUNTEVT:"
msgstr ""

#: ../../../networking/can.rst:852
msgid "Create the message TX_EXPIRED when count expires"
msgstr ""

#: ../../../networking/can.rst:854
msgid "TX_ANNOUNCE:"
msgstr ""

#: ../../../networking/can.rst:855
msgid "A change of data by the process is emitted immediately."
msgstr ""

#: ../../../networking/can.rst:857
msgid "TX_CP_CAN_ID:"
msgstr ""

#: ../../../networking/can.rst:858
msgid ""
"Copies the can_id from the message header to each subsequent frame in "
"frames. This is intended as usage simplification. For TX tasks the unique "
"can_id from the message header may differ from the can_id(s) stored for "
"transmission in the subsequent struct can_frame(s)."
msgstr ""

#: ../../../networking/can.rst:863
msgid "RX_FILTER_ID:"
msgstr ""

#: ../../../networking/can.rst:864
msgid "Filter by can_id alone, no frames required (nframes=0)."
msgstr ""

#: ../../../networking/can.rst:866
msgid "RX_CHECK_DLC:"
msgstr ""

#: ../../../networking/can.rst:867
msgid "A change of the DLC leads to an RX_CHANGED."
msgstr ""

#: ../../../networking/can.rst:869
msgid "RX_NO_AUTOTIMER:"
msgstr ""

#: ../../../networking/can.rst:870
msgid "Prevent automatically starting the timeout monitor."
msgstr ""

#: ../../../networking/can.rst:872
msgid "RX_ANNOUNCE_RESUME:"
msgstr ""

#: ../../../networking/can.rst:873
msgid ""
"If passed at RX_SETUP and a receive timeout occurred, a RX_CHANGED message "
"will be generated when the (cyclic) receive restarts."
msgstr ""

#: ../../../networking/can.rst:876
msgid "TX_RESET_MULTI_IDX:"
msgstr ""

#: ../../../networking/can.rst:877
msgid "Reset the index for the multiple frame transmission."
msgstr ""

#: ../../../networking/can.rst:879
msgid "RX_RTR_FRAME:"
msgstr ""

#: ../../../networking/can.rst:880
msgid "Send reply for RTR-request (placed in op->frames[0])."
msgstr ""

#: ../../../networking/can.rst:882
msgid "CAN_FD_FRAME:"
msgstr ""

#: ../../../networking/can.rst:883
msgid "The CAN frames following the bcm_msg_head are struct canfd_frame's"
msgstr ""

#: ../../../networking/can.rst:886
msgid "Broadcast Manager Transmission Timers"
msgstr ""

#: ../../../networking/can.rst:888
msgid ""
"Periodic transmission configurations may use up to two interval timers. In "
"this case the BCM sends a number of messages ('count') at an interval "
"'ival1', then continuing to send at another given interval 'ival2'. When "
"only one timer is needed 'count' is set to zero and only 'ival2' is used. "
"When SET_TIMER and START_TIMER flag were set the timers are activated. The "
"timer values can be altered at runtime when only SET_TIMER is set."
msgstr ""

#: ../../../networking/can.rst:897
msgid "Broadcast Manager message sequence transmission"
msgstr ""

#: ../../../networking/can.rst:899
msgid ""
"Up to 256 CAN frames can be transmitted in a sequence in the case of a "
"cyclic TX task configuration. The number of CAN frames is provided in the "
"'nframes' element of the BCM message head. The defined number of CAN frames "
"are added as array to the TX_SETUP BCM configuration message:"
msgstr ""

#: ../../../networking/can.rst:918
msgid ""
"With every transmission the index in the array of CAN frames is increased "
"and set to zero at index overflow."
msgstr ""

#: ../../../networking/can.rst:923
msgid "Broadcast Manager Receive Filter Timers"
msgstr ""

#: ../../../networking/can.rst:925
msgid ""
"The timer values ival1 or ival2 may be set to non-zero values at RX_SETUP. "
"When the SET_TIMER flag is set the timers are enabled:"
msgstr ""

#: ../../../networking/can.rst:928
msgid "ival1:"
msgstr ""

#: ../../../networking/can.rst:929
msgid ""
"Send RX_TIMEOUT when a received message is not received again within the "
"given time. When START_TIMER is set at RX_SETUP the timeout detection is "
"activated directly - even without a former CAN frame reception."
msgstr ""

#: ../../../networking/can.rst:933
msgid "ival2:"
msgstr ""

#: ../../../networking/can.rst:934
msgid ""
"Throttle the received message rate down to the value of ival2. This is "
"useful to reduce messages for the application when the signal inside the CAN "
"frame is stateless as state changes within the ival2 period may get lost."
msgstr ""

#: ../../../networking/can.rst:940
msgid "Broadcast Manager Multiplex Message Receive Filter"
msgstr ""

#: ../../../networking/can.rst:942
msgid ""
"To filter for content changes in multiplex message sequences an array of "
"more than one CAN frames can be passed in a RX_SETUP configuration message. "
"The data bytes of the first CAN frame contain the mask of relevant bits that "
"have to match in the subsequent CAN frames with the received CAN frame. If "
"one of the subsequent CAN frames is matching the bits in that frame data "
"mark the relevant content to be compared with the previous received content. "
"Up to 257 CAN frames (multiplex filter bit mask CAN frame plus 256 CAN "
"filters) can be added as array to the TX_SETUP BCM configuration message:"
msgstr ""

#: ../../../networking/can.rst:975
msgid "Broadcast Manager CAN FD Support"
msgstr ""

#: ../../../networking/can.rst:977
msgid ""
"The programming API of the CAN_BCM depends on struct can_frame which is "
"given as array directly behind the bcm_msg_head structure. To follow this "
"schema for the CAN FD frames a new flag 'CAN_FD_FRAME' in the bcm_msg_head "
"flags indicates that the concatenated CAN frame structures behind the "
"bcm_msg_head are defined as struct canfd_frame:"
msgstr ""

#: ../../../networking/can.rst:996
msgid ""
"When using CAN FD frames for multiplex filtering the MUX mask is still "
"expected in the first 64 bit of the struct canfd_frame data section."
msgstr ""

#: ../../../networking/can.rst:1001
msgid "Connected Transport Protocols (SOCK_SEQPACKET)"
msgstr ""

#: ../../../networking/can.rst:1003 ../../../networking/can.rst:1009
msgid "(to be written)"
msgstr ""

#: ../../../networking/can.rst:1007
msgid "Unconnected Transport Protocols (SOCK_DGRAM)"
msgstr ""

#: ../../../networking/can.rst:1015
msgid "SocketCAN Core Module"
msgstr ""

#: ../../../networking/can.rst:1017
msgid ""
"The SocketCAN core module implements the protocol family PF_CAN. CAN "
"protocol modules are loaded by the core module at runtime. The core module "
"provides an interface for CAN protocol modules to subscribe needed CAN IDs "
"(see :ref:`socketcan-receive-lists`)."
msgstr ""

#: ../../../networking/can.rst:1024
msgid "can.ko Module Params"
msgstr ""

#: ../../../networking/can.rst:1026
msgid ""
"**stats_timer**: To calculate the SocketCAN core statistics (e.g. current/"
"maximum frames per second) this 1 second timer is invoked at can.ko module "
"start time by default. This timer can be disabled by using stattimer=0 on "
"the module commandline."
msgstr ""

#: ../../../networking/can.rst:1032
msgid "**debug**: (removed since SocketCAN SVN r546)"
msgstr ""

#: ../../../networking/can.rst:1037
msgid "procfs content"
msgstr ""

#: ../../../networking/can.rst:1039
msgid ""
"As described in :ref:`socketcan-receive-lists` the SocketCAN core uses "
"several filter lists to deliver received CAN frames to CAN protocol modules. "
"These receive lists, their filters and the count of filter matches can be "
"checked in the appropriate receive list. All entries contain the device and "
"a protocol module identifier::"
msgstr ""

#: ../../../networking/can.rst:1055
msgid "In this example an application requests any CAN traffic from vcan0::"
msgstr ""

#: ../../../networking/can.rst:1064
msgid "Additional procfs files in /proc/net/can::"
msgstr ""

#: ../../../networking/can.rst:1072
msgid "Writing Own CAN Protocol Modules"
msgstr ""

#: ../../../networking/can.rst:1074
msgid ""
"To implement a new protocol in the protocol family PF_CAN a new protocol has "
"to be defined in include/linux/can.h . The prototypes and definitions to use "
"the SocketCAN core can be accessed by including include/linux/can/core.h . "
"In addition to functions that register the CAN protocol and the CAN device "
"notifier chain there are functions to subscribe CAN frames received by CAN "
"interfaces and to send CAN frames::"
msgstr ""

#: ../../../networking/can.rst:1086
msgid ""
"For details see the kerneldoc documentation in net/can/af_can.c or the "
"source code of net/can/raw.c or net/can/bcm.c ."
msgstr ""

#: ../../../networking/can.rst:1091
msgid "CAN Network Drivers"
msgstr ""

#: ../../../networking/can.rst:1093
msgid ""
"Writing a CAN network device driver is much easier than writing a CAN "
"character device driver. Similar to other known network device drivers you "
"mainly have to deal with:"
msgstr ""

#: ../../../networking/can.rst:1097
msgid "TX: Put the CAN frame from the socket buffer to the CAN controller."
msgstr ""

#: ../../../networking/can.rst:1098
msgid "RX: Put the CAN frame from the CAN controller to the socket buffer."
msgstr ""

#: ../../../networking/can.rst:1100
msgid ""
"See e.g. at Documentation/networking/netdevices.rst . The differences for "
"writing CAN network device driver are described below:"
msgstr ""

#: ../../../networking/can.rst:1105
msgid "General Settings"
msgstr ""

#: ../../../networking/can.rst:1107
msgid ""
"CAN network device drivers can use alloc_candev_mqs() and friends instead of "
"alloc_netdev_mqs(), to automatically take care of CAN-specific setup:"
msgstr ""

#: ../../../networking/can.rst:1114
msgid ""
"The struct can_frame or struct canfd_frame is the payload of each socket "
"buffer (skbuff) in the protocol family PF_CAN."
msgstr ""

#: ../../../networking/can.rst:1123
msgid ""
"As described in :ref:`socketcan-local-loopback1` the CAN network device "
"driver should support a local loopback functionality similar to the local "
"echo e.g. of tty devices. In this case the driver flag IFF_ECHO has to be "
"set to prevent the PF_CAN core from locally echoing sent frames (aka "
"loopback) as fallback solution::"
msgstr ""

#: ../../../networking/can.rst:1133
msgid "CAN Controller Hardware Filters"
msgstr ""

#: ../../../networking/can.rst:1135
msgid ""
"To reduce the interrupt load on deep embedded systems some CAN controllers "
"support the filtering of CAN IDs or ranges of CAN IDs. These hardware filter "
"capabilities vary from controller to controller and have to be identified as "
"not feasible in a multi-user networking approach. The use of the very "
"controller specific hardware filters could make sense in a very dedicated "
"use-case, as a filter on driver level would affect all users in the multi-"
"user system. The high efficient filter sets inside the PF_CAN core allow to "
"set different multiple filters for each socket separately. Therefore the use "
"of hardware filters goes to the category 'handmade tuning on deep embedded "
"systems'. The author is running a MPC603e @133MHz with four SJA1000 CAN "
"controllers from 2002 under heavy bus load without any problems ..."
msgstr ""

#: ../../../networking/can.rst:1151
msgid "Switchable Termination Resistors"
msgstr ""

#: ../../../networking/can.rst:1153
msgid ""
"CAN bus requires a specific impedance across the differential pair, "
"typically provided by two 120Ohm resistors on the farthest nodes of the bus. "
"Some CAN controllers support activating / deactivating a termination "
"resistor(s) to provide the correct impedance."
msgstr ""

#: ../../../networking/can.rst:1158
msgid "Query the available resistances::"
msgstr ""

#: ../../../networking/can.rst:1164
msgid "Activate the terminating resistor::"
msgstr ""

#: ../../../networking/can.rst:1168
msgid "Deactivate the terminating resistor::"
msgstr ""

#: ../../../networking/can.rst:1172
msgid ""
"To enable termination resistor support to a can-controller, either implement "
"in the controller's struct can-priv::"
msgstr ""

#: ../../../networking/can.rst:1179
msgid ""
"or add gpio control with the device tree entries from Documentation/"
"devicetree/bindings/net/can/can-controller.yaml"
msgstr ""

#: ../../../networking/can.rst:1184
msgid "The Virtual CAN Driver (vcan)"
msgstr ""

#: ../../../networking/can.rst:1186
msgid ""
"Similar to the network loopback devices, vcan offers a virtual local CAN "
"interface. A full qualified address on CAN consists of"
msgstr ""

#: ../../../networking/can.rst:1189
msgid "a unique CAN Identifier (CAN ID)"
msgstr ""

#: ../../../networking/can.rst:1190
msgid "the CAN bus this CAN ID is transmitted on (e.g. can0)"
msgstr ""

#: ../../../networking/can.rst:1192
msgid "so in common use cases more than one virtual CAN interface is needed."
msgstr ""

#: ../../../networking/can.rst:1194
msgid ""
"The virtual CAN interfaces allow the transmission and reception of CAN "
"frames without real CAN controller hardware. Virtual CAN network devices are "
"usually named 'vcanX', like vcan0 vcan1 vcan2 ... When compiled as a module "
"the virtual CAN driver module is called vcan.ko"
msgstr ""

#: ../../../networking/can.rst:1199
msgid ""
"Since Linux Kernel version 2.6.24 the vcan driver supports the Kernel "
"netlink interface to create vcan network devices. The creation and removal "
"of vcan network devices can be managed with the ip(8) tool::"
msgstr ""

#: ../../../networking/can.rst:1214
msgid "The CAN Network Device Driver Interface"
msgstr ""

#: ../../../networking/can.rst:1216
msgid ""
"The CAN network device driver interface provides a generic interface to "
"setup, configure and monitor CAN network devices. The user can then "
"configure the CAN device, like setting the bit-timing parameters, via the "
"netlink interface using the program \"ip\" from the \"IPROUTE2\" utility "
"suite. The following chapter describes briefly how to use it. Furthermore, "
"the interface uses a common data structure and exports a set of common "
"functions, which all real CAN network device drivers should use. Please have "
"a look to the SJA1000 or MSCAN driver to understand how to use them. The "
"name of the module is can-dev.ko."
msgstr ""

#: ../../../networking/can.rst:1228
msgid "Netlink interface to set/get devices properties"
msgstr ""

#: ../../../networking/can.rst:1230
msgid ""
"The CAN device must be configured via netlink interface. The supported "
"netlink message types are defined and briefly described in \"include/linux/"
"can/netlink.h\". CAN link support for the program \"ip\" of the IPROUTE2 "
"utility suite is available and it can be used as shown below:"
msgstr ""

#: ../../../networking/can.rst:1236
msgid "Setting CAN device properties::"
msgstr ""

#: ../../../networking/can.rst:1270
msgid "Display CAN device details and statistics::"
msgstr ""

#: ../../../networking/can.rst:1287
msgid "More info to the above output:"
msgstr ""

#: ../../../networking/can.rst:1289
msgid "\"<TRIPLE-SAMPLING>\""
msgstr ""

#: ../../../networking/can.rst:1290
msgid ""
"Shows the list of selected CAN controller modes: LOOPBACK, LISTEN-ONLY, or "
"TRIPLE-SAMPLING."
msgstr ""

#: ../../../networking/can.rst:1293
msgid "\"state ERROR-ACTIVE\""
msgstr ""

#: ../../../networking/can.rst:1294
msgid ""
"The current state of the CAN controller: \"ERROR-ACTIVE\", \"ERROR-"
"WARNING\", \"ERROR-PASSIVE\", \"BUS-OFF\" or \"STOPPED\""
msgstr ""

#: ../../../networking/can.rst:1297
msgid "\"restart-ms 100\""
msgstr ""

#: ../../../networking/can.rst:1298
msgid ""
"Automatic restart delay time. If set to a non-zero value, a restart of the "
"CAN controller will be triggered automatically in case of a bus-off "
"condition after the specified delay time in milliseconds. By default it's "
"off."
msgstr ""

#: ../../../networking/can.rst:1303
msgid "\"bitrate 125000 sample-point 0.875\""
msgstr ""

#: ../../../networking/can.rst:1304
msgid ""
"Shows the real bit-rate in bits/sec and the sample-point in the range "
"0.000..0.999. If the calculation of bit-timing parameters is enabled in the "
"kernel (CONFIG_CAN_CALC_BITTIMING=y), the bit-timing can be defined by "
"setting the \"bitrate\" argument. Optionally the \"sample-point\" can be "
"specified. By default it's 0.000 assuming CIA-recommended sample-points."
msgstr ""

#: ../../../networking/can.rst:1311
msgid "\"tq 125 prop-seg 6 phase-seg1 7 phase-seg2 2 sjw 1\""
msgstr ""

#: ../../../networking/can.rst:1312
msgid ""
"Shows the time quanta in ns, propagation segment, phase buffer segment 1 and "
"2 and the synchronisation jump width in units of tq. They allow to define "
"the CAN bit-timing in a hardware independent format as proposed by the Bosch "
"CAN 2.0 spec (see chapter 8 of http://www.semiconductors.bosch.de/pdf/"
"can2spec.pdf)."
msgstr ""

#: ../../../networking/can.rst:1318
msgid ""
"\"sja1000: tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp-inc 1 clock "
"8000000\""
msgstr ""

#: ../../../networking/can.rst:1319
msgid ""
"Shows the bit-timing constants of the CAN controller, here the \"sja1000\". "
"The minimum and maximum values of the time segment 1 and 2, the "
"synchronisation jump width in units of tq, the bitrate pre-scaler and the "
"CAN system clock frequency in Hz. These constants could be used for user-"
"defined (non-standard) bit-timing calculation algorithms in user-space."
msgstr ""

#: ../../../networking/can.rst:1326
msgid "\"re-started bus-errors arbit-lost error-warn error-pass bus-off\""
msgstr ""

#: ../../../networking/can.rst:1327
msgid ""
"Shows the number of restarts, bus and arbitration lost errors, and the state "
"changes to the error-warning, error-passive and bus-off state. RX overrun "
"errors are listed in the \"overrun\" field of the standard network "
"statistics."
msgstr ""

#: ../../../networking/can.rst:1333
msgid "Setting the CAN Bit-Timing"
msgstr ""

#: ../../../networking/can.rst:1335
msgid ""
"The CAN bit-timing parameters can always be defined in a hardware "
"independent format as proposed in the Bosch CAN 2.0 specification specifying "
"the arguments \"tq\", \"prop_seg\", \"phase_seg1\", \"phase_seg2\" and "
"\"sjw\"::"
msgstr ""

#: ../../../networking/can.rst:1343
msgid ""
"If the kernel option CONFIG_CAN_CALC_BITTIMING is enabled, CIA recommended "
"CAN bit-timing parameters will be calculated if the bit- rate is specified "
"with the argument \"bitrate\"::"
msgstr ""

#: ../../../networking/can.rst:1349
msgid ""
"Note that this works fine for the most common CAN controllers with standard "
"bit-rates but may *fail* for exotic bit-rates or CAN system clock "
"frequencies. Disabling CONFIG_CAN_CALC_BITTIMING saves some space and allows "
"user-space tools to solely determine and set the bit-timing parameters. The "
"CAN controller specific bit-timing constants can be used for that purpose. "
"They are listed by the following command::"
msgstr ""

#: ../../../networking/can.rst:1363
msgid "Starting and Stopping the CAN Network Device"
msgstr ""

#: ../../../networking/can.rst:1365
msgid ""
"A CAN network device is started or stopped as usual with the command "
"\"ifconfig canX up/down\" or \"ip link set canX up/down\". Be aware that you "
"*must* define proper bit-timing parameters for real CAN devices before you "
"can start it to avoid error-prone default settings::"
msgstr ""

#: ../../../networking/can.rst:1372
msgid ""
"A device may enter the \"bus-off\" state if too many errors occurred on the "
"CAN bus. Then no more messages are received or sent. An automatic bus-off "
"recovery can be enabled by setting the \"restart-ms\" to a non-zero value, e."
"g.::"
msgstr ""

#: ../../../networking/can.rst:1379
msgid ""
"Alternatively, the application may realize the \"bus-off\" condition by "
"monitoring CAN error message frames and do a restart when appropriate with "
"the command::"
msgstr ""

#: ../../../networking/can.rst:1385
msgid ""
"Note that a restart will also create a CAN error message frame (see also :"
"ref:`socketcan-network-problem-notifications`)."
msgstr ""

#: ../../../networking/can.rst:1392
msgid "CAN FD (Flexible Data Rate) Driver Support"
msgstr ""

#: ../../../networking/can.rst:1394
msgid ""
"CAN FD capable CAN controllers support two different bitrates for the "
"arbitration phase and the payload phase of the CAN FD frame. Therefore a "
"second bit timing has to be specified in order to enable the CAN FD bitrate."
msgstr ""

#: ../../../networking/can.rst:1398
msgid ""
"Additionally CAN FD capable CAN controllers support up to 64 bytes of "
"payload. The representation of this length in can_frame.len and canfd_frame."
"len for userspace applications and inside the Linux network layer is a plain "
"value from 0 .. 64 instead of the CAN 'data length code'. The data length "
"code was a 1:1 mapping to the payload length in the Classical CAN frames "
"anyway. The payload length to the bus-relevant DLC mapping is only performed "
"inside the CAN drivers, preferably with the helper functions "
"can_fd_dlc2len() and can_fd_len2dlc()."
msgstr ""

#: ../../../networking/can.rst:1407
msgid ""
"The CAN netdevice driver capabilities can be distinguished by the network "
"devices maximum transfer unit (MTU)::"
msgstr ""

#: ../../../networking/can.rst:1413
msgid ""
"The CAN device MTU can be retrieved e.g. with a SIOCGIFMTU ioctl() syscall. "
"N.B. CAN FD capable devices can also handle and send Classical CAN frames."
msgstr ""

#: ../../../networking/can.rst:1416
msgid ""
"When configuring CAN FD capable CAN controllers an additional 'data' bitrate "
"has to be set. This bitrate for the data phase of the CAN FD frame has to be "
"at least the bitrate which was configured for the arbitration phase. This "
"second bitrate is specified analogue to the first bitrate but the bitrate "
"setting keywords for the 'data' bitrate start with 'd' e.g. dbitrate, "
"dsample-point, dsjw or dtq and similar settings. When a data bitrate is set "
"within the configuration process the controller option \"fd on\" can be "
"specified to enable the CAN FD mode in the CAN controller. This controller "
"option also switches the device MTU to 72 (CANFD_MTU)."
msgstr ""

#: ../../../networking/can.rst:1426
msgid ""
"The first CAN FD specification presented as whitepaper at the International "
"CAN Conference 2012 needed to be improved for data integrity reasons. "
"Therefore two CAN FD implementations have to be distinguished today:"
msgstr ""

#: ../../../networking/can.rst:1430
msgid "ISO compliant:     The ISO 11898-1:2015 CAN FD implementation (default)"
msgstr ""

#: ../../../networking/can.rst:1431
msgid ""
"non-ISO compliant: The CAN FD implementation following the 2012 whitepaper"
msgstr ""

#: ../../../networking/can.rst:1433
msgid "Finally there are three types of CAN FD controllers:"
msgstr ""

#: ../../../networking/can.rst:1435
msgid "ISO compliant (fixed)"
msgstr ""

#: ../../../networking/can.rst:1436
msgid "non-ISO compliant (fixed, like the M_CAN IP core v3.0.1 in m_can.c)"
msgstr ""

#: ../../../networking/can.rst:1437
msgid "ISO/non-ISO CAN FD controllers (switchable, like the PEAK PCAN-USB FD)"
msgstr ""

#: ../../../networking/can.rst:1439
msgid ""
"The current ISO/non-ISO mode is announced by the CAN controller driver via "
"netlink and displayed by the 'ip' tool (controller option FD-NON-ISO). The "
"ISO/non-ISO-mode can be altered by setting 'fd-non-iso {on|off}' for "
"switchable CAN FD controllers only."
msgstr ""

#: ../../../networking/can.rst:1444
msgid ""
"Example configuring 500 kbit/s arbitration bitrate and 4 Mbit/s data "
"bitrate::"
msgstr ""

#: ../../../networking/can.rst:1463
msgid ""
"Example when 'fd-non-iso on' is added on this switchable CAN FD adapter::"
msgstr ""

#: ../../../networking/can.rst:1469
msgid "Supported CAN Hardware"
msgstr ""

#: ../../../networking/can.rst:1471
msgid ""
"Please check the \"Kconfig\" file in \"drivers/net/can\" to get an actual "
"list of the support CAN hardware. On the SocketCAN project website (see :ref:"
"`socketcan-resources`) there might be further drivers available, also for "
"older kernel versions."
msgstr ""

#: ../../../networking/can.rst:1480
msgid "SocketCAN Resources"
msgstr ""

#: ../../../networking/can.rst:1482
msgid ""
"The Linux CAN / SocketCAN project resources (project site / mailing list) "
"are referenced in the MAINTAINERS file in the Linux source tree. Search for "
"CAN NETWORK [LAYERS|DRIVERS]."
msgstr ""

#: ../../../networking/can.rst:1487
msgid "Credits"
msgstr ""

#: ../../../networking/can.rst:1489
msgid "Oliver Hartkopp (PF_CAN core, filters, drivers, bcm, SJA1000 driver)"
msgstr ""

#: ../../../networking/can.rst:1490
msgid ""
"Urs Thuermann (PF_CAN core, kernel integration, socket interfaces, raw, vcan)"
msgstr ""

#: ../../../networking/can.rst:1491
msgid "Jan Kizka (RT-SocketCAN core, Socket-API reconciliation)"
msgstr ""

#: ../../../networking/can.rst:1492
msgid ""
"Wolfgang Grandegger (RT-SocketCAN core & drivers, Raw Socket-API reviews, "
"CAN device driver interface, MSCAN driver)"
msgstr ""

#: ../../../networking/can.rst:1493
msgid "Robert Schwebel (design reviews, PTXdist integration)"
msgstr ""

#: ../../../networking/can.rst:1494
msgid "Marc Kleine-Budde (design reviews, Kernel 2.6 cleanups, drivers)"
msgstr ""

#: ../../../networking/can.rst:1495
msgid "Benedikt Spranger (reviews)"
msgstr ""

#: ../../../networking/can.rst:1496
msgid "Thomas Gleixner (LKML reviews, coding style, posting hints)"
msgstr ""

#: ../../../networking/can.rst:1497
msgid "Andrey Volkov (kernel subtree structure, ioctls, MSCAN driver)"
msgstr ""

#: ../../../networking/can.rst:1498
msgid "Matthias Brukner (first SJA1000 CAN netdevice implementation Q2/2003)"
msgstr ""

#: ../../../networking/can.rst:1499
msgid "Klaus Hitschler (PEAK driver integration)"
msgstr ""

#: ../../../networking/can.rst:1500
msgid "Uwe Koppe (CAN netdevices with PF_PACKET approach)"
msgstr ""

#: ../../../networking/can.rst:1501
msgid ""
"Michael Schulze (driver layer loopback requirement, RT CAN drivers review)"
msgstr ""

#: ../../../networking/can.rst:1502
msgid "Pavel Pisa (Bit-timing calculation)"
msgstr ""

#: ../../../networking/can.rst:1503
msgid "Sascha Hauer (SJA1000 platform driver)"
msgstr ""

#: ../../../networking/can.rst:1504
msgid "Sebastian Haas (SJA1000 EMS PCI driver)"
msgstr ""

#: ../../../networking/can.rst:1505
msgid "Markus Plessing (SJA1000 EMS PCI driver)"
msgstr ""

#: ../../../networking/can.rst:1506
msgid "Per Dalen (SJA1000 Kvaser PCI driver)"
msgstr ""

#: ../../../networking/can.rst:1507
msgid "Sam Ravnborg (reviews, coding style, kbuild help)"
msgstr ""
