# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-24 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/buffer.rst:2
msgid "Buffer Heads"
msgstr ""

#: ../../../filesystems/buffer.rst:4
msgid ""
"Linux uses buffer heads to maintain state about individual filesystem "
"blocks. Buffer heads are deprecated and new filesystems should use iomap "
"instead."
msgstr ""

#: ../../../filesystems/buffer.rst:8
msgid "Functions"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:306
#: ../../../filesystems/buffer:11: fs/buffer.c:1226
msgid "Release a buffer."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:310
#: include/linux/buffer_head.h:332 include/linux/buffer_head.h:475
#: include/linux/buffer_head.h:495 ../../../filesystems/buffer:11:
#: fs/buffer.c:571 fs/buffer.c:594 fs/buffer.c:637 fs/buffer.c:704
#: fs/buffer.c:1174 fs/buffer.c:1230 fs/buffer.c:1246 fs/buffer.c:1438
#: fs/buffer.c:1485 fs/buffer.c:1621 fs/buffer.c:1723 fs/buffer.c:2922
#: fs/buffer.c:3068 fs/buffer.c:3087 fs/buffer.c:3113
msgid "**Parameters**"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:312
#: include/linux/buffer_head.h:334 include/linux/buffer_head.h:497
#: ../../../filesystems/buffer:11: fs/buffer.c:1176 fs/buffer.c:1232
#: fs/buffer.c:1248 fs/buffer.c:3070 fs/buffer.c:3089
msgid "``struct buffer_head *bh``"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:307
#: ../../../filesystems/buffer:11: fs/buffer.c:1227
msgid "The buffer to release."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:309
#: include/linux/buffer_head.h:331 include/linux/buffer_head.h:476
#: include/linux/buffer_head.h:495 ../../../filesystems/buffer:11:
#: fs/buffer.c:570 fs/buffer.c:598 fs/buffer.c:641 fs/buffer.c:704
#: fs/buffer.c:1173 fs/buffer.c:1229 fs/buffer.c:1245 fs/buffer.c:1440
#: fs/buffer.c:1487 fs/buffer.c:1622 fs/buffer.c:1724 fs/buffer.c:2921
#: fs/buffer.c:3067 fs/buffer.c:3088 fs/buffer.c:3116
msgid "**Description**"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:308
msgid ""
"Decrement a buffer_head's reference count.  If **bh** is NULL, this function "
"is a no-op."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:311
msgid ""
"If all buffers on a folio have zero reference count, are clean and unlocked, "
"and if the folio is unlocked and not under writeback then "
"try_to_free_buffers() may strip the buffers from the folio in preparation "
"for freeing it (sometimes, rarely, buffers are removed from a folio but it "
"ends up not being freed, and buffers may later be reattached)."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:318
#: include/linux/buffer_head.h:334 include/linux/buffer_head.h:480
#: ../../../filesystems/buffer:11: fs/buffer.c:723 fs/buffer.c:1498
#: fs/buffer.c:2937
msgid "**Context**"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:319
#: include/linux/buffer_head.h:335
msgid "Any context."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:328
#: ../../../filesystems/buffer:11: fs/buffer.c:1242
msgid "Discard any dirty data in a buffer."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:329
#: ../../../filesystems/buffer:11: fs/buffer.c:1243
msgid "The buffer to forget."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:330
msgid ""
"Call this function instead of brelse() if the data written to a buffer no "
"longer needs to be written back.  It will clear the buffer's dirty flag so "
"writeback of this buffer will be skipped."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:471
#: ../../../filesystems/buffer:11: fs/buffer.c:1481
msgid "Read a block."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:477
#: ../../../filesystems/buffer:11: fs/buffer.c:1440 fs/buffer.c:1487
#: fs/buffer.c:1725
msgid "``struct block_device *bdev``"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:472
#: ../../../filesystems/buffer:11: fs/buffer.c:1482
msgid "The block device to read from."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:474
#: ../../../filesystems/buffer:11: fs/buffer.c:1437 fs/buffer.c:1484
#: fs/buffer.c:1722
msgid "``sector_t block``"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:473
#: ../../../filesystems/buffer:11: fs/buffer.c:1483
msgid "Block number in units of block size."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:475
#: ../../../filesystems/buffer:11: fs/buffer.c:1438 fs/buffer.c:1485
msgid "``unsigned size``"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:474
#: ../../../filesystems/buffer:11: fs/buffer.c:1484
msgid "The block size of this device in bytes."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:475
msgid ""
"Read a specified block, and return the buffer head that refers to it.  The "
"memory is allocated from the movable area so that it can be migrated.  The "
"returned buffer head has its refcount increased. The caller should call "
"brelse() when it has finished with the buffer."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:481
#: ../../../filesystems/buffer:11: fs/buffer.c:1499
msgid "May sleep waiting for I/O."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:483
#: include/linux/buffer_head.h:500 ../../../filesystems/buffer:11:
#: fs/buffer.c:729 fs/buffer.c:1444 fs/buffer.c:1501 fs/buffer.c:2940
msgid "**Return**"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:482
#: ../../../filesystems/buffer:11: fs/buffer.c:1500
msgid "NULL if the block was unreadable."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:491
msgid "Get a reference on the n'th buffer after this one."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:492
msgid "The buffer to start counting from."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:494
msgid "``unsigned int count``"
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:493
msgid "How many buffers to skip."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:494
msgid ""
"This is primarily useful for finding the nth buffer in a folio; in that case "
"you pass the head buffer and the byte offset in the folio divided by the "
"block size.  It can be used for other purposes, but it will wrap at the end "
"of the folio rather than returning NULL or proceeding to the next folio for "
"you."
msgstr ""

#: ../../../filesystems/buffer:10: include/linux/buffer_head.h:501
msgid "The requested buffer with an elevated refcount."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:567
msgid "write out & wait upon a mapping's \"associated\" buffers"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:573 fs/buffer.c:706
msgid "``struct address_space *mapping``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:568
msgid "the mapping which wants those buffers written"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:569
msgid ""
"Starts I/O against the buffers at mapping->i_private_list, and waits upon "
"that I/O."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:572
msgid ""
"Basically, this is a convenience function for fsync(). **mapping** is a file "
"or directory which needs those buffers to be written for a successful "
"fsync()."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:590 fs/buffer.c:633
msgid ""
"generic buffer fsync implementation for simple filesystems with no inode lock"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:596 fs/buffer.c:639
msgid "``struct file *file``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:593 fs/buffer.c:636
msgid "file to synchronize"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:595 fs/buffer.c:638
msgid "``loff_t start``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:594 fs/buffer.c:637
msgid "start offset in bytes"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:596 fs/buffer.c:639
msgid "``loff_t end``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:595 fs/buffer.c:638
msgid "end offset in bytes (inclusive)"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:597 fs/buffer.c:640
msgid "``bool datasync``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:596 fs/buffer.c:639
msgid "only synchronize essential metadata if true"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:597
msgid ""
"This is a generic implementation of the fsync method for simple filesystems "
"which track all non-inode metadata in the buffers list hanging off the "
"address_space structure."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:640
msgid ""
"This is a generic implementation of the fsync method for simple filesystems "
"which track all non-inode metadata in the buffers list hanging off the "
"address_space structure. This also makes sure that a device cache flush "
"operation is called at the end."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:700
msgid "Mark a folio as dirty."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:701
msgid "The address space containing this folio."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:703 fs/buffer.c:1623
#: fs/buffer.c:2924
msgid "``struct folio *folio``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:702
msgid "The folio to mark dirty."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:703
msgid ""
"Filesystems which use buffer_heads can use this function as their -"
">dirty_folio implementation.  Some filesystems need to do a little work "
"before calling this function.  Filesystems which do not use buffer_heads "
"should call filemap_dirty_folio() instead."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:708
msgid ""
"If the folio has buffers, the uptodate buffers are set dirty, to preserve "
"dirty-state coherency between the folio and the buffers. Buffers added to a "
"dirty folio are created dirty."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:712
msgid ""
"The buffers are dirtied before the folio is dirtied.  There's a small race "
"window in which writeback may see the folio cleanness but not the buffer "
"dirtiness.  That's fine.  If this code were to set the folio dirty before "
"the buffers, writeback could clear the folio dirty flag, see a bunch of "
"clean buffers and we'd end up with dirty buffers/clean folio on the dirty "
"folio list."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:719
msgid ""
"We use i_private_lock to lock against try_to_free_buffers() while using the "
"folio's buffer list.  This also prevents clean buffers being added to the "
"folio after it was set dirty."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:724
msgid ""
"May only be called from process context.  Does not sleep. Caller must ensure "
"that **folio** cannot be truncated during this call, typically by holding "
"the folio lock or having a page in the folio mapped and holding the page "
"table lock."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:729
msgid "True if the folio was dirtied; false if it was already dirtied."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1170
msgid "mark a buffer_head as needing writeout"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1171
msgid "the buffer_head to mark dirty"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1172
msgid ""
"mark_buffer_dirty() will set the dirty bit against the buffer, then set its "
"backing page dirty, then tag the page as dirty in the page cache and then "
"attach the address_space's inode to its superblock's dirty inode list."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1177
msgid ""
"mark_buffer_dirty() is atomic.  It takes bh->b_folio->mapping-"
">i_private_lock, i_pages lock and mapping->host->i_lock."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1228
msgid ""
"This variant of brelse() can be called if **bh** is guaranteed to not be "
"NULL."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1244
msgid ""
"This variant of bforget() can be called if **bh** is guaranteed to not be "
"NULL."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1434
msgid "Get a buffer_head in a block device's buffer cache."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1435
msgid "The block device."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1436
msgid "The block number."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1437
msgid "The size of buffer_heads for this **bdev**."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1439 fs/buffer.c:1486
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1438
msgid "The memory allocation flags to use."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1439
msgid ""
"The returned buffer head has its reference count incremented, but is not "
"locked.  The caller should call brelse() when it has finished with the "
"buffer.  The buffer may not be uptodate.  If needed, the caller can bring it "
"uptodate either by reading it or overwriting it."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1445
msgid "The buffer head, or NULL if memory could not be allocated."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1485
msgid "Not page allocation flags; see below."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1486
msgid ""
"You are not expected to call this function.  You should use one of "
"sb_bread(), sb_bread_unmovable() or __bread()."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1489
msgid ""
"Read a specified block, and return the buffer head that refers to it. If "
"**gfp** is 0, the memory will be allocated using the block device's default "
"GFP flags.  If **gfp** is __GFP_MOVABLE, the memory may be allocated from a "
"movable area.  Do not pass in a complete set of GFP flags."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1495
msgid ""
"The returned buffer head has its refcount increased.  The caller should call "
"brelse() when it has finished with the buffer."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1617
msgid "Invalidate part or all of a buffer-backed folio."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1618
msgid "The folio which is affected."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1620
msgid "``size_t offset``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1619
msgid "start of the range to invalidate"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1621
msgid "``size_t length``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1620
msgid "length of the range to invalidate"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1621
msgid ""
"block_invalidate_folio() is called when all or part of the folio has been "
"invalidated by a truncate operation."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1624
msgid ""
"block_invalidate_folio() does not have to release all buffers, but it must "
"ensure that no dirty buffer is left outside **offset** and that no I/O is "
"underway against any of the blocks which are outside the truncation point.  "
"Because the caller is about to free (and possibly reuse) those blocks on-"
"disk."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1719
msgid "clean a range of buffers in block device"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1720
msgid "Block device to clean buffers in"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1721
msgid "Start of a range of blocks to clean"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1723
msgid "``sector_t len``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1722
msgid "Number of blocks to clean"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1723
msgid ""
"We are taking a range of blocks for data and we don't want writeback of any "
"buffer-cache aliases starting from return from this function and until the "
"moment when something will explicitly mark the buffer dirty (hopefully that "
"will not happen until we will free that block ;-) We don't even need to mark "
"it not-uptodate - nobody can expect anything from a newly allocated buffer "
"anyway. We used to use unmap_buffer() for such invalidation, but that was "
"wrong. We definitely don't want to mark the alias unmapped, for example - it "
"would confuse anyone who might pick it with bread() afterwards..."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:1732
msgid ""
"Also..  Note that bforget() doesn't lock the buffer.  So there can be "
"writeout I/O going on against recently-freed buffers.  We don't wait on that "
"I/O in bforget() - it's more efficient to wait on the I/O only if we really "
"need to.  That happens here."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:2918
msgid "Release buffers attached to this folio."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:2919
msgid "The folio."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:2920
msgid ""
"If any buffers are in use (dirty, under writeback, elevated refcount), no "
"buffers will be freed."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:2923
msgid ""
"If the folio is dirty but all the buffers are clean then we need to be sure "
"to mark the folio clean as well.  This is because the folio may be against a "
"block device, and a later reattachment of buffers to a dirty folio will set "
"*all* buffers dirty.  Which would corrupt filesystem data on the same device."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:2929
msgid ""
"The same applies to regular filesystem folios: if all the buffers are clean "
"then we set the folio clean and proceed.  To do that, we require total "
"exclusion from block_dirty_folio().  That is obtained with i_private_lock."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:2934
msgid ""
"Exclusion against try_to_free_buffers may be obtained by either locking the "
"folio or by holding its mapping's i_private_lock."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:2938
msgid "Process context.  **folio** must be locked.  Will not sleep."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:2939
msgid "true if all buffers attached to this folio were freed."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3064
msgid "Test whether the buffer is uptodate"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3065 fs/buffer.c:3084
msgid "struct buffer_head"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3066
msgid ""
"Return true if the buffer is up-to-date and false, with the buffer locked, "
"if not."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3083
msgid "Submit read for a locked buffer"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3086 fs/buffer.c:3113
msgid "``blk_opf_t op_flags``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3085 fs/buffer.c:3112
msgid "appending REQ_OP_* flags besides REQ_OP_READ"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3087
msgid "``bool wait``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3086
msgid "wait until reading finish"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3087 fs/buffer.c:3115
msgid "Returns zero on success or don't wait, and -EIO on error."
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3109
msgid "Submit read for a batch of unlocked buffers"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3115
msgid "``int nr``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3110
msgid "entry number of the buffer batch"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3112
msgid "``struct buffer_head *bhs[]``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3111
msgid "a batch of struct buffer_head"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3114
msgid "``bool force_lock``"
msgstr ""

#: ../../../filesystems/buffer:11: fs/buffer.c:3113
msgid ""
"force to get a lock on the buffer if set, otherwise drops any buffer that "
"cannot lock."
msgstr ""
