# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/debugfs.rst:6
msgid "DebugFS"
msgstr ""

#: ../../../filesystems/debugfs.rst:8
msgid "Copyright |copy| 2009 Jonathan Corbet <corbet@lwn.net>"
msgstr ""

#: ../../../filesystems/debugfs.rst:10
msgid ""
"Debugfs exists as a simple way for kernel developers to make information "
"available to user space.  Unlike /proc, which is only meant for information "
"about a process, or sysfs, which has strict one-value-per-file rules, "
"debugfs has no rules at all.  Developers can put any information they want "
"there.  The debugfs filesystem is also intended to not serve as a stable ABI "
"to user space; in theory, there are no stability constraints placed on files "
"exported there.  The real world is not always so simple, though [1]_; even "
"debugfs interfaces are best designed with the idea that they will need to be "
"maintained forever."
msgstr ""

#: ../../../filesystems/debugfs.rst:20
msgid "Debugfs is typically mounted with a command like::"
msgstr ""

#: ../../../filesystems/debugfs.rst:24
msgid ""
"(Or an equivalent /etc/fstab line). The debugfs root directory is accessible "
"only to the root user by default. To change access to the tree the \"uid\", "
"\"gid\" and \"mode\" mount options can be used."
msgstr ""

#: ../../../filesystems/debugfs.rst:29
msgid "Note that the debugfs API is exported GPL-only to modules."
msgstr ""

#: ../../../filesystems/debugfs.rst:31
msgid ""
"Code using debugfs should include <linux/debugfs.h>.  Then, the first order "
"of business will be to create at least one directory to hold a set of "
"debugfs files::"
msgstr ""

#: ../../../filesystems/debugfs.rst:37
msgid ""
"This call, if successful, will make a directory called name underneath the "
"indicated parent directory.  If parent is NULL, the directory will be "
"created in the debugfs root.  On success, the return value is a struct "
"dentry pointer which can be used to create files in the directory (and to "
"clean it up at the end).  An ERR_PTR(-ERROR) return value indicates that "
"something went wrong.  If ERR_PTR(-ENODEV) is returned, that is an "
"indication that the kernel has been built without debugfs support and none "
"of the functions described below will work."
msgstr ""

#: ../../../filesystems/debugfs.rst:46
msgid ""
"The most general way to create a file within a debugfs directory is with::"
msgstr ""

#: ../../../filesystems/debugfs.rst:52
msgid ""
"Here, name is the name of the file to create, mode describes the access "
"permissions the file should have, parent indicates the directory which "
"should hold the file, data will be stored in the i_private field of the "
"resulting inode structure, and fops is a set of file operations which "
"implement the file's behavior.  At a minimum, the read() and/or write() "
"operations should be provided; others can be included as needed.  Again, the "
"return value will be a dentry pointer to the created file, ERR_PTR(-ERROR) "
"on error, or ERR_PTR(-ENODEV) if debugfs support is missing."
msgstr ""

#: ../../../filesystems/debugfs.rst:62
msgid ""
"Create a file with an initial size, the following function can be used "
"instead::"
msgstr ""

#: ../../../filesystems/debugfs.rst:70
msgid ""
"file_size is the initial file size. The other parameters are the same as the "
"function debugfs_create_file."
msgstr ""

#: ../../../filesystems/debugfs.rst:73
msgid ""
"In a number of cases, the creation of a set of file operations is not "
"actually necessary; the debugfs code provides a number of helper functions "
"for simple situations.  Files containing a single integer value can be "
"created with any of::"
msgstr ""

#: ../../../filesystems/debugfs.rst:87
msgid ""
"These files support both reading and writing the given value; if a specific "
"file should not be written to, simply set the mode bits accordingly.  The "
"values in these files are in decimal; if hexadecimal is more appropriate, "
"the following functions can be used instead::"
msgstr ""

#: ../../../filesystems/debugfs.rst:101
msgid ""
"These functions are useful as long as the developer knows the size of the "
"value to be exported.  Some types can have different widths on different "
"architectures, though, complicating the situation somewhat.  There are "
"functions meant to help out in such special cases::"
msgstr ""

#: ../../../filesystems/debugfs.rst:109
msgid ""
"As might be expected, this function will create a debugfs file to represent "
"a variable of type size_t."
msgstr ""

#: ../../../filesystems/debugfs.rst:112
msgid ""
"Similarly, there are helpers for variables of type unsigned long, in decimal "
"and hexadecimal::"
msgstr ""

#: ../../../filesystems/debugfs.rst:121
msgid "Boolean values can be placed in debugfs with::"
msgstr ""

#: ../../../filesystems/debugfs.rst:126
msgid ""
"A read on the resulting file will yield either Y (for non-zero values) or N, "
"followed by a newline.  If written to, it will accept either upper- or lower-"
"case values, or 1 or 0.  Any other input will be silently ignored."
msgstr ""

#: ../../../filesystems/debugfs.rst:130
msgid "Also, atomic_t values can be placed in debugfs with::"
msgstr ""

#: ../../../filesystems/debugfs.rst:135
msgid ""
"A read of this file will get atomic_t values, and a write of this file will "
"set atomic_t values."
msgstr ""

#: ../../../filesystems/debugfs.rst:138
msgid ""
"Another option is exporting a block of arbitrary binary data, with this "
"structure and function::"
msgstr ""

#: ../../../filesystems/debugfs.rst:150
msgid ""
"A read of this file will return the data pointed to by the "
"debugfs_blob_wrapper structure.  Some drivers use \"blobs\" as a simple way "
"to return several lines of (static) formatted text output.  This function "
"can be used to export binary information, but there does not appear to be "
"any code which does so in the mainline.  Note that all files created with "
"debugfs_create_blob() are read-only."
msgstr ""

#: ../../../filesystems/debugfs.rst:157
msgid ""
"If you want to dump a block of registers (something that happens quite often "
"during development, even if little such code reaches mainline), debugfs "
"offers two functions: one to make a registers-only file, and another to "
"insert a register block in the middle of another sequential file::"
msgstr ""

#: ../../../filesystems/debugfs.rst:182
msgid ""
"The \"base\" argument may be 0, but you may want to build the reg32 array "
"using __stringify, and a number of register names (macros) are actually byte "
"offsets over a base for the register block."
msgstr ""

#: ../../../filesystems/debugfs.rst:186
msgid ""
"If you want to dump a u32 array in debugfs, you can create a file with::"
msgstr ""

#: ../../../filesystems/debugfs.rst:197
msgid ""
"The \"array\" argument wraps a pointer to the array's data and the number of "
"its elements. Note: Once array is created its size can not be changed."
msgstr ""

#: ../../../filesystems/debugfs.rst:200
msgid "There is a helper function to create a device-related seq_file::"
msgstr ""

#: ../../../filesystems/debugfs.rst:208
msgid ""
"The \"dev\" argument is the device related to this debugfs file, and the "
"\"read_fn\" is a function pointer which to be called to print the seq_file "
"content."
msgstr ""

#: ../../../filesystems/debugfs.rst:212
msgid "There are a couple of other directory-oriented helper functions::"
msgstr ""

#: ../../../filesystems/debugfs.rst:221
msgid ""
"A call to debugfs_change_name() will give a new name to an existing debugfs "
"file, always in the same directory.  The new_name must not exist prior to "
"the call; the return value is 0 on success and -E... on failure. Symbolic "
"links can be created with debugfs_create_symlink()."
msgstr ""

#: ../../../filesystems/debugfs.rst:226
msgid ""
"There is one important thing that all debugfs users must take into account: "
"there is no automatic cleanup of any directories created in debugfs.  If a "
"module is unloaded without explicitly removing debugfs entries, the result "
"will be a lot of stale pointers and no end of highly antisocial behavior. So "
"all debugfs users - at least those which can be built as modules - must be "
"prepared to remove all files and directories they create there.  A file or "
"directory can be removed with::"
msgstr ""

#: ../../../filesystems/debugfs.rst:236
msgid ""
"The dentry value can be NULL or an error value, in which case nothing will "
"be removed.  Note that this function will recursively remove all files and "
"directories underneath it.  Previously, debugfs_remove_recursive() was used "
"to perform that task, but this function is now just an alias to "
"debugfs_remove().  debugfs_remove_recursive() should be considered "
"deprecated."
msgstr ""

#: ../../../filesystems/debugfs.rst:243
msgid "http://lwn.net/Articles/309298/"
msgstr ""
