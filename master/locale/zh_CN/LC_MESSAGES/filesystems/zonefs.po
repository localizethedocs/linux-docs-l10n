# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/zonefs.rst:5
msgid "ZoneFS - Zone filesystem for Zoned block devices"
msgstr ""

#: ../../../filesystems/zonefs.rst:8
msgid "Introduction"
msgstr ""

#: ../../../filesystems/zonefs.rst:10
msgid ""
"zonefs is a very simple file system exposing each zone of a zoned block "
"device as a file. Unlike a regular POSIX-compliant file system with native "
"zoned block device support (e.g. f2fs), zonefs does not hide the sequential "
"write constraint of zoned block devices to the user. Files representing "
"sequential write zones of the device must be written sequentially starting "
"from the end of the file (append only writes)."
msgstr ""

#: ../../../filesystems/zonefs.rst:17
msgid ""
"As such, zonefs is in essence closer to a raw block device access interface "
"than to a full-featured POSIX file system. The goal of zonefs is to simplify "
"the implementation of zoned block device support in applications by "
"replacing raw block device file accesses with a richer file API, avoiding "
"relying on direct block device file ioctls which may be more obscure to "
"developers. One example of this approach is the implementation of LSM (log-"
"structured merge) tree structures (such as used in RocksDB and LevelDB) on "
"zoned block devices by allowing SSTables to be stored in a zone file "
"similarly to a regular file system rather than as a range of sectors of the "
"entire disk. The introduction of the higher level construct \"one file is "
"one zone\" can help reducing the amount of changes needed in the application "
"as well as introducing support for different application programming "
"languages."
msgstr ""

#: ../../../filesystems/zonefs.rst:31
msgid "Zoned block devices"
msgstr ""

#: ../../../filesystems/zonefs.rst:33
msgid ""
"Zoned storage devices belong to a class of storage devices with an address "
"space that is divided into zones. A zone is a group of consecutive LBAs and "
"all zones are contiguous (there are no LBA gaps). Zones may have different "
"types."
msgstr ""

#: ../../../filesystems/zonefs.rst:37
msgid ""
"Conventional zones: there are no access constraints to LBAs belonging to "
"conventional zones. Any read or write access can be executed, similarly to a "
"regular block device."
msgstr ""

#: ../../../filesystems/zonefs.rst:40
msgid ""
"Sequential zones: these zones accept random reads but must be written "
"sequentially. Each sequential zone has a write pointer maintained by the "
"device that keeps track of the mandatory start LBA position of the next "
"write to the device. As a result of this write constraint, LBAs in a "
"sequential zone cannot be overwritten. Sequential zones must first be erased "
"using a special command (zone reset) before rewriting."
msgstr ""

#: ../../../filesystems/zonefs.rst:47
msgid ""
"Zoned storage devices can be implemented using various recording and media "
"technologies. The most common form of zoned storage today uses the SCSI "
"Zoned Block Commands (ZBC) and Zoned ATA Commands (ZAC) interfaces on "
"Shingled Magnetic Recording (SMR) HDDs."
msgstr ""

#: ../../../filesystems/zonefs.rst:52
msgid ""
"Solid State Disks (SSD) storage devices can also implement a zoned interface "
"to, for instance, reduce internal write amplification due to garbage "
"collection. The NVMe Zoned NameSpace (ZNS) is a technical proposal of the "
"NVMe standard committee aiming at adding a zoned storage interface to the "
"NVMe protocol."
msgstr ""

#: ../../../filesystems/zonefs.rst:58
msgid "Zonefs Overview"
msgstr ""

#: ../../../filesystems/zonefs.rst:60
msgid ""
"Zonefs exposes the zones of a zoned block device as files. The files "
"representing zones are grouped by zone type, which are themselves "
"represented by sub-directories. This file structure is built entirely using "
"zone information provided by the device and so does not require any complex "
"on-disk metadata structure."
msgstr ""

#: ../../../filesystems/zonefs.rst:67
msgid "On-disk metadata"
msgstr ""

#: ../../../filesystems/zonefs.rst:69
msgid ""
"zonefs on-disk metadata is reduced to an immutable super block which "
"persistently stores a magic number and optional feature flags and values. On "
"mount, zonefs uses blkdev_report_zones() to obtain the device zone "
"configuration and populates the mount point with a static file tree solely "
"based on this information. File sizes come from the device zone type and "
"write pointer position managed by the device itself."
msgstr ""

#: ../../../filesystems/zonefs.rst:76
msgid ""
"The super block is always written on disk at sector 0. The first zone of the "
"device storing the super block is never exposed as a zone file by zonefs. If "
"the zone containing the super block is a sequential zone, the mkzonefs "
"format tool always \"finishes\" the zone, that is, it transitions the zone "
"to a full state to make it read-only, preventing any data write."
msgstr ""

#: ../../../filesystems/zonefs.rst:83
msgid "Zone type sub-directories"
msgstr ""

#: ../../../filesystems/zonefs.rst:85
msgid ""
"Files representing zones of the same type are grouped together under the "
"same sub-directory automatically created on mount."
msgstr ""

#: ../../../filesystems/zonefs.rst:88
msgid ""
"For conventional zones, the sub-directory \"cnv\" is used. This directory is "
"however created if and only if the device has usable conventional zones. If "
"the device only has a single conventional zone at sector 0, the zone will "
"not be exposed as a file as it will be used to store the zonefs super block. "
"For such devices, the \"cnv\" sub-directory will not be created."
msgstr ""

#: ../../../filesystems/zonefs.rst:94
msgid "For sequential write zones, the sub-directory \"seq\" is used."
msgstr ""

#: ../../../filesystems/zonefs.rst:96
msgid ""
"These two directories are the only directories that exist in zonefs. Users "
"cannot create other directories and cannot rename nor delete the \"cnv\" and "
"\"seq\" sub-directories."
msgstr ""

#: ../../../filesystems/zonefs.rst:100
msgid ""
"The size of the directories indicated by the st_size field of struct stat, "
"obtained with the stat() or fstat() system calls, indicates the number of "
"files existing under the directory."
msgstr ""

#: ../../../filesystems/zonefs.rst:105
msgid "Zone files"
msgstr ""

#: ../../../filesystems/zonefs.rst:107
msgid ""
"Zone files are named using the number of the zone they represent within the "
"set of zones of a particular type. That is, both the \"cnv\" and \"seq\" "
"directories contain files named \"0\", \"1\", \"2\", ... The file numbers "
"also represent increasing zone start sector on the device."
msgstr ""

#: ../../../filesystems/zonefs.rst:112
msgid ""
"All read and write operations to zone files are not allowed beyond the file "
"maximum size, that is, beyond the zone capacity. Any access exceeding the "
"zone capacity is failed with the -EFBIG error."
msgstr ""

#: ../../../filesystems/zonefs.rst:116
msgid ""
"Creating, deleting, renaming or modifying any attribute of files and sub-"
"directories is not allowed."
msgstr ""

#: ../../../filesystems/zonefs.rst:119
msgid ""
"The number of blocks of a file as reported by stat() and fstat() indicates "
"the capacity of the zone file, or in other words, the maximum file size."
msgstr ""

#: ../../../filesystems/zonefs.rst:123
msgid "Conventional zone files"
msgstr ""

#: ../../../filesystems/zonefs.rst:125
msgid ""
"The size of conventional zone files is fixed to the size of the zone they "
"represent. Conventional zone files cannot be truncated."
msgstr ""

#: ../../../filesystems/zonefs.rst:128
msgid ""
"These files can be randomly read and written using any type of I/O "
"operation: buffered I/Os, direct I/Os, memory mapped I/Os (mmap), etc. There "
"are no I/O constraint for these files beyond the file size limit mentioned "
"above."
msgstr ""

#: ../../../filesystems/zonefs.rst:133
msgid "Sequential zone files"
msgstr ""

#: ../../../filesystems/zonefs.rst:135
msgid ""
"The size of sequential zone files grouped in the \"seq\" sub-directory "
"represents the file's zone write pointer position relative to the zone start "
"sector."
msgstr ""

#: ../../../filesystems/zonefs.rst:138
msgid ""
"Sequential zone files can only be written sequentially, starting from the "
"file end, that is, write operations can only be append writes. Zonefs makes "
"no attempt at accepting random writes and will fail any write request that "
"has a start offset not corresponding to the end of the file, or to the end "
"of the last write issued and still in-flight (for asynchronous I/O "
"operations)."
msgstr ""

#: ../../../filesystems/zonefs.rst:144
msgid ""
"Since dirty page writeback by the page cache does not guarantee a sequential "
"write pattern, zonefs prevents buffered writes and writeable shared mappings "
"on sequential files. Only direct I/O writes are accepted for these files. "
"zonefs relies on the sequential delivery of write I/O requests to the device "
"implemented by the block layer elevator. An elevator implementing the "
"sequential write feature for zoned block device (ELEVATOR_F_ZBD_SEQ_WRITE "
"elevator feature) must be used. This type of elevator (e.g. mq-deadline) is "
"set by default for zoned block devices on device initialization."
msgstr ""

#: ../../../filesystems/zonefs.rst:153
msgid ""
"There are no restrictions on the type of I/O used for read operations in "
"sequential zone files. Buffered I/Os, direct I/Os and shared read mappings "
"are all accepted."
msgstr ""

#: ../../../filesystems/zonefs.rst:157
msgid ""
"Truncating sequential zone files is allowed only down to 0, in which case, "
"the zone is reset to rewind the file zone write pointer position to the "
"start of the zone, or up to the zone capacity, in which case the file's zone "
"is transitioned to the FULL state (finish zone operation)."
msgstr ""

#: ../../../filesystems/zonefs.rst:163
msgid "Format options"
msgstr ""

#: ../../../filesystems/zonefs.rst:165
msgid "Several optional features of zonefs can be enabled at format time."
msgstr ""

#: ../../../filesystems/zonefs.rst:167
msgid ""
"Conventional zone aggregation: ranges of contiguous conventional zones can "
"be aggregated into a single larger file instead of the default one file per "
"zone."
msgstr ""

#: ../../../filesystems/zonefs.rst:169
msgid ""
"File ownership: The owner UID and GID of zone files is by default 0 (root) "
"but can be changed to any valid UID/GID."
msgstr ""

#: ../../../filesystems/zonefs.rst:171
msgid ""
"File access permissions: the default 640 access permissions can be changed."
msgstr ""

#: ../../../filesystems/zonefs.rst:174
msgid "IO error handling"
msgstr ""

#: ../../../filesystems/zonefs.rst:176
msgid ""
"Zoned block devices may fail I/O requests for reasons similar to regular "
"block devices, e.g. due to bad sectors. However, in addition to such known I/"
"O failure pattern, the standards governing zoned block devices behavior "
"define additional conditions that result in I/O errors."
msgstr ""

#: ../../../filesystems/zonefs.rst:181
msgid ""
"A zone may transition to the read-only condition (BLK_ZONE_COND_READONLY): "
"While the data already written in the zone is still readable, the zone can "
"no longer be written. No user action on the zone (zone management command or "
"read/write access) can change the zone condition back to a normal read/write "
"state. While the reasons for the device to transition a zone to read-only "
"state are not defined by the standards, a typical cause for such transition "
"would be a defective write head on an HDD (all zones under this head are "
"changed to read-only)."
msgstr ""

#: ../../../filesystems/zonefs.rst:190
msgid ""
"A zone may transition to the offline condition (BLK_ZONE_COND_OFFLINE): An "
"offline zone cannot be read nor written. No user action can transition an "
"offline zone back to an operational good state. Similarly to zone read-only "
"transitions, the reasons for a drive to transition a zone to the offline "
"condition are undefined. A typical cause would be a defective read-write "
"head on an HDD causing all zones on the platter under the broken head to be "
"inaccessible."
msgstr ""

#: ../../../filesystems/zonefs.rst:198
msgid ""
"Unaligned write errors: These errors result from the host issuing write "
"requests with a start sector that does not correspond to a zone write "
"pointer position when the write request is executed by the device. Even "
"though zonefs enforces sequential file write for sequential zones, unaligned "
"write errors may still happen in the case of a partial failure of a very "
"large direct I/O operation split into multiple BIOs/requests or asynchronous "
"I/O operations. If one of the write request within the set of sequential "
"write requests issued to the device fails, all write requests queued after "
"it will become unaligned and fail."
msgstr ""

#: ../../../filesystems/zonefs.rst:208
msgid ""
"Delayed write errors: similarly to regular block devices, if the device side "
"write cache is enabled, write errors may occur in ranges of previously "
"completed writes when the device write cache is flushed, e.g. on fsync(). "
"Similarly to the previous immediate unaligned write error case, delayed "
"write errors can propagate through a stream of cached sequential data for a "
"zone causing all data to be dropped after the sector that caused the error."
msgstr ""

#: ../../../filesystems/zonefs.rst:215
msgid ""
"All I/O errors detected by zonefs are notified to the user with an error "
"code return for the system call that triggered or detected the error. The "
"recovery actions taken by zonefs in response to I/O errors depend on the I/O "
"type (read vs write) and on the reason for the error (bad sector, unaligned "
"writes or zone condition change)."
msgstr ""

#: ../../../filesystems/zonefs.rst:221
msgid ""
"For read I/O errors, zonefs does not execute any particular recovery action, "
"but only if the file zone is still in a good condition and there is no "
"inconsistency between the file inode size and its zone write pointer "
"position. If a problem is detected, I/O error recovery is executed (see "
"below table)."
msgstr ""

#: ../../../filesystems/zonefs.rst:226
msgid "For write I/O errors, zonefs I/O error recovery is always executed."
msgstr ""

#: ../../../filesystems/zonefs.rst:228
msgid ""
"A zone condition change to read-only or offline also always triggers zonefs "
"I/O error recovery."
msgstr ""

#: ../../../filesystems/zonefs.rst:231
msgid ""
"Zonefs minimal I/O error recovery may change a file size and file access "
"permissions."
msgstr ""

#: ../../../filesystems/zonefs.rst:234
msgid ""
"File size changes: Immediate or delayed write errors in a sequential zone "
"file may cause the file inode size to be inconsistent with the amount of "
"data successfully written in the file zone. For instance, the partial "
"failure of a multi-BIO large write operation will cause the zone write "
"pointer to advance partially, even though the entire write operation will be "
"reported as failed to the user. In such case, the file inode size must be "
"advanced to reflect the zone write pointer change and eventually allow the "
"user to restart writing at the end of the file. A file size may also be "
"reduced to reflect a delayed write error detected on fsync(): in this case, "
"the amount of data effectively written in the zone may be less than "
"originally indicated by the file inode size. After such I/O error, zonefs "
"always fixes the file inode size to reflect the amount of data persistently "
"stored in the file zone."
msgstr ""

#: ../../../filesystems/zonefs.rst:249
msgid ""
"Access permission changes: A zone condition change to read-only is indicated "
"with a change in the file access permissions to render the file read-only. "
"This disables changes to the file attributes and data modification. For "
"offline zones, all permissions (read and write) to the file are disabled."
msgstr ""

#: ../../../filesystems/zonefs.rst:255
msgid ""
"Further action taken by zonefs I/O error recovery can be controlled by the "
"user with the \"errors=xxx\" mount option. The table below summarizes the "
"result of zonefs I/O error processing depending on the mount option and on "
"the zone conditions::"
msgstr ""

#: ../../../filesystems/zonefs.rst:283
msgid "Further notes:"
msgstr ""

#: ../../../filesystems/zonefs.rst:285
msgid ""
"The \"errors=remount-ro\" mount option is the default behavior of zonefs I/O "
"error processing if no errors mount option is specified."
msgstr ""

#: ../../../filesystems/zonefs.rst:287
msgid ""
"With the \"errors=remount-ro\" mount option, the change of the file access "
"permissions to read-only applies to all files. The file system is remounted "
"read-only."
msgstr ""

#: ../../../filesystems/zonefs.rst:290
msgid ""
"Access permission and file size changes due to the device transitioning "
"zones to the offline condition are permanent. Remounting or reformatting the "
"device with mkfs.zonefs (mkzonefs) will not change back offline zone files "
"to a good state."
msgstr ""

#: ../../../filesystems/zonefs.rst:294
msgid ""
"File access permission changes to read-only due to the device transitioning "
"zones to the read-only condition are permanent. Remounting or reformatting "
"the device will not re-enable file write access."
msgstr ""

#: ../../../filesystems/zonefs.rst:297
msgid ""
"File access permission changes implied by the remount-ro, zone-ro and zone-"
"offline mount options are temporary for zones in a good condition. "
"Unmounting and remounting the file system will restore the previous default "
"(format time values) access rights to the files affected."
msgstr ""

#: ../../../filesystems/zonefs.rst:301
msgid ""
"The repair mount option triggers only the minimal set of I/O error recovery "
"actions, that is, file size fixes for zones in a good condition. Zones "
"indicated as being read-only or offline by the device still imply changes to "
"the zone file access permissions as noted in the table above."
msgstr ""

#: ../../../filesystems/zonefs.rst:307
msgid "Mount options"
msgstr ""

#: ../../../filesystems/zonefs.rst:309
msgid ""
"zonefs defines several mount options: * errors=<behavior> * explicit-open"
msgstr ""

#: ../../../filesystems/zonefs.rst:314
msgid "\"errors=<behavior>\" option"
msgstr ""

#: ../../../filesystems/zonefs.rst:316
msgid ""
"The \"errors=<behavior>\" option mount option allows the user to specify "
"zonefs behavior in response to I/O errors, inode size inconsistencies or "
"zone condition changes. The defined behaviors are as follow:"
msgstr ""

#: ../../../filesystems/zonefs.rst:320
msgid "remount-ro (default)"
msgstr ""

#: ../../../filesystems/zonefs.rst:321
msgid "zone-ro"
msgstr ""

#: ../../../filesystems/zonefs.rst:322
msgid "zone-offline"
msgstr ""

#: ../../../filesystems/zonefs.rst:323
msgid "repair"
msgstr ""

#: ../../../filesystems/zonefs.rst:325
msgid ""
"The run-time I/O error actions defined for each behavior are detailed in the "
"previous section. Mount time I/O errors will cause the mount operation to "
"fail. The handling of read-only zones also differs between mount-time and "
"run-time. If a read-only zone is found at mount time, the zone is always "
"treated in the same manner as offline zones, that is, all accesses are "
"disabled and the zone file size set to 0. This is necessary as the write "
"pointer of read-only zones is defined as invalib by the ZBC and ZAC "
"standards, making it impossible to discover the amount of data that has been "
"written to the zone. In the case of a read-only zone discovered at run-time, "
"as indicated in the previous section. The size of the zone file is left "
"unchanged from its last updated value."
msgstr ""

#: ../../../filesystems/zonefs.rst:337
msgid "\"explicit-open\" option"
msgstr ""

#: ../../../filesystems/zonefs.rst:339
msgid ""
"A zoned block device (e.g. an NVMe Zoned Namespace device) may have limits "
"on the number of zones that can be active, that is, zones that are in the "
"implicit open, explicit open or closed conditions.  This potential "
"limitation translates into a risk for applications to see write IO errors "
"due to this limit being exceeded if the zone of a file is not already active "
"when a write request is issued by the user."
msgstr ""

#: ../../../filesystems/zonefs.rst:346
msgid ""
"To avoid these potential errors, the \"explicit-open\" mount option forces "
"zones to be made active using an open zone command when a file is opened for "
"writing for the first time. If the zone open command succeeds, the "
"application is then guaranteed that write requests can be processed. "
"Conversely, the \"explicit-open\" mount option will result in a zone close "
"command being issued to the device on the last close() of a zone file if the "
"zone is not full nor empty."
msgstr ""

#: ../../../filesystems/zonefs.rst:355
msgid "Runtime sysfs attributes"
msgstr ""

#: ../../../filesystems/zonefs.rst:357
msgid ""
"zonefs defines several sysfs attributes for mounted devices.  All attributes "
"are user readable and can be found in the directory /sys/fs/zonefs/<dev>/, "
"where <dev> is the name of the mounted zoned block device."
msgstr ""

#: ../../../filesystems/zonefs.rst:361
msgid "The attributes defined are as follows."
msgstr ""

#: ../../../filesystems/zonefs.rst:363
msgid ""
"**max_wro_seq_files**:  This attribute reports the maximum number of "
"sequential zone files that can be open for writing.  This number corresponds "
"to the maximum number of explicitly or implicitly open zones that the device "
"supports.  A value of 0 means that the device has no limit and that any zone "
"(any file) can be open for writing and written at any time, regardless of "
"the state of other zones.  When the *explicit-open* mount option is used, "
"zonefs will fail any open() system call requesting to open a sequential zone "
"file for writing when the number of sequential zone files already open for "
"writing has reached the *max_wro_seq_files* limit."
msgstr ""

#: ../../../filesystems/zonefs.rst:372
msgid ""
"**nr_wro_seq_files**:  This attribute reports the current number of "
"sequential zone files open for writing.  When the \"explicit-open\" mount "
"option is used, this number can never exceed *max_wro_seq_files*.  If the "
"*explicit-open* mount option is not used, the reported number can be greater "
"than *max_wro_seq_files*.  In such case, it is the responsibility of the "
"application to not write simultaneously more than *max_wro_seq_files* "
"sequential zone files.  Failure to do so can result in write errors."
msgstr ""

#: ../../../filesystems/zonefs.rst:379
msgid ""
"**max_active_seq_files**:  This attribute reports the maximum number of "
"sequential zone files that are in an active state, that is, sequential zone "
"files that are partially written (not empty nor full) or that have a zone "
"that is explicitly open (which happens only if the *explicit-open* mount "
"option is used).  This number is always equal to the maximum number of "
"active zones that the device supports.  A value of 0 means that the mounted "
"device has no limit on the number of sequential zone files that can be "
"active."
msgstr ""

#: ../../../filesystems/zonefs.rst:386
msgid ""
"**nr_active_seq_files**:  This attributes reports the current number of "
"sequential zone files that are active. If *max_active_seq_files* is not 0, "
"then the value of *nr_active_seq_files* can never exceed the value of "
"*nr_active_seq_files*, regardless of the use of the *explicit-open* mount "
"option."
msgstr ""

#: ../../../filesystems/zonefs.rst:393
msgid "Zonefs User Space Tools"
msgstr ""

#: ../../../filesystems/zonefs.rst:395
msgid ""
"The mkzonefs tool is used to format zoned block devices for use with zonefs. "
"This tool is available on Github at:"
msgstr ""

#: ../../../filesystems/zonefs.rst:398
msgid "https://github.com/damien-lemoal/zonefs-tools"
msgstr ""

#: ../../../filesystems/zonefs.rst:400
msgid ""
"zonefs-tools also includes a test suite which can be run against any zoned "
"block device, including null_blk block device created with zoned mode."
msgstr ""

#: ../../../filesystems/zonefs.rst:404
msgid "Examples"
msgstr ""

#: ../../../filesystems/zonefs.rst:406
msgid ""
"The following formats a 15TB host-managed SMR HDD with 256 MB zones with the "
"conventional zones aggregation feature enabled::"
msgstr ""

#: ../../../filesystems/zonefs.rst:416
msgid ""
"The size of the zone files sub-directories indicate the number of files "
"existing for each type of zones. In this example, there is only one "
"conventional zone file (all conventional zones are aggregated under a single "
"file)::"
msgstr ""

#: ../../../filesystems/zonefs.rst:425
msgid "This aggregated conventional zone file can be used as a regular file::"
msgstr ""

#: ../../../filesystems/zonefs.rst:430
msgid ""
"The \"seq\" sub-directory grouping files for sequential write zones has in "
"this example 55356 zones::"
msgstr ""

#: ../../../filesystems/zonefs.rst:442
msgid ""
"For sequential write zone files, the file size changes as data is appended "
"at the end of the file, similarly to any regular file system::"
msgstr ""

#: ../../../filesystems/zonefs.rst:453
msgid ""
"The written file can be truncated to the zone size, preventing any further "
"write operation::"
msgstr ""

#: ../../../filesystems/zonefs.rst:460
msgid ""
"Truncation to 0 size allows freeing the file zone storage space and restart "
"append-writes to the file::"
msgstr ""

#: ../../../filesystems/zonefs.rst:467
msgid ""
"Since files are statically mapped to zones on the disk, the number of blocks "
"of a file as reported by stat() and fstat() indicates the capacity of the "
"file zone::"
msgstr ""

#: ../../../filesystems/zonefs.rst:481
msgid ""
"The number of blocks of the file (\"Blocks\") in units of 512B blocks gives "
"the maximum file size of 524288 * 512 B = 256 MB, corresponding to the "
"device zone capacity in this example. Of note is that the \"IO block\" field "
"always indicates the minimum I/O size for writes and corresponds to the "
"device physical sector size."
msgstr ""
