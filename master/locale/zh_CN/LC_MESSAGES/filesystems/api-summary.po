# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/api-summary.rst:3
msgid "Linux Filesystems API summary"
msgstr ""

#: ../../../filesystems/api-summary.rst:5
msgid ""
"This section contains API-level documentation, mostly taken from the source "
"code itself."
msgstr ""

#: ../../../filesystems/api-summary.rst:9
msgid "The Linux VFS"
msgstr ""

#: ../../../filesystems/api-summary.rst:12
msgid "The Filesystem types"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:313
msgid "aop return codes with specific semantics"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:317
#: include/linux/fs.h:2439
msgid "**Constants**"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:319
msgid "``AOP_WRITEPAGE_ACTIVATE``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:320
msgid ""
"Informs the caller that page writeback has completed, that the page is still "
"locked, and should be considered active.  The VM uses this hint to return "
"the page to the active list -- it won't be a candidate for writeback again "
"in the near future.  Other callers must be careful to unlock the page if "
"they get this return.  Returned by writepage();"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:329
msgid "``AOP_TRUNCATED_PAGE``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:330
msgid ""
"The AOP method that was handed a locked page has unlocked it and the page "
"might have been truncated. The caller should back up to acquiring a new page "
"and trying again.  The aop will be taking reasonable precautions not to "
"livelock.  If the caller held a page reference, it should drop it before "
"retrying.  Returned by read_folio()."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:180
#: kernel/sysctl.c:627 kernel/sysctl.c:667 kernel/sysctl.c:686
#: kernel/sysctl.c:746 kernel/sysctl.c:812 kernel/sysctl.c:842
#: kernel/sysctl.c:977 kernel/sysctl.c:999 kernel/sysctl.c:1122
#: kernel/sysctl.c:1155 kernel/sysctl.c:1177 kernel/sysctl.c:1199
#: ../../../filesystems/api-summary:113: fs/proc/base.c:3468
#: ../../../filesystems/api-summary:119: fs/eventfd.c:51 fs/eventfd.c:100
#: fs/eventfd.c:191 fs/eventfd.c:317 fs/eventfd.c:343 fs/eventfd.c:361
#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:458
#: fs/sysfs/file.c:482 fs/sysfs/file.c:505 fs/sysfs/file.c:521
#: fs/sysfs/file.c:665 fs/sysfs/file.c:700 fs/sysfs/file.c:747
#: fs/sysfs/file.c:775 fs/sysfs/file.c:804
#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:102
#: fs/sysfs/symlink.c:164 ../../../filesystems/api-summary:143:
#: fs/debugfs/inode.c:3 fs/debugfs/inode.c:341 fs/debugfs/inode.c:499
#: fs/debugfs/inode.c:538 fs/debugfs/inode.c:563 fs/debugfs/inode.c:621
#: fs/debugfs/inode.c:670 fs/debugfs/inode.c:786 fs/debugfs/inode.c:810
#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:149
#: fs/debugfs/file.c:171 fs/debugfs/file.c:190 fs/debugfs/file.c:240
#: fs/debugfs/file.c:602 fs/debugfs/file.c:638 fs/debugfs/file.c:674
#: fs/debugfs/file.c:711 fs/debugfs/file.c:750 fs/debugfs/file.c:1004
#: fs/debugfs/file.c:1132 fs/debugfs/file.c:1194 fs/debugfs/file.c:1289
#: fs/debugfs/file.c:1318 fs/debugfs/file.c:1369
#: ../../../filesystems/api-summary:14: include/linux/fs.h:338
#: include/linux/fs.h:1163 include/linux/fs.h:1638 include/linux/fs.h:1658
#: include/linux/fs.h:1690 include/linux/fs.h:1710 include/linux/fs.h:1727
#: include/linux/fs.h:1741 include/linux/fs.h:1755 include/linux/fs.h:1888
#: include/linux/fs.h:1934 include/linux/fs.h:1947 include/linux/fs.h:1958
#: include/linux/fs.h:1969 include/linux/fs.h:1984 include/linux/fs.h:1999
#: include/linux/fs.h:2011 include/linux/fs.h:2023 include/linux/fs.h:2035
#: include/linux/fs.h:2064 include/linux/fs.h:2088 include/linux/fs.h:2453
#: include/linux/fs.h:2719 include/linux/fs.h:2854 include/linux/fs.h:3104
#: include/linux/fs.h:3125 include/linux/fs.h:3138 include/linux/fs.h:3157
#: include/linux/fs.h:3522 include/linux/fs.h:3534 include/linux/fs.h:3717
#: ../../../filesystems/api-summary:20: fs/dcache.c:585 fs/dcache.c:1004
#: fs/dcache.c:1041 fs/dcache.c:1251 fs/dcache.c:1413 fs/dcache.c:1545
#: fs/dcache.c:1763 fs/dcache.c:1947 fs/dcache.c:2068 fs/dcache.c:2092
#: fs/dcache.c:2115 fs/dcache.c:2327 fs/dcache.c:2458 fs/dcache.c:2497
#: fs/dcache.c:2725 fs/dcache.c:3044 fs/dcache.c:3079
#: ../../../filesystems/api-summary:23: include/linux/dcache.h:316
#: include/linux/dcache.h:333 include/linux/dcache.h:360
#: include/linux/dcache.h:482 include/linux/dcache.h:502
#: include/linux/dcache.h:527 include/linux/dcache.h:539
#: include/linux/dcache.h:551 include/linux/dcache.h:569
#: include/linux/dcache.h:586 ../../../filesystems/api-summary:29:
#: fs/inode.c:223 fs/inode.c:408 fs/inode.c:428 fs/inode.c:446 fs/inode.c:467
#: fs/inode.c:661 fs/inode.c:679 fs/inode.c:861 fs/inode.c:1133 fs/inode.c:1176
#: fs/inode.c:1223 fs/inode.c:1264 fs/inode.c:1338 fs/inode.c:1377
#: fs/inode.c:1417 fs/inode.c:1511 fs/inode.c:1571 fs/inode.c:1601
#: fs/inode.c:1636 fs/inode.c:1669 fs/inode.c:1719 fs/inode.c:1757
#: fs/inode.c:1921 fs/inode.c:1976 fs/inode.c:2039 fs/inode.c:2089
#: fs/inode.c:2264 fs/inode.c:2279 fs/inode.c:2356 fs/inode.c:2423
#: fs/inode.c:2440 fs/inode.c:2595 fs/inode.c:2622 fs/inode.c:2661
#: fs/inode.c:2725 fs/inode.c:2755 fs/inode.c:2838 fs/inode.c:2912
#: fs/inode.c:2935 ../../../filesystems/api-summary:32: fs/bad_inode.c:201
#: fs/bad_inode.c:228 fs/bad_inode.c:242 ../../../filesystems/api-summary:38:
#: fs/super.c:461 fs/super.c:498 fs/super.c:576 fs/super.c:605 fs/super.c:704
#: fs/super.c:947 fs/super.c:1239 fs/super.c:1387 fs/super.c:1736
#: fs/super.c:2017 fs/super.c:2220 ../../../filesystems/api-summary:44:
#: fs/locks.c:327 fs/locks.c:774 fs/locks.c:1391 fs/locks.c:1537
#: fs/locks.c:1652 fs/locks.c:1926 fs/locks.c:2003 fs/locks.c:2101
#: fs/locks.c:2190 fs/locks.c:2321 fs/locks.c:2714 fs/locks.c:2729
#: ../../../filesystems/api-summary:47: fs/locks.c:1411 fs/locks.c:1681
#: fs/locks.c:1735 fs/locks.c:2061 fs/locks.c:2077 fs/locks.c:2125
#: fs/locks.c:2208 ../../../filesystems/api-summary:53: fs/mpage.c:325
#: fs/mpage.c:654 ../../../filesystems/api-summary:56: fs/namei.c:449
#: fs/namei.c:562 fs/namei.c:609 fs/namei.c:622 fs/namei.c:2957 fs/namei.c:2984
#: fs/namei.c:3011 fs/namei.c:3038 fs/namei.c:3066 fs/namei.c:3107
#: fs/namei.c:3137 fs/namei.c:3469 fs/namei.c:4054 fs/namei.c:4289
#: fs/namei.c:4415 fs/namei.c:4517 fs/namei.c:4632 fs/namei.c:4793
#: fs/namei.c:4875 fs/namei.c:5052 fs/namei.c:5433 fs/namei.c:5476
#: fs/namei.c:5534 fs/namei.c:5554 ../../../filesystems/api-summary:59:
#: block/bio.c:295 block/bio.c:333 block/bio.c:481 block/bio.c:603
#: block/bio.c:812 block/bio.c:860 block/bio.c:891 block/bio.c:978
#: block/bio.c:1002 block/bio.c:1019 block/bio.c:1066 block/bio.c:1090
#: block/bio.c:1117 block/bio.c:1373 block/bio.c:1403 block/bio.c:1480
#: block/bio.c:1620 block/bio.c:1683 block/bio.c:1732 block/bio.c:1798
#: ../../../filesystems/api-summary:62: fs/seq_file.c:46 fs/seq_file.c:149
#: fs/seq_file.c:306 fs/seq_file.c:349 fs/seq_file.c:369 fs/seq_file.c:435
#: fs/seq_file.c:467 fs/seq_file.c:496 fs/seq_file.c:821 fs/seq_file.c:964
#: fs/seq_file.c:982 fs/seq_file.c:1000 fs/seq_file.c:1020 fs/seq_file.c:1043
#: fs/seq_file.c:1066 fs/seq_file.c:1092 fs/seq_file.c:1116
#: ../../../filesystems/api-summary:65: fs/filesystems.c:63
#: fs/filesystems.c:100 ../../../filesystems/api-summary:68:
#: fs/fs-writeback.c:810 fs/fs-writeback.c:827 fs/fs-writeback.c:952
#: fs/fs-writeback.c:2515 fs/fs-writeback.c:2796 fs/fs-writeback.c:2813
#: fs/fs-writeback.c:2828 fs/fs-writeback.c:2844 fs/fs-writeback.c:2885
#: fs/fs-writeback.c:2912 ../../../filesystems/api-summary:71:
#: fs/anon_inodes.c:194 fs/anon_inodes.c:219 fs/anon_inodes.c:252
#: fs/anon_inodes.c:316 ../../../filesystems/api-summary:74: fs/attr.c:26
#: fs/attr.c:54 fs/attr.c:146 fs/attr.c:233 fs/attr.c:313 fs/attr.c:397
#: ../../../filesystems/api-summary:77: fs/d_path.c:255
#: ../../../filesystems/api-summary:80: fs/dax.c:743 fs/dax.c:1702
#: fs/dax.c:2070 fs/dax.c:2142 ../../../filesystems/api-summary:83:
#: fs/libfs.c:812 fs/libfs.c:888 fs/libfs.c:1117 fs/libfs.c:1152
#: fs/libfs.c:1187 fs/libfs.c:1421 fs/libfs.c:1463 fs/libfs.c:1495
#: fs/libfs.c:1528 fs/libfs.c:1592 fs/libfs.c:1688 fs/libfs.c:1705
#: fs/libfs.c:1892 fs/libfs.c:1967 fs/libfs.c:1995 fs/libfs.c:2045
#: fs/libfs.c:2125 ../../../filesystems/api-summary:86: fs/posix_acl.c:597
#: fs/posix_acl.c:690 fs/posix_acl.c:755 fs/posix_acl.c:1083
#: fs/posix_acl.c:1160 fs/posix_acl.c:1205 ../../../filesystems/api-summary:89:
#: fs/stat.c:37 fs/stat.c:72 fs/stat.c:121 fs/stat.c:141 fs/stat.c:175
#: ../../../filesystems/api-summary:92: fs/sync.c:175 fs/sync.c:196
#: ../../../filesystems/api-summary:95: fs/xattr.c:466 fs/xattr.c:1135
#: fs/xattr.c:1166 ../../../filesystems/api-summary:98: fs/namespace.c:440
#: fs/namespace.c:499 fs/namespace.c:543 fs/namespace.c:564 fs/namespace.c:580
#: fs/namespace.c:1181 fs/namespace.c:1453 fs/namespace.c:1587
#: fs/namespace.c:1615 fs/namespace.c:2362
msgid "**Description**"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:331
msgid ""
"address_space_operation functions return these large constants to indicate "
"special semantics to the caller.  These are much larger than the bytes in a "
"page to allow for functions that return the number of bytes operated on in a "
"given page."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:485
#: include/linux/fs.h:1189
msgid "Contents of a cacheable, mappable object."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:489
#: include/linux/fs.h:1154 include/linux/fs.h:1188 include/linux/fs.h:2132
msgid "**Definition**::"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:512
#: include/linux/fs.h:1166 include/linux/fs.h:1227 include/linux/fs.h:2144
msgid "**Members**"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:486
msgid "``host``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:487
msgid "Owner, either the inode or the block_device."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:487
msgid "``i_pages``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:488
msgid "Cached pages."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:488
msgid "``invalidate_lock``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:489
msgid ""
"Guards coherency between page cache contents and file offset->disk block "
"mappings in the filesystem during invalidates. It is also used to block "
"modification of page cache contents through memory mappings."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:492
msgid "``gfp_mask``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:493
msgid "Memory allocation flags to use for allocating pages."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:493
msgid "``i_mmap_writable``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:494
msgid "Number of VM_SHARED, VM_MAYWRITE mappings."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:494
msgid "``nr_thps``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:495
msgid "Number of THPs in the pagecache (non-shmem only)."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:495
msgid "``i_mmap``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:496
msgid "Tree of private and shared mappings."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:497
msgid "``nrpages``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:498
msgid "Number of page entries, protected by the i_pages lock."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:498
msgid "``writeback_index``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:499
msgid "Writeback starts here."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:499
msgid "``a_ops``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:500
msgid "Methods."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:500
#: include/linux/fs.h:2135
msgid "``flags``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:501
msgid "Error bits and flags (AS_*)."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:501
msgid "``wb_err``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:502
msgid "The most recent error which has occurred."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:502
msgid "``i_private_lock``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:503
#: include/linux/fs.h:504 include/linux/fs.h:505
msgid "For use by the owner of the address_space."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:503
msgid "``i_private_list``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:496
msgid "``i_mmap_rwsem``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:497
msgid "Protects **i_mmap** and **i_mmap_writable**."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:504
msgid "``i_private_data``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1150
msgid "Track a file's readahead state."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1151
msgid "``start``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1152
msgid "Where the most recent readahead started."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1152
msgid "``size``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1153
msgid "Number of pages read in the most recent readahead."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1153
msgid "``async_size``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1154
msgid ""
"Numer of pages that were/are not needed immediately and so were/are "
"genuinely \"ahead\".  Start next readahead when the first of these pages is "
"accessed."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1156
msgid "``ra_pages``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1157
msgid "Maximum size of a readahead request, copied from the bdi."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1157
msgid "``order``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1158
msgid "Preferred folio order used for most recent readahead."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1158
msgid "``mmap_miss``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1159
msgid "How many mmap accesses missed in the page cache."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1159
msgid "``prev_pos``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1160
msgid "The last byte in the most recent read request."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1160
msgid ""
"When this structure is passed to ->readahead(), the \"most recent\" "
"readahead means the current readahead."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1184
msgid "Represents a file"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1185
msgid "``f_lock``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1186
msgid "Protects f_ep, f_flags. Must not be taken from IRQ context."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1186
msgid "``f_mode``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1187
msgid "FMODE_* flags often used in hotpaths"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1187
msgid "``f_op``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1188
msgid "file operations"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1188
msgid "``f_mapping``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1189
msgid "``private_data``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1190
msgid "filesystem or driver specific data"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1190
msgid "``f_inode``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1191
msgid "cached inode"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1191
msgid "``f_flags``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1192
msgid "file flags"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1192
msgid "``f_iocb_flags``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1193
msgid "iocb flags"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1193
msgid "``f_cred``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1194
msgid "stashed credentials of creator/opener"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1194
msgid "``f_owner``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1195
msgid "file owner"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2
msgid "anonymous"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1195
msgid "``f_path``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1196
msgid "path of the file"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1196
msgid "``__f_path``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1197
msgid ""
"writable alias for **f_path**; *ONLY* for core VFS and only before the file "
"gets open"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1198
msgid "``f_pos_lock``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1199
msgid "lock protecting file position"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1199
msgid "``f_pipe``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1200
msgid "specific to pipes"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1200
msgid "``f_pos``"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:178
#: kernel/sysctl.c:625 kernel/sysctl.c:665 kernel/sysctl.c:684
#: kernel/sysctl.c:744 kernel/sysctl.c:810 kernel/sysctl.c:840
#: kernel/sysctl.c:975 kernel/sysctl.c:997 kernel/sysctl.c:1120
#: kernel/sysctl.c:1197 ../../../filesystems/api-summary:14:
#: include/linux/fs.h:1201
msgid "file position"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1201
msgid "``f_security``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1202
msgid "LSM security context of this file"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1202
msgid "``f_wb_err``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1203
msgid "writeback error"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1203
msgid "``f_sb_err``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1204
msgid "per sb writeback errors"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1204
msgid "``f_ep``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1205
msgid "link of all epoll hooks for this file"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1205
msgid "``f_task_work``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1206
msgid "task work entry point"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1206
msgid "``f_llist``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1207
msgid "work queue entrypoint"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1207
msgid "``f_ra``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1208
msgid "file's readahead state"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1208
msgid "``f_freeptr``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1209
msgid "Pointer used by SLAB_TYPESAFE_BY_RCU file cache (don't touch.)"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1209
msgid "``f_ref``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1210
msgid "reference count"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1619
msgid "map an inode's i_uid down according to an idmapping"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:177
#: kernel/sysctl.c:624 kernel/sysctl.c:664 kernel/sysctl.c:683
#: kernel/sysctl.c:743 kernel/sysctl.c:809 kernel/sysctl.c:839
#: kernel/sysctl.c:974 kernel/sysctl.c:996 kernel/sysctl.c:1119
#: kernel/sysctl.c:1152 kernel/sysctl.c:1174 kernel/sysctl.c:1196
#: ../../../filesystems/api-summary:113: fs/proc/base.c:3469
#: ../../../filesystems/api-summary:119: fs/eventfd.c:51 fs/eventfd.c:101
#: fs/eventfd.c:190 fs/eventfd.c:318 fs/eventfd.c:344 fs/eventfd.c:362
#: ../../../filesystems/api-summary:125: fs/eventpoll.c:387 fs/eventpoll.c:402
#: fs/eventpoll.c:1468 fs/eventpoll.c:1924 fs/eventpoll.c:2061
#: fs/eventpoll.c:2126 ../../../filesystems/api-summary:131:
#: fs/sysfs/file.c:363 fs/sysfs/file.c:397 fs/sysfs/file.c:430
#: fs/sysfs/file.c:458 fs/sysfs/file.c:483 fs/sysfs/file.c:504
#: fs/sysfs/file.c:521 fs/sysfs/file.c:554 fs/sysfs/file.c:579
#: fs/sysfs/file.c:599 fs/sysfs/file.c:663 fs/sysfs/file.c:699
#: fs/sysfs/file.c:746 fs/sysfs/file.c:772 fs/sysfs/file.c:800
#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:88
#: fs/sysfs/symlink.c:101 fs/sysfs/symlink.c:143 fs/sysfs/symlink.c:161
#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:341
#: fs/debugfs/inode.c:491 fs/debugfs/inode.c:529 fs/debugfs/inode.c:560
#: fs/debugfs/inode.c:617 fs/debugfs/inode.c:664 fs/debugfs/inode.c:786
#: fs/debugfs/inode.c:810 fs/debugfs/inode.c:832 fs/debugfs/inode.c:898
#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:150
#: fs/debugfs/file.c:171 fs/debugfs/file.c:189 fs/debugfs/file.c:239
#: fs/debugfs/file.c:597 fs/debugfs/file.c:633 fs/debugfs/file.c:669
#: fs/debugfs/file.c:706 fs/debugfs/file.c:744 fs/debugfs/file.c:794
#: fs/debugfs/file.c:812 fs/debugfs/file.c:830 fs/debugfs/file.c:848
#: fs/debugfs/file.c:882 fs/debugfs/file.c:917 fs/debugfs/file.c:999
#: fs/debugfs/file.c:1127 fs/debugfs/file.c:1188 fs/debugfs/file.c:1284
#: fs/debugfs/file.c:1315 fs/debugfs/file.c:1363 fs/debugfs/file.c:1408
#: ../../../filesystems/api-summary:14: include/linux/fs.h:1623
#: include/linux/fs.h:1637 include/linux/fs.h:1657 include/linux/fs.h:1675
#: include/linux/fs.h:1689 include/linux/fs.h:1709 include/linux/fs.h:1727
#: include/linux/fs.h:1741 include/linux/fs.h:1755 include/linux/fs.h:1887
#: include/linux/fs.h:1934 include/linux/fs.h:1948 include/linux/fs.h:1959
#: include/linux/fs.h:1970 include/linux/fs.h:1985 include/linux/fs.h:2000
#: include/linux/fs.h:2012 include/linux/fs.h:2024 include/linux/fs.h:2036
#: include/linux/fs.h:2065 include/linux/fs.h:2089 include/linux/fs.h:2720
#: include/linux/fs.h:2855 include/linux/fs.h:3105 include/linux/fs.h:3126
#: include/linux/fs.h:3139 include/linux/fs.h:3158 include/linux/fs.h:3280
#: include/linux/fs.h:3291 include/linux/fs.h:3523 include/linux/fs.h:3535
#: include/linux/fs.h:3708 ../../../filesystems/api-summary:20: fs/dcache.c:586
#: fs/dcache.c:1005 fs/dcache.c:1042 fs/dcache.c:1252 fs/dcache.c:1413
#: fs/dcache.c:1546 fs/dcache.c:1644 fs/dcache.c:1763 fs/dcache.c:1947
#: fs/dcache.c:2069 fs/dcache.c:2093 fs/dcache.c:2114 fs/dcache.c:2168
#: fs/dcache.c:2326 fs/dcache.c:2459 fs/dcache.c:2498 fs/dcache.c:2725
#: fs/dcache.c:3044 fs/dcache.c:3079 ../../../filesystems/api-summary:23:
#: include/linux/dcache.h:317 include/linux/dcache.h:334
#: include/linux/dcache.h:361 include/linux/dcache.h:483
#: include/linux/dcache.h:503 include/linux/dcache.h:528
#: include/linux/dcache.h:540 include/linux/dcache.h:552
#: include/linux/dcache.h:569 include/linux/dcache.h:587
#: ../../../filesystems/api-summary:29: fs/inode.c:222 fs/inode.c:409
#: fs/inode.c:429 fs/inode.c:446 fs/inode.c:468 fs/inode.c:625 fs/inode.c:660
#: fs/inode.c:680 fs/inode.c:862 fs/inode.c:1134 fs/inode.c:1177
#: fs/inode.c:1219 fs/inode.c:1243 fs/inode.c:1261 fs/inode.c:1335
#: fs/inode.c:1374 fs/inode.c:1417 fs/inode.c:1511 fs/inode.c:1569
#: fs/inode.c:1599 fs/inode.c:1636 fs/inode.c:1667 fs/inode.c:1717
#: fs/inode.c:1757 fs/inode.c:1922 fs/inode.c:1976 fs/inode.c:2039
#: fs/inode.c:2089 fs/inode.c:2265 fs/inode.c:2280 fs/inode.c:2357
#: fs/inode.c:2424 fs/inode.c:2441 fs/inode.c:2593 fs/inode.c:2622
#: fs/inode.c:2662 fs/inode.c:2725 fs/inode.c:2756 fs/inode.c:2838
#: fs/inode.c:2911 fs/inode.c:2934 ../../../filesystems/api-summary:32:
#: fs/bad_inode.c:202 fs/bad_inode.c:229 fs/bad_inode.c:243
#: ../../../filesystems/api-summary:38: fs/super.c:462 fs/super.c:499
#: fs/super.c:577 fs/super.c:606 fs/super.c:703 fs/super.c:812 fs/super.c:946
#: fs/super.c:1240 fs/super.c:1387 fs/super.c:1658 fs/super.c:1710
#: fs/super.c:1737 fs/super.c:2016 fs/super.c:2219
#: ../../../filesystems/api-summary:44: fs/locks.c:327 fs/locks.c:775
#: fs/locks.c:1390 fs/locks.c:1534 fs/locks.c:1652 fs/locks.c:1923
#: fs/locks.c:2000 fs/locks.c:2101 fs/locks.c:2190 fs/locks.c:2319
#: fs/locks.c:2714 fs/locks.c:2730 ../../../filesystems/api-summary:47:
#: fs/locks.c:1411 fs/locks.c:1682 fs/locks.c:1732 fs/locks.c:2060
#: fs/locks.c:2077 fs/locks.c:2125 fs/locks.c:2208
#: ../../../filesystems/api-summary:53: fs/mpage.c:325 fs/mpage.c:653
#: ../../../filesystems/api-summary:56: fs/namei.c:447 fs/namei.c:561
#: fs/namei.c:610 fs/namei.c:623 fs/namei.c:2876 fs/namei.c:2894
#: fs/namei.c:2957 fs/namei.c:2984 fs/namei.c:3010 fs/namei.c:3037
#: fs/namei.c:3065 fs/namei.c:3106 fs/namei.c:3137 fs/namei.c:3466
#: fs/namei.c:4051 fs/namei.c:4286 fs/namei.c:4413 fs/namei.c:4516
#: fs/namei.c:4630 fs/namei.c:4791 fs/namei.c:4872 fs/namei.c:5053
#: fs/namei.c:5432 fs/namei.c:5476 fs/namei.c:5533 fs/namei.c:5555
#: ../../../filesystems/api-summary:59: block/bio.c:294 block/bio.c:333
#: block/bio.c:478 block/bio.c:603 block/bio.c:813 block/bio.c:858
#: block/bio.c:889 block/bio.c:976 block/bio.c:1001 block/bio.c:1017
#: block/bio.c:1064 block/bio.c:1089 block/bio.c:1116 block/bio.c:1374
#: block/bio.c:1400 block/bio.c:1481 block/bio.c:1621 block/bio.c:1681
#: block/bio.c:1731 block/bio.c:1795 ../../../filesystems/api-summary:62:
#: fs/seq_file.c:46 fs/seq_file.c:147 fs/seq_file.c:305 fs/seq_file.c:349
#: fs/seq_file.c:366 fs/seq_file.c:434 fs/seq_file.c:466 fs/seq_file.c:495
#: fs/seq_file.c:820 fs/seq_file.c:840 fs/seq_file.c:964 fs/seq_file.c:982
#: fs/seq_file.c:999 fs/seq_file.c:1020 fs/seq_file.c:1043 fs/seq_file.c:1065
#: fs/seq_file.c:1091 fs/seq_file.c:1114 ../../../filesystems/api-summary:65:
#: fs/filesystems.c:64 fs/filesystems.c:101
#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:810
#: fs/fs-writeback.c:828 fs/fs-writeback.c:951 fs/fs-writeback.c:2512
#: fs/fs-writeback.c:2795 fs/fs-writeback.c:2813 fs/fs-writeback.c:2828
#: fs/fs-writeback.c:2845 fs/fs-writeback.c:2885 fs/fs-writeback.c:2912
#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:189
#: fs/anon_inodes.c:213 fs/anon_inodes.c:245 fs/anon_inodes.c:311
#: ../../../filesystems/api-summary:74: fs/attr.c:25 fs/attr.c:53 fs/attr.c:145
#: fs/attr.c:233 fs/attr.c:312 fs/attr.c:395
#: ../../../filesystems/api-summary:77: fs/d_path.c:254
#: ../../../filesystems/api-summary:80: fs/dax.c:741 fs/dax.c:1701
#: fs/dax.c:2067 fs/dax.c:2141 ../../../filesystems/api-summary:83:
#: fs/libfs.c:810 fs/libfs.c:887 fs/libfs.c:1114 fs/libfs.c:1149
#: fs/libfs.c:1184 fs/libfs.c:1419 fs/libfs.c:1460 fs/libfs.c:1492
#: fs/libfs.c:1525 fs/libfs.c:1569 fs/libfs.c:1592 fs/libfs.c:1686
#: fs/libfs.c:1704 fs/libfs.c:1798 fs/libfs.c:1854 fs/libfs.c:1886
#: fs/libfs.c:1967 fs/libfs.c:1995 fs/libfs.c:2046 fs/libfs.c:2126
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:595 fs/posix_acl.c:688
#: fs/posix_acl.c:754 fs/posix_acl.c:1081 fs/posix_acl.c:1159
#: fs/posix_acl.c:1204 ../../../filesystems/api-summary:89: fs/stat.c:36
#: fs/stat.c:70 fs/stat.c:121 fs/stat.c:139 fs/stat.c:173
#: ../../../filesystems/api-summary:92: fs/sync.c:173 fs/sync.c:196
#: ../../../filesystems/api-summary:95: fs/xattr.c:266 fs/xattr.c:465
#: fs/xattr.c:528 fs/xattr.c:1134 fs/xattr.c:1165
#: ../../../filesystems/api-summary:98: fs/namespace.c:441 fs/namespace.c:500
#: fs/namespace.c:544 fs/namespace.c:565 fs/namespace.c:581 fs/namespace.c:1182
#: fs/namespace.c:1454 fs/namespace.c:1588 fs/namespace.c:1616
#: fs/namespace.c:2363 fs/namespace.c:3792
msgid "**Parameters**"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1625
#: include/linux/fs.h:1639 include/linux/fs.h:1659 include/linux/fs.h:1677
#: include/linux/fs.h:1691 include/linux/fs.h:1711 include/linux/fs.h:1726
#: include/linux/fs.h:1740 include/linux/fs.h:1754
#: ../../../filesystems/api-summary:29: fs/inode.c:2595 fs/inode.c:2624
#: fs/inode.c:2913 fs/inode.c:2936 ../../../filesystems/api-summary:56:
#: fs/namei.c:449 fs/namei.c:563 fs/namei.c:3012 fs/namei.c:3039
#: fs/namei.c:3067 fs/namei.c:3108 fs/namei.c:3468 fs/namei.c:4053
#: fs/namei.c:4288 fs/namei.c:4415 fs/namei.c:4518 fs/namei.c:4632
#: fs/namei.c:4793 fs/namei.c:4871 ../../../filesystems/api-summary:74:
#: fs/attr.c:27 fs/attr.c:55 fs/attr.c:147 fs/attr.c:314 fs/attr.c:397
#: ../../../filesystems/api-summary:83: fs/libfs.c:889
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:597 fs/posix_acl.c:690
#: fs/posix_acl.c:1083 fs/posix_acl.c:1161 fs/posix_acl.c:1206
#: ../../../filesystems/api-summary:89: fs/stat.c:72
#: ../../../filesystems/api-summary:95: fs/xattr.c:268 fs/xattr.c:530
msgid "``struct mnt_idmap *idmap``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1620
#: include/linux/fs.h:1634 include/linux/fs.h:1654 include/linux/fs.h:1672
#: include/linux/fs.h:1686 include/linux/fs.h:1706 include/linux/fs.h:1725
#: include/linux/fs.h:1739 ../../../filesystems/api-summary:29: fs/inode.c:2619
#: ../../../filesystems/api-summary:56: fs/namei.c:444 fs/namei.c:558
#: fs/namei.c:3463 fs/namei.c:4048 fs/namei.c:4283 fs/namei.c:4410
#: fs/namei.c:4513 fs/namei.c:4627 fs/namei.c:4788
#: ../../../filesystems/api-summary:74: fs/attr.c:142 fs/attr.c:309
#: fs/attr.c:392 ../../../filesystems/api-summary:89: fs/stat.c:67
msgid "idmap of the mount the inode was found from"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1622
#: include/linux/fs.h:1637 include/linux/fs.h:1674 include/linux/fs.h:1689
#: include/linux/fs.h:2722 ../../../filesystems/api-summary:29: fs/inode.c:2621
#: fs/inode.c:2910 ../../../filesystems/api-summary:74: fs/attr.c:25
#: fs/attr.c:235
msgid "``const struct inode *inode``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1621
#: include/linux/fs.h:1673
msgid "inode to map"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:3 fs/eventpoll.c:387
#: fs/eventpoll.c:405 fs/eventpoll.c:1933 fs/eventpoll.c:2064
#: fs/eventpoll.c:2129 ../../../filesystems/api-summary:14:
#: include/linux/fs.h:1623 include/linux/fs.h:1640 include/linux/fs.h:1675
#: include/linux/fs.h:1692 include/linux/fs.h:1758 include/linux/fs.h:2855
#: include/linux/fs.h:3712 ../../../filesystems/api-summary:20:
#: fs/dcache.c:2169 fs/dcache.c:2326 ../../../filesystems/api-summary:29:
#: fs/inode.c:2266 fs/inode.c:2363 fs/inode.c:2428 fs/inode.c:2445
#: fs/inode.c:2915 fs/inode.c:2940 ../../../filesystems/api-summary:38:
#: fs/super.c:726 fs/super.c:1244 fs/super.c:1398 fs/super.c:2063
#: ../../../filesystems/api-summary:56: fs/namei.c:5536
#: ../../../filesystems/api-summary:59: block/bio.c:504 block/bio.c:611
#: block/bio.c:1070 ../../../filesystems/api-summary:74: fs/attr.c:30
#: fs/attr.c:59 fs/attr.c:241 ../../../filesystems/api-summary:83:
#: fs/libfs.c:1710 fs/libfs.c:1800 fs/libfs.c:1854 fs/libfs.c:1895
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:769 fs/posix_acl.c:1085
#: fs/posix_acl.c:1162 fs/posix_acl.c:1206 ../../../filesystems/api-summary:95:
#: fs/xattr.c:478
msgid "**Return**"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1623
msgid ""
"whe inode's i_uid mapped down according to **idmap**. If the inode's i_uid "
"has no mapping INVALID_VFSUID is returned."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1633
msgid "check whether inode's i_uid needs to be updated"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1636
#: include/linux/fs.h:1656 include/linux/fs.h:1688 include/linux/fs.h:1708
#: ../../../filesystems/api-summary:74: fs/attr.c:312
msgid "``const struct iattr *attr``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1635
#: include/linux/fs.h:1655 include/linux/fs.h:1687 include/linux/fs.h:1707
msgid "the new attributes of **inode**"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1636
#: include/linux/fs.h:1656 include/linux/fs.h:1688 include/linux/fs.h:1708
msgid "the inode to update"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1637
msgid ""
"Check whether the $inode's i_uid field needs to be updated taking idmapped "
"mounts into account if the filesystem supports it."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1641
msgid "true if **inode**'s i_uid field needs to be updated, false if not."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1653
msgid "update **inode**'s i_uid field"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1657
#: include/linux/fs.h:1709 include/linux/fs.h:1729 include/linux/fs.h:1743
#: include/linux/fs.h:1889 include/linux/fs.h:3525 include/linux/fs.h:3537
#: ../../../filesystems/api-summary:20: fs/dcache.c:1007 fs/dcache.c:1044
#: fs/dcache.c:2071 fs/dcache.c:2095 fs/dcache.c:2113 fs/dcache.c:2724
#: fs/dcache.c:3046 ../../../filesystems/api-summary:29: fs/inode.c:221
#: fs/inode.c:411 fs/inode.c:431 fs/inode.c:448 fs/inode.c:470 fs/inode.c:627
#: fs/inode.c:662 fs/inode.c:682 fs/inode.c:1179 fs/inode.c:1263
#: fs/inode.c:1924 fs/inode.c:1978 fs/inode.c:2041 fs/inode.c:2091
#: fs/inode.c:2282 fs/inode.c:2592 fs/inode.c:2664 fs/inode.c:2724
#: fs/inode.c:2758 fs/inode.c:2840 ../../../filesystems/api-summary:32:
#: fs/bad_inode.c:204 fs/bad_inode.c:231 fs/bad_inode.c:245
#: ../../../filesystems/api-summary:44: fs/locks.c:1536 fs/locks.c:1654
#: fs/locks.c:2103 fs/locks.c:2732 ../../../filesystems/api-summary:47:
#: fs/locks.c:1413 fs/locks.c:2079 ../../../filesystems/api-summary:56:
#: fs/namei.c:446 fs/namei.c:560 fs/namei.c:5532
#: ../../../filesystems/api-summary:62: fs/seq_file.c:351
#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:809
#: fs/fs-writeback.c:2514 fs/fs-writeback.c:2887 fs/fs-writeback.c:2914
#: ../../../filesystems/api-summary:74: fs/attr.c:53 fs/attr.c:311
#: ../../../filesystems/api-summary:83: fs/libfs.c:1421 fs/libfs.c:1703
#: fs/libfs.c:1997 fs/libfs.c:2048 fs/libfs.c:2128
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:687
#: ../../../filesystems/api-summary:89: fs/stat.c:36 fs/stat.c:70 fs/stat.c:123
msgid "``struct inode *inode``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1657
msgid ""
"Safely update **inode**'s i_uid field translating the vfsuid of any idmapped "
"mount into the filesystem kuid."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1671
msgid "map an inode's i_gid down according to an idmapping"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1675
msgid ""
"the inode's i_gid mapped down according to **idmap**. If the inode's i_gid "
"has no mapping INVALID_VFSGID is returned."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1685
msgid "check whether inode's i_gid needs to be updated"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1689
msgid ""
"Check whether the $inode's i_gid field needs to be updated taking idmapped "
"mounts into account if the filesystem supports it."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1693
msgid "true if **inode**'s i_gid field needs to be updated, false if not."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1705
msgid "update **inode**'s i_gid field"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1709
msgid ""
"Safely update **inode**'s i_gid field translating the vfsgid of any idmapped "
"mount into the filesystem kgid."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1723
msgid "initialize inode's i_uid field with callers fsuid"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1724
#: include/linux/fs.h:1738
msgid "inode to initialize"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1726
msgid ""
"Initialize the i_uid field of **inode**. If the inode was found/created via "
"an idmapped mount map the caller's fsuid according to **idmap**."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1737
msgid "initialize inode's i_gid field with callers fsgid"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1740
msgid ""
"Initialize the i_gid field of **inode**. If the inode was found/created via "
"an idmapped mount map the caller's fsgid according to **idmap**."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1751
msgid "check whether caller's fsuid/fsgid is mapped"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1757
#: include/linux/fs.h:2002 include/linux/fs.h:2014 include/linux/fs.h:2026
#: include/linux/fs.h:2038 include/linux/fs.h:2067 include/linux/fs.h:2091
#: ../../../filesystems/api-summary:20: fs/dcache.c:1254
#: ../../../filesystems/api-summary:29: fs/inode.c:224 fs/inode.c:864
#: fs/inode.c:1136 fs/inode.c:1337 fs/inode.c:1376 fs/inode.c:1419
#: fs/inode.c:1513 fs/inode.c:1571 fs/inode.c:1601 fs/inode.c:1638
#: fs/inode.c:1669 fs/inode.c:1719 fs/inode.c:1759
#: ../../../filesystems/api-summary:38: fs/super.c:579 fs/super.c:608
#: fs/super.c:2018 fs/super.c:2221 ../../../filesystems/api-summary:68:
#: fs/fs-writeback.c:2797 fs/fs-writeback.c:2815 fs/fs-writeback.c:2830
#: fs/fs-writeback.c:2847 ../../../filesystems/api-summary:83: fs/libfs.c:1462
#: fs/libfs.c:1494 fs/libfs.c:1969
msgid "``struct super_block *sb``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1752
msgid "the superblock we want a mapping in"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1753
msgid "idmap of the relevant mount"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1754
msgid ""
"Check whether the caller's fsuid and fsgid have a valid mapping in the "
"s_user_ns of the superblock **sb**. If the caller is on an idmapped mount "
"map the caller's fsuid and fsgid according to the **idmap** first."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1759
msgid "true if fsuid and fsgid is mapped, false if not."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1883
msgid "set the ctime in the inode"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1884
msgid "inode in which to set the ctime"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1886
msgid "``time64_t sec``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1885
msgid "tv_sec value to set"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1887
msgid "``long nsec``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1886
msgid "tv_nsec value to set"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1887
msgid "Set the ctime in **inode** to { **sec**, **nsec** }"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1930
msgid "check if sb freeze level is held"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1936
#: include/linux/fs.h:1950 include/linux/fs.h:1961
msgid "``const struct super_block *sb``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1931
#: include/linux/fs.h:1945 include/linux/fs.h:1956 include/linux/fs.h:2033
#: include/linux/fs.h:2062 include/linux/fs.h:2086
msgid "the super we write to"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1933
msgid "``int level``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1932
msgid "the freeze level"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1933
msgid "> 0 - sb freeze level is held"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1934
msgid "0 - sb freeze level is not held"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1935
msgid "< 0 - !CONFIG_LOCKDEP/LOCK_STATE_UNKNOWN"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1944
#: include/linux/fs.h:1966
msgid "check if SB_FREEZE_WRITE is held"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1946
#: include/linux/fs.h:1957
msgid "May be false positive with !CONFIG_LOCKDEP/LOCK_STATE_UNKNOWN."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1955
#: include/linux/fs.h:1981
msgid "check if SB_FREEZE_WRITE is not held"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1972
#: include/linux/fs.h:1987
msgid "``const struct file *file``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1967
#: include/linux/fs.h:1982
msgid "the file we write to"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1968
#: include/linux/fs.h:1983
msgid ""
"May be false positive with !CONFIG_LOCKDEP/LOCK_STATE_UNKNOWN. May be false "
"positive with !S_ISREG, because file_start_write() has no effect on !S_ISREG."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1996
msgid "drop write access to a superblock"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1997
#: include/linux/fs.h:2009 include/linux/fs.h:2021
msgid "the super we wrote to"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:1998
msgid ""
"Decrement number of writers to the filesystem. Wake up possible waiters "
"wanting to freeze the filesystem."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2008
msgid "drop write access to a superblock from a page fault"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2010
msgid ""
"Decrement number of processes handling write page fault to the filesystem. "
"Wake up possible waiters wanting to freeze the filesystem."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2020
msgid "drop write access to a superblock for internal fs purposes"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2022
msgid ""
"Decrement fs-internal number of writers to the filesystem.  Wake up possible "
"waiters wanting to freeze the filesystem."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2032
msgid "get write access to a superblock"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2034
msgid ""
"When a process wants to write data or metadata to a file system (i.e. dirty "
"a page or an inode), it should embed the operation in a sb_start_write() - "
"sb_end_write() pair to get exclusion against file system freezing. This "
"function increments number of writers preventing freezing. If the file "
"system is already frozen, the function waits until the file system is thawed."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2041
msgid ""
"Since freeze protection behaves as a lock, users have to preserve ordering "
"of freeze protection and other filesystem locks. Generally, freeze "
"protection should be the outermost lock. In particular, we have:"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2045
msgid "sb_start_write"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2046
msgid ""
"-> i_rwsem                 (write path, truncate, directory ops, ...) -> "
"s_umount                (freeze_super, thaw_super)"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2061
msgid "get write access to a superblock from a page fault"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2063
msgid ""
"When a process starts handling write page fault, it should embed the "
"operation into sb_start_pagefault() - sb_end_pagefault() pair to get "
"exclusion against file system freezing. This is needed since the page fault "
"is going to dirty a page. This function increments number of running page "
"faults preventing freezing. If the file system is already frozen, the "
"function waits until the file system is thawed."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2070
msgid ""
"Since page fault freeze protection behaves as a lock, users have to preserve "
"ordering of freeze protection and other filesystem locks. It is advised to "
"put sb_start_pagefault() close to mmap_lock in lock ordering. Page fault "
"handling code implies lock dependency:"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2075
msgid "mmap_lock"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2076
msgid "-> sb_start_pagefault"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2085
msgid "get write access to a superblock for internal fs purposes"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2087
msgid ""
"This is the third level of protection against filesystem freezing. It is "
"free for use by a filesystem. The only requirement is that it must rank "
"below sb_start_pagefault."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2091
msgid ""
"For example filesystem can call sb_start_intwrite() when starting a "
"transaction which somewhat eases handling of freezing for internal sources "
"of filesystem changes (internal fs threads, discarding preallocation on file "
"close, etc.)."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2128
msgid "contains all information required for renaming"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2129
msgid "``mnt_idmap``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2130
msgid "idmap of the mount in which the rename is happening."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2130
msgid "``old_parent``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2131
msgid "parent of source"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2131
msgid "``old_dentry``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2132
msgid "source"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2132
msgid "``new_parent``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2133
msgid "parent of destination"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2133
msgid "``new_dentry``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2134
msgid "destination"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2134
msgid "``delegated_inode``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2135
msgid "returns an inode needing a delegation break"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2136
msgid "rename flags"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2435
msgid "holder of the freeze"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2441
msgid "``FREEZE_HOLDER_KERNEL``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2442
msgid "kernel wants to freeze or thaw filesystem"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2444
msgid "``FREEZE_HOLDER_USERSPACE``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2445
msgid "userspace wants to freeze or thaw filesystem"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2447
msgid "``FREEZE_MAY_NEST``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2448
msgid "whether nesting freeze and thaw requests is allowed"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2450
msgid "``FREEZE_EXCL``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2451
msgid "a freeze that can only be undone by the owner"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2440
msgid ""
"Indicate who the owner of the freeze or thaw request is and whether the "
"freeze needs to be exclusive or can nest. Without **FREEZE_MAY_NEST**, "
"multiple freeze and thaw requests from the same holder aren't allowed. It is "
"however allowed to hold a single **FREEZE_HOLDER_USERSPACE** and a single "
"**FREEZE_HOLDER_KERNEL** freeze at the same time. This is relied upon by "
"some filesystems during online repair or similar."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2716
msgid "is this inode using multigrain timestamps"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2717
msgid "inode to test for multigrain timestamps"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2718
msgid "Return true if the inode uses multigrain timestamps, false otherwise."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2851
msgid "check whether a mount is mapped"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2857
msgid "``const struct vfsmount *mnt``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2852
msgid "the mount to check"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2853
msgid ""
"If **mnt** has an non **nop_mnt_idmap** attached to it then **mnt** is "
"mapped."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:2856
msgid "true if mount is mapped, false if not."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3101
msgid "get write access to a superblock for regular file io"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:364
#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:802
#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:191
#: fs/debugfs/file.c:241 ../../../filesystems/api-summary:14:
#: include/linux/fs.h:3107 include/linux/fs.h:3128
#: ../../../filesystems/api-summary:29: fs/inode.c:2267 fs/inode.c:2359
#: fs/inode.c:2426 ../../../filesystems/api-summary:62: fs/seq_file.c:48
#: fs/seq_file.c:149 fs/seq_file.c:307 fs/seq_file.c:348 fs/seq_file.c:494
#: ../../../filesystems/api-summary:83: fs/libfs.c:1527 fs/libfs.c:1571
#: ../../../filesystems/api-summary:92: fs/sync.c:175 fs/sync.c:198
#: ../../../filesystems/api-summary:98: fs/namespace.c:546
msgid "``struct file *file``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3102
msgid "the file we want to write to"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3103
msgid ""
"This is a variant of sb_start_write() which is a noop on non-regualr file. "
"Should be matched with a call to file_end_write()."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3122
msgid "drop write access to a superblock of a regular file"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3123
msgid "the file we wrote to"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3124
msgid "Should be matched with a call to file_start_write()."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3135
msgid "get write access to a superblock for async file io"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3141
#: include/linux/fs.h:3160 ../../../filesystems/api-summary:29: fs/inode.c:2443
#: ../../../filesystems/api-summary:80: fs/dax.c:1703
msgid "``struct kiocb *iocb``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3136
msgid "the io context we want to submit the write with"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3137
msgid ""
"This is a variant of sb_start_write() for async io submission. Should be "
"matched with a call to kiocb_end_write()."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3154
msgid "drop write access to a superblock after async file io"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3155
msgid "the io context we sumbitted the write with"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3156
msgid "Should be matched with a call to kiocb_start_write()."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3276
msgid "returns true only if **name** is \".\" or \"..\""
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:662
#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:88
#: fs/sysfs/symlink.c:101 fs/sysfs/symlink.c:142
#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:343
#: fs/debugfs/inode.c:493 fs/debugfs/inode.c:531 fs/debugfs/inode.c:562
#: fs/debugfs/inode.c:619 fs/debugfs/inode.c:666 fs/debugfs/inode.c:812
#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:599
#: fs/debugfs/file.c:635 fs/debugfs/file.c:671 fs/debugfs/file.c:708
#: fs/debugfs/file.c:746 fs/debugfs/file.c:796 fs/debugfs/file.c:814
#: fs/debugfs/file.c:832 fs/debugfs/file.c:850 fs/debugfs/file.c:884
#: fs/debugfs/file.c:919 fs/debugfs/file.c:1001 fs/debugfs/file.c:1129
#: fs/debugfs/file.c:1190 fs/debugfs/file.c:1286 fs/debugfs/file.c:1365
#: fs/debugfs/file.c:1408 ../../../filesystems/api-summary:14:
#: include/linux/fs.h:3282 include/linux/fs.h:3293
#: ../../../filesystems/api-summary:56: fs/namei.c:2894
#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:191
#: fs/anon_inodes.c:215 fs/anon_inodes.c:247 fs/anon_inodes.c:313
#: ../../../filesystems/api-summary:95: fs/xattr.c:268 fs/xattr.c:530
#: fs/xattr.c:1165
msgid "``const char *name``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3277
msgid "file name to check"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3279
#: ../../../filesystems/api-summary:59: block/bio.c:1064 block/bio.c:1401
#: ../../../filesystems/api-summary:62: fs/seq_file.c:366 fs/seq_file.c:820
msgid "``size_t len``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3278
msgid "length of file name, in bytes"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3287
msgid "check if a file name contains \"..\" path components"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3288
msgid ""
"File path string to check Search for \"..\" surrounded by either '/' or "
"start/end of string."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3519
msgid "signal start of a direct I/O requests"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3520
#: include/linux/fs.h:3532
msgid "inode the direct I/O happens on"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3521
#: include/linux/fs.h:3533
msgid ""
"This is called once we've finished processing a direct I/O request, and is "
"used to wake up callers waiting for direct I/O to be quiesced."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3531
msgid "signal finish of a direct I/O requests"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3704
msgid "Check if a given name is suitable for a directory"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3710
#: ../../../filesystems/api-summary:56: fs/namei.c:3465 fs/namei.c:4285
#: fs/namei.c:4412 fs/namei.c:4515 fs/namei.c:4629 fs/namei.c:4790
#: fs/namei.c:4872
msgid "``struct inode *dir``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3714
msgid "inode of the directory where the new file will be created"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3716
#: ../../../filesystems/api-summary:20: fs/dcache.c:1762 fs/dcache.c:2168
#: fs/dcache.c:2325 ../../../filesystems/api-summary:83: fs/libfs.c:1799
#: fs/libfs.c:1888
msgid "``const struct qstr *name``"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3715
msgid "name of the new file"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3705
msgid ""
"This functions checks if the proposed filename is valid for the parent "
"directory. That means that only valid UTF-8 filenames will be accepted for "
"casefold directories from filesystems created with the strict encoding "
"flag.  That also means that any name will be accepted for directories that "
"doesn't have casefold enabled, or aren't being strict with the encoding."
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3717
msgid ""
"True: if the filename is suitable for this directory. It can be true if a "
"given name is not suitable for a strict encoding directory, but the "
"directory being used isn't strict"
msgstr ""

#: ../../../filesystems/api-summary:14: include/linux/fs.h:3720
msgid ""
"False if the filename isn't suitable for this directory. This only happens "
"when a directory is casefolded and the filesystem is strict about its "
"encoding."
msgstr ""

#: ../../../filesystems/api-summary.rst:18
msgid "The Directory Cache"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:582
msgid "drop a dentry"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:788
#: fs/debugfs/inode.c:834 ../../../filesystems/api-summary:146:
#: fs/debugfs/file.c:152 fs/debugfs/file.c:173
#: ../../../filesystems/api-summary:20: fs/dcache.c:588 fs/dcache.c:1646
#: fs/dcache.c:2116 fs/dcache.c:3043 ../../../filesystems/api-summary:23:
#: include/linux/dcache.h:319 include/linux/dcache.h:336
#: include/linux/dcache.h:571 ../../../filesystems/api-summary:56:
#: fs/namei.c:2896 fs/namei.c:3466 fs/namei.c:4286 fs/namei.c:4413
#: fs/namei.c:4516 fs/namei.c:4630 fs/namei.c:4791 fs/namei.c:5434
#: fs/namei.c:5478 fs/namei.c:5535 ../../../filesystems/api-summary:74:
#: fs/attr.c:144 fs/attr.c:394 ../../../filesystems/api-summary:83:
#: fs/libfs.c:886 fs/libfs.c:1706 ../../../filesystems/api-summary:86:
#: fs/posix_acl.c:595 fs/posix_acl.c:1080 fs/posix_acl.c:1158
#: fs/posix_acl.c:1203 ../../../filesystems/api-summary:95: fs/xattr.c:267
#: fs/xattr.c:467 fs/xattr.c:529 fs/xattr.c:1136
msgid "``struct dentry *dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:583
msgid "dentry to drop"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:584
msgid ""
"d_drop() unhashes the entry from the parent dentry hashes, so that it won't "
"be found through a VFS lookup any more. Note that this is different from "
"deleting the dentry - d_delete will try to mark the dentry negative if "
"possible, giving a successful _negative_ lookup, while d_drop will just make "
"the cache lookup fail."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:590
msgid ""
"d_drop() is used mainly for stuff that wants to invalidate a dentry for some "
"reason (NFS timeouts or autofs deletes)."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:593
msgid "__d_drop requires dentry->d_lock"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:595
msgid ""
"___d_drop doesn't mark dentry as \"unhashed\" (dentry->d_hash.pprev will be "
"LIST_POISON2, not NULL)."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1001
msgid "find any alias for a given inode"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1002
msgid "inode to find an alias for"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1003
msgid ""
"If any aliases exist for the given inode, take and return a reference for "
"one of them.  If no aliases exist, return ``NULL``."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1038
msgid "grab a hashed alias of inode"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1039
msgid "inode in question"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1040
msgid ""
"If inode has a hashed alias, or is a directory and has any alias, acquire "
"the reference to alias and return it. Otherwise return NULL. Notice that if "
"inode is a directory there can be only one alias and it can be unhashed only "
"if it has no children, or if it is the root of a filesystem, or if the "
"directory was renamed and d_revalidate was the first vfs operation to notice."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1047
msgid ""
"If the inode has an IS_ROOT, DCACHE_DISCONNECTED alias, then prefer any "
"other hashed alias over that one."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1248
msgid "shrink dcache for a superblock"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1249
#: ../../../filesystems/api-summary:29: fs/inode.c:1131 fs/inode.c:1508
msgid "superblock"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1250
msgid ""
"Shrink the dcache for the specified super block. This is used to free the "
"dcache before unmounting a file system."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1409
msgid "check for mounts over a dentry in the current namespace."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1415
msgid "``const struct path *parent``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1411
msgid "path to check."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1412
msgid ""
"Return true if the parent or its subdirectories contain a mount point in the "
"current namespace."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1542
msgid "prune dcache"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:340
#: fs/debugfs/inode.c:491 fs/debugfs/inode.c:529 fs/debugfs/inode.c:560
#: fs/debugfs/inode.c:616 fs/debugfs/inode.c:664 fs/debugfs/inode.c:809
#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:597
#: fs/debugfs/file.c:633 fs/debugfs/file.c:669 fs/debugfs/file.c:706
#: fs/debugfs/file.c:745 fs/debugfs/file.c:794 fs/debugfs/file.c:812
#: fs/debugfs/file.c:830 fs/debugfs/file.c:848 fs/debugfs/file.c:882
#: fs/debugfs/file.c:918 fs/debugfs/file.c:999 fs/debugfs/file.c:1127
#: fs/debugfs/file.c:1189 fs/debugfs/file.c:1285 fs/debugfs/file.c:1363
#: fs/debugfs/file.c:1409 ../../../filesystems/api-summary:20: fs/dcache.c:1548
msgid "``struct dentry *parent``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1543
msgid "parent of entries to prune"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1544
msgid "Prune the dcache to remove unused children of the parent dentry."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1640
msgid "detach submounts, prune dcache, and drop"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1641
msgid "dentry to invalidate (aka detach, prune and drop)"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1759
msgid "allocate a dcache entry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1765
msgid "``struct dentry * parent``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1760
msgid "parent of entry to allocate"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1761
msgid "qstr of the name"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1762
msgid ""
"Allocates a dentry. It returns ``NULL`` if there is insufficient memory "
"available. On a success the dentry is returned. The name passed in is copied "
"and the copy passed in may be reused after this call."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1943
msgid "fill in inode information for a dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1949 fs/dcache.c:2727
msgid "``struct dentry *entry``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1944
msgid "dentry to complete"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1946
msgid "``struct inode * inode``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1945
msgid "inode to attach to this dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1946
msgid "Fill in inode information in the entry."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1948
msgid "This turns negative dentries into productive full members of society."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:1951
msgid ""
"NOTE! This assumes that the inode count has been incremented (or otherwise "
"set) by the caller to indicate that it is now in use by the dcache."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2065
msgid "find or allocate a DISCONNECTED dentry for a given inode"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2066 fs/dcache.c:2090
msgid "inode to allocate the dentry for"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2067
msgid ""
"Obtain a dentry for an inode resulting from NFS filehandle conversion or "
"similar open by handle operations.  The returned dentry may be anonymous, or "
"may have a full name (if the inode was already in the cache)."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2071
msgid ""
"When called on a directory inode, we must ensure that the inode only ever "
"has one dentry.  If a dentry is found, that is returned instead of "
"allocating a new one."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2075
msgid ""
"On successful return, the reference to the inode has been transferred to the "
"dentry.  In case of an error the reference on the inode is released. To make "
"it easier to use in export operations a ``NULL`` or IS_ERR inode may be "
"passed in and the error will be propagated to the return value, with a "
"``NULL`` **inode** replaced by ERR_PTR(-ESTALE)."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2089
msgid "find or allocate a dentry for a given inode"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2091
msgid "Obtain an IS_ROOT dentry for the root of a filesystem."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2093
msgid ""
"We must ensure that directory inodes only ever have one dentry.  If a dentry "
"is found, that is returned instead of allocating a new one."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2096
msgid ""
"On successful return, the reference to the inode has been transferred to the "
"dentry.  In case of an error the reference on the inode is released.  A "
"``NULL`` or IS_ERR inode may be passed in and will be the error will be "
"propagate to the return value, with a ``NULL`` **inode** replaced by "
"ERR_PTR(-ESTALE)."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2110
msgid "lookup or allocate new dentry with case-exact name"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2111 fs/dcache.c:2165
msgid "the negative dentry that was passed to the parent's lookup func"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2112
msgid "the inode case-insensitive lookup has found"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2114
#: ../../../filesystems/api-summary:56: fs/namei.c:2959 fs/namei.c:2986
#: fs/namei.c:3009 fs/namei.c:3036 fs/namei.c:3064 fs/namei.c:3105
#: fs/namei.c:3139
msgid "``struct qstr *name``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2113 fs/dcache.c:2167
msgid "the case-exact name to be associated with the returned dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2114
msgid ""
"This is to avoid filling the dcache with case-insensitive names to the same "
"inode, only the actual correct case is stored in the dcache for case-"
"insensitive filesystems."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2118
msgid ""
"For a case-insensitive lookup match and if the case-exact dentry already "
"exists in the dcache, use it and return it."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2121
msgid ""
"If no entry exists with the exact case name, allocate new dentry with the "
"exact case, and return the spliced entry."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2164
msgid "compare dentry name with case-exact name"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2170
#: ../../../filesystems/api-summary:23: include/linux/dcache.h:363
#: include/linux/dcache.h:485 include/linux/dcache.h:505
#: include/linux/dcache.h:530 include/linux/dcache.h:542
#: include/linux/dcache.h:589 ../../../filesystems/api-summary:83:
#: fs/libfs.c:1800 fs/libfs.c:1856
msgid "``const struct dentry *dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2167 fs/dcache.c:2328
msgid "``const struct dentry *parent``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2166 fs/dcache.c:2323
msgid "parent dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2169
msgid "true if names are same, or false"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2322
msgid "search for a dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2324
msgid "qstr of name we wish to find"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2325
msgid "dentry, or NULL"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2326
msgid ""
"d_lookup searches the children of the parent dentry for the name in "
"question. If the dentry is found its reference count is incremented and the "
"dentry is returned. The caller must use dput to free the entry when it has "
"finished using it. ``NULL`` is returned if the dentry does not exist."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2455
msgid "delete a dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2461
msgid "``struct dentry * dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2456
msgid "The dentry to delete"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2457
msgid ""
"Turn the dentry into a negative dentry if possible, otherwise remove it from "
"the hash queues so it can be deleted later"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2494
msgid "add an entry back to the hash"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2500
msgid "``struct dentry * entry``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2495
msgid "dentry to add to the hash"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2496
msgid "Adds a dentry to the hash according to its name."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2721
msgid "add dentry to hash queues"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2722
msgid "dentry to add"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2723
msgid "The inode to attach to this dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:2724
msgid ""
"This adds the entry to the hash queues and initializes **inode**. The entry "
"was actually filled in earlier during d_alloc()."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3040
msgid "splice a disconnected dentry into the tree if one exists"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3041
msgid "the inode which may have a disconnected dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3042
msgid "a negative dentry which we want to point to the inode."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3043
msgid ""
"If inode is a directory and has an IS_ROOT alias, then d_move that in place "
"of the given dentry and return it, else simply d_add the inode to the dentry "
"and return NULL."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3047
msgid ""
"If a non-IS_ROOT directory is found, the filesystem is corrupt, and we "
"should error out: directories can't have multiple aliases."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3050
msgid ""
"This is needed in the lookup routine of any filesystem that is exportable "
"(via knfsd) so that we can build dcache paths to directories effectively."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3053
msgid ""
"If a dentry was found and moved, then it is returned.  Otherwise NULL is "
"returned.  This matches the expected return value of ->lookup."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3056
msgid ""
"Cluster filesystems may call this function with a negative, hashed dentry. "
"In that case, we know that the inode will be a regular file, and also this "
"will only occur during atomic_open. So we need to check for the dentry being "
"already hashed only in the final case."
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3075
msgid "is new dentry a subdirectory of old_dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3081
#: ../../../filesystems/api-summary:56: fs/namei.c:4873
#: ../../../filesystems/api-summary:83: fs/libfs.c:811
msgid "``struct dentry *new_dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3076
msgid "new dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3078
#: ../../../filesystems/api-summary:56: fs/namei.c:4874
#: ../../../filesystems/api-summary:83: fs/libfs.c:809
msgid "``struct dentry *old_dentry``"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3077
msgid "old dentry"
msgstr ""

#: ../../../filesystems/api-summary:20: fs/dcache.c:3078
msgid ""
"Returns true if new_dentry is a subdirectory of the parent (at any depth). "
"Returns false otherwise. Caller must ensure that \"new_dentry\" is pinned "
"before calling is_subdir()"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:313
#: include/linux/dcache.h:330
msgid "get a reference to a dentry"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:314
#: include/linux/dcache.h:331
msgid "dentry to get a reference to"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:315
msgid ""
"Given a live dentry, increment the reference count and return the dentry. "
"Caller must hold **dentry->d_lock**.  Making sure that dentry is alive is "
"caller's resonsibility.  There are many conditions sufficient to guarantee "
"that; e.g. anything with non-negative refcount is alive, so's anything "
"hashed, anything positive, anyone's parent, etc."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:332
msgid ""
"Given a dentry or ``NULL`` pointer increment the reference count if "
"appropriate and return the dentry.  A dentry will not be destroyed when it "
"has references.  Conversely, a dentry with no references can disappear for "
"any number of reasons, starting with memory pressure.  In other words, that "
"primitive is used to clone an existing reference; using it on something with "
"zero refcount is a bug."
msgstr ""

#: ../../../filesystems/api-summary:113: fs/proc/base.c:3477
#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:573
#: ../../../filesystems/api-summary:23: include/linux/dcache.h:340
msgid "**NOTE**"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:341
msgid ""
"it will spin if **dentry->d_lock** is held.  From the deadlock avoidance "
"point of view it is equivalent to spin_lock()/increment refcount/"
"spin_unlock(), so calling it under **dentry->d_lock** is always a bug; so's "
"calling it under ->d_lock on any of its descendents."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:357
msgid "is dentry hashed"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:358
msgid "entry to check"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:359
msgid "Returns true if the dentry passed is not currently hashed."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:479
msgid "Determine if a dentry is really negative (ignoring fallthroughs)"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:480
#: include/linux/dcache.h:500
msgid "The dentry in question"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:481
msgid ""
"Returns true if the dentry represents either an absent name or a name that "
"doesn't map to an inode (ie. ->d_inode is NULL).  The dentry could represent "
"a true miss, a whiteout that isn't represented by a 0,0 chardev or a "
"fallthrough marker in an opaque directory."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:486
msgid ""
"Note!  (1) This should be used *only* by a filesystem to examine its own "
"dentries.  It should not be used to look at some other filesystem's "
"dentries.  (2) It should also be used in combination with d_inode() to get "
"the inode.  (3) The dentry may have something attached to ->d_lower and the "
"type field of the flags may be set to something other than miss or whiteout."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:499
msgid "Determine if a dentry is really positive (ignoring fallthroughs)"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:501
msgid ""
"Returns true if the dentry represents a name that maps to an inode (ie. -"
">d_inode is not NULL).  The dentry might still represent a whiteout if that "
"is represented on medium as a 0,0 chardev."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:505
msgid ""
"Note!  (1) This should be used *only* by a filesystem to examine its own "
"dentries.  It should not be used to look at some other filesystem's "
"dentries.  (2) It should also be used in combination with d_inode() to get "
"the inode."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:524
msgid "Get the actual inode of this dentry"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:525
#: include/linux/dcache.h:537 include/linux/dcache.h:584
msgid "The dentry to query"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:526
#: include/linux/dcache.h:538
msgid ""
"This is the helper normal filesystems should use to get at their own inodes "
"in their own dentries and ignore the layering superimposed upon them."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:536
msgid "Get the actual inode of this dentry with READ_ONCE()"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:548
msgid "Get upper or lower inode we should be using"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:554
msgid "``const struct dentry *upper``"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:549
msgid "The upper layer"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:550
msgid ""
"This is the helper that should be used to get at the inode that will be used "
"if this dentry were to be opened as a file.  The inode may be on the upper "
"dentry or it may be on a lower dentry pinned by the upper."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:554
msgid "Normal filesystems should not use this to access their own inodes."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:565
msgid "Return the real dentry"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:566
msgid "the dentry to query"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:568
msgid "``enum d_real_type type``"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:567
msgid "the type of real dentry (data or metadata)"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:568
msgid ""
"If dentry is on a union/overlay, then return the underlying, real dentry. "
"Otherwise return the dentry itself."
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:571
msgid "See also: Documentation/filesystems/vfs.rst"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:583
msgid "Return the real inode hosting the data"
msgstr ""

#: ../../../filesystems/api-summary:23: include/linux/dcache.h:585
msgid ""
"If dentry is on a union/overlay, then return the underlying, real inode. "
"Otherwise return d_inode()."
msgstr ""

#: ../../../filesystems/api-summary.rst:27
msgid "Inode Handling"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:218
msgid "perform inode structure initialisation"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:219
msgid "superblock inode belongs to"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:220
msgid "inode to initialise"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:222
#: ../../../filesystems/api-summary:59: block/bio.c:858 block/bio.c:890
#: block/bio.c:1681
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:221
msgid "allocation flags"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:222
msgid ""
"These are initializations that need to be done on every inode allocation as "
"the fields are not initialised by slab allocation. If there are additional "
"allocations required **gfp** is used."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:405
msgid "directly drop an inode's link count"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:406 fs/inode.c:426
#: fs/inode.c:443 fs/inode.c:465 fs/inode.c:2753
msgid "inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:407
msgid ""
"This is a low-level filesystem helper to replace any direct filesystem "
"manipulation of i_nlink.  In cases where we are attempting to track writes "
"to the filesystem, a decrement to zero means an imminent write when the file "
"is truncated and actually unlinked on the filesystem."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:425
msgid "directly zero an inode's link count"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:427
msgid ""
"This is a low-level filesystem helper to replace any direct filesystem "
"manipulation of i_nlink.  See drop_nlink() for why we care about i_nlink "
"hitting zero."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:442
msgid "directly set an inode's link count"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:445
msgid "``unsigned int nlink``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:444
msgid "new nlink (should be non-zero)"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:445
msgid ""
"This is a low-level filesystem helper to replace any direct filesystem "
"manipulation of i_nlink."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:464
msgid "directly increment an inode's link count"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:466
msgid ""
"This is a low-level filesystem helper to replace any direct filesystem "
"manipulation of i_nlink.  Currently, it is only here for parity with "
"dec_nlink()."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:621
msgid "add inode to the superblock list of inodes"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:622
msgid "inode to add"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:656
msgid "hash an inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:657
msgid "unhashed inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:659 fs/inode.c:1260
#: fs/inode.c:1334 fs/inode.c:1373 fs/inode.c:1568 fs/inode.c:1598
#: fs/inode.c:1666 fs/inode.c:1716
msgid "``unsigned long hashval``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:658
msgid "unsigned long value used to locate this object in the inode_hashtable."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:660
msgid "Add an inode to the inode hash for this superblock."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:676
msgid "remove an inode from the hash"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:677
msgid "inode to unhash"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:678
msgid "Remove an inode from the superblock."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:858
msgid "evict all evictable inodes for a superblock"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:859
msgid "superblock to operate on"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:860
msgid ""
"Make sure that no inodes with zero refcount are retained.  This is called by "
"superblock shutdown after having SB_ACTIVE flag removed, so any inode "
"reaching zero refcount during or after that call will be immediately evicted."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1130
msgid "obtain an inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1132
msgid ""
"Allocates a new inode for given superblock. The default gfp_mask for "
"allocations related to inode->i_mapping is GFP_HIGHUSER_MOVABLE. If HIGHMEM "
"pages are unsuitable or it is known that pages allocated for the page cache "
"are not reclaimable or migratable, mapping_set_gfp_mask() must be called "
"with suitable flags on the newly created inode's mapping"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1173
msgid "clear the I_NEW state and wake up any waiters"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1174
msgid "new inode to unlock"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1175
msgid ""
"Called when the inode is fully initialised to clear the new state of the "
"inode and wake up anyone waiting for the inode to finish initialisation."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1215
msgid "take two i_mutexes on non-directory objects"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1221 fs/inode.c:1245
msgid "``struct inode *inode1``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1220
msgid "first inode to lock"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1222 fs/inode.c:1242
msgid "``struct inode *inode2``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1221
msgid "second inode to lock"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1216
msgid ""
"Lock any non-NULL argument. Passed objects must not be directories. Zero, "
"one or two objects may be locked by this function."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1239
msgid "release locks from lock_two_nondirectories()"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1240
msgid "first inode to unlock"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1241
msgid "second inode to unlock"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1257 fs/inode.c:1331
#: fs/inode.c:1370 fs/inode.c:1413
msgid "obtain an inode from a mounted file system"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1258
msgid "pre-allocated inode to use for insert to cache"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1259 fs/inode.c:1333
#: fs/inode.c:1372
msgid "hash value (usually inode number) to get"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1261 fs/inode.c:1335
#: fs/inode.c:1374 fs/inode.c:1569 fs/inode.c:1599 fs/inode.c:1717
msgid "``int (*test)(struct inode *, void *)``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1260 fs/inode.c:1334
#: fs/inode.c:1373 fs/inode.c:1568 fs/inode.c:1598 fs/inode.c:1666
msgid "callback used for comparisons between inodes"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1262 fs/inode.c:1336
#: fs/inode.c:1375
msgid "``int (*set)(struct inode *, void *)``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1261 fs/inode.c:1335
#: fs/inode.c:1374
msgid "callback used to initialize a new struct inode"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:494
#: fs/debugfs/inode.c:532 fs/debugfs/inode.c:620
#: ../../../filesystems/api-summary:29: fs/inode.c:1263 fs/inode.c:1337
#: fs/inode.c:1376 fs/inode.c:1570 fs/inode.c:1600 fs/inode.c:1668
#: fs/inode.c:1718 ../../../filesystems/api-summary:38: fs/super.c:814
#: ../../../filesystems/api-summary:59: block/bio.c:1400
msgid "``void *data``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1262 fs/inode.c:1336
#: fs/inode.c:1375
msgid "opaque data pointer to pass to **test** and **set**"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1263
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, and if present return it with an increased reference count. This is a "
"variant of iget5_locked() that doesn't allocate an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1267
msgid ""
"If the inode is not present in the cache, insert the pre-allocated inode and "
"return it locked, hashed, and with the I_NEW flag set. The file system gets "
"to fill it in before unlocking it via unlock_new_inode()."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1271 fs/inode.c:1346
msgid ""
"Note that both **test** and **set** are called with the inode_hash_lock "
"held, so they can't sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1332 fs/inode.c:1371
#: fs/inode.c:1414
msgid "super block of file system"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1337
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, and if present return it with an increased reference count. This is a "
"generalized version of iget_locked() for file systems where the inode number "
"is not sufficient for unique identification of an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1342
msgid ""
"If the inode is not present in the cache, allocate and insert a new inode "
"and return it locked, hashed, and with the I_NEW flag set. The file system "
"gets to fill it in before unlocking it via unlock_new_inode()."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1376
msgid ""
"This is equivalent to iget5_locked, except the **test** callback must "
"tolerate the inode not being stable, including being mid-teardown."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1416 fs/inode.c:1635
#: fs/inode.c:1756
msgid "``unsigned long ino``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1415
msgid "inode number to get"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1416
msgid ""
"Search for the inode specified by **ino** in the inode cache and if present "
"return it with an increased reference count. This is for file systems where "
"the inode number is sufficient for unique identification of an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1420
msgid ""
"If the inode is not in cache, allocate a new inode and return it locked, "
"hashed, and with the I_NEW flag set.  The file system gets to fill it in "
"before unlocking it via unlock_new_inode()."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1507
msgid "get a unique inode number"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1510
msgid "``ino_t max_reserved``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1509
msgid "highest reserved inode number"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1510
msgid ""
"Obtain an inode number that is unique on the system for a given superblock. "
"This is used by file systems that have no natural permanent inode numbering "
"system. An inode number is returned that is higher than the reserved limit "
"but unique."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1515
msgid ""
"BUGS: With a large number of inodes live on the file system this function "
"currently becomes quite slow."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1565 fs/inode.c:1595
#: fs/inode.c:1632
msgid "search for an inode in the inode cache"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1566 fs/inode.c:1596
#: fs/inode.c:1633 fs/inode.c:1664
msgid "super block of file system to search"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1567 fs/inode.c:1597
#: fs/inode.c:1665
msgid "hash value (usually inode number) to search for"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1569 fs/inode.c:1599
msgid "opaque data pointer to pass to **test**"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1570
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache. If the inode is in the cache, the inode is returned with an "
"incremented reference count."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1574 fs/inode.c:1608
#: ../../../filesystems/api-summary:62: fs/seq_file.c:54
#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2913
#: ../../../filesystems/api-summary:95: fs/xattr.c:1170
msgid "**Note**"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1575
msgid ""
"I_NEW is not waited upon so you have to be very careful what you do with the "
"returned inode.  You probably should be using ilookup5() instead."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1578
msgid ""
"Note2: **test** is called with the inode_hash_lock held, so can't sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1600
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, and if the inode is in the cache, return the inode with an "
"incremented reference count.  Waits on I_NEW before returning the inode. "
"returned with an incremented reference count."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1605
msgid ""
"This is a generalized version of ilookup() for file systems where the inode "
"number is not sufficient for unique identification of an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1609
msgid "**test** is called with the inode_hash_lock held, so can't sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1634
msgid "inode number to search for"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1635
msgid ""
"Search for the inode **ino** in the inode cache, and if the inode is in the "
"cache, the inode is returned with an incremented reference count."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1663 fs/inode.c:1713
msgid "find an inode in the inode cache"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1667
msgid "``int (*match)(struct inode *, unsigned long, void *)``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1667
msgid "opaque data pointer to pass to **match**"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1668
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, where the helper function **match** will return 0 if the inode does "
"not match, 1 if the inode does match, and -1 if the search should be "
"stopped.  The **match** function must be responsible for taking the i_lock "
"spin_lock and checking i_state for an inode being freed or being "
"initialized, and incrementing the reference count before returning 1.  It "
"also must not sleep, since it is called with the inode_hash_lock spinlock "
"held."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1677
msgid ""
"This is a even more generalized version of ilookup5() when the function must "
"never block --- find_inode() can block in __wait_on_freeing_inode() --- or "
"when the caller can not increment the reference count because the resulting "
"iput() might cause an inode eviction.  The tradeoff is that the **match** "
"funtion must be very carefully implemented."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1714 fs/inode.c:1754
msgid "Super block of file system to search"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1715
msgid "Key to hash"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1716
msgid "Function to test match on an inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1717
msgid "Data for test function"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1718 fs/inode.c:1756
msgid ""
"Search for the inode specified by **hashval** and **data** in the inode "
"cache, where the helper function **test** will return 0 if the inode does "
"not match and 1 if it does.  The **test** function must be responsible for "
"taking the i_lock spin_lock and checking i_state for an inode being freed or "
"being initialized."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1724 fs/inode.c:1762
msgid ""
"If successful, this will return the inode for which the **test** function "
"returned 1 and NULL otherwise."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1727 fs/inode.c:1765
msgid ""
"The **test** function is not permitted to take a ref on any inode presented. "
"It is also not permitted to sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1730 fs/inode.c:1768
msgid "The caller must hold the RCU read lock."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1753
msgid "Find an inode in the inode cache"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1755
msgid "The inode number to match"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1918
msgid "put an inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1919
msgid "inode to put"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1920
msgid ""
"Puts an inode, dropping its usage count. If the inode use count hits zero, "
"the inode is then freed and may also be destroyed."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1923
msgid "Consequently, iput() can sleep."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1972
msgid "find a block number in a file"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1973
msgid "inode owning the block number being requested"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1975
msgid "``sector_t *block``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1974
msgid "pointer containing the block to find"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1975
msgid ""
"Replaces the value in ``*block`` with the block number on the device holding "
"corresponding to the requested block number in the file. That is, asked for "
"block 4 of inode 1 the function will replace the 4 in ``*block``, with disk "
"block relative to the disk start that holds that block of the file."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:1981
msgid ""
"Returns -EINVAL in case of error, 0 otherwise. If mapping falls into a hole, "
"returns 0 and ``*block`` is also set to 0."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2035 fs/inode.c:2085
msgid "update the timestamps on the inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2036 fs/inode.c:2086
msgid "inode to be updated"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2038 fs/inode.c:2088
#: ../../../filesystems/api-summary:38: fs/super.c:813
#: ../../../filesystems/api-summary:47: fs/locks.c:1734
#: ../../../filesystems/api-summary:59: block/bio.c:1796
#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2512
#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:193
#: fs/anon_inodes.c:217 fs/anon_inodes.c:250 fs/anon_inodes.c:315
#: ../../../filesystems/api-summary:95: fs/xattr.c:271
msgid "``int flags``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2037 fs/inode.c:2087
msgid "S_* flags that needed to be updated"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2038
msgid ""
"The update_time function is called when an inode's timestamps need to be "
"updated for a read or write operation. This function handles updating the "
"actual timestamps. It's up to the caller to ensure that the inode is marked "
"dirty appropriately."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2043
msgid ""
"In the case where any of S_MTIME, S_CTIME, or S_VERSION need to be updated, "
"attempt to update all three of them. S_ATIME updates can be handled "
"independently of the rest."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2047
msgid "Returns a set of S_* flags indicating which values changed."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2088
msgid ""
"The update_time function is called when an inode's timestamps need to be "
"updated for a read or write operation. In the case where any of S_MTIME, "
"S_CTIME, or S_VERSION need to be updated we attempt to update all three of "
"them. S_ATIME updates can be handled done independently of the rest."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2093
msgid "Returns a S_* mask indicating which fields were updated."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2261
msgid "remove special file privileges (suid, capabilities)"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2262
msgid "file to remove privileges from"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2263
msgid ""
"When file is modified by a write or truncation ensure that special file "
"privileges are removed."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2267 fs/inode.c:2364
#: fs/inode.c:2428 fs/inode.c:2445
msgid "0 on success, negative errno on failure."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2276
msgid "Return FS time (possibly fine-grained)"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2277
msgid "inode."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2278
msgid ""
"Return the current time truncated to the time granularity supported by the "
"fs, as suitable for a ctime/mtime change. If the ctime is flagged as having "
"been QUERIED, get a fine-grained timestamp, but don't update the floor."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2283
msgid ""
"For a multigrain inode, this is effectively an estimate of the timestamp "
"that a file would receive. An actual update must go through "
"inode_set_ctime_current()."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2353
msgid "update mtime and ctime time"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2354
msgid "file accessed"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2355
msgid ""
"Update the mtime and ctime members of an inode and mark the inode for "
"writeback. Note that this function is meant exclusively for usage in the "
"file write path of filesystems, and filesystems may choose to explicitly "
"ignore updates via this function with the _NOCMTIME inode flag, e.g. for "
"network filesystem where these imestamps are handled by the server. This can "
"return an error for file systems who need to allocate space in order to "
"update an inode."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2420 fs/inode.c:2437
msgid "handle mandated vfs changes when modifying a file"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2421
msgid "file that was modified"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2422 fs/inode.c:2439
msgid ""
"When file has been modified ensure that special file privileges are removed "
"and time settings are updated."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2425 fs/inode.c:2442
#: ../../../filesystems/api-summary:38: fs/super.c:1241
msgid "**Context**"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2426 fs/inode.c:2443
msgid "Caller must hold the file's inode lock."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2438
msgid "iocb that was modified"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2589
msgid "Init uid,gid,mode for new inode according to posix standards"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2590 fs/inode.c:2931
msgid "idmap of the mount the inode was created from"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2591
msgid "New inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2593 fs/inode.c:2933
msgid "``const struct inode *dir``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2592
msgid "Directory inode"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:430
#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:490
#: fs/debugfs/inode.c:528 ../../../filesystems/api-summary:146:
#: fs/debugfs/file.c:596 fs/debugfs/file.c:632 fs/debugfs/file.c:668
#: fs/debugfs/file.c:705 fs/debugfs/file.c:744 fs/debugfs/file.c:793
#: fs/debugfs/file.c:811 fs/debugfs/file.c:829 fs/debugfs/file.c:847
#: fs/debugfs/file.c:881 fs/debugfs/file.c:917 fs/debugfs/file.c:998
#: fs/debugfs/file.c:1126 fs/debugfs/file.c:1188 fs/debugfs/file.c:1284
#: fs/debugfs/file.c:1362 ../../../filesystems/api-summary:29: fs/inode.c:2594
#: fs/inode.c:2934 ../../../filesystems/api-summary:56: fs/namei.c:3467
#: fs/namei.c:4051 fs/namei.c:4287 fs/namei.c:4414
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:596
msgid "``umode_t mode``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2593
msgid "mode of the new inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2594
msgid ""
"If the inode has been created through an idmapped mount the idmap of the "
"vfsmount must be passed through **idmap**. This function will then take care "
"to map the inode according to **idmap** before checking permissions and "
"initializing i_uid and i_gid. On non-idmapped mounts or if permission "
"checking is to be performed on the raw inode simply pass **nop_mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2618
msgid "check current task permissions to inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2620
msgid "inode being checked"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2621
msgid ""
"Return true if current either has CAP_FOWNER in a namespace with the inode "
"owner uid mapped, or owns the file."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2624
#: ../../../filesystems/api-summary:56: fs/namei.c:457 fs/namei.c:3470
#: fs/namei.c:4290 fs/namei.c:4416 fs/namei.c:4518 fs/namei.c:4643
#: fs/namei.c:4794 fs/namei.c:4886 ../../../filesystems/api-summary:74:
#: fs/attr.c:151 fs/attr.c:321 fs/attr.c:410
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:696
msgid ""
"If the inode has been found through an idmapped mount the idmap of the "
"vfsmount must be passed through **idmap**. This function will then take care "
"to map the inode according to **idmap** before checking permissions. On non-"
"idmapped mounts or if permission checking is to be performed on the raw "
"inode simply pass **nop_mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2658
msgid "wait for outstanding DIO requests to finish"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2659
msgid "inode to wait for"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2660
msgid ""
"Waits for all pending direct I/O requests to finish so that we can proceed "
"with a truncate or equivalent operation."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2663
msgid ""
"Must be called under a lock that serializes taking new references to "
"i_dio_count, usually by inode->i_rwsem."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2721
msgid "Truncate timespec to a granularity"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2727
msgid "``struct timespec64 t``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2722
msgid "Timespec"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2723
msgid "inode being updated"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2724
msgid ""
"Truncate a timespec to the granularity supported by the fs containing the "
"inode. Always rounds down. gran must not be 0 nor greater than a second "
"(NSEC_PER_SEC, or 10^9 ns)."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2752
msgid "set the ctime to current_time"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2754
msgid ""
"Set the inode's ctime to the current value for the inode. Returns the "
"current value that was assigned. If this is not a multigrain inode, then we "
"set it to the later of the coarse time and floor value."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2758
msgid ""
"If it is multigrain, then we first see if the coarse-grained timestamp is "
"distinct from what is already there. If so, then use that. Otherwise, get a "
"fine-grained timestamp."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2762
msgid ""
"After that, try to swap the new value into i_ctime_nsec. Accept the "
"resulting ctime, regardless of the outcome of the swap. If it has already "
"been replaced, then that timestamp is later than the earlier unacceptable "
"one, and is thus acceptable."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2834
msgid "try to update the ctime on a delegated inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2835
msgid "inode to update"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2837
msgid "``struct timespec64 update``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2836
msgid "timespec64 to set the ctime"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2837
msgid ""
"Attempt to atomically update the ctime on behalf of a delegation holder."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2839
msgid ""
"The nfs server can call back the holder of a delegation to get updated inode "
"attributes, including the mtime. When updating the mtime, update the ctime "
"to a value at least equal to that."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2843
msgid ""
"This can race with concurrent updates to the inode, in which case the update "
"is skipped."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2846
msgid ""
"Note that this works even when multigrain timestamps are not enabled, so it "
"is used in either case."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2907
msgid "check whether caller is CAP_FSETID privileged"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2908
#: ../../../filesystems/api-summary:74: fs/attr.c:23 fs/attr.c:51
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:593 fs/posix_acl.c:685
msgid "idmap of the mount **inode** was found from"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2909
#: ../../../filesystems/api-summary:74: fs/attr.c:24 fs/attr.c:52
msgid "inode to check"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2911
msgid "``vfsgid_t vfsgid``"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2910
msgid "the new/current vfsgid of **inode**"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2911
msgid ""
"Check whether **vfsgid** is in the caller's group list or if the caller is "
"privileged with CAP_FSETID over **inode**. This can be used to determine "
"whether the setgid bit can be kept or must be dropped."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2916
msgid "true if the caller is sufficiently privileged, false if not."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2930
msgid "handle the sgid bit for non-directories"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2932
msgid "parent directory inode"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2933
msgid "mode of the file to be created in **dir**"
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2934
msgid ""
"If the **mode** of the new file has both the S_ISGID and S_IXGRP bit raised "
"and **dir** has the S_ISGID bit raised ensure that the caller is either in "
"the group of the parent directory or they have CAP_FSETID in their user "
"namespace and are privileged over the parent directory. In all other cases, "
"strip the S_ISGID bit from **mode**."
msgstr ""

#: ../../../filesystems/api-summary:29: fs/inode.c:2941
msgid "the new mode to use for the file"
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:198
msgid "mark an inode bad due to an I/O error"
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:199
msgid "Inode to mark bad"
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:200
msgid ""
"When an inode cannot be read due to a media or remote network failure this "
"function makes the inode \"bad\" and causes I/O operations on it to fail "
"from this point on."
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:225
msgid "is an inode errored"
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:226
msgid "inode to test"
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:227
msgid "Returns true if the inode in question has been marked as bad."
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:239
msgid "Mark an under-construction inode as dead and release it"
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:240
msgid "The inode to discard"
msgstr ""

#: ../../../filesystems/api-summary:32: fs/bad_inode.c:241
msgid "Mark an under-construction inode as dead and release it."
msgstr ""

#: ../../../filesystems/api-summary.rst:36
msgid "Registration and Superblocks"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:458 fs/super.c:495
msgid "drop an active reference to superblock"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:464 fs/super.c:501
msgid "``struct super_block *s``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:459 fs/super.c:496
msgid "superblock to deactivate"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:460
msgid ""
"Drops an active reference to superblock, converting it into a temporary one "
"if there is no other active references left.  In that case we tell fs driver "
"to shut it down and drop the temporary reference we had just acquired."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:465
msgid "Caller holds exclusive lock on superblock; that lock is released."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:497
msgid ""
"Variant of deactivate_locked_super(), except that superblock is *not* locked "
"by caller.  If we are going to drop the final active reference, lock will be "
"acquired prior to that."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:573
msgid "prevents superblock from being reused"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:574
msgid "superblock to retire"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:575
msgid ""
"The function marks superblock to be ignored in superblock test, which "
"prevents it from being reused for any new mounts.  If the superblock has a "
"private bdi, it also unregisters it, but doesn't reduce the refcount of the "
"superblock to prevent potential races.  The refcount is reduced by "
"generic_shutdown_super().  The function can not be called concurrently with "
"generic_shutdown_super().  It is safe to call the function multiple times, "
"subsequent calls have no effect."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:583
msgid ""
"The marker will affect the re-use only for block-device-based superblocks.  "
"Other superblocks will still get marked if this function is used, but that "
"will not affect their reusability."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:602
msgid "common helper for ->kill_sb()"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:603
msgid "superblock to kill"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:604
msgid ""
"generic_shutdown_super() does all fs-independent work on superblock "
"shutdown.  Typical ->kill_sb() should pick all fs-specific objects that need "
"destruction out of superblock, call generic_shutdown_super() and release "
"aforementioned objects.  Note: dentries and inodes _are_ taken care of and "
"do not need specific handling."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:610
msgid ""
"Upon calling this function, the filesystem may no longer alter or rearrange "
"the set of dentries belonging to this super_block, nor may it change the "
"attachments of dentries to inodes."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:699
msgid "Find or create a superblock"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:705 fs/super.c:1389
#: fs/super.c:1660 fs/super.c:1712 fs/super.c:1739
#: ../../../filesystems/api-summary:98: fs/namespace.c:1184
msgid "``struct fs_context *fc``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:700 fs/super.c:1384
msgid "Filesystem context."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:702
msgid "``int (*test)(struct super_block *, struct fs_context *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:701
msgid "Comparison callback"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:703
msgid "``int (*set)(struct super_block *, struct fs_context *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:702
msgid "Setup callback"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:703
msgid "Create a new superblock or find an existing one."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:705
msgid ""
"The **test** callback is used to find a matching existing superblock. "
"Whether or not the requested parameters in **fc** are taken into account is "
"specific to the **test** callback that is used. They may even be completely "
"ignored."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:710
msgid "If an extant superblock is matched, it will be returned unless:"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:712
msgid ""
"the namespace the filesystem context **fc** and the extant superblock's "
"namespace differ"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:715
msgid ""
"the filesystem context **fc** has requested that reusing an extant "
"superblock is not allowed"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:718
msgid "In both cases EBUSY will be returned."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:720
msgid ""
"If no match is made, a new superblock will be allocated and basic "
"initialisation will be performed (s_type, s_fs_info and s_id will be set and "
"the **set** callback will be invoked), the superblock will be published and "
"it will be returned in a partially constructed state with SB_BORN and "
"SB_ACTIVE as yet unset."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:727
msgid ""
"On success, an extant or newly created superblock is returned. On failure an "
"error pointer is returned."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:808
msgid "find or create a superblock"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:814 fs/super.c:948
msgid "``struct file_system_type *type``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:809
msgid "filesystem type superblock should belong to"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:811
msgid "``int (*test)(struct super_block *,void *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:810
msgid "comparison callback"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:812
msgid "``int (*set)(struct super_block *,void *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:811
msgid "setup callback"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:812
msgid "mount flags"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:813
msgid "argument to each of them"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:942
msgid "call function for superblocks of given type"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:943
msgid "fs type"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:945
msgid "``void (*f)(struct super_block *, void *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:944
msgid "function to call"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:946
#: ../../../filesystems/api-summary:56: fs/namei.c:5557
msgid "``void *arg``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:945
msgid "argument to pass to it"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:946
msgid ""
"Scans the superblock list and calls given function, passing it locked "
"superblock and given argument."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1236
msgid "Allocate a block device for filesystems which don't have one."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1242
msgid "``dev_t *p``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1237
msgid "Pointer to a dev_t."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1238
msgid ""
"Filesystems which don't use real block devices can call this function to "
"allocate a virtual block device."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1242
msgid "Any context.  Frequently called while holding sb_lock."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1243
msgid ""
"0 on success, -EMFILE if there are no anonymous bdevs left or -ENOMEM if "
"memory allocation failed."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1383
msgid "Find or create a superblock by device number"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1386
#: ../../../filesystems/api-summary:56: fs/namei.c:4288
msgid "``dev_t dev``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1385
msgid "device number"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1386
msgid ""
"Find or create a superblock using the provided device number that will be "
"stored in fc->sget_key."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1389
msgid ""
"If an extant superblock is matched, then that will be returned with an "
"elevated reference count that the caller must transfer or discard."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1392
msgid ""
"If no match is made, a new superblock will be allocated and basic "
"initialisation will be performed (s_type, s_fs_info, s_id, s_dev will be "
"set). The superblock will be published and it will be returned in a "
"partially constructed state with SB_BORN and SB_ACTIVE as yet unset."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1399
msgid ""
"an existing or newly created superblock on success, an error pointer on "
"failure."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1654 fs/super.c:1706
msgid "Get a superblock based on a single block device"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1655 fs/super.c:1707
msgid "The filesystem context holding the parameters"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1657
msgid "``int (*fill_super)(struct super_block *sb, struct fs_context *fc)``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1656 fs/super.c:1708
msgid "Helper to initialise a new superblock"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1658
#: ../../../filesystems/api-summary:56: fs/namei.c:2875 fs/namei.c:2895
#: ../../../filesystems/api-summary:62: fs/seq_file.c:367
msgid "``unsigned int flags``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1657
msgid "GET_TREE_BDEV_* flags"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1709
msgid "``int (*fill_super)(struct super_block *, struct fs_context *)``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1733
msgid "Get the mountable root"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1734
msgid "The superblock configuration context."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:1735
msgid ""
"The filesystem is invoked to get or create a superblock which can then later "
"be used for mounting.  The filesystem places a pointer to the root to be "
"used for mounting in **fc->root**."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2012
msgid "lock the filesystem and force it into a consistent state"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2013
msgid "the super to lock"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2015 fs/super.c:2218
msgid "``enum freeze_holder who``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2014 fs/super.c:2217
msgid "context that wants to freeze"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2016 fs/super.c:2219
msgid "``const void *freeze_owner``"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2015 fs/super.c:2218
msgid "owner of the freeze"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2016
msgid ""
"Syncs the super to make sure the filesystem is consistent and calls the fs's "
"freeze_fs.  Subsequent calls to this without first thawing the fs may return "
"-EBUSY."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2020
msgid ""
"**who** should be: * ``FREEZE_HOLDER_USERSPACE`` if userspace wants to "
"freeze the fs; * ``FREEZE_HOLDER_KERNEL`` if the kernel wants to freeze the "
"fs. * ``FREEZE_MAY_NEST`` whether nesting freeze and thaw requests is "
"allowed."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2025
msgid ""
"The **who** argument distinguishes between the kernel and userspace trying "
"to freeze the filesystem.  Although there cannot be multiple kernel freezes "
"or multiple userspace freezes in effect at any given time, the kernel and "
"userspace can both hold a filesystem frozen.  The filesystem remains frozen "
"until there are no kernel or userspace freezes in effect."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2031
msgid ""
"A filesystem may hold multiple devices and thus a filesystems may be frozen "
"through the block layer via multiple block devices. In this case the request "
"is marked as being allowed to nest by passing FREEZE_MAY_NEST. The "
"filesystem remains frozen until all block devices are unfrozen. If multiple "
"freezes are attempted without FREEZE_MAY_NEST -EBUSY will be returned."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2038
msgid "During this function, sb->s_writers.frozen goes through these values:"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2040
msgid "SB_UNFROZEN: File system is normal, all writes progress as usual."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2042
msgid ""
"SB_FREEZE_WRITE: The file system is in the process of being frozen.  New "
"writes should be blocked, though page faults are still allowed. We wait for "
"all writes to complete and then proceed to the next stage."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2046
msgid ""
"SB_FREEZE_PAGEFAULT: Freezing continues. Now also page faults are blocked "
"but internal fs threads can still modify the filesystem (although they "
"should not dirty new pages or inodes), writeback can run etc. After waiting "
"for all running page faults we sync the filesystem which will clean all "
"dirty pages and inodes (no new dirty pages or inodes can be created when "
"sync is running)."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2053
msgid ""
"SB_FREEZE_FS: The file system is frozen. Now all internal sources of fs "
"modification are blocked (e.g. XFS preallocation truncation on inode "
"reclaim). This is usually implemented by blocking new transactions for "
"filesystems that have them and need this additional guard. After all "
"internal writers are finished we call ->freeze_fs() to finish filesystem "
"freezing. Then we transition to SB_FREEZE_COMPLETE state. This state is "
"mostly auxiliary for filesystems to verify they do not modify frozen fs."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2061
msgid "sb->s_writers.frozen is protected by sb->s_umount."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2064
msgid ""
"If the freeze was successful zero is returned. If the freeze failed a "
"negative error code is returned."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2215
msgid "unlock filesystem"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2216
msgid "the super to thaw"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2219
msgid ""
"Unlocks the filesystem and marks it writeable again after freeze_super() if "
"there are no remaining freezes on the filesystem."
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2222
msgid ""
"**who** should be: * ``FREEZE_HOLDER_USERSPACE`` if userspace wants to thaw "
"the fs; * ``FREEZE_HOLDER_KERNEL`` if the kernel wants to thaw the fs. * "
"``FREEZE_MAY_NEST`` whether nesting freeze and thaw requests is allowed"
msgstr ""

#: ../../../filesystems/api-summary:38: fs/super.c:2227
msgid ""
"A filesystem may hold multiple devices and thus a filesystems may have been "
"frozen through the block layer via multiple block devices. The filesystem "
"remains frozen until all block devices are unfrozen."
msgstr ""

#: ../../../filesystems/api-summary.rst:42
msgid "File Locks"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:323
msgid "Check for blocking lock requests"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:329
msgid "``struct file_lock_context *flctx``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:324
msgid "file lock context"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:326
msgid "``fl_owner_t owner``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:325
msgid "lock owner"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:326
msgid "Return values:"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:327
msgid ""
"``true``: **owner** has at least one blocker ``false``: **owner** has no "
"blockers"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:771
msgid "stop waiting for a file lock"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:777
msgid "``struct file_lock *waiter``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:772
msgid "the lock which was waiting"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:773
msgid "lockd/nfsd need to disconnect the lock while working on it."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1386
#: ../../../filesystems/api-summary:47: fs/locks.c:1407
msgid "Apply a POSIX-style lock to a file"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1392 fs/locks.c:1925
#: fs/locks.c:2002 fs/locks.c:2192 fs/locks.c:2321 fs/locks.c:2716
#: ../../../filesystems/api-summary:47: fs/locks.c:1684 fs/locks.c:1734
#: fs/locks.c:2059 ../../../filesystems/api-summary:83: fs/libfs.c:1688
msgid "``struct file *filp``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1387 fs/locks.c:2316
msgid "The file to apply the lock to"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1389 fs/locks.c:2100
#: fs/locks.c:2189 fs/locks.c:2319 fs/locks.c:2713
#: ../../../filesystems/api-summary:47: fs/locks.c:1410 fs/locks.c:2076
msgid "``struct file_lock *fl``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1388 fs/locks.c:2099
#: fs/locks.c:2318 ../../../filesystems/api-summary:47: fs/locks.c:1409
#: fs/locks.c:2075
msgid "The lock to be applied"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1390
msgid "``struct file_lock *conflock``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1389 fs/locks.c:2319
msgid "Place to return a copy of the conflicting lock, if found."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1390
msgid ""
"Add a POSIX style lock to a file. We merge adjacent & overlapping locks "
"whenever possible. POSIX locks are sorted by owner task, then by starting "
"address"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1394
msgid ""
"Note that if called with an FL_EXISTS argument, the caller may determine "
"whether or not a lock was successfully freed by testing the return value for "
"-ENOENT."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1530
msgid "revoke all outstanding leases on file"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1531
msgid "the inode of the file to return"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1533
msgid "``unsigned int mode``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1532
msgid "O_RDONLY: break only write leases; O_WRONLY or O_RDWR: break all leases"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1535
msgid "``unsigned int type``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1534
msgid ""
"FL_LEASE: break leases and delegations; FL_DELEG: break only delegations"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1536
msgid ""
"break_lease (inlined for speed) has checked there already is at least some "
"kind of lock (maybe a lease) on this file.  Leases are broken on a call to "
"open() or truncate().  This function can sleep unless you specified "
"``O_NONBLOCK`` to your open()."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1648
msgid "update modified time of an inode with exclusive lease"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1649
msgid "the inode"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1651
msgid "``struct timespec64 *time``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1650
msgid "pointer to a timespec which contains the last modified time"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1651
msgid ""
"This is to force NFS clients to flush their caches for files with exclusive "
"leases.  The justification is that if someone has an exclusive lease, then "
"they could be modifying it."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1919 fs/locks.c:1996
#: ../../../filesystems/api-summary:47: fs/locks.c:2056
msgid "sets a lease on an open file"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1920 fs/locks.c:1997
#: ../../../filesystems/api-summary:47: fs/locks.c:2058
#: ../../../filesystems/api-summary:83: fs/libfs.c:1683
msgid "file pointer"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1922 fs/locks.c:1999
#: ../../../filesystems/api-summary:47: fs/locks.c:2060
#: ../../../filesystems/api-summary:83: fs/libfs.c:1685
msgid "``int arg``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1921 fs/locks.c:1998
#: ../../../filesystems/api-summary:47: fs/locks.c:2059
#: ../../../filesystems/api-summary:83: fs/libfs.c:1684
msgid "type of lease to obtain"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1923
#: ../../../filesystems/api-summary:83: fs/libfs.c:1686
msgid "``struct file_lease **flp``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1922
msgid "input - file_lock to use, output - file_lock inserted"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1924 fs/locks.c:2001
#: ../../../filesystems/api-summary:83: fs/libfs.c:1687
msgid "``void **priv``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1923
msgid "private data for lm_setup (may be NULL if lm_setup doesn't require it)"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1925
msgid ""
"The (input) flp->fl_lmops->lm_break function is required by break_lease()."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2000
msgid "``struct file_lease **lease``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:1999
msgid "file_lock to use when adding a lease"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2000
msgid ""
"private info for lm_setup when adding a lease (may be NULL if lm_setup "
"doesn't require it)"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2002
msgid ""
"Call this to establish a lease on the file. The \"lease\" argument is not "
"used for F_UNLCK requests and may be NULL. For commands that set or alter an "
"existing lease, the ``(*lease)->fl_lmops->lm_break`` operation must be set; "
"if not, this function will return -ENOLCK (and generate a scary-looking "
"stack trace)."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2008
msgid ""
"The \"priv\" pointer is passed directly to the lm_setup function as-is. It "
"may be NULL if the lm_setup operation doesn't require it."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2097
msgid "Apply a lock to an inode"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2098
#: ../../../filesystems/api-summary:47: fs/locks.c:2074
msgid "inode of the file to apply to"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2100
msgid "Apply a POSIX or FLOCK style lock request to an inode."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2186
msgid "test file byte range lock"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2187
msgid "The file to test lock for"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2188
msgid "The lock to test; also used to hold result"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2189
msgid ""
"Returns -ERRNO on failure.  Indicates presence of conflicting lock by "
"setting conf->fl_type to something other than F_UNLCK."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2315
msgid "file byte range lock"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2318
#: ../../../filesystems/api-summary:47: fs/locks.c:2124
msgid "``unsigned int cmd``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2317
msgid "type of locking operation (F_SETLK, F_GETLK, etc.)"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2320
msgid "``struct file_lock *conf``"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2320
msgid ""
"A caller that doesn't care about the conflicting lock may pass NULL as the "
"final argument."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2323
msgid ""
"If the filesystem defines a private ->lock() method, then **conf** will be "
"left unchanged; so a caller that cares should initialize it to some "
"acceptable default."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2327
msgid ""
"To avoid blocking kernel daemons, such as lockd, that need to acquire POSIX "
"locks, the ->lock() interface may return asynchronously, before the lock has "
"been granted or denied by the underlying filesystem, if (and only if) "
"lm_grant is set. Additionally FOP_ASYNC_LOCK in file_operations fop_flags "
"need to be set."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2333
msgid ""
"Callers expecting ->lock() to return asynchronously will only use F_SETLK, "
"not F_SETLKW; they will set FL_SLEEP if (and only if) the request is for a "
"blocking lock. When ->lock() does return asynchronously, it must return "
"FILE_LOCK_DEFERRED, and call ->lm_grant() when the lock request completes. "
"If the request is for non-blocking lock the file system should return "
"FILE_LOCK_DEFERRED then try to get the lock and call the callback routine "
"with the result. If the request timed out the callback routine will return a "
"nonzero return code and the file system should release the lock. The file "
"system is also responsible to keep a corresponding posix lock when it grants "
"a lock so the VFS can find out which locks are locally held and do the "
"correct lock cleanup when required. The underlying filesystem must not drop "
"the kernel lock or call ->lm_grant() before returning to the caller with a "
"FILE_LOCK_DEFERRED return code."
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2710
msgid "file byte range unblock lock"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2711
msgid "The file to apply the unblock to"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2712
msgid "The lock to be unblocked"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2713
msgid "Used by lock managers to cancel blocked requests"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2726
msgid "are any file locks held on **inode**?"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2727
msgid "inode to check for locks"
msgstr ""

#: ../../../filesystems/api-summary:44: fs/locks.c:2728
msgid ""
"Return true if there are any FL_POSIX or FL_FLOCK locks currently set on "
"**inode**."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1408
msgid "inode of file to which lock request should be applied"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1410
msgid "Apply a POSIX style lock request to an inode."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1678
msgid "Enquire what lease is currently active"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1679
msgid "the file"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1680
msgid ""
"The value returned by this function will be one of (if no lease break is "
"pending):"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1683
msgid "``F_RDLCK`` to indicate a shared lease is held."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1685
msgid "``F_WRLCK`` to indicate an exclusive lease is held."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1687
msgid "``F_UNLCK`` to indicate no lease is held."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1689
msgid "(if a lease break is pending):"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1691
msgid "``F_RDLCK`` to indicate an exclusive lease needs to be"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1692
msgid "changed to a shared lease (or removed)."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1694
msgid "``F_UNLCK`` to indicate the lease needs to be removed."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1696
msgid ""
"XXX: sfr & willy disagree over whether F_INPROGRESS should be returned to "
"userspace."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1728
msgid ""
"see if the given file points to an inode that has an existing open that "
"would conflict with the desired lease."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1731
msgid "file to check"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1733
msgid "``const int arg``"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1732
msgid "type of lease that we're trying to acquire"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1733
msgid "current lock flags"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:1734
msgid ""
"Check to see if there's an existing open fd on this file that would conflict "
"with the lease we're trying to set."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2062 fs/locks.c:2127
msgid "``unsigned int fd``"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2057
msgid "open file descriptor"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2060
msgid ""
"Call this fcntl to establish a lease on the file. Note that you also need to "
"call ``F_SETSIG`` to receive a signal when the lease is broken."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2073
msgid "Apply a FLOCK-style lock to a file"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2076
msgid "Apply a FLOCK style lock request to an inode."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2121
msgid "flock() system call."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2122
msgid "the file descriptor to lock."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2123
msgid "the type of lock to apply."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2124
msgid ""
"Apply a ``FL_FLOCK`` style lock to an open file descriptor. The **cmd** can "
"be one of:"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2127
msgid "``LOCK_SH`` -- a shared lock."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2128
msgid "``LOCK_EX`` -- an exclusive lock."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2129
msgid "``LOCK_UN`` -- remove an existing lock."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2130
msgid "``LOCK_MAND`` -- a 'mandatory' flock. (DEPRECATED)"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2132
msgid "``LOCK_MAND`` support has been removed from the kernel."
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2204
msgid "translate a file_lock's fl_pid number into a namespace"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2210
msgid "``struct file_lock_core *fl``"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2205
msgid "The file_lock who's fl_pid should be translated"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2207
msgid "``struct pid_namespace *ns``"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2206
msgid "The namespace into which the pid should be translated"
msgstr ""

#: ../../../filesystems/api-summary:47: fs/locks.c:2207
msgid "Used to translate a fl_pid into a namespace virtual pid number"
msgstr ""

#: ../../../filesystems/api-summary.rst:51
msgid "Other Functions"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:321
msgid "start reads against pages"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:327
msgid "``struct readahead_control *rac``"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:322
msgid "Describes which pages to read."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:324 fs/mpage.c:653
msgid "``get_block_t get_block``"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:323
msgid "The filesystem's block mapper function."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:324
msgid ""
"This function walks the pages and the blocks within each page, building and "
"emitting large BIOs."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:327
msgid "If anything unusual happens, such as:"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:329
msgid "encountering a page which has buffers"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:330
msgid "encountering a page which has a non-hole after a hole"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:331
msgid "encountering a page with non-contiguous blocks"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:333
msgid ""
"then this code just gives up and calls the buffer_head-based read function. "
"It does handle a page which has holes at the end - that is a common case: "
"the end-of-file on blocksize < PAGE_SIZE setups."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:337
msgid "BH_Boundary explanation:"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:339
msgid ""
"There is a problem.  The mpage read code assembles several pages, gets all "
"their disk mappings, and then submits them all.  That's fine, but obtaining "
"the disk mappings may require I/O.  Reads of indirect blocks, for example."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:343
msgid ""
"So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be "
"submitted in the following order:"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:346
msgid "12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:348
msgid ""
"because the indirect block has to be read to get the mappings of blocks "
"13,14,15,16.  Obviously, this impacts performance."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:351
msgid ""
"So what we do it to allow the filesystem's get_block() function to set "
"BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block "
"after this one will require I/O against a block which is probably close to "
"this one.  So you should push what I/O you have currently accumulated."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:356
msgid "This all causes the disk requests to be issued in the correct order."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:649
msgid ""
"walk the list of dirty pages of the given address space & writepage() all of "
"them"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:655
#: ../../../filesystems/api-summary:80: fs/dax.c:743
msgid "``struct address_space *mapping``"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:650
msgid "address space structure to write"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:652
#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:812
#: fs/fs-writeback.c:830 fs/fs-writeback.c:953
msgid "``struct writeback_control *wbc``"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:651
msgid "subtract the number of written pages from ***wbc->nr_to_write**"
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:652
msgid "the filesystem's block mapper function."
msgstr ""

#: ../../../filesystems/api-summary:53: fs/mpage.c:653
msgid ""
"This is a library function, which implements the writepages() "
"address_space_operation."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:443
msgid "check for access rights on a Posix-like filesystem"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:445
msgid "inode to check access rights for"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:447 fs/namei.c:561
msgid "``int mask``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:446
msgid ""
"right to check for (``MAY_READ``, ``MAY_WRITE``, ``MAY_EXEC``, "
"``MAY_NOT_BLOCK`` ...)"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:448
msgid ""
"Used to check for read/write/execute permissions on a file. We use \"fsuid\" "
"for this, letting us set arbitrary permissions for filesystem access without "
"changing the \"normal\" uids which are used for other things."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:453
msgid ""
"generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk "
"request cannot be satisfied (eg. requires blocking or too much complexity). "
"It would then be called again in ref-walk mode."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:557
msgid "Check for access rights to a given inode"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:559
msgid "Inode to check permission on"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:560
msgid "Right to check for (``MAY_READ``, ``MAY_WRITE``, ``MAY_EXEC``)"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:561
msgid ""
"Check for read/write/execute permissions on an inode.  We use fs[ug]id for "
"this, letting us set arbitrary permissions for filesystem access without "
"changing the \"normal\" UIDs which are used for other things."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:565
msgid "When checking for MAY_APPEND, MAY_WRITE must also be set in **mask**."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:606
msgid "get a reference to a path"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:612 fs/namei.c:625
#: ../../../filesystems/api-summary:62: fs/seq_file.c:465
#: ../../../filesystems/api-summary:77: fs/d_path.c:256
#: ../../../filesystems/api-summary:89: fs/stat.c:175
#: ../../../filesystems/api-summary:98: fs/namespace.c:1456 fs/namespace.c:2365
msgid "``const struct path *path``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:607
msgid "path to get the reference to"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:608
msgid ""
"Given a path increment the reference count to the dentry and the vfsmount."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:619
msgid "put a reference to a path"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:620
msgid "path to put the reference to"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:621
msgid ""
"Given a path decrement the reference count to the dentry and the vfsmount."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2872
msgid "lookup a parent path relative to a dentry-vfsmount pair"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2878
msgid "``struct filename *filename``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2873
msgid "filename structure"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2874 fs/namei.c:2894
msgid "lookup flags"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2876
msgid "``struct path *parent``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2875 fs/namei.c:2895
msgid "pointer to struct path to fill"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2877
msgid "``struct qstr *last``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2876
msgid "last component"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2878
msgid "``int *type``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2877
msgid "type of the last component"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2879
msgid "``const struct path *root``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2878
msgid "pointer to struct path of the base directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2890
msgid "lookup a file path relative to a dentry-vfsmount pair"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2891
msgid "pointer to dentry of the base directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2893
#: ../../../filesystems/api-summary:98: fs/namespace.c:567 fs/namespace.c:583
#: fs/namespace.c:1618 fs/namespace.c:3794
msgid "``struct vfsmount *mnt``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2892
msgid "pointer to vfs mount of the base directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2893
msgid "pointer to file name"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2896
msgid "``struct path *path``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2953 fs/namei.c:2980
#: fs/namei.c:3133
msgid "filesystem helper to lookup single pathname component"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2954 fs/namei.c:2981
msgid "qstr storing pathname component to lookup"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2956 fs/namei.c:2983
#: fs/namei.c:3010 fs/namei.c:3037 fs/namei.c:3065 fs/namei.c:3106
#: fs/namei.c:3136
msgid "``struct dentry *base``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2955 fs/namei.c:2982
#: fs/namei.c:3009 fs/namei.c:3036 fs/namei.c:3064 fs/namei.c:3105
#: fs/namei.c:3135
msgid "base directory to lookup from"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2956
msgid ""
"Look up a dentry by name in the dcache, returning NULL if it does not "
"currently exist.  The function does not try to create a dentry and if one is "
"found it doesn't try to revalidate it."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2960 fs/namei.c:2983
msgid ""
"Note that this routine is purely a helper for filesystem usage and should "
"not be called by generic code.  It does no permission checking."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2963
msgid "No locks need be held - only a counted reference to **base** is needed."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:2986 fs/namei.c:3012
msgid "The caller must hold base->i_rwsem."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3006 fs/namei.c:3033
#: fs/namei.c:3061 fs/namei.c:3102
msgid "lookup single pathname component"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3007 fs/namei.c:3034
#: fs/namei.c:3062 fs/namei.c:3103
msgid "idmap of the mount the lookup is performed from"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3008 fs/namei.c:3104
msgid "qstr holding pathname component to lookup"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3010 fs/namei.c:3037
#: fs/namei.c:3072 fs/namei.c:3113
msgid "This can be used for in-kernel filesystem clients such as file servers."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3035 fs/namei.c:3063
msgid "qstr olding pathname component to lookup"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3039
msgid ""
"Unlike lookup_one, it should be called without the parent i_rwsem held, and "
"will take the i_rwsem itself if necessary."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3065 fs/namei.c:3106
msgid ""
"This helper will yield ERR_PTR(-ENOENT) on negatives. The helper returns "
"known positive or ERR_PTR(). This is what most of the users want."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3068 fs/namei.c:3109
msgid ""
"Note that pinned negative with unlocked parent _can_ become positive at any "
"time, so callers of lookup_one_unlocked() need to be very careful; pinned "
"positives have >d_inode stable, so this one avoids such problems."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3074
msgid ""
"It should be called without the parent i_rwsem held, and will take the "
"i_rwsem itself if necessary.  If a fatal signal is pending or delivered, it "
"will return ``-EINTR`` if the lock is needed."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3115
msgid "The helper should be called without i_rwsem held."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3134
msgid "pathname component to lookup"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3136
msgid ""
"Note that this routine is purely a helper for filesystem usage and should "
"not be called by generic code. It does no permission checking."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3139
msgid ""
"Unlike lookup_noperm(), it should be called without the parent i_rwsem held, "
"and will take the i_rwsem itself if necessary."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3142
msgid ""
"Unlike try_lookup_noperm() it *does* revalidate the dentry if it already "
"existed."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3462
msgid "create new file"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3464 fs/namei.c:4284
#: fs/namei.c:4411 fs/namei.c:4514 fs/namei.c:4789
msgid "inode of the parent directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3465
msgid "dentry of the child file"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3466
msgid "mode of the child file"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3468
msgid "``bool want_excl``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3467
msgid "whether the file must not yet exist"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:3468
msgid "Create a new file."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4047
msgid "open a tmpfile for kernel internal use"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4050
msgid "``const struct path *parentpath``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4049
msgid "path of the base directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4050
msgid "mode of the new tmpfile"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4052
msgid "``int open_flag``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4051
msgid "flags"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4053
msgid "``const struct cred *cred``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4052
msgid "credentials for open"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4053
msgid ""
"Create and open a temporary file.  The file is not accounted in nr_files, "
"hence this is only for kernel internal use, and must not be installed into "
"file tables or such."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4282
msgid "create device node or file"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4285
msgid "dentry of the child device node"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4286
msgid "mode of the child device node"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4287
msgid "device number of device to create"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4288
msgid "Create a device node or file."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4409
msgid "create directory returning correct dentry if possible"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4412 fs/namei.c:4515
msgid "dentry of the child directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4413
msgid "mode of the child directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4414
msgid "Create a directory."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4422
msgid ""
"In the event that the filesystem does not use the ***dentry** but leaves it "
"negative or unhashes it and possibly splices a different one returning it, "
"the original dentry is dput() and the alternate is returned."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4426
msgid "In case of an error the dentry is dput() and an ERR_PTR() is returned."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4512
msgid "remove directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4516
msgid "Remove a directory."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4626
msgid "unlink a filesystem object"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4628
msgid "parent directory"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4629
msgid "victim"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4631 fs/namei.c:4874
#: ../../../filesystems/api-summary:74: fs/attr.c:396
#: ../../../filesystems/api-summary:95: fs/xattr.c:272 fs/xattr.c:531
msgid "``struct inode **delegated_inode``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4630
msgid "returns victim inode, if the inode is delegated."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4631 fs/namei.c:4874
msgid "The caller must hold dir->i_rwsem exclusively."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4633
msgid ""
"If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and return "
"a reference to the inode in delegated_inode.  The caller should then break "
"the delegation on that inode and retry.  Because breaking a delegation may "
"take a long time, the caller should drop dir->i_rwsem before doing so."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4639 fs/namei.c:4882
#: fs/namei.c:5060
msgid ""
"Alternatively, a caller may pass NULL for delegated_inode.  This may be "
"appropriate for callers that expect the underlying filesystem not to be NFS "
"exported."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4787
msgid "create symlink"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4790
msgid "dentry of the child symlink file"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4792
msgid "``const char *oldname``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4791
msgid "name of the file to link to"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4792
msgid "Create a symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4868
msgid "create a new link"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4869
msgid "object to be linked"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4870
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1078 fs/posix_acl.c:1156
#: fs/posix_acl.c:1201
msgid "idmap of the mount"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4871
msgid "new parent"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4872
msgid "where to create the new link"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4873
msgid "returns inode needing a delegation break"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:4876
msgid ""
"If vfs_link discovers a delegation on the to-be-linked file in need of "
"breaking, it will return -EWOULDBLOCK and return a reference to the inode in "
"delegated_inode.  The caller should then break the delegation and retry.  "
"Because breaking a delegation may take a long time, the caller should drop "
"the i_rwsem before doing so."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5049
msgid "rename a filesystem object"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5055
msgid "``struct renamedata *rd``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5050
msgid "pointer to :c:type:`struct renamedata <renamedata>` info"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5051
msgid "The caller must hold multiple mutexes--see lock_rename())."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5053
msgid ""
"If vfs_rename discovers a delegation in need of breaking at either the "
"source or destination, it will return -EWOULDBLOCK and return a reference to "
"the inode in delegated_inode.  The caller should then break the delegation "
"and retry.  Because breaking a delegation may take a long time, the caller "
"should drop all locks before doing so."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5064
msgid ""
"The worst of all namespace operations - renaming directory. \"Perverted\" "
"doesn't even start to describe it. Somebody in UCB had a heck of a trip... "
"Problems:"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5068
msgid "we can get into loop creation."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5069
msgid ""
"race potential - two innocent renames can create a loop together. That's "
"where 4.4BSD screws up. Current fix: serialization on sb-"
">s_vfs_rename_mutex. We might be more accurate, but that's another story."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5073
msgid ""
"we may have to lock up to _four_ objects - parents and victim (if it "
"exists), and source (if it's a non-directory or a subdirectory that moves to "
"different parent). And that - after we got ->i_rwsem on parents (until then "
"we don't know whether the target exists).  Solution: try to be smart with "
"locking order for inodes.  We rely on the fact that tree topology may change "
"only under ->s_vfs_rename_mutex _and_ that parent of the object we move will "
"be locked.  Thus we can rank directories by the tree (ancestors first) and "
"rank all non-directories after them. That works since everybody except "
"rename does \"lock parent, lookup, lock child\" and rename is under -"
">s_vfs_rename_mutex. HOWEVER, it relies on the assumption that any object "
"with ->lookup() has no more than 1 dentry.  If \"hybrid\" objects will ever "
"appear, we'd better make sure that there's no link(2) for them."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5087
msgid ""
"conversion from fhandle to dentry may come in the wrong moment - when we are "
"removing the target. Solution: we will have to grab ->i_rwsem in the "
"fhandle_to_dentry code. [FIXME - current nfsfh.c relies on ->i_rwsem on "
"parents, which works but leads to some truly excessive locking]."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5428
msgid "copy symlink body into userspace buffer"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5429 fs/namei.c:5473
msgid "dentry on which to get symbolic link"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5431
msgid "``char __user *buffer``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5430
msgid "user memory pointer"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5432
#: ../../../filesystems/api-summary:77: fs/d_path.c:254
msgid "``int buflen``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5431
msgid "size of buffer"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5432
msgid "Does not touch atime.  That's up to the caller if necessary"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5434
msgid "Does not call security hook."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5472
msgid "get symlink body"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5475
#: ../../../filesystems/api-summary:83: fs/libfs.c:1704
msgid "``struct delayed_call *done``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5474
msgid "caller needs to free returned data with this"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5475
msgid "Calls security hook and i_op->get_link() on the supplied inode."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5477
msgid "It does not touch atime.  That's up to the caller if necessary."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5479
msgid "Does not work on \"special\" symlinks like /proc/$$/fd/N"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5529
msgid "An implementation of the get_link inode_operation."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5530
msgid "The directory entry which is the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5531
msgid "The inode for the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5533
msgid "``struct delayed_call *callback``"
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5532
msgid "Used to drop the reference to the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5533
msgid ""
"Filesystems which store their symlinks in the page cache should use this to "
"implement the get_link() member of their inode_operations."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5537
msgid "A pointer to the NUL-terminated symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5551
msgid "Drop the reference to the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5552
msgid "The folio which contains the symlink."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5553
msgid ""
"This is used internally by page_get_link().  It is exported for use by "
"filesystems which need to implement a variant of page_get_link() "
"themselves.  Despite the apparent symmetry, filesystems which use "
"page_get_link() do not need to call page_put_link()."
msgstr ""

#: ../../../filesystems/api-summary:56: fs/namei.c:5558
msgid ""
"The argument, while it has a void pointer type, must be a pointer to the "
"folio which was retrieved from the page cache.  The delayed_call "
"infrastructure is used to drop the reference count once the caller is done "
"with the symlink."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:290
msgid "reinitialize a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:296 block/bio.c:335
#: block/bio.c:815 block/bio.c:888 block/bio.c:978 block/bio.c:1003
#: block/bio.c:1019 block/bio.c:1066 block/bio.c:1091 block/bio.c:1118
#: block/bio.c:1376 block/bio.c:1623 block/bio.c:1683 block/bio.c:1733
msgid "``struct bio *bio``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:291
msgid "bio to reset"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:293 block/bio.c:480
#: block/bio.c:860 block/bio.c:891 block/bio.c:1402
msgid "``struct block_device *bdev``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:292
msgid "block device to use the bio for"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:294 block/bio.c:478
msgid "``blk_opf_t opf``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:293 block/bio.c:477
msgid "operation and flags for bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:295
msgid ""
"After calling bio_reset(), **bio** will be in the same state as a freshly "
"allocated bio returned bio bio_alloc_bioset() - the only fields that are "
"preserved are the ones that are initialized by bio_alloc_bioset(). See "
"comment in struct bio."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:329
msgid "chain bio completions"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:330
msgid "the target bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:332
msgid "``struct bio *parent``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:331
msgid "the parent bio of **bio**"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:332
msgid ""
"The caller won't have a bi_end_io called when **bio** completes - instead, "
"**parent**'s bi_end_io won't be called until both **parent** and **bio** "
"have completed; the chained bio will also be freed when it completes."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:336
msgid "The caller must not set bi_private or bi_end_io in **bio**."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:474
msgid "allocate a bio for I/O"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:475
msgid "block device to allocate the bio for (can be ``NULL``)"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:477 block/bio.c:605
msgid "``unsigned short nr_vecs``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:476
msgid "number of bvecs to pre-allocate"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:479 block/bio.c:602
msgid "``gfp_t gfp_mask``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:478 block/bio.c:601
msgid "the GFP_* mask given to the slab allocator"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:480 block/bio.c:859
#: block/bio.c:1682 block/bio.c:1797
msgid "``struct bio_set *bs``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:479
msgid "the bio_set to allocate from."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:480
msgid "Allocate a bio from the mempools in **bs**."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:482
msgid ""
"If ``__GFP_DIRECT_RECLAIM`` is set then bio_alloc will always be able to "
"allocate a bio.  This is due to the mempool guarantees.  To make this work, "
"callers must never allocate more than 1 bio at a time from the general pool. "
"Callers that need to allocate more than 1 bio must always submit the "
"previously allocated bio for IO before attempting to allocate a new one. "
"Failure to do so can cause deadlocks under memory pressure."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:489
msgid ""
"Note that when running under submit_bio_noacct() (i.e. any block driver), "
"bios are not submitted until after you return - see the code in "
"submit_bio_noacct() that converts recursion into iteration, to prevent stack "
"overflows."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:494
msgid ""
"This would normally mean allocating multiple bios under submit_bio_noacct() "
"would be susceptible to deadlocks, but we have deadlock avoidance code that "
"resubmits any blocked bios from a rescuer thread."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:499
msgid ""
"However, we do not guarantee forward progress for allocations from other "
"mempools. Doing multiple allocations from the same mempool under "
"submit_bio_noacct() should be avoided - instead, use bio_set's front_pad for "
"per bio allocations."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:505 block/bio.c:612
msgid "Pointer to new bio on success, NULL on failure."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:599
msgid "kmalloc a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:600
msgid "number of bio_vecs to allocate"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:602
msgid ""
"Use kmalloc to allocate a bio (including bvecs).  The bio must be "
"initialized using bio_init() before use.  To free a bio returned from this "
"function use kfree() after calling bio_uninit().  A bio returned from this "
"function can be reused by calling bio_uninit() before calling bio_init() "
"again."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:607
msgid ""
"Note that unlike bio_alloc() or bio_alloc_bioset() allocations from this "
"function are not backed by a mempool can fail.  Do not use this function for "
"allocations in the file system I/O path."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:809
msgid "release a reference to a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:810
msgid "bio to release reference to"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:812
msgid ""
"Put a reference to a :c:type:`struct bio <bio>`, either one you have gotten "
"with bio_alloc, bio_get or bio_clone_*. The last put of a bio will free it."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:854 block/bio.c:885
msgid "clone a bio that shares the original bio's biovec"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:855 block/bio.c:886
msgid "block_device to clone onto"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:857 block/bio.c:889
msgid "``struct bio *bio_src``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:856 block/bio.c:888
msgid "bio to clone from"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:857 block/bio.c:889
msgid "allocation priority"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:858
msgid "bio_set to allocate from"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:859
msgid ""
"Allocate a new bio that is a clone of **bio_src**. The caller owns the "
"returned bio, but not the actual data it points to."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:862
msgid ""
"The caller must ensure that the return bio is not freed before **bio_src**."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:887
msgid "bio to clone into"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:890
msgid ""
"Initialize a new bio in caller provided memory that is a clone of "
"**bio_src**. The caller owns the returned bio, but not the actual data it "
"points to."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:893
msgid "The caller must ensure that **bio_src** is not freed before **bio**."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:972
msgid "add page(s) to a bio in a new segment"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:973 block/bio.c:998
#: block/bio.c:1014 block/bio.c:1086 block/bio.c:1113 block/bio.c:1479
msgid "destination bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:975 block/bio.c:1016
msgid "``struct page *page``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:974 block/bio.c:1015
msgid "start page to add"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:976 block/bio.c:1017
#: block/bio.c:1116 ../../../filesystems/api-summary:83: fs/libfs.c:1797
msgid "``unsigned int len``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:975 block/bio.c:1000
msgid "length of the data to add, may cross pages"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:977
msgid "``unsigned int off``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:976
msgid "offset of the data relative to **page**, may cross pages"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:977
msgid ""
"Add the data at **page** + **off** to **bio** as a new bvec.  The caller "
"must ensure that **bio** has space for another bvec."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:997
msgid "add data in the direct kernel mapping to a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1000 block/bio.c:1088
#: block/bio.c:1115
msgid "``void *vaddr``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:999
msgid "data to add"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1001 block/bio.c:1089
msgid "``unsigned len``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1001
msgid ""
"Add the data at **vaddr** to **bio**.  The caller must have ensure a segment "
"is available for the added data.  No merging into an existing segment will "
"be performed."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1013
msgid "attempt to add page(s) to bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1016
msgid "vec entry length, may cross pages"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1018
msgid "``unsigned int offset``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1017
msgid "vec entry offset relative to **page**, may cross pages"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1018
msgid ""
"Attempt to add page(s) to the bio_vec maplist. This will only fail if either "
"bio->bi_vcnt == bio->bi_max_vecs or it's a cloned bio."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1060
msgid "Attempt to add part of a folio to a bio."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1061
msgid "BIO to add to."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1063
#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:950
msgid "``struct folio *folio``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1062
msgid "Folio to add."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1063
msgid "How many bytes from the folio to add."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1065
msgid "``size_t off``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1064
msgid "First byte in this folio to add."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1065
msgid ""
"Filesystems that use folios can call this function instead of calling "
"bio_add_page() for each page in the folio.  If **off** is bigger than "
"PAGE_SIZE, this function can create a bio_vec that starts in a page after "
"the bv_page.  BIOs do not support folios that are 4GiB or larger."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1071
msgid "Whether the addition was successful."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1085
msgid "add a vmalloc chunk to a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1087 block/bio.c:1114
msgid "vmalloc address to add"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1088 block/bio.c:1115
msgid "total length in bytes of the data to add"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1089
msgid ""
"Add data starting at **vaddr** to **bio** and return how many bytes were "
"added. This may be less than the amount originally asked.  Returns 0 if no "
"data could be added to **bio**."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1093 block/bio.c:1119
msgid ""
"This helper calls flush_kernel_vmap_range() for the range added.  For reads "
"the caller still needs to manually call invalidate_kernel_vmap_range() in "
"the completion handler."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1112
msgid "add a vmalloc region to a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1116
msgid ""
"Add data starting at **vaddr** to **bio**.  Return ``true`` on success or "
"``false`` if **bio** does not have enough space for the payload."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1370
msgid "submit a bio, and wait until it completes"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1371
msgid "The :c:type:`struct bio <bio>` which describes the I/O"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1372
msgid ""
"Simple wrapper around submit_bio(). Returns 0 on success, or the error from "
"bio_endio() on failure."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1375
msgid ""
"WARNING: Unlike to how submit_bio() is usually used, this function does not "
"result in bio reference to be consumed. The caller must drop the reference "
"on his own."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1396
msgid "synchronously read into / write from kernel mapping"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1397
msgid "block device to access"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1399
msgid "``sector_t sector``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1398
msgid "sector to access"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1399
msgid "data to read/write"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1400
msgid "length in byte to read/write"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1402
msgid "``enum req_op op``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1401
msgid "operation (e.g. REQ_OP_READ/REQ_OP_WRITE)"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1402
msgid ""
"Performs synchronous I/O to **bdev** for **data**/**len**.  **data** must be "
"in the kernel direct mapping and not a vmalloc address."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1477
msgid "copy contents of data buffers from one bio to another"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1483
msgid "``struct bio *dst``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1481
msgid "``struct bio *src``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1478
msgid "source bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1480
msgid ""
"Stops when it reaches the end of either **src** or **dst** - that is, copies "
"min(src->bi_size, dst->bi_size) bytes (or the equivalent for lists of bios)."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1617
msgid "end I/O on a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1618
msgid "bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1620
msgid ""
"bio_endio() will end I/O on the whole bio. bio_endio() is the preferred way "
"to end I/O on a bio. No one should call bi_end_io() directly on a bio unless "
"they own it and thus know that it has an end_io function."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1624
msgid ""
"bio_endio() can be called several times on a bio that has been chained using "
"bio_chain().  The ->bi_end_io() function will only be called the last time."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1677
msgid "split a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1678
msgid "bio to split"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1680
msgid "``int sectors``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1679
msgid "number of sectors to split from the front of **bio**"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1680
msgid "gfp mask"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1681
msgid "bio set to allocate from"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1682
msgid ""
"Allocates and returns a new bio which represents **sectors** from the start "
"of **bio**, and updates **bio** to represent the remaining sectors."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1685
msgid ""
"Unless this is a discard request the newly allocated bio will point to "
"**bio**'s bi_io_vec. It is the caller's responsibility to ensure that "
"neither **bio** nor **bs** are freed before the split bio."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1727
msgid "trim a bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1728
msgid "bio to trim"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1730
msgid "``sector_t offset``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1729
msgid "number of sectors to trim from the front of **bio**"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1731
msgid "``sector_t size``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1730
msgid "size we want to trim **bio** to, in sectors"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1731
msgid ""
"This function is typically used for bios that are cloned and submitted to "
"the underlying device in parts."
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1791
msgid "Initialize a bio_set"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1792
msgid "pool to initialize"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1794
msgid "``unsigned int pool_size``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1793
msgid "Number of bio and bio_vecs to cache in the mempool"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1795
msgid "``unsigned int front_pad``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1794
msgid "Number of bytes to allocate in front of the returned bio"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1795
msgid ""
"Flags to modify behavior, currently ``BIOSET_NEED_BVECS`` and "
"``BIOSET_NEED_RESCUER``"
msgstr ""

#: ../../../filesystems/api-summary:59: block/bio.c:1798
msgid ""
"Set up a bio_set to be used with **bio_alloc_bioset**. Allows the caller to "
"ask for a number of bytes to be allocated in front of the bio. Front pad "
"allocation is useful for embedding the bio inside another structure, to "
"avoid allocating extra data to go with the bio. Note that the bio must be "
"embedded at the END of that structure always, or things will break badly. If "
"``BIOSET_NEED_BVECS`` is set in **flags**, a separate pool will be allocated "
"for allocating iovecs.  This pool is not needed e.g. for bio_init_clone(). "
"If ``BIOSET_NEED_RESCUER`` is set, a workqueue is created which can be used "
"to dispatch queued requests when the mempool runs out of space."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:42
msgid "initialize sequential file"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:43
msgid "file we initialize"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:45
msgid "``const struct seq_operations *op``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:44
msgid "method table describing the sequence"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:45
msgid ""
"seq_open() sets **file**, associating it with a sequence described by "
"**op**.  **op->start\\(\\)** sets the iterator up and returns the first "
"element of sequence. **op->stop\\(\\)** shuts it down.  **op->next\\(\\)** "
"returns the next element of sequence.  **op->show\\(\\)** prints element "
"into the buffer.  In case of error ->start() and ->next() return "
"ERR_PTR(error).  In the end of sequence they return ``NULL``. ->show() "
"returns 0 in case of success and negative number in case of error. Returning "
"SEQ_SKIP means \"discard this element and move on\"."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:54
msgid "seq_open() will allocate a struct seq_file and store its"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:55
msgid "pointer in **file->private_data**. This pointer should not be modified."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:143
msgid "->read() method for sequential files."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:144
msgid "the file to read from"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:146
msgid "``char __user *buf``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:145
msgid "the buffer to read to"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:147
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:754
#: ../../../filesystems/api-summary:95: fs/xattr.c:270 fs/xattr.c:465
msgid "``size_t size``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:146
#: ../../../filesystems/api-summary:83: fs/libfs.c:1112 fs/libfs.c:1150
#: fs/libfs.c:1182
msgid "the maximum number of bytes to read"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:179
#: kernel/sysctl.c:626 kernel/sysctl.c:666 kernel/sysctl.c:685
#: kernel/sysctl.c:745 kernel/sysctl.c:811 kernel/sysctl.c:841
#: kernel/sysctl.c:976 kernel/sysctl.c:998 kernel/sysctl.c:1121
#: kernel/sysctl.c:1154 kernel/sysctl.c:1176 kernel/sysctl.c:1198
#: ../../../filesystems/api-summary:62: fs/seq_file.c:148 fs/seq_file.c:999
#: fs/seq_file.c:1065 ../../../filesystems/api-summary:83: fs/libfs.c:1114
#: fs/libfs.c:1149 fs/libfs.c:1184
msgid "``loff_t *ppos``"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1175
#: ../../../filesystems/api-summary:62: fs/seq_file.c:147
msgid "the current position in the file"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:148
msgid "Ready-made ->f_op->read()"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:301
msgid "->llseek() method for sequential files."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:302
msgid "the file in question"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:304
#: ../../../filesystems/api-summary:74: fs/attr.c:232
msgid "``loff_t offset``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:303
msgid "new position"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:305
msgid "``int whence``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:304
msgid "0 for absolute, 1 for relative position"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:305
msgid "Ready-made ->f_op->llseek()"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:345
msgid "free the structures associated with sequential file."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:346
msgid "its inode"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:347
msgid "file in question"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:348
msgid ""
"Frees the structures associated with sequential file; can be used as ->f_op-"
">release() if you don't have private data to destroy."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:362
msgid "print data into buffer, escaping some characters"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:368 fs/seq_file.c:468
#: fs/seq_file.c:497 fs/seq_file.c:842
msgid "``struct seq_file *m``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:363
msgid "target buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:365
msgid "``const char *src``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:364
msgid "source buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:365
msgid "size of source buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:366
msgid "flags to pass to string_escape_mem()"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:368 fs/seq_file.c:434
#: fs/seq_file.c:466 fs/seq_file.c:495
msgid "``const char *esc``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:367 fs/seq_file.c:433
msgid "set of characters that need escaping"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:368
msgid ""
"Puts data into buffer, replacing each occurrence of character from given "
"class (defined by **flags** and **esc**) with printable escaped sequence."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:371
msgid "Use seq_has_overflowed() to check for errors."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:430
msgid "mangle and copy path to buffer beginning"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:436
msgid "``char *s``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:431
msgid "buffer start"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:433
msgid "``const char *p``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:432
msgid "beginning of path in above buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:434
msgid ""
"Copy the path from **p** to **s**, replacing each occurrence of character "
"from **esc** with usual octal escape. Returns pointer past last written "
"character in **s**, or NULL in case of failure."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:462
msgid "seq_file interface to print a pathname"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:463 fs/seq_file.c:492
msgid "the seq_file handle"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:464
msgid "the struct path to print"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:465 fs/seq_file.c:494
msgid "set of characters to escape in the output"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:466
msgid ""
"return the absolute path of 'path', as represented by the dentry / mnt pair "
"in the path parameter."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:491
msgid "seq_file interface to print a pathname of a file"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:493
msgid "the struct file to print"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:495
msgid "return the absolute path to the file."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:816
msgid "write arbitrary data to buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:822
msgid "``struct seq_file *seq``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:817 fs/seq_file.c:837
msgid "seq_file identifying the buffer to which data should be written"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:819
msgid "``const void *data``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:818
msgid "data address"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:819
msgid "number of bytes"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:820
msgid "Return 0 on success, non-zero otherwise."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:836
msgid "write padding spaces to buffer"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:839
msgid "``char c``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:838
msgid "the byte to append after padding if non-zero"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:960 fs/seq_file.c:978
msgid "start an iteration of a hlist"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:966 fs/seq_file.c:984
#: fs/seq_file.c:998 fs/seq_file.c:1022 fs/seq_file.c:1045 fs/seq_file.c:1064
msgid "``struct hlist_head *head``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:961 fs/seq_file.c:979
#: fs/seq_file.c:997 fs/seq_file.c:1017 fs/seq_file.c:1040 fs/seq_file.c:1063
msgid "the head of the hlist"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:963 fs/seq_file.c:981
#: fs/seq_file.c:1019 fs/seq_file.c:1042 fs/seq_file.c:1091
msgid "``loff_t pos``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:962 fs/seq_file.c:980
#: fs/seq_file.c:1018 fs/seq_file.c:1041
msgid "the start position of the sequence"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:963 fs/seq_file.c:1019
#: fs/seq_file.c:1091
msgid "Called at seq_file->op->start()."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:981 fs/seq_file.c:1042
msgid ""
"Called at seq_file->op->start(). Call this function if you want to print a "
"header at the top of the output."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:995
msgid "move to the next position of the hlist"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1001 fs/seq_file.c:1067
#: fs/seq_file.c:1116
msgid "``void *v``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:996 fs/seq_file.c:1062
msgid "the current iterator"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:998 fs/seq_file.c:1064
msgid "the current position"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:999 fs/seq_file.c:1065
#: fs/seq_file.c:1115
msgid "Called at seq_file->op->next()."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1016 fs/seq_file.c:1039
msgid "start an iteration of a hlist protected by RCU"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1021 fs/seq_file.c:1045
#: fs/seq_file.c:1067
msgid ""
"This list-traversal primitive may safely run concurrently with the _rcu list-"
"mutation primitives such as hlist_add_head_rcu() as long as the traversal is "
"guarded by rcu_read_lock()."
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1061
msgid "move to the next position of the hlist protected by RCU"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1087
msgid "start an iteration of a percpu hlist array"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1093 fs/seq_file.c:1113
msgid "``struct hlist_head __percpu *head``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1088 fs/seq_file.c:1112
msgid "pointer to percpu array of struct hlist_heads"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1090 fs/seq_file.c:1114
msgid "``int *cpu``"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1089 fs/seq_file.c:1113
msgid "pointer to cpu \"cursor\""
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1090 fs/seq_file.c:1114
msgid "start position of sequence"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1110
msgid "move to the next position of the percpu hlist array"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1111
msgid "pointer to current hlist_node"
msgstr ""

#: ../../../filesystems/api-summary:62: fs/seq_file.c:1115
msgid "``loff_t *pos``"
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:60
msgid "register a new filesystem"
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:66
#: fs/filesystems.c:103
msgid "``struct file_system_type * fs``"
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:61
msgid "the file system structure"
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:62
msgid ""
"Adds the file system passed to the list of file systems the kernel is aware "
"of for mount and other syscalls. Returns 0 on success, or a negative errno "
"code on an error."
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:66
msgid ""
"The :c:type:`struct file_system_type <file_system_type>` that is passed is "
"linked into the kernel structures and must not be freed until the file "
"system has been unregistered."
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:97
msgid "unregister a file system"
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:98
msgid "filesystem to unregister"
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:99
msgid ""
"Remove a file system that was previously successfully registered with the "
"kernel. An error is returned if the file system is not found. Zero is "
"returned on a success."
msgstr ""

#: ../../../filesystems/api-summary:65: fs/filesystems.c:103
msgid ""
"Once this function has returned the :c:type:`struct file_system_type "
"<file_system_type>` structure may be freed or reused."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:806
msgid "associate wbc and inode for fdatawrite"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:807
msgid "writeback_control of interest"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:808
#: ../../../filesystems/api-summary:86: fs/posix_acl.c:686
msgid "target inode"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:809
msgid ""
"This function is to be used by __filemap_fdatawrite_range(), which is an "
"alternative entry point into writeback code, and first ensures **inode** is "
"associated with a bdi_writeback and attaches it to **wbc**."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:824
msgid "disassociate wbc from inode and perform foreign detection"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:825
msgid "writeback_control of the just finished writeback"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:826
msgid ""
"To be called after a writeback attempt of an inode finishes and undoes "
"wbc_attach_and_unlock_inode().  Can be called under any context."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:829
msgid ""
"As concurrent write sharing of an inode is expected to be very rare and "
"memcg only tracks page ownership on first-use basis severely confining the "
"usefulness of such sharing, cgroup writeback tracks ownership per-inode.  "
"While the support for concurrent write sharing of an inode is deemed "
"unnecessary, an inode being written to by different cgroups at different "
"points in time is a lot more common, and, more importantly, charging only by "
"first-use can too readily lead to grossly incorrect behaviors (single "
"foreign page can lead to gigabytes of writeback to be incorrectly "
"attributed)."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:839
msgid ""
"To resolve this issue, cgroup writeback detects the majority dirtier of an "
"inode and transfers the ownership to it.  To avoid unnecessary oscillation, "
"the detection mechanism keeps track of history and gives out the switch "
"verdict only if the foreign usage pattern is stable over a certain amount of "
"time and/or writeback attempts."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:845
msgid ""
"On each writeback attempt, **wbc** tries to detect the majority writer using "
"Boyer-Moore majority vote algorithm.  In addition to the byte count from the "
"majority voting, it also counts the bytes written for the current wb and the "
"last round's winner wb (max of last round's current wb, the winner from two "
"rounds ago, and the last round's majority candidate).  Keeping track of the "
"historical winner helps the algorithm to semi-reliably detect the most "
"active writer even when it's not the absolute majority."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:854
msgid ""
"Once the winner of the round is determined, whether the winner is foreign or "
"not and how much IO time the round consumed is recorded in inode-"
">i_wb_frn_history.  If the amount of recorded foreign IO time is over a "
"certain threshold, the switch verdict is given."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:947
msgid "account writeback to update inode cgroup ownership"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:948
msgid "writeback_control of the writeback in progress"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:949
msgid "folio being written out"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:951
msgid "``size_t bytes``"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:950
msgid "number of bytes being written out"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:951
msgid ""
"**bytes** from **folio** are about to written out during the writeback "
"controlled by **wbc**.  Keep the book for foreign inode detection.  See "
"wbc_detach_inode()."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2508
msgid "internal function to mark an inode dirty"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2510
msgid "inode to mark"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2511
msgid ""
"what kind of dirty, e.g. I_DIRTY_SYNC.  This can be a combination of "
"multiple I_DIRTY_* flags, except that I_DIRTY_TIME can't be combined with "
"I_DIRTY_PAGES."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2514
msgid ""
"Mark an inode as dirty.  We notify the filesystem, then update the inode's "
"dirty flags.  Then, if needed we add the inode to the appropriate dirty list."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2517
msgid ""
"Most callers should use mark_inode_dirty() or mark_inode_dirty_sync() "
"instead of calling this directly."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2520
msgid ""
"CAREFUL!  We only add the inode to the dirty list if it is hashed or if it "
"refers to a blockdev.  Unhashed inodes will never be added to the dirty list "
"even if they are later hashed, as they will have been marked dirty already."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2524
msgid ""
"In short, ensure you hash any inodes _before_ you start marking them dirty."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2526
msgid ""
"Note that for blockdevs, inode->dirtied_when represents the dirtying time of "
"the block-special inode (/dev/hda1) itself.  And the ->dirtied_when field of "
"the kernel-internal blockdev inode represents the dirtying time of the "
"blockdev's pages.  This is why for I_DIRTY_PAGES we always use page->mapping-"
">host, so the page-dirtying time is recorded in the internal blockdev inode."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2791
#: fs/fs-writeback.c:2809
msgid "writeback dirty inodes from given super_block"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2792
#: fs/fs-writeback.c:2810 fs/fs-writeback.c:2825 fs/fs-writeback.c:2842
msgid "the superblock"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2794
msgid "``unsigned long nr``"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2793
msgid "the number of pages to write"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2795
#: fs/fs-writeback.c:2812 fs/fs-writeback.c:2827
msgid "``enum wb_reason reason``"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2794
msgid "reason why some writeback work initiated"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2795
#: fs/fs-writeback.c:2812
msgid ""
"Start writeback on some inodes on this super_block. No guarantees are made "
"on how many (if any) will be written, and this function does not wait for IO "
"completion of submitted IO."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2811
#: fs/fs-writeback.c:2826
msgid "reason why some writeback work was initiated"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2824
msgid "try to start writeback if none underway"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2827
msgid "Invoke __writeback_inodes_sb_nr if no writeback is currently underway."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2841
msgid "sync sb inode pages"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2843
msgid ""
"This function writes and waits on any dirty inode belonging to this "
"super_block."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2881
#: fs/fs-writeback.c:2908
msgid "write an inode to disk"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2882
msgid "inode to write to disk"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2884
msgid "``int sync``"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2883
msgid "whether the write should be synchronous or not"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2884
msgid ""
"This function commits an inode to disk immediately if it is dirty. This is "
"primarily needed by knfsd."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2887
msgid ""
"The caller must either have a ref on the inode or must have set I_WILL_FREE."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2909
msgid "the inode to sync"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2911
msgid "``int wait``"
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2910
msgid "wait for I/O to complete."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2911
msgid "Write an inode to disk and adjust its dirty state after completion."
msgstr ""

#: ../../../filesystems/api-summary:68: fs/fs-writeback.c:2914
msgid "only writes the actual inode, no associated data or other metadata."
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:185
#: fs/anon_inodes.c:209
msgid ""
"creates a new file instance by hooking it up to an anonymous inode, and a "
"dentry that describe the \"class\" of the file"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:189
#: fs/anon_inodes.c:213 fs/anon_inodes.c:246 fs/anon_inodes.c:311
msgid "[in]    name of the \"class\" of the new file"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:497
#: fs/debugfs/inode.c:535 ../../../filesystems/api-summary:71:
#: fs/anon_inodes.c:191 fs/anon_inodes.c:215 fs/anon_inodes.c:248
#: fs/anon_inodes.c:313
msgid "``const struct file_operations *fops``"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:190
#: fs/anon_inodes.c:214 fs/anon_inodes.c:247 fs/anon_inodes.c:312
msgid "[in]    file operations for the new file"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:192
#: fs/anon_inodes.c:216 fs/anon_inodes.c:249 fs/anon_inodes.c:314
msgid "``void *priv``"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:191
#: fs/anon_inodes.c:215 fs/anon_inodes.c:248 fs/anon_inodes.c:313
msgid "[in]    private data for the new file (will be file's private_data)"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:192
#: fs/anon_inodes.c:216 fs/anon_inodes.c:249 fs/anon_inodes.c:314
msgid "[in]    flags"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:193
msgid ""
"Creates a new file by hooking it on a single inode. This is useful for files "
"that do not need to have a full-fledged inode in order to operate correctly. "
"All the files created with anon_inode_getfile() will share a single inode, "
"hence saving memory and avoiding code duplication for the file/inode/dentry "
"setup.  Returns the newly created file* or an error pointer."
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:218
msgid "``fmode_t f_mode``"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:217
msgid "[in]    fmode"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:218
msgid ""
"Creates a new file by hooking it on a single inode. This is useful for files "
"that do not need to have a full-fledged inode in order to operate correctly. "
"All the files created with anon_inode_getfile() will share a single inode, "
"hence saving memory and avoiding code duplication for the file/inode/dentry "
"setup. Allows setting the fmode. Returns the newly created file* or an error "
"pointer."
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:241
msgid ""
"Like anon_inode_getfile(), but creates a new !S_PRIVATE anon inode rather "
"than reuse the singleton anon inode and calls the inode_init_security_anon() "
"LSM hook."
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:251
msgid "``const struct inode *context_inode``"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:250
msgid "[in]    the logical relationship with the new inode (optional)"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:252
msgid ""
"Create a new anonymous inode and file pair.  This can be done for two "
"reasons:"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:255
msgid ""
"for the inode to have its own security context, so that LSMs can enforce "
"policy on the inode's creation;"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:258
msgid ""
"if the caller needs a unique inode, for example in order to customize the "
"size returned by fstat()"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:261
msgid ""
"The LSM may use **context_inode** in inode_init_security_anon(), but a "
"reference to it is not held."
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:264
msgid "Returns the newly created file* or an error pointer."
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:307
msgid ""
"creates a new file instance by hooking it up to an anonymous inode and a "
"dentry that describe the \"class\" of the file"
msgstr ""

#: ../../../filesystems/api-summary:71: fs/anon_inodes.c:315
msgid ""
"Creates a new file by hooking it on a single inode. This is useful for files "
"that do not need to have a full-fledged inode in order to operate "
"correctly.  All the files created with anon_inode_getfd() will use the same "
"singleton inode, reducing memory use and avoiding code duplication for the "
"file/inode/dentry setup.  Returns a newly created file descriptor or an "
"error code."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:21
msgid "determine whether the setgid bit needs to be removed"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:25
msgid ""
"This function determines whether the setgid bit needs to be removed. We "
"retain backwards compatibility and require setgid bit to be removed "
"unconditionally if S_IXGRP is set. Otherwise we have the exact same "
"requirements as setattr_prepare() and setattr_copy()."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:31
msgid "ATTR_KILL_SGID if setgid bit needs to be removed, 0 otherwise."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:49
msgid "determine whether the set{g,u}id bit needs to be dropped"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:53
msgid ""
"This function determines whether the set{g,u}id bits need to be removed. If "
"the setuid bit needs to be removed ATTR_KILL_SUID is returned. If the setgid "
"bit needs to be removed ATTR_KILL_SGID is returned. If both set{g,u}id bits "
"need to be removed the corresponding mask of both flags is returned."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:60
msgid ""
"A mask of ATTR_KILL_S{G,U}ID indicating which - if any - setid bits to "
"remove, 0 otherwise."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:141
msgid "check if attribute changes to a dentry are allowed"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:143
msgid "dentry to check"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:145 fs/attr.c:395
msgid "``struct iattr *attr``"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:144
msgid "attributes to change"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:145
msgid ""
"Check if we are allowed to change the attributes contained in **attr** in "
"the given dentry.  This includes the normal unix access permission checks, "
"as well as checks for rlimits and others. The function also clears SGID bit "
"from mode if user is not allowed to set it. Also file capabilities and IMA "
"extended attributes are cleared if ATTR_KILL_PRIV is set."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:157
msgid ""
"Should be called as the first thing in ->setattr implementations, possibly "
"after taking additional locks."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:229
msgid "may this inode be truncated to a given size"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:230
msgid "the inode to be truncated"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:231
msgid "the new size to assign to the inode"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:232
msgid "inode_newsize_ok must be called with i_rwsem held exclusively."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:234
msgid ""
"inode_newsize_ok will check filesystem limits and ulimits to check that the "
"new inode size is within limits. inode_newsize_ok will also send SIGXFSZ "
"when necessary. Caller must not proceed with inode size change if failure is "
"returned. **inode** must be a file (not directory), with appropriate "
"permissions to allow truncate (inode_newsize_ok does NOT check these "
"conditions)."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:242
msgid "0 on success, -ve errno on failure"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:308
msgid "copy simple metadata updates into the generic inode"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:310
msgid "the inode to be updated"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:311
msgid "the new attributes"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:312
msgid "setattr_copy must be called with i_rwsem held exclusively."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:314
msgid ""
"setattr_copy updates the inode's metadata with that specified in attr on "
"idmapped mounts. Necessary permission checks to determine whether or not the "
"S_ISGID property needs to be removed are performed with the correct idmapped "
"mount permission helpers. Noticeably missing is inode size update, which is "
"more complex as it requires pagecache updates."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:327
msgid ""
"The inode is not marked as dirty after this operation. The rationale is that "
"for \"simple\" filesystems, the struct inode is the inode storage. The "
"caller is free to mark the inode dirty afterwards if needed."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:391
msgid "modify attributes of a filesystem object"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:393
msgid "object affected"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:394
msgid "new attributes"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:395
msgid "returns inode, if the inode is delegated"
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:396
msgid "The caller must hold the i_rwsem exclusively on the affected object."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:398
msgid ""
"If notify_change discovers a delegation in need of breaking, it will return -"
"EWOULDBLOCK and return a reference to the inode in delegated_inode.  The "
"caller should then break the delegation and retry.  Because breaking a "
"delegation may take a long time, the caller should drop the i_rwsem before "
"doing so."
msgstr ""

#: ../../../filesystems/api-summary:74: fs/attr.c:404
msgid ""
"Alternatively, a caller may pass NULL for delegated_inode.  This may be "
"appropriate for callers that expect the underlying filesystem not to be NFS "
"exported.  Also, passing NULL is fine for callers holding the file open for "
"write, as there can be no conflicting delegation in that case."
msgstr ""

#: ../../../filesystems/api-summary:77: fs/d_path.c:250
msgid "return the path of a dentry"
msgstr ""

#: ../../../filesystems/api-summary:77: fs/d_path.c:251
msgid "path to report"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:748
#: fs/sysfs/file.c:774 fs/sysfs/file.c:801 ../../../filesystems/api-summary:77:
#: fs/d_path.c:253
msgid "``char *buf``"
msgstr ""

#: ../../../filesystems/api-summary:77: fs/d_path.c:252
msgid "buffer to return value in"
msgstr ""

#: ../../../filesystems/api-summary:77: fs/d_path.c:253
msgid "buffer length"
msgstr ""

#: ../../../filesystems/api-summary:77: fs/d_path.c:254
msgid ""
"Convert a dentry into an ASCII path name. If the entry has been deleted the "
"string \" (deleted)\" is appended. Note that this is ambiguous."
msgstr ""

#: ../../../filesystems/api-summary:77: fs/d_path.c:257
msgid ""
"Returns a pointer into the buffer or an error code if the path was too long. "
"Note: Callers should use the returned pointer, not the passed in buffer, to "
"use the name! The implementation often starts at an offset into the buffer, "
"and may leave 0 bytes at the start."
msgstr ""

#: ../../../filesystems/api-summary:77: fs/d_path.c:262
msgid "\"buflen\" should be positive."
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:737
msgid "find first pinned page in **mapping**"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:738
msgid "address space to scan for a page with ref count > 1"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:740
#: ../../../filesystems/api-summary:83: fs/libfs.c:1525 fs/libfs.c:1569
#: ../../../filesystems/api-summary:92: fs/sync.c:172
msgid "``loff_t start``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:739
msgid "Starting offset. Page containing 'start' is included."
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:741
#: ../../../filesystems/api-summary:83: fs/libfs.c:1526 fs/libfs.c:1570
#: ../../../filesystems/api-summary:92: fs/sync.c:173
msgid "``loff_t end``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:740
msgid ""
"End offset. Page containing 'end' is included. If 'end' is LLONG_MAX, pages "
"from 'start' till the end of file are included."
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:742
msgid ""
"DAX requires ZONE_DEVICE mapped pages. These pages are never 'onlined' to "
"the page allocator so they are considered idle when page->count == 1. A "
"filesystem uses this interface to determine if any page in the mapping is "
"busy, i.e. for DMA, or other get_user_pages() usages."
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:748
msgid ""
"It is expected that the filesystem is holding locks to block the "
"establishment of new mappings in this address_space. I.e. it expects to be "
"able to run unmap_mapping_range() and subsequently not race mapping_mapped() "
"becoming true."
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:1697
msgid "Perform I/O to a DAX file"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:1698
msgid "The control block for this I/O"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:1700
msgid "``struct iov_iter *iter``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:1699
msgid "The addresses to do I/O from or to"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:1701 fs/dax.c:2069
msgid "``const struct iomap_ops *ops``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:1700
msgid "iomap ops passed from the file system"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:1701
msgid ""
"This function performs read and write operations to directly mapped "
"persistent memory.  The callers needs to take care of read/write exclusion "
"and evicting any page cache pages in the region under I/O."
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2063
msgid "handle a page fault on a DAX file"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2069 fs/dax.c:2143
msgid "``struct vm_fault *vmf``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2064 fs/dax.c:2138
msgid "The description of the fault"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2066 fs/dax.c:2140
msgid "``unsigned int order``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2065
msgid "Order of the page to fault in"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2067
msgid "``unsigned long *pfnp``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2066
msgid "PFN to insert for synchronous faults if fsync is required"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2068
msgid "``int *iomap_errp``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2067
msgid "Storage for detailed error code in case of error"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2068
msgid "Iomap ops passed from the file system"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2069
msgid ""
"When a page fault occurs, filesystems may call this helper in their fault "
"handler for DAX files. dax_iomap_fault() assumes the caller has done all the "
"necessary locking for page fault to proceed successfully."
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2137
msgid "finish synchronous page fault"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2139
msgid "Order of entry to be inserted"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2141
msgid "``unsigned long pfn``"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2140
msgid "PFN to insert"
msgstr ""

#: ../../../filesystems/api-summary:80: fs/dax.c:2141
msgid ""
"This function ensures that the file range touched by the page fault is "
"stored persistently on the media and handles inserting of appropriate page "
"table entry."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:806
msgid "update the various inode timestamps for rename"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:812
msgid "``struct inode *old_dir``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:807
msgid "old parent directory"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:808
msgid "dentry that is being renamed"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:810
msgid "``struct inode *new_dir``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:809
msgid "new parent directory"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:810
msgid "target for rename"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:811
msgid ""
"POSIX mandates that the old and new parent directories have their ctime and "
"mtime updated, and that inodes of **old_dentry** and **new_dentry** (if "
"any), have their ctime updated."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:883
msgid "setattr for simple filesystem"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:884
msgid "idmap of the target mount"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:885
msgid "dentry"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:887
msgid "``struct iattr *iattr``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:886
msgid "iattr structure"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:887
msgid "Returns 0 on success, -error on failure."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:889
msgid ""
"simple_setattr is a simple ->setattr implementation without a proper "
"implementation of size changes."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:892
msgid ""
"It can either be used for in-memory filesystems or special files on simple "
"regular filesystems.  Anything that needs to change on-disk or wire state on "
"size changes needs its own setattr method."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1110
msgid "copy data from the buffer to user space"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1116
msgid "``void __user *to``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1111
msgid "the user space buffer to read to"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:803
#: ../../../filesystems/api-summary:83: fs/libfs.c:1113 fs/libfs.c:1151
#: fs/libfs.c:1183
msgid "``size_t count``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1113 fs/libfs.c:1148
#: fs/libfs.c:1183
msgid "the current position in the buffer"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1115 fs/libfs.c:1185
msgid "``const void *from``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1114 fs/libfs.c:1184
msgid "the buffer to read from"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1116 fs/libfs.c:1148
#: fs/libfs.c:1186
msgid "``size_t available``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1115 fs/libfs.c:1147
#: fs/libfs.c:1185
msgid "the size of the buffer"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1116
msgid ""
"The simple_read_from_buffer() function reads up to **count** bytes from the "
"buffer **from** at offset **ppos** into the user space address starting at "
"**to**."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1119 fs/libfs.c:1189
msgid ""
"On success, the number of bytes read is returned and the offset **ppos** is "
"advanced by this number, or negative value is returned on error."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1145
msgid "copy data from user space to the buffer"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1151 fs/libfs.c:1186
msgid "``void *to``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1146
msgid "the buffer to write to"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1150
msgid "``const void __user *from``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1149
msgid "the user space buffer to read from"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1151
msgid ""
"The simple_write_to_buffer() function reads up to **count** bytes from the "
"user space address starting at **from** into the buffer **to** at offset "
"**ppos**."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1154
msgid ""
"On success, the number of bytes written is returned and the offset **ppos** "
"is advanced by this number, or negative value is returned on error."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1180
msgid "copy data from the buffer"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1181
msgid "the kernel space buffer to read to"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1186
msgid ""
"The memory_read_from_buffer() function reads up to **count** bytes from the "
"buffer **from** at offset **ppos** into the kernel space address starting at "
"**to**."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1415
msgid "generic export_operations->encode_fh function"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1416
msgid "the object to encode"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1418
msgid "``__u32 *fh``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1417
msgid "where to store the file handle fragment"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1419
msgid "``int *max_len``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1418
msgid "maximum length to store there (in 4 byte units)"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1420
msgid "``struct inode *parent``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1419
msgid "parent directory inode, if wanted"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1420
msgid ""
"This generic encode_fh function assumes that the 32 inode number is suitable "
"for locating an inode, and that the generation number can be used to check "
"that it is still valid.  It places them in the filehandle fragment where "
"export_decode_fh expects to find them."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1456
msgid "generic helper for the fh_to_dentry export operation"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1457 fs/libfs.c:1489
msgid "filesystem to do the file handle conversion on"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1459 fs/libfs.c:1491
msgid "``struct fid *fid``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1458 fs/libfs.c:1490
msgid "file handle to convert"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1460 fs/libfs.c:1492
msgid "``int fh_len``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1459 fs/libfs.c:1491
msgid "length of the file handle in bytes"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1461 fs/libfs.c:1493
msgid "``int fh_type``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1460 fs/libfs.c:1492
msgid "type of file handle"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1462 fs/libfs.c:1494
msgid ""
"``struct inode *(*get_inode) (struct super_block *sb, u64 ino, u32 gen)``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1461 fs/libfs.c:1493
msgid "filesystem callback to retrieve inode"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1462
msgid ""
"This function decodes **fid** as long as it has one of the well-known Linux "
"filehandle types and calls **get_inode** on it to retrieve the inode for the "
"object specified in the file handle."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1488
msgid "generic helper for the fh_to_parent export operation"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1494
msgid ""
"This function decodes **fid** as long as it has one of the well-known Linux "
"filehandle types and calls **get_inode** on it to retrieve the inode for the "
"_parent_ object specified in the file handle if it is specified in the file "
"handle, or NULL otherwise."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1521
msgid "generic fsync implementation for simple filesystems"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1523 fs/libfs.c:1567
msgid "file to synchronize"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1524 fs/libfs.c:1568
msgid "start offset in bytes"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1525 fs/libfs.c:1569
msgid "end offset in bytes (inclusive)"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1527 fs/libfs.c:1571
#: ../../../filesystems/api-summary:92: fs/sync.c:174 fs/sync.c:195
msgid "``int datasync``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1526 fs/libfs.c:1570
msgid "only synchronize essential metadata if true"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1527
msgid ""
"This is a generic implementation of the fsync method for simple filesystems "
"which track all non-inode metadata in the buffers list hanging off the "
"address_space structure."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1565
msgid "generic fsync implementation for simple filesystems with flush"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1588
msgid "Check addressability of file system"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1594
msgid "``unsigned blocksize_bits``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1589
msgid "log of file system block size"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1591
msgid "``u64 num_blocks``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1590
msgid "number of blocks in file system"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1591
msgid ""
"Determine whether a file system with **num_blocks** blocks (and a block size "
"of 2****blocksize_bits**) is addressable by the sector_t and page cache of "
"the system.  Return 0 if so and -EFBIG otherwise."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1682
msgid "generic helper for prohibiting leases"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1685
msgid "new lease supplied for insertion"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1686
msgid "private data for lm_setup operation"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1687
msgid ""
"Generic helper for filesystems that do not wish to allow leases to be set. "
"All arguments are ignored and it just returns -EINVAL."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1700
msgid "generic helper to get the target of \"fast\" symlinks"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1701 fs/libfs.c:1703
msgid "not used here"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1702
msgid "the symlink inode"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1704
msgid ""
"Generic helper for filesystems to use for symlink inodes where a pointer to "
"the symlink target is stored in ->i_link.  NOTE: this isn't normally called, "
"since as an optimization the path lookup code uses any non-NULL ->i_link "
"directly, without calling ->get_link().  But ->get_link() still must be set, "
"to mark the inode_operations as being for a symlink."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1711
msgid "the symlink target"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1794
msgid "generic d_compare implementation for casefolding filesystems"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1795
msgid "dentry whose name we are checking against"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1796
msgid "len of name of dentry"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1798
msgid "``const char *str``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1797
msgid "str pointer to name of dentry"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1798
msgid "Name to compare against"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1800
msgid "0 if names match, 1 if mismatch, or -ERRNO"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1850
msgid "generic d_hash implementation for casefolding filesystems"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1851
msgid "dentry of the parent directory"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1853
msgid "``struct qstr *str``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1852
msgid "qstr of name whose hash we should fill in"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1854
msgid "0 if hash was successful or unchanged, and -EINVAL on error"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1882
msgid ""
"Match a name (case-insensitively) with a dirent. This is a filesystem helper "
"for comparison with directory entries. generic_ci_d_compare should be used "
"in VFS' ->d_compare instead."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1888
msgid "``const struct inode *parent``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1886
msgid "Inode of the parent of the dirent under comparison"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1887
msgid "name under lookup."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1889
msgid "``const struct qstr *folded_name``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1888
msgid "Optional pre-folded name under lookup"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1890
msgid "``const u8 *de_name``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1889
msgid "Dirent name."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1891
msgid "``u32 de_name_len``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1890
msgid "dirent name length."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1891
msgid ""
"Test whether a case-insensitive directory entry matches the filename being "
"searched.  If **folded_name** is provided, it is used instead of "
"recalculating the casefold of **name**."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1896
msgid ""
"> 0 if the directory entry matches, 0 if it doesn't match, or < 0 on error."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1963
msgid ""
"helper for choosing the set of filesystem-wide dentry operations for the "
"enabled features"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1965
msgid "superblock to be configured"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1966
msgid ""
"Filesystems supporting casefolding and/or fscrypt can call this helper at "
"mount-time to configure default dentry_operations to the best set of dentry "
"operations required for the enabled features. The helper must be called "
"after these have been configured, but before the root dentry is created."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1991
msgid "increments i_version"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1992
msgid "inode with the i_version that should be updated"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1994
msgid "``bool force``"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1993
msgid "increment the counter even if it's not necessary?"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1994
msgid ""
"Every time the inode is modified, the i_version field must be seen to have "
"changed by any observer."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:1997
msgid ""
"If \"force\" is set or the QUERIED flag is set, then ensure that we "
"increment the value, and clear the queried flag."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2000
msgid ""
"In the common case where neither is set, then we can return \"false\" "
"without updating i_version."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2003
msgid ""
"If this function returns false, and no other metadata has changed, then we "
"can avoid logging the metadata."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2042
msgid "read i_version for later use"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2043
msgid "inode from which i_version should be read"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2044
msgid ""
"Read the inode i_version counter. This should be used by callers that wish "
"to store the returned i_version for later comparison. This will guarantee "
"that a later query of the i_version will result in a different value if "
"anything has changed."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2049
msgid ""
"In this implementation, we fetch the current value, set the QUERIED flag and "
"then try to swap it into place with a cmpxchg, if it wasn't already set. If "
"that fails, we try again with the newly fetched value from the cmpxchg."
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2122
msgid "initialize the timestamps for a new inode"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2123
msgid "inode to be initialized"
msgstr ""

#: ../../../filesystems/api-summary:83: fs/libfs.c:2124
msgid ""
"When a new inode is created, most filesystems set the timestamps to the "
"current time. Add a helper to do this."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:591
msgid "chmod a posix acl"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:594
msgid "dentry to check permissions on"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:595
msgid "the new mode of **inode**"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:596
msgid ""
"If the dentry has been found through an idmapped mount the idmap of the "
"vfsmount must be passed through **idmap**. This function will then take care "
"to map the inode according to **idmap** before checking permissions. On non-"
"idmapped mounts or if permission checking is to be performed on the raw "
"inode simply pass **nop_mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:684
msgid "update mode in set_acl"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:688
msgid "``umode_t *mode_p``"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:687
msgid "mode (pointer) for update"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:689
msgid "``struct posix_acl **acl``"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:688
msgid "acl pointer"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:689
msgid ""
"Update the file mode when setting an ACL: compute the new file permission "
"bits based on the ACL.  In addition, if the ACL is equivalent to the new "
"file mode, set ***acl** to NULL to indicate that no ACL should be set."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:693
msgid ""
"As with chmod, clear the setgid bit if the caller is not in the owning group "
"or capable of CAP_FSETID (see inode_change_ok)."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:702
msgid "Called from set_acl inode operations."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:750
msgid "convert POSIX ACLs from backing store to VFS format"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:756
msgid "``struct user_namespace *userns``"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:751
msgid "the filesystem's idmapping"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:753
#: ../../../filesystems/api-summary:95: fs/xattr.c:269
msgid "``const void *value``"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:752
msgid "the uapi representation of POSIX ACLs"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:753
msgid "the size of **void**"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:754
msgid ""
"Filesystems that store POSIX ACLs in the unaltered uapi format should use "
"posix_acl_from_xattr() when reading them from the backing store and "
"converting them into the struct posix_acl VFS format. The helper is "
"specifically intended to be called from the acl inode operation."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:759
msgid ""
"The posix_acl_from_xattr() function will map the raw {g,u}id values stored "
"in ACL_{GROUP,USER} entries into idmapping in **userns**."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:762
msgid ""
"Note that posix_acl_from_xattr() does not take idmapped mounts into account. "
"If it did it calling it from the get acl inode operation would return POSIX "
"ACLs mapped according to an idmapped mount which would mean that the value "
"couldn't be cached for the filesystem. Idmapped mounts are taken into "
"account on the fly during permission checking or right at the VFS - "
"userspace boundary before reporting them to the user."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:770
msgid ""
"Allocated struct posix_acl on success, NULL for a valid header but without "
"actual POSIX ACL entries, or ERR_PTR() encoded error code."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1077
msgid "set posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1079
msgid "the dentry based on which to set the posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1081 fs/posix_acl.c:1159
#: fs/posix_acl.c:1204
msgid "``const char *acl_name``"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1080 fs/posix_acl.c:1158
#: fs/posix_acl.c:1203
msgid "the name of the posix acl"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1082
msgid "``struct posix_acl *kacl``"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1081
msgid "the posix acls in the appropriate VFS format"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1082
msgid ""
"This function sets **kacl**. The caller must all posix_acl_release() on "
"**kacl** afterwards."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1086 fs/posix_acl.c:1207
msgid "On success 0, on error negative errno."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1155
msgid "get posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1157 fs/posix_acl.c:1202
msgid "the dentry based on which to retrieve the posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1159
msgid ""
"This function retrieves **kacl** from the filesystem. The caller must all "
"posix_acl_release() on **kacl**."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1163
msgid "On success POSIX ACLs in VFS format, on error negative errno."
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1200
msgid "remove posix acls"
msgstr ""

#: ../../../filesystems/api-summary:86: fs/posix_acl.c:1204
msgid "This function removes posix acls."
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:32
msgid "Fill in the mtime and ctime and flag ctime as QUERIED"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:38 fs/stat.c:71 fs/stat.c:120
#: fs/stat.c:141 fs/stat.c:172
msgid "``struct kstat *stat``"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:33
msgid "where to store the resulting values"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:35 fs/stat.c:69 fs/stat.c:173
msgid "``u32 request_mask``"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:34
msgid "STATX_* values requested"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:35
msgid "inode from which to grab the c/mtime"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:36
msgid ""
"Given **inode**, grab the ctime and mtime out if it and store the result in "
"**stat**. When fetching the value, flag it as QUERIED (if not already) so "
"the next write will record a distinct timestamp."
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:40
msgid ""
"NB: The QUERIED flag is tracked in the ctime, but we set it there even if "
"only the mtime was requested, as that ensures that the next mtime change "
"will be distinct."
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:66
msgid "Fill in the basic attributes from the inode struct"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:68
msgid "statx request_mask"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:69 fs/stat.c:118
msgid "Inode to use as the source"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:70
msgid "Where to fill in the attributes"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:71
msgid ""
"Fill in the basic attributes in the kstat structure from data that's to be "
"found on the VFS inode structure.  This is the default if no getattr inode "
"operation is supplied."
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:75
msgid ""
"If the inode has been found through an idmapped mount the idmap of the "
"vfsmount must be passed through **idmap**. This function will then take care "
"to map the inode according to **idmap** before filling in the uid and gid "
"filds. On non-idmapped mounts or if permission checking is to be performed "
"on the raw inode simply pass **nop_mnt_idmap**."
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:117
msgid "Fill in the statx attributes from the inode flags"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:119 fs/stat.c:136
msgid "Where to fill in the attribute flags"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:120
msgid ""
"Fill in the STATX_ATTR_* flags in the kstat structure for properties of the "
"inode that are published on i_flags and enforced by the VFS."
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:135
msgid "Fill in atomic writes statx attributes"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:138
msgid "``unsigned int unit_min``"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:137
msgid "Minimum supported atomic write length in bytes"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:139
msgid "``unsigned int unit_max``"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:138
msgid "Maximum supported atomic write length in bytes"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:140
msgid "``unsigned int unit_max_opt``"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:139
msgid "Optimised maximum supported atomic write length in bytes"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:140
msgid ""
"Fill in the STATX{_ATTR}_WRITE_ATOMIC flags in the kstat structure from "
"atomic write unit_min and unit_max values."
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:169
msgid "getattr without security checks"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:170
msgid "file to get attributes from"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:171
msgid "structure to return attributes in"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:172
msgid "STATX_xxx flags indicating what the caller wants"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:174
msgid "``unsigned int query_flags``"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:173
msgid "Query mode (AT_STATX_SYNC_TYPE)"
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:174
msgid "Get attributes without calling security_inode_getattr."
msgstr ""

#: ../../../filesystems/api-summary:89: fs/stat.c:176
msgid ""
"Currently the only caller other than vfs_getattr is internal to the "
"filehandle lookup code, which uses only the inode number and returns no "
"attributes to any user.  Any other code probably wants vfs_getattr."
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:169
msgid "helper to sync a range of data & metadata to disk"
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:170 fs/sync.c:193
msgid "file to sync"
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:171
msgid "offset in bytes of the beginning of data range to sync"
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:172
msgid "offset in bytes of the end of data range (inclusive)"
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:173
msgid "perform only datasync"
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:174
msgid ""
"Write back data in range **start**..**end** and metadata for **file** to "
"disk.  If **datasync** is set only metadata needed to access modified file "
"data is written."
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:192
msgid "perform a fsync or fdatasync on a file"
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:194
msgid "only perform a fdatasync operation"
msgstr ""

#: ../../../filesystems/api-summary:92: fs/sync.c:195
msgid ""
"Write back data and metadata for **file** to disk.  If **datasync** is set "
"only metadata needed to access modified file data is written."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:262 fs/xattr.c:524
msgid "set an extended attribute while holding the inode lock"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:265 fs/xattr.c:527
msgid "idmap of the mount of the target inode"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:266 fs/xattr.c:528
msgid "object to perform setxattr on"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:267
msgid "xattr name to set"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:268
msgid "value to set **name** to"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:269
msgid "size of **value**"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:270
msgid "flags to pass into filesystem operations"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:271 fs/xattr.c:530
msgid ""
"on return, will contain an inode pointer that a delegation was broken on, "
"NULL if none."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:461
msgid "retrieve \\0 separated list of xattr names"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:462
msgid "the dentry from whose inode the xattr names are retrieved"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:464
msgid "``char *list``"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:463
msgid "buffer to store xattr names into"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:464
msgid "size of the buffer"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:465
msgid ""
"This function returns the names of all xattrs associated with the inode of "
"**dentry**."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:468
msgid ""
"Note, for legacy reasons the vfs_listxattr() function lists POSIX ACLs as "
"well. Since POSIX ACLs are decoupled from IOP_XATTR the vfs_listxattr() "
"function doesn't check for this flag since a filesystem could implement "
"POSIX ACLs without implementing any other xattrs."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:474
msgid ""
"However, since all codepaths that remove IOP_XATTR also assign of inode "
"operations that either don't implement or implement a stub ->listxattr() "
"operation."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:479
msgid ""
"On success, the size of the buffer that was used. On error a negative error "
"code."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:529
msgid "name of xattr to remove"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1130
msgid "run through a dentry's xattr list() operations"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1131
msgid "dentry to list the xattrs"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1133
msgid "``char *buffer``"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1132
msgid "result buffer"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1134
msgid "``size_t buffer_size``"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1133
msgid "size of **buffer**"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1134
msgid ""
"Combine the results of the list() operation from every xattr_handler in the "
"xattr_handler stack."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1137
msgid "Note that this will not include the entries for POSIX ACLs."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1161
msgid "Compute full attribute name from suffix"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1167
msgid "``const struct xattr_handler *handler``"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1163
msgid "handler of the xattr_handler operation"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1164
msgid "name passed to the xattr_handler operation"
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1165
msgid ""
"The get and set xattr handler operations are called with the remainder of "
"the attribute name after skipping the handler's prefix: for example, \"foo\" "
"is passed to the get operation of a handler with prefix \"user.\" to get "
"attribute \"user.foo\".  The full name is still \"there\" in the name though."
msgstr ""

#: ../../../filesystems/api-summary:95: fs/xattr.c:1171
msgid ""
"the list xattr handler operation when called from the vfs is passed a NULL "
"name; some file systems use this operation internally, with varying "
"semantics."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:437
msgid "get write access to a mount without freeze protection"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:443 fs/namespace.c:502
#: fs/namespace.c:1590
msgid "``struct vfsmount *m``"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:438 fs/namespace.c:497
msgid "the mount on which to take a write"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:439
msgid ""
"This tells the low-level filesystem that a write is about to be performed to "
"it, and makes sure that writes are allowed (mnt it read-write) before "
"returning success. This operation does not protect against filesystem being "
"frozen. When the write operation is finished, mnt_put_write_access() must be "
"called. This is effectively a refcount."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:496
msgid "get write access to a mount"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:498
msgid ""
"This tells the low-level filesystem that a write is about to be performed to "
"it, and makes sure that writes are allowed (mount is read-write, filesystem "
"is not frozen) before returning success.  When the write operation is "
"finished, mnt_drop_write() must be called.  This is effectively a refcount."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:540
msgid "get write access to a file's mount"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:541
msgid "the file who's mount on which to take a write"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:542
msgid ""
"This is like mnt_want_write, but if the file is already open for writing it "
"skips incrementing mnt_writers (since the open file already has a reference) "
"and instead only does the freeze protection and the check for emergency r/o "
"remounts.  This must be paired with mnt_drop_write_file."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:561 fs/namespace.c:577
msgid "give up write access to a mount"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:562 fs/namespace.c:578
msgid "the mount on which to give up write access"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:563
msgid ""
"Tells the low-level filesystem that we are done performing writes to it.  "
"Must be matched with mnt_get_write_access() call above."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:579
msgid ""
"Tells the low-level filesystem that we are done performing writes to it and "
"also allows filesystem to be frozen again.  Must be matched with "
"mnt_want_write() call above."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1178
msgid "Create a mount for a configured superblock"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1179
msgid "The configuration context with the superblock attached"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1180
msgid ""
"Create a mount to an already configured superblock.  If necessary, the "
"caller should invoke vfs_get_tree() before calling this."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1183
msgid "Note that this does not attach the mount to anything."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1450
msgid "Check if path is a mount in the current namespace."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1451
msgid "path to check"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1452
msgid ""
"d_mountpoint() can only be used reliably to establish if a dentry is not "
"mounted in any namespace and that common case is handled inline. "
"d_mountpoint() isn't aware of the possibility there may be multiple mounts "
"using a given dentry in a different namespace. This function checks if the "
"passed in path is a mountpoint rather than the dentry alone."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1584
msgid "check if a mount tree is busy"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1585
msgid "root of mount tree"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1586
msgid ""
"This is called to check if a tree of mounts has any open files, pwds, "
"chroots or sub mounts that are busy."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1612
msgid "check if a mount point is busy"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1613
msgid "root of mount"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1614
msgid ""
"This is called to check if a mount point has any open files, pwds, chroots "
"or sub mounts. If the mount has sub mounts this will return busy regardless "
"of whether the sub mounts are busy."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:1619
msgid ""
"Doesn't take quota and stuff into account. IOW, in some cases it will give "
"false negatives. The main reason why it's here is that we need a non-"
"destructive way to look for easily umountable filesystems."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:2359
msgid "create a private clone of a path"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:2360
msgid "path to clone"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:2361
msgid ""
"This creates a new vfsmount, which will be the clone of **path**.  The new "
"mount will not be attached anywhere in the namespace and will be private (i."
"e. changes to the originating mount won't be propagated into this)."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:2365
msgid "This assumes caller has called or done the equivalent of may_mount()."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:2367
msgid "Release with mntput()."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:3788
msgid "Put a mount on an expiration list"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:3789
msgid "The mount to list."
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:3791
msgid "``struct list_head *expiry_list``"
msgstr ""

#: ../../../filesystems/api-summary:98: fs/namespace.c:3790
msgid "The list to add the mount to."
msgstr ""

#: ../../../filesystems/api-summary.rst:102
msgid "The proc filesystem"
msgstr ""

#: ../../../filesystems/api-summary.rst:105
msgid "sysctl interface"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:173
msgid "read a string sysctl"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:179
#: kernel/sysctl.c:626 kernel/sysctl.c:666 kernel/sysctl.c:685
#: kernel/sysctl.c:745 kernel/sysctl.c:811 kernel/sysctl.c:841
#: kernel/sysctl.c:976 kernel/sysctl.c:998 kernel/sysctl.c:1121
#: kernel/sysctl.c:1154 kernel/sysctl.c:1176 kernel/sysctl.c:1198
msgid "``const struct ctl_table *table``"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:174
#: kernel/sysctl.c:621 kernel/sysctl.c:661 kernel/sysctl.c:680
#: kernel/sysctl.c:740 kernel/sysctl.c:806 kernel/sysctl.c:836
#: kernel/sysctl.c:971 kernel/sysctl.c:993 kernel/sysctl.c:1116
#: kernel/sysctl.c:1149 kernel/sysctl.c:1171 kernel/sysctl.c:1193
msgid "the sysctl table"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:176
#: kernel/sysctl.c:623 kernel/sysctl.c:663 kernel/sysctl.c:682
#: kernel/sysctl.c:742 kernel/sysctl.c:808 kernel/sysctl.c:838
#: kernel/sysctl.c:973 kernel/sysctl.c:995 kernel/sysctl.c:1118
#: kernel/sysctl.c:1151 kernel/sysctl.c:1173 kernel/sysctl.c:1195
msgid "``int write``"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:175
#: kernel/sysctl.c:622 kernel/sysctl.c:662 kernel/sysctl.c:681
#: kernel/sysctl.c:741 kernel/sysctl.c:807 kernel/sysctl.c:837
#: kernel/sysctl.c:972 kernel/sysctl.c:994 kernel/sysctl.c:1117
#: kernel/sysctl.c:1150 kernel/sysctl.c:1172 kernel/sysctl.c:1194
msgid "``TRUE`` if this is a write to the sysctl file"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:177
#: kernel/sysctl.c:624 kernel/sysctl.c:664 kernel/sysctl.c:683
#: kernel/sysctl.c:743 kernel/sysctl.c:809 kernel/sysctl.c:839
#: kernel/sysctl.c:974 kernel/sysctl.c:996 kernel/sysctl.c:1119
#: kernel/sysctl.c:1152 kernel/sysctl.c:1174 kernel/sysctl.c:1196
msgid "``void *buffer``"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:176
#: kernel/sysctl.c:623 kernel/sysctl.c:663 kernel/sysctl.c:682
#: kernel/sysctl.c:742 kernel/sysctl.c:808 kernel/sysctl.c:838
#: kernel/sysctl.c:973 kernel/sysctl.c:995 kernel/sysctl.c:1118
#: kernel/sysctl.c:1151 kernel/sysctl.c:1173 kernel/sysctl.c:1195
msgid "the user buffer"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:178
#: kernel/sysctl.c:625 kernel/sysctl.c:665 kernel/sysctl.c:684
#: kernel/sysctl.c:744 kernel/sysctl.c:810 kernel/sysctl.c:840
#: kernel/sysctl.c:975 kernel/sysctl.c:997 kernel/sysctl.c:1120
#: kernel/sysctl.c:1153 kernel/sysctl.c:1175 kernel/sysctl.c:1197
msgid "``size_t *lenp``"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:177
#: kernel/sysctl.c:624 kernel/sysctl.c:664 kernel/sysctl.c:683
#: kernel/sysctl.c:743 kernel/sysctl.c:809 kernel/sysctl.c:839
#: kernel/sysctl.c:974 kernel/sysctl.c:996 kernel/sysctl.c:1119
#: kernel/sysctl.c:1152 kernel/sysctl.c:1174 kernel/sysctl.c:1196
msgid "the size of the user buffer"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:179
msgid ""
"Reads/writes a string from/to the user buffer. If the kernel buffer provided "
"is not large enough to hold the string, the string is truncated. The copied "
"string is ``NULL-terminated``. If the string is being read by the user "
"process, it is copied and a newline '\\n' is added. It is truncated if the "
"buffer is not large enough."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:186
#: kernel/sysctl.c:632 kernel/sysctl.c:669 kernel/sysctl.c:688
#: kernel/sysctl.c:982 kernel/sysctl.c:1005 kernel/sysctl.c:1126
#: kernel/sysctl.c:1159 kernel/sysctl.c:1181 kernel/sysctl.c:1205
msgid "Returns 0 on success."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:620
msgid "read/write a bool"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:626
msgid ""
"Reads/writes one integer value from/to the user buffer, treated as an ASCII "
"string."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:629
msgid ""
"table->data must point to a bool variable and table->maxlen must be "
"sizeof(bool)."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:660
msgid "read a vector of integers"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:666
#: kernel/sysctl.c:745
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) integer values from/to "
"the user buffer, treated as an ASCII string."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:679
msgid "read a vector of unsigned integers"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:685
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer "
"values from/to the user buffer, treated as an ASCII string."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:739
msgid "read a vector of integers with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:748
#: kernel/sysctl.c:845 kernel/sysctl.c:979 kernel/sysctl.c:1002
msgid ""
"This routine will ensure the values are within the range specified by table-"
">extra1 (min) and table->extra2 (max)."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:751
msgid "Returns 0 on success or -EINVAL on write when the range check fails."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:805
msgid "read a vector of unsigned ints with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:811
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer "
"values from/to the user buffer, treated as an ASCII string. Negative strings "
"are not allowed."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:815
msgid ""
"This routine will ensure the values are within the range specified by table-"
">extra1 (min) and table->extra2 (max). There is a final sanity check for "
"UINT_MAX to avoid having to support wrap around uses from userspace."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:820
msgid "Returns 0 on success or -ERANGE on write when the range check fails."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:835
msgid "read a vector of unsigned chars with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:841
msgid ""
"Reads/writes up to table->maxlen/sizeof(u8) unsigned chars values from/to "
"the user buffer, treated as an ASCII string. Negative strings are not "
"allowed."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:848
msgid "Returns 0 on success or an error on write when the range check fails."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:970
msgid "read a vector of long integers with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:976
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long values "
"from/to the user buffer, treated as an ASCII string."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:992
msgid "read a vector of millisecond values with min/max values"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:998
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long values "
"from/to the user buffer, treated as an ASCII string. The values are treated "
"as milliseconds, and converted to jiffies when they are stored."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1115
msgid "read a vector of integers as seconds"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1121
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) integer values from/to "
"the user buffer, treated as an ASCII string. The values read are assumed to "
"be in seconds, and are converted into jiffies."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1148
msgid "read a vector of integers as 1/USER_HZ seconds"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1153
msgid "pointer to the file position"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1154
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) integer values from/to "
"the user buffer, treated as an ASCII string. The values read are assumed to "
"be in 1/USER_HZ seconds, and are converted into jiffies."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1170
msgid "read a vector of integers as 1 milliseconds"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1176
msgid ""
"Reads/writes up to table->maxlen/sizeof(unsigned int) integer values from/to "
"the user buffer, treated as an ASCII string. The values read are assumed to "
"be in 1/1000 seconds, and are converted into jiffies."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1192
msgid "read/write from/to a large bitmap"
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1198
msgid ""
"The bitmap is stored at table->data and the bitmap length (in bits) in table-"
">maxlen."
msgstr ""

#: ../../../filesystems/api-summary:107: kernel/sysctl.c:1201
msgid ""
"We use a range comma separated format (e.g. 1,3-4,10-10) so that large "
"bitmaps may be represented in a compact manner. Writing into the file will "
"clear the bitmap then update it with the given input."
msgstr ""

#: ../../../filesystems/api-summary.rst:111
msgid "proc filesystem interface"
msgstr ""

#: ../../../filesystems/api-summary:113: fs/proc/base.c:3465
msgid "Remove dcache entries for **pid** from the /proc dcache."
msgstr ""

#: ../../../filesystems/api-summary:113: fs/proc/base.c:3471
msgid "``struct pid *pid``"
msgstr ""

#: ../../../filesystems/api-summary:113: fs/proc/base.c:3466
msgid "pid that should be flushed."
msgstr ""

#: ../../../filesystems/api-summary:113: fs/proc/base.c:3467
msgid ""
"This function walks a list of inodes (that belong to any proc filesystem) "
"that are attached to the pid and flushes them from the dentry cache."
msgstr ""

#: ../../../filesystems/api-summary:113: fs/proc/base.c:3471
msgid ""
"It is safe and reasonable to cache /proc entries for a task until that task "
"exits.  After that they just clog up the dcache with useless entries, "
"possibly causing useful dcache entries to be flushed instead.  This routine "
"is provided to flush those useless dcache entries when a process is reaped."
msgstr ""

#: ../../../filesystems/api-summary:113: fs/proc/base.c:3478
msgid "This routine is just an optimization so it does not guarantee"
msgstr ""

#: ../../../filesystems/api-summary:113: fs/proc/base.c:3479
msgid ""
"that no dcache entries will exist after a process is reaped it just makes it "
"very unlikely that any will persist."
msgstr ""

#: ../../../filesystems/api-summary.rst:117
msgid "Events based on file descriptors"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:47
msgid "Increment the event counter"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:53 fs/eventfd.c:103
#: fs/eventfd.c:192
msgid "``struct eventfd_ctx *ctx``"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:48
msgid "[in] Pointer to the eventfd context."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:50
msgid "``__poll_t mask``"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:49
msgid "[in] poll mask"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:50
msgid ""
"This function is supposed to be called by the kernel in paths that do not "
"allow sleeping. In this function we allow the counter to reach the "
"ULLONG_MAX value, and we signal this as overflow condition by returning a "
"EPOLLERR to poll(2)."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:97
msgid "Releases a reference to the internal eventfd context."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:98 fs/eventfd.c:187
msgid "[in] Pointer to eventfd context."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:99
msgid ""
"The eventfd context reference must have been previously acquired either with "
"eventfd_ctx_fdget() or eventfd_ctx_fileget()."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:186
msgid "Read the current counter and removes wait queue."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:189
msgid "``wait_queue_entry_t *wait``"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:188
msgid "[in] Wait queue to be removed."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:190
msgid "``__u64 *cnt``"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:189
msgid "[out] Pointer to the 64-bit counter value."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:190
msgid "Returns ``0`` if successful, or the following error codes:"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:192
msgid ": The operation would have blocked."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:194
msgid ""
"This is used to atomically remove a wait queue entry from the eventfd wait "
"queue head, and read/reset the counter value."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:314
msgid "Acquire a reference of an eventfd file descriptor."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:320 fs/eventfd.c:346
msgid "``int fd``"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:315 fs/eventfd.c:341
msgid "[in] Eventfd file descriptor."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:316
msgid ""
"Returns a pointer to the eventfd file structure in case of success, or the "
"following error pointer:"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:319
msgid ": Invalid **fd** file descriptor."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:320 fs/eventfd.c:363
msgid ": The **fd** file descriptor is not an eventfd file."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:340 fs/eventfd.c:358
msgid "Acquires a reference to the internal eventfd context."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:342
msgid ""
"Returns a pointer to the internal eventfd context, otherwise the error "
"pointers returned by the following functions:"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:345
msgid "eventfd_fget"
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:359
msgid "[in] Eventfd file pointer."
msgstr ""

#: ../../../filesystems/api-summary:119: fs/eventfd.c:360
msgid ""
"Returns a pointer to the internal eventfd context, otherwise the error "
"pointer:"
msgstr ""

#: ../../../filesystems/api-summary.rst:123
msgid "eventpoll (epoll) interfaces"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:383
msgid "Checks if ready events might be available."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:389 fs/eventpoll.c:404
#: fs/eventpoll.c:1926 fs/eventpoll.c:2063 fs/eventpoll.c:2128
msgid "``struct eventpoll *ep``"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:385 fs/eventpoll.c:403
#: fs/eventpoll.c:1923
msgid "Pointer to the eventpoll context."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:387
msgid ""
"a value different than ``zero`` if ready events are available, or ``zero`` "
"otherwise."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:398
msgid ""
"check if busy poll has timed out. The timeout value from the epoll instance "
"ep is preferred, but if it is not set fallback to the system-wide global via "
"busy_loop_timeout."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:404
msgid "``unsigned long start_time``"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:402
msgid "The start time used to compute the remaining time until timeout."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:405
msgid "true if the timeout has expired, false otherwise."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1464
msgid ""
"The tfile_check_list is list of epitem_head, which have links that are "
"proposed to be newly added. We need to make sure that those added links "
"don't add too many paths such that we will spend all our time waking up "
"eventpoll objects."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1470
#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:900
msgid "``void``"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1
#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:1
msgid "no arguments"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1470
msgid ""
"``zero`` if the proposed links don't create too many paths, ``-1`` otherwise."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1920
msgid ""
"Retrieves ready events, and delivers them to the caller-supplied event "
"buffer."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1925
msgid "``struct epoll_event __user *events``"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1924
msgid ""
"Pointer to the userspace buffer where the ready events should be stored."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1927
msgid "``int maxevents``"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1926
msgid "Size (in terms of number of events) of the caller event buffer."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1928
msgid "``struct timespec64 *timeout``"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1927
msgid ""
"Maximum timeout for the ready events fetch operation, in timespec. If the "
"timeout is zero, the function will not block, while if the **timeout** ptr "
"is NULL, the function will block until at least one event has been retrieved "
"(or an error occurred)."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:1933
msgid ""
"the number of ready events which have been fetched, or an error code, in "
"case of error."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2057
msgid ""
"verify that adding an epoll file **ep** inside another epoll file does not "
"create closed loops, and determine the depth of the subtree starting at "
"**ep**"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2061
msgid "the :c:type:`struct eventpoll <eventpoll>` to be currently checked."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2063
msgid "``int depth``"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2062
msgid "Current depth of the path being checked."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2064
msgid "depth of the subtree, or INT_MAX if we found a loop or went too deep."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2122
msgid ""
"Performs a check to verify that adding an epoll file (**to**) into another "
"epoll file (represented by **ep**) does not create closed loops or too deep "
"chains."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2126
msgid "Pointer to the epoll we are inserting into."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2128
msgid "``struct eventpoll *to``"
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2127
msgid "Pointer to the epoll to be inserted."
msgstr ""

#: ../../../filesystems/api-summary:125: fs/eventpoll.c:2129
msgid ""
"``zero`` if adding the epoll **to** inside the epoll **from** does not "
"violate the constraints, or ``-1`` otherwise."
msgstr ""

#: ../../../filesystems/api-summary.rst:129
msgid "The Filesystem for Exporting Kernel Objects"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:359
msgid "create an attribute file for an object with custom ns"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:365
#: fs/sysfs/file.c:399 fs/sysfs/file.c:432 fs/sysfs/file.c:460
#: fs/sysfs/file.c:506 fs/sysfs/file.c:523 fs/sysfs/file.c:556
#: fs/sysfs/file.c:581 fs/sysfs/file.c:601 fs/sysfs/file.c:665
#: fs/sysfs/file.c:701 fs/sysfs/file.c:799
#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:90
#: fs/sysfs/symlink.c:103 fs/sysfs/symlink.c:145 fs/sysfs/symlink.c:163
msgid "``struct kobject *kobj``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:360
msgid "object we're creating for"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:362
#: fs/sysfs/file.c:396 fs/sysfs/file.c:429 fs/sysfs/file.c:457
#: fs/sysfs/file.c:503 fs/sysfs/file.c:520 fs/sysfs/file.c:553
msgid "``const struct attribute *attr``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:361
#: fs/sysfs/file.c:502 fs/sysfs/file.c:519
msgid "attribute descriptor"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:363
#: fs/sysfs/file.c:504
msgid "``const void *ns``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:362
msgid "namespace the new file should belong to"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:393
msgid "add an attribute file to a pre-existing group."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:394
#: fs/sysfs/file.c:427 fs/sysfs/file.c:551
#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:140
#: fs/sysfs/symlink.c:158
msgid "object we're acting for."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:395
#: fs/sysfs/file.c:428 fs/sysfs/file.c:552 fs/sysfs/file.c:577
#: fs/sysfs/file.c:597 fs/sysfs/file.c:799
msgid "attribute descriptor."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:397
#: fs/sysfs/file.c:554
msgid "``const char *group``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:396
#: fs/sysfs/file.c:553
msgid "group name."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:426
msgid "update the modified mode value on an object attribute."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:429
msgid "file permissions."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:454
msgid "break \"active\" protection"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:455
msgid "The kernel object **attr** is associated with."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:456
msgid "The attribute to break the \"active\" protection for."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:457
msgid ""
"With sysfs, just like kernfs, deletion of an attribute is postponed until "
"all active .show() and .store() callbacks have finished unless this function "
"is called. Hence this function is useful in methods that implement self "
"deletion."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:479
msgid "restore \"active\" protection"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:485
msgid "``struct kernfs_node *kn``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:480
msgid "Pointer returned by sysfs_break_active_protection()."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:481
msgid ""
"Undo the effects of sysfs_break_active_protection(). Since this function "
"calls kernfs_put() on the kernfs node that corresponds to the 'attr' "
"argument passed to sysfs_break_active_protection() that attribute may have "
"been removed between the sysfs_break_active_protection() and "
"sysfs_unbreak_active_protection() calls, it is not safe to access **kn** "
"after this function has returned."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:500
msgid "remove an object attribute with a custom ns tag"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:501
#: fs/sysfs/file.c:518
msgid "object we're acting for"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:503
msgid "namespace tag of the file to remove"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:504
msgid "Hash the attribute name and namespace tag and kill the victim."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:517
msgid "remove an object attribute from its own method"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:520
msgid "See kernfs_remove_self() for details."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:550
msgid "remove an attribute file from a group."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:575
msgid "create binary file for object."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:576
#: fs/sysfs/file.c:596 fs/sysfs/file.c:660 fs/sysfs/file.c:696
msgid "object."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:578
#: fs/sysfs/file.c:598 fs/sysfs/file.c:800
msgid "``const struct bin_attribute *attr``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:595
msgid "remove binary file for object."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:659
msgid "change owner of a sysfs file."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:661
msgid "name of the file to change."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:663
#: fs/sysfs/file.c:698
msgid "``kuid_t kuid``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:662
#: fs/sysfs/file.c:697
msgid "new owner's kuid"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:664
#: fs/sysfs/file.c:699
msgid "``kgid_t kgid``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:663
#: fs/sysfs/file.c:698
msgid "new owner's kgid"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:664
msgid ""
"This function looks up the sysfs entry **name** under **kobj** and changes "
"the ownership to **kuid**/**kgid**."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:667
#: fs/sysfs/file.c:709
msgid "Returns 0 on success or error code on failure."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:695
msgid "change owner of the given object."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:699
msgid ""
"Change the owner of the default directory, files, groups, and attributes of "
"**kobj** to **kuid**/**kgid**. Note that sysfs_change_owner mirrors how the "
"sysfs entries for a kobject are added by driver core. In summary, "
"sysfs_change_owner() takes care of the default directory entry for **kobj**, "
"the default attributes associated with the ktype of **kobj** and the default "
"attributes associated with the ktype of **kobj**. Additional properties not "
"added by driver core have to be changed by the driver or subsystem which "
"created them. This is similar to how driver/subsystem specific entries are "
"removed."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:742
#: fs/sysfs/file.c:768
msgid "scnprintf equivalent, aware of PAGE_SIZE buffer."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:743
#: fs/sysfs/file.c:769
msgid "start of PAGE_SIZE buffer."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:745
#: fs/sysfs/file.c:773 ../../../filesystems/api-summary:143:
#: fs/debugfs/inode.c:831
msgid "``const char *fmt``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:744
#: fs/sysfs/file.c:772
msgid "format"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:746
#: fs/sysfs/file.c:774 ../../../filesystems/api-summary:143:
#: fs/debugfs/inode.c:832
msgid "``...``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:745
msgid "optional arguments to **format**"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:746
msgid "Returns number of characters written to **buf**."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:771
msgid "``int at``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:770
msgid ""
"offset in **buf** to start write in bytes **at** must be >= 0 && < PAGE_SIZE"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:773
msgid "optional arguments to **fmt**"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:774
msgid "Returns number of characters written starting at &**buf**[**at**]."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:796
msgid "read callback to simply copy from memory."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:797
msgid "attribute file which is being read."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:798
msgid "object to which the attribute belongs."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:800
msgid "destination buffer."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:802
msgid "``loff_t off``"
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:801
msgid "offset in bytes from which to read."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:802
msgid "maximum number of bytes to read."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:803
msgid ""
"Simple ->read() callback for bin_attributes backed by a buffer in memory. "
"The **private** and **size** members in struct bin_attribute must be set to "
"the buffer's location and size before the bin_attribute is created in sysfs."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:807
msgid ""
"Bounds check for **off** and **count** is done in sysfs_kf_bin_read(). "
"Negative value check for **off** is done in vfs_setpos() and "
"default_llseek()."
msgstr ""

#: ../../../filesystems/api-summary:131: fs/sysfs/file.c:810
msgid "Returns number of bytes written to **buf**."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:84
#: fs/sysfs/symlink.c:97
msgid "create symlink between two objects."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:85
#: fs/sysfs/symlink.c:98
msgid "object whose directory we're creating the link in."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:87
#: fs/sysfs/symlink.c:100
msgid "``struct kobject *target``"
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:86
#: fs/sysfs/symlink.c:99 fs/sysfs/symlink.c:159
msgid "object we're pointing to."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:87
#: fs/sysfs/symlink.c:100
msgid "name of the symlink."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:101
msgid ""
"This function does the same as sysfs_create_link(), but it doesn't warn if "
"the link already exists."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:139
msgid "remove symlink in object's directory."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:141
msgid "name of the symlink to remove."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:157
msgid "rename symlink in object's directory."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:160
msgid "``struct kobject *targ``"
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:161
msgid "``const char *old``"
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:160
msgid "previous name of the symlink."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:162
msgid "``const char *new``"
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:161
msgid "new name of the symlink."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:163
msgid "``const void *new_ns``"
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:162
msgid "new namespace of the symlink."
msgstr ""

#: ../../../filesystems/api-summary:134: fs/sysfs/symlink.c:163
msgid "A helper function for the common rename symlink idiom."
msgstr ""

#: ../../../filesystems/api-summary.rst:138
msgid "The debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary.rst:141
msgid "debugfs interface"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:337
msgid "look up an existing debugfs file"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:338
msgid "a pointer to a string containing the name of the file to look up."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:339
msgid "a pointer to the parent dentry of the file."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:340
msgid ""
"This function will return a pointer to a dentry if it succeeds.  If the file "
"doesn't exist or an error occurs, ``NULL`` will be returned.  The returned "
"dentry must be passed to dput() when it is no longer needed."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:344
#: fs/debugfs/inode.c:570 fs/debugfs/inode.c:678 fs/debugfs/inode.c:836
msgid ""
"If debugfs is not enabled in the kernel, the value -``ENODEV`` will be "
"returned."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:487
#: fs/debugfs/inode.c:525
msgid "create a file in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:488
#: fs/debugfs/inode.c:526 fs/debugfs/inode.c:614
#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:594
#: fs/debugfs/file.c:630 fs/debugfs/file.c:666 fs/debugfs/file.c:703
#: fs/debugfs/file.c:742 fs/debugfs/file.c:791 fs/debugfs/file.c:809
#: fs/debugfs/file.c:827 fs/debugfs/file.c:845 fs/debugfs/file.c:879
#: fs/debugfs/file.c:915 fs/debugfs/file.c:996 fs/debugfs/file.c:1124
#: fs/debugfs/file.c:1186 fs/debugfs/file.c:1282 fs/debugfs/file.c:1360
msgid "a pointer to a string containing the name of the file to create."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:489
#: fs/debugfs/inode.c:527 ../../../filesystems/api-summary:146:
#: fs/debugfs/file.c:1283
msgid "the permission that the file should have."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:490
#: fs/debugfs/inode.c:528 fs/debugfs/inode.c:615
msgid ""
"a pointer to the parent dentry for this file.  This should be a directory "
"dentry if set.  If this parameter is NULL, then the file will be created in "
"the root of the debugfs filesystem."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:493
#: fs/debugfs/inode.c:531
msgid ""
"a pointer to something that the caller will want to get to later on.  The "
"inode.i_private pointer will point to this value on the open() call."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:496
#: fs/debugfs/inode.c:534
msgid ""
"a pointer to a struct file_operations that should be used for this file."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:498
msgid ""
"debugfs_create_file_unsafe() is completely analogous to "
"debugfs_create_file(), the only difference being that the fops handed it "
"will not get protected against file removals by the debugfs core."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:503
msgid ""
"It is your responsibility to protect your struct file_operation methods "
"against file removals by means of debugfs_file_get() and debugfs_file_put(). "
"->open() is still protected by debugfs though."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:508
msgid ""
"Any struct file_operations defined by means of DEFINE_DEBUGFS_ATTRIBUTE() is "
"protected against file removals and thus, may be used here."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:537
msgid "``loff_t file_size``"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:536
msgid "initial file size"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:537
msgid ""
"This is the basic \"create a file\" function for debugfs.  It allows for a "
"wide range of flexibility in creating a file, or a directory (if you want to "
"create a directory, the debugfs_create_dir() function is recommended to be "
"used instead.)"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:556
msgid "create a directory in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:557
msgid "a pointer to a string containing the name of the directory to create."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:559
msgid ""
"a pointer to the parent dentry for this file.  This should be a directory "
"dentry if set.  If this parameter is NULL, then the directory will be "
"created in the root of the debugfs filesystem."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:562
msgid "This function creates a directory in debugfs with the given name."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:564
#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1197
msgid ""
"This function will return a pointer to a dentry if it succeeds.  This "
"pointer must be passed to the debugfs_remove() function when the file is to "
"be removed (no automatic cleanup happens if your module is unloaded, you are "
"responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be returned."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:574
msgid ""
"it's expected that most callers should _ignore_ the errors returned by this "
"function. Other debugfs functions handle the fact that the \"dentry\" passed "
"to them could be an error and they don't crash in that case. Drivers should "
"generally work fine even if debugfs fails to init anyway."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:613
msgid "create automount point in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:619
msgid "``debugfs_automount_t f``"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:618
msgid "function to be called when pathname resolution steps on that one."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:619
msgid "opaque argument to pass to f()."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:620
msgid "**f** should return what ->d_automount() would."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:660
msgid "create a symbolic link in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:661
msgid ""
"a pointer to a string containing the name of the symbolic link to create."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:663
msgid ""
"a pointer to the parent dentry for this symbolic link.  This should be a "
"directory dentry if set.  If this parameter is NULL, then the symbolic link "
"will be created in the root of the debugfs filesystem."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:668
msgid "``const char *target``"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:667
msgid ""
"a pointer to a string containing the path to the target of the symbolic link."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:669
msgid ""
"This function creates a symbolic link with the given name in debugfs that "
"links to the given target path."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:672
msgid ""
"This function will return a pointer to a dentry if it succeeds.  This "
"pointer must be passed to the debugfs_remove() function when the symbolic "
"link is to be removed (no automatic cleanup happens if your module is "
"unloaded, you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) "
"will be returned."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:782
msgid "recursively removes a directory"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:783
msgid ""
"a pointer to a the dentry of the directory to be removed.  If this parameter "
"is NULL or an error value, nothing will be done."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:785
msgid ""
"This function recursively removes a directory tree in debugfs that was "
"previously created with a call to another debugfs function (like "
"debugfs_create_file() or variants thereof.)"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:789
msgid ""
"This function is required to be called in order for the file to be removed, "
"no automatic cleanup of files will happen when a module is removed, you are "
"responsible here."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:806
msgid "lookup a directory or file and recursively remove it"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:807
msgid "a pointer to a string containing the name of the item to look up."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:808
msgid "a pointer to the parent dentry of the item."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:809
msgid ""
"This is the equlivant of doing something like "
"debugfs_remove(debugfs_lookup(..)) but with the proper reference counting "
"handled for the directory being looked up."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:828
msgid "rename a file/directory in the debugfs filesystem"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:829
msgid "dentry of an object to be renamed."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:830
msgid "format for new name"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:1
msgid "variable arguments"
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:831
msgid ""
"This function renames a file/directory in debugfs.  The target must not "
"exist for rename to succeed."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:834
msgid "This function will return 0 on success and -E... on failure."
msgstr ""

#: ../../../filesystems/api-summary:143: fs/debugfs/inode.c:894
msgid "Tells whether debugfs has been registered"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:146
msgid "mark the beginning of file data access"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:147
msgid "the dentry object whose data is being accessed."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:148
msgid ""
"Up to a matching call to debugfs_file_put(), any successive call into the "
"file removing functions debugfs_remove() and debugfs_remove_recursive() will "
"block. Since associated private file data may only get freed after a "
"successful return of any of the removal functions, you may safely access it "
"after a successful call to debugfs_file_get() without worrying about "
"lifetime issues."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:155
msgid ""
"If -``EIO`` is returned, the file has already been removed and thus, it is "
"not safe to access any of its data. If, on the other hand, it is allowed to "
"access the file data, zero is returned."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:167
msgid "mark the end of file data access"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:168
msgid "the dentry object formerly passed to debugfs_file_get()."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:170
msgid ""
"Allow any ongoing concurrent call into debugfs_remove() or "
"debugfs_remove_recursive() blocked by a former call to debugfs_file_get() to "
"proceed and return to its caller."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:185
msgid "enter a debugfs cancellation"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:186
#: fs/debugfs/file.c:236
msgid "the file being accessed"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:188
#: fs/debugfs/file.c:238
msgid "``struct debugfs_cancellation *cancellation``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:187
msgid ""
"the cancellation object, the cancel callback inside of it must be initialized"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:189
msgid ""
"When a debugfs file is removed it needs to wait for all active operations to "
"complete. However, the operation itself may need to wait for hardware or "
"completion of some asynchronous process or similar. As such, it may need to "
"be cancelled to avoid long waits or even deadlocks."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:195
msgid ""
"This function can be used inside a debugfs handler that may need to be "
"cancelled. As soon as this function is called, the cancellation's 'cancel' "
"callback may be called, at which point the caller should proceed to call "
"debugfs_leave_cancellation() and leave the debugfs handler function as soon "
"as possible. Note that the 'cancel' callback is only ever called in the "
"context of some kind of debugfs_remove()."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:203
msgid "This function must be paired with debugfs_leave_cancellation()."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:235
msgid "leave cancellation section"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:237
msgid ""
"the cancellation previously registered with debugfs_enter_cancellation()"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:239
msgid "See the documentation of debugfs_enter_cancellation()."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:593
#: fs/debugfs/file.c:790
msgid ""
"create a debugfs file that is used to read and write an unsigned 8-bit value"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:595
#: fs/debugfs/file.c:631 fs/debugfs/file.c:667 fs/debugfs/file.c:704
#: fs/debugfs/file.c:743 fs/debugfs/file.c:792 fs/debugfs/file.c:810
#: fs/debugfs/file.c:828 fs/debugfs/file.c:846 fs/debugfs/file.c:880
#: fs/debugfs/file.c:916 fs/debugfs/file.c:997 fs/debugfs/file.c:1125
#: fs/debugfs/file.c:1187 fs/debugfs/file.c:1361
msgid "the permission that the file should have"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:596
#: fs/debugfs/file.c:632 fs/debugfs/file.c:668 fs/debugfs/file.c:705
#: fs/debugfs/file.c:744 fs/debugfs/file.c:793 fs/debugfs/file.c:811
#: fs/debugfs/file.c:829 fs/debugfs/file.c:847 fs/debugfs/file.c:881
#: fs/debugfs/file.c:917 fs/debugfs/file.c:998 fs/debugfs/file.c:1126
#: fs/debugfs/file.c:1188 fs/debugfs/file.c:1284 fs/debugfs/file.c:1362
#: fs/debugfs/file.c:1408
msgid ""
"a pointer to the parent dentry for this file.  This should be a directory "
"dentry if set.  If this parameter is ``NULL``, then the file will be created "
"in the root of the debugfs filesystem."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:600
#: fs/debugfs/file.c:797
msgid "``u8 *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:599
#: fs/debugfs/file.c:635 fs/debugfs/file.c:671 fs/debugfs/file.c:708
#: fs/debugfs/file.c:747 fs/debugfs/file.c:796 fs/debugfs/file.c:814
#: fs/debugfs/file.c:832 fs/debugfs/file.c:850 fs/debugfs/file.c:884
#: fs/debugfs/file.c:920 fs/debugfs/file.c:1001 fs/debugfs/file.c:1129
msgid "a pointer to the variable that the file should read to and write from."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:601
#: fs/debugfs/file.c:637 fs/debugfs/file.c:673 fs/debugfs/file.c:710
#: fs/debugfs/file.c:749 fs/debugfs/file.c:1003 fs/debugfs/file.c:1131
msgid ""
"This function creates a file in debugfs with the given name that contains "
"the value of the variable **value**.  If the **mode** variable is so set, it "
"can be read from, and written to."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:629
#: fs/debugfs/file.c:808
msgid ""
"create a debugfs file that is used to read and write an unsigned 16-bit value"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:636
#: fs/debugfs/file.c:815
msgid "``u16 *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:665
#: fs/debugfs/file.c:826
msgid ""
"create a debugfs file that is used to read and write an unsigned 32-bit value"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:672
#: fs/debugfs/file.c:833
msgid "``u32 *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:702
#: fs/debugfs/file.c:844
msgid ""
"create a debugfs file that is used to read and write an unsigned 64-bit value"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:709
#: fs/debugfs/file.c:851
msgid "``u64 *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:740
msgid ""
"create a debugfs file that is used to read and write an unsigned long value."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:748
msgid "``unsigned long *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:878
msgid "create a debugfs file that is used to read and write an size_t value"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:885
msgid "``size_t *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:913
msgid "create a debugfs file that is used to read and write an atomic_t value"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:921
msgid "``atomic_t *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:995
msgid "create a debugfs file that is used to read and write a boolean value"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1002
msgid "``bool *value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1123
msgid "create a debugfs file that is used to read and write a string value"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1130
msgid "``char **value``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1184
msgid "create a debugfs file that is used to read and write a binary blob"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1192
msgid "``struct debugfs_blob_wrapper *blob``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1191
msgid ""
"a pointer to a struct debugfs_blob_wrapper which contains a pointer to the "
"blob data and the size of the data."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1193
msgid ""
"This function creates a file in debugfs with the given name that exports "
"**blob->data** as a binary blob. If the **mode** variable is so set it can "
"be read from and written to."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1203
msgid ""
"If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will be "
"returned."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1280
msgid "create a debugfs file that is used to read u32 array."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1288
msgid "``struct debugfs_u32_array *array``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1287
msgid "wrapper struct containing data pointer and size of the array."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1288
msgid ""
"This function creates a file in debugfs with the given name that exports "
"**array** as data. If the **mode** variable is so set it can be read from. "
"Writing is not supported. Seek within the file is also not supported. Once "
"array is created its size can not be changed."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1311
msgid "use seq_print to describe a set of registers"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1317
msgid "``struct seq_file *s``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1312
msgid "the seq_file structure being used to generate output"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1314
msgid "``const struct debugfs_reg32 *regs``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1313
msgid "an array if struct debugfs_reg32 structures"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1315
msgid "``int nregs``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1314
msgid "the length of the above array"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1316
msgid "``void __iomem *base``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1315
msgid "the base address to be used in reading the registers"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1317
msgid "``char *prefix``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1316
msgid "a string to be prefixed to every output line"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1317
msgid ""
"This function outputs a text block describing the current values of some 32-"
"bit hardware registers. It is meant to be used within debugfs files based on "
"seq_file that need to show registers, intermixed with other information. The "
"prefix argument may be used to specify a leading string, because some "
"peripherals have several blocks of identical registers, for example "
"configuration of dma channels"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1359
msgid "create a debugfs file that returns register values"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1366
msgid "``struct debugfs_regset32 *regset``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1365
msgid ""
"a pointer to a struct debugfs_regset32, which contains a pointer to an array "
"of register definitions, the array size and the base address where the "
"register bank is to be found."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1368
msgid ""
"This function creates a file in debugfs with the given name that reports the "
"names and values of a set of 32-bit registers. If the **mode** variable is "
"so set it can be read from. Writing is not supported."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1404
msgid "create a debugfs file that is bound to device."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1410
msgid "``struct device *dev``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1406
msgid "device related to this debugfs file."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1407
msgid "name of the debugfs file."
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1412
msgid "``int (*read_fn)(struct seq_file *s, void *data)``"
msgstr ""

#: ../../../filesystems/api-summary:146: fs/debugfs/file.c:1411
msgid "function pointer called to print the seq_file content."
msgstr ""
