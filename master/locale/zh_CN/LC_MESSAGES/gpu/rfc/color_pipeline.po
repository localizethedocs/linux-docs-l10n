# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/rfc/color_pipeline.rst:5
msgid "Linux Color Pipeline API"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:8
msgid "What problem are we solving?"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:10
msgid ""
"We would like to support pre-, and post-blending complex color "
"transformations in display controller hardware in order to allow for HW-"
"supported HDR use-cases, as well as to provide support to color-managed "
"applications, such as video or image editors."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:15
msgid ""
"It is possible to support an HDR output on HW supporting the Colorspace and "
"HDR Metadata drm_connector properties, but that requires the compositor or "
"application to render and compose the content into one final buffer intended "
"for display. Doing so is costly."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:20
msgid ""
"Most modern display HW offers various 1D LUTs, 3D LUTs, matrices, and other "
"operations to support color transformations. These operations are often "
"implemented in fixed-function HW and therefore much more power efficient "
"than performing similar operations via shaders or CPU."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:25
msgid ""
"We would like to make use of this HW functionality to support complex color "
"transformations with no, or minimal CPU or shader load. The switch between "
"HW fixed-function blocks and shaders/CPU must be seamless with no visible "
"difference when fallback to shaders/CPU is neceesary at any time."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:32
msgid "How are other OSes solving this problem?"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:34
msgid ""
"The most widely supported use-cases regard HDR content, whether video or "
"gaming."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:37
msgid ""
"Most OSes will specify the source content format (color gamut, encoding "
"transfer function, and other metadata, such as max and average light levels) "
"to a driver. Drivers will then program their fixed-function HW accordingly "
"to map from a source content buffer's space to a display's space."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:42
msgid ""
"When fixed-function HW is not available the compositor will assemble a "
"shader to ask the GPU to perform the transformation from the source content "
"format to the display's format."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:46
msgid ""
"A compositor's mapping function and a driver's mapping function are usually "
"entirely separate concepts. On OSes where a HW vendor has no insight into "
"closed-source compositor code such a vendor will tune their color management "
"code to visually match the compositor's. On other OSes, where both mapping "
"functions are open to an implementer they will ensure both mappings match."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:52
msgid ""
"This results in mapping algorithm lock-in, meaning that no-one alone can "
"experiment with or introduce new mapping algorithms and achieve consistent "
"results regardless of which implementation path is taken."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:57
msgid "Why is Linux different?"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:59
msgid ""
"Unlike other OSes, where there is one compositor for one or more drivers, on "
"Linux we have a many-to-many relationship. Many compositors; many drivers. "
"In addition each compositor vendor or community has their own view of how "
"color management should be done. This is what makes Linux so beautiful."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:64
msgid ""
"This means that a HW vendor can now no longer tune their driver to one "
"compositor, as tuning it to one could make it look fairly different from "
"another compositor's color mapping."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:68
msgid "We need a better solution."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:72
msgid "Descriptive API"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:74
msgid ""
"An API that describes the source and destination colorspaces is a "
"descriptive API. It describes the input and output color spaces but does not "
"describe how precisely they should be mapped. Such a mapping includes many "
"minute design decision that can greatly affect the look of the final result."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:79
msgid ""
"It is not feasible to describe such mapping with enough detail to ensure the "
"same result from each implementation. In fact, these mappings are a very "
"active research area."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:85
msgid "Prescriptive API"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:87
msgid ""
"A prescriptive API describes not the source and destination colorspaces. It "
"instead prescribes a recipe for how to manipulate pixel values to arrive at "
"the desired outcome."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:91
msgid ""
"This recipe is generally an ordered list of straight-forward operations, "
"with clear mathematical definitions, such as 1D LUTs, 3D LUTs, matrices, or "
"other operations that can be described in a precise manner."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:97
msgid "The Color Pipeline API"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:99
msgid ""
"HW color management pipelines can significantly differ between HW vendors in "
"terms of availability, ordering, and capabilities of HW blocks. This makes a "
"common definition of color management blocks and their ordering nigh "
"impossible. Instead we are defining an API that allows user space to "
"discover the HW capabilities in a generic manner, agnostic of specific "
"drivers and hardware."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:108
msgid "drm_colorop Object"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:110
msgid ""
"To support the definition of color pipelines we define the DRM core object "
"type drm_colorop. Individual drm_colorop objects will be chained via the "
"NEXT property of a drm_colorop to constitute a color pipeline. Each "
"drm_colorop object is unique, i.e., even if multiple color pipelines have "
"the same operation they won't share the same drm_colorop object to describe "
"that operation."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:117
msgid ""
"Note that drivers are not expected to map drm_colorop objects statically to "
"specific HW blocks. The mapping of drm_colorop objects is entirely a driver-"
"internal detail and can be as dynamic or static as a driver needs it to be. "
"See more in the Driver Implementation Guide section below."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:122
msgid "Each drm_colorop has three core properties:"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:124
msgid ""
"TYPE: An enumeration property, defining the type of transformation, such as "
"* enumerated curve * custom (uniform) 1D LUT * 3x3 matrix * 3x4 matrix * 3D "
"LUT * etc."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:132
msgid ""
"Depending on the type of transformation other properties will describe more "
"details."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:135
msgid ""
"BYPASS: A boolean property that can be used to easily put a block into "
"bypass mode. The BYPASS property is not mandatory for a colorop, as long as "
"the entire pipeline can get bypassed by setting the COLOR_PIPELINE on a "
"plane to '0'."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:140
msgid ""
"NEXT: The ID of the next drm_colorop in a color pipeline, or 0 if this "
"drm_colorop is the last in the chain."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:143
msgid "An example of a drm_colorop object might look like one of these::"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:169
msgid "drm_colorop extensibility"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:171
msgid ""
"Unlike existing DRM core objects, like &drm_plane, drm_colorop is not "
"extensible. This simplifies implementations and keeps all functionality for "
"managing &drm_colorop objects in the DRM core."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:175
msgid ""
"If there is a need one may introduce a simple &drm_colorop_funcs function "
"table in the future, for example to support an IN_FORMATS property on a "
"&drm_colorop."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:179
msgid ""
"If a driver requires the ability to create a driver-specific colorop object "
"they will need to add &drm_colorop func table support with support for the "
"usual functions, like destroy, atomic_duplicate_state, and "
"atomic_destroy_state."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:186
msgid "COLOR_PIPELINE Plane Property"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:188
msgid ""
"Color Pipelines are created by a driver and advertised via a new "
"COLOR_PIPELINE enum property on each plane. Values of the property always "
"include object id 0, which is the default and means all color processing is "
"disabled. Additional values will be the object IDs of the first drm_colorop "
"in a pipeline. A driver can create and advertise none, one, or more possible "
"color pipelines. A DRM client will select a color pipeline by setting the "
"COLOR PIPELINE to the respective value."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:196
msgid ""
"NOTE: Many DRM clients will set enumeration properties via the string value, "
"often hard-coding it. Since this enumeration is generated based on the "
"colorop object IDs it is important to perform the Color Pipeline Discovery, "
"described below, instead of hard-coding color pipeline assignment. Drivers "
"might generate the enum strings dynamically. Hard-coded strings might only "
"work for specific drivers on a specific pieces of HW. Color Pipeline "
"Discovery can work universally, as long as drivers implement the required "
"color operations."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:205
msgid ""
"The COLOR_PIPELINE property is only exposed when the "
"DRM_CLIENT_CAP_PLANE_COLOR_PIPELINE is set. Drivers shall ignore any "
"existing pre-blend color operations when this cap is set, such as "
"COLOR_RANGE and COLOR_ENCODING. If drivers want to support COLOR_RANGE or "
"COLOR_ENCODING functionality when the color pipeline client cap is set, they "
"are expected to expose colorops in the pipeline to allow for the appropriate "
"color transformation."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:213
msgid ""
"Setting of the COLOR_PIPELINE plane property or drm_colorop properties is "
"only allowed for userspace that sets this client cap."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:216
msgid ""
"An example of a COLOR_PIPELINE property on a plane might look like this::"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:225
msgid "Color Pipeline Discovery"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:227
msgid "A DRM client wanting color management on a drm_plane will:"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:229
msgid "Get the COLOR_PIPELINE property of the plane"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:230
msgid "iterate all COLOR_PIPELINE enum values"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:231
msgid ""
"for each enum value walk the color pipeline (via the NEXT pointers) and see "
"if the available color operations are suitable for the desired color "
"management operations"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:235
msgid ""
"If userspace encounters an unknown or unsuitable color operation during "
"discovery it does not need to reject the entire color pipeline outright, as "
"long as the unknown or unsuitable colorop has a \"BYPASS\" property. Drivers "
"will ensure that a bypassed block does not have any effect."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:240
msgid ""
"An example of chained properties to define an AMD pre-blending color "
"pipeline might look like this::"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:284
msgid "Color Pipeline Programming"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:286
msgid "Once a DRM client has found a suitable pipeline it will:"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:288
msgid ""
"Set the COLOR_PIPELINE enum value to the one pointing at the first "
"drm_colorop object of the desired pipeline"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:290
msgid ""
"Set the properties for all drm_colorop objects in the pipeline to the "
"desired values, setting BYPASS to true for unused drm_colorop blocks, and "
"false for enabled drm_colorop blocks"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:293
msgid ""
"Perform (TEST_ONLY or not) atomic commit with all the other KMS states it "
"wishes to change"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:296
msgid ""
"To configure the pipeline for an HDR10 PQ plane and blending in linear "
"space, a compositor might perform an atomic commit with the following "
"property values::"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:325
msgid "Driver Implementer's Guide"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:327
msgid ""
"What does this all mean for driver implementations? As noted above the "
"colorops can map to HW directly but don't need to do so. Here are some "
"suggestions on how to think about creating your color pipelines:"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:331
msgid ""
"Try to expose pipelines that use already defined colorops, even if your "
"hardware pipeline is split differently. This allows existing userspace to "
"immediately take advantage of the hardware."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:335
msgid ""
"Additionally, try to expose your actual hardware blocks as colorops. Define "
"new colorop types where you believe it can offer significant benefits if "
"userspace learns to program them."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:339
msgid ""
"Avoid defining new colorops for compound operations with very narrow scope. "
"If you have a hardware block for a special operation that cannot be split "
"further, you can expose that as a new colorop type. However, try to not "
"define colorops for \"use cases\", especially if they require you to combine "
"multiple hardware blocks."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:345
msgid ""
"Design new colorops as prescriptive, not descriptive; by the mathematical "
"formula, not by the assumed input and output."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:348
msgid ""
"A defined colorop type must be deterministic. The exact behavior of the "
"colorop must be documented entirely, whether via a mathematical formula or "
"some other description. Its operation can depend only on its properties and "
"input and nothing else, allowed error tolerance notwithstanding."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:356
msgid "Driver Forward/Backward Compatibility"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:358
msgid ""
"As this is uAPI drivers can't regress color pipelines that have been "
"introduced for a given HW generation. New HW generations are free to abandon "
"color pipelines advertised for previous generations. Nevertheless, it can be "
"beneficial to carry support for existing color pipelines forward as those "
"will likely already have support in DRM clients."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:365
msgid ""
"Introducing new colorops to a pipeline is fine, as long as they can be "
"bypassed or are purely informational. DRM clients implementing support for "
"the pipeline can always skip unknown properties as long as they can be "
"confident that doing so will not cause unexpected results."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:370
msgid ""
"If a new colorop doesn't fall into one of the above categories (bypassable "
"or informational) the modified pipeline would be unusable for user space. In "
"this case a new pipeline should be defined."
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:376
msgid "References"
msgstr ""

#: ../../../gpu/rfc/color_pipeline.rst:378
msgid ""
"https://lore.kernel.org/dri-devel/"
"QMers3awXvNCQlyhWdTtsPwkp5ie9bze_hD5nAccFW7a_RXlWjYB7MoUW_8CKLT2bSQwIXVi5H6VULYIxCdgvryZoAoJnC5lZgyK1QWn488=@emersion."
"fr/"
msgstr ""
