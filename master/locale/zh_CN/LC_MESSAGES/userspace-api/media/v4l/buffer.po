# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/media/v4l/buffer.rst:8
msgid "Buffers"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:10
msgid ""
"A buffer contains data exchanged by application and driver using one of the "
"Streaming I/O methods. In the multi-planar API, the data is held in planes, "
"while the buffer structure acts as a container for the planes. Only pointers "
"to buffers (planes) are exchanged, the data itself is not copied. These "
"pointers, together with meta-information like timestamps or field parity, "
"are stored in a struct :c:type:`v4l2_buffer`, argument to the :ref:"
"`VIDIOC_QUERYBUF`, :ref:`VIDIOC_QBUF <VIDIOC_QBUF>` and :ref:`VIDIOC_DQBUF "
"<VIDIOC_QBUF>` ioctl. In the multi-planar API, some plane-specific members "
"of struct :c:type:`v4l2_buffer`, such as pointers and sizes for each plane, "
"are stored in struct :c:type:`v4l2_plane` instead. In that case, struct :c:"
"type:`v4l2_buffer` contains an array of plane structures."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:24
msgid ""
"Dequeued video buffers come with timestamps. The driver decides at which "
"part of the frame and with which clock the timestamp is taken. Please see "
"flags in the masks ``V4L2_BUF_FLAG_TIMESTAMP_MASK`` and "
"``V4L2_BUF_FLAG_TSTAMP_SRC_MASK`` in :ref:`buffer-flags`. These flags are "
"always valid and constant across all buffers during the whole video stream. "
"Changes in these flags may take place as a side effect of :ref:"
"`VIDIOC_S_INPUT <VIDIOC_G_INPUT>` or :ref:`VIDIOC_S_OUTPUT "
"<VIDIOC_G_OUTPUT>` however. The ``V4L2_BUF_FLAG_TIMESTAMP_COPY`` timestamp "
"type which is used by e.g. on mem-to-mem devices is an exception to the "
"rule: the timestamp source flags are copied from the OUTPUT video buffer to "
"the CAPTURE video buffer."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:38
msgid "Interactions between formats, controls and buffers"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:40
msgid ""
"V4L2 exposes parameters that influence the buffer size, or the way data is "
"laid out in the buffer. Those parameters are exposed through both formats "
"and controls. One example of such a control is the ``V4L2_CID_ROTATE`` "
"control that modifies the direction in which pixels are stored in the "
"buffer, as well as the buffer size when the selected format includes padding "
"at the end of lines."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:47
msgid ""
"The set of information needed to interpret the content of a buffer (e.g. the "
"pixel format, the line stride, the tiling orientation or the rotation) is "
"collectively referred to in the rest of this section as the buffer layout."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:51
msgid ""
"Controls that can modify the buffer layout shall set the "
"``V4L2_CTRL_FLAG_MODIFY_LAYOUT`` flag."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:54
msgid ""
"Modifying formats or controls that influence the buffer size or layout "
"require the stream to be stopped. Any attempt at such a modification while "
"the stream is active shall cause the ioctl setting the format or the control "
"to return the ``EBUSY`` error code. In that case drivers shall also set the "
"``V4L2_CTRL_FLAG_GRABBED`` flag when calling :c:func:`VIDIOC_QUERYCTRL` or :"
"c:func:`VIDIOC_QUERY_EXT_CTRL` for such a control while the stream is active."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:64
msgid ""
"The :c:func:`VIDIOC_S_SELECTION` ioctl can, depending on the hardware (for "
"instance if the device doesn't include a scaler), modify the format in "
"addition to the selection rectangle. Similarly, the :c:func:"
"`VIDIOC_S_INPUT`, :c:func:`VIDIOC_S_OUTPUT`, :c:func:`VIDIOC_S_STD` and :c:"
"func:`VIDIOC_S_DV_TIMINGS` ioctls can also modify the format and selection "
"rectangles. When those ioctls result in a buffer size or layout change, "
"drivers shall handle that condition as they would handle it in the :c:func:"
"`VIDIOC_S_FMT` ioctl in all cases described in this section."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:73
msgid ""
"Controls that only influence the buffer layout can be modified at any time "
"when the stream is stopped. As they don't influence the buffer size, no "
"special handling is needed to synchronize those controls with buffer "
"allocation and the ``V4L2_CTRL_FLAG_GRABBED`` flag is cleared once the "
"stream is stopped."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:79
msgid ""
"Formats and controls that influence the buffer size interact with buffer "
"allocation. The simplest way to handle this is for drivers to always require "
"buffers to be reallocated in order to change those formats or controls. In "
"that case, to perform such changes, userspace applications shall first stop "
"the video stream with the :c:func:`VIDIOC_STREAMOFF` ioctl if it is running "
"and free all buffers with the :c:func:`VIDIOC_REQBUFS` ioctl if they are "
"allocated. After freeing all buffers the ``V4L2_CTRL_FLAG_GRABBED`` flag for "
"controls is cleared. The format or controls can then be modified, and "
"buffers shall then be reallocated and the stream restarted. A typical ioctl "
"sequence is"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:90
#: ../../../userspace-api/media/v4l/buffer.rst:121
msgid "VIDIOC_STREAMOFF"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:91
msgid "VIDIOC_REQBUFS(0)"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:92
#: ../../../userspace-api/media/v4l/buffer.rst:122
msgid "VIDIOC_S_EXT_CTRLS"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:93
#: ../../../userspace-api/media/v4l/buffer.rst:123
msgid "VIDIOC_S_FMT"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:94
msgid "VIDIOC_REQBUFS(n)"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:95
#: ../../../userspace-api/media/v4l/buffer.rst:124
msgid "VIDIOC_QBUF"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:96
#: ../../../userspace-api/media/v4l/buffer.rst:125
msgid "VIDIOC_STREAMON"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:98
msgid ""
"The second :c:func:`VIDIOC_REQBUFS` call will take the new format and "
"control value into account to compute the buffer size to allocate. "
"Applications can also retrieve the size by calling the :c:func:"
"`VIDIOC_G_FMT` ioctl if needed."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:104
msgid ""
"The API doesn't mandate the above order for control (3.) and format (4.) "
"changes. Format and controls can be set in a different order, or even "
"interleaved, depending on the device and use case. For instance some "
"controls might behave differently for different pixel formats, in which case "
"the format might need to be set first."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:110
msgid ""
"When reallocation is required, any attempt to modify format or controls that "
"influences the buffer size while buffers are allocated shall cause the "
"format or control set ioctl to return the ``EBUSY`` error. Any attempt to "
"queue a buffer too small for the current format or controls shall cause the :"
"c:func:`VIDIOC_QBUF` ioctl to return a ``EINVAL`` error."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:116
msgid ""
"Buffer reallocation is an expensive operation. To avoid that cost, drivers "
"can (and are encouraged to) allow format or controls that influence the "
"buffer size to be changed with buffers allocated. In that case, a typical "
"ioctl sequence to modify format and controls is"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:127
msgid ""
"For this sequence to operate correctly, queued buffers need to be large "
"enough for the new format or controls. Drivers shall return a ``ENOSPC`` "
"error in response to format change (:c:func:`VIDIOC_S_FMT`) or control "
"changes (:c:func:`VIDIOC_S_CTRL` or :c:func:`VIDIOC_S_EXT_CTRLS`) if buffers "
"too small for the new format are currently queued. As a simplification, "
"drivers are allowed to return a ``EBUSY`` error from these ioctls if any "
"buffer is currently queued, without checking the queued buffers sizes."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:135
msgid ""
"Additionally, drivers shall return a ``EINVAL`` error from the :c:func:"
"`VIDIOC_QBUF` ioctl if the buffer being queued is too small for the current "
"format or controls. Together, these requirements ensure that queued buffers "
"will always be large enough for the configured format and controls."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:140
msgid ""
"Userspace applications can query the buffer size required for a given format "
"and controls by first setting the desired control values and then trying the "
"desired format. The :c:func:`VIDIOC_TRY_FMT` ioctl will return the required "
"buffer size."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:145
msgid "VIDIOC_S_EXT_CTRLS(x)"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:146
#: ../../../userspace-api/media/v4l/buffer.rst:148
msgid "VIDIOC_TRY_FMT()"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:147
msgid "VIDIOC_S_EXT_CTRLS(y)"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:150
msgid ""
"The :c:func:`VIDIOC_CREATE_BUFS` ioctl can then be used to allocate buffers "
"based on the queried sizes (for instance by allocating a set of buffers "
"large enough for all the desired formats and controls, or by allocating "
"separate set of appropriately sized buffers for each use case)."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:158
#: ../../../userspace-api/media/v4l/buffer.rst:164
msgid "struct v4l2_buffer"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:169
#: ../../../userspace-api/media/v4l/buffer.rst:178
#: ../../../userspace-api/media/v4l/buffer.rst:184
#: ../../../userspace-api/media/v4l/buffer.rst:193
#: ../../../userspace-api/media/v4l/buffer.rst:196
#: ../../../userspace-api/media/v4l/buffer.rst:223
#: ../../../userspace-api/media/v4l/buffer.rst:245
#: ../../../userspace-api/media/v4l/buffer.rst:251
#: ../../../userspace-api/media/v4l/buffer.rst:278
#: ../../../userspace-api/media/v4l/buffer.rst:287
#: ../../../userspace-api/media/v4l/buffer.rst:291
#: ../../../userspace-api/media/v4l/buffer.rst:324
#: ../../../userspace-api/media/v4l/buffer.rst:334
#: ../../../userspace-api/media/v4l/buffer.rst:342
#: ../../../userspace-api/media/v4l/buffer.rst:363
#: ../../../userspace-api/media/v4l/buffer.rst:374
#: ../../../userspace-api/media/v4l/buffer.rst:721
#: ../../../userspace-api/media/v4l/buffer.rst:724
msgid "__u32"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:170
msgid "``index``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:171
msgid ""
"Number of the buffer, set by the application except when calling :ref:"
"`VIDIOC_DQBUF <VIDIOC_QBUF>`, then it is set by the driver. This field can "
"range from zero to the number of buffers allocated with the :ref:"
"`VIDIOC_REQBUFS` ioctl (struct :c:type:`v4l2_requestbuffers` ``count``), "
"plus any buffers allocated with :ref:`VIDIOC_CREATE_BUFS` minus one."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:179
#: ../../../userspace-api/media/v4l/buffer.rst:722
msgid "``type``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:180
msgid ""
"Type of the buffer, same as struct :c:type:`v4l2_format` ``type`` or struct :"
"c:type:`v4l2_requestbuffers` ``type``, set by the application. See :c:type:"
"`v4l2_buf_type`"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:185
#: ../../../userspace-api/media/v4l/buffer.rst:325
msgid "``bytesused``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:186
msgid ""
"The number of bytes occupied by the data in the buffer. It depends on the "
"negotiated data format and may change with each buffer for compressed "
"variable size data like JPEG images. Drivers must set this field when "
"``type`` refers to a capture stream, applications when it refers to an "
"output stream. For multiplanar formats this field is ignored and the "
"``planes`` pointer is used instead."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:194
#: ../../../userspace-api/media/v4l/buffer.rst:725
msgid "``flags``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:195
msgid "Flags set by the application or driver, see :ref:`buffer-flags`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:197
msgid "``field``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:198
msgid ""
"Indicates the field order of the image in the buffer, see :c:type:"
"`v4l2_field`. This field is not used when the buffer contains VBI data. "
"Drivers must set it when ``type`` refers to a capture stream, applications "
"when it refers to an output stream."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:202
msgid "struct timeval"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:203
msgid "``timestamp``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:204
msgid ""
"For capture streams this is time when the first data byte was captured, as "
"returned by the :c:func:`clock_gettime()` function for the relevant clock "
"id; see ``V4L2_BUF_FLAG_TIMESTAMP_*`` in :ref:`buffer-flags`. For output "
"streams the driver stores the time at which the last data byte was actually "
"sent out in the ``timestamp`` field. This permits applications to monitor "
"the drift between the video and system clock. For output streams that use "
"``V4L2_BUF_FLAG_TIMESTAMP_COPY`` the application has to fill in the "
"timestamp which will be copied by the driver to the capture stream."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:214
msgid "struct :c:type:`v4l2_timecode`"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:215
msgid "``timecode``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:216
msgid ""
"When the ``V4L2_BUF_FLAG_TIMECODE`` flag is set in ``flags``, this structure "
"contains a frame timecode. In :c:type:`V4L2_FIELD_ALTERNATE <v4l2_field>` "
"mode the top and bottom field contain the same timecode. Timecodes are "
"intended to help video editing and are typically recorded on video tapes, "
"but also embedded in compressed formats like MPEG. This field is independent "
"of the ``timestamp`` and ``sequence`` fields."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:224
msgid "``sequence``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:225
msgid ""
"Set by the driver, counting the frames (not fields!) in sequence. This field "
"is set for both input and output devices."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:227
msgid ":cspan:`2`"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:229
msgid ""
"In :c:type:`V4L2_FIELD_ALTERNATE <v4l2_field>` mode the top and bottom field "
"have the same sequence number. The count starts at zero and includes dropped "
"or repeated frames. A dropped frame was received by an input device but "
"could not be stored due to lack of free buffer space. A repeated frame was "
"displayed again by an output device because the application did not pass new "
"data in time."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:239
msgid ""
"This may count the frames received e.g. over USB, without taking into "
"account the frames dropped by the remote hardware due to limited compression "
"throughput or bus bandwidth. These devices identify by not enumerating any "
"video standards, see :ref:`standard`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:246
msgid "``memory``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:247
msgid ""
"This field must be set by applications and/or drivers in accordance with the "
"selected I/O method. See :c:type:`v4l2_memory`"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:249
#: ../../../userspace-api/media/v4l/buffer.rst:340
msgid "union {"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:250
#: ../../../userspace-api/media/v4l/buffer.rst:341
msgid "``m``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:252
msgid "``offset``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:253
msgid ""
"For the single-planar API and when ``memory`` is ``V4L2_MEMORY_MMAP`` this "
"is the offset of the buffer from the start of the device memory. The value "
"is returned by the driver and apart of serving as parameter to the :c:func:"
"`mmap()` function not useful for applications. See :ref:`mmap` for details"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:259
#: ../../../userspace-api/media/v4l/buffer.rst:349
msgid "unsigned long"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:260
#: ../../../userspace-api/media/v4l/buffer.rst:350
msgid "``userptr``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:261
msgid ""
"For the single-planar API and when ``memory`` is ``V4L2_MEMORY_USERPTR`` "
"this is a pointer to the buffer (casted to unsigned long type) in virtual "
"memory, set by the application. See :ref:`userp` for details."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:265
#: ../../../userspace-api/media/v4l/buffer.rst:313
msgid "struct v4l2_plane"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:266
msgid "``*planes``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:267
msgid ""
"When using the multi-planar API, contains a userspace pointer to an array of "
"struct :c:type:`v4l2_plane`. The size of the array should be put in the "
"``length`` field of this struct :c:type:`v4l2_buffer` structure."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:271
#: ../../../userspace-api/media/v4l/buffer.rst:355
msgid "int"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:272
#: ../../../userspace-api/media/v4l/buffer.rst:356
msgid "``fd``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:273
msgid ""
"For the single-plane API and when ``memory`` is ``V4L2_MEMORY_DMABUF`` this "
"is the file descriptor associated with a DMABUF buffer."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:276
#: ../../../userspace-api/media/v4l/buffer.rst:361
msgid "}"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:279
#: ../../../userspace-api/media/v4l/buffer.rst:335
msgid "``length``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:280
msgid ""
"Size of the buffer (not the payload) in bytes for the single-planar API. "
"This is set by the driver based on the calls to :ref:`VIDIOC_REQBUFS` and/"
"or :ref:`VIDIOC_CREATE_BUFS`. For the multi-planar API the application sets "
"this to the number of elements in the ``planes`` array. The driver will fill "
"in the actual number of valid elements in that array."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:288
msgid "``reserved2``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:289
msgid ""
"A place holder for future extensions. Drivers and applications must set this "
"to 0."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:292
msgid "``request_fd``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:293
msgid ""
"The file descriptor of the request to queue the buffer to. If the flag "
"``V4L2_BUF_FLAG_REQUEST_FD`` is set, then the buffer will be queued to this "
"request. If the flag is not set, then this field will be ignored."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:298
msgid ""
"The ``V4L2_BUF_FLAG_REQUEST_FD`` flag and this field are only used by :ref:"
"`ioctl VIDIOC_QBUF <VIDIOC_QBUF>` and ignored by other ioctls that take a :c:"
"type:`v4l2_buffer` as argument."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:302
msgid ""
"Applications should not set ``V4L2_BUF_FLAG_REQUEST_FD`` for any ioctls "
"other than :ref:`VIDIOC_QBUF <VIDIOC_QBUF>`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:305
msgid ""
"If the device does not support requests, then ``EBADR`` will be returned. If "
"requests are supported but an invalid request file descriptor is given, then "
"``EINVAL`` will be returned."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:326
msgid ""
"The number of bytes occupied by data in the plane (its payload). Drivers "
"must set this field when ``type`` refers to a capture stream, applications "
"when it refers to an output stream."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:332
msgid ""
"Note that the actual image data starts at ``data_offset`` which may not be 0."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:336
msgid ""
"Size in bytes of the plane (not its payload). This is set by the driver "
"based on the calls to :ref:`VIDIOC_REQBUFS` and/or :ref:`VIDIOC_CREATE_BUFS`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:343
msgid "``mem_offset``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:344
msgid ""
"When the memory type in the containing struct :c:type:`v4l2_buffer` is "
"``V4L2_MEMORY_MMAP``, this is the value that should be passed to :c:func:"
"`mmap()`, similar to the ``offset`` field in struct :c:type:`v4l2_buffer`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:351
msgid ""
"When the memory type in the containing struct :c:type:`v4l2_buffer` is "
"``V4L2_MEMORY_USERPTR``, this is a userspace pointer to the memory allocated "
"for this plane by an application."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:357
msgid ""
"When the memory type in the containing struct :c:type:`v4l2_buffer` is "
"``V4L2_MEMORY_DMABUF``, this is a file descriptor associated with a DMABUF "
"buffer, similar to the ``fd`` field in struct :c:type:`v4l2_buffer`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:364
msgid "``data_offset``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:365
msgid ""
"Offset in bytes to video data in the plane. Drivers must set this field when "
"``type`` refers to a capture stream, applications when it refers to an "
"output stream."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:371
msgid ""
"That data_offset is included  in ``bytesused``. So the size of the image in "
"the plane is ``bytesused``-``data_offset`` at offset ``data_offset`` from "
"the start of the plane."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:375
msgid "``reserved[11]``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:376
msgid "Reserved for future use. Should be zeroed by drivers and applications."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:383
msgid "enum v4l2_buf_type"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:394
msgid "``V4L2_BUF_TYPE_VIDEO_CAPTURE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:395
#: ../../../userspace-api/media/v4l/buffer.rst:685
#: ../../../userspace-api/media/v4l/buffer.rst:756
msgid "1"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:396
msgid "Buffer of a single-planar video capture stream, see :ref:`capture`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:398
msgid "``V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:399
msgid "9"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:400
msgid "Buffer of a multi-planar video capture stream, see :ref:`capture`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:402
msgid "``V4L2_BUF_TYPE_VIDEO_OUTPUT``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:403
#: ../../../userspace-api/media/v4l/buffer.rst:688
#: ../../../userspace-api/media/v4l/buffer.rst:759
msgid "2"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:404
msgid "Buffer of a single-planar video output stream, see :ref:`output`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:406
msgid "``V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:407
msgid "10"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:408
msgid "Buffer of a multi-planar video output stream, see :ref:`output`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:409
msgid "``V4L2_BUF_TYPE_VIDEO_OVERLAY``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:410
#: ../../../userspace-api/media/v4l/buffer.rst:691
#: ../../../userspace-api/media/v4l/buffer.rst:762
msgid "3"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:411
msgid "Buffer for video overlay, see :ref:`overlay`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:412
msgid "``V4L2_BUF_TYPE_VBI_CAPTURE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:413
#: ../../../userspace-api/media/v4l/buffer.rst:694
#: ../../../userspace-api/media/v4l/buffer.rst:765
msgid "4"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:414
msgid "Buffer of a raw VBI capture stream, see :ref:`raw-vbi`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:415
msgid "``V4L2_BUF_TYPE_VBI_OUTPUT``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:416
#: ../../../userspace-api/media/v4l/buffer.rst:768
msgid "5"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:417
msgid "Buffer of a raw VBI output stream, see :ref:`raw-vbi`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:418
msgid "``V4L2_BUF_TYPE_SLICED_VBI_CAPTURE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:419
msgid "6"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:420
msgid "Buffer of a sliced VBI capture stream, see :ref:`sliced`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:421
msgid "``V4L2_BUF_TYPE_SLICED_VBI_OUTPUT``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:422
msgid "7"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:423
msgid "Buffer of a sliced VBI output stream, see :ref:`sliced`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:424
msgid "``V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:425
msgid "8"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:426
msgid "Buffer for video output overlay (OSD), see :ref:`osd`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:427
msgid "``V4L2_BUF_TYPE_SDR_CAPTURE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:428
msgid "11"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:429
msgid "Buffer for Software Defined Radio (SDR) capture stream, see :ref:`sdr`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:431
msgid "``V4L2_BUF_TYPE_SDR_OUTPUT``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:432
msgid "12"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:433
msgid "Buffer for Software Defined Radio (SDR) output stream, see :ref:`sdr`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:435
msgid "``V4L2_BUF_TYPE_META_CAPTURE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:436
msgid "13"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:437
msgid "Buffer for metadata capture, see :ref:`metadata`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:438
msgid "``V4L2_BUF_TYPE_META_OUTPUT``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:439
msgid "14"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:440
msgid "Buffer for metadata output, see :ref:`metadata`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:446
msgid "Buffer Flags"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:448
msgid "\\footnotesize"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:463
msgid "``V4L2_BUF_FLAG_MAPPED``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:464
msgid "0x00000001"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:465
msgid ""
"The buffer resides in device memory and has been mapped into the "
"application's address space, see :ref:`mmap` for details. Drivers set or "
"clear this flag when the :ref:`VIDIOC_QUERYBUF`, :ref:`VIDIOC_QBUF` or :ref:"
"`VIDIOC_DQBUF <VIDIOC_QBUF>` ioctl is called. Set by the driver."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:474
msgid "``V4L2_BUF_FLAG_QUEUED``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:475
msgid "0x00000002"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:476
msgid ""
"Internally drivers maintain two buffer queues, an incoming and outgoing "
"queue. When this flag is set, the buffer is currently on the incoming queue. "
"It automatically moves to the outgoing queue after the buffer has been "
"filled (capture devices) or displayed (output devices). Drivers set or clear "
"this flag when the ``VIDIOC_QUERYBUF`` ioctl is called. After (successful) "
"calling the ``VIDIOC_QBUF``\\ ioctl it is always set and after "
"``VIDIOC_DQBUF`` always cleared."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:486
msgid "``V4L2_BUF_FLAG_DONE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:487
msgid "0x00000004"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:488
msgid ""
"When this flag is set, the buffer is currently on the outgoing queue, ready "
"to be dequeued from the driver. Drivers set or clear this flag when the "
"``VIDIOC_QUERYBUF`` ioctl is called. After calling the ``VIDIOC_QBUF`` or "
"``VIDIOC_DQBUF`` it is always cleared. Of course a buffer cannot be on both "
"queues at the same time, the ``V4L2_BUF_FLAG_QUEUED`` and "
"``V4L2_BUF_FLAG_DONE`` flag are mutually exclusive. They can be both cleared "
"however, then the buffer is in \"dequeued\" state, in the application domain "
"so to say."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:499
msgid "``V4L2_BUF_FLAG_ERROR``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:500
msgid "0x00000040"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:501
msgid ""
"When this flag is set, the buffer has been dequeued successfully, although "
"the data might have been corrupted. This is recoverable, streaming may "
"continue as normal and the buffer may be reused normally. Drivers set this "
"flag when the ``VIDIOC_DQBUF`` ioctl is called."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:508
msgid "``V4L2_BUF_FLAG_IN_REQUEST``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:509
msgid "0x00000080"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:510
msgid "This buffer is part of a request that hasn't been queued yet."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:513
msgid "``V4L2_BUF_FLAG_KEYFRAME``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:514
msgid "0x00000008"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:515
msgid ""
"Drivers set or clear this flag when calling the ``VIDIOC_DQBUF`` ioctl. It "
"may be set by video capture devices when the buffer contains a compressed "
"image which is a key frame (or field), i. e. can be decompressed on its own. "
"Also known as an I-frame. Applications can set this bit when ``type`` refers "
"to an output stream."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:523
msgid "``V4L2_BUF_FLAG_PFRAME``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:524
msgid "0x00000010"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:525
msgid ""
"Similar to ``V4L2_BUF_FLAG_KEYFRAME`` this flags predicted frames or fields "
"which contain only differences to a previous key frame. Applications can set "
"this bit when ``type`` refers to an output stream."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:531
msgid "``V4L2_BUF_FLAG_BFRAME``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:532
msgid "0x00000020"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:533
msgid ""
"Similar to ``V4L2_BUF_FLAG_KEYFRAME`` this flags a bi-directional predicted "
"frame or field which contains only the differences between the current frame "
"and both the preceding and following key frames to specify its content. "
"Applications can set this bit when ``type`` refers to an output stream."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:540
msgid "``V4L2_BUF_FLAG_TIMECODE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:541
msgid "0x00000100"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:542
msgid ""
"The ``timecode`` field is valid. Drivers set or clear this flag when the "
"``VIDIOC_DQBUF`` ioctl is called. Applications can set this bit and the "
"corresponding ``timecode`` structure when ``type`` refers to an output "
"stream."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:548
msgid "``V4L2_BUF_FLAG_PREPARED``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:549
msgid "0x00000400"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:550
msgid ""
"The buffer has been prepared for I/O and can be queued by the application. "
"Drivers set or clear this flag when the :ref:`VIDIOC_QUERYBUF "
"<VIDIOC_QUERYBUF>`, :ref:`VIDIOC_PREPARE_BUF <VIDIOC_QBUF>`, :ref:"
"`VIDIOC_QBUF <VIDIOC_QBUF>` or :ref:`VIDIOC_DQBUF <VIDIOC_QBUF>` ioctl is "
"called."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:558
msgid "``V4L2_BUF_FLAG_NO_CACHE_INVALIDATE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:559
msgid "0x00000800"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:560
msgid ""
"Caches do not have to be invalidated for this buffer. Typically applications "
"shall use this flag if the data captured in the buffer is not going to be "
"touched by the CPU, instead the buffer will, probably, be passed on to a DMA-"
"capable hardware unit for further processing or output. This flag is ignored "
"unless the queue is used for :ref:`memory mapping <mmap>` streaming I/O and "
"reports :ref:`V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS <V4L2-BUF-CAP-SUPPORTS-"
"MMAP-CACHE-HINTS>` capability."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:570
msgid "``V4L2_BUF_FLAG_NO_CACHE_CLEAN``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:571
msgid "0x00001000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:572
msgid ""
"Caches do not have to be cleaned for this buffer. Typically applications "
"shall use this flag for output buffers if the data in this buffer has not "
"been created by the CPU but by some DMA-capable unit, in which case caches "
"have not been used. This flag is ignored unless the queue is used for :ref:"
"`memory mapping <mmap>` streaming I/O and reports :ref:"
"`V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS <V4L2-BUF-CAP-SUPPORTS-MMAP-CACHE-"
"HINTS>` capability."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:581
msgid "``V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:582
msgid "0x00000200"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:583
msgid ""
"Only valid if struct :c:type:`v4l2_requestbuffers` flag "
"``V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF`` is set. It is typically used "
"with stateless decoders where multiple output buffers each decode to a slice "
"of the decoded frame. Applications can set this flag when queueing the "
"output buffer to prevent the driver from dequeueing the capture buffer after "
"the output buffer has been decoded (i.e. the capture buffer is 'held'). If "
"the timestamp of this output buffer differs from that of the previous output "
"buffer, then that indicates the start of a new frame and the previously held "
"capture buffer is dequeued."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:594
msgid "``V4L2_BUF_FLAG_LAST``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:595
msgid "0x00100000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:596
msgid ""
"Last buffer produced by the hardware. mem2mem codec drivers set this flag on "
"the capture queue for the last buffer when the :ref:`VIDIOC_QUERYBUF` or :"
"ref:`VIDIOC_DQBUF <VIDIOC_QBUF>` ioctl is called. Due to hardware "
"limitations, the last buffer may be empty. In this case the driver will set "
"the ``bytesused`` field to 0, regardless of the format. Any subsequent call "
"to the :ref:`VIDIOC_DQBUF <VIDIOC_QBUF>` ioctl will not block anymore, but "
"return an ``EPIPE`` error code."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:607
msgid "``V4L2_BUF_FLAG_REQUEST_FD``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:608
msgid "0x00800000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:609
msgid "The ``request_fd`` field contains a valid file descriptor."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:612
msgid "``V4L2_BUF_FLAG_TIMESTAMP_MASK``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:613
msgid "0x0000e000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:614
msgid ""
"Mask for timestamp types below. To test the timestamp type, mask out bits "
"not belonging to timestamp type by performing a logical and operation with "
"buffer flags and timestamp mask."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:619
msgid "``V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:620
#: ../../../userspace-api/media/v4l/buffer.rst:655
msgid "0x00000000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:621
msgid ""
"Unknown timestamp type. This type is used by drivers before Linux 3.9 and "
"may be either monotonic (see below) or realtime (wall clock). Monotonic "
"clock has been favoured in embedded systems whereas most of the drivers use "
"the realtime clock. Either kinds of timestamps are available in user space "
"via :c:func:`clock_gettime` using clock IDs ``CLOCK_MONOTONIC`` and "
"``CLOCK_REALTIME``, respectively."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:630
msgid "``V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:631
msgid "0x00002000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:632
msgid ""
"The buffer timestamp has been taken from the ``CLOCK_MONOTONIC`` clock. To "
"access the same clock outside V4L2, use :c:func:`clock_gettime`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:637
msgid "``V4L2_BUF_FLAG_TIMESTAMP_COPY``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:638
msgid "0x00004000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:639
msgid ""
"The CAPTURE buffer timestamp has been taken from the corresponding OUTPUT "
"buffer. This flag applies only to mem2mem devices."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:643
msgid "``V4L2_BUF_FLAG_TSTAMP_SRC_MASK``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:644
msgid "0x00070000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:645
msgid ""
"Mask for timestamp sources below. The timestamp source defines the point of "
"time the timestamp is taken in relation to the frame. Logical 'and' "
"operation between the ``flags`` field and ``V4L2_BUF_FLAG_TSTAMP_SRC_MASK`` "
"produces the value of the timestamp source. Applications must set the "
"timestamp source when ``type`` refers to an output stream and "
"``V4L2_BUF_FLAG_TIMESTAMP_COPY`` is set."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:654
msgid "``V4L2_BUF_FLAG_TSTAMP_SRC_EOF``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:656
msgid ""
"End Of Frame. The buffer timestamp has been taken when the last pixel of the "
"frame has been received or the last pixel of the frame has been transmitted. "
"In practice, software generated timestamps will typically be read from the "
"clock a small amount of time after the last pixel has been received or "
"transmitten, depending on the system and other activity in it."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:664
msgid "``V4L2_BUF_FLAG_TSTAMP_SRC_SOE``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:665
msgid "0x00010000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:666
msgid ""
"Start Of Exposure. The buffer timestamp has been taken when the exposure of "
"the frame has begun. This is only valid for the "
"``V4L2_BUF_TYPE_VIDEO_CAPTURE`` buffer type."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:670
#: ../../../userspace-api/media/v4l/buffer.rst:697
msgid "\\normalsize"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:675
msgid "enum v4l2_memory"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:684
msgid "``V4L2_MEMORY_MMAP``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:686
msgid "The buffer is used for :ref:`memory mapping <mmap>` I/O."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:687
msgid "``V4L2_MEMORY_USERPTR``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:689
msgid "The buffer is used for :ref:`user pointer <userp>` I/O."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:690
msgid "``V4L2_MEMORY_OVERLAY``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:692
msgid "[to do]"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:693
msgid "``V4L2_MEMORY_DMABUF``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:695
msgid "The buffer is used for :ref:`DMA shared buffer <dmabuf>` I/O."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:702
msgid "Timecodes"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:704
msgid ""
"The :c:type:`v4l2_buffer_timecode` structure is designed to hold a :ref:"
"`smpte12m` or similar timecode. (struct :c:type:`timeval` timestamps are "
"stored in the struct :c:type:`v4l2_buffer` ``timestamp`` field.)"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:712
msgid "struct v4l2_timecode"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:723
msgid "Frame rate the timecodes are based on, see :ref:`timecode-type`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:726
msgid "Timecode flags, see :ref:`timecode-flags`."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:727
#: ../../../userspace-api/media/v4l/buffer.rst:731
#: ../../../userspace-api/media/v4l/buffer.rst:734
#: ../../../userspace-api/media/v4l/buffer.rst:737
#: ../../../userspace-api/media/v4l/buffer.rst:740
msgid "__u8"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:728
msgid "``frames``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:729
msgid "Frame count, 0 ... 23/24/29/49/59, depending on the type of timecode."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:732
msgid "``seconds``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:733
msgid "Seconds count, 0 ... 59. This is a binary, not BCD number."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:735
msgid "``minutes``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:736
msgid "Minutes count, 0 ... 59. This is a binary, not BCD number."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:738
msgid "``hours``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:739
msgid "Hours count, 0 ... 29. This is a binary, not BCD number."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:741
msgid "``userbits``\\ [4]"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:742
msgid "The \"user group\" bits from the timecode."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:748
msgid "Timecode Types"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:755
msgid "``V4L2_TC_TYPE_24FPS``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:757
msgid "24 frames per second, i. e. film."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:758
msgid "``V4L2_TC_TYPE_25FPS``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:760
msgid "25 frames per second, i. e. PAL or SECAM video."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:761
msgid "``V4L2_TC_TYPE_30FPS``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:763
msgid "30 frames per second, i. e. NTSC video."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:764
msgid "``V4L2_TC_TYPE_50FPS``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:767
msgid "``V4L2_TC_TYPE_60FPS``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:775
msgid "Timecode Flags"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:784
msgid "``V4L2_TC_FLAG_DROPFRAME``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:785
msgid "0x0001"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:786
msgid ""
"Indicates \"drop frame\" semantics for counting frames in 29.97 fps "
"material. When set, frame numbers 0 and 1 at the start of each minute, "
"except minutes 0, 10, 20, 30, 40, 50 are omitted from the count."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:790
msgid "``V4L2_TC_FLAG_COLORFRAME``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:791
msgid "0x0002"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:792
msgid "The \"color frame\" flag."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:793
msgid "``V4L2_TC_USERBITS_field``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:794
msgid "0x000C"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:795
msgid "Field mask for the \"binary group flags\"."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:796
msgid "``V4L2_TC_USERBITS_USERDEFINED``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:797
msgid "0x0000"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:798
msgid "Unspecified format."
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:799
msgid "``V4L2_TC_USERBITS_8BITCHARS``"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:800
msgid "0x0008"
msgstr ""

#: ../../../userspace-api/media/v4l/buffer.rst:801
msgid "8-bit ISO characters."
msgstr ""
