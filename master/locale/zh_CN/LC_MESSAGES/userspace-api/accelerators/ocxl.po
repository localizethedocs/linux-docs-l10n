# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/accelerators/ocxl.rst:3
msgid "OpenCAPI (Open Coherent Accelerator Processor Interface)"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:5
msgid ""
"OpenCAPI is an interface between processors and accelerators. It aims at "
"being low-latency and high-bandwidth."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:8
msgid ""
"The specification was developed by the OpenCAPI Consortium, and is now "
"available from the `Compute Express Link Consortium <https://"
"computeexpresslink.org/resource/opencapi-specification-archive/>`_."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:12
msgid ""
"It allows an accelerator (which could be an FPGA, ASICs, ...) to access the "
"host memory coherently, using virtual addresses. An OpenCAPI device can also "
"host its own memory, that can be accessed from the host."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:17
msgid ""
"OpenCAPI is known in linux as 'ocxl', as the open, processor-agnostic "
"evolution of 'cxl' (the driver for the IBM CAPI interface for powerpc), "
"which was named that way to avoid confusion with the ISDN CAPI subsystem."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:24
msgid "High-level view"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:26
msgid ""
"OpenCAPI defines a Data Link Layer (DL) and Transaction Layer (TL), to be "
"implemented on top of a physical link. Any processor or device implementing "
"the DL and TL can start sharing memory."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:55
msgid "Device discovery"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:57
msgid ""
"OpenCAPI relies on a PCI-like configuration space, implemented on the "
"device. So the host can discover AFUs by querying the config space."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:60
msgid ""
"OpenCAPI devices in Linux are treated like PCI devices (with a few caveats). "
"The firmware is expected to abstract the hardware as if it was a PCI link. A "
"lot of the existing PCI infrastructure is reused: devices are scanned and "
"BARs are assigned during the standard PCI enumeration. Commands like 'lspci' "
"can therefore be used to see what devices are available."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:67
msgid ""
"The configuration space defines the AFU(s) that can be found on the physical "
"adapter, such as its name, how many memory contexts it can work with, the "
"size of its MMIO areas, ..."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:74
msgid "MMIO"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:76
msgid "OpenCAPI defines two MMIO areas for each AFU:"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:78
msgid "the global MMIO area, with registers pertinent to the whole AFU."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:79
msgid "a per-process MMIO area, which has a fixed size for each context."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:84
msgid "AFU interrupts"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:86
msgid ""
"OpenCAPI includes the possibility for an AFU to send an interrupt to a host "
"process. It is done through a 'intrp_req' defined in the Transaction Layer, "
"specifying a 64-bit object handle which defines the interrupt."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:91
msgid ""
"The driver allows a process to allocate an interrupt and obtain its 64-bit "
"object handle, that can be passed to the AFU."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:97
msgid "char devices"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:99
msgid ""
"The driver creates one char device per AFU found on the physical device. A "
"physical device may have multiple functions and each function can have "
"multiple AFUs. At the time of this writing though, it has only been tested "
"with devices exporting only one AFU."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:104
msgid ""
"Char devices can be found in /dev/ocxl/ and are named as: /dev/ocxl/<AFU "
"name>.<location>.<index>"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:107
msgid ""
"where <AFU name> is a max 20-character long name, as found in the config "
"space of the AFU. <location> is added by the driver and can help distinguish "
"devices when a system has more than one instance of the same OpenCAPI "
"device. <index> is also to help distinguish AFUs in the unlikely case where "
"a device carries multiple copies of the same AFU."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:117
msgid "Sysfs class"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:119
msgid ""
"An ocxl class is added for the devices representing the AFUs. See /sys/class/"
"ocxl. The layout is described in Documentation/ABI/testing/sysfs-class-ocxl"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:126
msgid "User API"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:129
msgid "open"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:131
msgid ""
"Based on the AFU definition found in the config space, an AFU may support "
"working with more than one memory context, in which case the associated char "
"device may be opened multiple times by different processes."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:138
msgid "ioctl"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:140
msgid "OCXL_IOCTL_ATTACH:"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:142
msgid ""
"Attach the memory context of the calling process to the AFU so that the AFU "
"can access its memory."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:145
msgid "OCXL_IOCTL_IRQ_ALLOC:"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:147
msgid "Allocate an AFU interrupt and return an identifier."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:149
msgid "OCXL_IOCTL_IRQ_FREE:"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:151
msgid "Free a previously allocated AFU interrupt."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:153
msgid "OCXL_IOCTL_IRQ_SET_FD:"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:155
msgid ""
"Associate an event fd to an AFU interrupt so that the user process can be "
"notified when the AFU sends an interrupt."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:158
msgid "OCXL_IOCTL_GET_METADATA:"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:160
msgid ""
"Obtains configuration information from the card, such at the size of MMIO "
"areas, the AFU version, and the PASID for the current context."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:163
msgid "OCXL_IOCTL_ENABLE_P9_WAIT:"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:165
msgid ""
"Allows the AFU to wake a userspace thread executing 'wait'. Returns "
"information to userspace to allow it to configure the AFU. Note that this is "
"only available on POWER9."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:169
msgid "OCXL_IOCTL_GET_FEATURES:"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:171
msgid ""
"Reports on which CPU features that affect OpenCAPI are usable from userspace."
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:176
msgid "mmap"
msgstr ""

#: ../../../userspace-api/accelerators/ocxl.rst:178
msgid ""
"A process can mmap the per-process MMIO area for interactions with the AFU."
msgstr ""
