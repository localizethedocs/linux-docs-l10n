# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/mfd_noexec.rst:5
msgid "Introduction of non-executable mfd"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:0
msgid "Author"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:7
msgid "Daniel Verkamp <dverkamp@chromium.org> Jeff Xu <jeffxu@chromium.org>"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:0
msgid "Contributor"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:11
msgid "Aleksa Sarai <cyphar@cyphar.com>"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:13
msgid ""
"Since Linux introduced the memfd feature, memfds have always had their "
"execute bit set, and the memfd_create() syscall doesn't allow setting it "
"differently."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:17
msgid ""
"However, in a secure-by-default system, such as ChromeOS, (where all "
"executables should come from the rootfs, which is protected by verified "
"boot), this executable nature of memfd opens a door for NoExec bypass and "
"enables “confused deputy attack”.  E.g, in VRP bug [1]: cros_vm process "
"created a memfd to share the content with an external process, however the "
"memfd is overwritten and used for executing arbitrary code and root "
"escalation. [2] lists more VRP of this kind."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:25
msgid ""
"On the other hand, executable memfd has its legit use: runc uses memfd’s "
"seal and executable feature to copy the contents of the binary then execute "
"them. For such a system, we need a solution to differentiate runc's use of "
"executable memfds and an attacker's [3]."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:30
msgid "To address those above:"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:31
msgid "Let memfd_create() set X bit at creation time."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:32
msgid "Let memfd be sealed for modifying X bit when NX is set."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:33
msgid ""
"Add a new pid namespace sysctl: vm.memfd_noexec to help applications in "
"migrating and enforcing non-executable MFD."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:37
msgid "User API"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:38
msgid "``int memfd_create(const char *name, unsigned int flags)``"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:40
msgid "``MFD_NOEXEC_SEAL``"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:41
msgid ""
"When MFD_NOEXEC_SEAL bit is set in the ``flags``, memfd is created with NX. "
"F_SEAL_EXEC is set and the memfd can't be modified to add X later. "
"MFD_ALLOW_SEALING is also implied. This is the most common case for the "
"application to use memfd."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:46
msgid "``MFD_EXEC``"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:47
msgid "When MFD_EXEC bit is set in the ``flags``, memfd is created with X."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:49
msgid "Note:"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:50
msgid ""
"``MFD_NOEXEC_SEAL`` implies ``MFD_ALLOW_SEALING``. In case that an app "
"doesn't want sealing, it can add F_SEAL_SEAL after creation."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:55
msgid "Sysctl:"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:56
msgid "``pid namespaced sysctl vm.memfd_noexec``"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:58
msgid "The new pid namespaced sysctl vm.memfd_noexec has 3 values:"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:60
msgid "0: MEMFD_NOEXEC_SCOPE_EXEC"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:61
msgid ""
"memfd_create() without MFD_EXEC nor MFD_NOEXEC_SEAL acts like MFD_EXEC was "
"set."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:64
msgid "1: MEMFD_NOEXEC_SCOPE_NOEXEC_SEAL"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:65
msgid ""
"memfd_create() without MFD_EXEC nor MFD_NOEXEC_SEAL acts like "
"MFD_NOEXEC_SEAL was set."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:68
msgid "2: MEMFD_NOEXEC_SCOPE_NOEXEC_ENFORCED"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:69
msgid "memfd_create() without MFD_NOEXEC_SEAL will be rejected."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:71
msgid ""
"The sysctl allows finer control of memfd_create for old software that "
"doesn't set the executable bit; for example, a container with vm."
"memfd_noexec=1 means the old software will create non-executable memfd by "
"default while new software can create executable memfd by setting MFD_EXEC."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:77
msgid ""
"The value of vm.memfd_noexec is passed to child namespace at creation time. "
"In addition, the setting is hierarchical, i.e. during memfd_create, we will "
"search from current ns to root ns and use the most restrictive setting."
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:82
msgid "[1] https://crbug.com/1305267"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:84
msgid ""
"[2] https://bugs.chromium.org/p/chromium/issues/list?q=type%3Dbug-"
"security%20memfd%20escalation&can=1"
msgstr ""

#: ../../../userspace-api/mfd_noexec.rst:86
msgid "[3] https://lwn.net/Articles/781013/"
msgstr ""
