# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usb/authorization.rst:3
msgid "Authorizing (or not) your USB devices to connect to the system"
msgstr ""

#: ../../../usb/authorization.rst:5
msgid ""
"Copyright (C) 2007 Inaky Perez-Gonzalez <inaky@linux.intel.com> Intel "
"Corporation"
msgstr ""

#: ../../../usb/authorization.rst:7
msgid ""
"This feature allows you to control if a USB device can be used (or not) in a "
"system. This feature will allow you to implement a lock-down of USB devices, "
"fully controlled by user space."
msgstr ""

#: ../../../usb/authorization.rst:11
msgid ""
"As of now, when a USB device is connected it is configured and its "
"interfaces are immediately made available to the users.  With this "
"modification, only if root authorizes the device to be configured will then "
"it be possible to use it."
msgstr ""

#: ../../../usb/authorization.rst:17
msgid "Usage"
msgstr ""

#: ../../../usb/authorization.rst:19
msgid "Authorize a device to connect::"
msgstr ""

#: ../../../usb/authorization.rst:23
msgid "De-authorize a device::"
msgstr ""

#: ../../../usb/authorization.rst:27
msgid ""
"Set new devices connected to hostX to be deauthorized by default (ie: lock "
"down)::"
msgstr ""

#: ../../../usb/authorization.rst:32
msgid "Remove the lock down::"
msgstr ""

#: ../../../usb/authorization.rst:36
msgid ""
"By default, all USB devices are authorized.  Writing \"2\" to the "
"authorized_default attribute causes the kernel to authorize by default only "
"devices connected to internal USB ports."
msgstr ""

#: ../../../usb/authorization.rst:42
msgid "Example system lockdown (lame)"
msgstr ""

#: ../../../usb/authorization.rst:44
msgid ""
"Imagine you want to implement a lockdown so only devices of type XYZ can be "
"connected (for example, it is a kiosk machine with a visible USB port)::"
msgstr ""

#: ../../../usb/authorization.rst:56
msgid "Hookup an script to udev, for new USB devices::"
msgstr ""

#: ../../../usb/authorization.rst:64
msgid ""
"Now, device_is_my_type() is where the juice for a lockdown is. Just checking "
"if the class, type and protocol match something is the worse security "
"verification you can make (or the best, for someone willing to break it). If "
"you need something secure, use crypto and Certificate Authentication or "
"stuff like that. Something simple for an storage key could be::"
msgstr ""

#: ../../../usb/authorization.rst:88
msgid ""
"Of course, this is lame, you'd want to do a real certificate verification "
"stuff with PKI, so you don't depend on a shared secret, etc, but you get the "
"idea. Anybody with access to a device gadget kit can fake descriptors and "
"device info. Don't trust that. You are welcome."
msgstr ""

#: ../../../usb/authorization.rst:96
msgid "Interface authorization"
msgstr ""

#: ../../../usb/authorization.rst:98
msgid ""
"There is a similar approach to allow or deny specific USB interfaces. That "
"allows to block only a subset of an USB device."
msgstr ""

#: ../../../usb/authorization.rst:101
msgid "Authorize an interface::"
msgstr ""

#: ../../../usb/authorization.rst:105
msgid "Deauthorize an interface::"
msgstr ""

#: ../../../usb/authorization.rst:109
msgid ""
"The default value for new interfaces on a particular USB bus can be changed, "
"too."
msgstr ""

#: ../../../usb/authorization.rst:112
msgid "Allow interfaces per default::"
msgstr ""

#: ../../../usb/authorization.rst:116
msgid "Deny interfaces per default::"
msgstr ""

#: ../../../usb/authorization.rst:120
msgid ""
"Per default the interface_authorized_default bit is 1. So all interfaces "
"would authorized per default."
msgstr ""

#: ../../../usb/authorization.rst:123
msgid "Note:"
msgstr ""

#: ../../../usb/authorization.rst:124
msgid ""
"If a deauthorized interface will be authorized so the driver probing must be "
"triggered manually by writing INTERFACE to /sys/bus/usb/drivers_probe"
msgstr ""

#: ../../../usb/authorization.rst:127
msgid ""
"For drivers that need multiple interfaces all needed interfaces should be "
"authorized first. After that the drivers should be probed. This avoids side "
"effects."
msgstr ""
