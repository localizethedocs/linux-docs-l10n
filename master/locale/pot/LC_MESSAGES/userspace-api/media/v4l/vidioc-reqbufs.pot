# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:8
msgid "ioctl VIDIOC_REQBUFS"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:11
msgid "Name"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:13
msgid ""
"VIDIOC_REQBUFS - Initiate Memory Mapping, User Pointer I/O or DMA buffer I/O"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:16
msgid "Synopsis"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:20
msgid "``int ioctl(int fd, VIDIOC_REQBUFS, struct v4l2_requestbuffers *argp)``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:23
msgid "Arguments"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:25
msgid "``fd``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:26
msgid "File descriptor returned by :c:func:`open()`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:28
msgid "``argp``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:29
msgid "Pointer to struct :c:type:`v4l2_requestbuffers`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:32
msgid "Description"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:34
msgid ""
"This ioctl is used to initiate :ref:`memory mapped <mmap>`, :ref:`user "
"pointer <userp>` or :ref:`DMABUF <dmabuf>` based I/O. Memory mapped buffers "
"are located in device memory and must be allocated with this ioctl before "
"they can be mapped into the application's address space. User buffers are "
"allocated by applications themselves, and this ioctl is merely used to "
"switch the driver into user pointer I/O mode and to setup some internal "
"structures. Similarly, DMABUF buffers are allocated by applications through "
"a device driver, and this ioctl only configures the driver into DMABUF I/O "
"mode without performing any direct allocation."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:45
msgid ""
"To allocate device buffers applications initialize all fields of the struct :"
"c:type:`v4l2_requestbuffers` structure. They set the ``type`` field to the "
"respective stream or buffer type, the ``count`` field to the desired number "
"of buffers, ``memory`` must be set to the requested I/O method and the "
"``reserved`` array must be zeroed. When the ioctl is called with a pointer "
"to this structure the driver will attempt to allocate the requested number "
"of buffers and it stores the actual number allocated in the ``count`` field. "
"It can be smaller than the number requested, even zero, when the driver runs "
"out of free memory. A larger number is also possible when the driver "
"requires more buffers to function correctly. For example video output "
"requires at least two buffers, one displayed and one filled by the "
"application."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:58
msgid ""
"When the I/O method is not supported the ioctl returns an ``EINVAL`` error "
"code."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:61
msgid ""
"Applications can call :ref:`VIDIOC_REQBUFS` again to change the number of "
"buffers. Note that if any buffers are still mapped or exported via DMABUF, "
"then :ref:`VIDIOC_REQBUFS` can only succeed if the "
"``V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS`` capability is set. Otherwise :ref:"
"`VIDIOC_REQBUFS` will return the ``EBUSY`` error code. If "
"``V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS`` is set, then these buffers are "
"orphaned and will be freed when they are unmapped or when the exported "
"DMABUF fds are closed. A ``count`` value of zero frees or orphans all "
"buffers, after aborting or finishing any DMA in progress, an implicit :ref:"
"`VIDIOC_STREAMOFF <VIDIOC_STREAMON>`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:78
msgid "struct v4l2_requestbuffers"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:83
#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:86
#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:91
#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:96
msgid "__u32"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:84
msgid "``count``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:85
msgid "The number of buffers requested or granted."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:87
msgid "``type``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:88
msgid ""
"Type of the stream or buffers, this is the same as the struct :c:type:"
"`v4l2_format` ``type`` field. See :c:type:`v4l2_buf_type` for valid values."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:92
msgid "``memory``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:93
msgid ""
"Applications set this field to ``V4L2_MEMORY_MMAP``, ``V4L2_MEMORY_DMABUF`` "
"or ``V4L2_MEMORY_USERPTR``. See :c:type:`v4l2_memory`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:97
msgid "``capabilities``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:98
msgid ""
"Set by the driver. If 0, then the driver doesn't support capabilities. In "
"that case all you know is that the driver is guaranteed to support "
"``V4L2_MEMORY_MMAP`` and *might* support other :c:type:`v4l2_memory` types. "
"It will not support any other capabilities."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:104
msgid ""
"If you want to query the capabilities with a minimum of side-effects, then "
"this can be called with ``count`` set to 0, ``memory`` set to "
"``V4L2_MEMORY_MMAP`` and ``type`` set to the buffer type. This will free any "
"previously allocated buffers, so this is typically something that will be "
"done at the start of the application."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:109
#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:113
msgid "__u8"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:110
msgid "``flags``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:111
msgid ""
"Specifies additional buffer management attributes. See :ref:`memory-flags`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:114
msgid "``reserved``\\ [3]"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:115
msgid "Reserved for future extensions."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:128
msgid "V4L2 Buffer Capabilities Flags"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:133
msgid "``V4L2_BUF_CAP_SUPPORTS_MMAP``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:134
#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:180
msgid "0x00000001"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:135
msgid "This buffer type supports the ``V4L2_MEMORY_MMAP`` streaming mode."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:136
msgid "``V4L2_BUF_CAP_SUPPORTS_USERPTR``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:137
msgid "0x00000002"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:138
msgid "This buffer type supports the ``V4L2_MEMORY_USERPTR`` streaming mode."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:139
msgid "``V4L2_BUF_CAP_SUPPORTS_DMABUF``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:140
msgid "0x00000004"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:141
msgid "This buffer type supports the ``V4L2_MEMORY_DMABUF`` streaming mode."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:142
msgid "``V4L2_BUF_CAP_SUPPORTS_REQUESTS``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:143
msgid "0x00000008"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:144
msgid "This buffer type supports :ref:`requests <media-request-api>`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:145
msgid "``V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:146
msgid "0x00000010"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:147
msgid ""
"The kernel allows calling :ref:`VIDIOC_REQBUFS` while buffers are still "
"mapped or exported via DMABUF. These orphaned buffers will be freed when "
"they are unmapped or when the exported DMABUF fds are closed."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:150
msgid "``V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:151
msgid "0x00000020"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:152
msgid ""
"Only valid for stateless decoders. If set, then userspace can set the "
"``V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF`` flag to hold off on returning the "
"capture buffer until the OUTPUT timestamp changes."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:155
msgid "``V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:156
msgid "0x00000040"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:157
msgid ""
"This capability is set by the driver to indicate that the queue supports "
"cache and memory management hints. However, it's only valid when the queue "
"is used for :ref:`memory mapping <mmap>` streaming I/O. See :ref:"
"`V4L2_BUF_FLAG_NO_CACHE_INVALIDATE <V4L2-BUF-FLAG-NO-CACHE-INVALIDATE>`, :"
"ref:`V4L2_BUF_FLAG_NO_CACHE_CLEAN <V4L2-BUF-FLAG-NO-CACHE-CLEAN>` and :ref:"
"`V4L2_MEMORY_FLAG_NON_COHERENT <V4L2-MEMORY-FLAG-NON-COHERENT>`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:163
msgid "``V4L2_BUF_CAP_SUPPORTS_MAX_NUM_BUFFERS``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:164
msgid "0x00000080"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:165
msgid ""
"If set, then the ``max_num_buffers`` field in ``struct v4l2_create_buffers`` "
"is valid. If not set, then the maximum is ``VIDEO_MAX_FRAME`` buffers."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:167
msgid "``V4L2_BUF_CAP_SUPPORTS_REMOVE_BUFS``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:168
msgid "0x00000100"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:169
msgid "If set, then ``VIDIOC_REMOVE_BUFS`` is supported."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:174
msgid "Memory Consistency Flags"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:179
msgid "``V4L2_MEMORY_FLAG_NON_COHERENT``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:181
msgid ""
"A buffer is allocated either in coherent (it will be automatically coherent "
"between the CPU and the bus) or non-coherent memory. The latter can provide "
"performance gains, for instance the CPU cache sync/flush operations can be "
"avoided if the buffer is accessed by the corresponding device only and the "
"CPU does not read/write to/from that buffer. However, this requires extra "
"care from the driver -- it must guarantee memory consistency by issuing a "
"cache flush/sync when consistency is needed. If this flag is set V4L2 will "
"attempt to allocate the buffer in non-coherent memory. The flag takes effect "
"only if the buffer is used for :ref:`memory mapping <mmap>` I/O and the "
"queue reports the :ref:`V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS <V4L2-BUF-CAP-"
"SUPPORTS-MMAP-CACHE-HINTS>` capability."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:194
msgid "\\normalsize"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:199
msgid "Return Value"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:201
msgid ""
"On success 0 is returned, on error -1 and the ``errno`` variable is set "
"appropriately. The generic error codes are described at the :ref:`Generic "
"Error Codes <gen-errors>` chapter."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:205
msgid "EINVAL"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-reqbufs.rst:206
msgid ""
"The buffer type (``type`` field) or the requested I/O method (``memory``) is "
"not supported."
msgstr ""
