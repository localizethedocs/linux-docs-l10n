# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/mm/transhuge.rst:3
msgid "Transparent Hugepage Support"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:6
msgid "Objective"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:8
msgid ""
"Performance critical computing applications dealing with large memory "
"working sets are already running on top of libhugetlbfs and in turn "
"hugetlbfs. Transparent HugePage Support (THP) is an alternative mean of "
"using huge pages for the backing of virtual memory with huge pages that "
"supports the automatic promotion and demotion of page sizes and without the "
"shortcomings of hugetlbfs."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:15
msgid ""
"Currently THP only works for anonymous memory mappings and tmpfs/shmem. But "
"in the future it can expand to other filesystems."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:19
msgid ""
"in the examples below we presume that the basic page size is 4K and the huge "
"page size is 2M, although the actual numbers may vary depending on the CPU "
"architecture."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:23
msgid ""
"The reason applications are running faster is because of two factors. The "
"first factor is almost completely irrelevant and it's not of significant "
"interest because it'll also have the downside of requiring larger clear-page "
"copy-page in page faults which is a potentially negative effect. The first "
"factor consists in taking a single page fault for each 2M virtual region "
"touched by userland (so reducing the enter/exit kernel frequency by a 512 "
"times factor). This only matters the first time the memory is accessed for "
"the lifetime of a memory mapping. The second long lasting and much more "
"important factor will affect all subsequent accesses to the memory for the "
"whole runtime of the application. The second factor consist of two "
"components:"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:36
msgid ""
"the TLB miss will run faster (especially with virtualization using nested "
"pagetables but almost always also on bare metal without virtualization)"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:40
msgid ""
"a single TLB entry will be mapping a much larger amount of virtual memory in "
"turn reducing the number of TLB misses. With virtualization and nested "
"pagetables the TLB can be mapped of larger size only if both KVM and the "
"Linux guest are using hugepages but a significant speedup already happens if "
"only one of the two is using hugepages just because of the fact the TLB miss "
"is going to run faster."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:48
msgid ""
"Modern kernels support \"multi-size THP\" (mTHP), which introduces the "
"ability to allocate memory in blocks that are bigger than a base page but "
"smaller than traditional PMD-size (as described above), in increments of a "
"power-of-2 number of pages. mTHP can back anonymous memory (for example 16K, "
"32K, 64K, etc). These THPs continue to be PTE-mapped, but in many cases can "
"still provide similar benefits to those outlined above: Page faults are "
"significantly reduced (by a factor of e.g. 4, 8, 16, etc), but latency "
"spikes are much less prominent because the size of each page isn't as huge "
"as the PMD-sized variant and there is less memory to clear in each page "
"fault. Some architectures also employ TLB compression mechanisms to squeeze "
"more entries in when a set of PTEs are virtually and physically contiguous "
"and approporiately aligned. In this case, TLB misses will occur less often."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:63
msgid ""
"THP can be enabled system wide or restricted to certain tasks or even memory "
"ranges inside task's address space. Unless THP is completely disabled, there "
"is ``khugepaged`` daemon that scans memory and collapses sequences of basic "
"pages into PMD-sized huge pages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:68
msgid ""
"The THP behaviour is controlled via :ref:`sysfs <thp_sysfs>` interface and "
"using madvise(2) and prctl(2) system calls."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:71
msgid ""
"Transparent Hugepage Support maximizes the usefulness of free memory if "
"compared to the reservation approach of hugetlbfs by allowing all unused "
"memory to be used as cache or other movable (or even unmovable entities). It "
"doesn't require reservation to prevent hugepage allocation failures to be "
"noticeable from userland. It allows paging and all other advanced VM "
"features to be available on the hugepages. It requires no modifications for "
"applications to take advantage of it."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:80
msgid ""
"Applications however can be further optimized to take advantage of this "
"feature, like for example they've been optimized before to avoid a flood of "
"mmap system calls for every malloc(4k). Optimizing userland is by far not "
"mandatory and khugepaged already can take care of long lived page "
"allocations even for hugepage unaware applications that deals with large "
"amounts of memory."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:87
msgid ""
"In certain cases when hugepages are enabled system wide, application may end "
"up allocating more memory resources. An application may mmap a large region "
"but only touch 1 byte of it, in that case a 2M page might be allocated "
"instead of a 4k page for no good. This is why it's possible to disable "
"hugepages system-wide and to only have them inside MADV_HUGEPAGE madvise "
"regions."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:94
msgid ""
"Embedded systems should enable hugepages only inside madvise regions to "
"eliminate any risk of wasting any precious byte of memory and to only run "
"faster."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:98
msgid ""
"Applications that gets a lot of benefit from hugepages and that don't risk "
"to lose memory by using hugepages, should use madvise(MADV_HUGEPAGE) on "
"their critical mmapped regions."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:105
msgid "sysfs"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:108
msgid "Global THP controls"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:110
msgid ""
"Transparent Hugepage Support for anonymous memory can be disabled (mostly "
"for debugging purposes) or only enabled inside MADV_HUGEPAGE regions (to "
"avoid the risk of consuming more memory resources) or enabled system wide. "
"This can be achieved per-supported-THP-size with one of::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:119
msgid ""
"where <size> is the hugepage size being addressed, the available sizes for "
"which vary by system."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:122
msgid ""
"Setting \"never\" in all sysfs THP controls does **not** disable Transparent "
"Huge Pages globally. This is because ``madvise(..., MADV_COLLAPSE)`` ignores "
"these settings and collapses ranges to PMD-sized huge pages unconditionally."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:127
#: ../../../admin-guide/mm/transhuge.rst:136
msgid "For example::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:131
msgid ""
"Alternatively it is possible to specify that a given hugepage size will "
"inherit the top-level \"enabled\" value::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:140
msgid ""
"The top-level setting (for use with \"inherit\") can be set by issuing one "
"of the following commands::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:147
msgid ""
"By default, PMD-sized hugepages have enabled=\"inherit\" and all other "
"hugepage sizes have enabled=\"never\". If enabling multiple hugepage sizes, "
"the kernel will select the most appropriate enabled size for a given "
"allocation."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:152
msgid ""
"It's also possible to limit defrag efforts in the VM to generate anonymous "
"hugepages in case they're not immediately free to madvise regions or to "
"never try to defrag memory and simply fallback to regular pages unless "
"hugepages are immediately available. Clearly if we spend CPU time to defrag "
"memory, we would expect to gain even more by the fact we use hugepages later "
"instead of regular pages. This isn't always guaranteed, but it may be more "
"likely in case the allocation is for a MADV_HUGEPAGE region."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:169
#: ../../../admin-guide/mm/transhuge.rst:384
#: ../../../admin-guide/mm/transhuge.rst:438
msgid "always"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:170
msgid ""
"means that an application requesting THP will stall on allocation failure "
"and directly reclaim pages and compact memory in an effort to allocate a THP "
"immediately. This may be desirable for virtual machines that benefit heavily "
"from THP use and are willing to delay the VM start to utilise them."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:176
msgid "defer"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:177
msgid ""
"means that an application will wake kswapd in the background to reclaim "
"pages and wake kcompactd to compact memory so that THP is available in the "
"near future. It's the responsibility of khugepaged to then install the THP "
"pages later."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:182
msgid "defer+madvise"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:183
msgid ""
"will enter direct reclaim and compaction like ``always``, but only for "
"regions that have used madvise(MADV_HUGEPAGE); all other regions will wake "
"kswapd in the background to reclaim pages and wake kcompactd to compact "
"memory so that THP is available in the near future."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:189
msgid "madvise"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:190
msgid ""
"will enter direct reclaim like ``always`` but only for regions that are have "
"used madvise(MADV_HUGEPAGE). This is the default behaviour."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:194
#: ../../../admin-guide/mm/transhuge.rst:387
#: ../../../admin-guide/mm/transhuge.rst:445
msgid "never"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:195
msgid ""
"should be self-explanatory. Note that ``madvise(..., MADV_COLLAPSE)`` can "
"still cause transparent huge pages to be obtained even if this mode is "
"specified everywhere."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:199
msgid ""
"By default kernel tries to use huge, PMD-mappable zero page on read page "
"fault to anonymous mapping. It's possible to disable huge zero page by "
"writing 0 or enable it back by writing 1::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:206
msgid ""
"Some userspace (such as a test program, or an optimized memory allocation "
"library) may want to know the size (in bytes) of a PMD-mappable transparent "
"hugepage::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:212
msgid ""
"All THPs at fault and collapse time will be added to _deferred_list, and "
"will therefore be split under memory presure if they are considered "
"\"underused\". A THP is underused if the number of zero-filled pages in the "
"THP is above max_ptes_none (see below). It is possible to disable this "
"behaviour by writing 0 to shrink_underused, and enable it by writing 1 to "
"it::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:222
msgid ""
"khugepaged will be automatically started when PMD-sized THP is enabled "
"(either of the per-size anon control or the top-level control are set to "
"\"always\" or \"madvise\"), and it'll be automatically shutdown when PMD-"
"sized THP is disabled (when both the per-size anon control and the top-level "
"control are \"never\")"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:229
msgid "Khugepaged controls"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:232
msgid ""
"khugepaged currently only searches for opportunities to collapse to PMD-"
"sized THP and no attempt is made to collapse to other THP sizes."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:236
msgid ""
"khugepaged runs usually at low frequency so while one may not want to invoke "
"defrag algorithms synchronously during the page faults, it should be worth "
"invoking defrag at least in khugepaged. However it's also possible to "
"disable defrag in khugepaged by writing 0 or enable defrag in khugepaged by "
"writing 1::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:245
msgid ""
"You can also control how many pages khugepaged should scan at each pass::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:250
msgid ""
"and how many milliseconds to wait in khugepaged between each pass (you can "
"set this to 0 to run khugepaged at 100% utilization of one core)::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:255
msgid ""
"and how many milliseconds to wait in khugepaged if there's an hugepage "
"allocation failure to throttle the next allocation attempt::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:260
msgid ""
"The khugepaged progress can be seen in the number of pages collapsed (note "
"that this counter may not be an exact count of the number of pages "
"collapsed, since \"collapsed\" could mean multiple things: (1) A PTE mapping "
"being replaced by a PMD mapping, or (2) All 4K physical pages replaced by "
"one 2M hugepage. Each may happen independently, or together, depending on "
"the type of memory and the failures that occur. As such, this value should "
"be interpreted roughly as a sign of progress, and counters in /proc/vmstat "
"consulted for more accurate accounting)::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:271
msgid "for each pass::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:275
msgid ""
"``max_ptes_none`` specifies how many extra small pages (that are not already "
"mapped) can be allocated when collapsing a group of small pages into one "
"large page::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:281
msgid ""
"A higher value leads to use additional memory for programs. A lower value "
"leads to gain less thp performance. Value of max_ptes_none can waste cpu "
"time very little, you can ignore it."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:286
msgid ""
"``max_ptes_swap`` specifies how many pages can be brought in from swap when "
"collapsing a group of pages into a transparent huge page::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:291
msgid ""
"A higher value can cause excessive swap IO and waste memory. A lower value "
"can prevent THPs from being collapsed, resulting fewer pages being collapsed "
"into THPs, and lower memory access performance."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:296
msgid ""
"``max_ptes_shared`` specifies how many pages can be shared across multiple "
"processes. khugepaged might treat pages of THPs as shared if any page of "
"that THP is shared. Exceeding the number would block the collapse::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:302
msgid "A higher value may increase memory footprint for some workloads."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:305
msgid "Boot parameters"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:307
msgid ""
"You can change the sysfs boot time default for the top-level \"enabled\" "
"control by passing the parameter ``transparent_hugepage=always`` or "
"``transparent_hugepage=madvise`` or ``transparent_hugepage=never`` to the "
"kernel command line."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:312
msgid ""
"Alternatively, each supported anonymous THP size can be controlled by "
"passing ``thp_anon=<size>[KMG],<size>[KMG]:<state>;<size>[KMG]-<size>[KMG]:"
"<state>``, where ``<size>`` is the THP size (must be a power of 2 of "
"PAGE_SIZE and supported anonymous THP)  and ``<state>`` is one of "
"``always``, ``madvise``, ``never`` or ``inherit``."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:318
msgid ""
"For example, the following will set 16K, 32K, 64K THP to ``always``, set "
"128K, 512K to ``inherit``, set 256K to ``madvise`` and 1M, 2M to ``never``::"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:324
msgid ""
"``thp_anon=`` may be specified multiple times to configure all THP sizes as "
"required. If ``thp_anon=`` is specified at least once, any anon THP sizes "
"not explicitly configured on the command line are implicitly set to "
"``never``."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:329
msgid ""
"``transparent_hugepage`` setting only affects the global toggle. If "
"``thp_anon`` is not specified, PMD_ORDER THP will default to ``inherit``. "
"However, if a valid ``thp_anon`` setting is provided by the user, the "
"PMD_ORDER THP policy will be overridden. If the policy for PMD_ORDER is not "
"defined within a valid ``thp_anon``, its policy will default to ``never``."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:336
msgid ""
"Similarly to ``transparent_hugepage``, you can control the hugepage "
"allocation policy for the internal shmem mount by using the kernel parameter "
"``transparent_hugepage_shmem=<policy>``, where ``<policy>`` is one of the "
"seven valid policies for shmem (``always``, ``within_size``, ``advise``, "
"``never``, ``deny``, and ``force``)."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:342
msgid ""
"Similarly to ``transparent_hugepage_shmem``, you can control the default "
"hugepage allocation policy for the tmpfs mount by using the kernel parameter "
"``transparent_hugepage_tmpfs=<policy>``, where ``<policy>`` is one of the "
"four valid policies for tmpfs (``always``, ``within_size``, ``advise``, "
"``never``). The tmpfs mount default policy is ``never``."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:348
msgid ""
"In the same manner as ``thp_anon`` controls each supported anonymous THP "
"size, ``thp_shmem`` controls each supported shmem THP size. ``thp_shmem`` "
"has the same format as ``thp_anon``, but also supports the policy "
"``within_size``."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:353
msgid ""
"``thp_shmem=`` may be specified multiple times to configure all THP sizes as "
"required. If ``thp_shmem=`` is specified at least once, any shmem THP sizes "
"not explicitly configured on the command line are implicitly set to "
"``never``."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:358
msgid ""
"``transparent_hugepage_shmem`` setting only affects the global toggle. If "
"``thp_shmem`` is not specified, PMD_ORDER hugepage will default to "
"``inherit``. However, if a valid ``thp_shmem`` setting is provided by the "
"user, the PMD_ORDER hugepage policy will be overridden. If the policy for "
"PMD_ORDER is not defined within a valid ``thp_shmem``, its policy will "
"default to ``never``."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:366
msgid "Hugepages in tmpfs/shmem"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:368
msgid ""
"Traditionally, tmpfs only supported a single huge page size (\"PMD\"). "
"Today, it also supports smaller sizes just like anonymous memory, often "
"referred to as \"multi-size THP\" (mTHP). Huge pages of any size are "
"commonly represented in the kernel as \"large folios\"."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:373
msgid ""
"While there is fine control over the huge page sizes to use for the internal "
"shmem mount (see below), ordinary tmpfs mounts will make use of all "
"available huge page sizes without any control over the exact sizes, behaving "
"more like other file systems."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:379
msgid "tmpfs mounts"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:381
msgid ""
"The THP allocation policy for tmpfs mounts can be adjusted using the mount "
"option: ``huge=``. It can have following values:"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:385
msgid "Attempt to allocate huge pages every time we need a new page;"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:388
msgid ""
"Do not allocate huge pages. Note that ``madvise(..., MADV_COLLAPSE)`` can "
"still cause transparent huge pages to be obtained even if this mode is "
"specified everywhere;"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:392
#: ../../../admin-guide/mm/transhuge.rst:450
msgid "within_size"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:393
msgid ""
"Only allocate huge page if it will be fully within i_size. Also respect "
"madvise() hints;"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:396
#: ../../../admin-guide/mm/transhuge.rst:454
msgid "advise"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:397
msgid "Only allocate huge pages if requested with madvise();"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:399
msgid ""
"Remember, that the kernel may use huge pages of all available sizes, and "
"that no fine control as for the internal tmpfs mount is available."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:402
msgid ""
"The default policy in the past was ``never``, but it can now be adjusted "
"using the kernel parameter ``transparent_hugepage_tmpfs=<policy>``."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:405
msgid ""
"``mount -o remount,huge= /mountpoint`` works fine after mount: remounting "
"``huge=never`` will not attempt to break up huge pages at all, just stop "
"more from being allocated."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:409
msgid ""
"In addition to policies listed above, the sysfs knob /sys/kernel/mm/"
"transparent_hugepage/shmem_enabled will affect the allocation policy of "
"tmpfs mounts, when set to the following values:"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:413
msgid "deny"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:414
msgid "For use in emergencies, to force the huge option off from all mounts;"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:416
msgid "force"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:417
msgid "Force the huge option on for all - very useful for testing;"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:420
msgid "shmem / internal tmpfs"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:421
msgid ""
"The mount internal tmpfs mount is used for SysV SHM, memfds, shared "
"anonymous mmaps (of /dev/zero or MAP_ANONYMOUS), GPU drivers' DRM  objects, "
"Ashmem."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:424
msgid ""
"To control the THP allocation policy for this internal tmpfs mount, the "
"sysfs knob /sys/kernel/mm/transparent_hugepage/shmem_enabled and the knobs "
"per THP size in '/sys/kernel/mm/transparent_hugepage/hugepages-<size>kB/"
"shmem_enabled' can be used."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:430
msgid ""
"The global knob has the same semantics as the ``huge=`` mount options for "
"tmpfs mounts, except that the different huge page sizes can be controlled "
"individually, and will only use the setting of the global knob when the per-"
"size knob is set to 'inherit'."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:435
msgid ""
"The options 'force' and 'deny' are dropped for the individual sizes, which "
"are rather testing artifacts from the old ages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:439
msgid "Attempt to allocate <size> huge pages every time we need a new page;"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:441
msgid "inherit"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:442
msgid ""
"Inherit the top-level \"shmem_enabled\" value. By default, PMD-sized "
"hugepages have enabled=\"inherit\" and all other hugepage sizes have "
"enabled=\"never\";"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:446
msgid ""
"Do not allocate <size> huge pages. Note that ``madvise(..., MADV_COLLAPSE)`` "
"can still cause transparent huge pages to be obtained even if this mode is "
"specified everywhere;"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:451
msgid ""
"Only allocate <size> huge page if it will be fully within i_size. Also "
"respect madvise() hints;"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:455
msgid "Only allocate <size> huge pages if requested with madvise();"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:458
msgid "Need of application restart"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:460
msgid ""
"The transparent_hugepage/enabled and transparent_hugepage/hugepages-<size>kB/"
"enabled values and tmpfs mount option only affect future behavior. So to "
"make them effective you need to restart any application that could have been "
"using hugepages. This also applies to the regions registered in khugepaged."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:467
msgid "Monitoring usage"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:469
msgid ""
"The number of PMD-sized anonymous transparent huge pages currently used by "
"the system is available by reading the AnonHugePages field in ``/proc/"
"meminfo``. To identify what applications are using PMD-sized anonymous "
"transparent huge pages, it is necessary to read ``/proc/PID/smaps`` and "
"count the AnonHugePages fields for each mapping. (Note that AnonHugePages "
"only applies to traditional PMD-sized THP for historical reasons and should "
"have been called AnonHugePmdMapped)."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:477
msgid ""
"The number of file transparent huge pages mapped to userspace is available "
"by reading ShmemPmdMapped and ShmemHugePages fields in ``/proc/meminfo``. To "
"identify what applications are mapping file transparent huge pages, it is "
"necessary to read ``/proc/PID/smaps`` and count the FilePmdMapped fields for "
"each mapping."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:483
msgid ""
"Note that reading the smaps file is expensive and reading it frequently will "
"incur overhead."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:486
msgid ""
"There are a number of counters in ``/proc/vmstat`` that may be used to "
"monitor how successfully the system is providing huge pages for use."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:489
msgid "thp_fault_alloc"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:490
#: ../../../admin-guide/mm/transhuge.rst:584
msgid ""
"is incremented every time a huge page is successfully allocated and charged "
"to handle a page fault."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:493
msgid "thp_collapse_alloc"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:494
msgid ""
"is incremented by khugepaged when it has found a range of pages to collapse "
"into one huge page and has successfully allocated a new huge page to store "
"the data."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:498
msgid "thp_fault_fallback"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:499
msgid ""
"is incremented if a page fault fails to allocate or charge a huge page and "
"instead falls back to using small pages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:502
msgid "thp_fault_fallback_charge"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:503
msgid ""
"is incremented if a page fault fails to charge a huge page and instead falls "
"back to using small pages even though the allocation was successful."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:507
msgid "thp_collapse_alloc_failed"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:508
msgid ""
"is incremented if khugepaged found a range of pages that should be collapsed "
"into one huge page but failed the allocation."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:512
msgid "thp_file_alloc"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:513
msgid ""
"is incremented every time a shmem huge page is successfully allocated (Note "
"that despite being named after \"file\", the counter measures only shmem)."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:517
msgid "thp_file_fallback"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:518
msgid ""
"is incremented if a shmem huge page is attempted to be allocated but fails "
"and instead falls back to using small pages. (Note that despite being named "
"after \"file\", the counter measures only shmem)."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:522
msgid "thp_file_fallback_charge"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:523
msgid ""
"is incremented if a shmem huge page cannot be charged and instead falls back "
"to using small pages even though the allocation was successful. (Note that "
"despite being named after \"file\", the counter measures only shmem)."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:528
msgid "thp_file_mapped"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:529
msgid ""
"is incremented every time a file or shmem huge page is mapped into user "
"address space."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:532
msgid "thp_split_page"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:533
msgid ""
"is incremented every time a huge page is split into base pages. This can "
"happen for a variety of reasons but a common reason is that a huge page is "
"old and is being reclaimed. This action implies splitting all PMD the page "
"mapped with."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:538
msgid "thp_split_page_failed"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:539
#: ../../../admin-guide/mm/transhuge.rst:643
msgid ""
"is incremented if kernel fails to split huge page. This can happen if the "
"page was pinned by somebody."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:542
msgid "thp_deferred_split_page"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:543
msgid ""
"is incremented when a huge page is put onto split queue. This happens when a "
"huge page is partially unmapped and splitting it would free up some memory. "
"Pages on split queue are going to be split under memory pressure."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:548
msgid "thp_underused_split_page"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:549
msgid ""
"is incremented when a huge page on the split queue was split because it was "
"underused. A THP is underused if the number of zero pages in the THP is "
"above a certain threshold (/sys/kernel/mm/transparent_hugepage/khugepaged/"
"max_ptes_none)."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:554
msgid "thp_split_pmd"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:555
msgid ""
"is incremented every time a PMD split into table of PTEs. This can happen, "
"for instance, when application calls mprotect() or munmap() on part of huge "
"page. It doesn't split huge page, only page table entry."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:560
msgid "thp_zero_page_alloc"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:561
msgid ""
"is incremented every time a huge zero page used for thp is successfully "
"allocated. Note, it doesn't count every map of the huge zero page, only its "
"allocation."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:565
msgid "thp_zero_page_alloc_failed"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:566
msgid ""
"is incremented if kernel fails to allocate huge zero page and falls back to "
"using small pages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:569
msgid "thp_swpout"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:570
msgid ""
"is incremented every time a huge page is swapout in one piece without "
"splitting."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:573
msgid "thp_swpout_fallback"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:574
#: ../../../admin-guide/mm/transhuge.rst:620
msgid ""
"is incremented if a huge page has to be split before swapout. Usually "
"because failed to allocate some continuous swap space for the huge page."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:578
msgid ""
"In /sys/kernel/mm/transparent_hugepage/hugepages-<size>kB/stats, There are "
"also individual counters for each huge page size, which can be utilized to "
"monitor the system's effectiveness in providing huge pages for usage. Each "
"counter has its own corresponding file."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:583
msgid "anon_fault_alloc"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:587
msgid "anon_fault_fallback"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:588
msgid ""
"is incremented if a page fault fails to allocate or charge a huge page and "
"instead falls back to using huge pages with lower orders or small pages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:592
msgid "anon_fault_fallback_charge"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:593
msgid ""
"is incremented if a page fault fails to charge a huge page and instead falls "
"back to using huge pages with lower orders or small pages even though the "
"allocation was successful."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:597
msgid "zswpout"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:598
msgid ""
"is incremented every time a huge page is swapped out to zswap in one piece "
"without splitting."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:601
msgid "swpin"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:602
msgid ""
"is incremented every time a huge page is swapped in from a non-zswap swap "
"device in one piece."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:605
msgid "swpin_fallback"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:606
msgid ""
"is incremented if swapin fails to allocate or charge a huge page and instead "
"falls back to using huge pages with lower orders or small pages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:610
msgid "swpin_fallback_charge"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:611
msgid ""
"is incremented if swapin fails to charge a huge page and instead falls back "
"to using  huge pages with lower orders or small pages even though the "
"allocation was successful."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:615
msgid "swpout"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:616
msgid ""
"is incremented every time a huge page is swapped out to a non-zswap swap "
"device in one piece without splitting."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:619
msgid "swpout_fallback"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:624
msgid "shmem_alloc"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:625
msgid "is incremented every time a shmem huge page is successfully allocated."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:628
msgid "shmem_fallback"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:629
msgid ""
"is incremented if a shmem huge page is attempted to be allocated but fails "
"and instead falls back to using small pages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:632
msgid "shmem_fallback_charge"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:633
msgid ""
"is incremented if a shmem huge page cannot be charged and instead falls back "
"to using small pages even though the allocation was successful."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:637
msgid "split"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:638
msgid ""
"is incremented every time a huge page is successfully split into smaller "
"orders. This can happen for a variety of reasons but a common reason is that "
"a huge page is old and is being reclaimed."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:642
msgid "split_failed"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:646
msgid "split_deferred"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:647
msgid ""
"is incremented when a huge page is put onto split queue. This happens when a "
"huge page is partially unmapped and splitting it would free up some memory. "
"Pages on split queue are going to be split under memory pressure, if "
"splitting is possible."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:652
msgid "nr_anon"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:653
msgid ""
"the number of anonymous THP we have in the whole system. These THPs might be "
"currently entirely mapped or have partially unmapped/unused subpages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:657
msgid "nr_anon_partially_mapped"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:658
msgid ""
"the number of anonymous THP which are likely partially mapped, possibly "
"wasting memory, and have been queued for deferred memory reclamation. Note "
"that in corner some cases (e.g., failed migration), we might detect an "
"anonymous THP as \"partially mapped\" and count it here, even though it is "
"not actually partially mapped anymore."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:664
msgid ""
"As the system ages, allocating huge pages may be expensive as the system "
"uses memory compaction to copy data around memory to free a huge page for "
"use. There are some counters in ``/proc/vmstat`` to help monitor this "
"overhead."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:669
msgid "compact_stall"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:670
msgid ""
"is incremented every time a process stalls to run memory compaction so that "
"a huge page is free for use."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:673
msgid "compact_success"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:674
msgid ""
"is incremented if the system compacted memory and freed a huge page for use."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:677
msgid "compact_fail"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:678
msgid "is incremented if the system tries to compact memory but failed."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:681
msgid ""
"It is possible to establish how long the stalls were using the function "
"tracer to record how long was spent in __alloc_pages() and using the "
"mm_page_alloc tracepoint to identify which allocations were for huge pages."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:687
msgid "Optimizing the applications"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:689
msgid ""
"To be guaranteed that the kernel will map a THP immediately in any memory "
"region, the mmap region has to be hugepage naturally aligned. "
"posix_memalign() can provide that guarantee."
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:694
msgid "Hugetlbfs"
msgstr ""

#: ../../../admin-guide/mm/transhuge.rst:696
msgid ""
"You can use hugetlbfs on a kernel that has transparent hugepage support "
"enabled just fine as always. No difference can be noted in hugetlbfs other "
"than there will be less overall fragmentation. All usual features belonging "
"to hugetlbfs are preserved and unaffected. libhugetlbfs will also work fine "
"as usual."
msgstr ""
