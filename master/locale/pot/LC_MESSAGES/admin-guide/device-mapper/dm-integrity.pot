# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/device-mapper/dm-integrity.rst:3
msgid "dm-integrity"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:5
msgid ""
"The dm-integrity target emulates a block device that has additional per-"
"sector tags that can be used for storing integrity information."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:8
msgid ""
"A general problem with storing integrity tags with every sector is that "
"writing the sector and the integrity tag must be atomic - i.e. in case of "
"crash, either both sector and integrity tag or none of them is written."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:12
msgid ""
"To guarantee write atomicity, the dm-integrity target uses journal, it "
"writes sector data and integrity tags into a journal, commits the journal "
"and then copies the data and integrity tags to their respective location."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:16
msgid ""
"The dm-integrity target can be used with the dm-crypt target - in this "
"situation the dm-crypt target creates the integrity data and passes them to "
"the dm-integrity target via bio_integrity_payload attached to the bio. In "
"this mode, the dm-crypt and dm-integrity targets provide authenticated disk "
"encryption - if the attacker modifies the encrypted device, an I/O error is "
"returned instead of random data."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:23
msgid ""
"The dm-integrity target can also be used as a standalone target, in this "
"mode it calculates and verifies the integrity tag internally. In this mode, "
"the dm-integrity target can be used to detect silent data corruption on the "
"disk or in the I/O path."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:28
msgid ""
"There's an alternate mode of operation where dm-integrity uses a bitmap "
"instead of a journal. If a bit in the bitmap is 1, the corresponding "
"region's data and integrity tags are not synchronized - if the machine "
"crashes, the unsynchronized regions will be recalculated. The bitmap mode is "
"faster than the journal mode, because we don't have to write the data twice, "
"but it is also less reliable, because if data corruption happens when the "
"machine crashes, it may not be detected."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:36
msgid ""
"When loading the target for the first time, the kernel driver will format "
"the device. But it will only format the device if the superblock contains "
"zeroes. If the superblock is neither valid nor zeroed, the dm-integrity "
"target can't be loaded."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:41
msgid ""
"Accesses to the on-disk metadata area containing checksums (aka tags) are "
"buffered using dm-bufio. When an access to any given metadata area occurs, "
"each unique metadata area gets its own buffer(s). The buffer size is capped "
"at the size of the metadata area, but may be smaller, thereby requiring "
"multiple buffers to represent the full metadata area. A smaller buffer size "
"will produce a smaller resulting read/write operation to the metadata area "
"for small reads/writes. The metadata is still read even in a full write to "
"the data covered by a single buffer."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:50
msgid "To use the target for the first time:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:52
msgid "overwrite the superblock with zeroes"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:53
msgid ""
"load the dm-integrity target with one-sector size, the kernel driver will "
"format the device"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:55
msgid "unload the dm-integrity target"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:56
msgid "read the \"provided_data_sectors\" value from the superblock"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:57
msgid ""
"load the dm-integrity target with the target size \"provided_data_sectors\""
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:59
msgid ""
"if you want to use dm-integrity with dm-crypt, load the dm-crypt target with "
"the size \"provided_data_sectors\""
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:63
msgid "Target arguments:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:65
msgid "the underlying block device"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:67
msgid ""
"the number of reserved sector at the beginning of the device - the dm-"
"integrity won't read of write these sectors"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:70
msgid ""
"the size of the integrity tag (if \"-\" is used, the size is taken from the "
"internal-hash algorithm)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:73
msgid "mode:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:75
msgid "D - direct writes (without journal)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:76
msgid ""
"in this mode, journaling is not used and data sectors and integrity tags are "
"written separately. In case of crash, it is possible that the data and "
"integrity tag doesn't match."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:80
msgid "J - journaled writes"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:81
msgid ""
"data and integrity tags are written to the journal and atomicity is "
"guaranteed. In case of crash, either both data and tag or none of them are "
"written. The journaled mode degrades write throughput twice because the data "
"have to be written twice."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:86
msgid "B - bitmap mode - data and metadata are written without any"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:87
msgid ""
"synchronization, the driver maintains a bitmap of dirty regions where data "
"and metadata don't match. This mode can only be used with internal hash."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:90
msgid "R - recovery mode - in this mode, journal is not replayed,"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:91
msgid ""
"checksums are not checked and writes to the device are not allowed. This "
"mode is useful for data recovery if the device cannot be activated in any of "
"the other standard modes."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:95
msgid "I - inline mode - in this mode, dm-integrity will store integrity"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:96
msgid ""
"data directly in the underlying device sectors. The underlying device must "
"have an integrity profile that allows storing user integrity data and "
"provides enough space for the selected integrity tag."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:101
msgid "the number of additional arguments"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:103
msgid "Additional arguments:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:105
msgid "journal_sectors:number"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:106
msgid ""
"The size of journal, this argument is used only if formatting the device. If "
"the device is already formatted, the value from the superblock is used."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:110
msgid "interleave_sectors:number (default 32768)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:111
msgid ""
"The number of interleaved sectors. This values is rounded down to a power of "
"two. If the device is already formatted, the value from the superblock is "
"used."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:115
msgid "meta_device:device"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:116
msgid ""
"Don't interleave the data and metadata on the device. Use a separate device "
"for metadata."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:119
msgid "buffer_sectors:number (default 128)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:120
msgid ""
"The number of sectors in one metadata buffer. The value is rounded down to a "
"power of two."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:123
msgid "journal_watermark:number (default 50)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:124
msgid ""
"The journal watermark in percents. When the size of the journal exceeds this "
"watermark, the thread that flushes the journal will be started."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:128
msgid "commit_time:number (default 10000)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:129
msgid ""
"Commit time in milliseconds. When this time passes, the journal is written. "
"The journal is also written immediately if the FLUSH request is received."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:133
msgid "internal_hash:algorithm(:key)   (the key is optional)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:134
msgid ""
"Use internal hash or crc. When this argument is used, the dm-integrity "
"target won't accept integrity tags from the upper target, but it will "
"automatically generate and verify the integrity tags."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:139
msgid ""
"You can use a crc algorithm (such as crc32), then integrity target will "
"protect the data against accidental corruption. You can also use a hmac "
"algorithm (for example \"hmac(sha256):0123456789abcdef\"), in this mode it "
"will provide cryptographic authentication of the data without encryption."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:145
msgid ""
"When this argument is not used, the integrity tags are accepted from an "
"upper layer target, such as dm-crypt. The upper layer target should check "
"the validity of the integrity tags."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:149
msgid "recalculate"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:150
msgid ""
"Recalculate the integrity tags automatically. It is only valid when using "
"internal hash."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:153
msgid "journal_crypt:algorithm(:key)   (the key is optional)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:154
msgid ""
"Encrypt the journal using given algorithm to make sure that the attacker "
"can't read the journal. You can use a block cipher here (such as "
"\"cbc(aes)\") or a stream cipher (for example \"chacha20\" or \"ctr(aes)\")."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:159
msgid ""
"The journal contains history of last writes to the block device, an attacker "
"reading the journal could see the last sector numbers that were written. "
"From the sector numbers, the attacker can infer the size of files that were "
"written. To protect against this situation, you can encrypt the journal."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:165
msgid "journal_mac:algorithm(:key)     (the key is optional)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:166
msgid ""
"Protect sector numbers in the journal from accidental or malicious "
"modification. To protect against accidental modification, use a crc "
"algorithm, to protect against malicious modification, use a hmac algorithm "
"with a key."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:171
msgid ""
"This option is not needed when using internal-hash because in this mode, the "
"integrity of journal entries is checked when replaying the journal. Thus, "
"modified sector number would be detected at this stage."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:176
msgid "block_size:number (default 512)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:177
msgid ""
"The size of a data block in bytes. The larger the block size the less "
"overhead there is for per-block integrity metadata. Supported values are "
"512, 1024, 2048 and 4096 bytes."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:181
msgid "sectors_per_bit:number"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:182
msgid ""
"In the bitmap mode, this parameter specifies the number of 512-byte sectors "
"that corresponds to one bitmap bit."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:185
msgid "bitmap_flush_interval:number"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:186
msgid ""
"The bitmap flush interval in milliseconds. The metadata buffers are "
"synchronized when this interval expires."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:189
msgid "allow_discards"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:190
msgid ""
"Allow block discard requests (a.k.a. TRIM) for the integrity device. "
"Discards are only allowed to devices using internal hash."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:193
msgid "fix_padding"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:194
msgid ""
"Use a smaller padding of the tag area that is more space-efficient. If this "
"option is not present, large padding is used - that is for compatibility "
"with older kernels."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:198
msgid "fix_hmac"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:199
msgid "Improve security of internal_hash and journal_mac:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:201
msgid ""
"the section number is mixed to the mac, so that an attacker can't copy "
"sectors from one journal section to another journal section"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:203
msgid "the superblock is protected by journal_mac"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:204
msgid ""
"a 16-byte salt stored in the superblock is mixed to the mac, so that the "
"attacker can't detect that two disks have the same hmac key and also to "
"disallow the attacker to move sectors from one disk to another"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:209
msgid "legacy_recalculate"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:210
msgid ""
"Allow recalculating of volumes with HMAC keys. This is disabled by default "
"for security reasons - an attacker could modify the volume, set "
"recalc_sector to zero, and the kernel would not detect the modification."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:215
msgid ""
"The journal mode (D/J), buffer_sectors, journal_watermark, commit_time and "
"allow_discards can be changed when reloading the target (load an inactive "
"table and swap the tables with suspend and resume). The other arguments "
"should not be changed when reloading the target because the layout of disk "
"data depend on them and the reloaded target would be non-functional."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:221
msgid ""
"For example, on a device using the default interleave_sectors of 32768, a "
"block_size of 512, and an internal_hash of crc32c with a tag size of 4 "
"bytes, it will take 128 KiB of tags to track a full data area, requiring 256 "
"sectors of metadata per data area. With the default buffer_sectors of 128, "
"that means there will be 2 buffers per metadata area, or 2 buffers per 16 "
"MiB of data."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:228
msgid "Status line:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:230
msgid "the number of integrity mismatches"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:231
msgid ""
"provided data sectors - that is the number of sectors that the user could use"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:233
msgid "the current recalculating position (or '-' if we didn't recalculate)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:236
msgid "The layout of the formatted block device:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:238
msgid "reserved sectors"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:239
msgid ""
"(they are not used by this target, they can be used for storing LUKS "
"metadata or for other purpose), the size of the reserved area is specified "
"in the target arguments"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:243
msgid "superblock (4kiB)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:244
msgid "magic string - identifies that the device was formatted"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:245
msgid "version"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:246
msgid "log2(interleave sectors)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:247
msgid "integrity tag size"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:248
msgid "the number of journal sections"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:249
msgid ""
"provided data sectors - the number of sectors that this target provides (i."
"e. the size of the device minus the size of all metadata and padding). The "
"user of this target should not send bios that access data beyond the "
"\"provided data sectors\" limit."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:253
msgid "flags"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:254
msgid "SB_FLAG_HAVE_JOURNAL_MAC"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:255
msgid "a flag is set if journal_mac is used"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:256
msgid "SB_FLAG_RECALCULATING"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:257
msgid "recalculating is in progress"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:258
msgid "SB_FLAG_DIRTY_BITMAP"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:259
msgid "journal area contains the bitmap of dirty blocks"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:261
msgid "log2(sectors per block)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:262
msgid "a position where recalculating finished"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:263
msgid "journal"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:264
msgid "The journal is divided into sections, each section contains:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:266
msgid "metadata area (4kiB), it contains journal entries"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:268
msgid "every journal entry contains:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:270
msgid "logical sector (specifies where the data and tag should be written)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:272
msgid "last 8 bytes of data"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:273
msgid "integrity tag (the size is specified in the superblock)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:275
msgid "every metadata sector ends with"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:277
msgid ""
"mac (8-bytes), all the macs in 8 metadata sectors form a 64-byte value. It "
"is used to store hmac of sector numbers in the journal section, to protect "
"against a possibility that the attacker tampers with sector numbers in the "
"journal."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:282
#: ../../../admin-guide/device-mapper/dm-integrity.rst:291
msgid "commit id"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:284
msgid ""
"data area (the size is variable; it depends on how many journal entries fit "
"into the metadata area)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:287
msgid "every sector in the data area contains:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:289
msgid ""
"data (504 bytes of data, the last 8 bytes are stored in the journal entry)"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:293
msgid ""
"To test if the whole journal section was written correctly, every 512-byte "
"sector of the journal ends with 8-byte commit id. If the commit id matches "
"on all sectors in a journal section, then it is assumed that the section was "
"written correctly. If the commit id doesn't match, the section was written "
"partially and it should not be replayed."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:300
msgid "one or more runs of interleaved tags and data."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:301
msgid "Each run contains:"
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:303
msgid ""
"tag area - it contains integrity tags. There is one tag for each sector in "
"the data area. The size of this area is always 4KiB or greater."
msgstr ""

#: ../../../admin-guide/device-mapper/dm-integrity.rst:306
msgid ""
"data area - it contains data sectors. The number of data sectors in one run "
"must be a power of two. log2 of this value is stored in the superblock."
msgstr ""
