# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/cgroup-v1/cgroups.rst:3
msgid "Control Groups"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:5
msgid ""
"Written by Paul Menage <menage@google.com> based on Documentation/admin-"
"guide/cgroup-v1/cpusets.rst"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:8
msgid "Original copyright statements from cpusets.txt:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:10
msgid "Portions Copyright (C) 2004 BULL SA."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:12
msgid "Portions Copyright (c) 2004-2006 Silicon Graphics, Inc."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:14
msgid "Modified by Paul Jackson <pj@sgi.com>"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:16
msgid "Modified by Christoph Lameter <cl@gentwo.org>"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:39
msgid "1. Control Groups"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:42
msgid "1.1 What are cgroups ?"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:44
msgid ""
"Control Groups provide a mechanism for aggregating/partitioning sets of "
"tasks, and all their future children, into hierarchical groups with "
"specialized behaviour."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:48
msgid "Definitions:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:50
msgid ""
"A *cgroup* associates a set of tasks with a set of parameters for one or "
"more subsystems."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:53
msgid ""
"A *subsystem* is a module that makes use of the task grouping facilities "
"provided by cgroups to treat groups of tasks in particular ways. A subsystem "
"is typically a \"resource controller\" that schedules a resource or applies "
"per-cgroup limits, but it may be anything that wants to act on a group of "
"processes, e.g. a virtualization subsystem."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:60
msgid ""
"A *hierarchy* is a set of cgroups arranged in a tree, such that every task "
"in the system is in exactly one of the cgroups in the hierarchy, and a set "
"of subsystems; each subsystem has system-specific state attached to each "
"cgroup in the hierarchy.  Each hierarchy has an instance of the cgroup "
"virtual filesystem associated with it."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:66
msgid ""
"At any one time there may be multiple active hierarchies of task cgroups. "
"Each hierarchy is a partition of all tasks in the system."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:69
msgid ""
"User-level code may create and destroy cgroups by name in an instance of the "
"cgroup virtual file system, specify and query to which cgroup a task is "
"assigned, and list the task PIDs assigned to a cgroup. Those creations and "
"assignments only affect the hierarchy associated with that instance of the "
"cgroup file system."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:75
msgid ""
"On their own, the only use for cgroups is for simple job tracking. The "
"intention is that other subsystems hook into the generic cgroup support to "
"provide new attributes for cgroups, such as accounting/limiting the "
"resources which processes in a cgroup can access. For example, cpusets (see "
"Documentation/admin-guide/cgroup-v1/cpusets.rst) allow you to associate a "
"set of CPUs and a set of memory nodes with the tasks in each cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:86
msgid "1.2 Why are cgroups needed ?"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:88
msgid ""
"There are multiple efforts to provide process aggregations in the Linux "
"kernel, mainly for resource-tracking purposes. Such efforts include cpusets, "
"CKRM/ResGroups, UserBeanCounters, and virtual server namespaces. These all "
"require the basic notion of a grouping/partitioning of processes, with newly "
"forked processes ending up in the same group (cgroup) as their parent "
"process."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:95
msgid ""
"The kernel cgroup patch provides the minimum essential kernel mechanisms "
"required to efficiently implement such groups. It has minimal impact on the "
"system fast paths, and provides hooks for specific subsystems such as "
"cpusets to provide additional behaviour as desired."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:101
msgid ""
"Multiple hierarchy support is provided to allow for situations where the "
"division of tasks into cgroups is distinctly different for different "
"subsystems - having parallel hierarchies allows each hierarchy to be a "
"natural division of tasks, without having to handle complex combinations of "
"tasks that would be present if several unrelated subsystems needed to be "
"forced into the same tree of cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:109
msgid ""
"At one extreme, each resource controller or subsystem could be in a separate "
"hierarchy; at the other extreme, all subsystems would be attached to the "
"same hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:113
msgid ""
"As an example of a scenario (originally proposed by vatsa@in.ibm.com) that "
"can benefit from multiple hierarchies, consider a large university server "
"with various users - students, professors, system tasks etc. The resource "
"planning for this server could be along the following lines::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:136
msgid ""
"Browsers like Firefox/Lynx go into the WWW network class, while (k)nfsd goes "
"into the NFS network class."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:139
msgid ""
"At the same time Firefox/Lynx will share an appropriate CPU/Memory class "
"depending on who launched it (prof/student)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:142
msgid ""
"With the ability to classify tasks differently for different resources (by "
"putting those resource subsystems in different hierarchies), the admin can "
"easily set up a script which receives exec notifications and depending on "
"who is launching the browser he can::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:149
msgid ""
"With only a single hierarchy, he now would potentially have to create a "
"separate cgroup for every browser launched and associate it with appropriate "
"network and other resource class.  This may lead to proliferation of such "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:154
msgid ""
"Also let's say that the administrator would like to give enhanced network "
"access temporarily to a student's browser (since it is night and the user "
"wants to do online gaming :))  OR give one of the student's simulation apps "
"enhanced CPU power."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:159
msgid ""
"With ability to write PIDs directly to resource classes, it's just a matter "
"of::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:166
msgid ""
"Without this ability, the administrator would have to split the cgroup into "
"multiple separate ones and then associate the new cgroups with the new "
"resource classes."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:173
msgid "1.3 How are cgroups implemented ?"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:175
msgid "Control Groups extends the kernel as follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:177
msgid "Each task in the system has a reference-counted pointer to a css_set."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:180
msgid ""
"A css_set contains a set of reference-counted pointers to "
"cgroup_subsys_state objects, one for each cgroup subsystem registered in the "
"system. There is no direct link from a task to the cgroup of which it's a "
"member in each hierarchy, but this can be determined by following pointers "
"through the cgroup_subsys_state objects. This is because accessing the "
"subsystem state is something that's expected to happen frequently and in "
"performance-critical code, whereas operations that require a task's actual "
"cgroup assignments (in particular, moving between cgroups) are less common. "
"A linked list runs through the cg_list field of each task_struct using the "
"css_set, anchored at css_set->tasks."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:193
msgid ""
"A cgroup hierarchy filesystem can be mounted for browsing and manipulation "
"from user space."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:196
msgid "You can list all the tasks (by PID) attached to any cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:198
msgid ""
"The implementation of cgroups requires a few, simple hooks into the rest of "
"the kernel, none in performance-critical paths:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:201
msgid ""
"in init/main.c, to initialize the root cgroups and initial css_set at system "
"boot."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:204
msgid "in fork and exit, to attach and detach a task from its css_set."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:206
msgid ""
"In addition, a new file system of type \"cgroup\" may be mounted, to enable "
"browsing and modifying the cgroups presently known to the kernel.  When "
"mounting a cgroup hierarchy, you may specify a comma-separated list of "
"subsystems to mount as the filesystem mount options.  By default, mounting "
"the cgroup filesystem attempts to mount a hierarchy containing all "
"registered subsystems."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:213
msgid ""
"If an active hierarchy with exactly the same set of subsystems already "
"exists, it will be reused for the new mount. If no existing hierarchy "
"matches, and any of the requested subsystems are in use in an existing "
"hierarchy, the mount will fail with -EBUSY. Otherwise, a new hierarchy is "
"activated, associated with the requested subsystems."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:219
msgid ""
"It's not currently possible to bind a new subsystem to an active cgroup "
"hierarchy, or to unbind a subsystem from an active cgroup hierarchy. This "
"may be possible in future, but is fraught with nasty error-recovery issues."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:224
msgid ""
"When a cgroup filesystem is unmounted, if there are any child cgroups "
"created below the top-level cgroup, that hierarchy will remain active even "
"though unmounted; if there are no child cgroups then the hierarchy will be "
"deactivated."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:229
msgid ""
"No new system calls are added for cgroups - all support for querying and "
"modifying cgroups is via this cgroup file system."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:232
msgid ""
"Each task under /proc has an added file named 'cgroup' displaying, for each "
"active hierarchy, the subsystem names and the cgroup name as the path "
"relative to the root of the cgroup file system."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:236
msgid ""
"Each cgroup is represented by a directory in the cgroup file system "
"containing the following files describing that cgroup:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:239
msgid ""
"tasks: list of tasks (by PID) attached to that cgroup.  This list is not "
"guaranteed to be sorted.  Writing a thread ID into this file moves the "
"thread into this cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:242
msgid ""
"cgroup.procs: list of thread group IDs in the cgroup.  This list is not "
"guaranteed to be sorted or free of duplicate TGIDs, and userspace should "
"sort/uniquify the list if this property is required. Writing a thread group "
"ID into this file moves all threads in that group into this cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:247
msgid "notify_on_release flag: run the release agent on exit?"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:248
msgid ""
"release_agent: the path to use for release notifications (this file exists "
"in the top cgroup only)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:251
msgid ""
"Other subsystems such as cpusets may add additional files in each cgroup dir."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:254
msgid ""
"New cgroups are created using the mkdir system call or shell command.  The "
"properties of a cgroup, such as its flags, are modified by writing to the "
"appropriate file in that cgroups directory, as listed above."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:259
msgid ""
"The named hierarchical structure of nested cgroups allows partitioning a "
"large system into nested, dynamically changeable, \"soft-partitions\"."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:262
msgid ""
"The attachment of each task, automatically inherited at fork by any children "
"of that task, to a cgroup allows organizing the work load on a system into "
"related sets of tasks.  A task may be re-attached to any other cgroup, if "
"allowed by the permissions on the necessary cgroup file system directories."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:268
msgid ""
"When a task is moved from one cgroup to another, it gets a new css_set "
"pointer - if there's an already existing css_set with the desired collection "
"of cgroups then that group is reused, otherwise a new css_set is allocated. "
"The appropriate existing css_set is located by looking into a hash table."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:274
msgid ""
"To allow access from a cgroup to the css_sets (and hence tasks) that "
"comprise it, a set of cg_cgroup_link objects form a lattice; each "
"cg_cgroup_link is linked into a list of cg_cgroup_links for a single cgroup "
"on its cgrp_link_list field, and a list of cg_cgroup_links for a single "
"css_set on its cg_link_list."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:280
msgid ""
"Thus the set of tasks in a cgroup can be listed by iterating over each "
"css_set that references the cgroup, and sub-iterating over each css_set's "
"task set."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:284
msgid ""
"The use of a Linux virtual file system (vfs) to represent the cgroup "
"hierarchy provides for a familiar permission and name space for cgroups, "
"with a minimum of additional kernel code."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:289
msgid "1.4 What does notify_on_release do ?"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:291
msgid ""
"If the notify_on_release flag is enabled (1) in a cgroup, then whenever the "
"last task in the cgroup leaves (exits or attaches to some other cgroup) and "
"the last child cgroup of that cgroup is removed, then the kernel runs the "
"command specified by the contents of the \"release_agent\" file in that "
"hierarchy's root directory, supplying the pathname (relative to the mount "
"point of the cgroup file system) of the abandoned cgroup.  This enables "
"automatic removal of abandoned cgroups.  The default value of "
"notify_on_release in the root cgroup at system boot is disabled (0).  The "
"default value of other cgroups at creation is the current value of their "
"parents' notify_on_release settings. The default value of a cgroup "
"hierarchy's release_agent path is empty."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:305
msgid "1.5 What does clone_children do ?"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:307
msgid ""
"This flag only affects the cpuset controller. If the clone_children flag is "
"enabled (1) in a cgroup, a new cpuset cgroup will copy its configuration "
"from the parent during initialization."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:312
msgid "1.6 How do I use cgroups ?"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:314
msgid ""
"To start a new job that is to be contained within a cgroup, using the "
"\"cpuset\" cgroup subsystem, the steps are something like::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:327
msgid ""
"For example, the following sequence of commands will setup a cgroup named "
"\"Charlie\", containing just CPUs 2 and 3, and Memory Node 1, and then start "
"a subshell 'sh' in that cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:346
msgid "2. Usage Examples and Syntax"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:349
msgid "2.1 Basic Usage"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:351
msgid ""
"Creating, modifying, using cgroups can be done through the cgroup virtual "
"filesystem."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:354
msgid "To mount a cgroup hierarchy with all available subsystems, type::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:358
msgid ""
"The \"xxx\" is not interpreted by the cgroup code, but will appear in /proc/"
"mounts so may be any useful identifying string that you like."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:361
msgid ""
"Note: Some subsystems do not work without some user input first.  For "
"instance, if cpusets are enabled the user will have to populate the cpus and "
"mems files for each new cgroup created before that group can be used."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:365
msgid ""
"As explained in section `1.2 Why are cgroups needed?` you should create "
"different hierarchies of cgroups for each single resource or group of "
"resources you want to control. Therefore, you should mount a tmpfs on /sys/"
"fs/cgroup and create directories for each cgroup resource or resource group::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:374
msgid ""
"To mount a cgroup hierarchy with just the cpuset and memory subsystems, "
"type::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:379
msgid ""
"While remounting cgroups is currently supported, it is not recommend to use "
"it. Remounting allows changing bound subsystems and release_agent. Rebinding "
"is hardly useful as it only works when the hierarchy is empty and "
"release_agent itself should be replaced with conventional fsnotify. The "
"support for remounting will be removed in the future."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:386
msgid "To Specify a hierarchy's release_agent::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:391
msgid ""
"Note that specifying 'release_agent' more than once will return failure."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:393
msgid ""
"Note that changing the set of subsystems is currently only supported when "
"the hierarchy consists of a single (root) cgroup. Supporting the ability to "
"arbitrarily bind/unbind subsystems from an existing cgroup hierarchy is "
"intended to be implemented in the future."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:398
msgid ""
"Then under /sys/fs/cgroup/rg1 you can find a tree that corresponds to the "
"tree of the cgroups in the system. For instance, /sys/fs/cgroup/rg1 is the "
"cgroup that holds the whole system."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:402
msgid "If you want to change the value of release_agent::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:406
msgid "It can also be changed via remount."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:408
msgid "If you want to create a new cgroup under /sys/fs/cgroup/rg1::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:413
msgid "Now you want to do something with this cgroup:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:415
msgid "# cd my_cgroup"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:417
msgid "In this directory you can find several files::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:423
msgid "Now attach your shell to this cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:427
msgid ""
"You can also create cgroups inside your cgroup by using mkdir in this "
"directory::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:432
msgid "To remove a cgroup, just use rmdir::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:436
msgid ""
"This will fail if the cgroup is in use (has cgroups inside, or has processes "
"attached, or is held alive by other subsystem-specific reference)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:441
msgid "2.2 Attaching processes"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:447
msgid ""
"Note that it is PID, not PIDs. You can only attach ONE task at a time. If "
"you have several tasks to attach, you have to do it one after another::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:455
msgid "You can attach the current shell task by echoing 0::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:459
msgid ""
"You can use the cgroup.procs file instead of the tasks file to move all "
"threads in a threadgroup at once. Echoing the PID of any task in a "
"threadgroup to cgroup.procs causes all tasks in that threadgroup to be "
"attached to the cgroup. Writing 0 to cgroup.procs moves all tasks in the "
"writing task's threadgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:465
msgid ""
"Note: Since every task is always a member of exactly one cgroup in each "
"mounted hierarchy, to remove a task from its current cgroup you must move it "
"into a new cgroup (possibly the root cgroup) by writing to the new cgroup's "
"tasks file."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:470
msgid ""
"Note: Due to some restrictions enforced by some cgroup subsystems, moving a "
"process to another cgroup can fail."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:474
msgid "2.3 Mounting hierarchies by name"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:476
msgid ""
"Passing the name=<x> option when mounting a cgroups hierarchy associates the "
"given name with the hierarchy.  This can be used when mounting a pre-"
"existing hierarchy, in order to refer to it by name rather than by its set "
"of active subsystems.  Each hierarchy is either nameless, or has a unique "
"name."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:482
msgid "The name should match [\\w.-]+"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:484
msgid ""
"When passing a name=<x> option for a new hierarchy, you need to specify "
"subsystems manually; the legacy behaviour of mounting all subsystems when "
"none are explicitly specified is not supported when you give a subsystem a "
"name."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:489
msgid ""
"The name of the subsystem appears as part of the hierarchy description in /"
"proc/mounts and /proc/<pid>/cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:494
msgid "3. Kernel API"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:497
msgid "3.1 Overview"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:499
msgid ""
"Each kernel subsystem that wants to hook into the generic cgroup system "
"needs to create a cgroup_subsys object. This contains various methods, which "
"are callbacks from the cgroup system, along with a subsystem ID which will "
"be assigned by the cgroup system."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:504
msgid "Other fields in the cgroup_subsys object include:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:506
msgid ""
"subsys_id: a unique array index for the subsystem, indicating which entry in "
"cgroup->subsys[] this subsystem should be managing."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:509
msgid ""
"name: should be initialized to a unique subsystem name. Should be no longer "
"than MAX_CGROUP_TYPE_NAMELEN."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:512
msgid ""
"early_init: indicate if the subsystem needs early initialization at system "
"boot."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:515
msgid ""
"Each cgroup object created by the system has an array of pointers, indexed "
"by subsystem ID; this pointer is entirely managed by the subsystem; the "
"generic cgroup code will never touch this pointer."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:520
msgid "3.2 Synchronization"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:522
msgid ""
"There is a global mutex, cgroup_mutex, used by the cgroup system. This "
"should be taken by anything that wants to modify a cgroup. It may also be "
"taken to prevent cgroups from being modified, but more specific locks may be "
"more appropriate in that situation."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:528
msgid "See kernel/cgroup.c for more details."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:530
msgid ""
"Subsystems can take/release the cgroup_mutex via the functions cgroup_lock()/"
"cgroup_unlock()."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:533
msgid ""
"Accessing a task's cgroup pointer may be done in the following ways: - while "
"holding cgroup_mutex - while holding the task's alloc_lock (via task_lock()) "
"- inside an rcu_read_lock() section via rcu_dereference()"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:539
msgid "3.3 Subsystem API"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:541
msgid "Each subsystem should:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:543
msgid "add an entry in linux/cgroup_subsys.h"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:544
msgid "define a cgroup_subsys object called <name>_cgrp_subsys"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:546
msgid ""
"Each subsystem may export the following methods. The only mandatory methods "
"are css_alloc/free. Any others that are null are presumed to be successful "
"no-ops."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:550
msgid ""
"``struct cgroup_subsys_state *css_alloc(struct cgroup *cgrp)`` (cgroup_mutex "
"held by caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:553
msgid ""
"Called to allocate a subsystem state object for a cgroup. The subsystem "
"should allocate its subsystem state object for the passed cgroup, returning "
"a pointer to the new object on success or a ERR_PTR() value. On success, the "
"subsystem pointer should point to a structure of type cgroup_subsys_state "
"(typically embedded in a larger subsystem-specific object), which will be "
"initialized by the cgroup system. Note that this will be called at "
"initialization to create the root subsystem state for this subsystem; this "
"case can be identified by the passed cgroup object having a NULL parent "
"(since it's the root of the hierarchy) and may be an appropriate place for "
"initialization code."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:565
msgid "``int css_online(struct cgroup *cgrp)`` (cgroup_mutex held by caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:568
msgid ""
"Called after @cgrp successfully completed all allocations and made visible "
"to cgroup_for_each_child/descendant_*() iterators. The subsystem may choose "
"to fail creation by returning -errno. This callback can be used to implement "
"reliable state sharing and propagation along the hierarchy. See the comment "
"on cgroup_for_each_live_descendant_pre() for details."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:575
msgid ""
"``void css_offline(struct cgroup *cgrp);`` (cgroup_mutex held by caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:578
msgid ""
"This is the counterpart of css_online() and called iff css_online() has "
"succeeded on @cgrp. This signifies the beginning of the end of @cgrp. @cgrp "
"is being removed and the subsystem should start dropping all references it's "
"holding on @cgrp. When all references are dropped, cgroup removal will "
"proceed to the next step - css_free(). After this callback, @cgrp should be "
"considered dead to the subsystem."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:585
msgid "``void css_free(struct cgroup *cgrp)`` (cgroup_mutex held by caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:588
msgid ""
"The cgroup system is about to free @cgrp; the subsystem should free its "
"subsystem state object. By the time this method is called, @cgrp is "
"completely unused; @cgrp->parent is still valid. (Note - can also be called "
"for a newly-created cgroup if an error occurs after this subsystem's "
"create() method has been called for the new cgroup)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:594
msgid ""
"``int can_attach(struct cgroup *cgrp, struct cgroup_taskset *tset)`` "
"(cgroup_mutex held by caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:597
msgid ""
"Called prior to moving one or more tasks into a cgroup; if the subsystem "
"returns an error, this will abort the attach operation. @tset contains the "
"tasks to be attached and is guaranteed to have at least one task in it."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:602
msgid "If there are multiple tasks in the taskset, then:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:603
msgid "it's guaranteed that all are from the same thread group"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:604
msgid ""
"@tset contains all tasks from the thread group whether or not they're "
"switching cgroups"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:606
msgid "the first task is the leader"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:608
msgid ""
"Each @tset entry also contains the task's old cgroup and tasks which aren't "
"switching cgroup can be skipped easily using the cgroup_taskset_for_each() "
"iterator. Note that this isn't called on a fork. If this method returns 0 "
"(success) then this should remain valid while the caller holds cgroup_mutex "
"and it is ensured that either attach() or cancel_attach() will be called in "
"future."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:615
msgid ""
"``void css_reset(struct cgroup_subsys_state *css)`` (cgroup_mutex held by "
"caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:618
msgid ""
"An optional operation which should restore @css's configuration to the "
"initial state.  This is currently only used on the unified hierarchy when a "
"subsystem is disabled on a cgroup through \"cgroup.subtree_control\" but "
"should remain enabled because other subsystems depend on it.  cgroup core "
"makes such a css invisible by removing the associated interface files and "
"invokes this callback so that the hidden subsystem can return to the initial "
"neutral state. This prevents unexpected resource control from a hidden css "
"and ensures that the configuration is in the initial state when it is made "
"visible again later."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:629
msgid ""
"``void cancel_attach(struct cgroup *cgrp, struct cgroup_taskset *tset)`` "
"(cgroup_mutex held by caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:632
msgid ""
"Called when a task attach operation has failed after can_attach() has "
"succeeded. A subsystem whose can_attach() has some side-effects should "
"provide this function, so that the subsystem can implement a rollback. If "
"not, not necessary. This will be called only about subsystems whose "
"can_attach() operation have succeeded. The parameters are identical to "
"can_attach()."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:638
msgid ""
"``void attach(struct cgroup *cgrp, struct cgroup_taskset *tset)`` "
"(cgroup_mutex held by caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:641
msgid ""
"Called after the task has been attached to the cgroup, to allow any post-"
"attachment activity that requires memory allocations or blocking. The "
"parameters are identical to can_attach()."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:645
msgid "``void fork(struct task_struct *task)``"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:647
msgid "Called when a task is forked into a cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:649
msgid "``void exit(struct task_struct *task)``"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:651
msgid "Called during task exit."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:653
msgid "``void free(struct task_struct *task)``"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:655
msgid "Called when the task_struct is freed."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:657
msgid "``void bind(struct cgroup *root)`` (cgroup_mutex held by caller)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:660
msgid ""
"Called when a cgroup subsystem is rebound to a different hierarchy and root "
"cgroup. Currently this will only involve movement between the default "
"hierarchy (which never has sub-cgroups) and a hierarchy that is being "
"created/destroyed (and hence has no sub-cgroups)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:666
msgid "4. Extended attribute usage"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:668
msgid ""
"cgroup filesystem supports certain types of extended attributes in its "
"directories and files.  The current supported types are:"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:671
msgid "Trusted (XATTR_TRUSTED)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:672
msgid "Security (XATTR_SECURITY)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:674
msgid "Both require CAP_SYS_ADMIN capability to set."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:676
msgid ""
"Like in tmpfs, the extended attributes in cgroup filesystem are stored using "
"kernel memory and it's advised to keep the usage at minimum.  This is the "
"reason why user defined extended attributes are not supported, since any "
"user can do it and there's no limit in the value size."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:681
msgid ""
"The current known users for this feature are SELinux to limit cgroup usage "
"in containers and systemd for assorted meta data like main PID in a cgroup "
"(systemd creates a cgroup per service)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/cgroups.rst:686
msgid "5. Questions"
msgstr ""
