# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scsi/scsi_eh.rst:5
msgid "SCSI EH"
msgstr ""

#: ../../../scsi/scsi_eh.rst:7
msgid ""
"This document describes SCSI midlayer error handling infrastructure. Please "
"refer to Documentation/scsi/scsi_mid_low_api.rst for more information "
"regarding SCSI midlayer."
msgstr ""

#: ../../../scsi/scsi_eh.rst:31
msgid "1. How SCSI commands travel through the midlayer and to EH"
msgstr ""

#: ../../../scsi/scsi_eh.rst:34
msgid "1.1 struct scsi_cmnd"
msgstr ""

#: ../../../scsi/scsi_eh.rst:36
msgid ""
"Each SCSI command is represented with struct scsi_cmnd (== scmd).  A scmd "
"has two list_head's to link itself into lists.  The two are scmd->list and "
"scmd->eh_entry.  The former is used for free list or per-device allocated "
"scmd list and not of much interest to this EH discussion.  The latter is "
"used for completion and EH lists and unless otherwise stated scmds are "
"always linked using scmd->eh_entry in this discussion."
msgstr ""

#: ../../../scsi/scsi_eh.rst:46
msgid "1.2 How do scmd's get completed?"
msgstr ""

#: ../../../scsi/scsi_eh.rst:48
msgid ""
"Once LLDD gets hold of a scmd, either the LLDD will complete the command by "
"calling scsi_done callback passed from midlayer when invoking hostt-"
">queuecommand() or the block layer will time it out."
msgstr ""

#: ../../../scsi/scsi_eh.rst:54
msgid "1.2.1 Completing a scmd w/ scsi_done"
msgstr ""

#: ../../../scsi/scsi_eh.rst:56
msgid ""
"For all non-EH commands, scsi_done() is the completion callback.  It just "
"calls blk_mq_complete_request() to delete the block layer timer and raise "
"BLOCK_SOFTIRQ."
msgstr ""

#: ../../../scsi/scsi_eh.rst:60
msgid ""
"The BLOCK_SOFTIRQ indirectly calls scsi_complete(), which calls "
"scsi_decide_disposition() to determine what to do with the command. "
"scsi_decide_disposition() looks at the scmd->result value and sense data to "
"determine what to do with the command."
msgstr ""

#: ../../../scsi/scsi_eh.rst:65 ../../../scsi/scsi_eh.rst:338
msgid "SUCCESS"
msgstr ""

#: ../../../scsi/scsi_eh.rst:67
msgid ""
"scsi_finish_command() is invoked for the command.  The function does some "
"maintenance chores and then calls scsi_io_completion() to finish the I/O. "
"scsi_io_completion() then notifies the block layer on the completed request "
"by calling blk_end_request and friends or figures out what to do with the "
"remainder of the data in case of an error."
msgstr ""

#: ../../../scsi/scsi_eh.rst:75 ../../../scsi/scsi_eh.rst:343
msgid "NEEDS_RETRY"
msgstr ""

#: ../../../scsi/scsi_eh.rst:77
msgid "ADD_TO_MLQUEUE"
msgstr ""

#: ../../../scsi/scsi_eh.rst:79
msgid "scmd is requeued to blk queue."
msgstr ""

#: ../../../scsi/scsi_eh.rst:81 ../../../scsi/scsi_eh.rst:346
msgid "otherwise"
msgstr ""

#: ../../../scsi/scsi_eh.rst:83
msgid ""
"scsi_eh_scmd_add(scmd) is invoked for the command.  See [1-3] for details of "
"this function."
msgstr ""

#: ../../../scsi/scsi_eh.rst:88
msgid "1.2.2 Completing a scmd w/ timeout"
msgstr ""

#: ../../../scsi/scsi_eh.rst:90
msgid ""
"The timeout handler is scsi_timeout().  When a timeout occurs, this function"
msgstr ""

#: ../../../scsi/scsi_eh.rst:92
msgid ""
"invokes optional hostt->eh_timed_out() callback.  Return value can be one of"
msgstr ""

#: ../../../scsi/scsi_eh.rst:95
msgid "SCSI_EH_RESET_TIMER"
msgstr ""

#: ../../../scsi/scsi_eh.rst:96
msgid ""
"This indicates that more time is required to finish the command.  Timer is "
"restarted."
msgstr ""

#: ../../../scsi/scsi_eh.rst:99
msgid "SCSI_EH_NOT_HANDLED"
msgstr ""

#: ../../../scsi/scsi_eh.rst:100
msgid "eh_timed_out() callback did not handle the command. Step #2 is taken."
msgstr ""

#: ../../../scsi/scsi_eh.rst:103
msgid "SCSI_EH_DONE"
msgstr ""

#: ../../../scsi/scsi_eh.rst:104
msgid "eh_timed_out() completed the command."
msgstr ""

#: ../../../scsi/scsi_eh.rst:106
msgid ""
"scsi_abort_command() is invoked to schedule an asynchronous abort which may "
"issue a retry scmd->allowed + 1 times.  Asynchronous aborts are not invoked "
"for commands for which the SCSI_EH_ABORT_SCHEDULED flag is set (this "
"indicates that the command already had been aborted once, and this is a "
"retry which failed), when retries are exceeded, or when the EH deadline is "
"expired. In these cases Step #3 is taken."
msgstr ""

#: ../../../scsi/scsi_eh.rst:113
msgid ""
"scsi_eh_scmd_add(scmd) is invoked for the command.  See [1-4] for more "
"information."
msgstr ""

#: ../../../scsi/scsi_eh.rst:117
msgid "1.3 Asynchronous command aborts"
msgstr ""

#: ../../../scsi/scsi_eh.rst:119
msgid ""
"After a timeout occurs a command abort is scheduled from "
"scsi_abort_command(). If the abort is successful the command will either be "
"retried (if the number of retries is not exhausted) or terminated with "
"DID_TIME_OUT."
msgstr ""

#: ../../../scsi/scsi_eh.rst:124
msgid ""
"Otherwise scsi_eh_scmd_add() is invoked for the command. See [1-4] for more "
"information."
msgstr ""

#: ../../../scsi/scsi_eh.rst:128
msgid "1.4 How EH takes over"
msgstr ""

#: ../../../scsi/scsi_eh.rst:130
msgid "scmds enter EH via scsi_eh_scmd_add(), which does the following."
msgstr ""

#: ../../../scsi/scsi_eh.rst:132
msgid "Links scmd->eh_entry to shost->eh_cmd_q"
msgstr ""

#: ../../../scsi/scsi_eh.rst:134
msgid "Sets SHOST_RECOVERY bit in shost->shost_state"
msgstr ""

#: ../../../scsi/scsi_eh.rst:136
msgid "Increments shost->host_failed"
msgstr ""

#: ../../../scsi/scsi_eh.rst:138
msgid "Wakes up SCSI EH thread if shost->host_busy == shost->host_failed"
msgstr ""

#: ../../../scsi/scsi_eh.rst:140
msgid ""
"As can be seen above, once any scmd is added to shost->eh_cmd_q, "
"SHOST_RECOVERY shost_state bit is turned on.  This prevents any new scmd to "
"be issued from blk queue to the host; eventually, all scmds on the host "
"either complete normally, fail and get added to eh_cmd_q, or time out and "
"get added to shost->eh_cmd_q."
msgstr ""

#: ../../../scsi/scsi_eh.rst:146
msgid ""
"If all scmds either complete or fail, the number of in-flight scmds becomes "
"equal to the number of failed scmds - i.e. shost->host_busy == shost-"
">host_failed.  This wakes up SCSI EH thread.  So, once woken up, SCSI EH "
"thread can expect that all in-flight commands have failed and are linked on "
"shost->eh_cmd_q."
msgstr ""

#: ../../../scsi/scsi_eh.rst:152
msgid ""
"Note that this does not mean lower layers are quiescent.  If a LLDD "
"completed a scmd with error status, the LLDD and lower layers are assumed to "
"forget about the scmd at that point.  However, if a scmd has timed out, "
"unless hostt->eh_timed_out() made lower layers forget about the scmd, which "
"currently no LLDD does, the command is still active as long as lower layers "
"are concerned and completion could occur at any time.  Of course, all such "
"completions are ignored as the timer has already expired."
msgstr ""

#: ../../../scsi/scsi_eh.rst:161
msgid ""
"We'll talk about how SCSI EH takes actions to abort - make LLDD forget about "
"- timed out scmds later."
msgstr ""

#: ../../../scsi/scsi_eh.rst:166
msgid "2. How SCSI EH works"
msgstr ""

#: ../../../scsi/scsi_eh.rst:168
msgid "LLDD's can implement SCSI EH actions in one of the following two ways."
msgstr ""

#: ../../../scsi/scsi_eh.rst:171
msgid "Fine-grained EH callbacks"
msgstr ""

#: ../../../scsi/scsi_eh.rst:172
msgid ""
"LLDD can implement fine-grained EH callbacks and let SCSI midlayer drive "
"error handling and call appropriate callbacks. This will be discussed "
"further in [2-1]."
msgstr ""

#: ../../../scsi/scsi_eh.rst:176
msgid "eh_strategy_handler() callback"
msgstr ""

#: ../../../scsi/scsi_eh.rst:177
msgid ""
"This is one big callback which should perform whole error handling.  As "
"such, it should do all chores the SCSI midlayer performs during recovery.  "
"This will be discussed in [2-2]."
msgstr ""

#: ../../../scsi/scsi_eh.rst:181
msgid ""
"Once recovery is complete, SCSI EH resumes normal operation by calling "
"scsi_restart_operations(), which"
msgstr ""

#: ../../../scsi/scsi_eh.rst:184
msgid "Checks if door locking is needed and locks door."
msgstr ""

#: ../../../scsi/scsi_eh.rst:186
msgid "Clears SHOST_RECOVERY shost_state bit"
msgstr ""

#: ../../../scsi/scsi_eh.rst:188
msgid ""
"Wakes up waiters on shost->host_wait.  This occurs if someone calls "
"scsi_block_when_processing_errors() on the host. (*QUESTION* why is it "
"needed?  All operations will be blocked anyway after it reaches blk queue.)"
msgstr ""

#: ../../../scsi/scsi_eh.rst:193
msgid "Kicks queues in all devices on the host in the asses"
msgstr ""

#: ../../../scsi/scsi_eh.rst:197
msgid "2.1 EH through fine-grained callbacks"
msgstr ""

#: ../../../scsi/scsi_eh.rst:200
msgid "2.1.1 Overview"
msgstr ""

#: ../../../scsi/scsi_eh.rst:202
msgid ""
"If eh_strategy_handler() is not present, SCSI midlayer takes charge of "
"driving error handling.  EH's goals are two - make LLDD, host and device "
"forget about timed out scmds and make them ready for new commands.  A scmd "
"is said to be recovered if the scmd is forgotten by lower layers and lower "
"layers are ready to process or fail the scmd again."
msgstr ""

#: ../../../scsi/scsi_eh.rst:209
msgid ""
"To achieve these goals, EH performs recovery actions with increasing "
"severity.  Some actions are performed by issuing SCSI commands and others "
"are performed by invoking one of the following fine-grained hostt EH "
"callbacks.  Callbacks may be omitted and omitted ones are considered to fail "
"always."
msgstr ""

#: ../../../scsi/scsi_eh.rst:222
msgid ""
"Higher-severity actions are taken only when lower-severity actions cannot "
"recover some of failed scmds.  Also, note that failure of the highest-"
"severity action means EH failure and results in offlining of all unrecovered "
"devices."
msgstr ""

#: ../../../scsi/scsi_eh.rst:227
msgid "During recovery, the following rules are followed"
msgstr ""

#: ../../../scsi/scsi_eh.rst:229
msgid ""
"Recovery actions are performed on failed scmds on the to do list, "
"eh_work_q.  If a recovery action succeeds for a scmd, recovered scmds are "
"removed from eh_work_q."
msgstr ""

#: ../../../scsi/scsi_eh.rst:233
msgid ""
"Note that single recovery action on a scmd can recover multiple scmds.  e.g. "
"resetting a device recovers all failed scmds on the device."
msgstr ""

#: ../../../scsi/scsi_eh.rst:237
msgid ""
"Higher severity actions are taken iff eh_work_q is not empty after lower "
"severity actions are complete."
msgstr ""

#: ../../../scsi/scsi_eh.rst:240
msgid ""
"EH reuses failed scmds to issue commands for recovery.  For timed-out scmds, "
"SCSI EH ensures that LLDD forgets about a scmd before reusing it for EH "
"commands."
msgstr ""

#: ../../../scsi/scsi_eh.rst:244
msgid ""
"When a scmd is recovered, the scmd is moved from eh_work_q to EH local "
"eh_done_q using scsi_eh_finish_cmd().  After all scmds are recovered "
"(eh_work_q is empty), scsi_eh_flush_done_q() is invoked to either retry or "
"error-finish (notify upper layer of failure) recovered scmds."
msgstr ""

#: ../../../scsi/scsi_eh.rst:250
msgid ""
"scmds are retried iff its sdev is still online (not offlined during EH), "
"REQ_FAILFAST is not set and ++scmd->retries is less than scmd->allowed."
msgstr ""

#: ../../../scsi/scsi_eh.rst:256
msgid "2.1.2 Flow of scmds through EH"
msgstr ""

#: ../../../scsi/scsi_eh.rst:258
msgid "Error completion / time out"
msgstr ""

#: ../../../scsi/scsi_eh.rst:0
msgid "ACTION"
msgstr ""

#: ../../../scsi/scsi_eh.rst:260
msgid "scsi_eh_scmd_add() is invoked for scmd"
msgstr ""

#: ../../../scsi/scsi_eh.rst:262
msgid "add scmd to shost->eh_cmd_q"
msgstr ""

#: ../../../scsi/scsi_eh.rst:263
msgid "set SHOST_RECOVERY"
msgstr ""

#: ../../../scsi/scsi_eh.rst:264
msgid "shost->host_failed++"
msgstr ""

#: ../../../scsi/scsi_eh.rst:0
msgid "LOCKING"
msgstr ""

#: ../../../scsi/scsi_eh.rst:266
msgid "shost->host_lock"
msgstr ""

#: ../../../scsi/scsi_eh.rst:268
msgid "EH starts"
msgstr ""

#: ../../../scsi/scsi_eh.rst:270
msgid "move all scmds to EH's local eh_work_q.  shost->eh_cmd_q is cleared."
msgstr ""

#: ../../../scsi/scsi_eh.rst:273
msgid "shost->host_lock (not strictly necessary, just for consistency)"
msgstr ""

#: ../../../scsi/scsi_eh.rst:276
msgid "scmd recovered"
msgstr ""

#: ../../../scsi/scsi_eh.rst:278
msgid "scsi_eh_finish_cmd() is invoked to EH-finish scmd"
msgstr ""

#: ../../../scsi/scsi_eh.rst:280
msgid "move from local eh_work_q to local eh_done_q"
msgstr ""

#: ../../../scsi/scsi_eh.rst:282
msgid "none"
msgstr ""

#: ../../../scsi/scsi_eh.rst:0
msgid "CONCURRENCY"
msgstr ""

#: ../../../scsi/scsi_eh.rst:284
msgid ""
"at most one thread per separate eh_work_q to keep queue manipulation lockless"
msgstr ""

#: ../../../scsi/scsi_eh.rst:287
msgid "EH completes"
msgstr ""

#: ../../../scsi/scsi_eh.rst:289
msgid ""
"scsi_eh_flush_done_q() retries scmds or notifies upper layer of failure. May "
"be called concurrently but must have a no more than one thread per separate "
"eh_work_q to manipulate the queue locklessly"
msgstr ""

#: ../../../scsi/scsi_eh.rst:294
msgid "scmd is removed from eh_done_q and scmd->eh_entry is cleared"
msgstr ""

#: ../../../scsi/scsi_eh.rst:295
msgid "if retry is necessary, scmd is requeued using scsi_queue_insert()"
msgstr ""

#: ../../../scsi/scsi_eh.rst:297
msgid "otherwise, scsi_finish_command() is invoked for scmd"
msgstr ""

#: ../../../scsi/scsi_eh.rst:298
msgid "zero shost->host_failed"
msgstr ""

#: ../../../scsi/scsi_eh.rst:300
msgid "queue or finish function performs appropriate locking"
msgstr ""

#: ../../../scsi/scsi_eh.rst:304
msgid "2.1.3 Flow of control"
msgstr ""

#: ../../../scsi/scsi_eh.rst:306
msgid "EH through fine-grained callbacks start from scsi_unjam_host()."
msgstr ""

#: ../../../scsi/scsi_eh.rst:308
msgid "``scsi_unjam_host``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:310
msgid ""
"Lock shost->host_lock, splice_init shost->eh_cmd_q into local eh_work_q and "
"unlock host_lock.  Note that shost->eh_cmd_q is cleared by this action."
msgstr ""

#: ../../../scsi/scsi_eh.rst:314
msgid "Invoke scsi_eh_get_sense."
msgstr ""

#: ../../../scsi/scsi_eh.rst:316
msgid "``scsi_eh_get_sense``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:318
msgid ""
"This action is taken for each error-completed command without valid sense "
"data.  Most SCSI transports/LLDDs automatically acquire sense data on "
"command failures (autosense).  Autosense is recommended for performance "
"reasons and as sense information could get out of sync between occurrence of "
"CHECK CONDITION and this action."
msgstr ""

#: ../../../scsi/scsi_eh.rst:325
msgid ""
"Note that if autosense is not supported, scmd->sense_buffer contains invalid "
"sense data when error-completing the scmd with scsi_done().  "
"scsi_decide_disposition() always returns FAILED in such cases thus invoking "
"SCSI EH.  When the scmd reaches here, sense data is acquired and "
"scsi_decide_disposition() is called again."
msgstr ""

#: ../../../scsi/scsi_eh.rst:332
msgid ""
"Invoke scsi_request_sense() which issues REQUEST_SENSE command.  If fails, "
"no action.  Note that taking no action causes higher-severity recovery to be "
"taken for the scmd."
msgstr ""

#: ../../../scsi/scsi_eh.rst:336
msgid "Invoke scsi_decide_disposition() on the scmd"
msgstr ""

#: ../../../scsi/scsi_eh.rst:339
msgid ""
"scmd->retries is set to scmd->allowed preventing scsi_eh_flush_done_q() from "
"retrying the scmd and scsi_eh_finish_cmd() is invoked."
msgstr ""

#: ../../../scsi/scsi_eh.rst:344
msgid "scsi_eh_finish_cmd() invoked"
msgstr ""

#: ../../../scsi/scsi_eh.rst:347
msgid "No action."
msgstr ""

#: ../../../scsi/scsi_eh.rst:349
msgid "If !list_empty(&eh_work_q), invoke scsi_eh_ready_devs()"
msgstr ""

#: ../../../scsi/scsi_eh.rst:351
msgid "``scsi_eh_ready_devs``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:353
msgid ""
"This function takes four increasingly more severe measures to make failed "
"sdevs ready for new commands."
msgstr ""

#: ../../../scsi/scsi_eh.rst:356
msgid "Invoke scsi_eh_stu()"
msgstr ""

#: ../../../scsi/scsi_eh.rst:358
msgid "``scsi_eh_stu``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:360
msgid ""
"For each sdev which has failed scmds with valid sense data of which "
"scsi_check_sense()'s verdict is FAILED, START STOP UNIT command is issued w/ "
"start=1.  Note that as we explicitly choose error-completed scmds, it is "
"known that lower layers have forgotten about the scmd and we can reuse it "
"for STU."
msgstr ""

#: ../../../scsi/scsi_eh.rst:367
msgid ""
"If STU succeeds and the sdev is either offline or ready, all failed scmds on "
"the sdev are EH-finished with scsi_eh_finish_cmd()."
msgstr ""

#: ../../../scsi/scsi_eh.rst:371
msgid ""
"*NOTE* If hostt->eh_abort_handler() isn't implemented or failed, we may "
"still have timed out scmds at this point and STU doesn't make lower layers "
"forget about those scmds.  Yet, this function EH-finish all scmds on the "
"sdev if STU succeeds leaving lower layers in an inconsistent state.  It "
"seems that STU action should be taken only when a sdev has no timed out scmd."
msgstr ""

#: ../../../scsi/scsi_eh.rst:379
msgid "If !list_empty(&eh_work_q), invoke scsi_eh_bus_device_reset()."
msgstr ""

#: ../../../scsi/scsi_eh.rst:381
msgid "``scsi_eh_bus_device_reset``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:383
msgid ""
"This action is very similar to scsi_eh_stu() except that, instead of issuing "
"STU, hostt->eh_device_reset_handler() is used.  Also, as we're not issuing "
"SCSI commands and resetting clears all scmds on the sdev, there is no need "
"to choose error-completed scmds."
msgstr ""

#: ../../../scsi/scsi_eh.rst:389
msgid "If !list_empty(&eh_work_q), invoke scsi_eh_bus_reset()"
msgstr ""

#: ../../../scsi/scsi_eh.rst:391
msgid "``scsi_eh_bus_reset``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:393
msgid ""
"hostt->eh_bus_reset_handler() is invoked for each channel with failed "
"scmds.  If bus reset succeeds, all failed scmds on all ready or offline "
"sdevs on the channel are EH-finished."
msgstr ""

#: ../../../scsi/scsi_eh.rst:398
msgid "If !list_empty(&eh_work_q), invoke scsi_eh_host_reset()"
msgstr ""

#: ../../../scsi/scsi_eh.rst:400
msgid "``scsi_eh_host_reset``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:402
msgid ""
"This is the last resort.  hostt->eh_host_reset_handler() is invoked.  If "
"host reset succeeds, all failed scmds on all ready or offline sdevs on the "
"host are EH-finished."
msgstr ""

#: ../../../scsi/scsi_eh.rst:406
msgid "If !list_empty(&eh_work_q), invoke scsi_eh_offline_sdevs()"
msgstr ""

#: ../../../scsi/scsi_eh.rst:408
msgid "``scsi_eh_offline_sdevs``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:410
msgid ""
"Take all sdevs which still have unrecovered scmds offline and EH-finish the "
"scmds."
msgstr ""

#: ../../../scsi/scsi_eh.rst:413
msgid "Invoke scsi_eh_flush_done_q()."
msgstr ""

#: ../../../scsi/scsi_eh.rst:415
msgid "``scsi_eh_flush_done_q``"
msgstr ""

#: ../../../scsi/scsi_eh.rst:417
msgid ""
"At this point all scmds are recovered (or given up) and put on eh_done_q by "
"scsi_eh_finish_cmd().  This function flushes eh_done_q by either retrying or "
"notifying upper layer of failure of the scmds."
msgstr ""

#: ../../../scsi/scsi_eh.rst:424
msgid "2.2 EH through transportt->eh_strategy_handler()"
msgstr ""

#: ../../../scsi/scsi_eh.rst:426
msgid ""
"transportt->eh_strategy_handler() is invoked in the place of "
"scsi_unjam_host() and it is responsible for whole recovery process. On "
"completion, the handler should have made lower layers forget about all "
"failed scmds and either ready for new commands or offline.  Also, it should "
"perform SCSI EH maintenance chores to maintain integrity of SCSI midlayer.  "
"IOW, of the steps described in [2-1-2], all steps except for #1 must be "
"implemented by eh_strategy_handler()."
msgstr ""

#: ../../../scsi/scsi_eh.rst:436
msgid "2.2.1 Pre transportt->eh_strategy_handler() SCSI midlayer conditions"
msgstr ""

#: ../../../scsi/scsi_eh.rst:438
msgid "The following conditions are true on entry to the handler."
msgstr ""

#: ../../../scsi/scsi_eh.rst:440
msgid "Each failed scmd's eh_flags field is set appropriately."
msgstr ""

#: ../../../scsi/scsi_eh.rst:442
msgid "Each failed scmd is linked on scmd->eh_cmd_q by scmd->eh_entry."
msgstr ""

#: ../../../scsi/scsi_eh.rst:444
msgid "SHOST_RECOVERY is set."
msgstr ""

#: ../../../scsi/scsi_eh.rst:446
msgid "shost->host_failed == shost->host_busy"
msgstr ""

#: ../../../scsi/scsi_eh.rst:450
msgid "2.2.2 Post transportt->eh_strategy_handler() SCSI midlayer conditions"
msgstr ""

#: ../../../scsi/scsi_eh.rst:452
msgid "The following conditions must be true on exit from the handler."
msgstr ""

#: ../../../scsi/scsi_eh.rst:454
msgid "shost->host_failed is zero."
msgstr ""

#: ../../../scsi/scsi_eh.rst:456
msgid "shost->eh_cmd_q is cleared."
msgstr ""

#: ../../../scsi/scsi_eh.rst:458
msgid "Each scmd->eh_entry is cleared."
msgstr ""

#: ../../../scsi/scsi_eh.rst:460
msgid ""
"Either scsi_queue_insert() or scsi_finish_command() is called on each scmd.  "
"Note that the handler is free to use scmd->retries and ->allowed to limit "
"the number of retries."
msgstr ""

#: ../../../scsi/scsi_eh.rst:466
msgid "2.2.3 Things to consider"
msgstr ""

#: ../../../scsi/scsi_eh.rst:468
msgid ""
"Know that timed out scmds are still active on lower layers.  Make lower "
"layers forget about them before doing anything else with those scmds."
msgstr ""

#: ../../../scsi/scsi_eh.rst:472
msgid ""
"For consistency, when accessing/modifying shost data structure, grab shost-"
">host_lock."
msgstr ""

#: ../../../scsi/scsi_eh.rst:475
msgid ""
"On completion, each failed sdev must have forgotten about all active scmds."
msgstr ""

#: ../../../scsi/scsi_eh.rst:478
msgid ""
"On completion, each failed sdev must be ready for new commands or offline."
msgstr ""

#: ../../../scsi/scsi_eh.rst:482
msgid "Tejun Heo htejun@gmail.com"
msgstr ""

#: ../../../scsi/scsi_eh.rst:485
msgid "11th September 2005"
msgstr ""
