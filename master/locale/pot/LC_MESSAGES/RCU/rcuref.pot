# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../RCU/rcuref.rst:5
msgid "Reference-count design for elements of lists/arrays protected by RCU"
msgstr ""

#: ../../../RCU/rcuref.rst:8
msgid ""
"Please note that the percpu-ref feature is likely your first stop if you "
"need to combine reference counts and RCU.  Please see include/linux/percpu-"
"refcount.h for more information.  However, in those unusual cases where "
"percpu-ref would consume too much memory, please read on."
msgstr ""

#: ../../../RCU/rcuref.rst:16
msgid ""
"Reference counting on elements of lists which are protected by traditional "
"reader/writer spinlocks or semaphores are straightforward:"
msgstr ""

#: ../../../RCU/rcuref.rst:19
msgid "CODE LISTING A::"
msgstr ""

#: ../../../RCU/rcuref.rst:47
msgid ""
"If this list/array is made lock free using RCU as in changing the "
"write_lock() in add() and delete() to spin_lock() and changing read_lock() "
"in search_and_reference() to rcu_read_lock(), the atomic_inc() in "
"search_and_reference() could potentially hold reference to an element which "
"has already been deleted from the list/array.  Use atomic_inc_not_zero() in "
"this scenario as follows:"
msgstr ""

#: ../../../RCU/rcuref.rst:54
msgid "CODE LISTING B::"
msgstr ""

#: ../../../RCU/rcuref.rst:81
msgid ""
"Sometimes, a reference to the element needs to be obtained in the update "
"(write) stream.  In such cases, atomic_inc_not_zero() might be overkill, "
"since we hold the update-side spinlock.  One might instead use atomic_inc() "
"in such cases."
msgstr ""

#: ../../../RCU/rcuref.rst:86
msgid ""
"It is not always convenient to deal with \"FAIL\" in the "
"search_and_reference() code path.  In such cases, the atomic_dec_and_test() "
"may be moved from delete() to el_free() as follows:"
msgstr ""

#: ../../../RCU/rcuref.rst:91
msgid "CODE LISTING C::"
msgstr ""

#: ../../../RCU/rcuref.rst:119
msgid ""
"The key point is that the initial reference added by add() is not removed "
"until after a grace period has elapsed following removal.  This means that "
"search_and_reference() cannot find this element, which means that the value "
"of el->rc cannot increase.  Thus, once it reaches zero, there are no readers "
"that can or ever will be able to reference the element.  The element can "
"therefore safely be freed.  This in turn guarantees that if any reader finds "
"the element, that reader may safely acquire a reference without checking the "
"value of the reference counter."
msgstr ""

#: ../../../RCU/rcuref.rst:128
msgid ""
"A clear advantage of the RCU-based pattern in listing C over the one in "
"listing B is that any call to search_and_reference() that locates a given "
"object will succeed in obtaining a reference to that object, even given a "
"concurrent invocation of delete() for that same object. Similarly, a clear "
"advantage of both listings B and C over listing A is that a call to delete() "
"is not delayed even if there are an arbitrarily large number of calls to "
"search_and_reference() searching for the same object that delete() was "
"invoked on.  Instead, all that is delayed is the eventual invocation of "
"kfree(), which is usually not a problem on modern computer systems, even the "
"small ones."
msgstr ""

#: ../../../RCU/rcuref.rst:139
msgid ""
"In cases where delete() can sleep, synchronize_rcu() can be called from "
"delete(), so that el_free() can be subsumed into delete as follows::"
msgstr ""

#: ../../../RCU/rcuref.rst:156
msgid ""
"As additional examples in the kernel, the pattern in listing C is used by "
"reference counting of struct pid, while the pattern in listing B is used by "
"struct posix_acl."
msgstr ""
