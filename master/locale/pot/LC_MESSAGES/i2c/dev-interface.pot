# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../i2c/dev-interface.rst:3
msgid "Implementing I2C device drivers in userspace"
msgstr ""

#: ../../../i2c/dev-interface.rst:5
msgid ""
"Usually, I2C devices are controlled by a kernel driver. But it is also "
"possible to access all devices on an adapter from userspace, through the /"
"dev interface. You need to load module i2c-dev for this."
msgstr ""

#: ../../../i2c/dev-interface.rst:9
msgid ""
"Each registered I2C adapter gets a number, counting from 0. You can examine /"
"sys/class/i2c-dev/ to see what number corresponds to which adapter. "
"Alternatively, you can run \"i2cdetect -l\" to obtain a formatted list of "
"all I2C adapters present on your system at a given time. i2cdetect is part "
"of the i2c-tools package."
msgstr ""

#: ../../../i2c/dev-interface.rst:15
msgid ""
"I2C device files are character device files with major device number 89 and "
"a minor device number corresponding to the number assigned as explained "
"above. They should be called \"i2c-%d\" (i2c-0, i2c-1, ..., i2c-10, ...). "
"All 256 minor device numbers are reserved for I2C."
msgstr ""

#: ../../../i2c/dev-interface.rst:22
msgid "C example"
msgstr ""

#: ../../../i2c/dev-interface.rst:24
msgid ""
"So let's say you want to access an I2C adapter from a C program. First, you "
"need to include these two headers::"
msgstr ""

#: ../../../i2c/dev-interface.rst:30
msgid ""
"Now, you have to decide which adapter you want to access. You should "
"inspect /sys/class/i2c-dev/ or run \"i2cdetect -l\" to decide this. Adapter "
"numbers are assigned somewhat dynamically, so you can not assume much about "
"them. They can even change from one boot to the next."
msgstr ""

#: ../../../i2c/dev-interface.rst:35
msgid "Next thing, open the device file, as follows::"
msgstr ""

#: ../../../i2c/dev-interface.rst:48
msgid ""
"When you have opened the device, you must specify with what device address "
"you want to communicate::"
msgstr ""

#: ../../../i2c/dev-interface.rst:58
msgid ""
"Well, you are all set up now. You can now use SMBus commands or plain I2C to "
"communicate with your device. SMBus commands are preferred if the device "
"supports them. Both are illustrated below::"
msgstr ""

#: ../../../i2c/dev-interface.rst:92
msgid ""
"Note that only a subset of the I2C and SMBus protocols can be achieved by "
"the means of read() and write() calls. In particular, so-called combined "
"transactions (mixing read and write messages in the same transaction) aren't "
"supported. For this reason, this interface is almost never used by user-"
"space programs."
msgstr ""

#: ../../../i2c/dev-interface.rst:98
msgid ""
"IMPORTANT: because of the use of inline functions, you *have* to use '-O' or "
"some variation when you compile your program!"
msgstr ""

#: ../../../i2c/dev-interface.rst:103
msgid "Full interface description"
msgstr ""

#: ../../../i2c/dev-interface.rst:105
msgid "The following IOCTLs are defined:"
msgstr ""

#: ../../../i2c/dev-interface.rst:107
msgid "``ioctl(file, I2C_SLAVE, long addr)``"
msgstr ""

#: ../../../i2c/dev-interface.rst:108
msgid ""
"Change slave address. The address is passed in the 7 lower bits of the "
"argument (except for 10 bit addresses, passed in the 10 lower bits in this "
"case)."
msgstr ""

#: ../../../i2c/dev-interface.rst:112
msgid "``ioctl(file, I2C_TENBIT, long select)``"
msgstr ""

#: ../../../i2c/dev-interface.rst:113
msgid ""
"Selects ten bit addresses if select not equals 0, selects normal 7 bit "
"addresses if select equals 0. Default 0.  This request is only valid if the "
"adapter has I2C_FUNC_10BIT_ADDR."
msgstr ""

#: ../../../i2c/dev-interface.rst:117
msgid "``ioctl(file, I2C_PEC, long select)``"
msgstr ""

#: ../../../i2c/dev-interface.rst:118
msgid ""
"Selects SMBus PEC (packet error checking) generation and verification if "
"select not equals 0, disables if select equals 0. Default 0. Used only for "
"SMBus transactions.  This request only has an effect if the the adapter has "
"I2C_FUNC_SMBUS_PEC; it is still safe if not, it just doesn't have any effect."
msgstr ""

#: ../../../i2c/dev-interface.rst:124
msgid "``ioctl(file, I2C_FUNCS, unsigned long *funcs)``"
msgstr ""

#: ../../../i2c/dev-interface.rst:125
msgid "Gets the adapter functionality and puts it in ``*funcs``."
msgstr ""

#: ../../../i2c/dev-interface.rst:127
msgid "``ioctl(file, I2C_RDWR, struct i2c_rdwr_ioctl_data *msgset)``"
msgstr ""

#: ../../../i2c/dev-interface.rst:128
msgid ""
"Do combined read/write transaction without stop in between. Only valid if "
"the adapter has I2C_FUNC_I2C.  The argument is a pointer to a::"
msgstr ""

#: ../../../i2c/dev-interface.rst:137
msgid ""
"The msgs[] themselves contain further pointers into data buffers. The "
"function will write or read data to or from that buffers depending on "
"whether the I2C_M_RD flag is set in a particular message or not. The slave "
"address and whether to use ten bit address mode has to be set in each "
"message, overriding the values set with the above ioctl's."
msgstr ""

#: ../../../i2c/dev-interface.rst:143
msgid "``ioctl(file, I2C_SMBUS, struct i2c_smbus_ioctl_data *args)``"
msgstr ""

#: ../../../i2c/dev-interface.rst:144
msgid ""
"If possible, use the provided ``i2c_smbus_*`` methods described below "
"instead of issuing direct ioctls."
msgstr ""

#: ../../../i2c/dev-interface.rst:147
msgid ""
"You can do plain I2C transactions by using read(2) and write(2) calls. You "
"do not need to pass the address byte; instead, set it through ioctl "
"I2C_SLAVE before you try to access the device."
msgstr ""

#: ../../../i2c/dev-interface.rst:151
msgid ""
"You can do SMBus level transactions (see documentation file smbus-protocol."
"rst for details) through the following functions::"
msgstr ""

#: ../../../i2c/dev-interface.rst:168
msgid ""
"All these transactions return -1 on failure; you can read errno to see what "
"happened. The 'write' transactions return 0 on success; the 'read' "
"transactions return the read value, except for read_block, which returns the "
"number of values read. The block buffers need not be longer than 32 bytes."
msgstr ""

#: ../../../i2c/dev-interface.rst:174
msgid ""
"The above functions are made available by linking against the libi2c "
"library, which is provided by the i2c-tools project.  See: https://git."
"kernel.org/pub/scm/utils/i2c-tools/i2c-tools.git/."
msgstr ""

#: ../../../i2c/dev-interface.rst:180
msgid "Implementation details"
msgstr ""

#: ../../../i2c/dev-interface.rst:182
msgid ""
"For the interested, here's the code flow which happens inside the kernel "
"when you use the /dev interface to I2C:"
msgstr ""

#: ../../../i2c/dev-interface.rst:185
msgid ""
"Your program opens /dev/i2c-N and calls ioctl() on it, as described in "
"section \"C example\" above."
msgstr ""

#: ../../../i2c/dev-interface.rst:188
msgid ""
"These open() and ioctl() calls are handled by the i2c-dev kernel driver: see "
"i2c-dev.c:i2cdev_open() and i2c-dev.c:i2cdev_ioctl(), respectively. You can "
"think of i2c-dev as a generic I2C chip driver that can be programmed from "
"user-space."
msgstr ""

#: ../../../i2c/dev-interface.rst:193
msgid ""
"Some ioctl() calls are for administrative tasks and are handled by i2c-dev "
"directly. Examples include I2C_SLAVE (set the address of the device you want "
"to access) and I2C_PEC (enable or disable SMBus error checking on future "
"transactions.)"
msgstr ""

#: ../../../i2c/dev-interface.rst:198
msgid ""
"Other ioctl() calls are converted to in-kernel function calls by i2c-dev. "
"Examples include I2C_FUNCS, which queries the I2C adapter functionality "
"using i2c.h:i2c_get_functionality(), and I2C_SMBUS, which performs an SMBus "
"transaction using i2c-core-smbus.c:i2c_smbus_xfer()."
msgstr ""

#: ../../../i2c/dev-interface.rst:203
msgid ""
"The i2c-dev driver is responsible for checking all the parameters that come "
"from user-space for validity. After this point, there is no difference "
"between these calls that came from user-space through i2c-dev and calls that "
"would have been performed by kernel I2C chip drivers directly. This means "
"that I2C bus drivers don't need to implement anything special to support "
"access from user-space."
msgstr ""

#: ../../../i2c/dev-interface.rst:210
msgid ""
"These i2c.h functions are wrappers to the actual implementation of your I2C "
"bus driver. Each adapter must declare callback functions implementing these "
"standard calls. i2c.h:i2c_get_functionality() calls i2c_adapter.algo-"
">functionality(), while i2c-core-smbus.c:i2c_smbus_xfer() calls either "
"adapter.algo->smbus_xfer() if it is implemented, or if not, i2c-core-smbus.c:"
"i2c_smbus_xfer_emulated() which in turn calls i2c_adapter.algo-"
">master_xfer()."
msgstr ""

#: ../../../i2c/dev-interface.rst:219
msgid ""
"After your I2C bus driver has processed these requests, execution runs up "
"the call chain, with almost no processing done, except by i2c-dev to package "
"the returned data, if any, in suitable format for the ioctl."
msgstr ""
