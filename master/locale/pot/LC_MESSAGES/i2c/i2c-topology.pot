# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../i2c/i2c-topology.rst:3
msgid "I2C muxes and complex topologies"
msgstr ""

#: ../../../i2c/i2c-topology.rst:5
msgid ""
"There are a couple of reasons for building more complex I2C topologies than "
"a straight-forward I2C bus with one adapter and one or more devices."
msgstr ""

#: ../../../i2c/i2c-topology.rst:8
msgid "Some example use cases are:"
msgstr ""

#: ../../../i2c/i2c-topology.rst:10
msgid "A mux may be needed on the bus to prevent address collisions."
msgstr ""

#: ../../../i2c/i2c-topology.rst:12
msgid ""
"The bus may be accessible from some external bus master, and arbitration may "
"be needed to determine if it is ok to access the bus."
msgstr ""

#: ../../../i2c/i2c-topology.rst:15
msgid ""
"A device (particularly RF tuners) may want to avoid the digital noise from "
"the I2C bus, at least most of the time, and sits behind a gate that has to "
"be operated before the device can be accessed."
msgstr ""

#: ../../../i2c/i2c-topology.rst:19
msgid ""
"Several types of hardware components such as I2C muxes, I2C gates and I2C "
"arbitrators allow to handle such needs."
msgstr ""

#: ../../../i2c/i2c-topology.rst:22
msgid ""
"These components are represented as I2C adapter trees by Linux, where each "
"adapter has a parent adapter (except the root adapter) and zero or more "
"child adapters. The root adapter is the actual adapter that issues I2C "
"transfers, and all adapters with a parent are part of an \"i2c-mux\" object "
"(quoted, since it can also be an arbitrator or a gate)."
msgstr ""

#: ../../../i2c/i2c-topology.rst:28
msgid ""
"Depending of the particular mux driver, something happens when there is an "
"I2C transfer on one of its child adapters. The mux driver can obviously "
"operate a mux, but it can also do arbitration with an external bus master or "
"open a gate. The mux driver has two operations for this, select and "
"deselect. select is called before the transfer and (the optional) deselect "
"is called after the transfer."
msgstr ""

#: ../../../i2c/i2c-topology.rst:37
msgid "Locking"
msgstr ""

#: ../../../i2c/i2c-topology.rst:39
msgid ""
"There are two variants of locking available to I2C muxes, they can be mux-"
"locked or parent-locked muxes."
msgstr ""

#: ../../../i2c/i2c-topology.rst:44
msgid "Mux-locked muxes"
msgstr ""

#: ../../../i2c/i2c-topology.rst:46
msgid ""
"Mux-locked muxes does not lock the entire parent adapter during the full "
"select-transfer-deselect transaction, only the muxes on the parent adapter "
"are locked. Mux-locked muxes are mostly interesting if the select and/or "
"deselect operations must use I2C transfers to complete their tasks. Since "
"the parent adapter is not fully locked during the full transaction, "
"unrelated I2C transfers may interleave the different stages of the "
"transaction. This has the benefit that the mux driver may be easier and "
"cleaner to implement, but it has some caveats."
msgstr ""

#: ../../../i2c/i2c-topology.rst:56
msgid "Mux-locked Example"
msgstr ""

#: ../../../i2c/i2c-topology.rst:69 ../../../i2c/i2c-topology.rst:148
msgid "When there is an access to D1, this happens:"
msgstr ""

#: ../../../i2c/i2c-topology.rst:71 ../../../i2c/i2c-topology.rst:150
msgid "Someone issues an I2C transfer to D1."
msgstr ""

#: ../../../i2c/i2c-topology.rst:72 ../../../i2c/i2c-topology.rst:151
msgid "M1 locks muxes on its parent (the root adapter in this case)."
msgstr ""

#: ../../../i2c/i2c-topology.rst:73 ../../../i2c/i2c-topology.rst:153
msgid "M1 calls ->select to ready the mux."
msgstr ""

#: ../../../i2c/i2c-topology.rst:74
msgid ""
"M1 (presumably) does some I2C transfers as part of its select. These "
"transfers are normal I2C transfers that locks the parent adapter."
msgstr ""

#: ../../../i2c/i2c-topology.rst:77
msgid ""
"M1 feeds the I2C transfer from step 1 to its parent adapter as a normal I2C "
"transfer that locks the parent adapter."
msgstr ""

#: ../../../i2c/i2c-topology.rst:79 ../../../i2c/i2c-topology.rst:160
msgid "M1 calls ->deselect, if it has one."
msgstr ""

#: ../../../i2c/i2c-topology.rst:80
msgid "Same rules as in step 4, but for ->deselect."
msgstr ""

#: ../../../i2c/i2c-topology.rst:81 ../../../i2c/i2c-topology.rst:163
msgid "M1 unlocks muxes on its parent."
msgstr ""

#: ../../../i2c/i2c-topology.rst:83
msgid ""
"This means that accesses to D2 are lockout out for the full duration of the "
"entire operation. But accesses to D3 are possibly interleaved at any point."
msgstr ""

#: ../../../i2c/i2c-topology.rst:88
msgid "Mux-locked caveats"
msgstr ""

#: ../../../i2c/i2c-topology.rst:90
msgid "When using a mux-locked mux, be aware of the following restrictions:"
msgstr ""

#: ../../../i2c/i2c-topology.rst:92
msgid "[ML1]"
msgstr ""

#: ../../../i2c/i2c-topology.rst:93
msgid ""
"If you build a topology with a mux-locked mux being the parent of a parent-"
"locked mux, this might break the expectation from the parent-locked mux that "
"the root adapter is locked during the transaction."
msgstr ""

#: ../../../i2c/i2c-topology.rst:98
msgid "[ML2]"
msgstr ""

#: ../../../i2c/i2c-topology.rst:99
msgid ""
"It is not safe to build arbitrary topologies with two (or more) mux-locked "
"muxes that are not siblings, when there are address collisions between the "
"devices on the child adapters of these non-sibling muxes."
msgstr ""

#: ../../../i2c/i2c-topology.rst:104
msgid ""
"I.e. the select-transfer-deselect transaction targeting e.g. device address "
"0x42 behind mux-one may be interleaved with a similar operation targeting "
"device address 0x42 behind mux-two. The intent with such a topology would in "
"this hypothetical example be that mux-one and mux-two should not be selected "
"simultaneously, but mux-locked muxes do not guarantee that in all topologies."
msgstr ""

#: ../../../i2c/i2c-topology.rst:111
msgid "[ML3]"
msgstr ""

#: ../../../i2c/i2c-topology.rst:112
msgid ""
"A mux-locked mux cannot be used by a driver for auto-closing gates/muxes, i."
"e. something that closes automatically after a given number (one, in most "
"cases) of I2C transfers. Unrelated I2C transfers may creep in and close "
"prematurely."
msgstr ""

#: ../../../i2c/i2c-topology.rst:117
msgid "[ML4]"
msgstr ""

#: ../../../i2c/i2c-topology.rst:118
msgid ""
"If any non-I2C operation in the mux driver changes the I2C mux state, the "
"driver has to lock the root adapter during that operation. Otherwise garbage "
"may appear on the bus as seen from devices behind the mux, when an unrelated "
"I2C transfer is in flight during the non-I2C mux-changing operation."
msgstr ""

#: ../../../i2c/i2c-topology.rst:126
msgid "Parent-locked muxes"
msgstr ""

#: ../../../i2c/i2c-topology.rst:128
msgid ""
"Parent-locked muxes lock the parent adapter during the full select- transfer-"
"deselect transaction. The implication is that the mux driver has to ensure "
"that any and all I2C transfers through that parent adapter during the "
"transaction are unlocked I2C transfers (using e.g. __i2c_transfer), or a "
"deadlock will follow."
msgstr ""

#: ../../../i2c/i2c-topology.rst:135
msgid "Parent-locked Example"
msgstr ""

#: ../../../i2c/i2c-topology.rst:152
msgid "M1 locks its parent adapter."
msgstr ""

#: ../../../i2c/i2c-topology.rst:154
msgid ""
"If M1 does any I2C transfers (on this root adapter) as part of its select, "
"those transfers must be unlocked I2C transfers so that they do not deadlock "
"the root adapter."
msgstr ""

#: ../../../i2c/i2c-topology.rst:157
msgid ""
"M1 feeds the I2C transfer from step 1 to the root adapter as an unlocked I2C "
"transfer, so that it does not deadlock the parent adapter."
msgstr ""

#: ../../../i2c/i2c-topology.rst:161
msgid "Same rules as in step 5, but for ->deselect."
msgstr ""

#: ../../../i2c/i2c-topology.rst:162
msgid "M1 unlocks its parent adapter."
msgstr ""

#: ../../../i2c/i2c-topology.rst:165
msgid ""
"This means that accesses to both D2 and D3 are locked out for the full "
"duration of the entire operation."
msgstr ""

#: ../../../i2c/i2c-topology.rst:169
msgid "Parent-locked Caveats"
msgstr ""

#: ../../../i2c/i2c-topology.rst:171
msgid "When using a parent-locked mux, be aware of the following restrictions:"
msgstr ""

#: ../../../i2c/i2c-topology.rst:173
msgid "[PL1]"
msgstr ""

#: ../../../i2c/i2c-topology.rst:174
msgid ""
"If you build a topology with a parent-locked mux being the child of another "
"mux, this might break a possible assumption from the child mux that the root "
"adapter is unused between its select op and the actual transfer (e.g. if the "
"child mux is auto-closing and the parent mux issues I2C transfers as part of "
"its select). This is especially the case if the parent mux is mux-locked, "
"but it may also happen if the parent mux is parent-locked."
msgstr ""

#: ../../../i2c/i2c-topology.rst:182
msgid "[PL2]"
msgstr ""

#: ../../../i2c/i2c-topology.rst:183
msgid ""
"If select/deselect calls out to other subsystems such as gpio, pinctrl, "
"regmap or iio, it is essential that any I2C transfers caused by these "
"subsystems are unlocked. This can be convoluted to accomplish, maybe even "
"impossible if an acceptably clean solution is sought."
msgstr ""

#: ../../../i2c/i2c-topology.rst:191
msgid "Complex Examples"
msgstr ""

#: ../../../i2c/i2c-topology.rst:194
msgid "Parent-locked mux as parent of parent-locked mux"
msgstr ""

#: ../../../i2c/i2c-topology.rst:196
msgid "This is a useful topology, but it can be bad::"
msgstr ""

#: ../../../i2c/i2c-topology.rst:207
msgid ""
"When any device is accessed, all other devices are locked out for the full "
"duration of the operation (both muxes lock their parent, and specifically "
"when M2 requests its parent to lock, M1 passes the buck to the root adapter)."
msgstr ""

#: ../../../i2c/i2c-topology.rst:212
msgid ""
"This topology is bad if M2 is an auto-closing mux and M1->select issues any "
"unlocked I2C transfers on the root adapter that may leak through and be seen "
"by the M2 adapter, thus closing M2 prematurely."
msgstr ""

#: ../../../i2c/i2c-topology.rst:218
msgid "Mux-locked mux as parent of mux-locked mux"
msgstr ""

#: ../../../i2c/i2c-topology.rst:220 ../../../i2c/i2c-topology.rst:277
#: ../../../i2c/i2c-topology.rst:301 ../../../i2c/i2c-topology.rst:325
#: ../../../i2c/i2c-topology.rst:349
msgid "This is a good topology::"
msgstr ""

#: ../../../i2c/i2c-topology.rst:231
msgid ""
"When device D1 is accessed, accesses to D2 are locked out for the full "
"duration of the operation (muxes on the top child adapter of M1 are locked). "
"But accesses to D3 and D4 are possibly interleaved at any point."
msgstr ""

#: ../../../i2c/i2c-topology.rst:236
msgid ""
"Accesses to D3 locks out D1 and D2, but accesses to D4 are still possibly "
"interleaved."
msgstr ""

#: ../../../i2c/i2c-topology.rst:241
msgid "Mux-locked mux as parent of parent-locked mux"
msgstr ""

#: ../../../i2c/i2c-topology.rst:243
msgid "This is probably a bad topology::"
msgstr ""

#: ../../../i2c/i2c-topology.rst:254
msgid ""
"When device D1 is accessed, accesses to D2 and D3 are locked out for the "
"full duration of the operation (M1 locks child muxes on the root adapter). "
"But accesses to D4 are possibly interleaved at any point."
msgstr ""

#: ../../../i2c/i2c-topology.rst:259
msgid ""
"This kind of topology is generally not suitable and should probably be "
"avoided. The reason is that M2 probably assumes that there will be no I2C "
"transfers during its calls to ->select and ->deselect, and if there are, any "
"such transfers might appear on the slave side of M2 as partial I2C "
"transfers, i.e. garbage or worse. This might cause device lockups and/or "
"other problems."
msgstr ""

#: ../../../i2c/i2c-topology.rst:266
msgid ""
"The topology is especially troublesome if M2 is an auto-closing mux. In that "
"case, any interleaved accesses to D4 might close M2 prematurely, as might "
"any I2C transfers part of M1->select."
msgstr ""

#: ../../../i2c/i2c-topology.rst:270
msgid ""
"But if M2 is not making the above stated assumption, and if M2 is not auto-"
"closing, the topology is fine."
msgstr ""

#: ../../../i2c/i2c-topology.rst:275
msgid "Parent-locked mux as parent of mux-locked mux"
msgstr ""

#: ../../../i2c/i2c-topology.rst:288
msgid ""
"When D1 is accessed, accesses to D2 are locked out for the full duration of "
"the operation (muxes on the top child adapter of M1 are locked). Accesses to "
"D3 and D4 are possibly interleaved at any point, just as is expected for mux-"
"locked muxes."
msgstr ""

#: ../../../i2c/i2c-topology.rst:293
msgid ""
"When D3 or D4 are accessed, everything else is locked out. For D3 accesses, "
"M1 locks the root adapter. For D4 accesses, the root adapter is locked "
"directly."
msgstr ""

#: ../../../i2c/i2c-topology.rst:299
msgid "Two mux-locked sibling muxes"
msgstr ""

#: ../../../i2c/i2c-topology.rst:318
msgid ""
"When D1 is accessed, accesses to D2, D3 and D4 are locked out. But accesses "
"to D5 may be interleaved at any time."
msgstr ""

#: ../../../i2c/i2c-topology.rst:323
msgid "Two parent-locked sibling muxes"
msgstr ""

#: ../../../i2c/i2c-topology.rst:342
msgid ""
"When any device is accessed, accesses to all other devices are locked out."
msgstr ""

#: ../../../i2c/i2c-topology.rst:347
msgid "Mux-locked and parent-locked sibling muxes"
msgstr ""

#: ../../../i2c/i2c-topology.rst:366
msgid ""
"When D1 or D2 are accessed, accesses to D3 and D4 are locked out while "
"accesses to D5 may interleave. When D3 or D4 are accessed, accesses to all "
"other devices are locked out."
msgstr ""

#: ../../../i2c/i2c-topology.rst:372
msgid "Mux type of existing device drivers"
msgstr ""

#: ../../../i2c/i2c-topology.rst:374
msgid ""
"Whether a device is mux-locked or parent-locked depends on its "
"implementation. The following list was correct at the time of writing:"
msgstr ""

#: ../../../i2c/i2c-topology.rst:377
msgid "In drivers/i2c/muxes/:"
msgstr ""

#: ../../../i2c/i2c-topology.rst:380
msgid "i2c-arb-gpio-challenge"
msgstr ""

#: ../../../i2c/i2c-topology.rst:380 ../../../i2c/i2c-topology.rst:387
#: ../../../i2c/i2c-topology.rst:388 ../../../i2c/i2c-topology.rst:389
#: ../../../i2c/i2c-topology.rst:393 ../../../i2c/i2c-topology.rst:407
#: ../../../i2c/i2c-topology.rst:408 ../../../i2c/i2c-topology.rst:411
msgid "Parent-locked"
msgstr ""

#: ../../../i2c/i2c-topology.rst:381
msgid "i2c-mux-gpio"
msgstr ""

#: ../../../i2c/i2c-topology.rst:381
msgid ""
"Normally parent-locked, mux-locked iff all involved gpio pins are controlled "
"by the same I2C root adapter that they mux."
msgstr ""

#: ../../../i2c/i2c-topology.rst:384
msgid "i2c-mux-gpmux"
msgstr ""

#: ../../../i2c/i2c-topology.rst:384
msgid "Normally parent-locked, mux-locked iff specified in device-tree."
msgstr ""

#: ../../../i2c/i2c-topology.rst:386
msgid "i2c-mux-ltc4306"
msgstr ""

#: ../../../i2c/i2c-topology.rst:386 ../../../i2c/i2c-topology.rst:399
#: ../../../i2c/i2c-topology.rst:400 ../../../i2c/i2c-topology.rst:406
#: ../../../i2c/i2c-topology.rst:409 ../../../i2c/i2c-topology.rst:410
msgid "Mux-locked"
msgstr ""

#: ../../../i2c/i2c-topology.rst:387
msgid "i2c-mux-mlxcpld"
msgstr ""

#: ../../../i2c/i2c-topology.rst:388
msgid "i2c-mux-pca9541"
msgstr ""

#: ../../../i2c/i2c-topology.rst:389
msgid "i2c-mux-pca954x"
msgstr ""

#: ../../../i2c/i2c-topology.rst:390
msgid "i2c-mux-pinctrl"
msgstr ""

#: ../../../i2c/i2c-topology.rst:390
msgid ""
"Normally parent-locked, mux-locked iff all involved pinctrl devices are "
"controlled by the same I2C root adapter that they mux."
msgstr ""

#: ../../../i2c/i2c-topology.rst:393
msgid "i2c-mux-reg"
msgstr ""

#: ../../../i2c/i2c-topology.rst:396
msgid "In drivers/iio/:"
msgstr ""

#: ../../../i2c/i2c-topology.rst:399
msgid "gyro/mpu3050"
msgstr ""

#: ../../../i2c/i2c-topology.rst:400
msgid "imu/inv_mpu6050/"
msgstr ""

#: ../../../i2c/i2c-topology.rst:403
msgid "In drivers/media/:"
msgstr ""

#: ../../../i2c/i2c-topology.rst:406
msgid "dvb-frontends/lgdt3306a"
msgstr ""

#: ../../../i2c/i2c-topology.rst:407
msgid "dvb-frontends/m88ds3103"
msgstr ""

#: ../../../i2c/i2c-topology.rst:408
msgid "dvb-frontends/rtl2830"
msgstr ""

#: ../../../i2c/i2c-topology.rst:409
msgid "dvb-frontends/rtl2832"
msgstr ""

#: ../../../i2c/i2c-topology.rst:410
msgid "dvb-frontends/si2168"
msgstr ""

#: ../../../i2c/i2c-topology.rst:411
msgid "usb/cx231xx/"
msgstr ""
