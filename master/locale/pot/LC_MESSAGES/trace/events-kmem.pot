# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/events-kmem.rst:3
msgid "Subsystem Trace Points: kmem"
msgstr ""

#: ../../../trace/events-kmem.rst:5
msgid ""
"The kmem tracing system captures events related to object and page "
"allocation within the kernel. Broadly speaking there are five major "
"subheadings."
msgstr ""

#: ../../../trace/events-kmem.rst:8
msgid "Slab allocation of small objects of unknown type (kmalloc)"
msgstr ""

#: ../../../trace/events-kmem.rst:9
msgid "Slab allocation of small objects of known type"
msgstr ""

#: ../../../trace/events-kmem.rst:10
msgid "Page allocation"
msgstr ""

#: ../../../trace/events-kmem.rst:11
msgid "Per-CPU Allocator Activity"
msgstr ""

#: ../../../trace/events-kmem.rst:12
msgid "External Fragmentation"
msgstr ""

#: ../../../trace/events-kmem.rst:14
msgid ""
"This document describes what each of the tracepoints is and why they might "
"be useful."
msgstr ""

#: ../../../trace/events-kmem.rst:18
msgid "1. Slab allocation of small objects of unknown type"
msgstr ""

#: ../../../trace/events-kmem.rst:25
msgid ""
"Heavy activity for these events may indicate that a specific cache is "
"justified, particularly if kmalloc slab pages are getting significantly "
"internal fragmented as a result of the allocation pattern. By correlating "
"kmalloc with kfree, it may be possible to identify memory leaks and where "
"the allocation sites were."
msgstr ""

#: ../../../trace/events-kmem.rst:33
msgid "2. Slab allocation of small objects of known type"
msgstr ""

#: ../../../trace/events-kmem.rst:40
msgid ""
"These events are similar in usage to the kmalloc-related events except that "
"it is likely easier to pin the event down to a specific cache. At the time "
"of writing, no information is available on what slab is being allocated "
"from, but the call_site can usually be used to extrapolate that information."
msgstr ""

#: ../../../trace/events-kmem.rst:46
msgid "3. Page allocation"
msgstr ""

#: ../../../trace/events-kmem.rst:54
msgid ""
"These four events deal with page allocation and freeing. mm_page_alloc is a "
"simple indicator of page allocator activity. Pages may be allocated from the "
"per-CPU allocator (high performance) or the buddy allocator."
msgstr ""

#: ../../../trace/events-kmem.rst:58
msgid ""
"If pages are allocated directly from the buddy allocator, the "
"mm_page_alloc_zone_locked event is triggered. This event is important as "
"high amounts of activity imply high activity on the zone->lock. Taking this "
"lock impairs performance by disabling interrupts, dirtying cache lines "
"between CPUs and serialising many CPUs."
msgstr ""

#: ../../../trace/events-kmem.rst:64
msgid ""
"When a page is freed directly by the caller, the only mm_page_free event is "
"triggered. Significant amounts of activity here could indicate that the "
"callers should be batching their activities."
msgstr ""

#: ../../../trace/events-kmem.rst:68
msgid ""
"When pages are freed in batch, the also mm_page_free_batched is triggered. "
"Broadly speaking, pages are taken off the LRU lock in bulk and freed in "
"batch with a page list. Significant amounts of activity here could indicate "
"that the system is under memory pressure and can also indicate contention on "
"the lruvec->lru_lock."
msgstr ""

#: ../../../trace/events-kmem.rst:75
msgid "4. Per-CPU Allocator Activity"
msgstr ""

#: ../../../trace/events-kmem.rst:81
msgid ""
"In front of the page allocator is a per-cpu page allocator. It exists only "
"for order-0 pages, reduces contention on the zone->lock and reduces the "
"amount of writing on struct page."
msgstr ""

#: ../../../trace/events-kmem.rst:85
msgid ""
"When a per-CPU list is empty or pages of the wrong type are allocated, the "
"zone->lock will be taken once and the per-CPU list refilled. The event "
"triggered is mm_page_alloc_zone_locked for each page allocated with the "
"event indicating whether it is for a percpu_refill or not."
msgstr ""

#: ../../../trace/events-kmem.rst:90
msgid ""
"When the per-CPU list is too full, a number of pages are freed, each one "
"which triggers a mm_page_pcpu_drain event."
msgstr ""

#: ../../../trace/events-kmem.rst:93
msgid ""
"The individual nature of the events is so that pages can be tracked between "
"allocation and freeing. A number of drain or refill pages that occur "
"consecutively imply the zone->lock being taken once. Large amounts of per-"
"CPU refills and drains could imply an imbalance between CPUs where too much "
"work is being concentrated in one place. It could also indicate that the per-"
"CPU lists should be a larger size. Finally, large amounts of refills on one "
"CPU and drains on another could be a factor in causing large amounts of "
"cache line bounces due to writes between CPUs and worth investigating if "
"pages can be allocated and freed on the same CPU through some algorithm "
"change."
msgstr ""

#: ../../../trace/events-kmem.rst:104
msgid "5. External Fragmentation"
msgstr ""

#: ../../../trace/events-kmem.rst:109
msgid ""
"External fragmentation affects whether a high-order allocation will be "
"successful or not. For some types of hardware, this is important although it "
"is avoided where possible. If the system is using huge pages and needs to be "
"able to resize the pool over the lifetime of the system, this value is "
"important."
msgstr ""

#: ../../../trace/events-kmem.rst:115
msgid ""
"Large numbers of this event implies that memory is fragmenting and high-"
"order allocations will start failing at some time in the future. One means "
"of reducing the occurrence of this event is to increase the size of "
"min_free_kbytes in increments of 3*pageblock_size*nr_online_nodes where "
"pageblock_size is usually the size of the default hugepage size."
msgstr ""
