# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-06 15:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/histogram.rst:3
msgid "Event Histograms"
msgstr ""

#: ../../../trace/histogram.rst:5
msgid "Documentation written by Tom Zanussi"
msgstr ""

#: ../../../trace/histogram.rst:8
msgid "1. Introduction"
msgstr ""

#: ../../../trace/histogram.rst:10
msgid ""
"Histogram triggers are special event triggers that can be used to aggregate "
"trace event data into histograms.  For information on trace events and event "
"triggers, see Documentation/trace/events.rst."
msgstr ""

#: ../../../trace/histogram.rst:16
msgid "2. Histogram Trigger Command"
msgstr ""

#: ../../../trace/histogram.rst:18
msgid ""
"A histogram trigger command is an event trigger command that aggregates "
"event hits into a hash table keyed on one or more trace event format fields "
"(or stacktrace) and a set of running totals derived from one or more trace "
"event format fields and/or event counts (hitcount)."
msgstr ""

#: ../../../trace/histogram.rst:24
msgid "The format of a hist trigger is as follows::"
msgstr ""

#: ../../../trace/histogram.rst:30
msgid ""
"When a matching event is hit, an entry is added to a hash table using the "
"key(s) and value(s) named.  Keys and values correspond to fields in the "
"event's format description.  Values must correspond to numeric fields - on "
"an event hit, the value(s) will be added to a sum kept for that field.  The "
"special string 'hitcount' can be used in place of an explicit value field - "
"this is simply a count of event hits.  If 'values' isn't specified, an "
"implicit 'hitcount' value will be automatically created and used as the only "
"value. Keys can be any field, or the special string 'common_stacktrace', "
"which will use the event's kernel stacktrace as the key.  The keywords "
"'keys' or 'key' can be used to specify keys, and the keywords 'values', "
"'vals', or 'val' can be used to specify values.  Compound keys consisting of "
"up to three fields can be specified by the 'keys' keyword.  Hashing a "
"compound key produces a unique entry in the table for each unique "
"combination of component keys, and can be useful for providing more fine-"
"grained summaries of event data. Additionally, sort keys consisting of up to "
"two fields can be specified by the 'sort' keyword.  If more than one field "
"is specified, the result will be a 'sort within a sort': the first key is "
"taken to be the primary sort key and the second the secondary key.  If a "
"hist trigger is given a name using the 'name' parameter, its histogram data "
"will be shared with other triggers of the same name, and trigger hits will "
"update this common data.  Only triggers with 'compatible' fields can be "
"combined in this way; triggers are 'compatible' if the fields named in the "
"trigger share the same number and type of fields and those fields also have "
"the same names. Note that any two events always share the compatible "
"'hitcount' and 'common_stacktrace' fields and can therefore be combined "
"using those fields, however pointless that may be."
msgstr ""

#: ../../../trace/histogram.rst:60
msgid ""
"'hist' triggers add a 'hist' file to each event's subdirectory. Reading the "
"'hist' file for the event will dump the hash table in its entirety to "
"stdout.  If there are multiple hist triggers attached to an event, there "
"will be a table for each trigger in the output.  The table displayed for a "
"named trigger will be the same as any other instance having the same name. "
"Each printed hash table entry is a simple list of the keys and values "
"comprising the entry; keys are printed first and are delineated by curly "
"braces, and are followed by the set of value fields for the entry.  By "
"default, numeric fields are displayed as base-10 integers.  This can be "
"modified by appending any of the following modifiers to the field name:"
msgstr ""

#: ../../../trace/histogram.rst:74
msgid ".hex"
msgstr ""

#: ../../../trace/histogram.rst:74
msgid "display a number as a hex value"
msgstr ""

#: ../../../trace/histogram.rst:75
msgid ".sym"
msgstr ""

#: ../../../trace/histogram.rst:75
msgid "display an address as a symbol"
msgstr ""

#: ../../../trace/histogram.rst:76
msgid ".sym-offset"
msgstr ""

#: ../../../trace/histogram.rst:76
msgid "display an address as a symbol and offset"
msgstr ""

#: ../../../trace/histogram.rst:77
msgid ".syscall"
msgstr ""

#: ../../../trace/histogram.rst:77
msgid "display a syscall id as a system call name"
msgstr ""

#: ../../../trace/histogram.rst:78
msgid ".execname"
msgstr ""

#: ../../../trace/histogram.rst:78
msgid "display a common_pid as a program name"
msgstr ""

#: ../../../trace/histogram.rst:79
msgid ".log2"
msgstr ""

#: ../../../trace/histogram.rst:79
msgid "display log2 value rather than raw number"
msgstr ""

#: ../../../trace/histogram.rst:80
msgid ".buckets=size"
msgstr ""

#: ../../../trace/histogram.rst:80
msgid "display grouping of values rather than raw number"
msgstr ""

#: ../../../trace/histogram.rst:81
msgid ".usecs"
msgstr ""

#: ../../../trace/histogram.rst:81
msgid "display a common_timestamp in microseconds"
msgstr ""

#: ../../../trace/histogram.rst:82
msgid ".percent"
msgstr ""

#: ../../../trace/histogram.rst:82
msgid "display a number of percentage value"
msgstr ""

#: ../../../trace/histogram.rst:83
msgid ".graph"
msgstr ""

#: ../../../trace/histogram.rst:83
msgid "display a bar-graph of a value"
msgstr ""

#: ../../../trace/histogram.rst:84
msgid ".stacktrace"
msgstr ""

#: ../../../trace/histogram.rst:84
msgid "display as a stacktrace (must be a long[] type)"
msgstr ""

#: ../../../trace/histogram.rst:87
msgid ""
"Note that in general the semantics of a given field aren't interpreted when "
"applying a modifier to it, but there are some restrictions to be aware of in "
"this regard:"
msgstr ""

#: ../../../trace/histogram.rst:91
msgid ""
"only the 'hex' modifier can be used for values (because values are "
"essentially sums, and the other modifiers don't make sense in that context)."
msgstr ""

#: ../../../trace/histogram.rst:94
msgid ""
"the 'execname' modifier can only be used on a 'common_pid'.  The reason for "
"this is that the execname is simply the 'comm' value saved for the 'current' "
"process when an event was triggered, which is the same as the common_pid "
"value saved by the event tracing code.  Trying to apply that comm value to "
"other pid values wouldn't be correct, and typically events that care save "
"pid-specific comm fields in the event itself."
msgstr ""

#: ../../../trace/histogram.rst:102
msgid ""
"A typical usage scenario would be the following to enable a hist trigger, "
"read its current contents, and then turn it off::"
msgstr ""

#: ../../../trace/histogram.rst:113
msgid ""
"The trigger file itself can be read to show the details of the currently "
"attached hist trigger.  This information is also displayed at the top of the "
"'hist' file when read."
msgstr ""

#: ../../../trace/histogram.rst:117
msgid ""
"By default, the size of the hash table is 2048 entries.  The 'size' "
"parameter can be used to specify more or fewer than that.  The units are in "
"terms of hashtable entries - if a run uses more entries than specified, the "
"results will show the number of 'drops', the number of hits that were "
"ignored.  The size should be a power of 2 between 128 and 131072 (any non- "
"power-of-2 number specified will be rounded up)."
msgstr ""

#: ../../../trace/histogram.rst:125
msgid ""
"The 'sort' parameter can be used to specify a value field to sort on.  The "
"default if unspecified is 'hitcount' and the default sort order is "
"'ascending'.  To sort in the opposite direction, append .descending' to the "
"sort key."
msgstr ""

#: ../../../trace/histogram.rst:130
msgid ""
"The 'pause' parameter can be used to pause an existing hist trigger or to "
"start a hist trigger but not log any events until told to do so.  'continue' "
"or 'cont' can be used to start or restart a paused hist trigger."
msgstr ""

#: ../../../trace/histogram.rst:135
msgid ""
"The 'clear' parameter will clear the contents of a running hist trigger and "
"leave its current paused/active state."
msgstr ""

#: ../../../trace/histogram.rst:138
msgid ""
"Note that the 'pause', 'cont', and 'clear' parameters should be applied "
"using 'append' shell operator ('>>') if applied to an existing trigger, "
"rather than via the '>' operator, which will cause the trigger to be removed "
"through truncation."
msgstr ""

#: ../../../trace/histogram.rst:143
msgid ""
"The 'nohitcount' (or NOHC) parameter will suppress display of raw hitcount "
"in the histogram. This option requires at least one value field which is not "
"a 'raw hitcount'. For example, 'hist:...:vals=hitcount:nohitcount' is "
"rejected, but 'hist:...:vals=hitcount.percent:nohitcount' is OK."
msgstr ""

#: ../../../trace/histogram.rst:149
msgid "enable_hist/disable_hist"
msgstr ""

#: ../../../trace/histogram.rst:151
msgid ""
"The enable_hist and disable_hist triggers can be used to have one event "
"conditionally start and stop another event's already-attached hist trigger.  "
"Any number of enable_hist and disable_hist triggers can be attached to a "
"given event, allowing that event to kick off and stop aggregations on a host "
"of other events."
msgstr ""

#: ../../../trace/histogram.rst:157
msgid "The format is very similar to the enable/disable_event triggers::"
msgstr ""

#: ../../../trace/histogram.rst:162
msgid ""
"Instead of enabling or disabling the tracing of the target event into the "
"trace buffer as the enable/disable_event triggers do, the enable/"
"disable_hist triggers enable or disable the aggregation of the target event "
"into a hash table."
msgstr ""

#: ../../../trace/histogram.rst:167
msgid ""
"A typical usage scenario for the enable_hist/disable_hist triggers would be "
"to first set up a paused hist trigger on some event, followed by an "
"enable_hist/disable_hist pair that turns the hist aggregation on and off "
"when conditions of interest are hit::"
msgstr ""

#: ../../../trace/histogram.rst:181
msgid ""
"The above sets up an initially paused hist trigger which is unpaused and "
"starts aggregating events when a given program is executed, and which stops "
"aggregating when the process exits and the hist trigger is paused again."
msgstr ""

#: ../../../trace/histogram.rst:186
msgid ""
"The examples below provide a more concrete illustration of the concepts and "
"typical usage patterns discussed above."
msgstr ""

#: ../../../trace/histogram.rst:190
msgid "2.1. 'special' event fields"
msgstr ""

#: ../../../trace/histogram.rst:192
msgid ""
"There are a number of 'special event fields' available for use as keys or "
"values in a hist trigger.  These look like and behave as if they were actual "
"event fields, but aren't really part of the event's field definition or "
"format file.  They are however available for any event, and can be used "
"anywhere an actual event field could be. They are:"
msgstr ""

#: ../../../trace/histogram.rst:200
msgid "common_timestamp"
msgstr ""

#: ../../../trace/histogram.rst:200
msgid "u64"
msgstr ""

#: ../../../trace/histogram.rst:200
msgid ""
"timestamp (from ring buffer) associated with the event, in nanoseconds.  May "
"be modified by .usecs to have timestamps interpreted as microseconds."
msgstr ""

#: ../../../trace/histogram.rst:204
msgid "common_cpu"
msgstr ""

#: ../../../trace/histogram.rst:204
msgid "int"
msgstr ""

#: ../../../trace/histogram.rst:204
msgid "the cpu on which the event occurred."
msgstr ""

#: ../../../trace/histogram.rst:208
msgid "2.2. Extended error information"
msgstr ""

#: ../../../trace/histogram.rst:210
msgid ""
"For some error conditions encountered when invoking a hist trigger command, "
"extended error information is available via the tracing/error_log file.  See "
"\"Error conditions\" section in Documentation/trace/ftrace.rst for details."
msgstr ""

#: ../../../trace/histogram.rst:216
msgid "2.3. 'hist' trigger examples"
msgstr ""

#: ../../../trace/histogram.rst:218
msgid ""
"The first set of examples creates aggregations using the kmalloc event.  The "
"fields that can be used for the hist trigger are listed in the kmalloc "
"event's format file::"
msgstr ""

#: ../../../trace/histogram.rst:237
msgid ""
"We'll start by creating a hist trigger that generates a simple table that "
"lists the total number of bytes requested for each function in the kernel "
"that made one or more calls to kmalloc::"
msgstr ""

#: ../../../trace/histogram.rst:244
msgid ""
"This tells the tracing system to create a 'hist' trigger using the call_site "
"field of the kmalloc event as the key for the table, which just means that "
"each unique call_site address will have an entry created for it in the "
"table.  The 'val=bytes_req' parameter tells the hist trigger that for each "
"unique entry (call_site) in the table, it should keep a running total of the "
"number of bytes requested by that call_site."
msgstr ""

#: ../../../trace/histogram.rst:252
msgid ""
"We'll let it run for a while and then dump the contents of the 'hist' file "
"in the kmalloc event's subdirectory (for readability, a number of entries "
"have been omitted)::"
msgstr ""

#: ../../../trace/histogram.rst:290
msgid ""
"The output displays a line for each entry, beginning with the key specified "
"in the trigger, followed by the value(s) also specified in the trigger.  At "
"the beginning of the output is a line that displays the trigger info, which "
"can also be displayed by reading the 'trigger' file::"
msgstr ""

#: ../../../trace/histogram.rst:299
msgid ""
"At the end of the output are a few lines that display the overall totals for "
"the run.  The 'Hits' field shows the total number of times the event trigger "
"was hit, the 'Entries' field shows the total number of used entries in the "
"hash table, and the 'Dropped' field shows the number of hits that were "
"dropped because the number of used entries for the run exceeded the maximum "
"number of entries allowed for the table (normally 0, but if not a hint that "
"you may want to increase the size of the table using the 'size' parameter)."
msgstr ""

#: ../../../trace/histogram.rst:308
msgid ""
"Notice in the above output that there's an extra field, 'hitcount', which "
"wasn't specified in the trigger.  Also notice that in the trigger info "
"output, there's a parameter, 'sort=hitcount', which wasn't specified in the "
"trigger either.  The reason for that is that every trigger implicitly keeps "
"a count of the total number of hits attributed to a given entry, called the "
"'hitcount'.  That hitcount information is explicitly displayed in the "
"output, and in the absence of a user-specified sort parameter, is used as "
"the default sort field."
msgstr ""

#: ../../../trace/histogram.rst:318
msgid ""
"The value 'hitcount' can be used in place of an explicit value in the "
"'values' parameter if you don't really need to have any particular field "
"summed and are mainly interested in hit frequencies."
msgstr ""

#: ../../../trace/histogram.rst:323
msgid ""
"To turn the hist trigger off, simply call up the trigger in the command "
"history and re-execute it with a '!' prepended::"
msgstr ""

#: ../../../trace/histogram.rst:329
msgid ""
"Finally, notice that the call_site as displayed in the output above isn't "
"really very useful.  It's an address, but normally addresses are displayed "
"in hex.  To have a numeric field displayed as a hex value, simply append '."
"hex' to the field name in the trigger::"
msgstr ""

#: ../../../trace/histogram.rst:372
msgid ""
"Even that's only marginally more useful - while hex values do look more like "
"addresses, what users are typically more interested in when looking at text "
"addresses are the corresponding symbols instead.  To have an address "
"displayed as symbolic value instead, simply append '.sym' or '.sym-offset' "
"to the field name in the trigger::"
msgstr ""

#: ../../../trace/histogram.rst:421
msgid ""
"Because the default sort key above is 'hitcount', the above shows a the list "
"of call_sites by increasing hitcount, so that at the bottom we see the "
"functions that made the most kmalloc calls during the run.  If instead we "
"wanted to see the top kmalloc callers in terms of the number of bytes "
"requested rather than the number of calls, and we wanted the top caller to "
"appear at the top, we can use the 'sort' parameter, along with the "
"'descending' modifier::"
msgstr ""

#: ../../../trace/histogram.rst:467
msgid ""
"To display the offset and size information in addition to the symbol name, "
"just use 'sym-offset' instead::"
msgstr ""

#: ../../../trace/histogram.rst:504
msgid ""
"We can also add multiple fields to the 'values' parameter.  For example, we "
"might want to see the total number of bytes allocated alongside bytes "
"requested, and display the result sorted by bytes allocated in a descending "
"order::"
msgstr ""

#: ../../../trace/histogram.rst:546
msgid ""
"Finally, to finish off our kmalloc example, instead of simply having the "
"hist trigger display symbolic call_sites, we can have the hist trigger "
"additionally display the complete set of kernel stack traces that led to "
"each call_site.  To do that, we simply use the special value "
"'common_stacktrace' for the key parameter::"
msgstr ""

#: ../../../trace/histogram.rst:555
msgid ""
"The above trigger will use the kernel stack trace in effect when an event is "
"triggered as the key for the hash table.  This allows the enumeration of "
"every kernel callpath that led up to a particular event, along with a "
"running total of any of the event fields for that event.  Here we tally "
"bytes requested and bytes allocated for every callpath in the system that "
"led up to a kmalloc (in this case every callpath to a kmalloc for a kernel "
"compile)::"
msgstr ""

#: ../../../trace/histogram.rst:655
msgid ""
"If you key a hist trigger on common_pid, in order for example to gather and "
"display sorted totals for each process, you can use the special .execname "
"modifier to display the executable names for the processes in the table "
"rather than raw pids.  The example below keeps a per-process sum of total "
"bytes read::"
msgstr ""

#: ../../../trace/histogram.rst:696
msgid ""
"Similarly, if you key a hist trigger on syscall id, for example to gather "
"and display a list of systemwide syscall hits, you can use the special ."
"syscall modifier to display the syscall names rather than raw ids.  The "
"example below keeps a running total of syscall counts for the system during "
"the run::"
msgstr ""

#: ../../../trace/histogram.rst:742
msgid ""
"The syscall counts above provide a rough overall picture of system call "
"activity on the system; we can see for example that the most popular system "
"call on this system was the 'sys_ioctl' system call."
msgstr ""

#: ../../../trace/histogram.rst:746
msgid ""
"We can use 'compound' keys to refine that number and provide some further "
"insight as to which processes exactly contribute to the overall ioctl count."
msgstr ""

#: ../../../trace/histogram.rst:750
msgid ""
"The command below keeps a hitcount for every unique combination of system "
"call id and pid - the end result is essentially a table that keeps a per-pid "
"sum of system call hits.  The results are sorted using the system call id as "
"the primary key, and the hitcount sum as the secondary key::"
msgstr ""

#: ../../../trace/histogram.rst:800
msgid ""
"The above list does give us a breakdown of the ioctl syscall by pid, but it "
"also gives us quite a bit more than that, which we don't really care about "
"at the moment.  Since we know the syscall id for sys_ioctl (16, displayed "
"next to the sys_ioctl name), we can use that to filter out all the other "
"syscalls::"
msgstr ""

#: ../../../trace/histogram.rst:836
msgid ""
"The above output shows that 'compiz' and 'Xorg' are far and away the "
"heaviest ioctl callers (which might lead to questions about whether they "
"really need to be making all those calls and to possible avenues for further "
"investigation.)"
msgstr ""

#: ../../../trace/histogram.rst:841
msgid ""
"The compound key examples used a key and a sum value (hitcount) to sort the "
"output, but we can just as easily use two keys instead. Here's an example "
"where we use a compound key composed of the common_pid and size event "
"fields.  Sorting with pid as the primary key and 'size' as the secondary key "
"allows us to display an ordered summary of the recvfrom sizes, with counts, "
"received by each process::"
msgstr ""

#: ../../../trace/histogram.rst:892
msgid ""
"The above example also illustrates the fact that although a compound key is "
"treated as a single entity for hashing purposes, the sub-keys it's composed "
"of can be accessed independently."
msgstr ""

#: ../../../trace/histogram.rst:896
msgid ""
"The next example uses a string field as the hash key and demonstrates how "
"you can manually pause and continue a hist trigger. In this example, we'll "
"aggregate fork counts and don't expect a large number of entries in the hash "
"table, so we'll drop it to a much smaller number, say 256::"
msgstr ""

#: ../../../trace/histogram.rst:934
msgid ""
"If we want to pause the hist trigger, we can simply append :pause to the "
"command that started the trigger.  Notice that the trigger info displays as "
"[paused]::"
msgstr ""

#: ../../../trace/histogram.rst:971
msgid ""
"To manually continue having the trigger aggregate events, append :cont "
"instead.  Notice that the trigger info displays as [active] again, and the "
"data has changed::"
msgstr ""

#: ../../../trace/histogram.rst:1008
msgid ""
"The previous example showed how to start and stop a hist trigger by "
"appending 'pause' and 'continue' to the hist trigger command.  A hist "
"trigger can also be started in a paused state by initially starting the "
"trigger with ':pause' appended.  This allows you to start the trigger only "
"when you're ready to start collecting data and not before.  For example, you "
"could start the trigger in a paused state, then unpause it and do something "
"you want to measure, then pause the trigger again when done."
msgstr ""

#: ../../../trace/histogram.rst:1017
msgid ""
"Of course, doing this manually can be difficult and error-prone, but it is "
"possible to automatically start and stop a hist trigger based on some "
"condition, via the enable_hist and disable_hist triggers."
msgstr ""

#: ../../../trace/histogram.rst:1021
msgid ""
"For example, suppose we wanted to take a look at the relative weights in "
"terms of skb length for each callpath that leads to a netif_receive_skb "
"event when downloading a decent-sized file using wget."
msgstr ""

#: ../../../trace/histogram.rst:1026
msgid ""
"First we set up an initially paused stacktrace trigger on the "
"netif_receive_skb event::"
msgstr ""

#: ../../../trace/histogram.rst:1032
msgid ""
"Next, we set up an 'enable_hist' trigger on the sched_process_exec event, "
"with an 'if filename==/usr/bin/wget' filter.  The effect of this new trigger "
"is that it will 'unpause' the hist trigger we just set up on "
"netif_receive_skb if and only if it sees a sched_process_exec event with a "
"filename of '/usr/bin/wget'.  When that happens, all netif_receive_skb "
"events are aggregated into a hash table keyed on stacktrace::"
msgstr ""

#: ../../../trace/histogram.rst:1043
msgid ""
"The aggregation continues until the netif_receive_skb is paused again, which "
"is what the following disable_hist event does by creating a similar setup on "
"the sched_process_exit event, using the filter 'comm==wget'::"
msgstr ""

#: ../../../trace/histogram.rst:1051
msgid ""
"Whenever a process exits and the comm field of the disable_hist trigger "
"filter matches 'comm==wget', the netif_receive_skb hist trigger is disabled."
msgstr ""

#: ../../../trace/histogram.rst:1055
msgid ""
"The overall effect is that netif_receive_skb events are aggregated into the "
"hash table for only the duration of the wget.  Executing a wget command and "
"then listing the 'hist' file will display the output generated by the wget "
"command::"
msgstr ""

#: ../../../trace/histogram.rst:1136
msgid ""
"The above shows all the netif_receive_skb callpaths and their total lengths "
"for the duration of the wget command."
msgstr ""

#: ../../../trace/histogram.rst:1139
msgid ""
"The 'clear' hist trigger param can be used to clear the hash table. Suppose "
"we wanted to try another run of the previous example but this time also "
"wanted to see the complete list of events that went into the histogram.  In "
"order to avoid having to set everything up again, we can just clear the "
"histogram first::"
msgstr ""

#: ../../../trace/histogram.rst:1148
msgid ""
"Just to verify that it is in fact cleared, here's what we now see in the "
"hist file::"
msgstr ""

#: ../../../trace/histogram.rst:1159
msgid ""
"Since we want to see the detailed list of every netif_receive_skb event "
"occurring during the new run, which are in fact the same events being "
"aggregated into the hash table, we add some additional 'enable_event' events "
"to the triggering sched_process_exec and sched_process_exit events as such::"
msgstr ""

#: ../../../trace/histogram.rst:1171
msgid ""
"If you read the trigger files for the sched_process_exec and "
"sched_process_exit triggers, you should see two triggers for each: one "
"enabling/disabling the hist aggregation and the other enabling/disabling the "
"logging of events::"
msgstr ""

#: ../../../trace/histogram.rst:1184
msgid ""
"In other words, whenever either of the sched_process_exec or "
"sched_process_exit events is hit and matches 'wget', it enables or disables "
"both the histogram and the event log, and what you end up with is a hash "
"table and set of events just covering the specified duration.  Run the wget "
"command again::"
msgstr ""

#: ../../../trace/histogram.rst:1192
msgid ""
"Displaying the 'hist' file should show something similar to what you saw in "
"the last run, but this time you should also see the individual events in the "
"trace file::"
msgstr ""

#: ../../../trace/histogram.rst:1223
msgid ""
"The following example demonstrates how multiple hist triggers can be "
"attached to a given event.  This capability can be useful for creating a set "
"of different summaries derived from the same set of events, or for comparing "
"the effects of different filters, among other things::"
msgstr ""

#: ../../../trace/histogram.rst:1240
msgid ""
"The above set of commands create four triggers differing only in their "
"filters, along with a completely different though fairly nonsensical "
"trigger.  Note that in order to append multiple hist triggers to the same "
"file, you should use the '>>' operator to append them ('>' will also add the "
"new hist trigger, but will remove any existing hist triggers beforehand)."
msgstr ""

#: ../../../trace/histogram.rst:1247
msgid ""
"Displaying the contents of the 'hist' file for the event shows the contents "
"of all five histograms::"
msgstr ""

#: ../../../trace/histogram.rst:1363
msgid ""
"Named triggers can be used to have triggers share a common set of histogram "
"data.  This capability is mostly useful for combining the output of events "
"generated by tracepoints contained inside inline functions, but names can be "
"used in a hist trigger on any event. For example, these two triggers when "
"hit will update the same 'len' field in the shared 'foo' histogram data::"
msgstr ""

#: ../../../trace/histogram.rst:1375
msgid ""
"You can see that they're updating common histogram data by reading each "
"event's hist files at the same time::"
msgstr ""

#: ../../../trace/histogram.rst:1486
msgid ""
"And here's an example that shows how to combine histogram data from any two "
"events even if they don't share any 'compatible' fields other than "
"'hitcount' and 'common_stacktrace'.  These commands create a couple of "
"triggers named 'bar' using those fields::"
msgstr ""

#: ../../../trace/histogram.rst:1496
msgid ""
"And displaying the output of either shows some interesting if somewhat "
"confusing output::"
msgstr ""

#: ../../../trace/histogram.rst:1612
msgid "2.4. Inter-event hist triggers"
msgstr ""

#: ../../../trace/histogram.rst:1614
msgid ""
"Inter-event hist triggers are hist triggers that combine values from one or "
"more other events and create a histogram using that data.  Data from an "
"inter-event histogram can in turn become the source for further combined "
"histograms, thus providing a chain of related histograms, which is important "
"for some applications."
msgstr ""

#: ../../../trace/histogram.rst:1620
msgid ""
"The most important example of an inter-event quantity that can be used in "
"this manner is latency, which is simply a difference in timestamps between "
"two events.  Although latency is the most important inter-event quantity, "
"note that because the support is completely general across the trace event "
"subsystem, any event field can be used in an inter-event quantity."
msgstr ""

#: ../../../trace/histogram.rst:1627
msgid ""
"An example of a histogram that combines data from other histograms into a "
"useful chain would be a 'wakeupswitch latency' histogram that combines a "
"'wakeup latency' histogram and a 'switch latency' histogram."
msgstr ""

#: ../../../trace/histogram.rst:1632
msgid ""
"Normally, a hist trigger specification consists of a (possibly compound) key "
"along with one or more numeric values, which are continually updated sums "
"associated with that key.  A histogram specification in this case consists "
"of individual key and value specifications that refer to trace event fields "
"associated with a single event type."
msgstr ""

#: ../../../trace/histogram.rst:1639
msgid ""
"The inter-event hist trigger extension allows fields from multiple events to "
"be referenced and combined into a multi-event histogram specification.  In "
"support of this overall goal, a few enabling features have been added to the "
"hist trigger support:"
msgstr ""

#: ../../../trace/histogram.rst:1644
msgid ""
"In order to compute an inter-event quantity, a value from one event needs to "
"saved and then referenced from another event.  This requires the "
"introduction of support for histogram 'variables'."
msgstr ""

#: ../../../trace/histogram.rst:1648
msgid ""
"The computation of inter-event quantities and their combination require some "
"minimal amount of support for applying simple expressions to variables (+ "
"and -)."
msgstr ""

#: ../../../trace/histogram.rst:1652
msgid ""
"A histogram consisting of inter-event quantities isn't logically a histogram "
"on either event (so having the 'hist' file for either event host the "
"histogram output doesn't really make sense).  To address the idea that the "
"histogram is associated with a combination of events, support is added "
"allowing the creation of 'synthetic' events that are events derived from "
"other events. These synthetic events are full-fledged events just like any "
"other and can be used as such, as for instance to create the 'combination' "
"histograms mentioned previously."
msgstr ""

#: ../../../trace/histogram.rst:1662
msgid ""
"A set of 'actions' can be associated with histogram entries - these can be "
"used to generate the previously mentioned synthetic events, but can also be "
"used for other purposes, such as for example saving context when a 'max' "
"latency has been hit."
msgstr ""

#: ../../../trace/histogram.rst:1667
msgid ""
"Trace events don't have a 'timestamp' associated with them, but there is an "
"implicit timestamp saved along with an event in the underlying ftrace ring "
"buffer.  This timestamp is now exposed as a a synthetic field named "
"'common_timestamp' which can be used in histograms as if it were any other "
"event field; it isn't an actual field in the trace format but rather is a "
"synthesized value that nonetheless can be used as if it were an actual "
"field.  By default it is in units of nanoseconds; appending '.usecs' to a "
"common_timestamp field changes the units to microseconds."
msgstr ""

#: ../../../trace/histogram.rst:1677
msgid ""
"A note on inter-event timestamps: If common_timestamp is used in a "
"histogram, the trace buffer is automatically switched over to using absolute "
"timestamps and the \"global\" trace clock, in order to avoid bogus timestamp "
"differences with other clocks that aren't coherent across CPUs.  This can be "
"overridden by specifying one of the other trace clocks instead, using the "
"\"clock=XXX\" hist trigger attribute, where XXX is any of the clocks listed "
"in the tracing/trace_clock pseudo-file."
msgstr ""

#: ../../../trace/histogram.rst:1686
msgid "These features are described in more detail in the following sections."
msgstr ""

#: ../../../trace/histogram.rst:1689
msgid "2.5. Histogram Variables"
msgstr ""

#: ../../../trace/histogram.rst:1691
msgid ""
"Variables are simply named locations used for saving and retrieving values "
"between matching events.  A 'matching' event is defined as an event that has "
"a matching key - if a variable is saved for a histogram entry corresponding "
"to that key, any subsequent event with a matching key can access that "
"variable."
msgstr ""

#: ../../../trace/histogram.rst:1697
msgid ""
"A variable's value is normally available to any subsequent event until it is "
"set to something else by a subsequent event.  The one exception to that rule "
"is that any variable used in an expression is essentially 'read-once' - once "
"it's used by an expression in a subsequent event, it's reset to its 'unset' "
"state, which means it can't be used again unless it's set again.  This "
"ensures not only that an event doesn't use an uninitialized variable in a "
"calculation, but that that variable is used only once and not for any "
"unrelated subsequent match."
msgstr ""

#: ../../../trace/histogram.rst:1706
msgid ""
"The basic syntax for saving a variable is to simply prefix a unique variable "
"name not corresponding to any keyword along with an '=' sign to any event "
"field."
msgstr ""

#: ../../../trace/histogram.rst:1710
msgid ""
"Either keys or values can be saved and retrieved in this way.  This creates "
"a variable named 'ts0' for a histogram entry with the key 'next_pid'::"
msgstr ""

#: ../../../trace/histogram.rst:1717
msgid ""
"The ts0 variable can be accessed by any subsequent event having the same pid "
"as 'next_pid'."
msgstr ""

#: ../../../trace/histogram.rst:1720
msgid ""
"Variable references are formed by prepending the variable name with the '$' "
"sign.  Thus for example, the ts0 variable above would be referenced as "
"'$ts0' in expressions."
msgstr ""

#: ../../../trace/histogram.rst:1724
msgid ""
"Because 'vals=' is used, the common_timestamp variable value above will also "
"be summed as a normal histogram value would (though for a timestamp it makes "
"little sense)."
msgstr ""

#: ../../../trace/histogram.rst:1728
msgid "The below shows that a key value can also be saved in the same way::"
msgstr ""

#: ../../../trace/histogram.rst:1732
msgid ""
"If a variable isn't a key variable or prefixed with 'vals=', the associated "
"event field will be saved in a variable but won't be summed as a value::"
msgstr ""

#: ../../../trace/histogram.rst:1738
msgid ""
"Multiple variables can be assigned at the same time.  The below would result "
"in both ts0 and b being created as variables, with both common_timestamp and "
"field1 additionally being summed as values::"
msgstr ""

#: ../../../trace/histogram.rst:1745
msgid ""
"Note that variable assignments can appear either preceding or following "
"their use.  The command below behaves identically to the command above::"
msgstr ""

#: ../../../trace/histogram.rst:1752
msgid ""
"Any number of variables not bound to a 'vals=' prefix can also be assigned "
"by simply separating them with colons.  Below is the same thing but without "
"the values being summed in the histogram::"
msgstr ""

#: ../../../trace/histogram.rst:1758
msgid ""
"Variables set as above can be referenced and used in expressions on another "
"event."
msgstr ""

#: ../../../trace/histogram.rst:1761
msgid "For example, here's how a latency can be calculated::"
msgstr ""

#: ../../../trace/histogram.rst:1766
msgid ""
"In the first line above, the event's timestamp is saved into the variable "
"ts0.  In the next line, ts0 is subtracted from the second event's timestamp "
"to produce the latency, which is then assigned into yet another variable, "
"'wakeup_lat'.  The hist trigger below in turn makes use of the wakeup_lat "
"variable to compute a combined latency using the same key and variable from "
"yet another event::"
msgstr ""

#: ../../../trace/histogram.rst:1775
msgid ""
"Expressions support the use of addition, subtraction, multiplication and "
"division operators (+-\\*/)."
msgstr ""

#: ../../../trace/histogram.rst:1778
msgid ""
"Note if division by zero cannot be detected at parse time (i.e. the divisor "
"is not a constant), the result will be -1."
msgstr ""

#: ../../../trace/histogram.rst:1781
msgid "Numeric constants can also be used directly in an expression::"
msgstr ""

#: ../../../trace/histogram.rst:1785
msgid "or assigned to a variable and referenced in a subsequent expression::"
msgstr ""

#: ../../../trace/histogram.rst:1790
msgid ""
"Variables can even hold stacktraces, which are useful with synthetic events."
msgstr ""

#: ../../../trace/histogram.rst:1793
msgid "2.6. Synthetic Events"
msgstr ""

#: ../../../trace/histogram.rst:1795
msgid ""
"Synthetic events are user-defined events generated from hist trigger "
"variables or fields associated with one or more other events.  Their purpose "
"is to provide a mechanism for displaying data spanning multiple events "
"consistent with the existing and already familiar usage for normal events."
msgstr ""

#: ../../../trace/histogram.rst:1801
msgid ""
"To define a synthetic event, the user writes a simple specification "
"consisting of the name of the new event along with one or more variables and "
"their types, which can be any valid field type, separated by semicolons, to "
"the tracing/synthetic_events file."
msgstr ""

#: ../../../trace/histogram.rst:1806
msgid "See synth_field_size() for available types."
msgstr ""

#: ../../../trace/histogram.rst:1808
msgid ""
"If field_name contains [n], the field is considered to be a static array."
msgstr ""

#: ../../../trace/histogram.rst:1810
msgid ""
"If field_names contains[] (no subscript), the field is considered to be a "
"dynamic array, which will only take as much space in the event as is "
"required to hold the array."
msgstr ""

#: ../../../trace/histogram.rst:1814
msgid "A string field can be specified using either the static notation:"
msgstr ""

#: ../../../trace/histogram.rst:1816
msgid "char name[32];"
msgstr ""

#: ../../../trace/histogram.rst:1818
msgid "Or the dynamic:"
msgstr ""

#: ../../../trace/histogram.rst:1820
msgid "char name[];"
msgstr ""

#: ../../../trace/histogram.rst:1822
msgid "The size limit for either is 256."
msgstr ""

#: ../../../trace/histogram.rst:1824
msgid ""
"For instance, the following creates a new event named 'wakeup_latency' with "
"3 fields: lat, pid, and prio.  Each of those fields is simply a variable "
"reference to a variable on another event::"
msgstr ""

#: ../../../trace/histogram.rst:1834
msgid ""
"Reading the tracing/synthetic_events file lists all the currently defined "
"synthetic events, in this case the event defined above::"
msgstr ""

#: ../../../trace/histogram.rst:1840
msgid ""
"An existing synthetic event definition can be removed by prepending the "
"command that defined it with a '!'::"
msgstr ""

#: ../../../trace/histogram.rst:1846
msgid ""
"At this point, there isn't yet an actual 'wakeup_latency' event instantiated "
"in the event subsystem - for this to happen, a 'hist trigger action' needs "
"to be instantiated and bound to actual fields and variables defined on other "
"events (see Section 2.7. below on how that is done using hist trigger "
"'onmatch' action). Once that is done, the 'wakeup_latency' synthetic event "
"instance is created."
msgstr ""

#: ../../../trace/histogram.rst:1853
msgid ""
"The new event is created under the tracing/events/synthetic/ directory and "
"looks and behaves just like any other event::"
msgstr ""

#: ../../../trace/histogram.rst:1859
msgid "A histogram can now be defined for the new synthetic event::"
msgstr ""

#: ../../../trace/histogram.rst:1864
msgid "The above shows the latency \"lat\" in a power of 2 grouping."
msgstr ""

#: ../../../trace/histogram.rst:1866
msgid ""
"Like any other event, once a histogram is enabled for the event, the output "
"can be displayed by reading the event's 'hist' file::"
msgstr ""

#: ../../../trace/histogram.rst:1913
msgid ""
"The latency values can also be grouped linearly by a given size with the \"."
"buckets\" modifier and specify a size (in this case groups of 10)::"
msgstr ""

#: ../../../trace/histogram.rst:1946
msgid ""
"To save stacktraces, create a synthetic event with a field of type "
"\"unsigned long[]\" or even just \"long[]\". For example, to see how long a "
"task is blocked in an uninterruptible state::"
msgstr ""

#: ../../../trace/histogram.rst:1993
msgid ""
"A synthetic event that has a stacktrace field may use it as a key in "
"histogram::"
msgstr ""

#: ../../../trace/histogram.rst:2098
msgid "2.7. Hist trigger 'handlers' and 'actions'"
msgstr ""

#: ../../../trace/histogram.rst:2100
msgid ""
"A hist trigger 'action' is a function that's executed (in most cases "
"conditionally) whenever a histogram entry is added or updated."
msgstr ""

#: ../../../trace/histogram.rst:2103
msgid ""
"When a histogram entry is added or updated, a hist trigger 'handler' is what "
"decides whether the corresponding action is actually invoked or not."
msgstr ""

#: ../../../trace/histogram.rst:2107
msgid ""
"Hist trigger handlers and actions are paired together in the general form:"
msgstr ""

#: ../../../trace/histogram.rst:2110
msgid "<handler>.<action>"
msgstr ""

#: ../../../trace/histogram.rst:2112
msgid ""
"To specify a handler.action pair for a given event, simply specify that "
"handler.action pair between colons in the hist trigger specification."
msgstr ""

#: ../../../trace/histogram.rst:2116
msgid ""
"In theory, any handler can be combined with any action, but in practice, not "
"every handler.action combination is currently supported; if a given handler."
"action combination isn't supported, the hist trigger will fail with -EINVAL;"
msgstr ""

#: ../../../trace/histogram.rst:2121
msgid ""
"The default 'handler.action' if none is explicitly specified is as it always "
"has been, to simply update the set of values associated with an entry.  Some "
"applications, however, may want to perform additional actions at that point, "
"such as generate another event, or compare and save a maximum."
msgstr ""

#: ../../../trace/histogram.rst:2127
msgid ""
"The supported handlers and actions are listed below, and each is described "
"in more detail in the following paragraphs, in the context of descriptions "
"of some common and useful handler.action combinations."
msgstr ""

#: ../../../trace/histogram.rst:2131
msgid "The available handlers are:"
msgstr ""

#: ../../../trace/histogram.rst:2133
msgid "onmatch(matching.event)    - invoke action on any addition or update"
msgstr ""

#: ../../../trace/histogram.rst:2134
msgid "onmax(var)                 - invoke action if var exceeds current max"
msgstr ""

#: ../../../trace/histogram.rst:2135
msgid "onchange(var)              - invoke action if var changes"
msgstr ""

#: ../../../trace/histogram.rst:2137
msgid "The available actions are:"
msgstr ""

#: ../../../trace/histogram.rst:2139
msgid "trace(<synthetic_event_name>,param list)   - generate synthetic event"
msgstr ""

#: ../../../trace/histogram.rst:2140
msgid "save(field,...)                            - save current event fields"
msgstr ""

#: ../../../trace/histogram.rst:2141
msgid "snapshot()                                 - snapshot the trace buffer"
msgstr ""

#: ../../../trace/histogram.rst:2143
msgid "The following commonly-used handler.action pairs are available:"
msgstr ""

#: ../../../trace/histogram.rst:2145
msgid "onmatch(matching.event).trace(<synthetic_event_name>,param list)"
msgstr ""

#: ../../../trace/histogram.rst:2147
msgid ""
"The 'onmatch(matching.event).trace(<synthetic_event_name>,param list)' hist "
"trigger action is invoked whenever an event matches and the histogram entry "
"would be added or updated.  It causes the named synthetic event to be "
"generated with the values given in the 'param list'.  The result is the "
"generation of a synthetic event that consists of the values contained in "
"those variables at the time the invoking event was hit.  For example, if the "
"synthetic event name is 'wakeup_latency', a wakeup_latency event is "
"generated using onmatch(event).trace(wakeup_latency,arg1,arg2)."
msgstr ""

#: ../../../trace/histogram.rst:2157
msgid ""
"There is also an equivalent alternative form available for generating "
"synthetic events.  In this form, the synthetic event name is used as if it "
"were a function name.  For example, using the 'wakeup_latency' synthetic "
"event name again, the wakeup_latency event would be generated by invoking it "
"as if it were a function call, with the event field values passed in as "
"arguments: onmatch(event).wakeup_latency(arg1,arg2).  The syntax for this "
"form is:"
msgstr ""

#: ../../../trace/histogram.rst:2166
msgid "onmatch(matching.event).<synthetic_event_name>(param list)"
msgstr ""

#: ../../../trace/histogram.rst:2168
msgid ""
"In either case, the 'param list' consists of one or more parameters which "
"may be either variables or fields defined on either the 'matching.event' or "
"the target event.  The variables or fields specified in the param list may "
"be either fully-qualified or unqualified.  If a variable is specified as "
"unqualified, it must be unique between the two events.  A field name used as "
"a param can be unqualified if it refers to the target event, but must be "
"fully qualified if it refers to the matching event.  A fully-qualified name "
"is of the form 'system.event_name.$var_name' or 'system.event_name.field'."
msgstr ""

#: ../../../trace/histogram.rst:2179
msgid ""
"The 'matching.event' specification is simply the fully qualified event name "
"of the event that matches the target event for the onmatch() functionality, "
"in the form 'system.event_name'. Histogram keys of both events are compared "
"to find if events match. In case multiple histogram keys are used, they all "
"must match in the specified order."
msgstr ""

#: ../../../trace/histogram.rst:2186
msgid ""
"Finally, the number and type of variables/fields in the 'param list' must "
"match the number and types of the fields in the synthetic event being "
"generated."
msgstr ""

#: ../../../trace/histogram.rst:2190
msgid ""
"As an example the below defines a simple synthetic event and uses a variable "
"defined on the sched_wakeup_new event as a parameter when invoking the "
"synthetic event.  Here we define the synthetic event::"
msgstr ""

#: ../../../trace/histogram.rst:2201
msgid ""
"The following hist trigger both defines the missing testpid variable and "
"specifies an onmatch() action that generates a wakeup_new_test synthetic "
"event whenever a sched_wakeup_new event occurs, which because of the 'if "
"comm == \"cyclictest\"' filter only happens when the executable is "
"cyclictest::"
msgstr ""

#: ../../../trace/histogram.rst:2211
msgid "Or, equivalently, using the 'trace' keyword syntax::"
msgstr ""

#: ../../../trace/histogram.rst:2217
msgid ""
"Creating and displaying a histogram based on those events is now just a "
"matter of using the fields and new synthetic event in the tracing/events/"
"synthetic directory, as usual::"
msgstr ""

#: ../../../trace/histogram.rst:2224
msgid ""
"Running 'cyclictest' should cause wakeup_new events to generate "
"wakeup_new_test synthetic events which should result in histogram output in "
"the wakeup_new_test event's hist file::"
msgstr ""

#: ../../../trace/histogram.rst:2230
msgid ""
"A more typical usage would be to use two events to calculate a latency.  The "
"following example uses a set of hist triggers to produce a 'wakeup_latency' "
"histogram."
msgstr ""

#: ../../../trace/histogram.rst:2234
msgid "First, we define a 'wakeup_latency' synthetic event::"
msgstr ""

#: ../../../trace/histogram.rst:2239
msgid ""
"Next, we specify that whenever we see a sched_waking event for a cyclictest "
"thread, save the timestamp in a 'ts0' variable::"
msgstr ""

#: ../../../trace/histogram.rst:2246
msgid ""
"Then, when the corresponding thread is actually scheduled onto the CPU by a "
"sched_switch event (saved_pid matches next_pid), calculate the latency and "
"use that along with another variable and an event field to generate a "
"wakeup_latency synthetic event::"
msgstr ""

#: ../../../trace/histogram.rst:2256
msgid ""
"We also need to create a histogram on the wakeup_latency synthetic event in "
"order to aggregate the generated synthetic event data::"
msgstr ""

#: ../../../trace/histogram.rst:2262
msgid ""
"Finally, once we've run cyclictest to actually generate some events, we can "
"see the output by looking at the wakeup_latency synthetic event's hist file::"
msgstr ""

#: ../../../trace/histogram.rst:2268
msgid "onmax(var).save(field,..    .)"
msgstr ""

#: ../../../trace/histogram.rst:2270
msgid ""
"The 'onmax(var).save(field,...)' hist trigger action is invoked whenever the "
"value of 'var' associated with a histogram entry exceeds the current maximum "
"contained in that variable."
msgstr ""

#: ../../../trace/histogram.rst:2274
msgid ""
"The end result is that the trace event fields specified as the onmax.save() "
"params will be saved if 'var' exceeds the current maximum for that hist "
"trigger entry.  This allows context from the event that exhibited the new "
"maximum to be saved for later reference.  When the histogram is displayed, "
"additional fields displaying the saved values will be printed."
msgstr ""

#: ../../../trace/histogram.rst:2281
msgid ""
"As an example the below defines a couple of hist triggers, one for "
"sched_waking and another for sched_switch, keyed on pid.  Whenever a "
"sched_waking occurs, the timestamp is saved in the entry corresponding to "
"the current pid, and when the scheduler switches back to that pid, the "
"timestamp difference is calculated.  If the resulting latency, stored in "
"wakeup_lat, exceeds the current maximum latency, the values specified in the "
"save() fields are recorded::"
msgstr ""

#: ../../../trace/histogram.rst:2300
msgid ""
"When the histogram is displayed, the max value and the saved values "
"corresponding to the max are displayed following the rest of the fields::"
msgstr ""

#: ../../../trace/histogram.rst:2321
msgid "onmax(var).snapshot()"
msgstr ""

#: ../../../trace/histogram.rst:2323
msgid ""
"The 'onmax(var).snapshot()' hist trigger action is invoked whenever the "
"value of 'var' associated with a histogram entry exceeds the current maximum "
"contained in that variable."
msgstr ""

#: ../../../trace/histogram.rst:2327
msgid ""
"The end result is that a global snapshot of the trace buffer will be saved "
"in the tracing/snapshot file if 'var' exceeds the current maximum for any "
"hist trigger entry."
msgstr ""

#: ../../../trace/histogram.rst:2331
msgid ""
"Note that in this case the maximum is a global maximum for the current trace "
"instance, which is the maximum across all buckets of the histogram.  The key "
"of the specific trace event that caused the global maximum and the global "
"maximum itself are displayed, along with a message stating that a snapshot "
"has been taken and where to find it.  The user can use the key information "
"displayed to locate the corresponding bucket in the histogram for even more "
"detail."
msgstr ""

#: ../../../trace/histogram.rst:2340
msgid ""
"As an example the below defines a couple of hist triggers, one for "
"sched_waking and another for sched_switch, keyed on pid.  Whenever a "
"sched_waking event occurs, the timestamp is saved in the entry corresponding "
"to the current pid, and when the scheduler switches back to that pid, the "
"timestamp difference is calculated.  If the resulting latency, stored in "
"wakeup_lat, exceeds the current maximum latency, a snapshot is taken.  As "
"part of the setup, all the scheduler events are also enabled, which are the "
"events that will show up in the snapshot when it is taken at some point::"
msgstr ""

#: ../../../trace/histogram.rst:2362
msgid ""
"When the histogram is displayed, for each bucket the max value and the saved "
"values corresponding to the max are displayed following the rest of the "
"fields."
msgstr ""

#: ../../../trace/histogram.rst:2366
msgid ""
"If a snapshot was taken, there is also a message indicating that, along with "
"the value and event that triggered the global maximum::"
msgstr ""

#: ../../../trace/histogram.rst:2391
msgid ""
"In the above case, the event that triggered the global maximum has the key "
"with next_pid == 2103.  If you look at the bucket that has 2103 as the key, "
"you'll find the additional values save()'d along with the local maximum for "
"that bucket, which should be the same as the global maximum (since that was "
"the same value that triggered the global snapshot)."
msgstr ""

#: ../../../trace/histogram.rst:2398
msgid ""
"And finally, looking at the snapshot data should show at or near the end the "
"event that triggered the snapshot (in this case you can verify the "
"timestamps between the sched_waking and sched_switch events, which should "
"match the time displayed in the global maximum)::"
msgstr ""

#: ../../../trace/histogram.rst:2430
msgid "onchange(var).save(field,.. .)"
msgstr ""

#: ../../../trace/histogram.rst:2432
msgid ""
"The 'onchange(var).save(field,...)' hist trigger action is invoked whenever "
"the value of 'var' associated with a histogram entry changes."
msgstr ""

#: ../../../trace/histogram.rst:2436
msgid ""
"The end result is that the trace event fields specified as the onchange."
"save() params will be saved if 'var' changes for that hist trigger entry.  "
"This allows context from the event that changed the value to be saved for "
"later reference.  When the histogram is displayed, additional fields "
"displaying the saved values will be printed."
msgstr ""

#: ../../../trace/histogram.rst:2443
msgid "onchange(var).snapshot()"
msgstr ""

#: ../../../trace/histogram.rst:2445
msgid ""
"The 'onchange(var).snapshot()' hist trigger action is invoked whenever the "
"value of 'var' associated with a histogram entry changes."
msgstr ""

#: ../../../trace/histogram.rst:2449
msgid ""
"The end result is that a global snapshot of the trace buffer will be saved "
"in the tracing/snapshot file if 'var' changes for any hist trigger entry."
msgstr ""

#: ../../../trace/histogram.rst:2453
msgid ""
"Note that in this case the changed value is a global variable associated "
"with current trace instance.  The key of the specific trace event that "
"caused the value to change and the global value itself are displayed, along "
"with a message stating that a snapshot has been taken and where to find it.  "
"The user can use the key information displayed to locate the corresponding "
"bucket in the histogram for even more detail."
msgstr ""

#: ../../../trace/histogram.rst:2461
msgid ""
"As an example the below defines a hist trigger on the tcp_probe event, keyed "
"on dport.  Whenever a tcp_probe event occurs, the cwnd field is checked "
"against the current value stored in the $cwnd variable.  If the value has "
"changed, a snapshot is taken. As part of the setup, all the scheduler and "
"tcp events are also enabled, which are the events that will show up in the "
"snapshot when it is taken at some point::"
msgstr ""

#: ../../../trace/histogram.rst:2477
msgid ""
"When the histogram is displayed, for each bucket the tracked value and the "
"saved values corresponding to that value are displayed following the rest of "
"the fields."
msgstr ""

#: ../../../trace/histogram.rst:2481
msgid ""
"If a snapshot was taken, there is also a message indicating that, along with "
"the value and event that triggered the snapshot::"
msgstr ""

#: ../../../trace/histogram.rst:2508
msgid ""
"In the above case, the event that triggered the snapshot has the key with "
"dport == 80.  If you look at the bucket that has 80 as the key, you'll find "
"the additional values save()'d along with the changed value for that bucket, "
"which should be the same as the global changed value (since that was the "
"same value that triggered the global snapshot)."
msgstr ""

#: ../../../trace/histogram.rst:2515
msgid ""
"And finally, looking at the snapshot data should show at or near the end the "
"event that triggered the snapshot::"
msgstr ""

#: ../../../trace/histogram.rst:2530
msgid "2.8. User space creating a trigger"
msgstr ""

#: ../../../trace/histogram.rst:2532
msgid ""
"Writing into /sys/kernel/tracing/trace_marker writes into the ftrace ring "
"buffer. This can also act like an event, by writing into the trigger file "
"located in /sys/kernel/tracing/events/ftrace/print/"
msgstr ""

#: ../../../trace/histogram.rst:2536
msgid ""
"Modifying cyclictest to write into the trace_marker file before it sleeps "
"and after it wakes up, something like this::"
msgstr ""

#: ../../../trace/histogram.rst:2548
msgid "And later add something like::"
msgstr ""

#: ../../../trace/histogram.rst:2554
msgid "We can make a histogram from this::"
msgstr ""

#: ../../../trace/histogram.rst:2562
msgid ""
"The above created a synthetic event called \"latency\" and two histograms "
"against the trace_marker, one gets triggered when \"start\" is written into "
"the trace_marker file and the other when \"end\" is written. If the pids "
"match, then it will call the \"latency\" synthetic event with the calculated "
"latency as its parameter. Finally, a histogram is added to the latency "
"synthetic event to record the calculated latency along with the pid."
msgstr ""

#: ../../../trace/histogram.rst:2569
msgid "Now running cyclictest with::"
msgstr ""

#: ../../../trace/histogram.rst:2582
msgid "Note, the -b 1000 is used just to make --tracemark available."
msgstr ""

#: ../../../trace/histogram.rst:2584
msgid "Then we can see the histogram created by this with::"
msgstr ""

#: ../../../trace/histogram.rst:2876
msgid ""
"Note, the writes are around the sleep, so ideally they will all be of 250 "
"microseconds. If you are wondering how there are several that are under 250 "
"microseconds, that is because the way cyclictest works, is if one iteration "
"comes in late, the next one will set the timer to wake up less that 250. "
"That is, if an iteration came in 50 microseconds late, the next wake up will "
"be at 200 microseconds."
msgstr ""

#: ../../../trace/histogram.rst:2883
msgid ""
"But this could easily be done in userspace. To make this even more "
"interesting, we can mix the histogram between events that happened in the "
"kernel with trace_marker::"
msgstr ""

#: ../../../trace/histogram.rst:2893
msgid ""
"The difference this time is that instead of using the trace_marker to start "
"the latency, the sched_waking event is used, matching the common_pid for the "
"trace_marker write with the pid that is being woken by sched_waking."
msgstr ""

#: ../../../trace/histogram.rst:2897
msgid "After running cyclictest again with the same parameters, we now have::"
msgstr ""

#: ../../../trace/histogram.rst:3069
msgid ""
"This doesn't tell us any information about how late cyclictest may have "
"woken up, but it does show us a nice histogram of how long it took from the "
"time that cyclictest was woken to the time it made it into user space."
msgstr ""
