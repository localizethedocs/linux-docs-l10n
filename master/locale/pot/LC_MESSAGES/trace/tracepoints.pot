# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/tracepoints.rst:3
msgid "Using the Linux Kernel Tracepoints"
msgstr ""

#: ../../../trace/tracepoints.rst:0
msgid "Author"
msgstr ""

#: ../../../trace/tracepoints.rst:5
msgid "Mathieu Desnoyers"
msgstr ""

#: ../../../trace/tracepoints.rst:8
msgid ""
"This document introduces Linux Kernel Tracepoints and their use. It provides "
"examples of how to insert tracepoints in the kernel and connect probe "
"functions to them and provides some examples of probe functions."
msgstr ""

#: ../../../trace/tracepoints.rst:15
msgid "Purpose of tracepoints"
msgstr ""

#: ../../../trace/tracepoints.rst:16
msgid ""
"A tracepoint placed in code provides a hook to call a function (probe) that "
"you can provide at runtime. A tracepoint can be \"on\" (a probe is connected "
"to it) or \"off\" (no probe is attached). When a tracepoint is \"off\" it "
"has no effect, except for adding a tiny time penalty (checking a condition "
"for a branch) and space penalty (adding a few bytes for the function call at "
"the end of the instrumented function and adds a data structure in a separate "
"section).  When a tracepoint is \"on\", the function you provide is called "
"each time the tracepoint is executed, in the execution context of the "
"caller. When the function provided ends its execution, it returns to the "
"caller (continuing from the tracepoint site)."
msgstr ""

#: ../../../trace/tracepoints.rst:28
msgid ""
"You can put tracepoints at important locations in the code. They are "
"lightweight hooks that can pass an arbitrary number of parameters, whose "
"prototypes are described in a tracepoint declaration placed in a header file."
msgstr ""

#: ../../../trace/tracepoints.rst:33
msgid "They can be used for tracing and performance accounting."
msgstr ""

#: ../../../trace/tracepoints.rst:37
msgid "Usage"
msgstr ""

#: ../../../trace/tracepoints.rst:38
msgid "Two elements are required for tracepoints :"
msgstr ""

#: ../../../trace/tracepoints.rst:40
msgid "A tracepoint definition, placed in a header file."
msgstr ""

#: ../../../trace/tracepoints.rst:41
msgid "The tracepoint statement, in C code."
msgstr ""

#: ../../../trace/tracepoints.rst:43
msgid "In order to use tracepoints, you should include linux/tracepoint.h."
msgstr ""

#: ../../../trace/tracepoints.rst:45
msgid "In include/trace/events/subsys.h::"
msgstr ""

#: ../../../trace/tracepoints.rst:64
msgid "In subsys/file.c (where the tracing statement must be added)::"
msgstr ""

#: ../../../trace/tracepoints.rst:78
msgid "Where :"
msgstr ""

#: ../../../trace/tracepoints.rst:79
msgid "subsys_eventname is an identifier unique to your event"
msgstr ""

#: ../../../trace/tracepoints.rst:81
msgid "subsys is the name of your subsystem."
msgstr ""

#: ../../../trace/tracepoints.rst:82
msgid "eventname is the name of the event to trace."
msgstr ""

#: ../../../trace/tracepoints.rst:84
msgid ""
"`TP_PROTO(int firstarg, struct task_struct *p)` is the prototype of the "
"function called by this tracepoint."
msgstr ""

#: ../../../trace/tracepoints.rst:87
msgid ""
"`TP_ARGS(firstarg, p)` are the parameters names, same as found in the "
"prototype."
msgstr ""

#: ../../../trace/tracepoints.rst:90
msgid ""
"if you use the header in multiple source files, `#define "
"CREATE_TRACE_POINTS` should appear only in one source file."
msgstr ""

#: ../../../trace/tracepoints.rst:93
msgid ""
"Connecting a function (probe) to a tracepoint is done by providing a probe "
"(function to call) for the specific tracepoint through "
"register_trace_subsys_eventname().  Removing a probe is done through "
"unregister_trace_subsys_eventname(); it will remove the probe."
msgstr ""

#: ../../../trace/tracepoints.rst:98
msgid ""
"tracepoint_synchronize_unregister() must be called before the end of the "
"module exit function to make sure there is no caller left using the probe. "
"This, and the fact that preemption is disabled around the probe call, make "
"sure that probe removal and module unload are safe."
msgstr ""

#: ../../../trace/tracepoints.rst:103
msgid ""
"The tracepoint mechanism supports inserting multiple instances of the same "
"tracepoint, but a single definition must be made of a given tracepoint name "
"over all the kernel to make sure no type conflict will occur. Name mangling "
"of the tracepoints is done using the prototypes to make sure typing is "
"correct. Verification of probe type correctness is done at the registration "
"site by the compiler. Tracepoints can be put in inline functions, inlined "
"static functions, and unrolled loops as well as regular functions."
msgstr ""

#: ../../../trace/tracepoints.rst:112
msgid ""
"The naming scheme \"subsys_event\" is suggested here as a convention "
"intended to limit collisions. Tracepoint names are global to the kernel: "
"they are considered as being the same whether they are in the core kernel "
"image or in modules."
msgstr ""

#: ../../../trace/tracepoints.rst:117
msgid ""
"If the tracepoint has to be used in kernel modules, an "
"EXPORT_TRACEPOINT_SYMBOL_GPL() or EXPORT_TRACEPOINT_SYMBOL() can be used to "
"export the defined tracepoints."
msgstr ""

#: ../../../trace/tracepoints.rst:121
msgid ""
"If you need to do a bit of work for a tracepoint parameter, and that work is "
"only used for the tracepoint, that work can be encapsulated within an if "
"statement with the following::"
msgstr ""

#: ../../../trace/tracepoints.rst:135
msgid ""
"All trace_<tracepoint>_tp() calls have a matching "
"trace_<tracepoint>_enabled() function defined that returns true if the "
"tracepoint is enabled and false otherwise. The trace_<tracepoint>_tp() "
"should always be within the block of the if (trace_<tracepoint>_enabled()) "
"to prevent races between the tracepoint being enabled and the check being "
"seen."
msgstr ""

#: ../../../trace/tracepoints.rst:141
msgid ""
"The advantage of using the trace_<tracepoint>_enabled() is that it uses the "
"static_key of the tracepoint to allow the if statement to be implemented "
"with jump labels and avoid conditional branches."
msgstr ""

#: ../../../trace/tracepoints.rst:145
msgid ""
"The convenience macro TRACE_EVENT provides an alternative way to define "
"tracepoints. Note, DECLARE_TRACE(foo) creates a function \"trace_foo_tp()\" "
"whereas TRACE_EVENT(foo) creates a function \"trace_foo()\", and also "
"exposes the tracepoint as a trace event in /sys/kernel/tracing/events "
"directory.  Check http://lwn.net/Articles/379903, http://lwn.net/"
"Articles/381064 and http://lwn.net/Articles/383362 for a series of articles "
"with more details."
msgstr ""

#: ../../../trace/tracepoints.rst:153
msgid ""
"If you require calling a tracepoint from a header file, it is not "
"recommended to call one directly or to use the trace_<tracepoint>_enabled() "
"function call, as tracepoints in header files can have side effects if a "
"header is included from a file that has CREATE_TRACE_POINTS set, as well as "
"the trace_<tracepoint>() is not that small of an inline and can bloat the "
"kernel if used by other inlined functions. Instead, include tracepoint-defs."
"h and use tracepoint_enabled()."
msgstr ""

#: ../../../trace/tracepoints.rst:161
msgid "In a C file::"
msgstr ""

#: ../../../trace/tracepoints.rst:170
msgid "In the header file::"
msgstr ""
