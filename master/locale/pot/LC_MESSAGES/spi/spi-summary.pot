# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../spi/spi-summary.rst:3
msgid "Overview of Linux kernel SPI support"
msgstr ""

#: ../../../spi/spi-summary.rst:5
msgid "02-Feb-2012"
msgstr ""

#: ../../../spi/spi-summary.rst:8
msgid "What is SPI?"
msgstr ""

#: ../../../spi/spi-summary.rst:9
msgid ""
"The \"Serial Peripheral Interface\" (SPI) is a synchronous four wire serial "
"link used to connect microcontrollers to sensors, memory, and peripherals. "
"It's a simple \"de facto\" standard, not complicated enough to acquire a "
"standardization body.  SPI uses a host/target configuration."
msgstr ""

#: ../../../spi/spi-summary.rst:14
msgid ""
"The three signal wires hold a clock (SCK, often on the order of 10 MHz), and "
"parallel data lines with \"Master Out, Slave In\" (MOSI) or \"Master In, "
"Slave Out\" (MISO) signals.  (Other names are also used.)  There are four "
"clocking modes through which data is exchanged; mode-0 and mode-3 are most "
"commonly used.  Each clock cycle shifts data out and data in; the clock "
"doesn't cycle except when there is a data bit to shift.  Not all data bits "
"are used though; not every protocol uses those full duplex capabilities."
msgstr ""

#: ../../../spi/spi-summary.rst:22
msgid ""
"SPI hosts use a fourth \"chip select\" line to activate a given SPI target "
"device, so those three signal wires may be connected to several chips in "
"parallel.  All SPI targets support chipselects; they are usually active low "
"signals, labeled nCSx for target 'x' (e.g. nCS0).  Some devices have other "
"signals, often including an interrupt to the host."
msgstr ""

#: ../../../spi/spi-summary.rst:28
msgid ""
"Unlike serial busses like USB or SMBus, even low level protocols for SPI "
"target functions are usually not interoperable between vendors (except for "
"commodities like SPI memory chips)."
msgstr ""

#: ../../../spi/spi-summary.rst:32
msgid ""
"SPI may be used for request/response style device protocols, as with "
"touchscreen sensors and memory chips."
msgstr ""

#: ../../../spi/spi-summary.rst:35
msgid ""
"It may also be used to stream data in either direction (half duplex), or "
"both of them at the same time (full duplex)."
msgstr ""

#: ../../../spi/spi-summary.rst:38
msgid ""
"Some devices may use eight bit words.  Others may use different word "
"lengths, such as streams of 12-bit or 20-bit digital samples."
msgstr ""

#: ../../../spi/spi-summary.rst:41
msgid ""
"Words are usually sent with their most significant bit (MSB) first, but "
"sometimes the least significant bit (LSB) goes first instead."
msgstr ""

#: ../../../spi/spi-summary.rst:44
msgid "Sometimes SPI is used to daisy-chain devices, like shift registers."
msgstr ""

#: ../../../spi/spi-summary.rst:46
msgid ""
"In the same way, SPI targets will only rarely support any kind of automatic "
"discovery/enumeration protocol. The tree of target devices accessible from a "
"given SPI host controller will normally be set up manually, with "
"configuration tables."
msgstr ""

#: ../../../spi/spi-summary.rst:51
msgid ""
"SPI is only one of the names used by such four-wire protocols, and most "
"controllers have no problem handling \"MicroWire\" (think of it as half-"
"duplex SPI, for request/response protocols), SSP (\"Synchronous Serial "
"Protocol\"), PSP (\"Programmable Serial Protocol\"), and other related "
"protocols."
msgstr ""

#: ../../../spi/spi-summary.rst:57
msgid ""
"Some chips eliminate a signal line by combining MOSI and MISO, and limiting "
"themselves to half-duplex at the hardware level.  In fact some SPI chips "
"have this signal mode as a strapping option.  These can be accessed using "
"the same programming interface as SPI, but of course they won't handle full "
"duplex transfers.  You may find such chips described as using \"three wire\" "
"signaling: SCK, data, nCSx. (That data line is sometimes called MOMI or "
"SISO.)"
msgstr ""

#: ../../../spi/spi-summary.rst:65
msgid ""
"Microcontrollers often support both host and target sides of the SPI "
"protocol.  This document (and Linux) supports both the host and target sides "
"of SPI interactions."
msgstr ""

#: ../../../spi/spi-summary.rst:71
msgid "Who uses it?  On what kinds of systems?"
msgstr ""

#: ../../../spi/spi-summary.rst:72
msgid ""
"Linux developers using SPI are probably writing device drivers for embedded "
"systems boards.  SPI is used to control external chips, and it is also a "
"protocol supported by every MMC or SD memory card.  (The older \"DataFlash\" "
"cards, predating MMC cards but using the same connectors and card shape, "
"support only SPI.)  Some PC hardware uses SPI flash for BIOS code."
msgstr ""

#: ../../../spi/spi-summary.rst:78
msgid ""
"SPI target chips range from digital/analog converters used for analog "
"sensors and codecs, to memory, to peripherals like USB controllers or "
"Ethernet adapters; and more."
msgstr ""

#: ../../../spi/spi-summary.rst:82
msgid ""
"Most systems using SPI will integrate a few devices on a mainboard. Some "
"provide SPI links on expansion connectors; in cases where no dedicated SPI "
"controller exists, GPIO pins can be used to create a low speed "
"\"bitbanging\" adapter.  Very few systems will \"hotplug\" an SPI "
"controller; the reasons to use SPI focus on low cost and simple operation, "
"and if dynamic reconfiguration is important, USB will often be a more "
"appropriate low-pincount peripheral bus."
msgstr ""

#: ../../../spi/spi-summary.rst:90
msgid ""
"Many microcontrollers that can run Linux integrate one or more I/O "
"interfaces with SPI modes.  Given SPI support, they could use MMC or SD "
"cards without needing a special purpose MMC/SD/SDIO controller."
msgstr ""

#: ../../../spi/spi-summary.rst:96
msgid "I'm confused.  What are these four SPI \"clock modes\"?"
msgstr ""

#: ../../../spi/spi-summary.rst:97
msgid ""
"It's easy to be confused here, and the vendor documentation you'll find "
"isn't necessarily helpful.  The four modes combine two mode bits:"
msgstr ""

#: ../../../spi/spi-summary.rst:100
msgid ""
"CPOL indicates the initial clock polarity.  CPOL=0 means the clock starts "
"low, so the first (leading) edge is rising, and the second (trailing) edge "
"is falling.  CPOL=1 means the clock starts high, so the first (leading) edge "
"is falling."
msgstr ""

#: ../../../spi/spi-summary.rst:105
msgid ""
"CPHA indicates the clock phase used to sample data; CPHA=0 says sample on "
"the leading edge, CPHA=1 means the trailing edge."
msgstr ""

#: ../../../spi/spi-summary.rst:108
msgid ""
"Since the signal needs to stabilize before it's sampled, CPHA=0 implies that "
"its data is written half a clock before the first clock edge.  The "
"chipselect may have made it become available."
msgstr ""

#: ../../../spi/spi-summary.rst:112
msgid ""
"Chip specs won't always say \"uses SPI mode X\" in as many words, but their "
"timing diagrams will make the CPOL and CPHA modes clear."
msgstr ""

#: ../../../spi/spi-summary.rst:115
msgid ""
"In the SPI mode number, CPOL is the high order bit and CPHA is the low order "
"bit.  So when a chip's timing diagram shows the clock starting low (CPOL=0) "
"and data stabilized for sampling during the trailing clock edge (CPHA=1), "
"that's SPI mode 1."
msgstr ""

#: ../../../spi/spi-summary.rst:120
msgid ""
"Note that the clock mode is relevant as soon as the chipselect goes active.  "
"So the host must set the clock to inactive before selecting a target, and "
"the target can tell the chosen polarity by sampling the clock level when its "
"select line goes active.  That's why many devices support for example both "
"modes 0 and 3:  they don't care about polarity, and always clock data in/out "
"on rising clock edges."
msgstr ""

#: ../../../spi/spi-summary.rst:129
msgid "How do these driver programming interfaces work?"
msgstr ""

#: ../../../spi/spi-summary.rst:130
msgid ""
"The <linux/spi/spi.h> header file includes kerneldoc, as does the main "
"source code, and you should certainly read that chapter of the kernel API "
"document.  This is just an overview, so you get the big picture before those "
"details."
msgstr ""

#: ../../../spi/spi-summary.rst:135
msgid ""
"SPI requests always go into I/O queues.  Requests for a given SPI device are "
"always executed in FIFO order, and complete asynchronously through "
"completion callbacks.  There are also some simple synchronous wrappers for "
"those calls, including ones for common transaction types like writing a "
"command and then reading its response."
msgstr ""

#: ../../../spi/spi-summary.rst:141
msgid "There are two types of SPI driver, here called:"
msgstr ""

#: ../../../spi/spi-summary.rst:143
msgid "Controller drivers ..."
msgstr ""

#: ../../../spi/spi-summary.rst:144
msgid ""
"controllers may be built into System-On-Chip processors, and often support "
"both Controller and target roles. These drivers touch hardware registers and "
"may use DMA. Or they can be PIO bitbangers, needing just GPIO pins."
msgstr ""

#: ../../../spi/spi-summary.rst:149
msgid "Protocol drivers ..."
msgstr ""

#: ../../../spi/spi-summary.rst:150
msgid ""
"these pass messages through the controller driver to communicate with a "
"target or Controller device on the other side of an SPI link."
msgstr ""

#: ../../../spi/spi-summary.rst:154
msgid ""
"So for example one protocol driver might talk to the MTD layer to export "
"data to filesystems stored on SPI flash like DataFlash; and others might "
"control audio interfaces, present touchscreen sensors as input interfaces, "
"or monitor temperature and voltage levels during industrial processing. And "
"those might all be sharing the same controller driver."
msgstr ""

#: ../../../spi/spi-summary.rst:160
msgid ""
"A \"struct spi_device\" encapsulates the controller-side interface between "
"those two types of drivers."
msgstr ""

#: ../../../spi/spi-summary.rst:163
msgid ""
"There is a minimal core of SPI programming interfaces, focussing on using "
"the driver model to connect controller and protocol drivers using device "
"tables provided by board specific initialization code.  SPI shows up in "
"sysfs in several locations::"
msgstr ""

#: ../../../spi/spi-summary.rst:199
msgid ""
"At this time, the only class-specific state is the bus number (\"B\" in "
"\"spiB\"), so those /sys/class entries are only useful to quickly identify "
"busses."
msgstr ""

#: ../../../spi/spi-summary.rst:204
msgid "How does board-specific init code declare SPI devices?"
msgstr ""

#: ../../../spi/spi-summary.rst:205
msgid ""
"Linux needs several kinds of information to properly configure SPI devices. "
"That information is normally provided by board-specific code, even for chips "
"that do support some of automated discovery/enumeration."
msgstr ""

#: ../../../spi/spi-summary.rst:210
msgid "Declare Controllers"
msgstr ""

#: ../../../spi/spi-summary.rst:212
msgid ""
"The first kind of information is a list of what SPI controllers exist. For "
"System-on-Chip (SOC) based boards, these will usually be platform devices, "
"and the controller may need some platform_data in order to operate "
"properly.  The \"struct platform_device\" will include resources like the "
"physical address of the controller's first register and its IRQ."
msgstr ""

#: ../../../spi/spi-summary.rst:218
msgid ""
"Platforms will often abstract the \"register SPI controller\" operation, "
"maybe coupling it with code to initialize pin configurations, so that the "
"arch/.../mach-*/board-*.c files for several boards can all share the same "
"basic controller setup code.  This is because most SOCs have several SPI-"
"capable controllers, and only the ones actually usable on a given board "
"should normally be set up and registered."
msgstr ""

#: ../../../spi/spi-summary.rst:225
msgid "So for example arch/.../mach-*/board-*.c files might have code like::"
msgstr ""

#: ../../../spi/spi-summary.rst:242
msgid "And SOC-specific utility code might look something like::"
msgstr ""

#: ../../../spi/spi-summary.rst:268
msgid ""
"Notice how the platform_data for boards may be different, even if the same "
"SOC controller is used.  For example, on one board SPI might use an external "
"clock, where another derives the SPI clock from current settings of some "
"master clock."
msgstr ""

#: ../../../spi/spi-summary.rst:274
msgid "Declare target Devices"
msgstr ""

#: ../../../spi/spi-summary.rst:276
msgid ""
"The second kind of information is a list of what SPI target devices exist on "
"the target board, often with some board-specific data needed for the driver "
"to work correctly."
msgstr ""

#: ../../../spi/spi-summary.rst:280
msgid ""
"Normally your arch/.../mach-*/board-*.c files would provide a small table "
"listing the SPI devices on each board.  (This would typically be only a "
"small handful.)  That might look like::"
msgstr ""

#: ../../../spi/spi-summary.rst:302
msgid ""
"Again, notice how board-specific information is provided; each chip may need "
"several types.  This example shows generic constraints like the fastest SPI "
"clock to allow (a function of board voltage in this case) or how an IRQ pin "
"is wired, plus chip-specific constraints like an important delay that's "
"changed by the capacitance at one pin."
msgstr ""

#: ../../../spi/spi-summary.rst:308
msgid ""
"(There's also \"controller_data\", information that may be useful to the "
"controller driver.  An example would be peripheral-specific DMA tuning data "
"or chipselect callbacks.  This is stored in spi_device later.)"
msgstr ""

#: ../../../spi/spi-summary.rst:312
msgid ""
"The board_info should provide enough information to let the system work "
"without the chip's driver being loaded.  The most troublesome aspect of that "
"is likely the SPI_CS_HIGH bit in the spi_device.mode field, since sharing a "
"bus with a device that interprets chipselect \"backwards\" is not possible "
"until the infrastructure knows how to deselect it."
msgstr ""

#: ../../../spi/spi-summary.rst:318
msgid ""
"Then your board initialization code would register that table with the SPI "
"infrastructure, so that it's available later when the SPI host controller "
"driver is registered::"
msgstr ""

#: ../../../spi/spi-summary.rst:324
msgid ""
"Like with other static board-specific setup, you won't unregister those."
msgstr ""

#: ../../../spi/spi-summary.rst:326
msgid ""
"The widely used \"card\" style computers bundle memory, cpu, and little else "
"onto a card that's maybe just thirty square centimeters.  On such systems, "
"your ``arch/.../mach-.../board-*.c`` file would primarily provide "
"information about the devices on the mainboard into which such a card is "
"plugged.  That certainly includes SPI devices hooked up through the card "
"connectors!"
msgstr ""

#: ../../../spi/spi-summary.rst:334
msgid "Non-static Configurations"
msgstr ""

#: ../../../spi/spi-summary.rst:336
msgid ""
"When Linux includes support for MMC/SD/SDIO/DataFlash cards through SPI, "
"those configurations will also be dynamic.  Fortunately, such devices all "
"support basic device identification probes, so they should hotplug normally."
msgstr ""

#: ../../../spi/spi-summary.rst:342
msgid "How do I write an \"SPI Protocol Driver\"?"
msgstr ""

#: ../../../spi/spi-summary.rst:343
msgid ""
"Most SPI drivers are currently kernel drivers, but there's also support for "
"userspace drivers.  Here we talk only about kernel drivers."
msgstr ""

#: ../../../spi/spi-summary.rst:346
msgid "SPI protocol drivers somewhat resemble platform device drivers::"
msgstr ""

#: ../../../spi/spi-summary.rst:358
msgid ""
"The driver core will automatically attempt to bind this driver to any SPI "
"device whose board_info gave a modalias of \"CHIP\".  Your probe() code "
"might look like this unless you're creating a device which is managing a bus "
"(appearing under /sys/class/spi_master)."
msgstr ""

#: ../../../spi/spi-summary.rst:385
msgid ""
"As soon as it enters probe(), the driver may issue I/O requests to the SPI "
"device using \"struct spi_message\".  When remove() returns, or after "
"probe() fails, the driver guarantees that it won't submit any more such "
"messages."
msgstr ""

#: ../../../spi/spi-summary.rst:390
msgid ""
"An spi_message is a sequence of protocol operations, executed as one atomic "
"sequence.  SPI driver controls include:"
msgstr ""

#: ../../../spi/spi-summary.rst:393
msgid ""
"when bidirectional reads and writes start ... by how its sequence of "
"spi_transfer requests is arranged;"
msgstr ""

#: ../../../spi/spi-summary.rst:396
msgid ""
"which I/O buffers are used ... each spi_transfer wraps a buffer for each "
"transfer direction, supporting full duplex (two pointers, maybe the same one "
"in both cases) and half duplex (one pointer is NULL) transfers;"
msgstr ""

#: ../../../spi/spi-summary.rst:401
msgid ""
"optionally defining short delays after transfers ... using the spi_transfer."
"delay.value setting (this delay can be the only protocol effect, if the "
"buffer length is zero) ... when specifying this delay the default "
"spi_transfer.delay.unit is microseconds, however this can be adjusted to "
"clock cycles or nanoseconds if needed;"
msgstr ""

#: ../../../spi/spi-summary.rst:408
msgid ""
"whether the chipselect becomes inactive after a transfer and any delay ... "
"by using the spi_transfer.cs_change flag;"
msgstr ""

#: ../../../spi/spi-summary.rst:411
msgid ""
"hinting whether the next message is likely to go to this same device ... "
"using the spi_transfer.cs_change flag on the last transfer in that atomic "
"group, and potentially saving costs for chip deselect and select operations."
msgstr ""

#: ../../../spi/spi-summary.rst:416
msgid ""
"Follow standard kernel rules, and provide DMA-safe buffers in your "
"messages.  That way controller drivers using DMA aren't forced to make extra "
"copies unless the hardware requires it (e.g. working around hardware errata "
"that force the use of bounce buffering)."
msgstr ""

#: ../../../spi/spi-summary.rst:421
msgid ""
"The basic I/O primitive is spi_async().  Async requests may be issued in any "
"context (irq handler, task, etc) and completion is reported using a callback "
"provided with the message. After any detected error, the chip is deselected "
"and processing of that spi_message is aborted."
msgstr ""

#: ../../../spi/spi-summary.rst:427
msgid ""
"There are also synchronous wrappers like spi_sync(), and wrappers like "
"spi_read(), spi_write(), and spi_write_then_read().  These may be issued "
"only in contexts that may sleep, and they're all clean (and small, and "
"\"optional\") layers over spi_async()."
msgstr ""

#: ../../../spi/spi-summary.rst:432
msgid ""
"The spi_write_then_read() call, and convenience wrappers around it, should "
"only be used with small amounts of data where the cost of an extra copy may "
"be ignored.  It's designed to support common RPC-style requests, such as "
"writing an eight bit command and reading a sixteen bit response -- "
"spi_w8r16() being one its wrappers, doing exactly that."
msgstr ""

#: ../../../spi/spi-summary.rst:439
msgid ""
"Some drivers may need to modify spi_device characteristics like the transfer "
"mode, wordsize, or clock rate.  This is done with spi_setup(), which would "
"normally be called from probe() before the first I/O is done to the device.  "
"However, that can also be called at any time that no message is pending for "
"that device."
msgstr ""

#: ../../../spi/spi-summary.rst:445
msgid ""
"While \"spi_device\" would be the bottom boundary of the driver, the upper "
"boundaries might include sysfs (especially for sensor readings), the input "
"layer, ALSA, networking, MTD, the character device framework, or other Linux "
"subsystems."
msgstr ""

#: ../../../spi/spi-summary.rst:450
msgid ""
"Note that there are two types of memory your driver must manage as part of "
"interacting with SPI devices."
msgstr ""

#: ../../../spi/spi-summary.rst:453
msgid ""
"I/O buffers use the usual Linux rules, and must be DMA-safe. You'd normally "
"allocate them from the heap or free page pool. Don't use the stack, or "
"anything that's declared \"static\"."
msgstr ""

#: ../../../spi/spi-summary.rst:457
msgid ""
"The spi_message and spi_transfer metadata used to glue those I/O buffers "
"into a group of protocol transactions.  These can be allocated anywhere it's "
"convenient, including as part of other allocate-once driver data "
"structures.  Zero-init these."
msgstr ""

#: ../../../spi/spi-summary.rst:462
msgid ""
"If you like, spi_message_alloc() and spi_message_free() convenience routines "
"are available to allocate and zero-initialize an spi_message with several "
"transfers."
msgstr ""

#: ../../../spi/spi-summary.rst:468
msgid "How do I write an \"SPI Controller Driver\"?"
msgstr ""

#: ../../../spi/spi-summary.rst:469
msgid ""
"An SPI controller will probably be registered on the platform_bus; write a "
"driver to bind to the device, whichever bus is involved."
msgstr ""

#: ../../../spi/spi-summary.rst:472
msgid ""
"The main task of this type of driver is to provide an \"spi_controller\". "
"Use spi_alloc_host() to allocate the host controller, and "
"spi_controller_get_devdata() to get the driver-private data allocated for "
"that device."
msgstr ""

#: ../../../spi/spi-summary.rst:488
msgid ""
"The driver will initialize the fields of that spi_controller, including the "
"bus number (maybe the same as the platform device ID) and three methods used "
"to interact with the SPI core and SPI protocol drivers.  It will also "
"initialize its own internal state.  (See below about bus numbering and those "
"methods.)"
msgstr ""

#: ../../../spi/spi-summary.rst:493
msgid ""
"After you initialize the spi_controller, then use spi_register_controller() "
"to publish it to the rest of the system. At that time, device nodes for the "
"controller and any predeclared spi devices will be made available, and the "
"driver model core will take care of binding them to drivers."
msgstr ""

#: ../../../spi/spi-summary.rst:498
msgid ""
"If you need to remove your SPI controller driver, "
"spi_unregister_controller() will reverse the effect of "
"spi_register_controller()."
msgstr ""

#: ../../../spi/spi-summary.rst:503
msgid "Bus Numbering"
msgstr ""

#: ../../../spi/spi-summary.rst:505
msgid ""
"Bus numbering is important, since that's how Linux identifies a given SPI "
"bus (shared SCK, MOSI, MISO).  Valid bus numbers start at zero.  On SOC "
"systems, the bus numbers should match the numbers defined by the chip "
"manufacturer.  For example, hardware controller SPI2 would be bus number 2, "
"and spi_board_info for devices connected to it would use that number."
msgstr ""

#: ../../../spi/spi-summary.rst:511
msgid ""
"If you don't have such hardware-assigned bus number, and for some reason you "
"can't just assign them, then provide a negative bus number.  That will then "
"be replaced by a dynamically assigned number. You'd then need to treat this "
"as a non-static configuration (see above)."
msgstr ""

#: ../../../spi/spi-summary.rst:518
msgid "SPI Host Controller Methods"
msgstr ""

#: ../../../spi/spi-summary.rst:520
msgid "``ctlr->setup(struct spi_device *spi)``"
msgstr ""

#: ../../../spi/spi-summary.rst:521
msgid ""
"This sets up the device clock rate, SPI mode, and word sizes. Drivers may "
"change the defaults provided by board_info, and then call spi_setup(spi) to "
"invoke this routine.  It may sleep."
msgstr ""

#: ../../../spi/spi-summary.rst:525
msgid ""
"Unless each SPI target has its own configuration registers, don't change "
"them right away ... otherwise drivers could corrupt I/O that's in progress "
"for other SPI devices."
msgstr ""

#: ../../../spi/spi-summary.rst:531
msgid ""
"BUG ALERT:  for some reason the first version of many spi_controller drivers "
"seems to get this wrong. When you code setup(), ASSUME that the controller "
"is actively processing transfers for another device."
msgstr ""

#: ../../../spi/spi-summary.rst:536
msgid "``ctlr->cleanup(struct spi_device *spi)``"
msgstr ""

#: ../../../spi/spi-summary.rst:537
msgid ""
"Your controller driver may use spi_device.controller_state to hold state it "
"dynamically associates with that device.  If you do that, be sure to provide "
"the cleanup() method to free that state."
msgstr ""

#: ../../../spi/spi-summary.rst:541
msgid "``ctlr->prepare_transfer_hardware(struct spi_controller *ctlr)``"
msgstr ""

#: ../../../spi/spi-summary.rst:542
msgid ""
"This will be called by the queue mechanism to signal to the driver that a "
"message is coming in soon, so the subsystem requests the driver to prepare "
"the transfer hardware by issuing this call. This may sleep."
msgstr ""

#: ../../../spi/spi-summary.rst:547
msgid "``ctlr->unprepare_transfer_hardware(struct spi_controller *ctlr)``"
msgstr ""

#: ../../../spi/spi-summary.rst:548
msgid ""
"This will be called by the queue mechanism to signal to the driver that "
"there are no more messages pending in the queue and it may relax the "
"hardware (e.g. by power management calls). This may sleep."
msgstr ""

#: ../../../spi/spi-summary.rst:552
msgid ""
"``ctlr->transfer_one_message(struct spi_controller *ctlr, struct spi_message "
"*mesg)``"
msgstr ""

#: ../../../spi/spi-summary.rst:553
msgid ""
"The subsystem calls the driver to transfer a single message while queuing "
"transfers that arrive in the meantime. When the driver is finished with this "
"message, it must call spi_finalize_current_message() so the subsystem can "
"issue the next message. This may sleep."
msgstr ""

#: ../../../spi/spi-summary.rst:559
msgid ""
"``ctrl->transfer_one(struct spi_controller *ctlr, struct spi_device *spi, "
"struct spi_transfer *transfer)``"
msgstr ""

#: ../../../spi/spi-summary.rst:560
msgid ""
"The subsystem calls the driver to transfer a single transfer while queuing "
"transfers that arrive in the meantime. When the driver is finished with this "
"transfer, it must call spi_finalize_current_transfer() so the subsystem can "
"issue the next transfer. This may sleep. Note: transfer_one and "
"transfer_one_message are mutually exclusive; when both are set, the generic "
"subsystem does not call your transfer_one callback."
msgstr ""

#: ../../../spi/spi-summary.rst:568
msgid "Return values:"
msgstr ""

#: ../../../spi/spi-summary.rst:570
msgid "negative errno: error"
msgstr ""

#: ../../../spi/spi-summary.rst:571
msgid "0: transfer is finished"
msgstr ""

#: ../../../spi/spi-summary.rst:572
msgid "1: transfer is still in progress"
msgstr ""

#: ../../../spi/spi-summary.rst:574
msgid ""
"``ctrl->set_cs_timing(struct spi_device *spi, u8 setup_clk_cycles, u8 "
"hold_clk_cycles, u8 inactive_clk_cycles)``"
msgstr ""

#: ../../../spi/spi-summary.rst:575
msgid ""
"This method allows SPI client drivers to request SPI host controller for "
"configuring device specific CS setup, hold and inactive timing requirements."
msgstr ""

#: ../../../spi/spi-summary.rst:580
msgid "Deprecated Methods"
msgstr ""

#: ../../../spi/spi-summary.rst:582
msgid "``ctrl->transfer(struct spi_device *spi, struct spi_message *message)``"
msgstr ""

#: ../../../spi/spi-summary.rst:583
msgid ""
"This must not sleep. Its responsibility is to arrange that the transfer "
"happens and its complete() callback is issued. The two will normally happen "
"later, after other transfers complete, and if the controller is idle it will "
"need to be kickstarted. This method is not used on queued controllers and "
"must be NULL if transfer_one_message() and (un)prepare_transfer_hardware() "
"are implemented."
msgstr ""

#: ../../../spi/spi-summary.rst:593
msgid "SPI Message Queue"
msgstr ""

#: ../../../spi/spi-summary.rst:595
msgid ""
"If you are happy with the standard queueing mechanism provided by the SPI "
"subsystem, just implement the queued methods specified above. Using the "
"message queue has the upside of centralizing a lot of code and providing "
"pure process-context execution of methods. The message queue can also be "
"elevated to realtime priority on high-priority SPI traffic."
msgstr ""

#: ../../../spi/spi-summary.rst:601
msgid ""
"Unless the queueing mechanism in the SPI subsystem is selected, the bulk of "
"the driver will be managing the I/O queue fed by the now deprecated function "
"transfer()."
msgstr ""

#: ../../../spi/spi-summary.rst:605
msgid ""
"That queue could be purely conceptual.  For example, a driver used only for "
"low-frequency sensor access might be fine using synchronous PIO."
msgstr ""

#: ../../../spi/spi-summary.rst:608
msgid ""
"But the queue will probably be very real, using message->queue, PIO, often "
"DMA (especially if the root filesystem is in SPI flash), and execution "
"contexts like IRQ handlers, tasklets, or workqueues (such as keventd).  Your "
"driver can be as fancy, or as simple, as you need. Such a transfer() method "
"would normally just add the message to a queue, and then start some "
"asynchronous transfer engine (unless it's already running)."
msgstr ""

#: ../../../spi/spi-summary.rst:618
msgid "Extensions to the SPI protocol"
msgstr ""

#: ../../../spi/spi-summary.rst:619
msgid ""
"The fact that SPI doesn't have a formal specification or standard permits "
"chip manufacturers to implement the SPI protocol in slightly different ways. "
"In most cases, SPI protocol implementations from different vendors are "
"compatible among each other. For example, in SPI mode 0 (CPOL=0, CPHA=0) the "
"bus lines may behave like the following:"
msgstr ""

#: ../../../spi/spi-summary.rst:642 ../../../spi/spi-summary.rst:681
msgid "Legend::"
msgstr ""

#: ../../../spi/spi-summary.rst:649
msgid ""
"In some few cases, chips extend the SPI protocol by specifying line "
"behaviors that other SPI protocols don't (e.g. data line state for when CS "
"is not asserted). Those distinct SPI protocols, modes, and configurations "
"are supported by different SPI mode flags."
msgstr ""

#: ../../../spi/spi-summary.rst:655
msgid "MOSI idle state configuration"
msgstr ""

#: ../../../spi/spi-summary.rst:657
msgid ""
"Common SPI protocol implementations don't specify any state or behavior for "
"the MOSI line when the controller is not clocking out data. However, there "
"do exist peripherals that require specific MOSI line state when data is not "
"being clocked out. For example, if the peripheral expects the MOSI line to "
"be high when the controller is not clocking out data "
"(``SPI_MOSI_IDLE_HIGH``), then a transfer in SPI mode 0 would look like the "
"following:"
msgstr ""

#: ../../../spi/spi-summary.rst:688
msgid ""
"In this extension to the usual SPI protocol, the MOSI line state is "
"specified to be kept high when CS is asserted but the controller is not "
"clocking out data to the peripheral and also when CS is not asserted."
msgstr ""

#: ../../../spi/spi-summary.rst:692
msgid ""
"Peripherals that require this extension must request it by setting the "
"``SPI_MOSI_IDLE_HIGH`` bit into the mode attribute of their ``struct "
"spi_device`` and call spi_setup(). Controllers that support this extension "
"should indicate it by setting ``SPI_MOSI_IDLE_HIGH`` in the mode_bits "
"attribute of their ``struct spi_controller``. The configuration to idle MOSI "
"low is analogous but uses the ``SPI_MOSI_IDLE_LOW`` mode bit."
msgstr ""

#: ../../../spi/spi-summary.rst:701
msgid "THANKS TO"
msgstr ""

#: ../../../spi/spi-summary.rst:702
msgid ""
"Contributors to Linux-SPI discussions include (in alphabetical order, by "
"last name):"
msgstr ""

#: ../../../spi/spi-summary.rst:705
msgid "Mark Brown"
msgstr ""

#: ../../../spi/spi-summary.rst:706
msgid "David Brownell"
msgstr ""

#: ../../../spi/spi-summary.rst:707
msgid "Russell King"
msgstr ""

#: ../../../spi/spi-summary.rst:708
msgid "Grant Likely"
msgstr ""

#: ../../../spi/spi-summary.rst:709
msgid "Dmitry Pervushin"
msgstr ""

#: ../../../spi/spi-summary.rst:710
msgid "Stephen Street"
msgstr ""

#: ../../../spi/spi-summary.rst:711
msgid "Mark Underwood"
msgstr ""

#: ../../../spi/spi-summary.rst:712
msgid "Andrew Victor"
msgstr ""

#: ../../../spi/spi-summary.rst:713
msgid "Linus Walleij"
msgstr ""

#: ../../../spi/spi-summary.rst:714
msgid "Vitaly Wool"
msgstr ""
