# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../firmware-guide/acpi/enumeration.rst:5
msgid "ACPI Based Device Enumeration"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:7
msgid ""
"ACPI 5 introduced a set of new resources (UartTSerialBus, I2cSerialBus, "
"SpiSerialBus, GpioIo and GpioInt) which can be used in enumerating slave "
"devices behind serial bus controllers."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:11
msgid ""
"In addition we are starting to see peripherals integrated in the SoC/Chipset "
"to appear only in ACPI namespace. These are typically devices that are "
"accessed through memory-mapped registers."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:15
msgid ""
"In order to support this and re-use the existing drivers as much as possible "
"we decided to do following:"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:18
msgid ""
"Devices that have no bus connector resource are represented as platform "
"devices."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:21
msgid ""
"Devices behind real busses where there is a connector resource are "
"represented as struct spi_device or struct i2c_client. Note that standard "
"UARTs are not busses so there is no struct uart_device, although some of "
"them may be represented by struct serdev_device."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:26
msgid ""
"As both ACPI and Device Tree represent a tree of devices (and their "
"resources) this implementation follows the Device Tree way as much as "
"possible."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:30
msgid ""
"The ACPI implementation enumerates devices behind busses (platform, SPI, "
"I2C, and in some cases UART), creates the physical devices and binds them to "
"their ACPI handle in the ACPI namespace."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:34
msgid ""
"This means that when ACPI_HANDLE(dev) returns non-NULL the device was "
"enumerated from ACPI namespace. This handle can be used to extract other "
"device-specific configuration. There is an example of this below."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:39
msgid "Platform bus support"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:41
msgid ""
"Since we are using platform devices to represent devices that are not "
"connected to any physical bus we only need to implement a platform driver "
"for the device and add supported ACPI IDs. If this same IP-block is used on "
"some other non-ACPI platform, the driver might work out of the box or needs "
"some minor changes."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:47
msgid ""
"Adding ACPI support for an existing driver should be pretty straightforward. "
"Here is the simplest example::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:63
msgid ""
"If the driver needs to perform more complex initialization like getting and "
"configuring GPIOs it can get its ACPI handle and extract this information "
"from ACPI tables."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:68
msgid "ACPI device objects"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:70
msgid ""
"Generally speaking, there are two categories of devices in a system in which "
"ACPI is used as an interface between the platform firmware and the OS: "
"Devices that can be discovered and enumerated natively, through a protocol "
"defined for the specific bus that they are on (for example, configuration "
"space in PCI), without the platform firmware assistance, and devices that "
"need to be described by the platform firmware so that they can be "
"discovered.  Still, for any device known to the platform firmware, "
"regardless of which category it falls into, there can be a corresponding "
"ACPI device object in the ACPI Namespace in which case the Linux kernel will "
"create a struct acpi_device object based on it for that device."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:81
msgid ""
"Those struct acpi_device objects are never used for binding drivers to "
"natively discoverable devices, because they are represented by other types "
"of device objects (for example, struct pci_dev for PCI devices) that are "
"bound to by device drivers (the corresponding struct acpi_device object is "
"then used as an additional source of information on the configuration of the "
"given device). Moreover, the core ACPI device enumeration code creates "
"struct platform_device objects for the majority of devices that are "
"discovered and enumerated with the help of the platform firmware and those "
"platform device objects can be bound to by platform drivers in direct "
"analogy with the natively enumerable devices case.  Therefore it is "
"logically inconsistent and so generally invalid to bind drivers to struct "
"acpi_device objects, including drivers for devices that are discovered with "
"the help of the platform firmware."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:94
msgid ""
"Historically, ACPI drivers that bound directly to struct acpi_device objects "
"were implemented for some devices enumerated with the help of the platform "
"firmware, but this is not recommended for any new drivers.  As explained "
"above, platform device objects are created for those devices as a rule (with "
"a few exceptions that are not relevant here) and so platform drivers should "
"be used for handling them, even though the corresponding ACPI device objects "
"are the only source of device configuration information in that case."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:102
msgid ""
"For every device having a corresponding struct acpi_device object, the "
"pointer to it is returned by the ACPI_COMPANION() macro, so it is always "
"possible to get to the device configuration information stored in the ACPI "
"device object this way.  Accordingly, struct acpi_device can be regarded as "
"a part of the interface between the kernel and the ACPI Namespace, whereas "
"device objects of other types (for example, struct pci_dev or struct "
"platform_device) are used for interacting with the rest of the system."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:111
msgid "DMA support"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:113
msgid ""
"DMA controllers enumerated via ACPI should be registered in the system to "
"provide generic access to their resources. For example, a driver that would "
"like to be accessible to slave devices via generic API call "
"dma_request_chan() must register itself at the end of the probe function "
"like this::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:122
msgid ""
"and implement custom xlate function if needed (usually "
"acpi_dma_simple_xlate() is enough) which converts the FixedDMA resource "
"provided by struct acpi_dma_spec into the corresponding DMA channel. A piece "
"of code for that case could look like::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:157
msgid ""
"dma_request_chan() will call xlate_func() for each registered DMA "
"controller. In the xlate function the proper channel must be chosen based on "
"information in struct acpi_dma_spec and the properties of the controller "
"provided by struct acpi_dma."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:162
msgid ""
"Clients must call dma_request_chan() with the string parameter that "
"corresponds to a specific FixedDMA resource. By default \"tx\" means the "
"first entry of the FixedDMA resource array, \"rx\" means the second entry. "
"The table below shows a layout::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:181
msgid ""
"So, the FixedDMA with request line 0x0018 is \"tx\" and next one is \"rx\" "
"in this example."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:184
msgid ""
"In robust cases the client unfortunately needs to call "
"acpi_dma_request_slave_chan_by_index() directly and therefore choose the "
"specific FixedDMA resource by its index."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:189
msgid "Named Interrupts"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:191
msgid ""
"Drivers enumerated via ACPI can have names to interrupts in the ACPI table "
"which can be used to get the IRQ number in the driver."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:194
msgid ""
"The interrupt name can be listed in _DSD as 'interrupt-names'. The names "
"should be listed as an array of strings which will map to the Interrupt() "
"resource in the ACPI table corresponding to its index."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:198
msgid "The table below shows an example of its usage::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:219
msgid ""
"The interrupt name 'default' will correspond to 0x20 in Interrupt() resource "
"and 'alert' to 0x24. Note that only the Interrupt() resource is mapped and "
"not GpioInt() or similar."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:223
msgid ""
"The driver can call the function - fwnode_irq_get_byname() with the fwnode "
"and interrupt name as arguments to get the corresponding IRQ number."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:227
msgid "SPI serial bus support"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:229
msgid ""
"Slave devices behind SPI bus have SpiSerialBus resource attached to them. "
"This is extracted automatically by the SPI core and the slave devices are "
"enumerated once spi_register_master() is called by the bus driver."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:233
msgid "Here is what the ACPI namespace for a SPI slave might look like::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:251
msgid ""
"The SPI device drivers only need to add ACPI IDs in a similar way to the "
"platform device drivers. Below is an example where we add ACPI support to "
"at25 SPI eeprom driver (this is meant for the above ACPI snippet)::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:268
msgid ""
"Note that this driver actually needs more information like page size of the "
"eeprom, etc. This information can be passed via _DSD method like::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:286
msgid ""
"Then the at25 SPI driver can get this configuration by calling device "
"property APIs during ->probe() phase like::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:302
msgid "I2C serial bus support"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:304
msgid ""
"The slaves behind I2C bus controller only need to add the ACPI IDs like with "
"the platform and SPI drivers. The I2C core automatically enumerates any "
"slave devices behind the controller device once the adapter is registered."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:309
msgid ""
"Below is an example of how to add ACPI support to the existing mpu3050 input "
"driver::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:332
msgid "Reference to PWM device"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:334
msgid ""
"Sometimes a device can be a consumer of PWM channel. Obviously OS would like "
"to know which one. To provide this mapping the special property has been "
"introduced, i.e.::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:359
msgid ""
"In the above example the PWM-based LED driver references to the PWM channel "
"0 of \\_SB.PCI0.PWM device with initial period setting equal to 600 ms (note "
"that value is given in nanoseconds)."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:364
msgid "GPIO support"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:366
msgid ""
"ACPI 5 introduced two new resources to describe GPIO connections: GpioIo and "
"GpioInt. These resources can be used to pass GPIO numbers used by the device "
"to the driver. ACPI 5.1 extended this with _DSD (Device Specific Data) which "
"made it possible to name the GPIOs among other things."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:371
#: ../../../firmware-guide/acpi/enumeration.rst:441
msgid "For example::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:404
msgid ""
"These GPIO numbers are controller relative and path \"\\\\_SB.PCI0.GPI0\" "
"specifies the path to the controller. In order to use these GPIOs in Linux "
"we need to translate them to the corresponding Linux GPIO descriptors."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:408
msgid ""
"There is a standard GPIO API for that and it is documented in Documentation/"
"admin-guide/gpio/."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:411
msgid ""
"In the above example we can get the corresponding two GPIO descriptors with "
"a code like this::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:429
msgid ""
"There are also devm_* versions of these functions which release the "
"descriptors once the device is released."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:432
msgid ""
"See Documentation/firmware-guide/acpi/gpio-properties.rst for more "
"information about the _DSD binding related to GPIOs."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:436
msgid "RS-485 support"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:438
msgid ""
"ACPI _DSD (Device Specific Data) can be used to describe RS-485 capability "
"of UART."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:461
msgid "MFD devices"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:463
msgid ""
"The MFD devices register their children as platform devices. For the child "
"devices there needs to be an ACPI handle that they can use to reference "
"parts of the ACPI namespace that relate to them. In the Linux MFD subsystem "
"we provide two ways:"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:468
msgid "The children share the parent ACPI handle."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:469
msgid "The MFD cell can specify the ACPI id of the device."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:471
msgid ""
"For the first case, the MFD drivers do not need to do anything. The "
"resulting child platform device will have its ACPI_COMPANION() set to point "
"to the parent device."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:475
msgid ""
"If the ACPI namespace has a device that we can match using an ACPI id or "
"ACPI adr, the cell should be set like::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:489
msgid ""
"The ACPI id \"XYZ0001\" is then used to lookup an ACPI device directly under "
"the MFD device and if found, that ACPI companion device is bound to the "
"resulting child platform device."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:494
msgid "Device Tree namespace link device ID"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:496
msgid ""
"The Device Tree protocol uses device identification based on the "
"\"compatible\" property whose value is a string or an array of strings "
"recognized as device identifiers by drivers and the driver core.  The set of "
"all those strings may be regarded as a device identification namespace "
"analogous to the ACPI/PNP device ID namespace.  Consequently, in principle "
"it should not be necessary to allocate a new (and arguably redundant) ACPI/"
"PNP device ID for a devices with an existing identification string in the "
"Device Tree (DT) namespace, especially if that ID is only needed to indicate "
"that a given device is compatible with another one, presumably having a "
"matching driver in the kernel already."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:506
msgid ""
"In ACPI, the device identification object called _CID (Compatible ID) is "
"used to list the IDs of devices the given one is compatible with, but those "
"IDs must belong to one of the namespaces prescribed by the ACPI "
"specification (see Section 6.1.2 of ACPI 6.0 for details) and the DT "
"namespace is not one of them. Moreover, the specification mandates that "
"either a _HID or an _ADR identification object be present for all ACPI "
"objects representing devices (Section 6.1 of ACPI 6.0).  For non-enumerable "
"bus types that object must be _HID and its value must be a device ID from "
"one of the namespaces prescribed by the specification too."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:515
msgid ""
"The special DT namespace link device ID, PRP0001, provides a means to use "
"the existing DT-compatible device identification in ACPI and to satisfy the "
"above requirements following from the ACPI specification at the same time.  "
"Namely, if PRP0001 is returned by _HID, the ACPI subsystem will look for the "
"\"compatible\" property in the device object's _DSD and will use the value "
"of that property to identify the corresponding device in analogy with the "
"original DT device identification algorithm.  If the \"compatible\" property "
"is not present or its value is not valid, the device will not be enumerated "
"by the ACPI subsystem.  Otherwise, it will be enumerated automatically as a "
"platform device (except when an I2C or SPI link from the device to its "
"parent is present, in which case the ACPI core will leave the device "
"enumeration to the parent's driver) and the identification strings from the "
"\"compatible\" property value will be used to find a driver for the device "
"along with the device IDs listed by _CID (if present)."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:530
msgid ""
"Analogously, if PRP0001 is present in the list of device IDs returned by "
"_CID, the identification strings listed by the \"compatible\" property value "
"(if present and valid) will be used to look for a driver matching the "
"device, but in that case their relative priority with respect to the other "
"device IDs listed by _HID and _CID depends on the position of PRP0001 in the "
"_CID return package. Specifically, the device IDs returned by _HID and "
"preceding PRP0001 in the _CID return package will be checked first.  Also in "
"that case the bus type the device will be enumerated to depends on the "
"device ID returned by _HID."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:539
msgid ""
"For example, the following ACPI sample might be used to enumerate an lm75-"
"type I2C temperature sensor and match it to the driver using the Device Tree "
"namespace link::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:565
msgid ""
"It is valid to define device objects with a _HID returning PRP0001 and "
"without the \"compatible\" property in the _DSD or a _CID as long as one of "
"their ancestors provides a _DSD with a valid \"compatible\" property.  Such "
"device objects are then simply regarded as additional \"blocks\" providing "
"hierarchical configuration information to the driver of the composite "
"ancestor device."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:571
msgid ""
"However, PRP0001 can only be returned from either _HID or _CID of a device "
"object if all of the properties returned by the _DSD associated with it "
"(either the _DSD of the device object itself or the _DSD of its ancestor in "
"the \"composite device\" case described above) can be used in the ACPI "
"environment. Otherwise, the _DSD itself is regarded as invalid and therefore "
"the \"compatible\" property returned by it is meaningless."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:578
msgid ""
"Refer to Documentation/firmware-guide/acpi/DSD-properties-rules.rst for more "
"information."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:582
msgid "PCI hierarchy representation"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:584
msgid ""
"Sometimes it could be useful to enumerate a PCI device, knowing its position "
"on the PCI bus."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:587
msgid ""
"For example, some systems use PCI devices soldered directly on the mother "
"board, in a fixed position (ethernet, Wi-Fi, serial ports, etc.). In this "
"conditions it is possible to refer to these PCI devices knowing their "
"position on the PCI bus topology."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:592
msgid ""
"To identify a PCI device, a complete hierarchical description is required, "
"from the chipset root port to the final device, through all the intermediate "
"bridges/switches of the board."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:596
msgid ""
"For example, let's assume we have a system with a PCIe serial port, an Exar "
"XR17V3521, soldered on the main board. This UART chip also includes 16 GPIOs "
"and we want to add the property ``gpio-line-names`` [1]_ to these pins. In "
"this case, the ``lspci`` output for this component is::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:603
msgid "The complete ``lspci`` output (manually reduced in length) is::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:620
msgid "The bus topology is::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:634
msgid ""
"To describe this Exar device on the PCI bus, we must start from the ACPI "
"name of the chipset bridge (also called \"root port\") with address::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:639
msgid ""
"To find this information, it is necessary to disassemble the BIOS ACPI "
"tables, in particular the DSDT (see also [2]_)::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:648
msgid ""
"Now, in the dsdt.dsl, we have to search the device whose address is related "
"to 0x14 (device) and 0x01 (function). In this case we can find the following "
"device::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:670
msgid ""
"and the _ADR method [3]_ returns exactly the device/function couple that we "
"are looking for. With this information and analyzing the above ``lspci`` "
"output (both the devices list and the devices tree), we can write the "
"following ACPI description for the Exar PCIe UART, also adding the list of "
"its GPIO line names::"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:720
msgid ""
"The location \"_SB.PCI0.RP02\" is obtained by the above investigation in the "
"dsdt.dsl table, whereas the device names \"BRG1\", \"BRG2\" and \"EXAR\" are "
"created analyzing the position of the Exar UART in the PCI bus topology."
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:725
msgid "References"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:727
msgid "Documentation/firmware-guide/acpi/gpio-properties.rst"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:729
msgid "Documentation/admin-guide/acpi/initrd_table_override.rst"
msgstr ""

#: ../../../firmware-guide/acpi/enumeration.rst:731
msgid ""
"ACPI Specifications, Version 6.3 - Paragraph 6.1.1 _ADR Address) https://"
"uefi.org/sites/default/files/resources/ACPI_6_3_May16.pdf, referenced "
"2020-11-18"
msgstr ""
