# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/boot-time-mm.rst:3
msgid "Boot time memory management"
msgstr ""

#: ../../../core-api/boot-time-mm.rst:5
msgid ""
"Early system initialization cannot use \"normal\" memory management simply "
"because it is not set up yet. But there is still need to allocate memory for "
"various data structures, for instance for the physical page allocator."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:10
msgid ""
"A specialized allocator called ``memblock`` performs the boot time memory "
"management. The architecture specific initialization must set it up in :c:"
"func:`setup_arch` and tear it down in :c:func:`mem_init` functions."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:15
msgid ""
"Once the early memory management is available it offers a variety of "
"functions and macros for memory allocations. The allocation request may be "
"directed to the first (and probably the only) node or to a particular node "
"in a NUMA system. There are API variants that panic when an allocation fails "
"and those that don't."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:21
msgid "Memblock also offers a variety of APIs that control its own behaviour."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:24
msgid "Memblock Overview"
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:43
msgid ""
"Memblock is a method of managing memory regions during the early boot period "
"when the usual kernel memory allocators are not up and running."
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:47
msgid ""
"Memblock views the system memory as collections of contiguous regions. There "
"are several types of these collections:"
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:50
msgid ""
"``memory`` - describes the physical memory available to the kernel; this may "
"differ from the actual physical memory installed in the system, for instance "
"when the memory is restricted with ``mem=`` command line parameter"
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:54
msgid "``reserved`` - describes the regions that were allocated"
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:55
msgid ""
"``physmem`` - describes the actual physical memory available during boot "
"regardless of the possible restrictions and memory hot(un)plug; the "
"``physmem`` type is only available on some architectures."
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:59
msgid ""
"Each region is represented by struct memblock_region that defines the region "
"extents, its attributes and NUMA node id on NUMA systems. Every memory type "
"is described by the struct memblock_type which contains an array of memory "
"regions along with the allocator metadata. The \"memory\" and \"reserved\" "
"types are nicely wrapped with struct memblock. This structure is statically "
"initialized at build time. The region arrays are initially sized to "
"``INIT_MEMBLOCK_MEMORY_REGIONS`` for \"memory\" and "
"``INIT_MEMBLOCK_RESERVED_REGIONS`` for \"reserved\". The region array for "
"\"physmem\" is initially sized to ``INIT_PHYSMEM_REGIONS``. The "
"memblock_allow_resize() enables automatic resizing of the region arrays "
"during addition of new regions. This feature should be used with care so "
"that memory allocated for the region array will not overlap with areas that "
"should be reserved, for example initrd."
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:74
msgid ""
"The early architecture setup should tell memblock what the physical memory "
"layout is by using memblock_add() or memblock_add_node() functions. The "
"first function does not assign the region to a NUMA node and it is "
"appropriate for UMA systems. Yet, it is possible to use it on NUMA systems "
"as well and assign the region to a NUMA node later in the setup process "
"using memblock_set_node(). The memblock_add_node() performs such an "
"assignment directly."
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:82
msgid ""
"Once memblock is setup the memory can be allocated using one of the API "
"variants:"
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:85
msgid ""
"memblock_phys_alloc*() - these functions return the **physical** address of "
"the allocated memory"
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:87
msgid ""
"memblock_alloc*() - these functions return the **virtual** address of the "
"allocated memory."
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:90
msgid ""
"Note, that both API variants use implicit assumptions about allowed memory "
"ranges and the fallback methods. Consult the documentation of "
"memblock_alloc_internal() and memblock_alloc_range_nid() functions for more "
"elaborate description."
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:95
msgid ""
"As the system boot progresses, the architecture specific mem_init() function "
"frees all the memory to the buddy page allocator."
msgstr ""

#: ../../../core-api/boot-time-mm:26: mm/memblock.c:98
msgid ""
"Unless an architecture enables ``CONFIG_ARCH_KEEP_MEMBLOCK``, the memblock "
"data structures (except \"physmem\") will be discarded after the system "
"initialization completes."
msgstr ""

#: ../../../core-api/boot-time-mm.rst:31
msgid "Functions and structures"
msgstr ""

#: ../../../core-api/boot-time-mm.rst:33
msgid ""
"Here is the description of memblock data structures, functions and macros. "
"Some of them are actually internal, but since they are documented it would "
"be silly to omit them. Besides, reading the descriptions for the internal "
"functions can help to understand what really happens under the hood."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:28
msgid "definition of memory region attributes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:32
msgid "**Constants**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:34
msgid "``MEMBLOCK_NONE``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:35
msgid "no special request"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:37
msgid "``MEMBLOCK_HOTPLUG``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:38
msgid ""
"memory region indicated in the firmware-provided memory map during early "
"boot as hot(un)pluggable system RAM (e.g., memory range that might get "
"hotunplugged later). With \"movable_node\" set on the kernel commandline, "
"try keeping this memory region hotunpluggable. Does not apply to memblocks "
"added (\"hotplugged\") after early boot."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:44
msgid "``MEMBLOCK_MIRROR``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:45
msgid "mirrored region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:47
msgid "``MEMBLOCK_NOMAP``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:48
msgid ""
"don't add to kernel direct mapping and treat as reserved in the memory map; "
"refer to memblock_mark_nomap() description for further details"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:52
msgid "``MEMBLOCK_DRIVER_MANAGED``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:53
msgid ""
"memory region that is always detected and added via a driver, and never "
"indicated in the firmware-provided memory map as system RAM. This "
"corresponds to IORESOURCE_SYSRAM_DRIVER_MANAGED in the kernel resource tree."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:58
msgid "``MEMBLOCK_RSRV_NOINIT``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:59
msgid ""
"reserved memory region for which struct pages are not fully initialized. "
"Users of this flag are responsible to properly initialize struct pages of "
"this region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:63
msgid "``MEMBLOCK_RSRV_KERN``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:64
msgid ""
"memory region that is reserved for kernel use, either explictitly with "
"memblock_reserve_kern() or via memblock allocation APIs. All memblock "
"allocations set this flag."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:68
msgid "``MEMBLOCK_KHO_SCRATCH``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:69
msgid ""
"memory region that kexec can pass to the next kernel in handover mode. "
"During early boot, we do not know about all memory reservations yet, so we "
"get scratch memory from the previous kernel that we know is good to use. It "
"is the only memory that allocations may happen from in this phase."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:67
msgid "represents a memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:71
#: include/linux/memblock.h:87 include/linux/memblock.h:103
msgid "**Definition**::"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:82
#: include/linux/memblock.h:97 include/linux/memblock.h:112
msgid "**Members**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:68
msgid "``base``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:69
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:988
msgid "base address of the region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:69
msgid "``size``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:70
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:989
msgid "size of the region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:70
#: include/linux/memblock.h:209 include/linux/memblock.h:229
#: include/linux/memblock.h:355 include/linux/memblock.h:371
msgid "``flags``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:71
msgid "memory region attributes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:71
#: include/linux/memblock.h:208 include/linux/memblock.h:228
#: include/linux/memblock.h:317 include/linux/memblock.h:354
#: include/linux/memblock.h:370
msgid "``nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:72
msgid "NUMA node id"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:83
msgid "collection of memory regions of certain type"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:84
msgid "``cnt``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:85
msgid "number of regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:85
msgid "``max``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:86
msgid "size of the allocated array"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:86
msgid "``total_size``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:87
msgid "size of all regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:87
msgid "``regions``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:88
msgid "array of regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:88
msgid "``name``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:89
msgid "the memory type symbolic name"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:99
msgid "memblock allocator metadata"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:100
msgid "``bottom_up``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:101
msgid "is bottom up direction?"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:101
msgid "``current_limit``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:102
msgid "physical address of the current allocation limit"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:102
msgid "``memory``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:103
msgid "usable memory regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:103
msgid "``reserved``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:104
msgid "reserved memory regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:191
msgid "``for_each_physmem_range (i, type, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:189
msgid "iterate through physmem areas not included in type."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:193
#: include/linux/memblock.h:206 include/linux/memblock.h:226
#: include/linux/memblock.h:247 include/linux/memblock.h:258
#: include/linux/memblock.h:270 include/linux/memblock.h:318
#: include/linux/memblock.h:337 include/linux/memblock.h:355
#: include/linux/memblock.h:371 include/linux/memblock.h:529
#: include/linux/memblock.h:548 include/linux/memblock.h:559
#: include/linux/memblock.h:570 include/linux/memblock.h:581
#: include/linux/memblock.h:592 include/linux/memblock.h:601
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:223 mm/memblock.c:258
#: mm/memblock.c:297 mm/memblock.c:334 mm/memblock.c:386 mm/memblock.c:417
#: mm/memblock.c:531 mm/memblock.c:567 mm/memblock.c:597 mm/memblock.c:719
#: mm/memblock.c:743 mm/memblock.c:764 mm/memblock.c:798 mm/memblock.c:900
#: mm/memblock.c:914 mm/memblock.c:990 mm/memblock.c:1024 mm/memblock.c:1036
#: mm/memblock.c:1048 mm/memblock.c:1065 mm/memblock.c:1085 mm/memblock.c:1097
#: mm/memblock.c:1122 mm/memblock.c:1138 mm/memblock.c:1193 mm/memblock.c:1293
#: mm/memblock.c:1421 mm/memblock.c:1454 mm/memblock.c:1517 mm/memblock.c:1616
#: mm/memblock.c:1640 mm/memblock.c:1659 mm/memblock.c:1704 mm/memblock.c:1735
#: mm/memblock.c:1767 mm/memblock.c:1802 mm/memblock.c:1822 mm/memblock.c:1884
#: mm/memblock.c:2056 mm/memblock.c:2077 mm/memblock.c:2404 mm/memblock.c:2458
#: mm/memblock.c:2483
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:195
#: include/linux/memblock.h:208 include/linux/memblock.h:228
#: include/linux/memblock.h:249 include/linux/memblock.h:260
#: include/linux/memblock.h:272 include/linux/memblock.h:320
#: include/linux/memblock.h:339 include/linux/memblock.h:357
#: include/linux/memblock.h:373
msgid "``i``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:190
#: include/linux/memblock.h:204 include/linux/memblock.h:224
#: include/linux/memblock.h:244 include/linux/memblock.h:256
#: include/linux/memblock.h:267 include/linux/memblock.h:335
#: include/linux/memblock.h:352 include/linux/memblock.h:368
msgid "u64 used as loop variable"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:192
msgid "``type``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:191
msgid "ptr to memblock_type which excludes from the iteration, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:193
#: include/linux/memblock.h:210 include/linux/memblock.h:230
#: include/linux/memblock.h:246 include/linux/memblock.h:258
#: include/linux/memblock.h:269 include/linux/memblock.h:318
#: include/linux/memblock.h:338 include/linux/memblock.h:356
#: include/linux/memblock.h:372
msgid "``p_start``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:192
#: include/linux/memblock.h:209 include/linux/memblock.h:229
#: include/linux/memblock.h:245 include/linux/memblock.h:257
#: include/linux/memblock.h:268 include/linux/memblock.h:337
#: include/linux/memblock.h:355 include/linux/memblock.h:371
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1195 mm/memblock.c:1296
msgid "ptr to phys_addr_t for start address of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:194
#: include/linux/memblock.h:211 include/linux/memblock.h:231
#: include/linux/memblock.h:247 include/linux/memblock.h:259
#: include/linux/memblock.h:270 include/linux/memblock.h:319
#: include/linux/memblock.h:339 include/linux/memblock.h:357
#: include/linux/memblock.h:373
msgid "``p_end``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:193
#: include/linux/memblock.h:210 include/linux/memblock.h:230
#: include/linux/memblock.h:246 include/linux/memblock.h:258
#: include/linux/memblock.h:269 include/linux/memblock.h:338
#: include/linux/memblock.h:356 include/linux/memblock.h:372
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1196 mm/memblock.c:1297
msgid "ptr to phys_addr_t for end address of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:204
msgid ""
"``__for_each_mem_range (i, type_a, type_b, nid, flags, p_start, p_end, "
"p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:202
msgid ""
"iterate through memblock areas from type_a and not included in type_b. Or "
"just type_a if type_b is NULL."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:206
#: include/linux/memblock.h:226
msgid "``type_a``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:205
#: include/linux/memblock.h:225
msgid "ptr to memblock_type to iterate"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:207
#: include/linux/memblock.h:227
msgid "``type_b``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:206
#: include/linux/memblock.h:226
msgid "ptr to memblock_type which excludes from the iteration"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:207
#: include/linux/memblock.h:227 include/linux/memblock.h:353
#: include/linux/memblock.h:369 ../../../core-api/boot-time-mm:40:
#: mm/memblock.c:1191 mm/memblock.c:1292
msgid "node selector, ``NUMA_NO_NODE`` for all nodes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:208
#: include/linux/memblock.h:228 include/linux/memblock.h:354
#: include/linux/memblock.h:370 ../../../core-api/boot-time-mm:40:
#: mm/memblock.c:226 mm/memblock.c:261 mm/memblock.c:300 mm/memblock.c:1192
#: mm/memblock.c:1293
msgid "pick from blocks based on memory attributes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:212
#: include/linux/memblock.h:232 include/linux/memblock.h:320
#: include/linux/memblock.h:358 include/linux/memblock.h:374
msgid "``p_nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:211
#: include/linux/memblock.h:231 include/linux/memblock.h:319
#: include/linux/memblock.h:357 include/linux/memblock.h:373
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1197 mm/memblock.c:1298
msgid "ptr to int for nid of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:224
msgid ""
"``__for_each_mem_range_rev (i, type_a, type_b, nid, flags, p_start, p_end, "
"p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:222
#: include/linux/memblock.h:254
msgid ""
"reverse iterate through memblock areas from type_a and not included in "
"type_b. Or just type_a if type_b is NULL."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:245
msgid "``for_each_mem_range (i, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:243
msgid "iterate through memory areas."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:256
msgid "``for_each_mem_range_rev (i, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:268
msgid "``for_each_reserved_mem_range (i, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:266
msgid "iterate over all reserved memblock areas"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:271
#: include/linux/memblock.h:321 include/linux/memblock.h:340
#: include/linux/memblock.h:359 include/linux/memblock.h:375
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:3 mm/memblock.c:228
#: mm/memblock.c:263 mm/memblock.c:302 mm/memblock.c:337 mm/memblock.c:418
#: mm/memblock.c:571 mm/memblock.c:600 mm/memblock.c:721 mm/memblock.c:743
#: mm/memblock.c:765 mm/memblock.c:801 mm/memblock.c:900 mm/memblock.c:914
#: mm/memblock.c:993 mm/memblock.c:1065 mm/memblock.c:1099 mm/memblock.c:1122
#: mm/memblock.c:1199 mm/memblock.c:1300 mm/memblock.c:1423 mm/memblock.c:1457
#: mm/memblock.c:1521 mm/memblock.c:1618 mm/memblock.c:1641 mm/memblock.c:1663
#: mm/memblock.c:1711 mm/memblock.c:1742 mm/memblock.c:1773 mm/memblock.c:1803
#: mm/memblock.c:1822 mm/memblock.c:2056 mm/memblock.c:2077 mm/memblock.c:2459
#: mm/memblock.c:2482
msgid "**Description**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:270
msgid ""
"Walks over reserved areas of memblock. Available as soon as memblock is "
"initialized."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:316
msgid "``for_each_mem_pfn_range (i, nid, p_start, p_end, p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:314
msgid "early memory pfn range iterator"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:315
msgid "an integer used as loop variable"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:316
msgid "node selector, ``MAX_NUMNODES`` for all nodes"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:317
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1454
msgid "ptr to ulong for start pfn of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:318
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1455
msgid "ptr to ulong for end pfn of the range, can be ``NULL``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:320
msgid "Walks over configured memory ranges."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:335
msgid "``for_each_free_mem_pfn_range_in_zone_from (i, zone, p_start, p_end)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:333
msgid "iterate through zone specific free memblock areas from a given point"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:337
msgid "``zone``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:336
#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1453
msgid "zone in which all of the memory blocks reside"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:339
msgid ""
"Walks over free (memory && !reserved) areas of memblock in a specific zone, "
"continuing from current position. Available as soon as memblock is "
"initialized."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:353
msgid "``for_each_free_mem_range (i, nid, flags, p_start, p_end, p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:351
msgid "iterate through free memblock areas"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:358
msgid ""
"Walks over free (memory && !reserved) areas of memblock.  Available as soon "
"as memblock is initialized."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:369
msgid ""
"``for_each_free_mem_range_reverse (i, nid, flags, p_start, p_end, p_nid)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:367
msgid "rev-iterate through free memblock areas"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:374
msgid ""
"Walks over free (memory && !reserved) areas of memblock in reverse order.  "
"Available as soon as memblock is initialized."
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:525
msgid ""
"Set the current allocation limit to allow limiting allocations to what is "
"currently accessible during boot"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:531
msgid "``phys_addr_t limit``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:528
msgid "New limit value (physical address)"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:544
msgid "get the lowest pfn of the memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:550
#: include/linux/memblock.h:561 include/linux/memblock.h:572
#: include/linux/memblock.h:583
msgid "``const struct memblock_region *reg``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:545
#: include/linux/memblock.h:556 include/linux/memblock.h:567
#: include/linux/memblock.h:578
msgid "memblock_region structure"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:547
#: include/linux/memblock.h:558 include/linux/memblock.h:569
#: include/linux/memblock.h:580 ../../../core-api/boot-time-mm:40:
#: mm/memblock.c:229 mm/memblock.c:264 mm/memblock.c:303 mm/memblock.c:338
#: mm/memblock.c:423 mm/memblock.c:604 mm/memblock.c:723 mm/memblock.c:745
#: mm/memblock.c:767 mm/memblock.c:806 mm/memblock.c:994 mm/memblock.c:1024
#: mm/memblock.c:1036 mm/memblock.c:1048 mm/memblock.c:1073 mm/memblock.c:1085
#: mm/memblock.c:1108 mm/memblock.c:1124 mm/memblock.c:1139 mm/memblock.c:1425
#: mm/memblock.c:1533 mm/memblock.c:1619 mm/memblock.c:1644 mm/memblock.c:1670
#: mm/memblock.c:1713 mm/memblock.c:1745 mm/memblock.c:1775 mm/memblock.c:1886
#: mm/memblock.c:2057 mm/memblock.c:2079 mm/memblock.c:2460 mm/memblock.c:2484
msgid "**Return**"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:547
msgid "the lowest pfn intersecting with the memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:555
msgid "get the end pfn of the memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:558
#: include/linux/memblock.h:580
msgid "the end_pfn of the reserved region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:566
msgid "get the lowest pfn of the reserved region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:569
msgid "the lowest pfn intersecting with the reserved region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:577
msgid "get the end pfn of the reserved region"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:590
msgid "``for_each_mem_region (region)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:588
msgid "iterate over memory regions"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:594
#: include/linux/memblock.h:603
msgid "``region``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:589
#: include/linux/memblock.h:598
msgid "loop variable"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:599
msgid "``for_each_reserved_mem_region (region)``"
msgstr ""

#: ../../../core-api/boot-time-mm:39: include/linux/memblock.h:597
msgid "itereate over reserved memory regions"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:219
msgid "find free area utility in bottom-up"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:225 mm/memblock.c:260
#: mm/memblock.c:297 mm/memblock.c:336 mm/memblock.c:1517 mm/memblock.c:1616
msgid "``phys_addr_t start``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:220 mm/memblock.c:255
#: mm/memblock.c:296 mm/memblock.c:331
msgid "start of candidate range"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:222 mm/memblock.c:257
#: mm/memblock.c:298 mm/memblock.c:333 mm/memblock.c:1518 mm/memblock.c:1617
msgid "``phys_addr_t end``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:221 mm/memblock.c:256
#: mm/memblock.c:297 mm/memblock.c:332
msgid ""
"end of candidate range, can be ``MEMBLOCK_ALLOC_ANYWHERE`` or "
"``MEMBLOCK_ALLOC_ACCESSIBLE``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:224 mm/memblock.c:259
#: mm/memblock.c:299 mm/memblock.c:335 mm/memblock.c:568 mm/memblock.c:597
#: mm/memblock.c:718 mm/memblock.c:742 mm/memblock.c:798 mm/memblock.c:913
#: mm/memblock.c:990 mm/memblock.c:1023 mm/memblock.c:1035 mm/memblock.c:1047
#: mm/memblock.c:1064 mm/memblock.c:1084 mm/memblock.c:1098 mm/memblock.c:1121
#: mm/memblock.c:1138 mm/memblock.c:1420 mm/memblock.c:1519 mm/memblock.c:1618
#: mm/memblock.c:1642 mm/memblock.c:1661 mm/memblock.c:1706 mm/memblock.c:1737
#: mm/memblock.c:1769 mm/memblock.c:1804 mm/memblock.c:1821 mm/memblock.c:2055
#: mm/memblock.c:2076
msgid "``phys_addr_t size``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:223 mm/memblock.c:258
#: mm/memblock.c:294 mm/memblock.c:334
msgid "size of free area to find"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:225 mm/memblock.c:260
#: mm/memblock.c:296 mm/memblock.c:336 mm/memblock.c:1516 mm/memblock.c:1615
#: mm/memblock.c:1639 mm/memblock.c:1658 mm/memblock.c:1704 mm/memblock.c:1735
#: mm/memblock.c:1766 mm/memblock.c:1801
msgid "``phys_addr_t align``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:224 mm/memblock.c:259
#: mm/memblock.c:295 mm/memblock.c:335
msgid "alignment of free area to find"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:226 mm/memblock.c:261
#: mm/memblock.c:300 mm/memblock.c:569 mm/memblock.c:598 mm/memblock.c:719
#: mm/memblock.c:1192 mm/memblock.c:1293 mm/memblock.c:1422 mm/memblock.c:1519
#: mm/memblock.c:1640 mm/memblock.c:1661 mm/memblock.c:1710 mm/memblock.c:1741
#: mm/memblock.c:1772
msgid "``int nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:225 mm/memblock.c:260
#: mm/memblock.c:299 mm/memblock.c:1518 mm/memblock.c:1639 mm/memblock.c:1660
#: mm/memblock.c:1709 mm/memblock.c:1740 mm/memblock.c:1771
msgid "nid of the free area to find, ``NUMA_NO_NODE`` for any node"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:227 mm/memblock.c:262
#: mm/memblock.c:301 mm/memblock.c:570 mm/memblock.c:599 mm/memblock.c:720
#: mm/memblock.c:1193 mm/memblock.c:1294
msgid "``enum memblock_flags flags``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:227
msgid ""
"Utility called from memblock_find_in_range_node(), find free area bottom-up."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:230 mm/memblock.c:265
#: mm/memblock.c:304 mm/memblock.c:339
msgid "Found address on success, 0 on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:254
msgid "find free area utility, in top-down"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:262
msgid ""
"Utility called from memblock_find_in_range_node(), find free area top-down."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:293
msgid "find free area in given range and node"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:301
msgid ""
"Find **size** free area aligned to **align** in the specified range and node."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:330
msgid "find free area in given range"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:336
msgid "Find **size** free area aligned to **align** in the specified range."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:382
msgid "discard memory and reserved arrays if they were allocated"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:388 mm/memblock.c:1886
#: mm/memblock.c:2406
msgid "``void``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1
msgid "no arguments"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:413
msgid "double the size of the memblock regions array"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:419 mm/memblock.c:533
#: mm/memblock.c:569 mm/memblock.c:599 mm/memblock.c:800 mm/memblock.c:992
#: mm/memblock.c:1421
msgid "``struct memblock_type *type``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:414
msgid "memblock type of the regions array being doubled"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:416
msgid "``phys_addr_t new_area_start``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:415
msgid "starting address of memory range to avoid overlap with"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:417
msgid "``phys_addr_t new_area_size``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:416
msgid "size of memory range to avoid overlap with"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:417
msgid ""
"Double the size of the **type** regions array. If memblock is being used to "
"allocate memory for a new reserved regions array and there is a previously "
"allocated memory range [**new_area_start**, **new_area_start** + "
"**new_area_size**] waiting to be reserved, ensure the memory used by the new "
"array does not overlap."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:424
msgid "0 on success, -1 on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:527
msgid "merge neighboring compatible regions"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:528
msgid "memblock type to scan"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:530
msgid "``unsigned long start_rgn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:529
msgid "start scanning from (**start_rgn** - 1)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:531
msgid "``unsigned long end_rgn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:530
msgid ""
"end scanning at (**end_rgn** - 1) Scan **type** and merge neighboring "
"compatible regions in [**start_rgn** - 1, **end_rgn**)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:563
msgid "insert new memblock region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:564
msgid "memblock type to insert into"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:566
msgid "``int idx``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:565
msgid "index for the insertion point"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:567 mm/memblock.c:596
#: mm/memblock.c:721 mm/memblock.c:745 mm/memblock.c:797 mm/memblock.c:916
#: mm/memblock.c:989 mm/memblock.c:1026 mm/memblock.c:1038 mm/memblock.c:1050
#: mm/memblock.c:1067 mm/memblock.c:1087 mm/memblock.c:1099 mm/memblock.c:1124
#: mm/memblock.c:1140 mm/memblock.c:1423 mm/memblock.c:1824 mm/memblock.c:2058
#: mm/memblock.c:2079
msgid "``phys_addr_t base``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:566 mm/memblock.c:595
#: mm/memblock.c:716 mm/memblock.c:740
msgid "base address of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:567 mm/memblock.c:596
#: mm/memblock.c:717 mm/memblock.c:741
msgid "size of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:568
msgid "node id of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:569 mm/memblock.c:598
#: mm/memblock.c:719
msgid "flags of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:570
msgid ""
"Insert new memblock region [**base**, **base** + **size**) into **type** at "
"**idx**. **type** must already have extra room to accommodate the new region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:593 mm/memblock.c:739
msgid "add new memblock region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:594
msgid "memblock type to add new region into"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:597 mm/memblock.c:718
msgid "nid of the new region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:599
msgid ""
"Add new memblock region [**base**, **base** + **size**) into **type**.  The "
"new region is allowed to overlap with existing ones - overlaps don't affect "
"already existing regions.  **type** is guaranteed to be minimal (all "
"neighbouring compatible regions are merged) after the addition."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:605 mm/memblock.c:724
#: mm/memblock.c:746 mm/memblock.c:807 mm/memblock.c:995 mm/memblock.c:1024
#: mm/memblock.c:1036 mm/memblock.c:1048 mm/memblock.c:1073 mm/memblock.c:1085
#: mm/memblock.c:1109 mm/memblock.c:1125 mm/memblock.c:1139 mm/memblock.c:1426
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:715
msgid "add new memblock region within a NUMA node"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:720 mm/memblock.c:742
msgid ""
"Add new memblock region [**base**, **base** + **size**) to the \"memory\" "
"type. See memblock_add_range() description for mode details"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:760
msgid ""
"check if amount of memory with no node ID assigned is less than a threshold"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:766
msgid "``unsigned long threshold_bytes``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:762
msgid "maximal memory size that can have unassigned node ID (in bytes)."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:764
msgid ""
"A buggy firmware may report memory that does not belong to any node. Check "
"if amount of such memory is below **threshold_bytes**."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:768
msgid "true on success, false on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:794
msgid "isolate given range into disjoint memblocks"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:795
msgid "memblock type to isolate range for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:796
msgid "base of range to isolate"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:797
msgid "size of range to isolate"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:799
msgid "``int *start_rgn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:798
msgid "out parameter for the start of isolated region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:800
msgid "``int *end_rgn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:799
msgid "out parameter for the end of isolated region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:800
msgid ""
"Walk **type** and ensure that regions don't cross the boundaries defined by "
"[**base**, **base** + **size**).  Crossing regions are split at the "
"boundaries, which may create at most two more regions.  The index of the "
"first region inside the range is returned in ***start_rgn** and the index of "
"the first region after the range is returned in ***end_rgn**."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:896
msgid "free boot memory allocation"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:902
msgid "``void *ptr``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:897
msgid "starting address of the  boot memory allocation"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:899
msgid "``size_t size``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:898 mm/memblock.c:912
#: mm/memblock.c:1820
msgid "size of the boot memory block in bytes"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:899
msgid ""
"Free boot memory block previously allocated by memblock_alloc_xx() API. The "
"freeing memory will not be released to the buddy allocator."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:910
msgid "free boot memory block"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:911 mm/memblock.c:1819
msgid "phys starting address of the  boot memory block"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:913
msgid ""
"Free boot memory block previously allocated by memblock_phys_alloc_xx() API. "
"The freeing memory will not be released to the buddy allocator."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:986
msgid "set or clear flag for a memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:987
msgid "memblock type to set/clear flag for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:991
msgid "``int set``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:990
msgid "set or clear the flag"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:992
msgid "``int flag``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:991
msgid "the flag to update"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:992
msgid ""
"This function isolates region [**base**, **base** + **size**), and sets/"
"clears flag"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1020
msgid "Mark hotpluggable memory with flag MEMBLOCK_HOTPLUG."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1021 mm/memblock.c:1033
#: mm/memblock.c:1045 mm/memblock.c:1062 mm/memblock.c:1082 mm/memblock.c:1096
#: mm/memblock.c:1119 mm/memblock.c:1136
msgid "the base phys addr of the region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1022 mm/memblock.c:1034
#: mm/memblock.c:1046 mm/memblock.c:1063 mm/memblock.c:1083 mm/memblock.c:1097
#: mm/memblock.c:1120 mm/memblock.c:1137
msgid "the size of the region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1032
msgid "Clear flag MEMBLOCK_HOTPLUG for a specified region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1044
msgid "Mark mirrored memory with flag MEMBLOCK_MIRROR."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1061
msgid "Mark a memory region with flag MEMBLOCK_NOMAP."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1064
msgid ""
"The memory regions marked with ``MEMBLOCK_NOMAP`` will not be added to the "
"direct mapping of the physical memory. These regions will still be covered "
"by the memory map. The struct page representing NOMAP memory frames in the "
"memory map will be PageReserved()"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1069
msgid "**Note**"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1070
msgid ""
"if the memory being marked ``MEMBLOCK_NOMAP`` was allocated from memblock, "
"the caller must inform kmemleak to ignore that memory"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1081
msgid "Clear flag MEMBLOCK_NOMAP for a specified region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1093
msgid "Mark a reserved memory region with flag MEMBLOCK_RSRV_NOINIT"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1098
msgid ""
"The struct pages for the reserved regions marked ``MEMBLOCK_RSRV_NOINIT`` "
"will not be fully initialized to allow the caller optimize their "
"initialization."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1101
msgid ""
"When ``CONFIG_DEFERRED_STRUCT_PAGE_INIT`` is enabled, setting this flag "
"completely bypasses the initialization of struct pages for such region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1104
msgid ""
"When ``CONFIG_DEFERRED_STRUCT_PAGE_INIT`` is disabled, struct pages in this "
"region will be initialized with default values but won't be marked as "
"reserved."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1118
msgid "Mark a memory region as MEMBLOCK_KHO_SCRATCH."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1121
msgid ""
"Only memory regions marked with ``MEMBLOCK_KHO_SCRATCH`` will be considered "
"for allocations during early boot with kexec handover."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1134
msgid "Clear MEMBLOCK_KHO_SCRATCH flag for a specified region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1189
msgid "next function for for_each_free_mem_range() etc."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1195 mm/memblock.c:1295
#: mm/memblock.c:1456
msgid "``u64 *idx``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1190 mm/memblock.c:1291
#: mm/memblock.c:1452
msgid "pointer to u64 loop variable"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1194 mm/memblock.c:1295
msgid "``struct memblock_type *type_a``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1193 mm/memblock.c:1294
msgid "pointer to memblock_type from where the range is taken"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1195 mm/memblock.c:1296
msgid "``struct memblock_type *type_b``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1194 mm/memblock.c:1295
msgid "pointer to memblock_type which excludes memory from being taken"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1196 mm/memblock.c:1297
msgid "``phys_addr_t *out_start``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1197 mm/memblock.c:1298
msgid "``phys_addr_t *out_end``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1198 mm/memblock.c:1299
msgid "``int *out_nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1198
msgid ""
"Find the first area from ***idx** which matches **nid**, fill the out "
"parameters, and update ***idx** for the next iteration.  The lower 32bit of "
"***idx** contains index into type_a and the upper 32bit indexes the areas "
"before each region in type_b.  For example, if type_b regions look like the "
"following,"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1204
msgid "0:[0-16), 1:[32-48), 2:[128-130)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1206
msgid "The upper 32bit indexes the following regions."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1208
msgid "0:[0-0), 1:[16-32), 2:[48-128), 3:[130-MAX)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1210
msgid ""
"As both region arrays are sorted, the function advances the two indices in "
"lockstep and returns each intersection."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1289
msgid "generic next function for for_each_*_range_rev()"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1299
msgid ""
"Finds the next range from type_a which is not marked as unsuitable in type_b."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1302
msgid "Reverse of __next_mem_range()."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1417
msgid "set node ID on memblock regions"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1418
msgid "base of area to set node ID for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1419
msgid "size of area to set node ID for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1420
msgid "memblock type to set node ID for"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1421
msgid "node ID to set"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1422
msgid ""
"Set the nid of memblock **type** regions in [**base**, **base** + **size**) "
"to **nid**. Regions which cross the area boundaries are split as necessary."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1450
msgid "iterator for for_each_*_range_in_zone()"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1454
msgid "``struct zone *zone``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1455
msgid "``unsigned long *out_spfn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1456
msgid "``unsigned long *out_epfn``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1456
msgid ""
"This function is meant to be a zone/pfn specific wrapper for the "
"for_each_mem_range type iterators. Specifically they are used in the "
"deferred memory init routines and as such we were duplicating much of this "
"logic throughout the code. So instead of having it in multiple locations it "
"seemed like it would make more sense to centralize this to one new iterator "
"that does everything they need."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1513 mm/memblock.c:1655
#: mm/memblock.c:1763
msgid "allocate boot memory block"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1514 mm/memblock.c:1613
#: mm/memblock.c:1637 mm/memblock.c:1656 mm/memblock.c:1702 mm/memblock.c:1733
#: mm/memblock.c:1764 mm/memblock.c:1799
msgid "size of memory block to be allocated in bytes"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1515 mm/memblock.c:1614
#: mm/memblock.c:1638 mm/memblock.c:1657 mm/memblock.c:1703 mm/memblock.c:1734
#: mm/memblock.c:1765 mm/memblock.c:1800
msgid "alignment of the region and block's size"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1516 mm/memblock.c:1658
msgid "the lower bound of the memory region to allocate (phys address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1517 mm/memblock.c:1659
msgid "the upper bound of the memory region to allocate (phys address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1520 mm/memblock.c:1662
msgid "``bool exact_nid``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1519 mm/memblock.c:1661
msgid "control the allocation fall back to other nodes"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1520
msgid ""
"The allocation is performed from memory region limited by memblock."
"current_limit if **end** == ``MEMBLOCK_ALLOC_ACCESSIBLE``."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1523
msgid ""
"If the specified node can not hold the requested memory and **exact_nid** is "
"false, the allocation falls back to any node in the system."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1526
msgid ""
"For systems with memory mirroring, the allocation is attempted first from "
"the regions with mirroring enabled and then retried from any memory region."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1530
msgid ""
"In addition, function using kmemleak_alloc_phys for allocated boot memory "
"block, it is never reported as leaks."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1534
msgid ""
"Physical address of allocated memory block on success, ``0`` on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1612
msgid "allocate a memory block inside specified range"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1615
msgid "the lower bound of the memory region to allocate (physical address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1616
msgid "the upper bound of the memory region to allocate (physical address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1617
msgid "Allocate **size** bytes in the between **start** and **end**."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1620 mm/memblock.c:1645
msgid ""
"physical address of the allocated memory block on success, ``0`` on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1636
msgid "allocate a memory block from specified NUMA node"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1640
msgid ""
"Allocates memory block from the specified NUMA node. If the node has no "
"available memory, attempts to allocated from any node in the system."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1659 mm/memblock.c:1705
#: mm/memblock.c:1736 mm/memblock.c:1767
msgid "``phys_addr_t min_addr``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1660 mm/memblock.c:1707
#: mm/memblock.c:1738 mm/memblock.c:1769
msgid "``phys_addr_t max_addr``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1662
msgid ""
"Allocates memory block using memblock_alloc_range_nid() and converts the "
"returned physical address to virtual."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1665
msgid ""
"The **min_addr** limit is dropped if it can not be satisfied and the "
"allocation will fall back to memory below **min_addr**. Other constraints, "
"such as node and mirrored memory will be handled again in "
"memblock_alloc_range_nid()."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1671 mm/memblock.c:1714
#: mm/memblock.c:1746 mm/memblock.c:1776
msgid "Virtual address of allocated memory block on success, NULL on failure."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1700
msgid "allocate boot memory block on the exact node without zeroing memory"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1704 mm/memblock.c:1735
#: mm/memblock.c:1766
msgid ""
"the lower bound of the memory region from where the allocation is preferred "
"(phys address)"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1706 mm/memblock.c:1737
#: mm/memblock.c:1768
msgid ""
"the upper bound of the memory region from where the allocation is preferred "
"(phys address), or ``MEMBLOCK_ALLOC_ACCESSIBLE`` to allocate only from "
"memory limited by memblock.current_limit value"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1710
msgid ""
"Public function, provides additional debug information (including caller "
"info), if enabled. Does not zero allocated memory."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1731
msgid "allocate boot memory block without zeroing memory and without panicking"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1741
msgid ""
"Public function, provides additional debug information (including caller "
"info), if enabled. Does not zero allocated memory, does not panic if request "
"cannot be satisfied."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1772
msgid ""
"Public function, provides additional debug information (including caller "
"info), if enabled. This function zeroes the allocated memory."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1798
msgid "Try to allocate memory and panic on failure"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1802
msgid "``const char *func``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1801
msgid "caller func name"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1802
msgid ""
"This function attempts to allocate memory using memblock_alloc, and in case "
"of failure, it calls panic with the formatted message. This function should "
"not be used directly, please use the macro memblock_alloc_or_panic."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1818
msgid "free pages directly to buddy allocator"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1821
msgid ""
"This is only useful when the memblock allocator has already been torn down, "
"but we are still initializing the system.  Pages are released directly to "
"the buddy allocator."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1880
msgid "return estimated number of free pages from memblock point of view"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1881
msgid ""
"During bootup, subsystems might need a rough estimate of the number of free "
"pages in the whole system, before precise numbers are available from the "
"buddy. Especially with CONFIG_DEFERRED_STRUCT_PAGE_INIT, the numbers "
"obtained from the buddy might be very imprecise during bootup."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:1888
msgid "An estimated number of free pages from memblock point of view."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2052
msgid "check if a region is a subset of memory"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2053 mm/memblock.c:2074
msgid "base of region to check"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2054 mm/memblock.c:2075
msgid "size of region to check"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2055
msgid ""
"Check if the region [**base**, **base** + **size**) is a subset of a memory "
"block."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2058
msgid "0 if false, non-zero if true"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2073
msgid "check if a region intersects reserved memory"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2076
msgid ""
"Check if the region [**base**, **base** + **size**) intersects a reserved "
"memory block."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2080
msgid "True if they intersect, false if not."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2400
msgid "release free pages to the buddy allocator"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2454
msgid "Find reserved memory region with a given name"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2460 mm/memblock.c:2485
msgid "``const char *name``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2455
msgid "The name that is attached to a reserved memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2457
msgid "``phys_addr_t *start``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2456
msgid "If found, holds the start address"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2458
msgid "``phys_addr_t *size``"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2457
msgid "If found, holds the size of the address."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2458
msgid "**start** and **size** are only updated if **name** is found."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2461
msgid "1 if found or 0 if not found."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2479
msgid "Release reserved memory region with a given name"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2480
msgid "The name that is attatched to a reserved memory region"
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2481
msgid ""
"Forcibly release the pages in the reserved memory region so that those "
"memory can be used as free memory. After released the reserved region size "
"becomes 0."
msgstr ""

#: ../../../core-api/boot-time-mm:40: mm/memblock.c:2485
msgid "1 if released or 0 if not found."
msgstr ""
