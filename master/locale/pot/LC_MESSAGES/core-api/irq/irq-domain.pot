# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/irq/irq-domain.rst:3
msgid "The irq_domain Interrupt Number Mapping Library"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:5
msgid ""
"The current design of the Linux kernel uses a single large number space "
"where each separate IRQ source is assigned a unique number. This is simple "
"when there is only one interrupt controller. But in systems with multiple "
"interrupt controllers, the kernel must ensure that each one gets assigned "
"non-overlapping allocations of Linux IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:12
msgid ""
"The number of interrupt controllers registered as unique irqchips shows a "
"rising tendency. For example, subdrivers of different kinds such as GPIO "
"controllers avoid reimplementing identical callback mechanisms as the IRQ "
"core system by modelling their interrupt handlers as irqchips. I.e. in "
"effect cascading interrupt controllers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:18
msgid ""
"So in the past, IRQ numbers could be chosen so that they match the hardware "
"IRQ line into the root interrupt controller (i.e. the component actually "
"firing the interrupt line to the CPU). Nowadays, this number is just a "
"number and the number has no relationship to hardware interrupt numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:24
msgid ""
"For this reason, we need a mechanism to separate controller-local interrupt "
"numbers, called hardware IRQs, from Linux IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:27
msgid ""
"The irq_alloc_desc*() and irq_free_desc*() APIs provide allocation of IRQ "
"numbers, but they don't provide any support for reverse mapping of the "
"controller-local IRQ (hwirq) number into the Linux IRQ number space."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:32
msgid ""
"The irq_domain library adds a mapping between hwirq and IRQ numbers on top "
"of the irq_alloc_desc*() API. An irq_domain to manage the mapping is "
"preferred over interrupt controller drivers open coding their own reverse "
"mapping scheme."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:37
msgid ""
"irq_domain also implements a translation from an abstract struct irq_fwspec "
"to hwirq numbers (Device Tree, non-DT firmware node, ACPI GSI, and software "
"node so far), and can be easily extended to support other IRQ topology data "
"sources. The implementation is performed without any extra platform support "
"code."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:44
msgid "irq_domain Usage"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:45
msgid ""
"struct irq_domain could be defined as an irq domain controller. That is, it "
"handles the mapping between hardware and virtual interrupt numbers for a "
"given interrupt domain. The domain structure is generally created by the PIC "
"code for a given PIC instance (though a domain can cover more than one PIC "
"if they have a flat number model). It is the domain callbacks that are "
"responsible for setting the irq_chip on a given irq_desc after it has been "
"mapped."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:53
msgid ""
"The host code and data structures use a fwnode_handle pointer to identify "
"the domain. In some cases, and in order to preserve source code "
"compatibility, this fwnode pointer is \"upgraded\" to a DT device_node. For "
"those firmware infrastructures that do not provide a unique identifier for "
"an interrupt controller, the irq_domain code offers a fwnode allocator."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:60
msgid ""
"An interrupt controller driver creates and registers a struct irq_domain by "
"calling one of the irq_domain_create_*() functions (each mapping method has "
"a different allocator function, more on that later). The function will "
"return a pointer to the struct irq_domain on success. The caller must "
"provide the allocator function with a struct irq_domain_ops pointer."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:67
msgid ""
"In most cases, the irq_domain will begin empty without any mappings between "
"hwirq and IRQ numbers.  Mappings are added to the irq_domain by calling "
"irq_create_mapping() which accepts the irq_domain and a hwirq number as "
"arguments. If a mapping for the hwirq doesn't already exist, "
"irq_create_mapping() allocates a new Linux irq_desc, associates it with the "
"hwirq, and calls the :c:member:`irq_domain_ops.map()` callback. In there, "
"the driver can perform any required hardware setup."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:76
msgid ""
"Once a mapping has been established, it can be retrieved or used via a "
"variety of methods:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:79
msgid ""
"irq_resolve_mapping() returns a pointer to the irq_desc structure for a "
"given domain and hwirq number, or NULL if there was no mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:82
msgid ""
"irq_find_mapping() returns a Linux IRQ number for a given domain and hwirq "
"number, or 0 if there was no mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:84
msgid ""
"generic_handle_domain_irq() handles an interrupt described by a domain and a "
"hwirq number"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:87
msgid ""
"Note that irq_domain lookups must happen in contexts that are compatible "
"with an RCU read-side critical section."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:90
msgid ""
"The irq_create_mapping() function must be called *at least once* before any "
"call to irq_find_mapping(), lest the descriptor will not be allocated."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:94
msgid ""
"If the driver has the Linux IRQ number or the irq_data pointer, and needs to "
"know the associated hwirq number (such as in the irq_chip callbacks) then it "
"can be directly obtained from :c:member:`irq_data.hwirq`."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:100
msgid "Types of irq_domain Mappings"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:102
msgid ""
"There are several mechanisms available for reverse mapping from hwirq to "
"Linux IRQ, and each mechanism uses a different allocation function. Which "
"reverse map type should be used depends on the use case.  Each of the "
"reverse map types are described below:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:108
msgid "Linear"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:114
msgid ""
"The linear reverse map maintains a fixed-size table indexed by the hwirq "
"number.  When a hwirq is mapped, an irq_desc is allocated for the hwirq, and "
"the IRQ number is stored in the table."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:118
msgid ""
"The Linear map is a good choice when the maximum number of hwirqs is fixed "
"and a relatively small number (~ < 256).  The advantages of this map are "
"fixed-time lookup for IRQ numbers, and irq_descs are only allocated for in-"
"use IRQs.  The disadvantage is that the table must be as large as the "
"largest possible hwirq number."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:124
msgid "The majority of drivers should use the Linear map."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:127
msgid "Tree"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:133
msgid ""
"The irq_domain maintains a radix tree map from hwirq numbers to Linux IRQs.  "
"When an hwirq is mapped, an irq_desc is allocated and the hwirq is used as "
"the lookup key for the radix tree."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:137
msgid ""
"The Tree map is a good choice if the hwirq number can be very large since it "
"doesn't need to allocate a table as large as the largest hwirq number.  The "
"disadvantage is that hwirq to IRQ number lookup is dependent on how many "
"entries are in the table."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:142
msgid "Very few drivers should need this mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:145
msgid "No Map"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:151
msgid ""
"The No Map mapping is to be used when the hwirq number is programmable in "
"the hardware.  In this case it is best to program the Linux IRQ number into "
"the hardware itself so that no mapping is required.  Calling "
"irq_create_direct_mapping() will allocate a Linux IRQ number and call the ."
"map() callback so that driver can program the Linux IRQ number into the "
"hardware."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:158
msgid ""
"Most drivers cannot use this mapping, and it is now gated on the "
"CONFIG_IRQ_DOMAIN_NOMAP option. Please refrain from introducing new users of "
"this API."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:163
msgid "Legacy"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:170
msgid ""
"The Legacy mapping is a special case for drivers that already have a range "
"of irq_descs allocated for the hwirqs.  It is used when the driver cannot be "
"immediately converted to use the Linear mapping.  For example, many embedded "
"system board support files use a set of #defines for IRQ numbers that are "
"passed to struct device registrations.  In that case the Linux IRQ numbers "
"cannot be dynamically assigned and the Legacy mapping should be used."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:178
msgid ""
"As the name implies, the \\*_legacy() functions are deprecated and only "
"exist to ease the support of ancient platforms. No new users should be "
"added. Same goes for the \\*_simple() functions when their use results in "
"the legacy behaviour."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:183
msgid ""
"The Legacy map assumes a contiguous range of IRQ numbers has already been "
"allocated for the controller and that the IRQ number can be calculated by "
"adding a fixed offset to the hwirq number, and visa-versa.  The disadvantage "
"is that it requires the interrupt controller to manage IRQ allocations and "
"it requires an irq_desc to be allocated for every hwirq, even if it is "
"unused."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:190
msgid ""
"The Legacy map should only be used if fixed IRQ mappings must be supported.  "
"For example, ISA controllers would use the Legacy map for mapping Linux IRQs "
"0-15 so that existing ISA drivers get the correct IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:195
msgid ""
"Most users of legacy mappings should use irq_domain_create_simple() which "
"will use a legacy domain only if an IRQ range is supplied by the system and "
"will otherwise use a linear domain mapping. The semantics of this call are "
"such that if an IRQ range is specified then descriptors will be allocated on-"
"the-fly for it, and if no range is specified it will fall through to "
"irq_domain_create_linear() which means *no* IRQ descriptors will be "
"allocated."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:203
msgid ""
"A typical use case for simple domains is where an irqchip provider is "
"supporting both dynamic and static IRQ assignments."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:206
msgid ""
"In order to avoid ending up in a situation where a linear domain is used and "
"no descriptor gets allocated it is very important to make sure that the "
"driver using the simple domain call irq_create_mapping() before any "
"irq_find_mapping() since the latter will actually work for the static IRQ "
"assignment case."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:213
msgid "Hierarchy IRQ Domain"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:215
msgid ""
"On some architectures, there may be multiple interrupt controllers involved "
"in delivering an interrupt from the device to the target CPU. Let's look at "
"a typical interrupt delivery path on x86 platforms::"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:221
msgid "There are three interrupt controllers involved:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:223
msgid "IOAPIC controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:224
msgid "Interrupt remapping controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:225
msgid "Local APIC controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:227
msgid ""
"To support such a hardware topology and make software architecture match "
"hardware architecture, an irq_domain data structure is built for each "
"interrupt controller and those irq_domains are organized into hierarchy. "
"When building irq_domain hierarchy, the irq_domain nearest the device is "
"child and the irq_domain nearest the CPU is parent. So a hierarchy structure "
"as below will be built for the example above::"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:242
msgid "There are four major interfaces to use hierarchy irq_domain:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:244
msgid ""
"irq_domain_alloc_irqs(): allocate IRQ descriptors and interrupt controller "
"related resources to deliver these interrupts."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:246
msgid ""
"irq_domain_free_irqs(): free IRQ descriptors and interrupt controller "
"related resources associated with these interrupts."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:248
msgid ""
"irq_domain_activate_irq(): activate interrupt controller hardware to deliver "
"the interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:250
msgid ""
"irq_domain_deactivate_irq(): deactivate interrupt controller hardware to "
"stop delivering the interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:253
msgid "The following is needed to support hierarchy irq_domain:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:255
msgid ""
"The :c:member:`parent` field in struct irq_domain is used to maintain "
"irq_domain hierarchy information."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:257
msgid ""
"The :c:member:`parent_data` field in struct irq_data is used to build "
"hierarchy irq_data to match hierarchy irq_domains. The irq_data is used to "
"store irq_domain pointer and hardware irq number."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:261
msgid ""
"The :c:member:`alloc()`, :c:member:`free()`, and other callbacks in struct "
"irq_domain_ops to support hierarchy irq_domain operations."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:264
msgid ""
"With the support of hierarchy irq_domain and hierarchy irq_data ready, an "
"irq_domain structure is built for each interrupt controller, and an irq_data "
"structure is allocated for each irq_domain associated with an IRQ."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:269
msgid ""
"For an interrupt controller driver to support hierarchy irq_domain, it needs "
"to:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:272
msgid "Implement irq_domain_ops.alloc() and irq_domain_ops.free()"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:273
msgid ""
"Optionally, implement irq_domain_ops.activate() and irq_domain_ops."
"deactivate()."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:275
msgid ""
"Optionally, implement an irq_chip to manage the interrupt controller "
"hardware."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:277
msgid ""
"There is no need to implement irq_domain_ops.map() and irq_domain_ops."
"unmap(). They are unused with hierarchy irq_domain."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:280
msgid ""
"Note the hierarchy irq_domain is in no way x86-specific, and is heavily used "
"to support other architectures, such as ARM, ARM64 etc."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:284
msgid "Stacked irq_chip"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:286
msgid ""
"Now, we could go one step further to support stacked (hierarchy) irq_chip. "
"That is, an irq_chip is associated with each irq_data along the hierarchy. A "
"child irq_chip may implement a required action by itself or by cooperating "
"with its parent irq_chip."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:291
msgid ""
"With stacked irq_chip, interrupt controller driver only needs to deal with "
"the hardware managed by itself and may ask for services from its parent "
"irq_chip when needed. So we could achieve a much cleaner software "
"architecture."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:297
msgid "Debugging"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:299
msgid ""
"Most of the internals of the IRQ subsystem are exposed in debugfs by turning "
"CONFIG_GENERIC_IRQ_DEBUGFS on."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:303
msgid "Structures and Public Functions Provided"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:305
msgid ""
"This chapter contains the autogenerated documentation of the structures and "
"exported kernel API functions which are used for IRQ domains."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:32
msgid "generic IRQ specifier structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:36
#: ../include/linux/irqdomain.h:52 ../include/linux/irqdomain.h:73
#: ../include/linux/irqdomain.h:136 ../include/linux/irqdomain.h:295
msgid "**Definition**::"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:44
#: ../include/linux/irqdomain.h:59 ../include/linux/irqdomain.h:94
#: ../include/linux/irqdomain.h:165 ../include/linux/irqdomain.h:318
msgid "**Members**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:34
#: ../include/linux/irqdomain.h:144 ../include/linux/irqdomain.h:292
msgid "``fwnode``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:35
msgid "Pointer to a firmware-specific descriptor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:35
msgid "``param_count``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:36
msgid "Number of device-specific parameters"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:36
msgid "``param``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:37
msgid "Device-specific parameters"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:40
#: ../include/linux/irqdomain.h:55 ../include/linux/irqdomain.h:96
#: ../include/linux/irqdomain.h:170 ../include/linux/irqdomain.h:469
#: ../include/linux/irqdomain.h:559 ../include/linux/irqdomain.h:600
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:69
#: ../kernel/irq/irqdomain.c:116 ../kernel/irq/irqdomain.c:382
#: ../kernel/irq/irqdomain.c:456 ../kernel/irq/irqdomain.c:553
#: ../kernel/irq/irqdomain.c:571 ../kernel/irq/irqdomain.c:731
#: ../kernel/irq/irqdomain.c:803 ../kernel/irq/irqdomain.c:1038
#: ../kernel/irq/irqdomain.c:1092 ../kernel/irq/irqdomain.c:1116
#: ../kernel/irq/irqdomain.c:1140 ../kernel/irq/irqdomain.c:1165
#: ../kernel/irq/irqdomain.c:1223 ../kernel/irq/irqdomain.c:1248
#: ../kernel/irq/irqdomain.c:1387 ../kernel/irq/irqdomain.c:1671
#: ../kernel/irq/irqdomain.c:1731 ../kernel/irq/irqdomain.c:1814
#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1986
#: ../kernel/irq/irqdomain.c:2005
msgid "**Description**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:37
msgid ""
"This structure, directly modeled after of_phandle_args, is used to pass a "
"device-specific description of an interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:48
msgid "firmware provided IRQ information structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:50
#: ../include/linux/irqdomain.h:138
msgid "``flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:51
msgid "Information validity flags"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:51
msgid "``affinity``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:52
msgid "Affinity mask for this interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:52
msgid ""
"This structure reports firmware-specific information about an interrupt. The "
"only significant information is the affinity of a per-CPU interrupt, but "
"this is designed to be extended as required."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:69
msgid "Methods for irq_domain objects"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:70
msgid "``match``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:71
msgid ""
"Match an interrupt controller device node to a domain, returns 1 on a match"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:72
msgid "``select``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:73
msgid ""
"Match an interrupt controller fw specification. It is more generic than "
"**match** as it receives a complete struct irq_fwspec. Therefore, **select** "
"is preferred if provided. Returns 1 on a match."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:75
msgid "``map``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:76
msgid ""
"Create or update a mapping between a virtual irq number and a hw irq number. "
"This is called only once for a given mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:77
msgid "``unmap``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:78
msgid "Dispose of such a mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:78
msgid "``xlate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:79
msgid ""
"Given a device tree node and interrupt specifier, decode the hardware irq "
"number and linux irq type value."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:80
msgid "``alloc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:81
msgid "Allocate **nr_irqs** interrupts starting from **virq**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:81
msgid "``free``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:82
msgid "Free **nr_irqs** interrupts starting from **virq**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:82
msgid "``activate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:83
msgid ""
"Activate one interrupt in HW (**irqd**). If **reserve** is set, only reserve "
"the vector. If unset, assign the vector (called from request_irq())."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:85
msgid "``deactivate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:86
msgid "Disarm one interrupt (**irqd**)."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:86
msgid "``translate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:87
msgid ""
"Given **fwspec**, decode the hardware irq number (**out_hwirq**) and linux "
"irq type value (**out_type**). This is a generalised **xlate** (over struct "
"irq_fwspec) and is preferred if provided."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:89
msgid "``get_fwspec_info``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:90
msgid ""
"Given **fwspec**, report additional firmware-provided information in "
"**info**. Optional."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:92
msgid "``debug_show``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:93
msgid "For domains to show specific data for an interrupt in debugfs."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:93
msgid ""
"Functions below are provided by the driver and called whenever a new mapping "
"is created or an old mapping is disposed. The driver can then proceed to "
"whatever internal data structures management is required. It also needs to "
"setup the irq_desc when returning from map()."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:132
msgid "Hardware interrupt number translation object"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:133
msgid "``link``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:134
msgid "Element in global irq_domain list."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:134
msgid "``name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:135
msgid "Name of interrupt domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:135
#: ../include/linux/irqdomain.h:304
msgid "``ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:136
msgid "Pointer to irq_domain methods"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:136
#: ../include/linux/irqdomain.h:305
msgid "``host_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:137
msgid ""
"Private data pointer for use by owner.  Not touched by irq_domain core code."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:139
msgid "Per irq_domain flags"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:139
msgid "``mapcount``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:140
msgid "The number of mapped interrupts"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:140
msgid "``mutex``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:141
msgid "Domain lock, hierarchical domains use root domain's lock"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:141
msgid "``root``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:142
msgid "Pointer to root domain, or containing structure if non-hierarchical"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:145
msgid ""
"Pointer to firmware node associated with the irq_domain. Pretty easy to swap "
"it for the of_node via the irq_domain_get_of_node accessor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:146
#: ../include/linux/irqdomain.h:301
msgid "``bus_token``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:147
msgid ""
"**fwnode**'s device_node might be used for several irq domains. But in "
"connection with **bus_token**, the pair shall be unique in a system."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:149
msgid "``gc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:150
msgid ""
"Pointer to a list of generic chips. There is a helper function for setting "
"up one or more generic chips for interrupt controllers drivers using the "
"generic chip library which uses this pointer."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:152
#: ../include/linux/irqdomain.h:306
msgid "``dev``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:153
msgid ""
"Pointer to the device which instantiated the irqdomain With per device irq "
"domains this is not necessarily the same as **pm_dev**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:155
msgid "``pm_dev``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:156
msgid ""
"Pointer to a device that can be utilized for power management purposes "
"related to the irq domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:157
#: ../include/linux/irqdomain.h:329
msgid "``parent``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:158
msgid "Pointer to parent irq_domain to support hierarchy irq_domains"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:158
msgid "``msi_parent_ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:159
msgid "Pointer to MSI parent domain methods for per device domain init"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:159
#: ../include/linux/irqdomain.h:311
msgid "``exit``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:160
msgid "Function called when the domain is destroyed"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:162
#: ../include/linux/irqdomain.h:295
msgid "``hwirq_max``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:163
msgid ""
"Top limit for the HW irq number. Especially to avoid conflicts/failures with "
"reserved HW irqs. Can be ~0."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:164
msgid "``revmap_size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:165
msgid "Size of the linear map table **revmap**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:165
msgid "``revmap_tree``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:166
msgid "Radix map tree for hwirqs that don't fit in the linear map"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:166
msgid "``revmap``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:167
msgid "Linear table of irq_data pointers"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:142
msgid "Optional elements:"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:144
msgid "Revmap data, used internally by the irq domain code:"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:291
msgid "Domain information structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:293
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:448
msgid "firmware node for the interrupt controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:293
msgid "``domain_flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:294
msgid "Additional flags to add to the domain flags"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:294
msgid "``size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:295
msgid "Size of linear map; 0 for radix mapping only"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:296
msgid "Maximum number of interrupts supported by controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:296
msgid "``direct_max``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:297
msgid ""
"Maximum value of direct maps; Use ~0 for no limit; 0 for no direct mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:298
msgid "``hwirq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:299
msgid "The first hardware interrupt number (legacy domains only)"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:299
msgid "``virq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:300
msgid ""
"The first Linux interrupt number for legacy domains to immediately associate "
"the interrupts after domain creation"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:302
msgid "Domain bus token"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:302
msgid "``name_suffix``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:303
msgid ""
"Optional name suffix to avoid collisions when multiple domains are added "
"using same fwnode"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:305
msgid "Domain operation callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:306
#: ../include/linux/irqdomain.h:417 ../include/linux/irqdomain.h:557
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:454
msgid "Controller private data pointer"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:307
msgid "Device which creates the domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:330
msgid "Pointer to the parent irq domain used in a hierarchy domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:307
msgid "``dgc_info``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:308
msgid ""
"Geneneric chip information structure pointer used to create generic chips "
"for the domain if not NULL."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:309
msgid "``init``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:310
msgid ""
"Function called when the domain is created. Allow to do some additional "
"domain initialisation."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:312
msgid ""
"Function called when the domain is destroyed. Allow to do some additional "
"cleanup operation."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:413
msgid "Allocate and register a linear revmap irq_domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:417
#: ../include/linux/irqdomain.h:469 ../include/linux/irqdomain.h:490
#: ../include/linux/irqdomain.h:503 ../include/linux/irqdomain.h:555
#: ../include/linux/irqdomain.h:598 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:66 ../kernel/irq/irqdomain.c:117
#: ../kernel/irq/irqdomain.c:371 ../kernel/irq/irqdomain.c:383
#: ../kernel/irq/irqdomain.c:451 ../kernel/irq/irqdomain.c:511
#: ../kernel/irq/irqdomain.c:554 ../kernel/irq/irqdomain.c:571
#: ../kernel/irq/irqdomain.c:732 ../kernel/irq/irqdomain.c:802
#: ../kernel/irq/irqdomain.c:1011 ../kernel/irq/irqdomain.c:1037
#: ../kernel/irq/irqdomain.c:1088 ../kernel/irq/irqdomain.c:1112
#: ../kernel/irq/irqdomain.c:1136 ../kernel/irq/irqdomain.c:1161
#: ../kernel/irq/irqdomain.c:1199 ../kernel/irq/irqdomain.c:1220
#: ../kernel/irq/irqdomain.c:1245 ../kernel/irq/irqdomain.c:1299
#: ../kernel/irq/irqdomain.c:1387 ../kernel/irq/irqdomain.c:1487
#: ../kernel/irq/irqdomain.c:1506 ../kernel/irq/irqdomain.c:1532
#: ../kernel/irq/irqdomain.c:1554 ../kernel/irq/irqdomain.c:1575
#: ../kernel/irq/irqdomain.c:1666 ../kernel/irq/irqdomain.c:1730
#: ../kernel/irq/irqdomain.c:1814 ../kernel/irq/irqdomain.c:1918
#: ../kernel/irq/irqdomain.c:1937 ../../../core-api/irq/irq-domain:319:
#: ../kernel/irq/irqdomain.c:1883 ../kernel/irq/irqdomain.c:1985
#: ../kernel/irq/irqdomain.c:2005
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:419
#: ../include/linux/irqdomain.h:556 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:119 ../kernel/irq/irqdomain.c:453
msgid "``struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:414
msgid "pointer to interrupt controller's FW node."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:416
#: ../include/linux/irqdomain.h:555 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:450
msgid "``unsigned int size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:415
msgid "Number of interrupts in the domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:417
#: ../include/linux/irqdomain.h:557 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:454
msgid "``const struct irq_domain_ops *ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:416
msgid "map/unmap domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:418
#: ../include/linux/irqdomain.h:558 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:455
msgid "``void *host_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:419
#: ../include/linux/irqdomain.h:473 ../include/linux/irqdomain.h:490
#: ../include/linux/irqdomain.h:503 ../include/linux/irqdomain.h:563
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:3
#: ../kernel/irq/irqdomain.c:370
msgid "**Return**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:419
msgid "Newly created irq_domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:465
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:798
msgid "Map a hardware interrupt into linux irq space"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:471
#: ../include/linux/irqdomain.h:492 ../include/linux/irqdomain.h:505
#: ../include/linux/irqdomain.h:600 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:385 ../kernel/irq/irqdomain.c:556
#: ../kernel/irq/irqdomain.c:734 ../kernel/irq/irqdomain.c:804
#: ../kernel/irq/irqdomain.c:1039 ../kernel/irq/irqdomain.c:1389
#: ../kernel/irq/irqdomain.c:1489 ../kernel/irq/irqdomain.c:1508
#: ../kernel/irq/irqdomain.c:1534 ../kernel/irq/irqdomain.c:1556
#: ../kernel/irq/irqdomain.c:1577 ../kernel/irq/irqdomain.c:1668
#: ../kernel/irq/irqdomain.c:1732 ../kernel/irq/irqdomain.c:1816
#: ../kernel/irq/irqdomain.c:1920 ../kernel/irq/irqdomain.c:1939
msgid "``struct irq_domain *domain``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:466
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:799
msgid "domain owning this hardware interrupt or NULL for default domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:468
#: ../include/linux/irqdomain.h:489 ../include/linux/irqdomain.h:502
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:801
#: ../kernel/irq/irqdomain.c:1036 ../kernel/irq/irqdomain.c:1506
#: ../kernel/irq/irqdomain.c:1532
msgid "``irq_hw_number_t hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:467
#: ../include/linux/irqdomain.h:488 ../include/linux/irqdomain.h:501
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:800
#: ../kernel/irq/irqdomain.c:1035
msgid "hardware irq number in that domain space"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:468
msgid "Only one mapping per hardware interrupt is permitted."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:470
msgid ""
"If the sense/trigger is to be specified, set_irq_type() should be called on "
"the number returned from that call."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:474
msgid "Linux irq number or 0 on error"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:486
#: ../include/linux/irqdomain.h:499 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:1033
msgid "Find a linux irq from a hw irq number."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:487
#: ../include/linux/irqdomain.h:500 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:1034
msgid "domain owning this hardware interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:490
msgid "Interrupt descriptor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:503
msgid "Linux irq number or 0 if not found"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:551
msgid "Add a irqdomain into the hierarchy"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:557
msgid "``struct irq_domain *parent``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:552
msgid "Parent irq domain to associate with the new domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:554
msgid "``unsigned int flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:553
msgid "Irq domain flags associated to the domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:554
msgid "Size of the domain. See below"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:555
msgid "Optional fwnode of the interrupt controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:556
msgid "Pointer to the interrupt domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:558
msgid "If **size** is 0 a tree domain is created, otherwise a linear domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:560
msgid ""
"If successful the parent is associated to the new domain and the domain "
"flags are set."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:564
msgid "A pointer to IRQ domain, or ``NULL`` on failure."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:594
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1662
msgid "Allocate IRQs from domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:595
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1663
msgid "domain to allocate from"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:597
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1554
#: ../kernel/irq/irqdomain.c:1575 ../kernel/irq/irqdomain.c:1666
#: ../kernel/irq/irqdomain.c:1918 ../kernel/irq/irqdomain.c:1937
#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1882
msgid "``unsigned int nr_irqs``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:596
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1665
msgid "number of IRQs to allocate"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:598
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1667
msgid "``int node``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:597
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1666
msgid "NUMA node id for memory allocation"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:599
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1668
#: ../kernel/irq/irqdomain.c:1730 ../kernel/irq/irqdomain.c:1919
msgid "``void *arg``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:598
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1667
msgid "domain specific argument"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:599
msgid "See __irq_domain_alloc_irqs()' documentation."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:62
msgid "Allocate a fwnode_handle suitable for identifying an irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:68
msgid "``unsigned int type``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:64
msgid "Type of irqchip_fwnode. See linux/irqdomain.h"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:66
msgid "``int id``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:65
msgid "Optional user provided id if name != NULL"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:67
msgid "``const char *name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:66
msgid "Optional user provided domain name"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:68
msgid "``phys_addr_t *pa``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:67
msgid "Optional user-provided physical address"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:68
msgid ""
"Allocate a struct irqchip_fwid, and return a pointer to the embedded "
"fwnode_handle (or NULL on failure)."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:71
#: ../kernel/irq/irqdomain.c:1168
msgid "**Note**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:72
msgid ""
"The types IRQCHIP_FWNODE_NAMED and IRQCHIP_FWNODE_NAMED_ID are solely to "
"transport name information to irqdomain creation code. The node is not "
"stored. For other types the pointer is kept in the irq domain struct."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:113
msgid "Free a non-OF-backed fwnode_handle"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:114
msgid "fwnode_handle to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:115
msgid "Free a fwnode_handle allocated with irq_domain_alloc_fwnode."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:367
msgid "Instantiate a new irq domain data structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:373
msgid "``const struct irq_domain_info *info``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:368
msgid "Domain information pointer pointing to the information for this domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:370
msgid "A pointer to the instantiated irq domain or an ERR_PTR value."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:379
msgid "Remove an irq domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:380
msgid "domain to remove"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:381
msgid ""
"This routine is used to remove an irq domain. The caller must ensure that "
"all mappings within the domain have been disposed of prior to use, depending "
"on the revmap type."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:447
msgid "Register an irq_domain and optionally map a range of irqs"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:449
msgid "total number of irqs in mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:451
msgid "``unsigned int first_irq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:450
msgid ""
"first number of irq block assigned to the domain, pass zero to assign irqs "
"on-the-fly. If first_irq is non-zero, then pre-map all of the irqs in the "
"domain to virqs starting at first_irq."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:453
msgid "domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:455
msgid ""
"Allocates an irq_domain, and optionally if first_irq is positive then also "
"allocate irq_descs and map all of the hwirqs to virqs starting at first_irq."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:458
msgid ""
"This is intended to implement the expected behaviour for most interrupt "
"controllers. If device tree is used, then first_irq will be 0 and irqs get "
"mapped dynamically on the fly. However, if the controller requires static "
"virq assignments (non-DT boot) then it will set that up correctly."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:507
msgid "Locates a domain for a given fwspec"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:513
#: ../kernel/irq/irqdomain.c:1199 ../kernel/irq/irqdomain.c:1220
#: ../kernel/irq/irqdomain.c:1245
msgid "``struct irq_fwspec *fwspec``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:508
msgid "FW specifier for an interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:510
msgid "``enum irq_domain_bus_token bus_token``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:509
msgid "domain-specific data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:550
msgid "Set a \"default\" irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:551
msgid "default domain pointer"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:552
msgid ""
"For convenience, it's possible to set a \"default\" domain that will be used "
"whenever NULL is passed to irq_create_mapping(). It makes life easier for "
"platforms that want to manipulate a few hard coded interrupt numbers that "
"aren't properly represented in the device-tree."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:567
msgid "Retrieve the \"default\" irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:573
msgid "``void``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1
msgid "no arguments"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:569
msgid "the default domain, if any."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:570
msgid ""
"Modern code should never use this. This should only be used on systems that "
"cannot implement a firmware->fwnode mapping (which both DT and ACPI provide)."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:728
msgid "Allocate an irq for direct mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:729
msgid "domain to allocate the irq for or NULL for default domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:730
msgid ""
"This routine is used for irq controllers which can choose the hardware "
"interrupt numbers they generate. In such a case it's simplest to use the "
"linux irq as the hardware interrupt number. It still uses the linear or "
"radix tree to store the mapping, but the irq controller can optimize the "
"revmap path by using the hwirq directly."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:802
#: ../kernel/irq/irqdomain.c:1670
msgid "``const struct irq_affinity_desc *affinity``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:801
msgid "irq affinity"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:802
msgid ""
"Only one mapping per hardware interrupt is permitted. Returns a linux irq "
"number. If the sense/trigger is to be specified, set_irq_type() should be "
"called on the number returned from that call."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1007
msgid "Unmap an interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1013
#: ../kernel/irq/irqdomain.c:1386 ../kernel/irq/irqdomain.c:1486
#: ../kernel/irq/irqdomain.c:1505 ../kernel/irq/irqdomain.c:1531
#: ../kernel/irq/irqdomain.c:1553 ../kernel/irq/irqdomain.c:1574
#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1885
msgid "``unsigned int virq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1008
msgid "linux irq number of the interrupt to unmap"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1037
msgid "``unsigned int *irq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1036
msgid "optional pointer to return the Linux irq if required"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1037
msgid "Returns the interrupt descriptor."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1084
msgid "Generic xlate for direct one cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1090
#: ../kernel/irq/irqdomain.c:1114 ../kernel/irq/irqdomain.c:1138
#: ../kernel/irq/irqdomain.c:1163 ../kernel/irq/irqdomain.c:1201
#: ../kernel/irq/irqdomain.c:1222 ../kernel/irq/irqdomain.c:1247
msgid "``struct irq_domain *d``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1085
#: ../kernel/irq/irqdomain.c:1109 ../kernel/irq/irqdomain.c:1133
#: ../kernel/irq/irqdomain.c:1158 ../kernel/irq/irqdomain.c:1197
#: ../kernel/irq/irqdomain.c:1218 ../kernel/irq/irqdomain.c:1243
msgid "Interrupt domain involved in the translation"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1087
#: ../kernel/irq/irqdomain.c:1111 ../kernel/irq/irqdomain.c:1135
#: ../kernel/irq/irqdomain.c:1160
msgid "``struct device_node *ctrlr``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1086
#: ../kernel/irq/irqdomain.c:1110 ../kernel/irq/irqdomain.c:1134
#: ../kernel/irq/irqdomain.c:1159
msgid "The device tree node for the device whose interrupt is translated"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1088
#: ../kernel/irq/irqdomain.c:1112 ../kernel/irq/irqdomain.c:1136
#: ../kernel/irq/irqdomain.c:1161
msgid "``const u32 *intspec``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1087
#: ../kernel/irq/irqdomain.c:1111 ../kernel/irq/irqdomain.c:1135
#: ../kernel/irq/irqdomain.c:1160
msgid "The interrupt specifier data from the device tree"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1089
#: ../kernel/irq/irqdomain.c:1113 ../kernel/irq/irqdomain.c:1137
#: ../kernel/irq/irqdomain.c:1162
msgid "``unsigned int intsize``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1088
#: ../kernel/irq/irqdomain.c:1112 ../kernel/irq/irqdomain.c:1136
#: ../kernel/irq/irqdomain.c:1161
msgid "The number of entries in **intspec**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1090
#: ../kernel/irq/irqdomain.c:1163 ../kernel/irq/irqdomain.c:1200
#: ../kernel/irq/irqdomain.c:1221 ../kernel/irq/irqdomain.c:1246
msgid "``unsigned long *out_hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1089
#: ../kernel/irq/irqdomain.c:1113 ../kernel/irq/irqdomain.c:1137
#: ../kernel/irq/irqdomain.c:1162 ../kernel/irq/irqdomain.c:1199
#: ../kernel/irq/irqdomain.c:1220 ../kernel/irq/irqdomain.c:1245
msgid "Pointer to storage for the hardware interrupt number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1091
#: ../kernel/irq/irqdomain.c:1115 ../kernel/irq/irqdomain.c:1139
#: ../kernel/irq/irqdomain.c:1164 ../kernel/irq/irqdomain.c:1201
#: ../kernel/irq/irqdomain.c:1222 ../kernel/irq/irqdomain.c:1247
msgid "``unsigned int *out_type``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1090
#: ../kernel/irq/irqdomain.c:1114 ../kernel/irq/irqdomain.c:1138
#: ../kernel/irq/irqdomain.c:1163 ../kernel/irq/irqdomain.c:1200
#: ../kernel/irq/irqdomain.c:1221 ../kernel/irq/irqdomain.c:1246
msgid "Pointer to storage for the interrupt type"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1091
msgid ""
"Device Tree IRQ specifier translation function which works with one cell "
"bindings where the cell value maps directly to the hwirq number."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1108
msgid "Generic xlate for direct two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1114
#: ../kernel/irq/irqdomain.c:1138
msgid "``irq_hw_number_t *out_hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1115
#: ../kernel/irq/irqdomain.c:1222
msgid ""
"Device Tree IRQ specifier translation function which works with two cell "
"bindings where the cell values map directly to the hwirq number and linux "
"irq flags."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1132
msgid "Generic xlate for direct two or three cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1139
msgid ""
"Device Tree interrupt specifier translation function for two or three cell "
"bindings, where the cell values map directly to the hardware interrupt "
"number and the type specifier."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1157
msgid "Generic xlate for one or two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1164
msgid ""
"Device Tree IRQ specifier translation function which works with either one "
"or two cell bindings where the cell values map directly to the hwirq number "
"and linux irq flags."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1169
msgid ""
"don't use this function unless your interrupt controller explicitly supports "
"both one and two cell bindings.  For the majority of controllers the "
"_onecell() or _twocell() variants above should be used."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1195
msgid "Generic translate for direct one cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1198
#: ../kernel/irq/irqdomain.c:1219 ../kernel/irq/irqdomain.c:1244
msgid "The firmware interrupt specifier to translate"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1216
msgid "Generic translate for direct two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1241
msgid "Generic translate for direct two or three cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1247
msgid ""
"Firmware interrupt specifier translation function for two or three cell "
"specifications, where the parameter values map directly to the hardware "
"interrupt number and the type specifier."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1295
msgid "Clear hwirq, chip and chip_data in **irq_data**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1301
#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1987
#: ../kernel/irq/irqdomain.c:2007
msgid "``struct irq_data *irq_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1296
msgid "The pointer to irq_data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1383
msgid "Mark the first unused level of a hierarchy"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1384
msgid "IRQ domain from which the hierarchy is to be disconnected"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1385
msgid "IRQ number where the hierarchy is to be trimmed"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1386
msgid ""
"Marks the **virq** level belonging to **domain** as disconnected. Returns -"
"EINVAL if **virq** doesn't have a valid irq_data pointing to **domain**."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1390
msgid ""
"Its only use is to be able to trim levels of hierarchy that do not have any "
"real meaning for this interrupt, and that the driver marks as such from its ."
"alloc() callback."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1483
msgid "Get irq_data associated with **virq** and **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1484
msgid "domain to match"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1485
msgid "IRQ number to get irq_data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1502
msgid "Set hwirq and irqchip of **virq** at **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1503
#: ../kernel/irq/irqdomain.c:1529 ../kernel/irq/irqdomain.c:1551
#: ../kernel/irq/irqdomain.c:1572
msgid "Interrupt domain to match"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1504
#: ../kernel/irq/irqdomain.c:1530
msgid "IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1505
msgid "The hwirq number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1507
#: ../kernel/irq/irqdomain.c:1533
msgid "``const struct irq_chip *chip``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1506
#: ../kernel/irq/irqdomain.c:1532
msgid "The associated interrupt chip"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1508
#: ../kernel/irq/irqdomain.c:1534
msgid "``void *chip_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1507
msgid "The associated chip data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1528
msgid "Set the complete data for a **virq** in **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1531
msgid "The hardware interrupt number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1533
msgid "The associated interrupt chip data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1535
msgid "``irq_flow_handler_t handler``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1534
msgid "The interrupt flow handler"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1536
msgid "``void *handler_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1535
msgid "The interrupt flow handler data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1537
msgid "``const char *handler_name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1536
msgid "The interrupt handler name"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1550
msgid "Clear irq_data and free the parent"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1552
#: ../kernel/irq/irqdomain.c:1573
msgid "IRQ number to start with"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1553
#: ../kernel/irq/irqdomain.c:1574
msgid "The number of irqs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1571
msgid "Clear handler and handler data, clear irqdata and free parent"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1665
msgid "``int irq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1664
msgid "allocate specified IRQ number if irq_base >= 0"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1669
msgid "``bool realloc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1668
msgid "IRQ descriptors have already been allocated if true"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1669
msgid "Optional irq affinity mask for multiqueue devices"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1670
msgid ""
"Allocate IRQ numbers and initialized all data structures to support "
"hierarchy IRQ domains. Parameter **realloc** is mainly to support legacy "
"IRQs. Returns error code or allocated IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1675
msgid ""
"The whole process to setup an IRQ has been split into two steps. The first "
"step, __irq_domain_alloc_irqs(), is to allocate IRQ descriptor and required "
"hardware resources. The second step, irq_domain_activate_irq(), is to "
"program the hardware with preallocated resources. In this way, it's easier "
"to rollback when failing to allocate resources."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1726
msgid "Push a domain in to the top of a hierarchy."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1727
msgid "Domain to push."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1729
#: ../kernel/irq/irqdomain.c:1813
msgid "``int virq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1728
msgid "Irq to push the domain in to."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1729
msgid "Passed to the irq_domain_ops alloc() function."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1730
msgid ""
"For an already existing irqdomain hierarchy, as might be obtained via a call "
"to pci_enable_msix(), add an additional domain to the head of the processing "
"chain.  Must be called before request_irq() has been called."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1810
msgid "Remove a domain from the top of a hierarchy."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1811
msgid "Domain to remove."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1812
msgid "Irq to remove the domain from."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1813
msgid ""
"Undo the effects of a call to irq_domain_push_irq().  Must be called either "
"before request_irq() or after free_irq()."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1914
msgid "Allocate interrupts from parent domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1915
msgid "Domain below which interrupts must be allocated"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1917
#: ../kernel/irq/irqdomain.c:1936
msgid "``unsigned int irq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1916
#: ../kernel/irq/irqdomain.c:1935
msgid "Base IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1917
msgid "Number of IRQs to allocate"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1918
msgid "Allocation data (arch/domain specific)"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1933
msgid "Free interrupts from parent domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1934
msgid "Domain below which interrupts must be freed"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1936
msgid "Number of IRQs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:314
msgid "Internal Functions Provided"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:316
msgid ""
"This chapter contains the autogenerated documentation of the internal "
"functions."
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1879
msgid "Free IRQ number and associated data structures"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1880
msgid "base IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1881
msgid "number of IRQs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1981
msgid "Call domain_ops->activate recursively to activate interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1983
msgid "Outermost irq_data associated with interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1985
msgid "``bool reserve``"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1984
msgid "If set only reserve an interrupt vector instead of assigning one"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1985
msgid ""
"This is the second step to call domain_ops->activate to program interrupt "
"controllers, so the interrupt could actually get delivered."
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:2001
msgid "Call domain_ops->deactivate recursively to deactivate interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:2003
msgid "outermost irq_data associated with interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:2004
msgid ""
"It calls domain_ops->deactivate to program interrupt controllers to disable "
"interrupt delivery."
msgstr ""
