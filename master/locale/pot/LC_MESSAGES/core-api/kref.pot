# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/kref.rst:3
msgid "Adding reference counters (krefs) to kernel objects"
msgstr ""

#: ../../../core-api/kref.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/kref.rst:5
msgid "Corey Minyard <minyard@acm.org>"
msgstr ""

#: ../../../core-api/kref.rst:6
msgid "Thomas Hellstr√∂m <thomas.hellstrom@linux.intel.com>"
msgstr ""

#: ../../../core-api/kref.rst:8
msgid ""
"A lot of this was lifted from Greg Kroah-Hartman's 2004 OLS paper and "
"presentation on krefs, which can be found at:"
msgstr ""

#: ../../../core-api/kref.rst:11
msgid ""
"http://www.kroah.com/linux/talks/ols_2004_kref_paper/Reprint-Kroah-Hartman-"
"OLS2004.pdf"
msgstr ""

#: ../../../core-api/kref.rst:12
msgid "http://www.kroah.com/linux/talks/ols_2004_kref_talk/"
msgstr ""

#: ../../../core-api/kref.rst:15
msgid "Introduction"
msgstr ""

#: ../../../core-api/kref.rst:17
msgid ""
"krefs allow you to add reference counters to your objects.  If you have "
"objects that are used in multiple places and passed around, and you don't "
"have refcounts, your code is almost certainly broken.  If you want "
"refcounts, krefs are the way to go."
msgstr ""

#: ../../../core-api/kref.rst:22
msgid "To use a kref, add one to your data structures like::"
msgstr ""

#: ../../../core-api/kref.rst:33
msgid "The kref can occur anywhere within the data structure."
msgstr ""

#: ../../../core-api/kref.rst:36
msgid "Initialization"
msgstr ""

#: ../../../core-api/kref.rst:38
msgid ""
"You must initialize the kref after you allocate it.  To do this, call "
"kref_init as so::"
msgstr ""

#: ../../../core-api/kref.rst:48
msgid "This sets the refcount in the kref to 1."
msgstr ""

#: ../../../core-api/kref.rst:51
msgid "Kref rules"
msgstr ""

#: ../../../core-api/kref.rst:53
msgid "Once you have an initialized kref, you must follow the following rules:"
msgstr ""

#: ../../../core-api/kref.rst:56
msgid ""
"If you make a non-temporary copy of a pointer, especially if it can be "
"passed to another thread of execution, you must increment the refcount with "
"kref_get() before passing it off::"
msgstr ""

#: ../../../core-api/kref.rst:62
msgid ""
"If you already have a valid pointer to a kref-ed structure (the refcount "
"cannot go to zero) you may do this without a lock."
msgstr ""

#: ../../../core-api/kref.rst:65
msgid "When you are done with a pointer, you must call kref_put()::"
msgstr ""

#: ../../../core-api/kref.rst:69
msgid ""
"If this is the last reference to the pointer, the release routine will be "
"called.  If the code never tries to get a valid pointer to a kref-ed "
"structure without already holding a valid pointer, it is safe to do this "
"without a lock."
msgstr ""

#: ../../../core-api/kref.rst:75
msgid ""
"If the code attempts to gain a reference to a kref-ed structure without "
"already holding a valid pointer, it must serialize access where a kref_put() "
"cannot occur during the kref_get(), and the structure must remain valid "
"during the kref_get()."
msgstr ""

#: ../../../core-api/kref.rst:80
msgid ""
"For example, if you allocate some data and then pass it to another thread to "
"process::"
msgstr ""

#: ../../../core-api/kref.rst:124
msgid ""
"This way, it doesn't matter what order the two threads handle the data, the "
"kref_put() handles knowing when the data is not referenced any more and "
"releasing it.  The kref_get() does not require a lock, since we already have "
"a valid pointer that we own a refcount for.  The put needs no lock because "
"nothing tries to get the data without already holding a pointer."
msgstr ""

#: ../../../core-api/kref.rst:131
msgid ""
"In the above example, kref_put() will be called 2 times in both success and "
"error paths. This is necessary because the reference count got incremented 2 "
"times by kref_init() and kref_get()."
msgstr ""

#: ../../../core-api/kref.rst:135
msgid ""
"Note that the \"before\" in rule 1 is very important.  You should never do "
"something like::"
msgstr ""

#: ../../../core-api/kref.rst:146
msgid ""
"Don't assume you know what you are doing and use the above construct. First "
"of all, you may not know what you are doing.  Second, you may know what you "
"are doing (there are some situations where locking is involved where the "
"above may be legal) but someone else who doesn't know what they are doing "
"may change the code or copy the code.  It's bad style.  Don't do it."
msgstr ""

#: ../../../core-api/kref.rst:153
msgid ""
"There are some situations where you can optimize the gets and puts. For "
"instance, if you are done with an object and enqueuing it for something else "
"or passing it off to something else, there is no reason to do a get then a "
"put::"
msgstr ""

#: ../../../core-api/kref.rst:163
msgid "Just do the enqueue.  A comment about this is always welcome::"
msgstr ""

#: ../../../core-api/kref.rst:169
msgid ""
"The last rule (rule 3) is the nastiest one to handle.  Say, for instance, "
"you have a list of items that are each kref-ed, and you wish to get the "
"first one.  You can't just pull the first item off the list and kref_get() "
"it.  That violates rule 3 because you are not already holding a valid "
"pointer.  You must add a mutex (or some other lock). For instance::"
msgstr ""

#: ../../../core-api/kref.rst:211
msgid ""
"The kref_put() return value is useful if you do not want to hold the lock "
"during the whole release operation.  Say you didn't want to call kfree() "
"with the lock held in the example above (since it is kind of pointless to do "
"so).  You could use kref_put() as follows::"
msgstr ""

#: ../../../core-api/kref.rst:232
msgid ""
"This is really more useful if you have to call other routines as part of the "
"free operations that could take a long time or might claim the same lock.  "
"Note that doing everything in the release routine is still preferred as it "
"is a little neater."
msgstr ""

#: ../../../core-api/kref.rst:237
msgid ""
"The above example could also be optimized using kref_get_unless_zero() in "
"the following way::"
msgstr ""

#: ../../../core-api/kref.rst:268
msgid ""
"Which is useful to remove the mutex lock around kref_put() in put_entry(), "
"but it's important that kref_get_unless_zero is enclosed in the same "
"critical section that finds the entry in the lookup table, otherwise "
"kref_get_unless_zero may reference already freed memory. Note that it is "
"illegal to use kref_get_unless_zero without checking its return value. If "
"you are sure (by already having a valid pointer) that kref_get_unless_zero() "
"will return true, then use kref_get() instead."
msgstr ""

#: ../../../core-api/kref.rst:277
msgid "Krefs and RCU"
msgstr ""

#: ../../../core-api/kref.rst:279
msgid ""
"The function kref_get_unless_zero also makes it possible to use rcu locking "
"for lookups in the above example::"
msgstr ""

#: ../../../core-api/kref.rst:319
msgid ""
"But note that the struct kref member needs to remain in valid memory for a "
"rcu grace period after release_entry_rcu was called. That can be "
"accomplished by using kfree_rcu(entry, rhead) as done above, or by calling "
"synchronize_rcu() before using kfree, but note that synchronize_rcu() may "
"sleep for a substantial amount of time."
msgstr ""

#: ../../../core-api/kref.rst:326
msgid "Functions and structures"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:26
msgid "initialize object."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:30 include/linux/kref.h:44
#: include/linux/kref.h:53 include/linux/kref.h:76 include/linux/kref.h:97
#: include/linux/kref.h:118
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:32 include/linux/kref.h:46
#: include/linux/kref.h:55 include/linux/kref.h:78 include/linux/kref.h:99
#: include/linux/kref.h:120
msgid "``struct kref *kref``"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:27
msgid "object in question."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:40
msgid "increment refcount for object."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:41 include/linux/kref.h:115
msgid "object."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:49 include/linux/kref.h:72
#: include/linux/kref.h:93
msgid "Decrement refcount for object"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:50 include/linux/kref.h:73
#: include/linux/kref.h:94
msgid "Object"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:52 include/linux/kref.h:75
#: include/linux/kref.h:96
msgid "``void (*release)(struct kref *kref)``"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:51 include/linux/kref.h:74
#: include/linux/kref.h:95
msgid ""
"Pointer to the function that will clean up the object when the last "
"reference to the object is released."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:54 include/linux/kref.h:78
#: include/linux/kref.h:99 include/linux/kref.h:117
msgid "**Description**"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:53
msgid ""
"Decrement the refcount, and if 0, call **release**.  The caller may not pass "
"NULL or kfree() as the release function."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:56 include/linux/kref.h:126
msgid "**Return**"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:57
msgid ""
"1 if this call removed the object, otherwise return 0.  Beware, if this "
"function returns 0, another caller may have removed the object by the time "
"this function returns.  The return value is only certain if you want to see "
"if the object is definitely released."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:77
msgid "``struct mutex *mutex``"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:76
msgid "Mutex which protects the release function."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:77
msgid ""
"This variant of kref_lock() calls the **release** function with the "
"**mutex** held.  The **release** function will release the mutex."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:98
msgid "``spinlock_t *lock``"
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:97
msgid "Spinlock which protects the release function."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:98
msgid ""
"This variant of kref_lock() calls the **release** function with the **lock** "
"held.  The **release** function will release the lock."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:114
msgid "Increment refcount for object unless it is zero."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:116
msgid ""
"This function is intended to simplify locking around refcounting for objects "
"that can be looked up from a lookup structure, and which are removed from "
"that lookup structure in the object destructor. Operations on such objects "
"require at least a read lock around lookup + kref_get, and a write lock "
"around kref_put + remove from lookup structure. Furthermore, RCU "
"implementations become extremely tricky. With a lookup followed by a "
"kref_get_unless_zero *with return value check* locking in the kref_put path "
"can be deferred to the actual removal from the lookup structure and RCU "
"lookups become trivial."
msgstr ""

#: ../../../core-api/kref:328: include/linux/kref.h:127
msgid "non-zero if the increment succeeded. Otherwise return 0."
msgstr ""
