# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../dev-tools/kcov.rst:2
msgid "KCOV: code coverage for fuzzing"
msgstr ""

#: ../../../dev-tools/kcov.rst:4
msgid ""
"KCOV collects and exposes kernel code coverage information in a form "
"suitable for coverage-guided fuzzing. Coverage data of a running kernel is "
"exported via the ``kcov`` debugfs file. Coverage collection is enabled on a "
"task basis, and thus KCOV can capture precise coverage of a single system "
"call."
msgstr ""

#: ../../../dev-tools/kcov.rst:9
msgid ""
"Note that KCOV does not aim to collect as much coverage as possible. It aims "
"to collect more or less stable coverage that is a function of syscall "
"inputs. To achieve this goal, it does not collect coverage in soft/hard "
"interrupts (unless remove coverage collection is enabled, see below) and "
"from some inherently non-deterministic parts of the kernel (e.g. scheduler, "
"locking)."
msgstr ""

#: ../../../dev-tools/kcov.rst:15
msgid ""
"Besides collecting code coverage, KCOV can also collect comparison operands. "
"See the \"Comparison operands collection\" section for details."
msgstr ""

#: ../../../dev-tools/kcov.rst:18
msgid ""
"Besides collecting coverage data from syscall handlers, KCOV can also "
"collect coverage for annotated parts of the kernel executing in background "
"kernel tasks or soft interrupts. See the \"Remote coverage collection\" "
"section for details."
msgstr ""

#: ../../../dev-tools/kcov.rst:24
msgid "Prerequisites"
msgstr ""

#: ../../../dev-tools/kcov.rst:26
msgid ""
"KCOV relies on compiler instrumentation and requires GCC 6.1.0 or later or "
"any Clang version supported by the kernel."
msgstr ""

#: ../../../dev-tools/kcov.rst:29
msgid "Collecting comparison operands is supported with GCC 8+ or with Clang."
msgstr ""

#: ../../../dev-tools/kcov.rst:31
msgid "To enable KCOV, configure the kernel with::"
msgstr ""

#: ../../../dev-tools/kcov.rst:35
msgid "To enable comparison operands collection, set::"
msgstr ""

#: ../../../dev-tools/kcov.rst:39
msgid "Coverage data only becomes accessible once debugfs has been mounted::"
msgstr ""

#: ../../../dev-tools/kcov.rst:44
msgid "Coverage collection"
msgstr ""

#: ../../../dev-tools/kcov.rst:46
msgid ""
"The following program demonstrates how to use KCOV to collect coverage for a "
"single syscall from within a test program:"
msgstr ""

#: ../../../dev-tools/kcov.rst:114
msgid ""
"After piping through ``addr2line`` the output of the program looks as "
"follows::"
msgstr ""

#: ../../../dev-tools/kcov.rst:131
msgid ""
"If a program needs to collect coverage from several threads (independently), "
"it needs to open ``/sys/kernel/debug/kcov`` in each thread separately."
msgstr ""

#: ../../../dev-tools/kcov.rst:134
msgid ""
"The interface is fine-grained to allow efficient forking of test processes. "
"That is, a parent process opens ``/sys/kernel/debug/kcov``, enables trace "
"mode, mmaps coverage buffer, and then forks child processes in a loop. The "
"child processes only need to enable coverage (it gets disabled automatically "
"when a thread exits)."
msgstr ""

#: ../../../dev-tools/kcov.rst:141
msgid "Comparison operands collection"
msgstr ""

#: ../../../dev-tools/kcov.rst:143
msgid "Comparison operands collection is similar to coverage collection:"
msgstr ""

#: ../../../dev-tools/kcov.rst:217
msgid ""
"Note that the KCOV modes (collection of code coverage or comparison "
"operands) are mutually exclusive."
msgstr ""

#: ../../../dev-tools/kcov.rst:221
msgid "Remote coverage collection"
msgstr ""

#: ../../../dev-tools/kcov.rst:223
msgid ""
"Besides collecting coverage data from handlers of syscalls issued from a "
"userspace process, KCOV can also collect coverage for parts of the kernel "
"executing in other contexts - so-called \"remote\" coverage."
msgstr ""

#: ../../../dev-tools/kcov.rst:227
msgid "Using KCOV to collect remote coverage requires:"
msgstr ""

#: ../../../dev-tools/kcov.rst:229
msgid ""
"Modifying kernel code to annotate the code section from where coverage "
"should be collected with ``kcov_remote_start`` and ``kcov_remote_stop``."
msgstr ""

#: ../../../dev-tools/kcov.rst:232
msgid ""
"Using ``KCOV_REMOTE_ENABLE`` instead of ``KCOV_ENABLE`` in the userspace "
"process that collects coverage."
msgstr ""

#: ../../../dev-tools/kcov.rst:235
msgid ""
"Both ``kcov_remote_start`` and ``kcov_remote_stop`` annotations and the "
"``KCOV_REMOTE_ENABLE`` ioctl accept handles that identify particular "
"coverage collection sections. The way a handle is used depends on the "
"context where the matching code section executes."
msgstr ""

#: ../../../dev-tools/kcov.rst:240
msgid "KCOV supports collecting remote coverage from the following contexts:"
msgstr ""

#: ../../../dev-tools/kcov.rst:242
msgid ""
"Global kernel background tasks. These are the tasks that are spawned during "
"kernel boot in a limited number of instances (e.g. one USB ``hub_event`` "
"worker is spawned per one USB HCD)."
msgstr ""

#: ../../../dev-tools/kcov.rst:246
msgid ""
"Local kernel background tasks. These are spawned when a userspace process "
"interacts with some kernel interface and are usually killed when the process "
"exits (e.g. vhost workers)."
msgstr ""

#: ../../../dev-tools/kcov.rst:250
msgid "Soft interrupts."
msgstr ""

#: ../../../dev-tools/kcov.rst:252
msgid ""
"For #1 and #3, a unique global handle must be chosen and passed to the "
"corresponding ``kcov_remote_start`` call. Then a userspace process must pass "
"this handle to ``KCOV_REMOTE_ENABLE`` in the ``handles`` array field of the "
"``kcov_remote_arg`` struct. This will attach the used KCOV device to the "
"code section referenced by this handle. Multiple global handles identifying "
"different code sections can be passed at once."
msgstr ""

#: ../../../dev-tools/kcov.rst:259
msgid ""
"For #2, the userspace process instead must pass a non-zero handle through "
"the ``common_handle`` field of the ``kcov_remote_arg`` struct. This common "
"handle gets saved to the ``kcov_handle`` field in the current "
"``task_struct`` and needs to be passed to the newly spawned local tasks via "
"custom kernel code modifications. Those tasks should in turn use the passed "
"handle in their ``kcov_remote_start`` and ``kcov_remote_stop`` annotations."
msgstr ""

#: ../../../dev-tools/kcov.rst:266
msgid ""
"KCOV follows a predefined format for both global and common handles. Each "
"handle is a ``u64`` integer. Currently, only the one top and the lower 4 "
"bytes are used. Bytes 4-7 are reserved and must be zero."
msgstr ""

#: ../../../dev-tools/kcov.rst:270
msgid ""
"For global handles, the top byte of the handle denotes the id of a subsystem "
"this handle belongs to. For example, KCOV uses ``1`` as the USB subsystem "
"id. The lower 4 bytes of a global handle denote the id of a task instance "
"within that subsystem. For example, each ``hub_event`` worker uses the USB "
"bus number as the task instance id."
msgstr ""

#: ../../../dev-tools/kcov.rst:276
msgid ""
"For common handles, a reserved value ``0`` is used as a subsystem id, as "
"such handles don't belong to a particular subsystem. The lower 4 bytes of a "
"common handle identify a collective instance of all local tasks spawned by "
"the userspace process that passed a common handle to ``KCOV_REMOTE_ENABLE``."
msgstr ""

#: ../../../dev-tools/kcov.rst:281
msgid ""
"In practice, any value can be used for common handle instance id if coverage "
"is only collected from a single userspace process on the system. However, if "
"common handles are used by multiple processes, unique instance ids must be "
"used for each process. One option is to use the process id as the common "
"handle instance id."
msgstr ""

#: ../../../dev-tools/kcov.rst:287
msgid ""
"The following program demonstrates using KCOV to collect coverage from both "
"local tasks spawned by the process and the global task that handles USB bus "
"#1:"
msgstr ""
