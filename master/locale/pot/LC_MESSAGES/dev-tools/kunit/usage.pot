# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-06 15:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../dev-tools/kunit/usage.rst:4
msgid "Writing Tests"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:7
msgid "Test Cases"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:9
msgid ""
"The fundamental unit in KUnit is the test case. A test case is a function "
"with the signature ``void (*)(struct kunit *test)``. It calls the function "
"under test and then sets *expectations* for what should happen. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:24
msgid ""
"In the above example, ``example_test_success`` always passes because it does "
"nothing; no expectations are set, and therefore all expectations pass. On "
"the other hand ``example_test_failure`` always fails because it calls "
"``KUNIT_FAIL``, which is a special expectation that logs a message and "
"causes the test case to fail."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:31
msgid "Expectations"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:32
msgid ""
"An *expectation* specifies that we expect a piece of code to do something in "
"a test. An expectation is called like a function. A test is made by setting "
"expectations about the behavior of a piece of code under test. When one or "
"more expectations fail, the test case fails and information about the "
"failure is logged. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:46
msgid ""
"In the above example, ``add_test_basic`` makes a number of assertions about "
"the behavior of a function called ``add``. The first parameter is always of "
"type ``struct kunit *``, which contains information about the current test "
"context. The second parameter, in this case, is what the value is expected "
"to be. The last value is what the value actually is. If ``add`` passes all "
"of these expectations, the test case, ``add_test_basic`` will pass; if any "
"one of these expectations fails, the test case will fail."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:54
msgid ""
"A test case *fails* when any expectation is violated; however, the test will "
"continue to run, and try other expectations until the test case ends or is "
"otherwise terminated. This is as opposed to *assertions* which are discussed "
"later."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:59
msgid ""
"To learn about more KUnit expectations, see Documentation/dev-tools/kunit/"
"api/test.rst."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:62
msgid ""
"A single test case should be short, easy to understand, and focused on a "
"single behavior."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:65
msgid ""
"For example, if we want to rigorously test the ``add`` function above, "
"create additional tests cases which would test each property that an ``add`` "
"function should have as shown below:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:94
msgid "Assertions"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:96
msgid ""
"An assertion is like an expectation, except that the assertion immediately "
"terminates the test case if the condition is not satisfied. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:115
msgid ""
"In this example, we need to be able to allocate an array to test the "
"``sort()`` function. So we use ``KUNIT_ASSERT_NOT_ERR_OR_NULL()`` to abort "
"the test if there's an allocation error."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:120
msgid ""
"In other test frameworks, ``ASSERT`` macros are often implemented by calling "
"``return`` so they only work from the test function. In KUnit, we stop the "
"current kthread on failure, so you can call them from anywhere."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:125
msgid ""
"Warning: There is an exception to the above rule. You shouldn't use "
"assertions in the suite's exit() function, or in the free function for a "
"resource. These run when a test is shutting down, and an assertion here "
"prevents further cleanup code from running, potentially leading to a memory "
"leak."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:131
msgid "Customizing error messages"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:133
msgid ""
"Each of the ``KUNIT_EXPECT`` and ``KUNIT_ASSERT`` macros have a ``_MSG`` "
"variant.  These take a format string and arguments to provide additional "
"context to the automatically generated error messages."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:148
msgid ""
"Alternatively, one can take full control over the error message by using "
"``KUNIT_FAIL()``, e.g."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:162
msgid "Test Suites"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:164
msgid ""
"We need many test cases covering all the unit's behaviors. It is common to "
"have many similar tests. In order to reduce duplication in these closely "
"related tests, most unit testing frameworks (including KUnit) provide the "
"concept of a *test suite*. A test suite is a collection of test cases for a "
"unit of code with optional setup and teardown functions that run before/"
"after the whole suite and/or every test case."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:172
msgid "A test case will only run if it is associated with a test suite."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:174
#: ../../../dev-tools/kunit/usage.rst:961
#: ../../../dev-tools/kunit/usage.rst:1195
msgid "For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:195
msgid ""
"In the above example, the test suite ``example_test_suite`` would first run "
"``example_suite_init``, then run the test cases ``example_test_foo``, "
"``example_test_bar``, and ``example_test_baz``. Each would have "
"``example_test_init`` called immediately before it and ``example_test_exit`` "
"called immediately after it. Finally, ``example_suite_exit`` would be called "
"after everything else. ``kunit_test_suite(example_test_suite)`` registers "
"the test suite with the KUnit test framework."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:204
msgid ""
"The ``exit`` and ``suite_exit`` functions will run even if ``init`` or "
"``suite_init`` fail. Make sure that they can handle any inconsistent state "
"which may result from ``init`` or ``suite_init`` encountering errors or "
"exiting early."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:209
msgid ""
"``kunit_test_suite(...)`` is a macro which tells the linker to put the "
"specified test suite in a special linker section so that it can be run by "
"KUnit either after ``late_init``, or when the test module is loaded (if the "
"test was built as a module)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:214
msgid "For more information, see Documentation/dev-tools/kunit/api/test.rst."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:219
msgid "Writing Tests For Other Architectures"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:221
msgid ""
"It is better to write tests that run on UML to tests that only run under a "
"particular architecture. It is better to write tests that run under QEMU or "
"another easy to obtain (and monetarily free) software environment to a "
"specific piece of hardware."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:226
msgid ""
"Nevertheless, there are still valid reasons to write a test that is "
"architecture or hardware specific. For example, we might want to test code "
"that really belongs in ``arch/some-arch/*``. Even so, try to write the test "
"so that it does not depend on physical hardware. Some of our test cases may "
"not need hardware, only few tests actually require the hardware to test it. "
"When hardware is not available, instead of disabling tests, we can skip them."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:233
msgid ""
"Now that we have narrowed down exactly what bits are hardware specific, the "
"actual procedure for writing and running the tests is same as writing normal "
"KUnit tests."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:238
msgid ""
"We may have to reset hardware state. If this is not possible, we may only be "
"able to run one test case per invocation."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:245
msgid "Common Patterns"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:248
msgid "Isolating Behavior"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:250
msgid ""
"Unit testing limits the amount of code under test to a single unit. It "
"controls what code gets run when the unit under test calls a function. Where "
"a function is exposed as part of an API such that the definition of that "
"function can be changed without affecting the rest of the code base. In the "
"kernel, this comes from two constructs: classes, which are structs that "
"contain function pointers provided by the implementer, and architecture-"
"specific functions, which have definitions selected at compile time."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:259
msgid "Classes"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:261
msgid ""
"Classes are not a construct that is built into the C programming language; "
"however, it is an easily derived concept. Accordingly, in most cases, every "
"project that does not use a standardized object oriented library (like "
"GNOME's GObject) has their own slightly different way of doing object "
"oriented programming; the Linux kernel is no exception."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:267
msgid ""
"The central concept in kernel object oriented programming is the class. In "
"the kernel, a *class* is a struct that contains function pointers. This "
"creates a contract between *implementers* and *users* since it forces them "
"to use the same function signature without having to call the function "
"directly. To be a class, the function pointers must specify that a pointer "
"to the class, known as a *class handle*, be one of the parameters. Thus the "
"member functions (also known as *methods*) have access to member variables "
"(also known as *fields*) allowing the same implementation to have multiple "
"*instances*."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:276
msgid ""
"A class can be *overridden* by *child classes* by embedding the *parent "
"class* in the child class. Then when the child class *method* is called, the "
"child implementation knows that the pointer passed to it is of a parent "
"contained within the child. Thus, the child can compute the pointer to "
"itself because the pointer to the parent is always a fixed offset from the "
"pointer to the child. This offset is the offset of the parent contained in "
"the child struct. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:310
msgid ""
"In this example, computing the pointer to the child from the pointer to the "
"parent is done by ``container_of``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:314
msgid "Faking Classes"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:316
msgid ""
"In order to unit test a piece of code that calls a method in a class, the "
"behavior of the method must be controllable, otherwise the test ceases to be "
"a unit test and becomes an integration test."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:320
msgid ""
"A fake class implements a piece of code that is different than what runs in "
"a production instance, but behaves identical from the standpoint of the "
"callers. This is done to replace a dependency that is hard to deal with, or "
"is slow. For example, implementing a fake EEPROM that stores the "
"\"contents\" in an internal buffer. Assume we have a class that represents "
"an EEPROM:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:333
msgid "And we want to test code that buffers writes to the EEPROM:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:346
msgid "We can test this code by *faking out* the underlying EEPROM:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:382
msgid "We can now use it to test ``struct eeprom_buffer``:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:474
msgid "Testing Against Multiple Inputs"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:476
msgid ""
"Testing just a few inputs is not enough to ensure that the code works "
"correctly, for example: testing a hash function."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:479
msgid ""
"We can write a helper macro or function. The function is called for each "
"input. For example, to test ``sha1sum(1)``, we can write:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:492
msgid ""
"Note the use of the ``_MSG`` version of ``KUNIT_EXPECT_STREQ`` to print a "
"more detailed error and make the assertions clearer within the helper macros."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:495
msgid ""
"The ``_MSG`` variants are useful when the same expectation is called "
"multiple times (in a loop or helper function) and thus the line number is "
"not enough to identify what failed, as shown below."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:499
msgid ""
"In complicated cases, we recommend using a *table-driven test* compared to "
"the helper macro variation, for example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:529
msgid "There is more boilerplate code involved, but it can:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:531
msgid ""
"be more readable when there are multiple inputs/outputs (due to field names)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:533
msgid "For example, see ``fs/ext4/inode-test.c``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:535
msgid "reduce duplication if test cases are shared across multiple tests."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:537
msgid ""
"For example: if we want to test ``sha256sum``, we could add a ``sha256`` "
"field and reuse ``cases``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:540
msgid "be converted to a \"parameterized test\"."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:543
msgid "Parameterized Testing"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:545
msgid ""
"To run a test case against multiple inputs, KUnit provides a parameterized "
"testing framework. This feature formalizes and extends the concept of table-"
"driven tests discussed previously."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:549
msgid ""
"A KUnit test is determined to be parameterized if a parameter generator "
"function is provided when registering the test case. A test user can either "
"write their own generator function or use one that is provided by KUnit. The "
"generator function is stored in  ``kunit_case->generate_params`` and can be "
"set using the macros described in the section below."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:555
msgid ""
"To establish the terminology, a \"parameterized test\" is a test which is "
"run multiple times (once per \"parameter\" or \"parameter run\"). Each "
"parameter run has both its own independent ``struct kunit`` (the \"parameter "
"run context\") and access to a shared parent ``struct kunit`` (the "
"\"parameterized test context\")."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:561
msgid "Passing Parameters to a Test"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:562
msgid "There are three ways to provide the parameters to a test:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:564
msgid "Array Parameter Macros:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:566
msgid ""
"KUnit provides special support for the common table-driven testing pattern. "
"By applying either ``KUNIT_ARRAY_PARAM`` or ``KUNIT_ARRAY_PARAM_DESC`` to "
"the ``cases`` array from the previous section, we can create a parameterized "
"test as shown below:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:613
msgid "Custom Parameter Generator Function:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:615
msgid ""
"The generator function is responsible for generating parameters one-by-one "
"and has the following signature: ``const void* (*)(struct kunit *test, const "
"void *prev, char *desc)``. You can pass the generator function to the "
"``KUNIT_CASE_PARAM`` or ``KUNIT_CASE_PARAM_WITH_INIT`` macros."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:621
msgid ""
"The function receives the previously generated parameter as the ``prev`` "
"argument (which is ``NULL`` on the first call) and can also access the "
"parameterized test context passed as the ``test`` argument. KUnit calls this "
"function repeatedly until it returns ``NULL``, which signifies that a "
"parameterized test ended."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:627
msgid "Below is an example of how it works:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:673
msgid "Runtime Parameter Array Registration in the Init Function:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:675
msgid ""
"For scenarios where you might need to initialize a parameterized test, you "
"can directly register a parameter array to the parameterized test context."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:678
msgid ""
"To do this, you must pass the parameterized test context, the array itself, "
"the array size, and a ``get_description()`` function to the "
"``kunit_register_params_array()`` macro. This macro populates ``struct "
"kunit_params`` within the parameterized test context, effectively storing a "
"parameter array object. The ``get_description()`` function will be used for "
"populating parameter descriptions and has the following signature: ``void (*)"
"(struct kunit *test, const void *param, char *desc)``. Note that it also has "
"access to the parameterized test context."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:688
msgid ""
"When using this way to register a parameter array, you will need to manually "
"pass ``kunit_array_gen_params()`` as the generator function to "
"``KUNIT_CASE_PARAM_WITH_INIT``. ``kunit_array_gen_params()`` is a KUnit "
"helper that will use the registered array to generate the parameters."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:693
msgid ""
"If needed, instead of passing the KUnit helper, you can also pass your own "
"custom generator function that utilizes the parameter array. To access the "
"parameter array from within the parameter generator function use ``test-"
">params_array.params``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:698
msgid ""
"The ``kunit_register_params_array()`` macro should be called within a "
"``param_init()`` function that initializes the parameterized test and has "
"the following signature ``int (*)(struct kunit *test)``. For a detailed "
"explanation of this mechanism please refer to the \"Adding Shared "
"Resources\" section that is after this one. This method supports registering "
"both dynamically built and static parameter arrays."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:705
msgid ""
"The code snippet below shows the ``example_param_init_dynamic_arr`` test "
"that utilizes ``make_fibonacci_params()`` to create a dynamic array, which "
"is then registered using ``kunit_register_params_array()``. To see the full "
"code please refer to lib/kunit/kunit-example-test.c."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:752
msgid "Adding Shared Resources"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:753
msgid ""
"All parameter runs in this framework hold a reference to the parameterized "
"test context, which can be accessed using the parent ``struct kunit`` "
"pointer. The parameterized test context is not used to execute any test "
"logic itself; instead, it serves as a container for shared resources."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:758
msgid ""
"It's possible to add resources to share between parameter runs within a "
"parameterized test by using ``KUNIT_CASE_PARAM_WITH_INIT``, to which you "
"pass custom ``param_init()`` and ``param_exit()`` functions. These functions "
"run once before and once after the parameterized test, respectively."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:763
msgid ""
"The ``param_init()`` function, with the signature ``int (*)(struct kunit "
"*test)``, can be used for adding resources to the ``resources`` or ``priv`` "
"fields of the parameterized test context, registering the parameter array, "
"and any other initialization logic."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:768
msgid ""
"The ``param_exit()`` function, with the signature ``void (*)(struct kunit "
"*test)``, can be used to release any resources that were not parameterized "
"test managed (i.e. not automatically cleaned up after the parameterized test "
"ends) and for any other exit logic."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:773
msgid ""
"Both ``param_init()`` and ``param_exit()`` are passed the parameterized test "
"context behind the scenes. However, the test case function receives the "
"parameter run context. Therefore, to manage and access shared resources from "
"within a test case function, you must use ``test->parent``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:778
msgid ""
"For instance, finding a shared resource allocated by the Resource API "
"requires passing ``test->parent`` to ``kunit_find_resource()``. This "
"principle extends to all other APIs that might be used in the test case "
"function, including ``kunit_kzalloc()``, ``kunit_kmalloc_array()``, and "
"others (see Documentation/dev-tools/kunit/api/test.rst and the Documentation/"
"dev-tools/kunit/api/resource.rst)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:786
msgid ""
"The ``suite->init()`` function, which executes before each parameter run, "
"receives the parameter run context. Therefore, any resources set up in "
"``suite->init()`` are cleaned up after each parameter run."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:790
msgid ""
"The code below shows how you can add the shared resources. Note that this "
"code utilizes the Resource API, which you can read more about here: "
"Documentation/dev-tools/kunit/api/resource.rst. To see the full version of "
"this code please refer to lib/kunit/kunit-example-test.c."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:850
msgid ""
"As an alternative to using the KUnit Resource API for sharing resources, you "
"can place them in ``test->parent->priv``. This serves as a more lightweight "
"method for resource storage, best for scenarios where complex resource "
"management is not required."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:855
msgid ""
"As stated previously ``param_init()`` and ``param_exit()`` get the "
"parameterized test context. So, you can directly use ``test->priv`` within "
"``param_init/exit`` to manage shared resources. However, from within the "
"test case function, you must navigate up to the parent ``struct kunit`` i.e. "
"the parameterized test context. Therefore, you need to use ``test->parent-"
">priv`` to access those same resources."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:862
msgid ""
"The resources placed in ``test->parent->priv`` will need to be allocated in "
"memory to persist across the parameter runs. If memory is allocated using "
"the KUnit memory allocation APIs (described more in the \"Allocating "
"Memory\" section below), you won't need to worry about deallocation. The "
"APIs will make the memory parameterized test 'managed', ensuring that it "
"will automatically get cleaned up after the parameterized test concludes."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:869
msgid ""
"The code below demonstrates example usage of the ``priv`` field for shared "
"resources:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:926
msgid "Allocating Memory"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:928
msgid ""
"Where you might use ``kzalloc``, you can instead use ``kunit_kzalloc`` as "
"KUnit will then ensure that the memory is freed once the test completes."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:931
msgid ""
"This is useful because it lets us use the ``KUNIT_ASSERT_EQ`` macros to exit "
"early from a test without having to worry about remembering to call "
"``kfree``. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:947
msgid "Registering Cleanup Actions"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:949
msgid ""
"If you need to perform some cleanup beyond simple use of ``kunit_kzalloc``, "
"you can register a custom \"deferred action\", which is a cleanup function "
"run when the test exits (whether cleanly, or via a failed assertion)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:953
msgid ""
"Actions are simple functions with no return value, and a single ``void*`` "
"context argument, and fulfill the same role as \"cleanup\" functions in "
"Python and Go tests, \"defer\" statements in languages which support them, "
"and (in some cases) destructors in RAII languages."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:958
msgid ""
"These are very useful for unregistering things from global lists, closing "
"files or other resources, or freeing resources."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:981
msgid ""
"Note that, for functions like device_unregister which only accept a single "
"pointer-sized argument, it's possible to automatically generate a wrapper "
"with the ``KUNIT_DEFINE_ACTION_WRAPPER()`` macro, for example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:990
msgid ""
"You should do this in preference to manually casting to the "
"``kunit_action_t`` type, as casting function pointers will break Control "
"Flow Integrity (CFI)."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:993
msgid ""
"``kunit_add_action`` can fail if, for example, the system is out of memory. "
"You can use ``kunit_add_action_or_reset`` instead which runs the action "
"immediately if it cannot be deferred."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:997
msgid ""
"If you need more control over when the cleanup function is called, you can "
"trigger it early using ``kunit_release_action``, or cancel it entirely with "
"``kunit_remove_action``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1003
msgid "Testing Static Functions"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1005
msgid ""
"If you want to test static functions without exposing those functions "
"outside of testing, one option is conditionally export the symbol. When "
"KUnit is enabled, the symbol is exposed but remains static otherwise. To use "
"this method, follow the template below."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1038
msgid ""
"For a full example, see this `patch <https://lore.kernel.org/"
"all/20221207014024.340230-3-rmoar@google.com/>`_ where a test is modified to "
"conditionally expose static functions for testing using the macros above."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1042
msgid ""
"As an **alternative** to the method above, you could conditionally "
"``#include`` the test file at the end of your .c file. This is not "
"recommended but works if needed. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1057
msgid "Injecting Test-Only Code"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1059
msgid "Similar to as shown above, we can add test-specific logic. For example:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1072
msgid ""
"This test-only code can be made more useful by accessing the current "
"``kunit_test`` as shown in next section: *Accessing The Current Test*."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1076
msgid "Accessing The Current Test"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1078
msgid ""
"In some cases, we need to call test-only code from outside the test file.  "
"This is helpful, for example, when providing a fake implementation of a "
"function, or to fail any current test from within an error handler. We can "
"do this via the ``kunit_test`` field in ``task_struct``, which we can access "
"using the ``kunit_get_current_test()`` function in ``kunit/test-bug.h``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1084
msgid ""
"``kunit_get_current_test()`` is safe to call even if KUnit is not enabled. "
"If KUnit is not enabled, or if no test is running in the current task, it "
"will return ``NULL``. This compiles down to either a no-op or a static key "
"check, so will have a negligible performance impact when no test is running."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1089
msgid ""
"The example below uses this to implement a \"mock\" implementation of a "
"function, ``foo``:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1123
msgid ""
"In this example, we are using the ``priv`` member of ``struct kunit`` as a "
"way of passing data to the test from the init function. In general ``priv`` "
"is pointer that can be used for any user data. This is preferred over static "
"variables, as it avoids concurrency issues."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1128
msgid ""
"Had we wanted something more flexible, we could have used a named "
"``kunit_resource``. Each test can have multiple resources which have string "
"names providing the same flexibility as a ``priv`` member, but also, for "
"example, allowing helper functions to create resources without conflicting "
"with each other. It is also possible to define a clean up function for each "
"resource, making it easy to avoid resource leaks. For more information, see "
"Documentation/dev-tools/kunit/api/resource.rst."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1136
msgid "Failing The Current Test"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1138
msgid ""
"If we want to fail the current test, we can use "
"``kunit_fail_current_test(fmt, args...)`` which is defined in ``<kunit/test-"
"bug.h>`` and does not require pulling in ``<kunit/test.h>``. For example, we "
"have an option to enable some extra debug checks on some data structures as "
"shown below:"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1161
msgid ""
"``kunit_fail_current_test()`` is safe to call even if KUnit is not enabled. "
"If KUnit is not enabled, or if no test is running in the current task, it "
"will do nothing. This compiles down to either a no-op or a static key check, "
"so will have a negligible performance impact when no test is running."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1167
msgid "Managing Fake Devices and Drivers"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1169
msgid ""
"When testing drivers or code which interacts with drivers, many functions "
"will require a ``struct device`` or ``struct device_driver``. In many cases, "
"setting up a real device is not required to test any given function, so a "
"fake device can be used instead."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1174
msgid ""
"KUnit provides helper functions to create and manage these fake devices, "
"which are internally of type ``struct kunit_device``, and are attached to a "
"special ``kunit_bus``. These devices support managed device resources "
"(devres), as described in Documentation/driver-api/driver-model/devres.rst"
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1179
msgid ""
"To create a KUnit-managed ``struct device_driver``, use "
"``kunit_driver_create()``, which will create a driver with the given name, "
"on the ``kunit_bus``. This driver will automatically be destroyed when the "
"corresponding test finishes, but can also be manually destroyed with "
"``driver_unregister()``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1184
msgid ""
"To create a fake device, use the ``kunit_device_register()``, which will "
"create and register a device, using a new KUnit-managed driver created with "
"``kunit_driver_create()``. To provide a specific, non-KUnit-managed driver, "
"use ``kunit_device_register_with_driver()`` instead. Like with managed "
"drivers, KUnit-managed fake devices are automatically cleaned up when the "
"test finishes, but can be manually cleaned up early with "
"``kunit_device_unregister()``."
msgstr ""

#: ../../../dev-tools/kunit/usage.rst:1191
msgid ""
"The KUnit devices should be used in preference to "
"``root_device_register()``, and instead of ``platform_device_register()`` in "
"cases where the device is not otherwise a platform device."
msgstr ""
