# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../staging/remoteproc.rst:3
msgid "Remote Processor Framework"
msgstr ""

#: ../../../staging/remoteproc.rst:6
msgid "Introduction"
msgstr ""

#: ../../../staging/remoteproc.rst:8
msgid ""
"Modern SoCs typically have heterogeneous remote processor devices in "
"asymmetric multiprocessing (AMP) configurations, which may be running "
"different instances of operating system, whether it's Linux or any other "
"flavor of real-time OS."
msgstr ""

#: ../../../staging/remoteproc.rst:12
msgid ""
"OMAP4, for example, has dual Cortex-A9, dual Cortex-M3 and a C64x+ DSP. In a "
"typical configuration, the dual cortex-A9 is running Linux in a SMP "
"configuration, and each of the other three cores (two M3 cores and a DSP) is "
"running its own instance of RTOS in an AMP configuration."
msgstr ""

#: ../../../staging/remoteproc.rst:17
msgid ""
"The remoteproc framework allows different platforms/architectures to control "
"(power on, load firmware, power off) those remote processors while "
"abstracting the hardware differences, so the entire driver doesn't need to "
"be duplicated. In addition, this framework also adds rpmsg virtio devices "
"for remote processors that supports this kind of communication. This way, "
"platform-specific remoteproc drivers only need to provide a few low-level "
"handlers, and then all rpmsg drivers will then just work (for more "
"information about the virtio-based rpmsg bus and its drivers, please read "
"Documentation/staging/rpmsg.rst). Registration of other types of virtio "
"devices is now also possible. Firmwares just need to publish what kind of "
"virtio devices do they support, and then remoteproc will add those devices. "
"This makes it possible to reuse the existing virtio drivers with remote "
"processor backends at a minimal development cost."
msgstr ""

#: ../../../staging/remoteproc.rst:33
msgid "User API"
msgstr ""

#: ../../../staging/remoteproc.rst:39
msgid "Boot a remote processor (i.e. load its firmware, power it on, ...)."
msgstr ""

#: ../../../staging/remoteproc.rst:41
msgid ""
"If the remote processor is already powered on, this function immediately "
"returns (successfully)."
msgstr ""

#: ../../../staging/remoteproc.rst:44
msgid ""
"Returns 0 on success, and an appropriate error value otherwise. Note: to use "
"this function you should already have a valid rproc handle. There are "
"several ways to achieve that cleanly (devres, pdata, the way "
"remoteproc_rpmsg.c does this, or, if this becomes prevalent, we might also "
"consider using dev_archdata for this)."
msgstr ""

#: ../../../staging/remoteproc.rst:54
msgid ""
"Power off a remote processor (previously booted with rproc_boot()). In case "
"@rproc is still being used by an additional user(s), then this function will "
"just decrement the power refcount and exit, without really powering off the "
"device."
msgstr ""

#: ../../../staging/remoteproc.rst:59
msgid ""
"Returns 0 on success, and an appropriate error value otherwise. Every call "
"to rproc_boot() must (eventually) be accompanied by a call to "
"rproc_shutdown(). Calling rproc_shutdown() redundantly is a bug."
msgstr ""

#: ../../../staging/remoteproc.rst:65
msgid ""
"we're not decrementing the rproc's refcount, only the power refcount. which "
"means that the @rproc handle stays valid even after rproc_shutdown() "
"returns, and users can still use it with a subsequent rproc_boot(), if "
"needed."
msgstr ""

#: ../../../staging/remoteproc.rst:74
msgid ""
"Find an rproc handle using a device tree phandle. Returns the rproc handle "
"on success, and NULL on failure. This function increments the remote "
"processor's refcount, so always use rproc_put() to decrement it back once "
"rproc isn't needed anymore."
msgstr ""

#: ../../../staging/remoteproc.rst:80
msgid "Typical usage"
msgstr ""

#: ../../../staging/remoteproc.rst:108
msgid "API for implementors"
msgstr ""

#: ../../../staging/remoteproc.rst:116
msgid ""
"Allocate a new remote processor handle, but don't register it yet. Required "
"parameters are the underlying device, the name of this remote processor, "
"platform-specific ops handlers, the name of the firmware to boot this rproc "
"with, and the length of private data needed by the allocating rproc driver "
"(in bytes)."
msgstr ""

#: ../../../staging/remoteproc.rst:122
msgid ""
"This function should be used by rproc implementations during initialization "
"of the remote processor."
msgstr ""

#: ../../../staging/remoteproc.rst:125
msgid ""
"After creating an rproc handle using this function, and when ready, "
"implementations should then call rproc_add() to complete the registration of "
"the remote processor."
msgstr ""

#: ../../../staging/remoteproc.rst:129
msgid "On success, the new rproc is returned, and on failure, NULL."
msgstr ""

#: ../../../staging/remoteproc.rst:133
msgid ""
"**never** directly deallocate @rproc, even if it was not registered yet. "
"Instead, when you need to unroll rproc_alloc(), use rproc_free()."
msgstr ""

#: ../../../staging/remoteproc.rst:140
msgid "Free an rproc handle that was allocated by rproc_alloc."
msgstr ""

#: ../../../staging/remoteproc.rst:142
msgid ""
"This function essentially unrolls rproc_alloc(), by decrementing the rproc's "
"refcount. It doesn't directly free rproc; that would happen only if there "
"are no other references to rproc and its refcount now dropped to zero."
msgstr ""

#: ../../../staging/remoteproc.rst:151
msgid ""
"Register @rproc with the remoteproc framework, after it has been allocated "
"with rproc_alloc()."
msgstr ""

#: ../../../staging/remoteproc.rst:154
msgid ""
"This is called by the platform-specific rproc implementation, whenever a new "
"remote processor device is probed."
msgstr ""

#: ../../../staging/remoteproc.rst:157
msgid ""
"Returns 0 on success and an appropriate error code otherwise. Note: this "
"function initiates an asynchronous firmware loading context, which will look "
"for virtio devices supported by the rproc's firmware."
msgstr ""

#: ../../../staging/remoteproc.rst:162
msgid ""
"If found, those virtio devices will be created and added, so as a result of "
"registering this remote processor, additional virtio drivers might get "
"probed."
msgstr ""

#: ../../../staging/remoteproc.rst:170
msgid "Unroll rproc_add()."
msgstr ""

#: ../../../staging/remoteproc.rst:172
msgid ""
"This function should be called when the platform specific rproc "
"implementation decides to remove the rproc device. it should _only_ be "
"called if a previous invocation of rproc_add() has completed successfully."
msgstr ""

#: ../../../staging/remoteproc.rst:177
msgid ""
"After rproc_del() returns, @rproc is still valid, and its last refcount "
"should be decremented by calling rproc_free()."
msgstr ""

#: ../../../staging/remoteproc.rst:180
msgid "Returns 0 on success and -EINVAL if @rproc isn't valid."
msgstr ""

#: ../../../staging/remoteproc.rst:186
msgid "Report a crash in a remoteproc"
msgstr ""

#: ../../../staging/remoteproc.rst:188
msgid ""
"This function must be called every time a crash is detected by the platform "
"specific rproc implementation. This should not be called from a non-"
"remoteproc driver. This function can be called from atomic/interrupt context."
msgstr ""

#: ../../../staging/remoteproc.rst:194
msgid "Implementation callbacks"
msgstr ""

#: ../../../staging/remoteproc.rst:196
msgid ""
"These callbacks should be provided by platform-specific remoteproc drivers::"
msgstr ""

#: ../../../staging/remoteproc.rst:211
msgid ""
"Every remoteproc implementation should at least provide the ->start and -"
">stop handlers. If rpmsg/virtio functionality is also desired, then the -"
">kick handler should be provided as well."
msgstr ""

#: ../../../staging/remoteproc.rst:215
msgid ""
"The ->start() handler takes an rproc handle and should then power on the "
"device and boot it (use rproc->priv to access platform-specific private "
"data). The boot address, in case needed, can be found in rproc->bootaddr "
"(remoteproc core puts there the ELF entry point). On success, 0 should be "
"returned, and on failure, an appropriate error code."
msgstr ""

#: ../../../staging/remoteproc.rst:221
msgid ""
"The ->stop() handler takes an rproc handle and powers the device down. On "
"success, 0 is returned, and on failure, an appropriate error code."
msgstr ""

#: ../../../staging/remoteproc.rst:224
msgid ""
"The ->kick() handler takes an rproc handle, and an index of a virtqueue "
"where new message was placed in. Implementations should interrupt the remote "
"processor and let it know it has pending messages. Notifying remote "
"processors the exact virtqueue index to look in is optional: it is easy (and "
"not too expensive) to go through the existing virtqueues and look for new "
"buffers in the used rings."
msgstr ""

#: ../../../staging/remoteproc.rst:232
msgid "Binary Firmware Structure"
msgstr ""

#: ../../../staging/remoteproc.rst:234
msgid ""
"At this point remoteproc supports ELF32 and ELF64 firmware binaries. "
"However, it is quite expected that other platforms/devices which we'd want "
"to support with this framework will be based on different binary formats."
msgstr ""

#: ../../../staging/remoteproc.rst:238
msgid ""
"When those use cases show up, we will have to decouple the binary format "
"from the framework core, so we can support several binary formats without "
"duplicating common code."
msgstr ""

#: ../../../staging/remoteproc.rst:242
msgid ""
"When the firmware is parsed, its various segments are loaded to memory "
"according to the specified device address (might be a physical address if "
"the remote processor is accessing memory directly)."
msgstr ""

#: ../../../staging/remoteproc.rst:246
msgid ""
"In addition to the standard ELF segments, most remote processors would also "
"include a special section which we call \"the resource table\"."
msgstr ""

#: ../../../staging/remoteproc.rst:249
msgid ""
"The resource table contains system resources that the remote processor "
"requires before it should be powered on, such as allocation of physically "
"contiguous memory, or iommu mapping of certain on-chip peripherals. "
"Remotecore will only power up the device after all the resource table's "
"requirement are met."
msgstr ""

#: ../../../staging/remoteproc.rst:255
msgid ""
"In addition to system resources, the resource table may also contain "
"resource entries that publish the existence of supported features or "
"configurations by the remote processor, such as trace buffers and supported "
"virtio devices (and their configurations)."
msgstr ""

#: ../../../staging/remoteproc.rst:260
msgid "The resource table begins with this header::"
msgstr ""

#: ../../../staging/remoteproc.rst:281
msgid ""
"Immediately following this header are the resource entries themselves, each "
"of which begins with the following resource entry header::"
msgstr ""

#: ../../../staging/remoteproc.rst:298
msgid ""
"Some resources entries are mere announcements, where the host is informed of "
"specific remoteproc configuration. Other entries require the host to do "
"something (e.g. allocate a system resource). Sometimes a negotiation is "
"expected, where the firmware requests a resource, and once allocated, the "
"host should provide back its details (e.g. address of an allocated memory "
"region)."
msgstr ""

#: ../../../staging/remoteproc.rst:305
msgid "Here are the various resource types that are currently supported::"
msgstr ""

#: ../../../staging/remoteproc.rst:336
msgid ""
"For more details regarding a specific resource type, please see its "
"dedicated structure in include/linux/remoteproc.h."
msgstr ""

#: ../../../staging/remoteproc.rst:339
msgid ""
"We also expect that platform-specific resource entries will show up at some "
"point. When that happens, we could easily add a new RSC_PLATFORM type, and "
"hand those resources to the platform-specific rproc driver to handle."
msgstr ""

#: ../../../staging/remoteproc.rst:344
msgid "Virtio and remoteproc"
msgstr ""

#: ../../../staging/remoteproc.rst:346
msgid ""
"The firmware should provide remoteproc information about virtio devices that "
"it supports, and their configurations: a RSC_VDEV resource entry should "
"specify the virtio device id (as in virtio_ids.h), virtio features, virtio "
"config space, vrings information, etc."
msgstr ""

#: ../../../staging/remoteproc.rst:351
msgid ""
"When a new remote processor is registered, the remoteproc framework will "
"look for its resource table and will register the virtio devices it "
"supports. A firmware may support any number of virtio devices, and of any "
"type (a single remote processor can also easily support several rpmsg virtio "
"devices this way, if desired)."
msgstr ""

#: ../../../staging/remoteproc.rst:357
msgid ""
"Of course, RSC_VDEV resource entries are only good enough for static "
"allocation of virtio devices. Dynamic allocations will also be made possible "
"using the rpmsg bus (similar to how we already do dynamic allocations of "
"rpmsg channels; read more about it in rpmsg.txt)."
msgstr ""
