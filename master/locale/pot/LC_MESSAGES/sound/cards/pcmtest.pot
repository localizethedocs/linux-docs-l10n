# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../sound/cards/pcmtest.rst:4
msgid "The Virtual PCM Test Driver"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:6
msgid ""
"The Virtual PCM Test Driver emulates a generic PCM device, and can be used "
"for testing/fuzzing of the userspace ALSA applications, as well as for "
"testing/fuzzing of the PCM middle layer. Additionally, it can be used for "
"simulating hard to reproduce problems with PCM devices."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:12
msgid "What can this driver do?"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:14
msgid "At this moment the driver can do the following things:"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:15
msgid "Simulate both capture and playback processes"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:16
msgid "Generate random or pattern-based capturing data"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:17
msgid "Inject delays into the playback and capturing processes"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:18
msgid "Inject errors during the PCM callbacks"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:20
msgid ""
"It supports up to 8 substreams and 4 channels. Also it supports both "
"interleaved and non-interleaved access modes."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:23
msgid ""
"Also, this driver can check the playback stream for containing the "
"predefined pattern, which is used in the corresponding selftest (alsa/"
"pcmtest-test.sh) to check the PCM middle layer data transferring "
"functionality. Additionally, this driver redefines the default RESET ioctl, "
"and the selftest covers this PCM API functionality as well."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:29
msgid "Configuration"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:31
msgid ""
"The driver has several parameters besides the common ALSA module parameters:"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:33
msgid "fill_mode (bool) - Buffer fill mode (see below)"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:34
msgid "inject_delay (int)"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:35
msgid "inject_hwpars_err (bool)"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:36
msgid "inject_prepare_err (bool)"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:37
msgid "inject_trigger_err (bool)"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:41
msgid "Capture Data Generation"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:43
msgid ""
"The driver has two modes of data generation: the first (0 in the fill_mode "
"parameter) means random data generation, the second (1 in the fill_mode) - "
"pattern-based data generation. Let's look at the second mode."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:47
msgid ""
"First of all, you may want to specify the pattern for data generation. You "
"can do it by writing the pattern to the debugfs file. There are pattern "
"buffer debugfs entries for each channel, as well as entries which contain "
"the pattern buffer length."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:51
msgid "/sys/kernel/debug/pcmtest/fill_pattern[0-3]"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:52
msgid "/sys/kernel/debug/pcmtest/fill_pattern[0-3]_len"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:54
msgid ""
"To set the pattern for the channel 0 you can execute the following command:"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:60
msgid ""
"Then, after every capture action performed on the 'pcmtest' device the "
"buffer for the channel 0 will contain "
"'mycoolpatternmycoolpatternmycoolpatternmy...'."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:63
msgid "The pattern itself can be up to 4096 bytes long."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:66
msgid "Delay injection"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:68
msgid ""
"The driver has 'inject_delay' parameter, which has very self-descriptive "
"name and can be used for time delay/speedup simulations. The parameter has "
"integer type, and it means the delay added between module's internal timer "
"ticks."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:72
msgid ""
"If the 'inject_delay' value is positive, the buffer will be filled slower, "
"if it is negative - faster. You can try it yourself by starting a recording "
"in any audiorecording application (like Audacity) and selecting the "
"'pcmtest' device as a source."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:77
msgid ""
"This parameter can be also used for generating a huge amount of sound data "
"in a very short period of time (with the negative 'inject_delay' value)."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:81
msgid "Errors injection"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:83
msgid ""
"This module can be used for injecting errors into the PCM communication "
"process. This action can help you to figure out how the userspace ALSA "
"program behaves under unusual circumstances."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:87
msgid ""
"For example, you can make all 'hw_params' PCM callback calls return EBUSY "
"error by writing '1' to the 'inject_hwpars_err' module parameter:"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:94
msgid "Errors can be injected into the following PCM callbacks:"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:96
msgid "hw_params (EBUSY)"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:97
msgid "prepare (EINVAL)"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:98
msgid "trigger (EINVAL)"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:101
msgid "Playback test"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:103
msgid ""
"This driver can be also used for the playback functionality testing - every "
"time you write the playback data to the 'pcmtest' PCM device and close it, "
"the driver checks the buffer for containing the looped pattern (which is "
"specified in the fill_pattern debugfs file for each channel). If the "
"playback buffer content represents the looped pattern, 'pc_test' debugfs "
"entry is set into '1'. Otherwise, the driver sets it to '0'."
msgstr ""

#: ../../../sound/cards/pcmtest.rst:110
msgid "ioctl redefinition test"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:112
msgid ""
"The driver redefines the 'reset' ioctl, which is default for all PCM "
"devices. To test this functionality, we can trigger the reset ioctl and "
"check the 'ioctl_test' debugfs entry:"
msgstr ""

#: ../../../sound/cards/pcmtest.rst:120
msgid ""
"If the ioctl is triggered successfully, this file will contain '1', and '0' "
"otherwise."
msgstr ""
