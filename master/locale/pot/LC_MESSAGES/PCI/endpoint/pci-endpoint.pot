# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../PCI/endpoint/pci-endpoint.rst:5
msgid ""
"This document is a guide to use the PCI Endpoint Framework in order to "
"create endpoint controller driver, endpoint function driver, and using "
"configfs interface to bind the function driver to the controller driver."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:10
msgid "Introduction"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:12
msgid ""
"Linux has a comprehensive PCI subsystem to support PCI controllers that "
"operates in Root Complex mode. The subsystem has capability to scan PCI bus, "
"assign memory resources and IRQ resources, load PCI driver (based on vendor "
"ID, device ID), support other services like hot-plug, power management, "
"advanced error reporting and virtual channels."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:18
msgid ""
"However the PCI controller IP integrated in some SoCs is capable of "
"operating either in Root Complex mode or Endpoint mode. PCI Endpoint "
"Framework will add endpoint mode support in Linux. This will help to run "
"Linux in an EP system which can have a wide variety of use cases from "
"testing or validation, co-processor accelerator, etc."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:25
msgid "PCI Endpoint Core"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:27
msgid ""
"The PCI Endpoint Core layer comprises 3 components: the Endpoint Controller "
"library, the Endpoint Function library, and the configfs layer to bind the "
"endpoint function with the endpoint controller."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:32
msgid "PCI Endpoint Controller(EPC) Library"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:34
msgid ""
"The EPC library provides APIs to be used by the controller that can operate "
"in endpoint mode. It also provides APIs to be used by function driver/"
"library in order to implement a particular endpoint function."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:39
msgid "APIs for the PCI controller Driver"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:41
msgid ""
"This section lists the APIs that the PCI Endpoint core provides to be used "
"by the PCI controller driver."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:44
msgid "devm_pci_epc_create()/pci_epc_create()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:46
msgid "The PCI controller driver should implement the following ops:"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:48
msgid "write_header: ops to populate configuration space header"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:49
msgid "set_bar: ops to configure the BAR"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:50
msgid "clear_bar: ops to reset the BAR"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:51
msgid "alloc_addr_space: ops to allocate in PCI controller address space"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:52
msgid "free_addr_space: ops to free the allocated address space"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:53
msgid "raise_irq: ops to raise a legacy, MSI or MSI-X interrupt"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:54
msgid "start: ops to start the PCI link"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:55
msgid "stop: ops to stop the PCI link"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:57
msgid ""
"The PCI controller driver can then create a new EPC device by invoking "
"devm_pci_epc_create()/pci_epc_create()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:60
msgid "pci_epc_destroy()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:62
msgid ""
"The PCI controller driver can destroy the EPC device created by "
"pci_epc_create() using pci_epc_destroy()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:65
msgid "pci_epc_linkup()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:67
msgid ""
"In order to notify all the function devices that the EPC device to which "
"they are linked has established a link with the host, the PCI controller "
"driver should invoke pci_epc_linkup()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:71
msgid "pci_epc_mem_init()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:73
msgid ""
"Initialize the pci_epc_mem structure used for allocating EPC addr space."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:75
msgid "pci_epc_mem_exit()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:77
msgid "Cleanup the pci_epc_mem structure allocated during pci_epc_mem_init()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:81
msgid "EPC APIs for the PCI Endpoint Function Driver"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:83
#: ../../../PCI/endpoint/pci-endpoint.rst:218
msgid ""
"This section lists the APIs that the PCI Endpoint core provides to be used "
"by the PCI endpoint function driver."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:86
msgid "pci_epc_write_header()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:88
msgid ""
"The PCI endpoint function driver should use pci_epc_write_header() to write "
"the standard configuration header to the endpoint controller."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:91
msgid "pci_epc_set_bar()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:93
msgid ""
"The PCI endpoint function driver should use pci_epc_set_bar() to configure "
"the Base Address Register in order for the host to assign PCI addr space. "
"Register space of the function driver is usually configured using this API."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:98
msgid ""
"Some endpoint controllers also support calling pci_epc_set_bar() again for "
"the same BAR (without calling pci_epc_clear_bar()) to update inbound address "
"translations after the host has programmed the BAR base address. Endpoint "
"function drivers can check this capability via the dynamic_inbound_mapping "
"EPC feature bit."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:104
msgid ""
"When pci_epf_bar.num_submap is non-zero, the endpoint function driver is "
"requesting BAR subrange mapping using pci_epf_bar.submap. This requires the "
"EPC to advertise support via the subrange_mapping EPC feature bit."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:108
msgid ""
"When an EPF driver wants to make use of the inbound subrange mapping "
"feature, it requires that the BAR base address has been programmed by the "
"host during enumeration. Thus, it needs to call pci_epc_set_bar() twice for "
"the same BAR (requires dynamic_inbound_mapping): first with num_submap set "
"to zero and configuring the BAR size, then after the PCIe link is up and the "
"host enumerates the endpoint and programs the BAR base address, again with "
"num_submap set to non-zero value."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:116
msgid ""
"Note that when making use of the inbound subrange mapping feature, the EPF "
"driver must not call pci_epc_clear_bar() between the two pci_epc_set_bar() "
"calls, because clearing the BAR can clear/disable the BAR register or BAR "
"decode on the endpoint while the host still expects the assigned BAR address "
"to remain valid."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:122
msgid "pci_epc_clear_bar()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:124
msgid ""
"The PCI endpoint function driver should use pci_epc_clear_bar() to reset the "
"BAR."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:127
msgid "pci_epc_raise_irq()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:129
msgid ""
"The PCI endpoint function driver should use pci_epc_raise_irq() to raise "
"Legacy Interrupt, MSI or MSI-X Interrupt."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:132
msgid "pci_epc_mem_alloc_addr()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:134
msgid ""
"The PCI endpoint function driver should use pci_epc_mem_alloc_addr(), to "
"allocate memory address from EPC addr space which is required to access RC's "
"buffer"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:138
msgid "pci_epc_mem_free_addr()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:140
msgid ""
"The PCI endpoint function driver should use pci_epc_mem_free_addr() to free "
"the memory space allocated using pci_epc_mem_alloc_addr()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:143
msgid "pci_epc_map_addr()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:145
msgid ""
"A PCI endpoint function driver should use pci_epc_map_addr() to map to a RC "
"PCI address the CPU address of local memory obtained with "
"pci_epc_mem_alloc_addr()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:149
msgid "pci_epc_unmap_addr()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:151
msgid ""
"A PCI endpoint function driver should use pci_epc_unmap_addr() to unmap the "
"CPU address of local memory mapped to a RC address with pci_epc_map_addr()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:154
msgid "pci_epc_mem_map()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:156
msgid ""
"A PCI endpoint controller may impose constraints on the RC PCI addresses "
"that can be mapped. The function pci_epc_mem_map() allows endpoint function "
"drivers to allocate and map controller memory while handling such "
"constraints. This function will determine the size of the memory that must "
"be allocated with pci_epc_mem_alloc_addr() for successfully mapping a RC PCI "
"address range. This function will also indicate the size of the PCI address "
"range that was actually mapped, which can be less than the requested size, "
"as well as the offset into the allocated memory to use for accessing the "
"mapped RC PCI address range."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:166
msgid "pci_epc_mem_unmap()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:168
msgid ""
"A PCI endpoint function driver can use pci_epc_mem_unmap() to unmap and free "
"controller memory that was allocated and mapped using pci_epc_mem_map()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:173
msgid "Other EPC APIs"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:175
msgid ""
"There are other APIs provided by the EPC library. These are used for binding "
"the EPF device with EPC device. pci-ep-cfs.c can be used as reference for "
"using these APIs."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:179
msgid "pci_epc_get()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:181
msgid ""
"Get a reference to the PCI endpoint controller based on the device name of "
"the controller."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:184
msgid "pci_epc_put()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:186
msgid ""
"Release the reference to the PCI endpoint controller obtained using "
"pci_epc_get()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:189
msgid "pci_epc_add_epf()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:191
msgid ""
"Add a PCI endpoint function to a PCI endpoint controller. A PCIe device can "
"have up to 8 functions according to the specification."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:194
msgid "pci_epc_remove_epf()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:196
msgid "Remove the PCI endpoint function from PCI endpoint controller."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:198
msgid "pci_epc_start()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:200
msgid ""
"The PCI endpoint function driver should invoke pci_epc_start() once it has "
"configured the endpoint function and wants to start the PCI link."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:203
msgid "pci_epc_stop()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:205
msgid ""
"The PCI endpoint function driver should invoke pci_epc_stop() to stop the "
"PCI LINK."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:210
msgid "PCI Endpoint Function(EPF) Library"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:212
msgid ""
"The EPF library provides APIs to be used by the function driver and the EPC "
"library to provide endpoint mode functionality."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:216
msgid "EPF APIs for the PCI Endpoint Function Driver"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:221
msgid "pci_epf_register_driver()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:223
msgid "The PCI Endpoint Function driver should implement the following ops:"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:224
msgid "bind: ops to perform when an EPC device has been bound to EPF device"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:225
msgid ""
"unbind: ops to perform when a binding has been lost between an EPC device "
"and EPF device"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:227
msgid "add_cfs: optional ops to create function specific configfs attributes"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:230
msgid ""
"The PCI Function driver can then register the PCI EPF driver by using "
"pci_epf_register_driver()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:233
msgid "pci_epf_unregister_driver()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:235
msgid ""
"The PCI Function driver can unregister the PCI EPF driver by using "
"pci_epf_unregister_driver()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:238
msgid "pci_epf_alloc_space()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:240
msgid ""
"The PCI Function driver can allocate space for a particular BAR using "
"pci_epf_alloc_space()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:243
msgid "pci_epf_free_space()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:245
msgid ""
"The PCI Function driver can free the allocated space (using "
"pci_epf_alloc_space) by invoking pci_epf_free_space()."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:249
msgid "APIs for the PCI Endpoint Controller Library"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:251
msgid ""
"This section lists the APIs that the PCI Endpoint core provides to be used "
"by the PCI endpoint controller library."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:254
msgid "pci_epf_linkup()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:256
msgid ""
"The PCI endpoint controller library invokes pci_epf_linkup() when the EPC "
"device has established the connection to the host."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:260
msgid "Other EPF APIs"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:262
msgid ""
"There are other APIs provided by the EPF library. These are used to notify "
"the function driver when the EPF device is bound to the EPC device. pci-ep-"
"cfs.c can be used as reference for using these APIs."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:266
msgid "pci_epf_create()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:268
msgid ""
"Create a new PCI EPF device by passing the name of the PCI EPF device. This "
"name will be used to bind the EPF device to a EPF driver."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:271
msgid "pci_epf_destroy()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:273
msgid "Destroy the created PCI EPF device."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:275
msgid "pci_epf_bind()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:277
msgid ""
"pci_epf_bind() should be invoked when the EPF device has been bound to an "
"EPC device."
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:280
msgid "pci_epf_unbind()"
msgstr ""

#: ../../../PCI/endpoint/pci-endpoint.rst:282
msgid ""
"pci_epf_unbind() should be invoked when the binding between EPC device and "
"EPF device is lost."
msgstr ""
