# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../PCI/pciebus-howto.rst:6
msgid "The PCI Express Port Bus Driver Guide HOWTO"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:0
msgid "Author"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:8
msgid "Tom L Nguyen tom.l.nguyen@intel.com 11/03/2004"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:0
msgid "Copyright"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:9
msgid "|copy| 2004 Intel Corporation"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:12
msgid "About this guide"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:14
msgid ""
"This guide describes the basics of the PCI Express Port Bus driver and "
"provides information on how to enable the service drivers to register/"
"unregister with the PCI Express Port Bus Driver."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:20
msgid "What is the PCI Express Port Bus Driver"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:22
msgid ""
"A PCI Express Port is a logical PCI-PCI Bridge structure. There are two "
"types of PCI Express Port: the Root Port and the Switch Port. The Root Port "
"originates a PCI Express link from a PCI Express Root Complex and the Switch "
"Port connects PCI Express links to internal logical PCI buses. The Switch "
"Port, which has its secondary bus representing the switch's internal routing "
"logic, is called the switch's Upstream Port. The switch's Downstream Port is "
"bridging from switch's internal routing bus to a bus representing the "
"downstream PCI Express link from the PCI Express Switch."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:32
msgid ""
"A PCI Express Port can provide up to four distinct functions, referred to in "
"this document as services, depending on its port type. PCI Express Port's "
"services include native hotplug support (HP), power management event support "
"(PME), advanced error reporting support (AER), and virtual channel support "
"(VC). These services may be handled by a single complex driver or be "
"individually distributed and handled by corresponding service drivers."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:41
msgid "Why use the PCI Express Port Bus Driver?"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:43
msgid ""
"In existing Linux kernels, the Linux Device Driver Model allows a physical "
"device to be handled by only a single driver. The PCI Express Port is a PCI-"
"PCI Bridge device with multiple distinct services. To maintain a clean and "
"simple solution each service may have its own software service driver. In "
"this case several service drivers will compete for a single PCI-PCI Bridge "
"device. For example, if the PCI Express Root Port native hotplug service "
"driver is loaded first, it claims a PCI-PCI Bridge Root Port. The kernel "
"therefore does not load other service drivers for that Root Port. In other "
"words, it is impossible to have multiple service drivers load and run on a "
"PCI-PCI Bridge device simultaneously using the current driver model."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:56
msgid ""
"To enable multiple service drivers running simultaneously requires having a "
"PCI Express Port Bus driver, which manages all populated PCI Express Ports "
"and distributes all provided service requests to the corresponding service "
"drivers as required. Some key advantages of using the PCI Express Port Bus "
"driver are listed below:"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:62
msgid ""
"Allow multiple service drivers to run simultaneously on a PCI-PCI Bridge "
"Port device."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:65
msgid "Allow service drivers implemented in an independent staged approach."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:68
msgid ""
"Allow one service driver to run on multiple PCI-PCI Bridge Port devices."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:71
msgid ""
"Manage and distribute resources of a PCI-PCI Bridge Port device to requested "
"service drivers."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:75
msgid "Configuring the PCI Express Port Bus Driver vs. Service Drivers"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:78
msgid "Including the PCI Express Port Bus Driver Support into the Kernel"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:80
msgid ""
"Including the PCI Express Port Bus driver depends on whether the PCI Express "
"support is included in the kernel config. The kernel will automatically "
"include the PCI Express Port Bus driver as a kernel driver when the PCI "
"Express support is enabled in the kernel."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:86
msgid "Enabling Service Driver Support"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:88
msgid ""
"PCI device drivers are implemented based on Linux Device Driver Model. All "
"service drivers are PCI device drivers. As discussed above, it is impossible "
"to load any service driver once the kernel has loaded the PCI Express Port "
"Bus Driver. To meet the PCI Express Port Bus Driver Model requires some "
"minimal changes on existing service drivers that imposes no impact on the "
"functionality of existing service drivers."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:95
msgid ""
"A service driver is required to use the two APIs shown below to register its "
"service with the PCI Express Port Bus driver (see section 5.2.1 & 5.2.2). It "
"is important that a service driver initializes the pcie_port_service_driver "
"data structure, included in header file /include/linux/pcieport_if.h, before "
"calling these APIs. Failure to do so will result an identity mismatch, which "
"prevents the PCI Express Port Bus driver from loading a service driver."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:104
msgid "pcie_port_service_register"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:109
msgid ""
"This API replaces the Linux Driver Model's pci_register_driver API. A "
"service driver should always calls pcie_port_service_register at module "
"init. Note that after service driver being loaded, calls such as "
"pci_enable_device(dev) and pci_set_master(dev) are no longer necessary since "
"these calls are executed by the PCI Port Bus driver."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:116
msgid "pcie_port_service_unregister"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:121
msgid ""
"pcie_port_service_unregister replaces the Linux Driver Model's "
"pci_unregister_driver. It's always called by service driver when a module "
"exits."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:126
msgid "Sample Code"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:128
msgid ""
"Below is sample service driver code to initialize the port service driver "
"data structure. ::"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:151
msgid ""
"Below is a sample code for registering/unregistering a service driver. ::"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:177
msgid "Possible Resource Conflicts"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:179
msgid ""
"Since all service drivers of a PCI-PCI Bridge Port device are allowed to run "
"simultaneously, below lists a few of possible resource conflicts with "
"proposed solutions."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:184
msgid "MSI and MSI-X Vector Resource"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:186
msgid ""
"Once MSI or MSI-X interrupts are enabled on a device, it stays in this mode "
"until they are disabled again.  Since service drivers of the same PCI-PCI "
"Bridge port share the same physical device, if an individual service driver "
"enables or disables MSI/MSI-X mode it may result unpredictable behavior."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:192
msgid ""
"To avoid this situation all service drivers are not permitted to switch "
"interrupt mode on its device. The PCI Express Port Bus driver is responsible "
"for determining the interrupt mode and this should be transparent to service "
"drivers. Service drivers need to know only the vector IRQ assigned to the "
"field irq of struct pcie_device, which is passed in when the PCI Express "
"Port Bus driver probes each service driver. Service drivers should use "
"(struct pcie_device*)dev->irq to call request_irq/free_irq. In addition, the "
"interrupt mode is stored in the field interrupt_mode of struct pcie_device."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:203
msgid "PCI Memory/IO Mapped Regions"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:205
msgid ""
"Service drivers for PCI Express Power Management (PME), Advanced Error "
"Reporting (AER), Hot-Plug (HP) and Virtual Channel (VC) access PCI "
"configuration space on the PCI Express port. In all cases the registers "
"accessed are independent of each other. This patch assumes that all service "
"drivers will be well behaved and not overwrite other service driver's "
"configuration settings."
msgstr ""

#: ../../../PCI/pciebus-howto.rst:213
msgid "PCI Config Registers"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:215
msgid ""
"Each service driver runs its PCI config operations on its own capability "
"structure except the PCI Express capability structure, that is shared "
"between many drivers including the service drivers. RMW Capability accessors "
"(pcie_capability_clear_and_set_word(), pcie_capability_set_word(), and "
"pcie_capability_clear_word()) protect a selected set of PCI Express "
"Capability Registers:"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:222
msgid "Link Control Register"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:223
msgid "Root Control Register"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:224
msgid "Link Control 2 Register"
msgstr ""

#: ../../../PCI/pciebus-howto.rst:226
msgid ""
"Any change to those registers should be performed using RMW accessors to "
"avoid problems due to concurrent updates. For the up-to-date list of "
"protected registers, see pcie_capability_clear_and_set_word()."
msgstr ""
