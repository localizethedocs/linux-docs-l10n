# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/f2fs.rst:5
msgid "Flash-Friendly File System (F2FS)"
msgstr ""

#: ../../../filesystems/f2fs.rst:8
msgid "Overview"
msgstr ""

#: ../../../filesystems/f2fs.rst:10
msgid ""
"NAND flash memory-based storage devices, such as SSD, eMMC, and SD cards, "
"have been equipped on a variety systems ranging from mobile to server "
"systems. Since they are known to have different characteristics from the "
"conventional rotating disks, a file system, an upper layer to the storage "
"device, should adapt to the changes from the sketch in the design level."
msgstr ""

#: ../../../filesystems/f2fs.rst:16
msgid ""
"F2FS is a file system exploiting NAND flash memory-based storage devices, "
"which is based on Log-structured File System (LFS). The design has been "
"focused on addressing the fundamental issues in LFS, which are snowball "
"effect of wandering tree and high cleaning overhead."
msgstr ""

#: ../../../filesystems/f2fs.rst:21
msgid ""
"Since a NAND flash memory-based storage device shows different "
"characteristic according to its internal geometry or flash memory management "
"scheme, namely FTL, F2FS and its tools support various parameters not only "
"for configuring on-disk layout, but also for selecting allocation and "
"cleaning algorithms."
msgstr ""

#: ../../../filesystems/f2fs.rst:26
msgid ""
"The following git tree provides the file system formatting tool (mkfs.f2fs), "
"a consistency checking tool (fsck.f2fs), and a debugging tool (dump.f2fs)."
msgstr ""

#: ../../../filesystems/f2fs.rst:29
msgid "git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs-tools.git"
msgstr ""

#: ../../../filesystems/f2fs.rst:31
msgid "For sending patches, please use the following mailing list:"
msgstr ""

#: ../../../filesystems/f2fs.rst:33
msgid "linux-f2fs-devel@lists.sourceforge.net"
msgstr ""

#: ../../../filesystems/f2fs.rst:35
msgid "For reporting bugs, please use the following f2fs bug tracker link:"
msgstr ""

#: ../../../filesystems/f2fs.rst:37
msgid ""
"https://bugzilla.kernel.org/enter_bug.cgi?"
"product=File%20System&component=f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:40
msgid "Background and Design issues"
msgstr ""

#: ../../../filesystems/f2fs.rst:43
msgid "Log-structured File System (LFS)"
msgstr ""

#: ../../../filesystems/f2fs.rst:44
msgid ""
"\"A log-structured file system writes all modifications to disk sequentially "
"in a log-like structure, thereby speeding up  both file writing and crash "
"recovery. The log is the only structure on disk; it contains indexing "
"information so that files can be read back from the log efficiently. In "
"order to maintain large free areas on disk for fast writing, we divide  the "
"log into segments and use a segment cleaner to compress the live information "
"from heavily fragmented segments.\" from Rosenblum, M. and Ousterhout, J. "
"K., 1992, \"The design and implementation of a log-structured file system\", "
"ACM Trans. Computer Systems 10, 1, 26–52."
msgstr ""

#: ../../../filesystems/f2fs.rst:55 ../../../filesystems/f2fs.rst:95
msgid "Wandering Tree Problem"
msgstr ""

#: ../../../filesystems/f2fs.rst:56
msgid ""
"In LFS, when a file data is updated and written to the end of log, its "
"direct pointer block is updated due to the changed location. Then the "
"indirect pointer block is also updated due to the direct pointer block "
"update. In this manner, the upper index structures such as inode, inode map, "
"and checkpoint block are also updated recursively. This problem is called as "
"wandering tree problem [1], and in order to enhance the performance, it "
"should eliminate or relax the update propagation as much as possible."
msgstr ""

#: ../../../filesystems/f2fs.rst:64
msgid ""
"[1] Bityutskiy, A. 2005. JFFS3 design issues. http://www.linux-mtd.infradead."
"org/"
msgstr ""

#: ../../../filesystems/f2fs.rst:67 ../../../filesystems/f2fs.rst:101
msgid "Cleaning Overhead"
msgstr ""

#: ../../../filesystems/f2fs.rst:68
msgid ""
"Since LFS is based on out-of-place writes, it produces so many obsolete "
"blocks scattered across the whole storage. In order to serve new empty log "
"space, it needs to reclaim these obsolete blocks seamlessly to users. This "
"job is called as a cleaning process."
msgstr ""

#: ../../../filesystems/f2fs.rst:73
msgid "The process consists of three operations as follows."
msgstr ""

#: ../../../filesystems/f2fs.rst:75
msgid "A victim segment is selected through referencing segment usage table."
msgstr ""

#: ../../../filesystems/f2fs.rst:76
msgid ""
"It loads parent index structures of all the data in the victim identified by "
"segment summary blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:78
msgid ""
"It checks the cross-reference between the data and its parent index "
"structure."
msgstr ""

#: ../../../filesystems/f2fs.rst:79
msgid "It moves valid data selectively."
msgstr ""

#: ../../../filesystems/f2fs.rst:81
msgid ""
"This cleaning job may cause unexpected long delays, so the most important "
"goal is to hide the latencies to users. And also definitely, it should "
"reduce the amount of valid data to be moved, and move them quickly as well."
msgstr ""

#: ../../../filesystems/f2fs.rst:86
msgid "Key Features"
msgstr ""

#: ../../../filesystems/f2fs.rst:89
msgid "Flash Awareness"
msgstr ""

#: ../../../filesystems/f2fs.rst:90
msgid ""
"Enlarge the random write area for better performance, but provide the high "
"spatial locality"
msgstr ""

#: ../../../filesystems/f2fs.rst:92
msgid ""
"Align FS data structures to the operational units in FTL as best efforts"
msgstr ""

#: ../../../filesystems/f2fs.rst:96
msgid ""
"Use a term, “node”, that represents inodes as well as various pointer blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:97
msgid ""
"Introduce Node Address Table (NAT) containing the locations of all the "
"“node” blocks; this will cut off the update propagation."
msgstr ""

#: ../../../filesystems/f2fs.rst:102
msgid "Support a background cleaning process"
msgstr ""

#: ../../../filesystems/f2fs.rst:103
msgid ""
"Support greedy and cost-benefit algorithms for victim selection policies"
msgstr ""

#: ../../../filesystems/f2fs.rst:104
msgid "Support multi-head logs for static/dynamic hot and cold data separation"
msgstr ""

#: ../../../filesystems/f2fs.rst:105
msgid "Introduce adaptive logging for efficient block allocation"
msgstr ""

#: ../../../filesystems/f2fs.rst:108
msgid "Mount Options"
msgstr ""

#: ../../../filesystems/f2fs.rst:112
msgid "background_gc=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:112
msgid ""
"Turn on/off cleaning operations, namely garbage collection, triggered in "
"background when I/O subsystem is idle. If background_gc=on, it will turn on "
"the garbage collection and if background_gc=off, garbage collection will be "
"turned off. If background_gc=sync, it will turn on synchronous garbage "
"collection running in background. Default value for this option is on. So "
"garbage collection is on by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:120
msgid "gc_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:120
msgid ""
"When background_gc is on, this option can be enabled to let background GC "
"thread to handle foreground GC requests, it can eliminate the sluggish issue "
"caused by slow foreground GC operation when GC is triggered from a process "
"with limited I/O and CPU resources."
msgstr ""

#: ../../../filesystems/f2fs.rst:125
msgid "nogc_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:125
msgid "Disable GC merge feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:126
msgid "disable_roll_forward"
msgstr ""

#: ../../../filesystems/f2fs.rst:126
msgid "Disable the roll-forward recovery routine"
msgstr ""

#: ../../../filesystems/f2fs.rst:127
msgid "norecovery"
msgstr ""

#: ../../../filesystems/f2fs.rst:127
msgid ""
"Disable the roll-forward recovery routine, mounted read- only (i.e., -o ro,"
"disable_roll_forward)"
msgstr ""

#: ../../../filesystems/f2fs.rst:129
msgid "discard/nodiscard"
msgstr ""

#: ../../../filesystems/f2fs.rst:129
msgid ""
"Enable/disable real-time discard in f2fs, if discard is enabled, f2fs will "
"issue discard/TRIM commands when a segment is cleaned."
msgstr ""

#: ../../../filesystems/f2fs.rst:132
msgid "heap/no_heap"
msgstr ""

#: ../../../filesystems/f2fs.rst:132
msgid "Deprecated."
msgstr ""

#: ../../../filesystems/f2fs.rst:133
msgid "nouser_xattr"
msgstr ""

#: ../../../filesystems/f2fs.rst:133
msgid ""
"Disable Extended User Attributes. Note: xattr is enabled by default if "
"CONFIG_F2FS_FS_XATTR is selected."
msgstr ""

#: ../../../filesystems/f2fs.rst:135
msgid "noacl"
msgstr ""

#: ../../../filesystems/f2fs.rst:135
msgid ""
"Disable POSIX Access Control List. Note: acl is enabled by default if "
"CONFIG_F2FS_FS_POSIX_ACL is selected."
msgstr ""

#: ../../../filesystems/f2fs.rst:137
msgid "active_logs=%u"
msgstr ""

#: ../../../filesystems/f2fs.rst:137
msgid ""
"Support configuring the number of active logs. In the current design, f2fs "
"supports only 2, 4, and 6 logs. Default number is 6."
msgstr ""

#: ../../../filesystems/f2fs.rst:140
msgid "disable_ext_identify"
msgstr ""

#: ../../../filesystems/f2fs.rst:140
msgid ""
"Disable the extension list configured by mkfs, so f2fs is not aware of cold "
"files such as media files."
msgstr ""

#: ../../../filesystems/f2fs.rst:142
msgid "inline_xattr"
msgstr ""

#: ../../../filesystems/f2fs.rst:142
msgid "Enable the inline xattrs feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:143
msgid "noinline_xattr"
msgstr ""

#: ../../../filesystems/f2fs.rst:143
msgid "Disable the inline xattrs feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:144
msgid "inline_xattr_size=%u"
msgstr ""

#: ../../../filesystems/f2fs.rst:144
msgid ""
"Support configuring inline xattr size, it depends on flexible inline xattr "
"feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:146
msgid "inline_data"
msgstr ""

#: ../../../filesystems/f2fs.rst:146
msgid ""
"Enable the inline data feature: Newly created small (<~3.4k) files can be "
"written into inode block."
msgstr ""

#: ../../../filesystems/f2fs.rst:148
msgid "inline_dentry"
msgstr ""

#: ../../../filesystems/f2fs.rst:148
msgid ""
"Enable the inline dir feature: data in newly created directory entries can "
"be written into inode block. The space of inode block which is used to store "
"inline dentries is limited to ~3.4k."
msgstr ""

#: ../../../filesystems/f2fs.rst:152
msgid "noinline_dentry"
msgstr ""

#: ../../../filesystems/f2fs.rst:152
msgid "Disable the inline dentry feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:153
msgid "flush_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:153
msgid ""
"Merge concurrent cache_flush commands as much as possible to eliminate "
"redundant command issues. If the underlying device handles the cache_flush "
"command relatively slowly, recommend to enable this option."
msgstr ""

#: ../../../filesystems/f2fs.rst:157
msgid "nobarrier"
msgstr ""

#: ../../../filesystems/f2fs.rst:157
msgid ""
"This option can be used if underlying storage guarantees its cached data "
"should be written to the novolatile area. If this option is set, no "
"cache_flush commands are issued but f2fs still guarantees the write ordering "
"of all the data writes."
msgstr ""

#: ../../../filesystems/f2fs.rst:162
msgid "barrier"
msgstr ""

#: ../../../filesystems/f2fs.rst:162
msgid "If this option is set, cache_flush commands are allowed to be issued."
msgstr ""

#: ../../../filesystems/f2fs.rst:164
msgid "fastboot"
msgstr ""

#: ../../../filesystems/f2fs.rst:164
msgid ""
"This option is used when a system wants to reduce mount time as much as "
"possible, even though normal performance can be sacrificed."
msgstr ""

#: ../../../filesystems/f2fs.rst:167
msgid "extent_cache"
msgstr ""

#: ../../../filesystems/f2fs.rst:167
msgid ""
"Enable an extent cache based on rb-tree, it can cache as many as extent "
"which map between contiguous logical address and physical address per inode, "
"resulting in increasing the cache hit ratio. Set by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:171
msgid "noextent_cache"
msgstr ""

#: ../../../filesystems/f2fs.rst:171
msgid ""
"Disable an extent cache based on rb-tree explicitly, see the above "
"extent_cache mount option."
msgstr ""

#: ../../../filesystems/f2fs.rst:173
msgid "noinline_data"
msgstr ""

#: ../../../filesystems/f2fs.rst:173
msgid ""
"Disable the inline data feature, inline data feature is enabled by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:175
msgid "data_flush"
msgstr ""

#: ../../../filesystems/f2fs.rst:175
msgid ""
"Enable data flushing before checkpoint in order to persist data of regular "
"and symlink."
msgstr ""

#: ../../../filesystems/f2fs.rst:177
msgid "reserve_root=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:177
msgid ""
"Support configuring reserved space which is used for allocation from a "
"privileged user with specified uid or gid, unit: 4KB, the default limit is "
"12.5% of user blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:180
msgid "reserve_node=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:180
msgid ""
"Support configuring reserved nodes which are used for allocation from a "
"privileged user with specified uid or gid, the default limit is 12.5% of all "
"nodes."
msgstr ""

#: ../../../filesystems/f2fs.rst:183
msgid "resuid=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:183
msgid "The user ID which may use the reserved blocks and nodes."
msgstr ""

#: ../../../filesystems/f2fs.rst:184
msgid "resgid=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:184
msgid "The group ID which may use the reserved blocks and nodes."
msgstr ""

#: ../../../filesystems/f2fs.rst:185
msgid "fault_injection=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:185
msgid ""
"Enable fault injection in all supported types with specified injection rate."
msgstr ""

#: ../../../filesystems/f2fs.rst:187
msgid "fault_type=%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:187
msgid ""
"Support configuring fault injection type, should be enabled with "
"fault_injection option, fault type value is shown below, it supports single "
"or combined type."
msgstr ""

#: ../../../filesystems/f2fs.rst:221
msgid "mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:221
msgid ""
"Control block allocation mode which supports \"adaptive\" and \"lfs\". In "
"\"lfs\" mode, there should be no random writes towards main area. \"fragment:"
"segment\" and \"fragment:block\" are newly added here. These are developer "
"options for experiments to simulate filesystem fragmentation/after-GC "
"situation itself. The developers use these modes to understand filesystem "
"fragmentation/after-GC condition well, and eventually get some insights to "
"handle them better. In \"fragment:segment\", f2fs allocates a new segment in "
"random position. With this, we can simulate the after-GC condition. In "
"\"fragment:block\", we can scatter block allocation with "
"\"max_fragment_chunk\" and \"max_fragment_hole\" sysfs nodes. We added some "
"randomness to both chunk and hole size to make it close to realistic IO "
"pattern. So, in this mode, f2fs will allocate 1..<max_fragment_chunk> blocks "
"in a chunk and make a hole in the length of 1..<max_fragment_hole> by turns. "
"With this, the newly allocated blocks will be scattered throughout the whole "
"partition. Note that \"fragment:block\" implicitly enables \"fragment:"
"segment\" option for more randomness. Please, use these options for your "
"experiments and we strongly recommend to re-format the filesystem after "
"using these options."
msgstr ""

#: ../../../filesystems/f2fs.rst:242
msgid "usrquota"
msgstr ""

#: ../../../filesystems/f2fs.rst:242 ../../../filesystems/f2fs.rst:252
msgid "Enable plain user disk quota accounting."
msgstr ""

#: ../../../filesystems/f2fs.rst:243
msgid "grpquota"
msgstr ""

#: ../../../filesystems/f2fs.rst:243
msgid "Enable plain group disk quota accounting."
msgstr ""

#: ../../../filesystems/f2fs.rst:244
msgid "prjquota"
msgstr ""

#: ../../../filesystems/f2fs.rst:244
msgid "Enable plain project quota accounting."
msgstr ""

#: ../../../filesystems/f2fs.rst:245
msgid "usrjquota=<file>"
msgstr ""

#: ../../../filesystems/f2fs.rst:245
msgid "Appoint specified file and type during mount, so that quota"
msgstr ""

#: ../../../filesystems/f2fs.rst:246
msgid "grpjquota=<file>"
msgstr ""

#: ../../../filesystems/f2fs.rst:246
msgid "information can be properly updated during recovery flow,"
msgstr ""

#: ../../../filesystems/f2fs.rst:247
msgid "prjjquota=<file>"
msgstr ""

#: ../../../filesystems/f2fs.rst:247
msgid "<quota file>: must be in root directory;"
msgstr ""

#: ../../../filesystems/f2fs.rst:248
msgid "jqfmt=<quota type>"
msgstr ""

#: ../../../filesystems/f2fs.rst:248
msgid "<quota type>: [vfsold,vfsv0,vfsv1]."
msgstr ""

#: ../../../filesystems/f2fs.rst:249
msgid "usrjquota="
msgstr ""

#: ../../../filesystems/f2fs.rst:249
msgid "Turn off user journalled quota."
msgstr ""

#: ../../../filesystems/f2fs.rst:250
msgid "grpjquota="
msgstr ""

#: ../../../filesystems/f2fs.rst:250
msgid "Turn off group journalled quota."
msgstr ""

#: ../../../filesystems/f2fs.rst:251
msgid "prjjquota="
msgstr ""

#: ../../../filesystems/f2fs.rst:251
msgid "Turn off project journalled quota."
msgstr ""

#: ../../../filesystems/f2fs.rst:252
msgid "quota"
msgstr ""

#: ../../../filesystems/f2fs.rst:253
msgid "noquota"
msgstr ""

#: ../../../filesystems/f2fs.rst:253
msgid "Disable all plain disk quota option."
msgstr ""

#: ../../../filesystems/f2fs.rst:254
msgid "alloc_mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:254
msgid ""
"Adjust block allocation policy, which supports \"reuse\" and \"default\"."
msgstr ""

#: ../../../filesystems/f2fs.rst:256
msgid "fsync_mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:256
msgid ""
"Control the policy of fsync. Currently supports \"posix\", \"strict\", and "
"\"nobarrier\". In \"posix\" mode, which is default, fsync will follow POSIX "
"semantics and does a light operation to improve the filesystem performance. "
"In \"strict\" mode, fsync will be heavy and behaves in line with xfs, ext4 "
"and btrfs, where xfstest generic/342 will pass, but the performance will "
"regress. \"nobarrier\" is based on \"posix\", but doesn't issue flush "
"command for non-atomic files likewise \"nobarrier\" mount option."
msgstr ""

#: ../../../filesystems/f2fs.rst:265
msgid "test_dummy_encryption"
msgstr ""

#: ../../../filesystems/f2fs.rst:266
msgid "test_dummy_encryption=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:267
msgid ""
"Enable dummy encryption, which provides a fake fscrypt context. The fake "
"fscrypt context is used by xfstests. The argument may be either \"v1\" or "
"\"v2\", in order to select the corresponding fscrypt policy version."
msgstr ""

#: ../../../filesystems/f2fs.rst:271
msgid "checkpoint=%s[:%u[%]]"
msgstr ""

#: ../../../filesystems/f2fs.rst:271
msgid ""
"Set to \"disable\" to turn off checkpointing. Set to \"enable\" to re-enable "
"checkpointing. Is enabled by default. While disabled, any unmounting or "
"unexpected shutdowns will cause the filesystem contents to appear as they "
"did when the filesystem was mounted with that option. While mounting with "
"checkpoint=disable, the filesystem must run garbage collection to ensure "
"that all available space can be used. If this takes too much time, the mount "
"may return EAGAIN. You may optionally add a value to indicate how much of "
"the disk you would be willing to temporarily give up to avoid additional "
"garbage collection. This can be given as a number of blocks, or as a "
"percent. For instance, mounting with checkpoint=disable:100% would always "
"succeed, but it may hide up to all remaining free space. The actual space "
"that would be unusable can be viewed at /sys/fs/f2fs/<disk>/unusable This "
"space is reclaimed once checkpoint=enable."
msgstr ""

#: ../../../filesystems/f2fs.rst:287
msgid "checkpoint_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:287
msgid ""
"When checkpoint is enabled, this can be used to create a kernel daemon and "
"make it to merge concurrent checkpoint requests as much as possible to "
"eliminate redundant checkpoint issues. Plus, we can eliminate the sluggish "
"issue caused by slow checkpoint operation when the checkpoint is done in a "
"process context in a cgroup having low i/o budget and cpu shares. To make "
"this do better, we set the default i/o priority of the kernel daemon to "
"\"3\", to give one higher priority than other kernel threads. This is the "
"same way to give a I/O priority to the jbd2 journaling thread of ext4 "
"filesystem."
msgstr ""

#: ../../../filesystems/f2fs.rst:297
msgid "nocheckpoint_merge"
msgstr ""

#: ../../../filesystems/f2fs.rst:297
msgid "Disable checkpoint merge feature."
msgstr ""

#: ../../../filesystems/f2fs.rst:298
msgid "compress_algorithm=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:298
msgid ""
"Control compress algorithm, currently f2fs supports \"lzo\", \"lz4\", "
"\"zstd\" and \"lzo-rle\" algorithm."
msgstr ""

#: ../../../filesystems/f2fs.rst:300
msgid "compress_algorithm=%s:%d"
msgstr ""

#: ../../../filesystems/f2fs.rst:300
msgid ""
"Control compress algorithm and its compress level, now, only \"lz4\" and "
"\"zstd\" support compress level config::"
msgstr ""

#: ../../../filesystems/f2fs.rst:310
msgid "compress_log_size=%u"
msgstr ""

#: ../../../filesystems/f2fs.rst:310
msgid ""
"Support configuring compress cluster size. The size will be 4KB * (1 << %u). "
"The default and minimum sizes are 16KB."
msgstr ""

#: ../../../filesystems/f2fs.rst:312
msgid "compress_extension=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:312
msgid ""
"Support adding specified extension, so that f2fs can enable compression on "
"those corresponding files, e.g. if all files with '.ext' has high "
"compression rate, we can set the '.ext' on compression extension list and "
"enable compression on these file by default rather than to enable it via "
"ioctl. For other files, we can still enable compression via ioctl. Note "
"that, there is one reserved special extension '*', it can be set to enable "
"compression for all files."
msgstr ""

#: ../../../filesystems/f2fs.rst:320
msgid "nocompress_extension=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:320
msgid ""
"Support adding specified extension, so that f2fs can disable compression on "
"those corresponding files, just contrary to compression extension. If you "
"know exactly which files cannot be compressed, you can use this. The same "
"extension name can't appear in both compress and nocompress extension at the "
"same time. If the compress extension specifies all files, the types "
"specified by the nocompress extension will be treated as special cases and "
"will not be compressed. Don't allow use '*' to specifie all file in "
"nocompress extension. After add nocompress_extension, the priority should "
"be: dir_flag < comp_extention,nocompress_extension < comp_file_flag,"
"no_comp_file_flag. See more in compression sections."
msgstr ""

#: ../../../filesystems/f2fs.rst:332
msgid "compress_chksum"
msgstr ""

#: ../../../filesystems/f2fs.rst:332
msgid "Support verifying chksum of raw data in compressed cluster."
msgstr ""

#: ../../../filesystems/f2fs.rst:333
msgid "compress_mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:333
msgid ""
"Control file compression mode. This supports \"fs\" and \"user\" modes. In "
"\"fs\" mode (default), f2fs does automatic compression on the compression "
"enabled files. In \"user\" mode, f2fs disables the automaic compression and "
"gives the user discretion of choosing the target file and the timing. The "
"user can do manual compression/decompression on the compression enabled "
"files using ioctls."
msgstr ""

#: ../../../filesystems/f2fs.rst:340
msgid "compress_cache"
msgstr ""

#: ../../../filesystems/f2fs.rst:340
msgid ""
"Support to use address space of a filesystem managed inode to cache "
"compressed block, in order to improve cache hit ratio of random read."
msgstr ""

#: ../../../filesystems/f2fs.rst:343
msgid "inlinecrypt"
msgstr ""

#: ../../../filesystems/f2fs.rst:343
msgid ""
"When possible, encrypt/decrypt the contents of encrypted files using the blk-"
"crypto framework rather than filesystem-layer encryption. This allows the "
"use of inline encryption hardware. The on-disk format is unaffected. For "
"more details, see Documentation/block/inline-encryption.rst."
msgstr ""

#: ../../../filesystems/f2fs.rst:349
msgid "atgc"
msgstr ""

#: ../../../filesystems/f2fs.rst:349
msgid ""
"Enable age-threshold garbage collection, it provides high effectiveness and "
"efficiency on background GC."
msgstr ""

#: ../../../filesystems/f2fs.rst:351
msgid "discard_unit=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:351
msgid ""
"Control discard unit, the argument can be \"block\", \"segment\" and "
"\"section\", issued discard command's offset/size will be aligned to the "
"unit, by default, \"discard_unit=block\" is set, so that small discard "
"functionality is enabled. For blkzoned device, \"discard_unit=section\" will "
"be set by default, it is helpful for large sized SMR or ZNS devices to "
"reduce memory cost by getting rid of fs metadata supports small discard."
msgstr ""

#: ../../../filesystems/f2fs.rst:359
msgid "memory=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:359
msgid ""
"Control memory mode. This supports \"normal\" and \"low\" modes. \"low\" "
"mode is introduced to support low memory devices. Because of the nature of "
"low memory devices, in this mode, f2fs will try to save memory sometimes by "
"sacrificing performance. \"normal\" mode is the default mode and same as "
"before."
msgstr ""

#: ../../../filesystems/f2fs.rst:364
msgid "age_extent_cache"
msgstr ""

#: ../../../filesystems/f2fs.rst:364
msgid ""
"Enable an age extent cache based on rb-tree. It records data block update "
"frequency of the extent per inode, in order to provide better temperature "
"hints for data block allocation."
msgstr ""

#: ../../../filesystems/f2fs.rst:368
msgid "errors=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:368
msgid ""
"Specify f2fs behavior on critical errors. This supports modes: \"panic\", "
"\"continue\" and \"remount-ro\", respectively, trigger panic immediately, "
"continue without doing anything, and remount the partition in read-only "
"mode. By default it uses \"continue\" mode."
msgstr ""

#: ../../../filesystems/f2fs.rst:387
msgid "nat_bits"
msgstr ""

#: ../../../filesystems/f2fs.rst:387
msgid ""
"Enable nat_bits feature to enhance full/empty nat blocks access, by default "
"it's disabled."
msgstr ""

#: ../../../filesystems/f2fs.rst:389
msgid "lookup_mode=%s"
msgstr ""

#: ../../../filesystems/f2fs.rst:389
msgid ""
"Control the directory lookup behavior for casefolded directories. This "
"option has no effect on directories that do not have the casefold feature "
"enabled."
msgstr ""

#: ../../../filesystems/f2fs.rst:413
msgid "Debugfs Entries"
msgstr ""

#: ../../../filesystems/f2fs.rst:415
msgid ""
"/sys/kernel/debug/f2fs/ contains information about all the partitions "
"mounted as f2fs. Each file shows the whole f2fs information."
msgstr ""

#: ../../../filesystems/f2fs.rst:418
msgid "/sys/kernel/debug/f2fs/status includes:"
msgstr ""

#: ../../../filesystems/f2fs.rst:420
msgid "major file system information managed by f2fs currently"
msgstr ""

#: ../../../filesystems/f2fs.rst:421
msgid "average SIT information about whole segments"
msgstr ""

#: ../../../filesystems/f2fs.rst:422
msgid "current memory footprint consumed by f2fs."
msgstr ""

#: ../../../filesystems/f2fs.rst:425
msgid "Sysfs Entries"
msgstr ""

#: ../../../filesystems/f2fs.rst:427
msgid ""
"Information about mounted f2fs file systems can be found in /sys/fs/f2fs.  "
"Each mounted filesystem will have a directory in /sys/fs/f2fs based on its "
"device name (i.e., /sys/fs/f2fs/sda). The files in each per-device directory "
"are shown in table below."
msgstr ""

#: ../../../filesystems/f2fs.rst:432
msgid ""
"Files in /sys/fs/f2fs/<devname> (see also Documentation/ABI/testing/sysfs-fs-"
"f2fs)"
msgstr ""

#: ../../../filesystems/f2fs.rst:436
msgid "Usage"
msgstr ""

#: ../../../filesystems/f2fs.rst:438
msgid "Download userland tools and compile them."
msgstr ""

#: ../../../filesystems/f2fs.rst:440
msgid ""
"Skip, if f2fs was compiled statically inside kernel. Otherwise, insert the "
"f2fs.ko module::"
msgstr ""

#: ../../../filesystems/f2fs.rst:445
msgid "Create a directory to use when mounting::"
msgstr ""

#: ../../../filesystems/f2fs.rst:449
msgid "Format the block device, and then mount as f2fs::"
msgstr ""

#: ../../../filesystems/f2fs.rst:455
msgid "mkfs.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:456
msgid ""
"The mkfs.f2fs is for the use of formatting a partition as the f2fs "
"filesystem, which builds a basic on-disk layout."
msgstr ""

#: ../../../filesystems/f2fs.rst:459
msgid "The quick options consist of:"
msgstr ""

#: ../../../filesystems/f2fs.rst:462
msgid "``-l [label]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:462
msgid "Give a volume label, up to 512 unicode name."
msgstr ""

#: ../../../filesystems/f2fs.rst:463
msgid "``-a [0 or 1]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:463
msgid "Split start location of each area for heap-based allocation."
msgstr ""

#: ../../../filesystems/f2fs.rst:465
msgid "1 is set by default, which performs this."
msgstr ""

#: ../../../filesystems/f2fs.rst:466
msgid "``-o [int]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:466
msgid "Set overprovision ratio in percent over volume size."
msgstr ""

#: ../../../filesystems/f2fs.rst:468
msgid "5 is set by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:469
msgid "``-s [int]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:469
msgid "Set the number of segments per section."
msgstr ""

#: ../../../filesystems/f2fs.rst:471 ../../../filesystems/f2fs.rst:474
msgid "1 is set by default."
msgstr ""

#: ../../../filesystems/f2fs.rst:472
msgid "``-z [int]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:472
msgid "Set the number of sections per zone."
msgstr ""

#: ../../../filesystems/f2fs.rst:475
msgid "``-e [str]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:475
msgid "Set basic extension list. e.g. \"mp3,gif,mov\""
msgstr ""

#: ../../../filesystems/f2fs.rst:476
msgid "``-t [0 or 1]``"
msgstr ""

#: ../../../filesystems/f2fs.rst:476
msgid "Disable discard command or not."
msgstr ""

#: ../../../filesystems/f2fs.rst:478
msgid "1 is set by default, which conducts discard."
msgstr ""

#: ../../../filesystems/f2fs.rst:481
msgid ""
"Note: please refer to the manpage of mkfs.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:484
msgid "fsck.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:485
msgid ""
"The fsck.f2fs is a tool to check the consistency of an f2fs-formatted "
"partition, which examines whether the filesystem metadata and user-made data "
"are cross-referenced correctly or not. Note that, initial version of the "
"tool does not fix any inconsistency."
msgstr ""

#: ../../../filesystems/f2fs.rst:490
msgid "The quick options consist of::"
msgstr ""

#: ../../../filesystems/f2fs.rst:494
msgid ""
"Note: please refer to the manpage of fsck.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:497
msgid "dump.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:498
msgid ""
"The dump.f2fs shows the information of specific inode and dumps SSA and SIT "
"to file. Each file is dump_ssa and dump_sit."
msgstr ""

#: ../../../filesystems/f2fs.rst:501
msgid ""
"The dump.f2fs is used to debug on-disk data structures of the f2fs "
"filesystem. It shows on-disk inode information recognized by a given inode "
"number, and is able to dump all the SSA and SIT entries into predefined "
"files, ./dump_ssa and ./dump_sit respectively."
msgstr ""

#: ../../../filesystems/f2fs.rst:506
msgid "The options consist of::"
msgstr ""

#: ../../../filesystems/f2fs.rst:513
msgid "Examples::"
msgstr ""

#: ../../../filesystems/f2fs.rst:519
msgid ""
"Note: please refer to the manpage of dump.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:522
msgid "sload.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:523
msgid ""
"The sload.f2fs gives a way to insert files and directories in the existing "
"disk image. This tool is useful when building f2fs images given compiled "
"files."
msgstr ""

#: ../../../filesystems/f2fs.rst:526
msgid ""
"Note: please refer to the manpage of sload.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:529
msgid "resize.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:530
msgid ""
"The resize.f2fs lets a user resize the f2fs-formatted disk image, while "
"preserving all the files and directories stored in the image."
msgstr ""

#: ../../../filesystems/f2fs.rst:533
msgid ""
"Note: please refer to the manpage of resize.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:536
msgid "defrag.f2fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:537
msgid ""
"The defrag.f2fs can be used to defragment scattered written data as well as "
"filesystem metadata across the disk. This can improve the write speed by "
"giving more free consecutive space."
msgstr ""

#: ../../../filesystems/f2fs.rst:541
msgid ""
"Note: please refer to the manpage of defrag.f2fs(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:544
msgid "f2fs_io"
msgstr ""

#: ../../../filesystems/f2fs.rst:545
msgid ""
"The f2fs_io is a simple tool to issue various filesystem APIs as well as "
"f2fs-specific ones, which is very useful for QA tests."
msgstr ""

#: ../../../filesystems/f2fs.rst:548
msgid ""
"Note: please refer to the manpage of f2fs_io(8) to get full option list."
msgstr ""

#: ../../../filesystems/f2fs.rst:551
msgid "Design"
msgstr ""

#: ../../../filesystems/f2fs.rst:554
msgid "On-disk Layout"
msgstr ""

#: ../../../filesystems/f2fs.rst:556
msgid ""
"F2FS divides the whole volume into a number of segments, each of which is "
"fixed to 2MB in size. A section is composed of consecutive segments, and a "
"zone consists of a set of sections. By default, section and zone sizes are "
"set to one segment size identically, but users can easily modify the sizes "
"by mkfs."
msgstr ""

#: ../../../filesystems/f2fs.rst:561
msgid ""
"F2FS splits the entire volume into six areas, and all the areas except "
"superblock consist of multiple segments as described below::"
msgstr ""

#: ../../../filesystems/f2fs.rst:583
msgid "Superblock (SB)"
msgstr ""

#: ../../../filesystems/f2fs.rst:584
msgid ""
"It is located at the beginning of the partition, and there exist two copies "
"to avoid file system crash. It contains basic partition information and some "
"default parameters of f2fs."
msgstr ""

#: ../../../filesystems/f2fs.rst:588
msgid "Checkpoint (CP)"
msgstr ""

#: ../../../filesystems/f2fs.rst:589
msgid ""
"It contains file system information, bitmaps for valid NAT/SIT sets, orphan "
"inode lists, and summary entries of current active segments."
msgstr ""

#: ../../../filesystems/f2fs.rst:592
msgid "Segment Information Table (SIT)"
msgstr ""

#: ../../../filesystems/f2fs.rst:593
msgid ""
"It contains segment information such as valid block count and bitmap for the "
"validity of all the blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:596
msgid "Node Address Table (NAT)"
msgstr ""

#: ../../../filesystems/f2fs.rst:597
msgid ""
"It is composed of a block address table for all the node blocks stored in "
"Main area."
msgstr ""

#: ../../../filesystems/f2fs.rst:600
msgid "Segment Summary Area (SSA)"
msgstr ""

#: ../../../filesystems/f2fs.rst:601
msgid ""
"It contains summary entries which contains the owner information of all the "
"data and node blocks stored in Main area."
msgstr ""

#: ../../../filesystems/f2fs.rst:604
msgid "Main Area"
msgstr ""

#: ../../../filesystems/f2fs.rst:605
msgid "It contains file and directory data including their indices."
msgstr ""

#: ../../../filesystems/f2fs.rst:607
msgid ""
"In order to avoid misalignment between file system and flash-based storage, "
"F2FS aligns the start block address of CP with the segment size. Also, it "
"aligns the start block address of Main area with the zone size by reserving "
"some segments in SSA area."
msgstr ""

#: ../../../filesystems/f2fs.rst:612
msgid ""
"Reference the following survey for additional technical details. https://"
"wiki.linaro.org/WorkingGroups/Kernel/Projects/FlashCardSurvey"
msgstr ""

#: ../../../filesystems/f2fs.rst:616
msgid "File System Metadata Structure"
msgstr ""

#: ../../../filesystems/f2fs.rst:618
msgid ""
"F2FS adopts the checkpointing scheme to maintain file system consistency. At "
"mount time, F2FS first tries to find the last valid checkpoint data by "
"scanning CP area. In order to reduce the scanning time, F2FS uses only two "
"copies of CP. One of them always indicates the last valid data, which is "
"called as shadow copy mechanism. In addition to CP, NAT and SIT also adopt "
"the shadow copy mechanism."
msgstr ""

#: ../../../filesystems/f2fs.rst:624
msgid ""
"For file system consistency, each CP points to which NAT and SIT copies are "
"valid, as shown as below::"
msgstr ""

#: ../../../filesystems/f2fs.rst:641
msgid "Index Structure"
msgstr ""

#: ../../../filesystems/f2fs.rst:643
msgid ""
"The key data structure to manage the data locations is a \"node\". Similar "
"to traditional file structures, F2FS has three types of node: inode, direct "
"node, indirect node. F2FS assigns 4KB to an inode block which contains 923 "
"data block indices, two direct node pointers, two indirect node pointers, "
"and one double indirect node pointer as described below. One direct node "
"block contains 1018 data blocks, and one indirect node block contains also "
"1018 node blocks. Thus, one inode block (i.e., a file) covers::"
msgstr ""

#: ../../../filesystems/f2fs.rst:665
msgid ""
"Note that all the node blocks are mapped by NAT which means the location of "
"each node is translated by the NAT table. In the consideration of the "
"wandering tree problem, F2FS is able to cut off the propagation of node "
"updates caused by leaf data writes."
msgstr ""

#: ../../../filesystems/f2fs.rst:671
msgid "Directory Structure"
msgstr ""

#: ../../../filesystems/f2fs.rst:673
msgid ""
"A directory entry occupies 11 bytes, which consists of the following "
"attributes."
msgstr ""

#: ../../../filesystems/f2fs.rst:675
msgid "hash          hash value of the file name"
msgstr ""

#: ../../../filesystems/f2fs.rst:676
msgid "ino           inode number"
msgstr ""

#: ../../../filesystems/f2fs.rst:677
msgid "len           the length of file name"
msgstr ""

#: ../../../filesystems/f2fs.rst:678
msgid "type          file type such as directory, symlink, etc"
msgstr ""

#: ../../../filesystems/f2fs.rst:680
msgid ""
"A dentry block consists of 214 dentry slots and file names. Therein a bitmap "
"is used to represent whether each dentry is valid or not. A dentry block "
"occupies 4KB with the following composition."
msgstr ""

#: ../../../filesystems/f2fs.rst:707
msgid ""
"F2FS implements multi-level hash tables for directory structure. Each level "
"has a hash table with dedicated number of hash buckets as shown below. Note "
"that \"A(2B)\" means a bucket includes 2 data blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:729
msgid "The number of blocks and buckets are determined by::"
msgstr ""

#: ../../../filesystems/f2fs.rst:741
msgid ""
"When F2FS finds a file name in a directory, at first a hash value of the "
"file name is calculated. Then, F2FS scans the hash table in level #0 to find "
"the dentry consisting of the file name and its inode number. If not found, "
"F2FS scans the next hash table in level #1. In this way, F2FS scans hash "
"tables in each levels incrementally from 1 to N. In each level F2FS needs to "
"scan only one bucket determined by the following equation, which shows "
"O(log(# of files)) complexity::"
msgstr ""

#: ../../../filesystems/f2fs.rst:751
msgid ""
"In the case of file creation, F2FS finds empty consecutive slots that cover "
"the file name. F2FS searches the empty slots in the hash tables of whole "
"levels from 1 to N in the same way as the lookup operation."
msgstr ""

#: ../../../filesystems/f2fs.rst:755
msgid "The following figure shows an example of two cases holding children::"
msgstr ""

#: ../../../filesystems/f2fs.rst:770
msgid "Default Block Allocation"
msgstr ""

#: ../../../filesystems/f2fs.rst:772
msgid ""
"At runtime, F2FS manages six active logs inside \"Main\" area: Hot/Warm/Cold "
"node and Hot/Warm/Cold data."
msgstr ""

#: ../../../filesystems/f2fs.rst:775
msgid "Hot node      contains direct node blocks of directories."
msgstr ""

#: ../../../filesystems/f2fs.rst:776
msgid "Warm node     contains direct node blocks except hot node blocks."
msgstr ""

#: ../../../filesystems/f2fs.rst:777
msgid "Cold node     contains indirect node blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:778
msgid "Hot data      contains dentry blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:779
msgid "Warm data     contains data blocks except hot and cold data blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:780
msgid "Cold data     contains multimedia data or migrated data blocks"
msgstr ""

#: ../../../filesystems/f2fs.rst:782
msgid ""
"LFS has two schemes for free space management: threaded log and copy-and-"
"compac- tion. The copy-and-compaction scheme which is known as cleaning, is "
"well-suited for devices showing very good sequential write performance, "
"since free segments are served all the time for writing new data. However, "
"it suffers from cleaning overhead under high utilization. Contrarily, the "
"threaded log scheme suffers from random writes, but no cleaning process is "
"needed. F2FS adopts a hybrid scheme where the copy-and-compaction scheme is "
"adopted by default, but the policy is dynamically changed to the threaded "
"log scheme according to the file system status."
msgstr ""

#: ../../../filesystems/f2fs.rst:792
msgid ""
"In order to align F2FS with underlying flash-based storage, F2FS allocates a "
"segment in a unit of section. F2FS expects that the section size would be "
"the same as the unit size of garbage collection in FTL. Furthermore, with "
"respect to the mapping granularity in FTL, F2FS allocates each section of "
"the active logs from different zones as much as possible, since FTL can "
"write the data in the active logs into one allocation unit according to its "
"mapping granularity."
msgstr ""

#: ../../../filesystems/f2fs.rst:800
msgid "Cleaning process"
msgstr ""

#: ../../../filesystems/f2fs.rst:802
msgid ""
"F2FS does cleaning both on demand and in the background. On-demand cleaning "
"is triggered when there are not enough free segments to serve VFS calls. "
"Background cleaner is operated by a kernel thread, and triggers the cleaning "
"job when the system is idle."
msgstr ""

#: ../../../filesystems/f2fs.rst:807
msgid ""
"F2FS supports two victim selection policies: greedy and cost-benefit "
"algorithms. In the greedy algorithm, F2FS selects a victim segment having "
"the smallest number of valid blocks. In the cost-benefit algorithm, F2FS "
"selects a victim segment according to the segment age and the number of "
"valid blocks in order to address log block thrashing problem in the greedy "
"algorithm. F2FS adopts the greedy algorithm for on-demand cleaner, while "
"background cleaner adopts cost-benefit algorithm."
msgstr ""

#: ../../../filesystems/f2fs.rst:815
msgid ""
"In order to identify whether the data in the victim segment are valid or "
"not, F2FS manages a bitmap. Each bit represents the validity of a block, and "
"the bitmap is composed of a bit stream covering whole blocks in main area."
msgstr ""

#: ../../../filesystems/f2fs.rst:820
msgid "Write-hint Policy"
msgstr ""

#: ../../../filesystems/f2fs.rst:822
msgid "F2FS sets the whint all the time with the below policy."
msgstr ""

#: ../../../filesystems/f2fs.rst:825
msgid "User"
msgstr ""

#: ../../../filesystems/f2fs.rst:825
msgid "F2FS"
msgstr ""

#: ../../../filesystems/f2fs.rst:825
msgid "Block"
msgstr ""

#: ../../../filesystems/f2fs.rst:827 ../../../filesystems/f2fs.rst:828
#: ../../../filesystems/f2fs.rst:829 ../../../filesystems/f2fs.rst:830
#: ../../../filesystems/f2fs.rst:836 ../../../filesystems/f2fs.rst:837
#: ../../../filesystems/f2fs.rst:838
msgid "N/A"
msgstr ""

#: ../../../filesystems/f2fs.rst:827
msgid "META"
msgstr ""

#: ../../../filesystems/f2fs.rst:827
msgid "WRITE_LIFE_NONE|REQ_META"
msgstr ""

#: ../../../filesystems/f2fs.rst:828
msgid "HOT_NODE"
msgstr ""

#: ../../../filesystems/f2fs.rst:828 ../../../filesystems/f2fs.rst:845
msgid "WRITE_LIFE_NONE"
msgstr ""

#: ../../../filesystems/f2fs.rst:829
msgid "WARM_NODE"
msgstr ""

#: ../../../filesystems/f2fs.rst:829 ../../../filesystems/f2fs.rst:846
msgid "WRITE_LIFE_MEDIUM"
msgstr ""

#: ../../../filesystems/f2fs.rst:830
msgid "COLD_NODE"
msgstr ""

#: ../../../filesystems/f2fs.rst:830 ../../../filesystems/f2fs.rst:847
msgid "WRITE_LIFE_LONG"
msgstr ""

#: ../../../filesystems/f2fs.rst:831
msgid "ioctl(COLD)"
msgstr ""

#: ../../../filesystems/f2fs.rst:831 ../../../filesystems/f2fs.rst:836
#: ../../../filesystems/f2fs.rst:842
msgid "COLD_DATA"
msgstr ""

#: ../../../filesystems/f2fs.rst:831 ../../../filesystems/f2fs.rst:836
#: ../../../filesystems/f2fs.rst:842
msgid "WRITE_LIFE_EXTREME"
msgstr ""

#: ../../../filesystems/f2fs.rst:832
msgid "extension list"
msgstr ""

#: ../../../filesystems/f2fs.rst:832 ../../../filesystems/f2fs.rst:845
#: ../../../filesystems/f2fs.rst:846 ../../../filesystems/f2fs.rst:847
msgid "\""
msgstr ""

#: ../../../filesystems/f2fs.rst:834
msgid "-- buffered io"
msgstr ""

#: ../../../filesystems/f2fs.rst:837 ../../../filesystems/f2fs.rst:843
msgid "HOT_DATA"
msgstr ""

#: ../../../filesystems/f2fs.rst:837 ../../../filesystems/f2fs.rst:843
msgid "WRITE_LIFE_SHORT"
msgstr ""

#: ../../../filesystems/f2fs.rst:838 ../../../filesystems/f2fs.rst:844
msgid "WARM_DATA"
msgstr ""

#: ../../../filesystems/f2fs.rst:838 ../../../filesystems/f2fs.rst:844
msgid "WRITE_LIFE_NOT_SET"
msgstr ""

#: ../../../filesystems/f2fs.rst:840
msgid "-- direct io"
msgstr ""

#: ../../../filesystems/f2fs.rst:851
msgid "Fallocate(2) Policy"
msgstr ""

#: ../../../filesystems/f2fs.rst:853
msgid "The default policy follows the below POSIX rule."
msgstr ""

#: ../../../filesystems/f2fs.rst:855
msgid "Allocating disk space"
msgstr ""

#: ../../../filesystems/f2fs.rst:856
msgid ""
"The default operation (i.e., mode is zero) of fallocate() allocates the disk "
"space within the range specified by offset and len.  The file size (as "
"reported by stat(2)) will be changed if offset+len is greater than the file "
"size.  Any subregion within the range specified by offset and len that did "
"not contain data before the call will be initialized to zero.  This default "
"behavior closely resembles the behavior of the posix_fallocate(3) library "
"function, and is intended as a method of optimally implementing that "
"function."
msgstr ""

#: ../../../filesystems/f2fs.rst:865
msgid ""
"However, once F2FS receives ioctl(fd, F2FS_IOC_SET_PIN_FILE) in prior to "
"fallocate(fd, DEFAULT_MODE), it allocates on-disk block addresses having "
"zero or random data, which is useful to the below scenario where:"
msgstr ""

#: ../../../filesystems/f2fs.rst:869
msgid "create(fd)"
msgstr ""

#: ../../../filesystems/f2fs.rst:870
msgid "ioctl(fd, F2FS_IOC_SET_PIN_FILE)"
msgstr ""

#: ../../../filesystems/f2fs.rst:871
msgid "fallocate(fd, 0, 0, size)"
msgstr ""

#: ../../../filesystems/f2fs.rst:872
msgid "address = fibmap(fd, offset)"
msgstr ""

#: ../../../filesystems/f2fs.rst:873
msgid "open(blkdev)"
msgstr ""

#: ../../../filesystems/f2fs.rst:874
msgid "write(blkdev, address)"
msgstr ""

#: ../../../filesystems/f2fs.rst:877
msgid "Compression implementation"
msgstr ""

#: ../../../filesystems/f2fs.rst:879
msgid ""
"New term named cluster is defined as basic unit of compression, file can be "
"divided into multiple clusters logically. One cluster includes 4 << n (n >= "
"0) logical pages, compression size is also cluster size, each of cluster can "
"be compressed or not."
msgstr ""

#: ../../../filesystems/f2fs.rst:884
msgid ""
"In cluster metadata layout, one special block address is used to indicate a "
"cluster is a compressed one or normal one; for compressed cluster, following "
"metadata maps cluster to [1, 4 << n - 1] physical blocks, in where f2fs "
"stores data including compress header and compressed data."
msgstr ""

#: ../../../filesystems/f2fs.rst:889
msgid ""
"In order to eliminate write amplification during overwrite, F2FS only "
"support compression on write-once file, data can be compressed only when all "
"logical blocks in cluster contain valid data and compress ratio of cluster "
"data is lower than specified threshold."
msgstr ""

#: ../../../filesystems/f2fs.rst:894
msgid "To enable compression on regular inode, there are four ways:"
msgstr ""

#: ../../../filesystems/f2fs.rst:896
msgid "chattr +c file"
msgstr ""

#: ../../../filesystems/f2fs.rst:897
msgid "chattr +c dir; touch dir/file"
msgstr ""

#: ../../../filesystems/f2fs.rst:898
msgid "mount w/ -o compress_extension=ext; touch file.ext"
msgstr ""

#: ../../../filesystems/f2fs.rst:899
msgid "mount w/ -o compress_extension=*; touch any_file"
msgstr ""

#: ../../../filesystems/f2fs.rst:901
msgid "To disable compression on regular inode, there are two ways:"
msgstr ""

#: ../../../filesystems/f2fs.rst:903
msgid "chattr -c file"
msgstr ""

#: ../../../filesystems/f2fs.rst:904
msgid "mount w/ -o nocompress_extension=ext; touch file.ext"
msgstr ""

#: ../../../filesystems/f2fs.rst:906
msgid "Priority in between FS_COMPR_FL, FS_NOCOMP_FS, extensions:"
msgstr ""

#: ../../../filesystems/f2fs.rst:908
msgid ""
"compress_extension=so; nocompress_extension=zip; chattr +c dir; touch dir/"
"foo.so; touch dir/bar.zip; touch dir/baz.txt; then foo.so and baz.txt should "
"be compresse, bar.zip should be non-compressed. chattr +c dir/bar.zip can "
"enable compress on bar.zip."
msgstr ""

#: ../../../filesystems/f2fs.rst:912
msgid ""
"compress_extension=so; nocompress_extension=zip; chattr -c dir; touch dir/"
"foo.so; touch dir/bar.zip; touch dir/baz.txt; then foo.so should be "
"compresse, bar.zip and baz.txt should be non-compressed. chattr+c dir/bar."
"zip; chattr+c dir/baz.txt; can enable compress on bar.zip and baz.txt."
msgstr ""

#: ../../../filesystems/f2fs.rst:918
msgid ""
"At this point, compression feature doesn't expose compressed space to user "
"directly in order to guarantee potential data updates later to the space. "
"Instead, the main goal is to reduce data writes to flash disk as much as "
"possible, resulting in extending disk life time as well as relaxing IO "
"congestion. Alternatively, we've added "
"ioctl(F2FS_IOC_RELEASE_COMPRESS_BLOCKS) interface to reclaim compressed "
"space and show it to user after setting a special flag to the inode. Once "
"the compressed space is released, the flag will block writing data to the "
"file until either the compressed space is reserved via "
"ioctl(F2FS_IOC_RESERVE_COMPRESS_BLOCKS) or the file size is truncated to "
"zero."
msgstr ""

#: ../../../filesystems/f2fs.rst:929
msgid "Compress metadata layout::"
msgstr ""

#: ../../../filesystems/f2fs.rst:949
msgid "Compression mode"
msgstr ""

#: ../../../filesystems/f2fs.rst:951
msgid ""
"f2fs supports \"fs\" and \"user\" compression modes with "
"\"compression_mode\" mount option. With this option, f2fs provides a choice "
"to select the way how to compress the compression enabled files (refer to "
"\"Compression implementation\" section for how to enable compression on a "
"regular inode)."
msgstr ""

#: ../../../filesystems/f2fs.rst:956
msgid "compress_mode=fs"
msgstr ""

#: ../../../filesystems/f2fs.rst:958
msgid ""
"This is the default option. f2fs does automatic compression in the writeback "
"of the compression enabled files."
msgstr ""

#: ../../../filesystems/f2fs.rst:961
msgid "compress_mode=user"
msgstr ""

#: ../../../filesystems/f2fs.rst:963
msgid ""
"This disables the automatic compression and gives the user discretion of "
"choosing the target file and the timing. The user can do manual compression/"
"decompression on the compression enabled files using "
"F2FS_IOC_DECOMPRESS_FILE and F2FS_IOC_COMPRESS_FILE ioctls like the below."
msgstr ""

#: ../../../filesystems/f2fs.rst:968
msgid "To decompress a file::"
msgstr ""

#: ../../../filesystems/f2fs.rst:973
msgid "To compress a file::"
msgstr ""

#: ../../../filesystems/f2fs.rst:979
msgid "NVMe Zoned Namespace devices"
msgstr ""

#: ../../../filesystems/f2fs.rst:981
msgid ""
"ZNS defines a per-zone capacity which can be equal or less than the zone-"
"size. Zone-capacity is the number of usable blocks in the zone. F2FS checks "
"if zone-capacity is less than zone-size, if it is, then any segment which "
"starts after the zone-capacity is marked as not-free in the free segment "
"bitmap at initial mount time. These segments are marked as permanently used "
"so they are not allocated for writes and consequently are not needed to be "
"garbage collected. In case the zone-capacity is not aligned to default "
"segment size(2MB), then a segment can start before the zone-capacity and "
"span across zone-capacity boundary. Such spanning segments are also "
"considered as usable segments. All blocks past the zone-capacity are "
"considered unusable in these segments."
msgstr ""

#: ../../../filesystems/f2fs.rst:994
msgid "Device aliasing feature"
msgstr ""

#: ../../../filesystems/f2fs.rst:996
msgid ""
"f2fs can utilize a special file called a \"device aliasing file.\" This file "
"allows the entire storage device to be mapped with a single, large extent, "
"not using the usual f2fs node structures. This mapped area is pinned and "
"primarily intended for holding the space."
msgstr ""

#: ../../../filesystems/f2fs.rst:1001
msgid ""
"Essentially, this mechanism allows a portion of the f2fs area to be "
"temporarily reserved and used by another filesystem or for different "
"purposes. Once that external usage is complete, the device aliasing file can "
"be deleted, releasing the reserved space back to F2FS for its own use."
msgstr ""

#: ../../../filesystems/f2fs.rst:1033
msgid ""
"So, the key idea is, user can do any file operations on /dev/vdc, and "
"reclaim the space after the use, while the space is counted as /data. That "
"doesn't require modifying partition size and filesystem format."
msgstr ""
