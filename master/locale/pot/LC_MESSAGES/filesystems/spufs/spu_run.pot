# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/spufs/spu_run.rst:5
msgid "spu_run"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:9
msgid "Name"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:10
msgid "spu_run - execute an spu context"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:14
msgid "Synopsis"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:23
msgid "Description"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:24
msgid ""
"The  spu_run system call is used on PowerPC machines that implement the Cell "
"Broadband Engine Architecture in order to access Synergistic  Pro- cessor  "
"Units  (SPUs).  It  uses the fd that was returned from spu_cre- ate(2) to "
"address a specific SPU context. When the context gets  sched- uled  to a "
"physical SPU, it starts execution at the instruction pointer passed in npc."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:31
msgid ""
"Execution of SPU code happens synchronously, meaning that spu_run  does not  "
"return  while the SPU is still running. If there is a need to exe- cute SPU "
"code in parallel with other code on either  the  main  CPU  or other  SPUs,  "
"you  need to create a new thread of execution first, e.g. using the "
"pthread_create(3) call."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:37
msgid ""
"When spu_run returns, the current value of the SPU instruction  pointer is  "
"written back to npc, so you can call spu_run again without updating the "
"pointers."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:41
msgid ""
"event can be a NULL pointer or point to an extended  status  code  that "
"gets  filled  when spu_run returns. It can be one of the following con- "
"stants:"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:45
msgid "SPE_EVENT_DMA_ALIGNMENT"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:46
msgid "A DMA alignment error"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:48
msgid "SPE_EVENT_SPE_DATA_SEGMENT"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:49
msgid "A DMA segmentation error"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:51
msgid "SPE_EVENT_SPE_DATA_STORAGE"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:52
msgid "A DMA storage error"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:54
msgid ""
"If NULL is passed as the event argument, these errors will result in  a "
"signal delivered to the calling process."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:58
msgid "Return Value"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:59
msgid ""
"spu_run  returns the value of the spu_status register or -1 to indicate an "
"error and set errno to one of the error  codes  listed  below.   The "
"spu_status  register  value  contains  a  bit  mask of status codes and "
"optionally a 14 bit code returned from the stop-and-signal  instruction on "
"the SPU. The bit masks for the status codes are:"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:65
msgid "0x02"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:66
msgid "SPU was stopped by stop-and-signal."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:68
msgid "0x04"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:69
msgid "SPU was stopped by halt."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:71
msgid "0x08"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:72
msgid "SPU is waiting for a channel."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:74
msgid "0x10"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:75
msgid "SPU is in single-step mode."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:77
msgid "0x20"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:78
msgid "SPU has tried to execute an invalid instruction."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:80
msgid "0x40"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:81
msgid "SPU has tried to access an invalid channel."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:83
msgid "0x3fff0000"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:84
msgid ""
"The  bits  masked with this value contain the code returned from stop-and-"
"signal."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:87
msgid ""
"There are always one or more of the lower eight bits set  or  an  error code "
"is returned from spu_run."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:91
msgid "Errors"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:92
msgid "EAGAIN or EWOULDBLOCK"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:93
msgid "fd is in non-blocking mode and spu_run would block."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:95
msgid "EBADF  fd is not a valid file descriptor."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:97
msgid "EFAULT npc is not a valid pointer or status is neither NULL nor a valid"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:98
msgid "pointer."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:100
msgid "EINTR  A signal occurred while spu_run was in progress.  The npc  value"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:101
msgid "has  been updated to the new program counter value if necessary."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:103
msgid "EINVAL fd is not a file descriptor returned from spu_create(2)."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:105
msgid "ENOMEM Insufficient memory was available to handle a page fault result-"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:106
msgid "ing from an MFC direct memory access."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:108
msgid "ENOSYS the functionality is not provided by the current system, because"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:109
msgid ""
"either the hardware does not provide SPUs or the spufs module is not loaded."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:114
msgid "Notes"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:115
msgid ""
"spu_run  is  meant  to  be  used  from  libraries that implement a more "
"abstract interface to SPUs, not to be used from  regular  applications. See  "
"http://www.bsc.es/projects/deepcomputing/linuxoncell/ for the rec- ommended "
"libraries."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:122
msgid "Conforming to"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:123
msgid ""
"This call is Linux specific and only implemented by the ppc64 architec- "
"ture. Programs using this system call are not portable."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:128
msgid "Bugs"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:129
msgid "The code does not yet fully implement all features lined out here."
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:133
msgid "Author"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:134
msgid "Arnd Bergmann <arndb@de.ibm.com>"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:137
msgid "See Also"
msgstr ""

#: ../../../filesystems/spufs/spu_run.rst:138
msgid "capabilities(7), close(2), spu_create(2), spufs(7)"
msgstr ""
