# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../nvme/nvme-pci-endpoint-target.rst:5
msgid "NVMe PCI Endpoint Function Target"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:0
msgid "Author"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:7
msgid "Damien Le Moal <dlemoal@kernel.org>"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:9
msgid ""
"The NVMe PCI endpoint function target driver implements an NVMe PCIe "
"controller using an NVMe fabrics target controller configured with the PCI "
"transport type."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:13
msgid "Overview"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:15
msgid ""
"The NVMe PCI endpoint function target driver allows exposing an NVMe target "
"controller over a PCIe link, thus implementing an NVMe PCIe device similar "
"to a regular M.2 SSD. The target controller is created in the same manner as "
"when using NVMe over fabrics: the controller represents the interface to an "
"NVMe subsystem using a port. The port transfer type must be configured to be "
"\"pci\". The subsystem can be configured to have namespaces backed by "
"regular files or block devices, or can use NVMe passthrough to expose to the "
"PCI host an existing physical NVMe device or an NVMe fabrics host controller "
"(e.g. a NVMe TCP host controller)."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:25
msgid ""
"The NVMe PCI endpoint function target driver relies as much as possible on "
"the NVMe target core code to parse and execute NVMe commands submitted by "
"the PCIe host. However, using the PCI endpoint framework API and DMA API, "
"the driver is also responsible for managing all data transfers over the PCIe "
"link. This implies that the NVMe PCI endpoint function target driver "
"implements several NVMe data structure management and some NVMe command "
"parsing."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:32
msgid ""
"The driver manages retrieval of NVMe commands in submission queues using DMA "
"if supported, or MMIO otherwise. Each command retrieved is then executed "
"using a work item to maximize performance with the parallel execution of "
"multiple commands on different CPUs. The driver uses a work item to "
"constantly poll the doorbell of all submission queues to detect command "
"submissions from the PCIe host."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:39
msgid ""
"The driver transfers completion queues entries of completed commands to the "
"PCIe host using MMIO copy of the entries in the host completion queue. After "
"posting completion entries in a completion queue, the driver uses the PCI "
"endpoint framework API to raise an interrupt to the host to signal the "
"commands completion."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:45
msgid ""
"For any command that has a data buffer, the NVMe PCI endpoint target driver "
"parses the command PRPs or SGLs lists to create a list of PCI address "
"segments representing the mapping of the command data buffer on the host. "
"The command data buffer is transferred over the PCIe link using this list of "
"PCI address segments using DMA, if supported. If DMA is not supported, MMIO "
"is used, which results in poor performance. For write commands, the command "
"data buffer is transferred from the host into a local memory buffer before "
"executing the command using the target core code. For read commands, a local "
"memory buffer is allocated to execute the command and the content of that "
"buffer is transferred to the host once the command completes."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:57
msgid "Controller Capabilities"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:59
msgid ""
"The NVMe capabilities exposed to the PCIe host through the BAR 0 registers "
"are almost identical to the capabilities of the NVMe target controller "
"implemented by the target core code. There are some exceptions."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:63
msgid ""
"The NVMe PCI endpoint target driver always sets the controller capability "
"CQR bit to request \"Contiguous Queues Required\". This is to facilitate the "
"mapping of a queue PCI address range to the local CPU address space."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:67
msgid "The doorbell stride (DSTRB) is always set to be 4B"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:69
msgid ""
"Since the PCI endpoint framework does not provide a way to handle PCI level "
"resets, the controller capability NSSR bit (NVM Subsystem Reset Supported) "
"is always cleared."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:73
msgid ""
"The boot partition support (BPS), Persistent Memory Region Supported (PMRS) "
"and Controller Memory Buffer Supported (CMBS) capabilities are never "
"reported."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:78
msgid "Supported Features"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:80
msgid ""
"The NVMe PCI endpoint target driver implements support for both PRPs and "
"SGLs. The driver also implements IRQ vector coalescing and submission queue "
"arbitration burst."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:84
msgid ""
"The maximum number of queues and the maximum data transfer size (MDTS) are "
"configurable through configfs before starting the controller. To avoid "
"issues with excessive local memory usage for executing commands, MDTS "
"defaults to 512 KB and is limited to a maximum of 2 MB (arbitrary limit)."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:90
msgid "Minimum number of PCI Address Mapping Windows Required"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:92
msgid ""
"Most PCI endpoint controllers provide a limited number of mapping windows "
"for mapping a PCI address range to local CPU memory addresses. The NVMe PCI "
"endpoint target controllers uses mapping windows for the following."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:96
msgid "One memory window for raising MSI or MSI-X interrupts"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:97
msgid "One memory window for MMIO transfers"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:98
msgid "One memory window for each completion queue"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:100
msgid ""
"Given the highly asynchronous nature of the NVMe PCI endpoint target driver "
"operation, the memory windows as described above will generally not be used "
"simultaneously, but that may happen. So a safe maximum number of completion "
"queues that can be supported is equal to the total number of memory mapping "
"windows of the PCI endpoint controller minus two. E.g. for an endpoint PCI "
"controller with 32 outbound memory windows available, up to 30 completion "
"queues can be safely operated without any risk of getting PCI address "
"mapping errors due to the lack of memory windows."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:110
msgid "Maximum Number of Queue Pairs"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:112
msgid ""
"Upon binding of the NVMe PCI endpoint target driver to the PCI endpoint "
"controller, BAR 0 is allocated with enough space to accommodate the admin "
"queue and multiple I/O queues. The maximum of number of I/O queues pairs "
"that can be supported is limited by several factors."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:117
msgid ""
"The NVMe target core code limits the maximum number of I/O queues to the "
"number of online CPUs."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:119
msgid ""
"The total number of queue pairs, including the admin queue, cannot exceed "
"the number of MSI-X or MSI vectors available."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:121
msgid ""
"The total number of completion queues must not exceed the total number of "
"PCI mapping windows minus 2 (see above)."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:124
msgid ""
"The NVMe endpoint function driver allows configuring the maximum number of "
"queue pairs through configfs."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:128
msgid "Limitations and NVMe Specification Non-Compliance"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:130
msgid ""
"Similar to the NVMe target core code, the NVMe PCI endpoint target driver "
"does not support multiple submission queues using the same completion queue. "
"All submission queues must specify a unique completion queue."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:136
msgid "User Guide"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:138
msgid ""
"This section describes the hardware requirements and how to setup an NVMe "
"PCI endpoint target device."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:142
msgid "Kernel Requirements"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:144
msgid ""
"The kernel must be compiled with the configuration options "
"CONFIG_PCI_ENDPOINT, CONFIG_PCI_ENDPOINT_CONFIGFS, and "
"CONFIG_NVME_TARGET_PCI_EPF enabled. CONFIG_PCI, CONFIG_BLK_DEV_NVME and "
"CONFIG_NVME_TARGET must also be enabled (obviously)."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:149
msgid ""
"In addition to this, at least one PCI endpoint controller driver should be "
"available for the endpoint hardware used."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:152
msgid ""
"To facilitate testing, enabling the null-blk driver "
"(CONFIG_BLK_DEV_NULL_BLK) is also recommended. With this, a simple setup "
"using a null_blk block device as a subsystem namespace can be used."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:157
msgid "Hardware Requirements"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:159
msgid ""
"To use the NVMe PCI endpoint target driver, at least one endpoint controller "
"device is required."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:162
msgid "To find the list of endpoint controller devices in the system::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:167
msgid "If PCI_ENDPOINT_CONFIGFS is enabled::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:172
msgid ""
"The endpoint board must of course also be connected to a host with a PCI "
"cable with RX-TX signal swapped. If the host PCI slot used does not have "
"plug-and-play capabilities, the host should be powered off when the NVMe PCI "
"endpoint device is configured."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:178
msgid "NVMe Endpoint Device"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:180
msgid ""
"Creating an NVMe endpoint device is a two step process. First, an NVMe "
"target subsystem and port must be defined. Second, the NVMe PCI endpoint "
"device must be setup and bound to the subsystem and port created."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:185
msgid "Creating an NVMe Subsystem and Port"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:187
msgid ""
"Details about how to configure an NVMe target subsystem and port are outside "
"the scope of this document. The following only provides a simple example of "
"a port and subsystem with a single namespace backed by a null_blk device."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:191
msgid "First, make sure that configfs is enabled::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:195
msgid ""
"Next, create a null_blk device (default settings give a 250 GB device "
"without memory backing). The block device created will be /dev/nullb0 by "
"default::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:202
msgid "The NVMe PCI endpoint function target driver must be loaded::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:210
msgid ""
"Now, create a subsystem and a port that we will use to create a PCI target "
"controller when setting up the NVMe PCI endpoint target device. In this "
"example, the port is created with a maximum of 4 I/O queue pairs::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:222
msgid ""
"Next, create and enable the subsystem namespace using the null_blk block "
"device::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:229
msgid "Finally, create the target port and link it to the subsystem::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:238
msgid "Creating an NVMe PCI Endpoint Device"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:240
msgid ""
"With the NVMe target subsystem and port ready for use, the NVMe PCI endpoint "
"device can now be created and enabled. The NVMe PCI endpoint target driver "
"should already be loaded (that is done automatically when the port is "
"created)::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:247
msgid "Next, create function 0::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:258
msgid ""
"Configure the function using any device ID (the vendor ID for the device "
"will be automatically set to the same value as the NVMe target subsystem "
"vendor ID)::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:266
msgid ""
"If the PCI endpoint controller used does not support MSI-X, MSI can be "
"configured instead::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:271
msgid ""
"Next, let's bind our endpoint device with the target subsystem and port that "
"we created::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:277
msgid ""
"The endpoint function can then be bound to the endpoint controller and the "
"controller started::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:284
msgid ""
"On the endpoint machine, kernel messages will show information as the NVMe "
"target device and endpoint device are created and connected."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:297
msgid "PCI Root-Complex Host"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:299
msgid ""
"Booting the PCI host will result in the initialization of the PCIe link "
"(this may be signaled by the PCI endpoint driver with a kernel message). A "
"kernel message on the endpoint will also signal when the host NVMe driver "
"enables the device controller::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:306
msgid ""
"On the host side, the NVMe PCI endpoint function target device is "
"discoverable as a PCI device, with the vendor ID and device ID as "
"configured::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:312
msgid ""
"An this device will be recognized as an NVMe device with a single namespace::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:318
msgid ""
"The NVMe endpoint block device can then be used as any other regular NVMe "
"namespace block device. The *nvme* command line utility can be used to get "
"more detailed information about the endpoint device::"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:339
msgid "Endpoint Bindings"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:341
msgid ""
"The NVMe PCI endpoint target driver uses the PCI endpoint configfs device "
"attributes as follows."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:345
msgid "vendorid"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:345
msgid "Ignored (the vendor id of the NVMe target subsystem is used)"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:346
msgid "deviceid"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:346
#: ../../../nvme/nvme-pci-endpoint-target.rst:354
msgid "Anything is OK (e.g. PCI_ANY_ID)"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:347
msgid "revid"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:347
#: ../../../nvme/nvme-pci-endpoint-target.rst:351
msgid "Do not care"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:348
msgid "progif_code"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:348
msgid "Must be 0x02 (NVM Express)"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:349
msgid "baseclass_code"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:349
msgid "Must be 0x01 (PCI_BASE_CLASS_STORAGE)"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:350
msgid "subclass_code"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:350
msgid "Must be 0x08 (Non-Volatile Memory controller)"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:351
msgid "cache_line_size"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:352
msgid "subsys_vendor_id"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:352
msgid "Ignored (the subsystem vendor id of the NVMe target subsystem is used)"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:354
msgid "subsys_id"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:355
msgid "msi_interrupts"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:355
#: ../../../nvme/nvme-pci-endpoint-target.rst:356
msgid "At least equal to the number of queue pairs desired"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:356
msgid "msix_interrupts"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:357
msgid "interrupt_pin"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:357
msgid "Interrupt PIN to use if MSI and MSI-X are not supported"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:360
msgid ""
"The NVMe PCI endpoint target function also has some specific configurable "
"fields defined in the *nvme* subdirectory of the function directory. These "
"fields are as follows."
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:365
msgid "mdts_kb"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:365
msgid "Maximum data transfer size in KiB (default: 512)"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:366
msgid "portid"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:366
msgid "The ID of the target port to use"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:367
msgid "subsysnqn"
msgstr ""

#: ../../../nvme/nvme-pci-endpoint-target.rst:367
msgid "The NQN of the target subsystem to use"
msgstr ""
