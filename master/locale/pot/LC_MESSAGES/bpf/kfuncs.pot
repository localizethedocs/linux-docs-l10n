# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/kfuncs.rst:7
msgid "BPF Kernel Functions (kfuncs)"
msgstr ""

#: ../../../bpf/kfuncs.rst:10
msgid "1. Introduction"
msgstr ""

#: ../../../bpf/kfuncs.rst:12
msgid ""
"BPF Kernel Functions or more commonly known as kfuncs are functions in the "
"Linux kernel which are exposed for use by BPF programs. Unlike normal BPF "
"helpers, kfuncs do not have a stable interface and can change from one "
"kernel release to another. Hence, BPF programs need to be updated in "
"response to changes in the kernel. See :ref:"
"`BPF_kfunc_lifecycle_expectations` for more information."
msgstr ""

#: ../../../bpf/kfuncs.rst:19
msgid "2. Defining a kfunc"
msgstr ""

#: ../../../bpf/kfuncs.rst:21
msgid ""
"There are two ways to expose a kernel function to BPF programs, either make "
"an existing function in the kernel visible, or add a new wrapper for BPF. In "
"both cases, care must be taken that BPF program can only call such function "
"in a valid context. To enforce this, visibility of a kfunc can be per "
"program type."
msgstr ""

#: ../../../bpf/kfuncs.rst:26
msgid ""
"If you are not creating a BPF wrapper for existing kernel function, skip "
"ahead to :ref:`BPF_kfunc_nodef`."
msgstr ""

#: ../../../bpf/kfuncs.rst:30
msgid "2.1 Creating a wrapper kfunc"
msgstr ""

#: ../../../bpf/kfuncs.rst:32
msgid ""
"When defining a wrapper kfunc, the wrapper function should have extern "
"linkage. This prevents the compiler from optimizing away dead code, as this "
"wrapper kfunc is not invoked anywhere in the kernel itself. It is not "
"necessary to provide a prototype in a header for the wrapper kfunc."
msgstr ""

#: ../../../bpf/kfuncs.rst:37 ../../../bpf/kfuncs.rst:148
#: ../../../bpf/kfuncs.rst:170 ../../../bpf/kfuncs.rst:187
#: ../../../bpf/kfuncs.rst:214
msgid "An example is given below::"
msgstr ""

#: ../../../bpf/kfuncs.rst:49
msgid ""
"A wrapper kfunc is often needed when we need to annotate parameters of the "
"kfunc. Otherwise one may directly make the kfunc visible to the BPF program "
"by registering it with the BPF subsystem. See :ref:`BPF_kfunc_nodef`."
msgstr ""

#: ../../../bpf/kfuncs.rst:54
msgid "2.2 kfunc Parameters"
msgstr ""

#: ../../../bpf/kfuncs.rst:56
msgid ""
"All kfuncs now require trusted arguments by default. This means that all "
"pointer arguments must be valid, and all pointers to BTF objects must be "
"passed in their unmodified form (at a zero offset, and without having been "
"obtained from walking another pointer, with exceptions described below)."
msgstr ""

#: ../../../bpf/kfuncs.rst:61
msgid ""
"There are two types of pointers to kernel objects which are considered "
"\"trusted\":"
msgstr ""

#: ../../../bpf/kfuncs.rst:63
msgid ""
"Pointers which are passed as tracepoint or struct_ops callback arguments."
msgstr ""

#: ../../../bpf/kfuncs.rst:64
msgid "Pointers which were returned from a KF_ACQUIRE kfunc."
msgstr ""

#: ../../../bpf/kfuncs.rst:66
msgid ""
"Pointers to non-BTF objects (e.g. scalar pointers) may also be passed to "
"kfuncs, and may have a non-zero offset."
msgstr ""

#: ../../../bpf/kfuncs.rst:69
msgid ""
"The definition of \"valid\" pointers is subject to change at any time, and "
"has absolutely no ABI stability guarantees."
msgstr ""

#: ../../../bpf/kfuncs.rst:72
msgid ""
"As mentioned above, a nested pointer obtained from walking a trusted pointer "
"is no longer trusted, with one exception. If a struct type has a field that "
"is guaranteed to be valid (trusted or rcu, as in KF_RCU description below) "
"as long as its parent pointer is valid, the following macros can be used to "
"express that to the verifier:"
msgstr ""

#: ../../../bpf/kfuncs.rst:78
msgid "``BTF_TYPE_SAFE_TRUSTED``"
msgstr ""

#: ../../../bpf/kfuncs.rst:79
msgid "``BTF_TYPE_SAFE_RCU``"
msgstr ""

#: ../../../bpf/kfuncs.rst:80
msgid "``BTF_TYPE_SAFE_RCU_OR_NULL``"
msgstr ""

#: ../../../bpf/kfuncs.rst:82
msgid "For example,"
msgstr ""

#: ../../../bpf/kfuncs.rst:90
msgid "or"
msgstr ""

#: ../../../bpf/kfuncs.rst:101
msgid "In other words, you must:"
msgstr ""

#: ../../../bpf/kfuncs.rst:103
msgid "Wrap the valid pointer type in a ``BTF_TYPE_SAFE_*`` macro."
msgstr ""

#: ../../../bpf/kfuncs.rst:105
msgid ""
"Specify the type and name of the valid nested field. This field must match "
"the field in the original type definition exactly."
msgstr ""

#: ../../../bpf/kfuncs.rst:108
msgid ""
"A new type declared by a ``BTF_TYPE_SAFE_*`` macro also needs to be emitted "
"so that it appears in BTF. For example, ``BTF_TYPE_SAFE_TRUSTED(struct "
"socket)`` is emitted in the ``type_is_trusted()`` function as follows:"
msgstr ""

#: ../../../bpf/kfuncs.rst:117
msgid "2.3 Annotating kfunc parameters"
msgstr ""

#: ../../../bpf/kfuncs.rst:119
msgid ""
"Similar to BPF helpers, there is sometime need for additional context "
"required by the verifier to make the usage of kernel functions safer and "
"more useful. Hence, we can annotate a parameter by suffixing the name of the "
"argument of the kfunc with a __tag, where tag may be one of the supported "
"annotations."
msgstr ""

#: ../../../bpf/kfuncs.rst:125
msgid "2.3.1 __sz Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:127
msgid ""
"This annotation is used to indicate a memory and size pair in the argument "
"list. An example is given below::"
msgstr ""

#: ../../../bpf/kfuncs.rst:135
msgid ""
"Here, the verifier will treat first argument as a PTR_TO_MEM, and second "
"argument as its size. By default, without __sz annotation, the size of the "
"type of the pointer is used. Without __sz annotation, a kfunc cannot accept "
"a void pointer."
msgstr ""

#: ../../../bpf/kfuncs.rst:141
msgid "2.3.2 __k Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:143
msgid ""
"This annotation is only understood for scalar arguments, where it indicates "
"that the verifier must check the scalar argument to be a known constant, "
"which does not indicate a size parameter, and the value of the constant is "
"relevant to the safety of the program."
msgstr ""

#: ../../../bpf/kfuncs.rst:155
msgid ""
"Here, bpf_obj_new uses local_type_id argument to find out the size of that "
"type ID in program's BTF and return a sized pointer to it. Each type ID will "
"have a distinct size, hence it is crucial to treat each such call as "
"distinct when values don't match during verifier state pruning checks."
msgstr ""

#: ../../../bpf/kfuncs.rst:160
msgid ""
"Hence, whenever a constant scalar argument is accepted by a kfunc which is "
"not a size parameter, and the value of the constant matters for program "
"safety, __k suffix should be used."
msgstr ""

#: ../../../bpf/kfuncs.rst:165
msgid "2.3.3 __uninit Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:167
msgid ""
"This annotation is used to indicate that the argument will be treated as "
"uninitialized."
msgstr ""

#: ../../../bpf/kfuncs.rst:177
msgid ""
"Here, the dynptr will be treated as an uninitialized dynptr. Without this "
"annotation, the verifier will reject the program if the dynptr passed in is "
"not initialized."
msgstr ""

#: ../../../bpf/kfuncs.rst:182
msgid "2.3.4 __nullable Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:184
msgid ""
"This annotation is used to indicate that the pointer argument may be NULL. "
"The verifier will allow passing NULL for such arguments."
msgstr ""

#: ../../../bpf/kfuncs.rst:194
msgid ""
"Here, the task pointer may be NULL. The kfunc is responsible for checking if "
"the pointer is NULL before dereferencing it."
msgstr ""

#: ../../../bpf/kfuncs.rst:197
msgid ""
"The __nullable annotation can be combined with other annotations. For "
"example, when used with __sz or __szk annotations for memory and size pairs, "
"the verifier will skip size validation when a NULL pointer is passed, but "
"will still process the size argument to extract constant size information "
"when needed::"
msgstr ""

#: ../../../bpf/kfuncs.rst:206
msgid ""
"Here, the buffer may be NULL. If the buffer is not NULL, it must be at least "
"buffer__szk bytes in size. The kfunc is responsible for checking if the "
"buffer is NULL before using it."
msgstr ""

#: ../../../bpf/kfuncs.rst:211
msgid "2.3.5 __str Annotation"
msgstr ""

#: ../../../bpf/kfuncs.rst:212
msgid ""
"This annotation is used to indicate that the argument is a constant string."
msgstr ""

#: ../../../bpf/kfuncs.rst:221
msgid "In this case, ``bpf_get_file_xattr()`` can be called as::"
msgstr ""

#: ../../../bpf/kfuncs.rst:225
msgid "Or::"
msgstr ""

#: ../../../bpf/kfuncs.rst:238
msgid "2.4 Using an existing kernel function"
msgstr ""

#: ../../../bpf/kfuncs.rst:240
msgid ""
"When an existing function in the kernel is fit for consumption by BPF "
"programs, it can be directly registered with the BPF subsystem. However, "
"care must still be taken to review the context in which it will be invoked "
"by the BPF program and whether it is safe to do so."
msgstr ""

#: ../../../bpf/kfuncs.rst:246
msgid "2.5 Annotating kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:248
msgid ""
"In addition to kfuncs' arguments, verifier may need more information about "
"the type of kfunc(s) being registered with the BPF subsystem. To do so, we "
"define flags on a set of kfuncs as follows::"
msgstr ""

#: ../../../bpf/kfuncs.rst:257
msgid ""
"This set encodes the BTF ID of each kfunc listed above, and encodes the "
"flags along with it. Ofcourse, it is also allowed to specify no flags."
msgstr ""

#: ../../../bpf/kfuncs.rst:260
msgid ""
"kfunc definitions should also always be annotated with the ``__bpf_kfunc`` "
"macro. This prevents issues such as the compiler inlining the kfunc if it's "
"a static kernel function, or the function being elided in an LTO build as "
"it's not used in the rest of the kernel. Developers should not manually add "
"annotations to their kfunc to prevent these issues. If an annotation is "
"required to prevent such an issue with your kfunc, it is a bug and should be "
"added to the definition of the macro so that other kfuncs are similarly "
"protected. An example is given below::"
msgstr ""

#: ../../../bpf/kfuncs.rst:275
msgid "2.5.1 KF_ACQUIRE flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:277
msgid ""
"The KF_ACQUIRE flag is used to indicate that the kfunc returns a pointer to "
"a refcounted object. The verifier will then ensure that the pointer to the "
"object is eventually released using a release kfunc, or transferred to a map "
"using a referenced kptr (by invoking bpf_kptr_xchg). If not, the verifier "
"fails the loading of the BPF program until no lingering references remain in "
"all possible explored states of the program."
msgstr ""

#: ../../../bpf/kfuncs.rst:285
msgid "2.5.2 KF_RET_NULL flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:287
msgid ""
"The KF_RET_NULL flag is used to indicate that the pointer returned by the "
"kfunc may be NULL. Hence, it forces the user to do a NULL check on the "
"pointer returned from the kfunc before making use of it (dereferencing or "
"passing to another helper). This flag is often used in pairing with "
"KF_ACQUIRE flag, but both are orthogonal to each other."
msgstr ""

#: ../../../bpf/kfuncs.rst:294
msgid "2.5.3 KF_RELEASE flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:296
msgid ""
"The KF_RELEASE flag is used to indicate that the kfunc releases the pointer "
"passed in to it. There can be only one referenced pointer that can be passed "
"in. All copies of the pointer being released are invalidated as a result of "
"invoking kfunc with this flag."
msgstr ""

#: ../../../bpf/kfuncs.rst:302
msgid "2.5.4 KF_SLEEPABLE flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:304
msgid ""
"The KF_SLEEPABLE flag is used for kfuncs that may sleep. Such kfuncs can "
"only be called by sleepable BPF programs (BPF_F_SLEEPABLE)."
msgstr ""

#: ../../../bpf/kfuncs.rst:308
msgid "2.5.5 KF_DESTRUCTIVE flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:310
msgid ""
"The KF_DESTRUCTIVE flag is used to indicate functions calling which is "
"destructive to the system. For example such a call can result in system "
"rebooting or panicking. Due to this additional restrictions apply to these "
"calls. At the moment they only require CAP_SYS_BOOT capability, but more can "
"be added later."
msgstr ""

#: ../../../bpf/kfuncs.rst:317
msgid "2.5.6 KF_RCU flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:319
msgid ""
"The KF_RCU flag allows kfuncs to opt out of the default trusted args "
"requirement and accept RCU pointers with weaker guarantees. The kfuncs "
"marked with KF_RCU expect either PTR_TRUSTED or MEM_RCU arguments. The "
"verifier guarantees that the objects are valid and there is no use-after-"
"free. The pointers are not NULL, but the object's refcount could have "
"reached zero. The kfuncs need to consider doing refcnt != 0 check, "
"especially when returning a KF_ACQUIRE pointer. Note as well that a "
"KF_ACQUIRE kfunc that is KF_RCU should very likely also be KF_RET_NULL."
msgstr ""

#: ../../../bpf/kfuncs.rst:329
msgid "2.5.7 KF_RCU_PROTECTED flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:331
msgid ""
"The KF_RCU_PROTECTED flag is used to indicate that the kfunc must be invoked "
"in an RCU critical section. This is assumed by default in non-sleepable "
"programs, and must be explicitly ensured by calling ``bpf_rcu_read_lock`` "
"for sleepable ones."
msgstr ""

#: ../../../bpf/kfuncs.rst:336
msgid ""
"If the kfunc returns a pointer value, this flag also enforces that the "
"returned pointer is RCU protected, and can only be used while the RCU "
"critical section is active."
msgstr ""

#: ../../../bpf/kfuncs.rst:340
msgid ""
"The flag is distinct from the ``KF_RCU`` flag, which only ensures that its "
"arguments are at least RCU protected pointers. This may transitively imply "
"that RCU protection is ensured, but it does not work in cases of kfuncs "
"which require RCU protection but do not take RCU protected arguments."
msgstr ""

#: ../../../bpf/kfuncs.rst:348
msgid "2.5.8 KF_DEPRECATED flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:350
msgid ""
"The KF_DEPRECATED flag is used for kfuncs which are scheduled to be changed "
"or removed in a subsequent kernel release. A kfunc that is marked with "
"KF_DEPRECATED should also have any relevant information captured in its "
"kernel doc. Such information typically includes the kfunc's expected "
"remaining lifespan, a recommendation for new functionality that can replace "
"it if any is available, and possibly a rationale for why it is being removed."
msgstr ""

#: ../../../bpf/kfuncs.rst:358
msgid ""
"Note that while on some occasions, a KF_DEPRECATED kfunc may continue to be "
"supported and have its KF_DEPRECATED flag removed, it is likely to be far "
"more difficult to remove a KF_DEPRECATED flag after it's been added than it "
"is to prevent it from being added in the first place. As described in :ref:"
"`BPF_kfunc_lifecycle_expectations`, users that rely on specific kfuncs are "
"encouraged to make their use-cases known as early as possible, and "
"participate in upstream discussions regarding whether to keep, change, "
"deprecate, or remove those kfuncs if and when such discussions occur."
msgstr ""

#: ../../../bpf/kfuncs.rst:368
msgid "2.5.9 KF_IMPLICIT_ARGS flag"
msgstr ""

#: ../../../bpf/kfuncs.rst:370
msgid ""
"The KF_IMPLICIT_ARGS flag is used to indicate that the BPF signature of the "
"kfunc is different from it's kernel signature, and the values for implicit "
"arguments are provided at load time by the verifier."
msgstr ""

#: ../../../bpf/kfuncs.rst:374
msgid ""
"Only arguments of specific types are implicit. Currently only ``struct "
"bpf_prog_aux *`` type is supported."
msgstr ""

#: ../../../bpf/kfuncs.rst:377
msgid ""
"A kfunc with KF_IMPLICIT_ARGS flag therefore has two types in BTF: one "
"function matching the kernel declaration (with _impl suffix in the name by "
"convention), and another matching the intended BPF API."
msgstr ""

#: ../../../bpf/kfuncs.rst:381
msgid ""
"Verifier only allows calls to the non-_impl version of a kfunc, that uses a "
"signature without the implicit arguments."
msgstr ""

#: ../../../bpf/kfuncs.rst:384
msgid "Example declaration:"
msgstr ""

#: ../../../bpf/kfuncs.rst:392
msgid "Example usage in BPF program:"
msgstr ""

#: ../../../bpf/kfuncs.rst:400
msgid "2.6 Registering the kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:402
msgid ""
"Once the kfunc is prepared for use, the final step to making it visible is "
"registering it with the BPF subsystem. Registration is done per BPF program "
"type. An example is shown below::"
msgstr ""

#: ../../../bpf/kfuncs.rst:423
msgid "2.7  Specifying no-cast aliases with ___init"
msgstr ""

#: ../../../bpf/kfuncs.rst:425
msgid ""
"The verifier will always enforce that the BTF type of a pointer passed to a "
"kfunc by a BPF program, matches the type of pointer specified in the kfunc "
"definition. The verifier, does, however, allow types that are equivalent "
"according to the C standard to be passed to the same kfunc arg, even if "
"their BTF_IDs differ."
msgstr ""

#: ../../../bpf/kfuncs.rst:431
msgid "For example, for the following type definition:"
msgstr ""

#: ../../../bpf/kfuncs.rst:440
msgid ""
"The verifier would allow a ``struct bpf_cpumask *`` to be passed to a kfunc "
"taking a ``cpumask_t *`` (which is a typedef of ``struct cpumask *``). For "
"instance, both ``struct cpumask *`` and ``struct bpf_cpmuask *`` can be "
"passed to bpf_cpumask_test_cpu()."
msgstr ""

#: ../../../bpf/kfuncs.rst:445
msgid ""
"In some cases, this type-aliasing behavior is not desired. ``struct "
"nf_conn___init`` is one such example:"
msgstr ""

#: ../../../bpf/kfuncs.rst:454
msgid ""
"The C standard would consider these types to be equivalent, but it would not "
"always be safe to pass either type to a trusted kfunc. ``struct "
"nf_conn___init`` represents an allocated ``struct nf_conn`` object that has "
"*not yet been initialized*, so it would therefore be unsafe to pass a "
"``struct nf_conn___init *`` to a kfunc that's expecting a fully initialized "
"``struct nf_conn *`` (e.g. ``bpf_ct_change_timeout()``)."
msgstr ""

#: ../../../bpf/kfuncs.rst:461
msgid ""
"In order to accommodate such requirements, the verifier will enforce strict "
"PTR_TO_BTF_ID type matching if two types have the exact same name, with one "
"being suffixed with ``___init``."
msgstr ""

#: ../../../bpf/kfuncs.rst:468
msgid "3. kfunc lifecycle expectations"
msgstr ""

#: ../../../bpf/kfuncs.rst:470
msgid ""
"kfuncs provide a kernel <-> kernel API, and thus are not bound by any of the "
"strict stability restrictions associated with kernel <-> user UAPIs. This "
"means they can be thought of as similar to EXPORT_SYMBOL_GPL, and can "
"therefore be modified or removed by a maintainer of the subsystem they're "
"defined in when it's deemed necessary."
msgstr ""

#: ../../../bpf/kfuncs.rst:476
msgid ""
"Like any other change to the kernel, maintainers will not change or remove a "
"kfunc without having a reasonable justification.  Whether or not they'll "
"choose to change a kfunc will ultimately depend on a variety of factors, "
"such as how widely used the kfunc is, how long the kfunc has been in the "
"kernel, whether an alternative kfunc exists, what the norm is in terms of "
"stability for the subsystem in question, and of course what the technical "
"cost is of continuing to support the kfunc."
msgstr ""

#: ../../../bpf/kfuncs.rst:484
msgid "There are several implications of this:"
msgstr ""

#: ../../../bpf/kfuncs.rst:486
msgid ""
"kfuncs that are widely used or have been in the kernel for a long time will "
"be more difficult to justify being changed or removed by a maintainer. In "
"other words, kfuncs that are known to have a lot of users and provide "
"significant value provide stronger incentives for maintainers to invest the "
"time and complexity in supporting them. It is therefore important for "
"developers that are using kfuncs in their BPF programs to communicate and "
"explain how and why those kfuncs are being used, and to participate in "
"discussions regarding those kfuncs when they occur upstream."
msgstr ""

#: ../../../bpf/kfuncs.rst:495
msgid ""
"Unlike regular kernel symbols marked with EXPORT_SYMBOL_GPL, BPF programs "
"that call kfuncs are generally not part of the kernel tree. This means that "
"refactoring cannot typically change callers in-place when a kfunc changes, "
"as is done for e.g. an upstreamed driver being updated in place when a "
"kernel symbol is changed."
msgstr ""

#: ../../../bpf/kfuncs.rst:501
msgid ""
"Unlike with regular kernel symbols, this is expected behavior for BPF "
"symbols, and out-of-tree BPF programs that use kfuncs should be considered "
"relevant to discussions and decisions around modifying and removing those "
"kfuncs. The BPF community will take an active role in participating in "
"upstream discussions when necessary to ensure that the perspectives of such "
"users are taken into account."
msgstr ""

#: ../../../bpf/kfuncs.rst:508
msgid ""
"A kfunc will never have any hard stability guarantees. BPF APIs cannot and "
"will not ever hard-block a change in the kernel purely for stability "
"reasons. That being said, kfuncs are features that are meant to solve "
"problems and provide value to users. The decision of whether to change or "
"remove a kfunc is a multivariate technical decision that is made on a case-"
"by-case basis, and which is informed by data points such as those mentioned "
"above. It is expected that a kfunc being removed or changed with no warning "
"will not be a common occurrence or take place without sound justification, "
"but it is a possibility that must be accepted if one is to use kfuncs."
msgstr ""

#: ../../../bpf/kfuncs.rst:520
msgid "3.1 kfunc deprecation"
msgstr ""

#: ../../../bpf/kfuncs.rst:522
msgid ""
"As described above, while sometimes a maintainer may find that a kfunc must "
"be changed or removed immediately to accommodate some changes in their "
"subsystem, usually kfuncs will be able to accommodate a longer and more "
"measured deprecation process. For example, if a new kfunc comes along which "
"provides superior functionality to an existing kfunc, the existing kfunc may "
"be deprecated for some period of time to allow users to migrate their BPF "
"programs to use the new one. Or, if a kfunc has no known users, a decision "
"may be made to remove the kfunc (without providing an alternative API) after "
"some deprecation period so as to provide users with a window to notify the "
"kfunc maintainer if it turns out that the kfunc is actually being used."
msgstr ""

#: ../../../bpf/kfuncs.rst:533
msgid ""
"It's expected that the common case will be that kfuncs will go through a "
"deprecation period rather than being changed or removed without warning. As "
"described in :ref:`KF_deprecated_flag`, the kfunc framework provides the "
"KF_DEPRECATED flag to kfunc developers to signal to users that a kfunc has "
"been deprecated. Once a kfunc has been marked with KF_DEPRECATED, the "
"following procedure is followed for removal:"
msgstr ""

#: ../../../bpf/kfuncs.rst:540
msgid ""
"Any relevant information for deprecated kfuncs is documented in the kfunc's "
"kernel docs. This documentation will typically include the kfunc's expected "
"remaining lifespan, a recommendation for new functionality that can replace "
"the usage of the deprecated function (or an explanation as to why no such "
"replacement exists), etc."
msgstr ""

#: ../../../bpf/kfuncs.rst:546
msgid ""
"The deprecated kfunc is kept in the kernel for some period of time after it "
"was first marked as deprecated. This time period will be chosen on a case-by-"
"case basis, and will typically depend on how widespread the use of the kfunc "
"is, how long it has been in the kernel, and how hard it is to move to "
"alternatives. This deprecation time period is \"best effort\", and as "
"described :ref:`above<BPF_kfunc_lifecycle_expectations>`, circumstances may "
"sometimes dictate that the kfunc be removed before the full intended "
"deprecation period has elapsed."
msgstr ""

#: ../../../bpf/kfuncs.rst:555
msgid ""
"After the deprecation period the kfunc will be removed. At this point, BPF "
"programs calling the kfunc will be rejected by the verifier."
msgstr ""

#: ../../../bpf/kfuncs.rst:559
msgid "4. Core kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:561
msgid ""
"The BPF subsystem provides a number of \"core\" kfuncs that are potentially "
"applicable to a wide variety of different possible use cases and programs. "
"Those kfuncs are documented here."
msgstr ""

#: ../../../bpf/kfuncs.rst:566
msgid "4.1 struct task_struct * kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:568
msgid ""
"There are a number of kfuncs that allow ``struct task_struct *`` objects to "
"be used as kptrs:"
msgstr ""

#: ../../../bpf/kfuncs:571: ../kernel/bpf/helpers.c:2583
msgid ""
"Acquire a reference to a task. A task acquired by this kfunc which is not "
"stored in a map as a kptr, must be released by calling bpf_task_release()."
msgstr ""

#: ../../../bpf/kfuncs:571: ../kernel/bpf/helpers.c:2587
#: ../kernel/bpf/helpers.c:2600 ../../../bpf/kfuncs:643:
#: ../kernel/bpf/helpers.c:2746 ../../../bpf/kfuncs:683:
#: ../kernel/bpf/helpers.c:2616 ../kernel/bpf/helpers.c:2627
#: ../../../bpf/kfuncs:696: ../kernel/bpf/helpers.c:2645
#: ../../../bpf/kfuncs:699: ../kernel/bpf/helpers.c:2666
msgid "**Parameters**"
msgstr ""

#: ../../../bpf/kfuncs:571: ../kernel/bpf/helpers.c:2589
#: ../kernel/bpf/helpers.c:2602
msgid "``struct task_struct *p``"
msgstr ""

#: ../../../bpf/kfuncs:571: ../kernel/bpf/helpers.c:2586
msgid "The task on which a reference is being acquired."
msgstr ""

#: ../../../bpf/kfuncs:571: ../kernel/bpf/helpers.c:2596
msgid "Release the reference acquired on a task."
msgstr ""

#: ../../../bpf/kfuncs:571: ../kernel/bpf/helpers.c:2597
msgid "The task on which a reference is being released."
msgstr ""

#: ../../../bpf/kfuncs.rst:574
msgid ""
"These kfuncs are useful when you want to acquire or release a reference to a "
"``struct task_struct *`` that was passed as e.g. a tracepoint arg, or a "
"struct_ops callback arg. For example:"
msgstr ""

#: ../../../bpf/kfuncs.rst:601
msgid ""
"References acquired on ``struct task_struct *`` objects are RCU protected. "
"Therefore, when in an RCU read region, you can obtain a pointer to a task "
"embedded in a map value without having to acquire a reference:"
msgstr ""

#: ../../../bpf/kfuncs.rst:639
msgid ""
"A BPF program can also look up a task from a pid. This can be useful if the "
"caller doesn't have a trusted pointer to a ``struct task_struct *`` object "
"that it can acquire a reference on with bpf_task_acquire()."
msgstr ""

#: ../../../bpf/kfuncs:643: ../kernel/bpf/helpers.c:2742
msgid ""
"Find a struct task_struct from its pid by looking it up in the root pid "
"namespace idr. If a task is returned, it must either be stored in a map, or "
"released with bpf_task_release()."
msgstr ""

#: ../../../bpf/kfuncs:643: ../kernel/bpf/helpers.c:2748
msgid "``s32 pid``"
msgstr ""

#: ../../../bpf/kfuncs:643: ../kernel/bpf/helpers.c:2745
msgid "The pid of the task being looked up."
msgstr ""

#: ../../../bpf/kfuncs.rst:646
msgid "Here is an example of it being used:"
msgstr ""

#: ../../../bpf/kfuncs.rst:679
msgid "4.2 struct cgroup * kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:681
msgid "``struct cgroup *`` objects also have acquire and release functions:"
msgstr ""

#: ../../../bpf/kfuncs:683: ../kernel/bpf/helpers.c:2612
msgid ""
"Acquire a reference to a cgroup. A cgroup acquired by this kfunc which is "
"not stored in a map as a kptr, must be released by calling "
"bpf_cgroup_release()."
msgstr ""

#: ../../../bpf/kfuncs:683: ../kernel/bpf/helpers.c:2618
#: ../kernel/bpf/helpers.c:2629 ../../../bpf/kfuncs:696:
#: ../kernel/bpf/helpers.c:2647
msgid "``struct cgroup *cgrp``"
msgstr ""

#: ../../../bpf/kfuncs:683: ../kernel/bpf/helpers.c:2615
msgid "The cgroup on which a reference is being acquired."
msgstr ""

#: ../../../bpf/kfuncs:683: ../kernel/bpf/helpers.c:2623
msgid ""
"Release the reference acquired on a cgroup. If this kfunc is invoked in an "
"RCU read region, the cgroup is guaranteed to not be freed until the current "
"grace period has ended, even if its refcount drops to 0."
msgstr ""

#: ../../../bpf/kfuncs:683: ../kernel/bpf/helpers.c:2627
msgid "The cgroup on which a reference is being released."
msgstr ""

#: ../../../bpf/kfuncs.rst:686
msgid ""
"These kfuncs are used in exactly the same manner as bpf_task_acquire() and "
"bpf_task_release() respectively, so we won't provide examples for them."
msgstr ""

#: ../../../bpf/kfuncs.rst:691
msgid ""
"Other kfuncs available for interacting with ``struct cgroup *`` objects are "
"bpf_cgroup_ancestor() and bpf_cgroup_from_id(), allowing callers to access "
"the ancestor of a cgroup and find a cgroup by its ID, respectively. Both "
"return a cgroup kptr."
msgstr ""

#: ../../../bpf/kfuncs:696: ../kernel/bpf/helpers.c:2641
msgid ""
"Perform a lookup on an entry in a cgroup's ancestor array. A cgroup returned "
"by this kfunc which is not subsequently stored in a map, must be released by "
"calling bpf_cgroup_release()."
msgstr ""

#: ../../../bpf/kfuncs:696: ../kernel/bpf/helpers.c:2644
msgid "The cgroup for which we're performing a lookup."
msgstr ""

#: ../../../bpf/kfuncs:696: ../kernel/bpf/helpers.c:2646
msgid "``int level``"
msgstr ""

#: ../../../bpf/kfuncs:696: ../kernel/bpf/helpers.c:2645
msgid "The level of ancestor to look up."
msgstr ""

#: ../../../bpf/kfuncs:699: ../kernel/bpf/helpers.c:2662
msgid ""
"Find a cgroup from its ID. A cgroup returned by this kfunc which is not "
"subsequently stored in a map, must be released by calling "
"bpf_cgroup_release()."
msgstr ""

#: ../../../bpf/kfuncs:699: ../kernel/bpf/helpers.c:2668
msgid "``u64 cgid``"
msgstr ""

#: ../../../bpf/kfuncs:699: ../kernel/bpf/helpers.c:2665
msgid "cgroup id."
msgstr ""

#: ../../../bpf/kfuncs.rst:702
msgid ""
"Eventually, BPF should be updated to allow this to happen with a normal "
"memory load in the program itself. This is currently not possible without "
"more work in the verifier. bpf_cgroup_ancestor() can be used as follows:"
msgstr ""

#: ../../../bpf/kfuncs.rst:730
msgid "4.3 struct cpumask * kfuncs"
msgstr ""

#: ../../../bpf/kfuncs.rst:732
msgid ""
"BPF provides a set of kfuncs that can be used to query, allocate, mutate, "
"and destroy struct cpumask * objects. Please refer to :ref:`cpumasks-header-"
"label` for more details."
msgstr ""
