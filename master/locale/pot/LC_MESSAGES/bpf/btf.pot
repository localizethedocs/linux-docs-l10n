# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/btf.rst:3
msgid "BPF Type Format (BTF)"
msgstr ""

#: ../../../bpf/btf.rst:6
msgid "1. Introduction"
msgstr ""

#: ../../../bpf/btf.rst:8
msgid ""
"BTF (BPF Type Format) is the metadata format which encodes the debug info "
"related to BPF program/map. The name BTF was used initially to describe data "
"types. The BTF was later extended to include function info for defined "
"subroutines, and line info for source/line information."
msgstr ""

#: ../../../bpf/btf.rst:13
msgid ""
"The debug info is used for map pretty print, function signature, etc. The "
"function signature enables better bpf program/function kernel symbol. The "
"line info helps generate source annotated translated byte code, jited code "
"and verifier log."
msgstr ""

#: ../../../bpf/btf.rst:18
msgid "The BTF specification contains two parts,"
msgstr ""

#: ../../../bpf/btf.rst:19
msgid "BTF kernel API"
msgstr ""

#: ../../../bpf/btf.rst:20
msgid "BTF ELF file format"
msgstr ""

#: ../../../bpf/btf.rst:22
msgid ""
"The kernel API is the contract between user space and kernel. The kernel "
"verifies the BTF info before using it. The ELF file format is a user space "
"contract between ELF file and libbpf loader."
msgstr ""

#: ../../../bpf/btf.rst:26
msgid ""
"The type and string sections are part of the BTF kernel API, describing the "
"debug info (mostly types related) referenced by the bpf program. These two "
"sections are discussed in details in :ref:`BTF_Type_String`."
msgstr ""

#: ../../../bpf/btf.rst:33
msgid "2. BTF Type and String Encoding"
msgstr ""

#: ../../../bpf/btf.rst:35
msgid ""
"The file ``include/uapi/linux/btf.h`` provides high-level definition of how "
"types/strings are encoded."
msgstr ""

#: ../../../bpf/btf.rst:38
msgid "The beginning of data blob must be::"
msgstr ""

#: ../../../bpf/btf.rst:53
msgid ""
"The magic is ``0xeB9F``, which has different encoding for big and little "
"endian systems, and can be used to test whether BTF is generated for big- or "
"little-endian target. The ``btf_header`` is designed to be extensible with "
"``hdr_len`` equal to ``sizeof(struct btf_header)`` when a data blob is "
"generated."
msgstr ""

#: ../../../bpf/btf.rst:60
msgid "2.1 String Encoding"
msgstr ""

#: ../../../bpf/btf.rst:62
msgid ""
"The first string in the string section must be a null string. The rest of "
"string table is a concatenation of other null-terminated strings."
msgstr ""

#: ../../../bpf/btf.rst:66
msgid "2.2 Type Encoding"
msgstr ""

#: ../../../bpf/btf.rst:68
msgid ""
"The type id ``0`` is reserved for ``void`` type. The type section is parsed "
"sequentially and type id is assigned to each recognized type starting from "
"id ``1``. Currently, the following types are supported::"
msgstr ""

#: ../../../bpf/btf.rst:92
msgid ""
"Note that the type section encodes debug info, not just pure types. "
"``BTF_KIND_FUNC`` is not a type, and it represents a defined subprogram."
msgstr ""

#: ../../../bpf/btf.rst:95
msgid "Each type contains the following common data::"
msgstr ""

#: ../../../bpf/btf.rst:122
msgid ""
"For certain kinds, the common data are followed by kind-specific data. The "
"``name_off`` in ``struct btf_type`` specifies the offset in the string "
"table. The following sections detail encoding of each kind."
msgstr ""

#: ../../../bpf/btf.rst:127
msgid "2.2.1 BTF_KIND_INT"
msgstr ""

#: ../../../bpf/btf.rst:129 ../../../bpf/btf.rst:181 ../../../bpf/btf.rst:193
#: ../../../bpf/btf.rst:238 ../../../bpf/btf.rst:282 ../../../bpf/btf.rst:307
#: ../../../bpf/btf.rst:319 ../../../bpf/btf.rst:331 ../../../bpf/btf.rst:343
#: ../../../bpf/btf.rst:355 ../../../bpf/btf.rst:367 ../../../bpf/btf.rst:389
#: ../../../bpf/btf.rst:414 ../../../bpf/btf.rst:443 ../../../bpf/btf.rst:468
#: ../../../bpf/btf.rst:480 ../../../bpf/btf.rst:514 ../../../bpf/btf.rst:545
msgid "``struct btf_type`` encoding requirement:"
msgstr ""

#: ../../../bpf/btf.rst:130 ../../../bpf/btf.rst:469
msgid "``name_off``: any valid offset"
msgstr ""

#: ../../../bpf/btf.rst:131 ../../../bpf/btf.rst:183 ../../../bpf/btf.rst:195
#: ../../../bpf/btf.rst:321 ../../../bpf/btf.rst:333 ../../../bpf/btf.rst:345
#: ../../../bpf/btf.rst:357 ../../../bpf/btf.rst:369 ../../../bpf/btf.rst:391
#: ../../../bpf/btf.rst:416 ../../../bpf/btf.rst:446 ../../../bpf/btf.rst:470
msgid "``info.kind_flag``: 0"
msgstr ""

#: ../../../bpf/btf.rst:132
msgid "``info.kind``: BTF_KIND_INT"
msgstr ""

#: ../../../bpf/btf.rst:133 ../../../bpf/btf.rst:185 ../../../bpf/btf.rst:197
#: ../../../bpf/btf.rst:311 ../../../bpf/btf.rst:323 ../../../bpf/btf.rst:335
#: ../../../bpf/btf.rst:347 ../../../bpf/btf.rst:359 ../../../bpf/btf.rst:418
#: ../../../bpf/btf.rst:472 ../../../bpf/btf.rst:484 ../../../bpf/btf.rst:518
msgid "``info.vlen``: 0"
msgstr ""

#: ../../../bpf/btf.rst:134
msgid "``size``: the size of the int type in bytes."
msgstr ""

#: ../../../bpf/btf.rst:136
msgid ""
"``btf_type`` is followed by a ``u32`` with the following bits arrangement::"
msgstr ""

#: ../../../bpf/btf.rst:142
msgid "The ``BTF_INT_ENCODING`` has the following attributes::"
msgstr ""

#: ../../../bpf/btf.rst:148
msgid ""
"The ``BTF_INT_ENCODING()`` provides extra information: signedness, char, or "
"bool, for the int type. The char and bool encoding are mostly useful for "
"pretty print. At most one encoding can be specified for the int type."
msgstr ""

#: ../../../bpf/btf.rst:152
msgid ""
"The ``BTF_INT_BITS()`` specifies the number of actual bits held by this int "
"type. For example, a 4-bit bitfield encodes ``BTF_INT_BITS()`` equals to 4. "
"The ``btf_type.size * 8`` must be equal to or greater than "
"``BTF_INT_BITS()`` for the type. The maximum value of ``BTF_INT_BITS()`` is "
"128."
msgstr ""

#: ../../../bpf/btf.rst:157
msgid ""
"The ``BTF_INT_OFFSET()`` specifies the starting bit offset to calculate "
"values for this int. For example, a bitfield struct member has:"
msgstr ""

#: ../../../bpf/btf.rst:160
msgid "btf member bit offset 100 from the start of the structure,"
msgstr ""

#: ../../../bpf/btf.rst:161 ../../../bpf/btf.rst:171
msgid "btf member pointing to an int type,"
msgstr ""

#: ../../../bpf/btf.rst:162
msgid "the int type has ``BTF_INT_OFFSET() = 2`` and ``BTF_INT_BITS() = 4``"
msgstr ""

#: ../../../bpf/btf.rst:164
msgid ""
"Then in the struct memory layout, this member will occupy ``4`` bits "
"starting from bits ``100 + 2 = 102``."
msgstr ""

#: ../../../bpf/btf.rst:167
msgid ""
"Alternatively, the bitfield struct member can be the following to access the "
"same bits as the above:"
msgstr ""

#: ../../../bpf/btf.rst:170
msgid "btf member bit offset 102,"
msgstr ""

#: ../../../bpf/btf.rst:172
msgid "the int type has ``BTF_INT_OFFSET() = 0`` and ``BTF_INT_BITS() = 4``"
msgstr ""

#: ../../../bpf/btf.rst:174
msgid ""
"The original intention of ``BTF_INT_OFFSET()`` is to provide flexibility of "
"bitfield encoding. Currently, both llvm and pahole generate "
"``BTF_INT_OFFSET() = 0`` for all int types."
msgstr ""

#: ../../../bpf/btf.rst:179
msgid "2.2.2 BTF_KIND_PTR"
msgstr ""

#: ../../../bpf/btf.rst:182 ../../../bpf/btf.rst:194 ../../../bpf/btf.rst:332
#: ../../../bpf/btf.rst:344 ../../../bpf/btf.rst:356 ../../../bpf/btf.rst:390
msgid "``name_off``: 0"
msgstr ""

#: ../../../bpf/btf.rst:184
msgid "``info.kind``: BTF_KIND_PTR"
msgstr ""

#: ../../../bpf/btf.rst:186
msgid "``type``: the pointee type of the pointer"
msgstr ""

#: ../../../bpf/btf.rst:188 ../../../bpf/btf.rst:314 ../../../bpf/btf.rst:326
#: ../../../bpf/btf.rst:338 ../../../bpf/btf.rst:350 ../../../bpf/btf.rst:362
#: ../../../bpf/btf.rst:375 ../../../bpf/btf.rst:475
msgid "No additional type data follow ``btf_type``."
msgstr ""

#: ../../../bpf/btf.rst:191
msgid "2.2.3 BTF_KIND_ARRAY"
msgstr ""

#: ../../../bpf/btf.rst:196
msgid "``info.kind``: BTF_KIND_ARRAY"
msgstr ""

#: ../../../bpf/btf.rst:198
msgid "``size/type``: 0, not used"
msgstr ""

#: ../../../bpf/btf.rst:200
msgid "``btf_type`` is followed by one ``struct btf_array``::"
msgstr ""

#: ../../../bpf/btf.rst:208
msgid "The ``struct btf_array`` encoding:"
msgstr ""

#: ../../../bpf/btf.rst:209
msgid "``type``: the element type"
msgstr ""

#: ../../../bpf/btf.rst:210
msgid "``index_type``: the index type"
msgstr ""

#: ../../../bpf/btf.rst:211
msgid ""
"``nelems``: the number of elements for this array (``0`` is also allowed)."
msgstr ""

#: ../../../bpf/btf.rst:213
msgid ""
"The ``index_type`` can be any regular int type (``u8``, ``u16``, ``u32``, "
"``u64``, ``unsigned __int128``). The original design of including "
"``index_type`` follows DWARF, which has an ``index_type`` for its array "
"type. Currently in BTF, beyond type verification, the ``index_type`` is not "
"used."
msgstr ""

#: ../../../bpf/btf.rst:218
msgid ""
"The ``struct btf_array`` allows chaining through element type to represent "
"multidimensional arrays. For example, for ``int a[5][6]``, the following "
"type information illustrates the chaining:"
msgstr ""

#: ../../../bpf/btf.rst:222
msgid "[1]: int"
msgstr ""

#: ../../../bpf/btf.rst:223
msgid "[2]: array, ``btf_array.type = [1]``, ``btf_array.nelems = 6``"
msgstr ""

#: ../../../bpf/btf.rst:224
msgid "[3]: array, ``btf_array.type = [2]``, ``btf_array.nelems = 5``"
msgstr ""

#: ../../../bpf/btf.rst:226
msgid ""
"Currently, both pahole and llvm collapse multidimensional array into one-"
"dimensional array, e.g., for ``a[5][6]``, the ``btf_array.nelems`` is equal "
"to ``30``. This is because the original use case is map pretty print where "
"the whole array is dumped out so one-dimensional array is enough. As more "
"BTF usage is explored, pahole and llvm can be changed to generate proper "
"chained representation for multidimensional arrays."
msgstr ""

#: ../../../bpf/btf.rst:234
msgid "2.2.4 BTF_KIND_STRUCT"
msgstr ""

#: ../../../bpf/btf.rst:236
msgid "2.2.5 BTF_KIND_UNION"
msgstr ""

#: ../../../bpf/btf.rst:239 ../../../bpf/btf.rst:283 ../../../bpf/btf.rst:546
msgid "``name_off``: 0 or offset to a valid C identifier"
msgstr ""

#: ../../../bpf/btf.rst:240 ../../../bpf/btf.rst:482 ../../../bpf/btf.rst:516
msgid "``info.kind_flag``: 0 or 1"
msgstr ""

#: ../../../bpf/btf.rst:241
msgid "``info.kind``: BTF_KIND_STRUCT or BTF_KIND_UNION"
msgstr ""

#: ../../../bpf/btf.rst:242
msgid "``info.vlen``: the number of struct/union members"
msgstr ""

#: ../../../bpf/btf.rst:243
msgid "``info.size``: the size of the struct/union in bytes"
msgstr ""

#: ../../../bpf/btf.rst:245
msgid ""
"``btf_type`` is followed by ``info.vlen`` number of ``struct btf_member``.::"
msgstr ""

#: ../../../bpf/btf.rst:253
msgid "``struct btf_member`` encoding:"
msgstr ""

#: ../../../bpf/btf.rst:254 ../../../bpf/btf.rst:297 ../../../bpf/btf.rst:308
#: ../../../bpf/btf.rst:320 ../../../bpf/btf.rst:368 ../../../bpf/btf.rst:415
#: ../../../bpf/btf.rst:561
msgid "``name_off``: offset to a valid C identifier"
msgstr ""

#: ../../../bpf/btf.rst:255
msgid "``type``: the member type"
msgstr ""

#: ../../../bpf/btf.rst:256
msgid "``offset``: <see below>"
msgstr ""

#: ../../../bpf/btf.rst:258
msgid ""
"If the type info ``kind_flag`` is not set, the offset contains only bit "
"offset of the member. Note that the base type of the bitfield can only be "
"int or enum type. If the bitfield size is 32, the base type can be either "
"int or enum type. If the bitfield size is not 32, the base type must be int, "
"and int type ``BTF_INT_BITS()`` encodes the bitfield size."
msgstr ""

#: ../../../bpf/btf.rst:264
msgid ""
"If the ``kind_flag`` is set, the ``btf_member.offset`` contains both member "
"bitfield size and bit offset. The bitfield size and bit offset are "
"calculated as below.::"
msgstr ""

#: ../../../bpf/btf.rst:271
msgid ""
"In this case, if the base type is an int type, it must be a regular int type:"
msgstr ""

#: ../../../bpf/btf.rst:273
msgid "``BTF_INT_OFFSET()`` must be 0."
msgstr ""

#: ../../../bpf/btf.rst:274
msgid "``BTF_INT_BITS()`` must be equal to ``{1,2,4,8,16} * 8``."
msgstr ""

#: ../../../bpf/btf.rst:276
msgid ""
"Commit 9d5f9f701b18 introduced ``kind_flag`` and explains why both modes "
"exist."
msgstr ""

#: ../../../bpf/btf.rst:280
msgid "2.2.6 BTF_KIND_ENUM"
msgstr ""

#: ../../../bpf/btf.rst:284 ../../../bpf/btf.rst:547
msgid "``info.kind_flag``: 0 for unsigned, 1 for signed"
msgstr ""

#: ../../../bpf/btf.rst:285
msgid "``info.kind``: BTF_KIND_ENUM"
msgstr ""

#: ../../../bpf/btf.rst:286 ../../../bpf/btf.rst:549
msgid "``info.vlen``: number of enum values"
msgstr ""

#: ../../../bpf/btf.rst:287 ../../../bpf/btf.rst:550
msgid "``size``: 1/2/4/8"
msgstr ""

#: ../../../bpf/btf.rst:289
msgid ""
"``btf_type`` is followed by ``info.vlen`` number of ``struct btf_enum``.::"
msgstr ""

#: ../../../bpf/btf.rst:296
msgid "The ``btf_enum`` encoding:"
msgstr ""

#: ../../../bpf/btf.rst:298
msgid "``val``: any value"
msgstr ""

#: ../../../bpf/btf.rst:300
msgid ""
"If the original enum value is signed and the size is less than 4, that value "
"will be sign extended into 4 bytes. If the size is 8, the value will be "
"truncated into 4 bytes."
msgstr ""

#: ../../../bpf/btf.rst:305
msgid "2.2.7 BTF_KIND_FWD"
msgstr ""

#: ../../../bpf/btf.rst:309
msgid "``info.kind_flag``: 0 for struct, 1 for union"
msgstr ""

#: ../../../bpf/btf.rst:310
msgid "``info.kind``: BTF_KIND_FWD"
msgstr ""

#: ../../../bpf/btf.rst:312
msgid "``type``: 0"
msgstr ""

#: ../../../bpf/btf.rst:317
msgid "2.2.8 BTF_KIND_TYPEDEF"
msgstr ""

#: ../../../bpf/btf.rst:322
msgid "``info.kind``: BTF_KIND_TYPEDEF"
msgstr ""

#: ../../../bpf/btf.rst:324
msgid "``type``: the type which can be referred by name at ``name_off``"
msgstr ""

#: ../../../bpf/btf.rst:329
msgid "2.2.9 BTF_KIND_VOLATILE"
msgstr ""

#: ../../../bpf/btf.rst:334
msgid "``info.kind``: BTF_KIND_VOLATILE"
msgstr ""

#: ../../../bpf/btf.rst:336
msgid "``type``: the type with ``volatile`` qualifier"
msgstr ""

#: ../../../bpf/btf.rst:341
msgid "2.2.10 BTF_KIND_CONST"
msgstr ""

#: ../../../bpf/btf.rst:346
msgid "``info.kind``: BTF_KIND_CONST"
msgstr ""

#: ../../../bpf/btf.rst:348
msgid "``type``: the type with ``const`` qualifier"
msgstr ""

#: ../../../bpf/btf.rst:353
msgid "2.2.11 BTF_KIND_RESTRICT"
msgstr ""

#: ../../../bpf/btf.rst:358
msgid "``info.kind``: BTF_KIND_RESTRICT"
msgstr ""

#: ../../../bpf/btf.rst:360
msgid "``type``: the type with ``restrict`` qualifier"
msgstr ""

#: ../../../bpf/btf.rst:365
msgid "2.2.12 BTF_KIND_FUNC"
msgstr ""

#: ../../../bpf/btf.rst:370
msgid "``info.kind``: BTF_KIND_FUNC"
msgstr ""

#: ../../../bpf/btf.rst:371
msgid "``info.vlen``: linkage information (BTF_FUNC_STATIC, BTF_FUNC_GLOBAL"
msgstr ""

#: ../../../bpf/btf.rst:372
msgid "or BTF_FUNC_EXTERN - see :ref:`BTF_Function_Linkage_Constants`)"
msgstr ""

#: ../../../bpf/btf.rst:373
msgid "``type``: a BTF_KIND_FUNC_PROTO type"
msgstr ""

#: ../../../bpf/btf.rst:377
msgid ""
"A BTF_KIND_FUNC defines not a type, but a subprogram (function) whose "
"signature is defined by ``type``. The subprogram is thus an instance of that "
"type. The BTF_KIND_FUNC may in turn be referenced by a func_info in the :ref:"
"`BTF_Ext_Section` (ELF) or in the arguments to :ref:`BPF_Prog_Load` (ABI)."
msgstr ""

#: ../../../bpf/btf.rst:383
msgid ""
"Currently, only linkage values of BTF_FUNC_STATIC and BTF_FUNC_GLOBAL are "
"supported in the kernel."
msgstr ""

#: ../../../bpf/btf.rst:387
msgid "2.2.13 BTF_KIND_FUNC_PROTO"
msgstr ""

#: ../../../bpf/btf.rst:392
msgid "``info.kind``: BTF_KIND_FUNC_PROTO"
msgstr ""

#: ../../../bpf/btf.rst:393
msgid "``info.vlen``: # of parameters"
msgstr ""

#: ../../../bpf/btf.rst:394
msgid "``type``: the return type"
msgstr ""

#: ../../../bpf/btf.rst:396
msgid ""
"``btf_type`` is followed by ``info.vlen`` number of ``struct btf_param``.::"
msgstr ""

#: ../../../bpf/btf.rst:403
msgid ""
"If a BTF_KIND_FUNC_PROTO type is referred by a BTF_KIND_FUNC type, then "
"``btf_param.name_off`` must point to a valid C identifier except for the "
"possible last argument representing the variable argument. The btf_param."
"type refers to parameter type."
msgstr ""

#: ../../../bpf/btf.rst:408
msgid ""
"If the function has variable arguments, the last parameter is encoded with "
"``name_off = 0`` and ``type = 0``."
msgstr ""

#: ../../../bpf/btf.rst:412
msgid "2.2.14 BTF_KIND_VAR"
msgstr ""

#: ../../../bpf/btf.rst:417
msgid "``info.kind``: BTF_KIND_VAR"
msgstr ""

#: ../../../bpf/btf.rst:419
msgid "``type``: the type of the variable"
msgstr ""

#: ../../../bpf/btf.rst:421
msgid ""
"``btf_type`` is followed by a single ``struct btf_variable`` with the "
"following data::"
msgstr ""

#: ../../../bpf/btf.rst:428
msgid ""
"``btf_var.linkage`` may take the values: BTF_VAR_STATIC, "
"BTF_VAR_GLOBAL_ALLOCATED or BTF_VAR_GLOBAL_EXTERN - see :ref:"
"`BTF_Var_Linkage_Constants`."
msgstr ""

#: ../../../bpf/btf.rst:431
msgid ""
"Not all type of global variables are supported by LLVM at this point. The "
"following is currently available:"
msgstr ""

#: ../../../bpf/btf.rst:434
msgid "static variables with or without section attributes"
msgstr ""

#: ../../../bpf/btf.rst:435
msgid "global variables with section attributes"
msgstr ""

#: ../../../bpf/btf.rst:437
msgid ""
"The latter is for future extraction of map key/value type id's from a map "
"definition."
msgstr ""

#: ../../../bpf/btf.rst:441
msgid "2.2.15 BTF_KIND_DATASEC"
msgstr ""

#: ../../../bpf/btf.rst:444
msgid "``name_off``: offset to a valid name associated with a variable or"
msgstr ""

#: ../../../bpf/btf.rst:445
msgid "one of .data/.bss/.rodata"
msgstr ""

#: ../../../bpf/btf.rst:447
msgid "``info.kind``: BTF_KIND_DATASEC"
msgstr ""

#: ../../../bpf/btf.rst:448
msgid "``info.vlen``: # of variables"
msgstr ""

#: ../../../bpf/btf.rst:449
msgid "``size``: total section size in bytes (0 at compilation time, patched"
msgstr ""

#: ../../../bpf/btf.rst:450
msgid "to actual size by BPF loaders such as libbpf)"
msgstr ""

#: ../../../bpf/btf.rst:452
msgid ""
"``btf_type`` is followed by ``info.vlen`` number of ``struct "
"btf_var_secinfo``.::"
msgstr ""

#: ../../../bpf/btf.rst:460
msgid "``struct btf_var_secinfo`` encoding:"
msgstr ""

#: ../../../bpf/btf.rst:461
msgid "``type``: the type of the BTF_KIND_VAR variable"
msgstr ""

#: ../../../bpf/btf.rst:462
msgid "``offset``: the in-section offset of the variable"
msgstr ""

#: ../../../bpf/btf.rst:463
msgid "``size``: the size of the variable in bytes"
msgstr ""

#: ../../../bpf/btf.rst:466
msgid "2.2.16 BTF_KIND_FLOAT"
msgstr ""

#: ../../../bpf/btf.rst:471
msgid "``info.kind``: BTF_KIND_FLOAT"
msgstr ""

#: ../../../bpf/btf.rst:473
msgid "``size``: the size of the float type in bytes: 2, 4, 8, 12 or 16."
msgstr ""

#: ../../../bpf/btf.rst:478
msgid "2.2.17 BTF_KIND_DECL_TAG"
msgstr ""

#: ../../../bpf/btf.rst:481 ../../../bpf/btf.rst:515
msgid "``name_off``: offset to a non-empty string"
msgstr ""

#: ../../../bpf/btf.rst:483
msgid "``info.kind``: BTF_KIND_DECL_TAG"
msgstr ""

#: ../../../bpf/btf.rst:485
msgid "``type``: ``struct``, ``union``, ``func``, ``var`` or ``typedef``"
msgstr ""

#: ../../../bpf/btf.rst:487
msgid "``btf_type`` is followed by ``struct btf_decl_tag``.::"
msgstr ""

#: ../../../bpf/btf.rst:493
msgid ""
"The ``type`` should be ``struct``, ``union``, ``func``, ``var`` or "
"``typedef``. For ``var`` or ``typedef`` type, ``btf_decl_tag.component_idx`` "
"must be ``-1``. For the other three types, if the btf_decl_tag attribute is "
"applied to the ``struct``, ``union`` or ``func`` itself, ``btf_decl_tag."
"component_idx`` must be ``-1``. Otherwise, the attribute is applied to a "
"``struct``/``union`` member or a ``func`` argument, and ``btf_decl_tag."
"component_idx`` should be a valid index (starting from 0) pointing to a "
"member or an argument."
msgstr ""

#: ../../../bpf/btf.rst:502
msgid ""
"If ``info.kind_flag`` is 0, then this is a normal decl tag, and the "
"``name_off`` encodes btf_decl_tag attribute string."
msgstr ""

#: ../../../bpf/btf.rst:505
msgid ""
"If ``info.kind_flag`` is 1, then the decl tag represents an arbitrary "
"__attribute__. In this case, ``name_off`` encodes a string representing the "
"attribute-list of the attribute specifier. For example, for an "
"``__attribute__((aligned(4)))`` the string's contents is ``aligned(4)``."
msgstr ""

#: ../../../bpf/btf.rst:512
msgid "2.2.18 BTF_KIND_TYPE_TAG"
msgstr ""

#: ../../../bpf/btf.rst:517
msgid "``info.kind``: BTF_KIND_TYPE_TAG"
msgstr ""

#: ../../../bpf/btf.rst:519
msgid "``type``: the type with ``btf_type_tag`` attribute"
msgstr ""

#: ../../../bpf/btf.rst:521
msgid ""
"Currently, ``BTF_KIND_TYPE_TAG`` is only emitted for pointer types. It has "
"the following btf type chain: ::"
msgstr ""

#: ../../../bpf/btf.rst:529
msgid ""
"Basically, a pointer type points to zero or more type_tag, then zero or more "
"const/volatile/restrict/typedef and finally the base type. The base type is "
"one of int, ptr, array, struct, union, enum, func_proto and float types."
msgstr ""

#: ../../../bpf/btf.rst:534
msgid ""
"Similarly to decl tags, if the ``info.kind_flag`` is 0, then this is a "
"normal type tag, and the ``name_off`` encodes btf_type_tag attribute string."
msgstr ""

#: ../../../bpf/btf.rst:538
msgid ""
"If ``info.kind_flag`` is 1, then the type tag represents an arbitrary "
"__attribute__, and the ``name_off`` encodes a string representing the "
"attribute-list of the attribute specifier."
msgstr ""

#: ../../../bpf/btf.rst:543
msgid "2.2.19 BTF_KIND_ENUM64"
msgstr ""

#: ../../../bpf/btf.rst:548
msgid "``info.kind``: BTF_KIND_ENUM64"
msgstr ""

#: ../../../bpf/btf.rst:552
msgid ""
"``btf_type`` is followed by ``info.vlen`` number of ``struct btf_enum64``.::"
msgstr ""

#: ../../../bpf/btf.rst:560
msgid "The ``btf_enum64`` encoding:"
msgstr ""

#: ../../../bpf/btf.rst:562
msgid "``val_lo32``: lower 32-bit value for a 64-bit value"
msgstr ""

#: ../../../bpf/btf.rst:563
msgid "``val_hi32``: high 32-bit value for a 64-bit value"
msgstr ""

#: ../../../bpf/btf.rst:565
msgid ""
"If the original enum value is signed and the size is less than 8, that value "
"will be sign extended into 8 bytes."
msgstr ""

#: ../../../bpf/btf.rst:569
msgid "2.3 Constant Values"
msgstr ""

#: ../../../bpf/btf.rst:574
msgid "2.3.1 Function Linkage Constant Values"
msgstr ""

#: ../../../bpf/btf.rst:575
msgid "Function Linkage Values and Meanings"
msgstr ""

#: ../../../bpf/btf.rst:578 ../../../bpf/btf.rst:593
msgid "kind"
msgstr ""

#: ../../../bpf/btf.rst:578 ../../../bpf/btf.rst:593
msgid "value"
msgstr ""

#: ../../../bpf/btf.rst:578 ../../../bpf/btf.rst:593
msgid "description"
msgstr ""

#: ../../../bpf/btf.rst:580
msgid "``BTF_FUNC_STATIC``"
msgstr ""

#: ../../../bpf/btf.rst:580 ../../../bpf/btf.rst:595
msgid "0x0"
msgstr ""

#: ../../../bpf/btf.rst:580
msgid ""
"definition of subprogram not visible outside containing compilation unit"
msgstr ""

#: ../../../bpf/btf.rst:581
msgid "``BTF_FUNC_GLOBAL``"
msgstr ""

#: ../../../bpf/btf.rst:581 ../../../bpf/btf.rst:596
msgid "0x1"
msgstr ""

#: ../../../bpf/btf.rst:581
msgid "definition of subprogram visible outside containing compilation unit"
msgstr ""

#: ../../../bpf/btf.rst:582
msgid "``BTF_FUNC_EXTERN``"
msgstr ""

#: ../../../bpf/btf.rst:582 ../../../bpf/btf.rst:597
msgid "0x2"
msgstr ""

#: ../../../bpf/btf.rst:582
msgid ""
"declaration of a subprogram whose definition is outside the containing "
"compilation unit"
msgstr ""

#: ../../../bpf/btf.rst:589
msgid "2.3.2 Variable Linkage Constant Values"
msgstr ""

#: ../../../bpf/btf.rst:590
msgid "Variable Linkage Values and Meanings"
msgstr ""

#: ../../../bpf/btf.rst:595
msgid "``BTF_VAR_STATIC``"
msgstr ""

#: ../../../bpf/btf.rst:595
msgid ""
"definition of global variable not visible outside containing compilation unit"
msgstr ""

#: ../../../bpf/btf.rst:596
msgid "``BTF_VAR_GLOBAL_ALLOCATED``"
msgstr ""

#: ../../../bpf/btf.rst:596
msgid ""
"definition of global variable visible outside containing compilation unit"
msgstr ""

#: ../../../bpf/btf.rst:597
msgid "``BTF_VAR_GLOBAL_EXTERN``"
msgstr ""

#: ../../../bpf/btf.rst:597
msgid ""
"declaration of global variable whose definition is outside the containing "
"compilation unit"
msgstr ""

#: ../../../bpf/btf.rst:601
msgid "3. BTF Kernel API"
msgstr ""

#: ../../../bpf/btf.rst:603
msgid "The following bpf syscall command involves BTF:"
msgstr ""

#: ../../../bpf/btf.rst:604
msgid "BPF_BTF_LOAD: load a blob of BTF data into kernel"
msgstr ""

#: ../../../bpf/btf.rst:605
msgid "BPF_MAP_CREATE: map creation with btf key and value type info."
msgstr ""

#: ../../../bpf/btf.rst:606
msgid "BPF_PROG_LOAD: prog load with btf function and line info."
msgstr ""

#: ../../../bpf/btf.rst:607
msgid "BPF_BTF_GET_FD_BY_ID: get a btf fd"
msgstr ""

#: ../../../bpf/btf.rst:608
msgid ""
"BPF_OBJ_GET_INFO_BY_FD: btf, func_info, line_info and other btf related info "
"are returned."
msgstr ""

#: ../../../bpf/btf.rst:611
msgid "The workflow typically looks like: ::"
msgstr ""

#: ../../../bpf/btf.rst:644
msgid "3.1 BPF_BTF_LOAD"
msgstr ""

#: ../../../bpf/btf.rst:646
msgid ""
"Load a blob of BTF data into kernel. A blob of data, described in :ref:"
"`BTF_Type_String`, can be directly loaded into the kernel. A ``btf_fd`` is "
"returned to a userspace."
msgstr ""

#: ../../../bpf/btf.rst:651
msgid "3.2 BPF_MAP_CREATE"
msgstr ""

#: ../../../bpf/btf.rst:653
msgid "A map can be created with ``btf_fd`` and specified key/value type id.::"
msgstr ""

#: ../../../bpf/btf.rst:659
msgid "In libbpf, the map can be defined with extra annotation like below: ::"
msgstr ""

#: ../../../bpf/btf.rst:669
msgid ""
"During ELF parsing, libbpf is able to extract key/value type_id's and assign "
"them to BPF_MAP_CREATE attributes automatically."
msgstr ""

#: ../../../bpf/btf.rst:675
msgid "3.3 BPF_PROG_LOAD"
msgstr ""

#: ../../../bpf/btf.rst:677
msgid ""
"During prog_load, func_info and line_info can be passed to kernel with "
"proper values for the following attributes: ::"
msgstr ""

#: ../../../bpf/btf.rst:692
msgid "The func_info and line_info are an array of below, respectively.::"
msgstr ""

#: ../../../bpf/btf.rst:705
msgid ""
"func_info_rec_size is the size of each func_info record, and "
"line_info_rec_size is the size of each line_info record. Passing the record "
"size to kernel make it possible to extend the record itself in the future."
msgstr ""

#: ../../../bpf/btf.rst:709
msgid "Below are requirements for func_info:"
msgstr ""

#: ../../../bpf/btf.rst:710
msgid "func_info[0].insn_off must be 0."
msgstr ""

#: ../../../bpf/btf.rst:711
msgid ""
"the func_info insn_off is in strictly increasing order and matches bpf func "
"boundaries."
msgstr ""

#: ../../../bpf/btf.rst:714
msgid "Below are requirements for line_info:"
msgstr ""

#: ../../../bpf/btf.rst:715
msgid ""
"the first insn in each func must have a line_info record pointing to it."
msgstr ""

#: ../../../bpf/btf.rst:716
msgid "the line_info insn_off is in strictly increasing order."
msgstr ""

#: ../../../bpf/btf.rst:718
msgid ""
"For line_info, the line number and column number are defined as below: ::"
msgstr ""

#: ../../../bpf/btf.rst:725
msgid "3.4 BPF_{PROG,MAP}_GET_NEXT_ID"
msgstr ""

#: ../../../bpf/btf.rst:727
msgid ""
"In kernel, every loaded program, map or btf has a unique id. The id won't "
"change during the lifetime of a program, map, or btf."
msgstr ""

#: ../../../bpf/btf.rst:730
msgid ""
"The bpf syscall command BPF_{PROG,MAP}_GET_NEXT_ID returns all id's, one for "
"each command, to user space, for bpf program or maps, respectively, so an "
"inspection tool can inspect all programs and maps."
msgstr ""

#: ../../../bpf/btf.rst:735
msgid "3.5 BPF_{PROG,MAP}_GET_FD_BY_ID"
msgstr ""

#: ../../../bpf/btf.rst:737
msgid ""
"An introspection tool cannot use id to get details about program or maps. A "
"file descriptor needs to be obtained first for reference-counting purpose."
msgstr ""

#: ../../../bpf/btf.rst:741
msgid "3.6 BPF_OBJ_GET_INFO_BY_FD"
msgstr ""

#: ../../../bpf/btf.rst:743
msgid ""
"Once a program/map fd is acquired, an introspection tool can get the "
"detailed information from kernel about this fd, some of which are BTF-"
"related. For example, ``bpf_map_info`` returns ``btf_id`` and key/value type "
"ids. ``bpf_prog_info`` returns ``btf_id``, func_info, and line info for "
"translated bpf byte codes, and jited_line_info."
msgstr ""

#: ../../../bpf/btf.rst:750
msgid "3.7 BPF_BTF_GET_FD_BY_ID"
msgstr ""

#: ../../../bpf/btf.rst:752
msgid ""
"With ``btf_id`` obtained in ``bpf_map_info`` and ``bpf_prog_info``, bpf "
"syscall command BPF_BTF_GET_FD_BY_ID can retrieve a btf fd. Then, with "
"command BPF_OBJ_GET_INFO_BY_FD, the btf blob, originally loaded into the "
"kernel with BPF_BTF_LOAD, can be retrieved."
msgstr ""

#: ../../../bpf/btf.rst:757
msgid ""
"With the btf blob, ``bpf_map_info``, and ``bpf_prog_info``, an introspection "
"tool has full btf knowledge and is able to pretty print map key/values, dump "
"func signatures and line info, along with byte/jit codes."
msgstr ""

#: ../../../bpf/btf.rst:762
msgid "4. ELF File Format Interface"
msgstr ""

#: ../../../bpf/btf.rst:765
msgid "4.1 .BTF section"
msgstr ""

#: ../../../bpf/btf.rst:767
msgid ""
"The .BTF section contains type and string data. The format of this section "
"is same as the one describe in :ref:`BTF_Type_String`."
msgstr ""

#: ../../../bpf/btf.rst:773
msgid "4.2 .BTF.ext section"
msgstr ""

#: ../../../bpf/btf.rst:775
msgid ""
"The .BTF.ext section encodes func_info, line_info and CO-RE relocations "
"which needs loader manipulation before loading into the kernel."
msgstr ""

#: ../../../bpf/btf.rst:778
msgid ""
"The specification for .BTF.ext section is defined at ``tools/lib/bpf/btf.h`` "
"and ``tools/lib/bpf/btf.c``."
msgstr ""

#: ../../../bpf/btf.rst:781
msgid "The current header of .BTF.ext section::"
msgstr ""

#: ../../../bpf/btf.rst:800
msgid ""
"It is very similar to .BTF section. Instead of type/string section, it "
"contains func_info, line_info and core_relo sub-sections. See :ref:"
"`BPF_Prog_Load` for details about func_info and line_info record format."
msgstr ""

#: ../../../bpf/btf.rst:805
msgid "The func_info is organized as below.::"
msgstr ""

#: ../../../bpf/btf.rst:812
msgid ""
"``func_info_rec_size`` specifies the size of ``bpf_func_info`` structure "
"when .BTF.ext is generated. ``btf_ext_info_sec``, defined below, is a "
"collection of func_info for each specific ELF section.::"
msgstr ""

#: ../../../bpf/btf.rst:823
msgid "Here, num_info must be greater than 0."
msgstr ""

#: ../../../bpf/btf.rst:825
msgid "The line_info is organized as below.::"
msgstr ""

#: ../../../bpf/btf.rst:832
msgid ""
"``line_info_rec_size`` specifies the size of ``bpf_line_info`` structure "
"when .BTF.ext is generated."
msgstr ""

#: ../../../bpf/btf.rst:835
msgid ""
"The interpretation of ``bpf_func_info->insn_off`` and ``bpf_line_info-"
">insn_off`` is different between kernel API and ELF API. For kernel API, the "
"``insn_off`` is the instruction offset in the unit of ``struct bpf_insn``. "
"For ELF API, the ``insn_off`` is the byte offset from the beginning of "
"section (``btf_ext_info_sec->sec_name_off``)."
msgstr ""

#: ../../../bpf/btf.rst:841
msgid "The core_relo is organized as below.::"
msgstr ""

#: ../../../bpf/btf.rst:847
msgid ""
"``core_relo_rec_size`` specifies the size of ``bpf_core_relo`` structure "
"when .BTF.ext is generated. All ``bpf_core_relo`` structures within a single "
"``btf_ext_info_sec`` describe relocations applied to section named by "
"``btf_ext_info_sec->sec_name_off``."
msgstr ""

#: ../../../bpf/btf.rst:852
msgid ""
"See :ref:`Documentation/bpf/llvm_reloc.rst <btf-co-re-relocations>` for more "
"information on CO-RE relocations."
msgstr ""

#: ../../../bpf/btf.rst:856
msgid "4.3 .BTF_ids section"
msgstr ""

#: ../../../bpf/btf.rst:858
msgid ""
"The .BTF_ids section encodes BTF ID values that are used within the kernel."
msgstr ""

#: ../../../bpf/btf.rst:860
msgid ""
"This section is created during the kernel compilation with the help of "
"macros defined in ``include/linux/btf_ids.h`` header file. Kernel code can "
"use them to create lists and sets (sorted lists) of BTF ID values."
msgstr ""

#: ../../../bpf/btf.rst:864
msgid ""
"The ``BTF_ID_LIST`` and ``BTF_ID`` macros define unsorted list of BTF ID "
"values, with following syntax::"
msgstr ""

#: ../../../bpf/btf.rst:871 ../../../bpf/btf.rst:896
msgid "resulting in following layout in .BTF_ids section::"
msgstr ""

#: ../../../bpf/btf.rst:878
msgid "The ``u32 list[];`` variable is defined to access the list."
msgstr ""

#: ../../../bpf/btf.rst:880
msgid ""
"The ``BTF_ID_UNUSED`` macro defines 4 zero bytes. It's used when we want to "
"define unused entry in BTF_ID_LIST, like::"
msgstr ""

#: ../../../bpf/btf.rst:888
msgid ""
"The ``BTF_SET_START/END`` macros pair defines sorted list of BTF ID values "
"and their count, with following syntax::"
msgstr ""

#: ../../../bpf/btf.rst:905
msgid "The ``struct btf_id_set set;`` variable is defined to access the list."
msgstr ""

#: ../../../bpf/btf.rst:907
msgid "The ``typeX`` name can be one of following::"
msgstr ""

#: ../../../bpf/btf.rst:911
msgid "and is used as a filter when resolving the BTF ID value."
msgstr ""

#: ../../../bpf/btf.rst:913
msgid ""
"All the BTF ID lists and sets are compiled in the .BTF_ids section and "
"resolved during the linking phase of kernel build by ``resolve_btfids`` tool."
msgstr ""

#: ../../../bpf/btf.rst:917
msgid "4.4 .BTF.base section"
msgstr ""

#: ../../../bpf/btf.rst:918
msgid ""
"Split BTF - where the .BTF section only contains types not in the associated "
"base .BTF section - is an extremely efficient way to encode type information "
"for kernel modules, since they generally consist of a few module-specific "
"types along with a large set of shared kernel types. The former are encoded "
"in split BTF, while the latter are encoded in base BTF, resulting in more "
"compact representations. A type in split BTF that refers to a type in base "
"BTF refers to it using its base BTF ID, and split BTF IDs start at "
"last_base_BTF_ID + 1."
msgstr ""

#: ../../../bpf/btf.rst:927
msgid ""
"The downside of this approach however is that this makes the split BTF "
"somewhat brittle - when the base BTF changes, base BTF ID references are no "
"longer valid and the split BTF itself becomes useless. The role of the .BTF."
"base section is to make split BTF more resilient for cases where the base "
"BTF may change, as is the case for kernel modules not built every time the "
"kernel is for example. .BTF.base contains named base types; INTs, FLOATs, "
"STRUCTs, UNIONs, ENUM[64]s and FWDs. INTs and FLOATs are fully described in ."
"BTF.base sections, while composite types like structs and unions are not "
"fully defined - the .BTF.base type simply serves as a description of the "
"type the split BTF referred to, so structs/unions have 0 members in the .BTF."
"base section. ENUM[64]s are similarly recorded with 0 members. Any other "
"types are added to the split BTF. This distillation process then leaves us "
"with a .BTF.base section with such minimal descriptions of base types and ."
"BTF split section which refers to those base types. Later, we can relocate "
"the split BTF using both the information stored in the .BTF.base section and "
"the new .BTF base; the type information in the .BTF.base section allows us "
"to update the split BTF references to point at the corresponding new base "
"BTF IDs."
msgstr ""

#: ../../../bpf/btf.rst:946
msgid ""
"BTF relocation happens on kernel module load when a kernel module has a .BTF."
"base section, and libbpf also provides a btf__relocate() API to accomplish "
"this."
msgstr ""

#: ../../../bpf/btf.rst:950
msgid "As an example consider the following base BTF::"
msgstr ""

#: ../../../bpf/btf.rst:957
msgid "...and associated split BTF::"
msgstr ""

#: ../../../bpf/btf.rst:961
msgid "i.e. split BTF describes a pointer to struct foo { int f1; int f2 };"
msgstr ""

#: ../../../bpf/btf.rst:963
msgid ".BTF.base will consist of::"
msgstr ""

#: ../../../bpf/btf.rst:968
msgid "If we relocate the split BTF later using the following new base BTF::"
msgstr ""

#: ../../../bpf/btf.rst:976
msgid ""
"...we can use our .BTF.base description to know that the split BTF reference "
"is to struct foo, and relocation results in new split BTF::"
msgstr ""

#: ../../../bpf/btf.rst:981
msgid "Note that we had to update BTF ID and start BTF ID for the split BTF."
msgstr ""

#: ../../../bpf/btf.rst:983
msgid ""
"So we see how .BTF.base plays the role of facilitating later relocation, "
"leading to more resilient split BTF."
msgstr ""

#: ../../../bpf/btf.rst:986
msgid ""
".BTF.base sections will be generated automatically for out-of-tree kernel "
"module builds - i.e. where KBUILD_EXTMOD is set (as it would be for \"make "
"M=path/2/mod\" cases). .BTF.base generation requires pahole support for the "
"\"distilled_base\" BTF feature; this is available in pahole v1.28 and later."
msgstr ""

#: ../../../bpf/btf.rst:992
msgid "5. Using BTF"
msgstr ""

#: ../../../bpf/btf.rst:995
msgid "5.1 bpftool map pretty print"
msgstr ""

#: ../../../bpf/btf.rst:997
msgid ""
"With BTF, the map key/value can be printed based on fields rather than "
"simply raw bytes. This is especially valuable for large structure or if your "
"data structure has bitfields. For example, for the following map,::"
msgstr ""

#: ../../../bpf/btf.rst:1019
msgid "bpftool is able to pretty print like below: ::"
msgstr ""

#: ../../../bpf/btf.rst:1036
msgid "5.2 bpftool prog dump"
msgstr ""

#: ../../../bpf/btf.rst:1038
msgid ""
"The following is an example showing how func_info and line_info can help "
"prog dump with better kernel symbol names, function prototypes and line "
"information.::"
msgstr ""

#: ../../../bpf/btf.rst:1070
msgid "5.3 Verifier Log"
msgstr ""

#: ../../../bpf/btf.rst:1072
msgid ""
"The following is an example of how line_info can help debugging verification "
"failure.::"
msgstr ""

#: ../../../bpf/btf.rst:1096
msgid "6. BTF Generation"
msgstr ""

#: ../../../bpf/btf.rst:1098
msgid "You need latest pahole"
msgstr ""

#: ../../../bpf/btf.rst:1100
msgid "https://git.kernel.org/pub/scm/devel/pahole/pahole.git/"
msgstr ""

#: ../../../bpf/btf.rst:1102
msgid ""
"or llvm (8.0 or later). The pahole acts as a dwarf2btf converter. It doesn't "
"support .BTF.ext and btf BTF_KIND_FUNC type yet. For example,::"
msgstr ""

#: ../../../bpf/btf.rst:1120
msgid ""
"The llvm is able to generate .BTF and .BTF.ext directly with -g for bpf "
"target only. The assembly code (-S) is able to show the BTF encoding in "
"assembly format.::"
msgstr ""

#: ../../../bpf/btf.rst:1203
msgid "7. Testing"
msgstr ""

#: ../../../bpf/btf.rst:1205
msgid ""
"The kernel BPF selftest `tools/testing/selftests/bpf/prog_tests/btf.c`_ "
"provides an extensive set of BTF-related tests."
msgstr ""
