# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-06 15:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/skbuff.rst:4
msgid "struct sk_buff"
msgstr ""

#: ../../../networking/skbuff.rst:6
msgid ""
":c:type:`sk_buff` is the main networking structure representing a packet."
msgstr ""

#: ../../../networking/skbuff.rst:10
msgid "Basic sk_buff geometry"
msgstr ""

#: ../../../networking/skbuff:12: include/linux/skbuff.h:736
msgid ""
"struct sk_buff itself is a metadata structure and does not hold any packet "
"data. All the data is held in associated buffers."
msgstr ""

#: ../../../networking/skbuff:12: include/linux/skbuff.h:739
msgid ""
":c:type:`sk_buff.head <sk_buff>` points to the main \"head\" buffer. The "
"head buffer is divided into two parts:"
msgstr ""

#: ../../../networking/skbuff:12: include/linux/skbuff.h:742
msgid ""
"data buffer, containing headers and sometimes payload; this is the part of "
"the skb operated on by the common helpers such as skb_put() or skb_pull();"
msgstr ""

#: ../../../networking/skbuff:12: include/linux/skbuff.h:745
msgid ""
"shared info (struct skb_shared_info) which holds an array of pointers to "
"read-only data in the (page, offset, length) format."
msgstr ""

#: ../../../networking/skbuff:12: include/linux/skbuff.h:748
msgid ""
"Optionally :c:type:`skb_shared_info.frag_list <skb_shared_info>` may point "
"to another skb."
msgstr ""

#: ../../../networking/skbuff:12: include/linux/skbuff.h:750
msgid "Basic diagram may look like this::"
msgstr ""

#: ../../../networking/skbuff.rst:16
msgid "Shared skbs and skb clones"
msgstr ""

#: ../../../networking/skbuff.rst:18
msgid ""
":c:member:`sk_buff.users` is a simple refcount allowing multiple entities to "
"keep a struct sk_buff alive. skbs with a ``sk_buff.users != 1`` are referred "
"to as shared skbs (see skb_shared())."
msgstr ""

#: ../../../networking/skbuff.rst:22
msgid ""
"skb_clone() allows for fast duplication of skbs. None of the data buffers "
"get copied, but caller gets a new metadata struct (struct sk_buff). "
"&skb_shared_info.refcount indicates the number of skbs pointing at the same "
"packet data (i.e. clones)."
msgstr ""

#: ../../../networking/skbuff.rst:28
msgid "dataref and headerless skbs"
msgstr ""

#: ../../../networking/skbuff:30: include/linux/skbuff.h:632
msgid ""
"Transport layers send out clones of payload skbs they hold for "
"retransmissions. To allow lower layers of the stack to prepend their headers "
"we split :c:type:`skb_shared_info.dataref <skb_shared_info>` into two "
"halves. The lower 16 bits count the overall number of references. The higher "
"16 bits indicate how many of the references are payload-only. "
"skb_header_cloned() checks if skb is allowed to add / write the headers."
msgstr ""

#: ../../../networking/skbuff:30: include/linux/skbuff.h:639
msgid ""
"The creator of the skb (e.g. TCP) marks its skb as :c:type:`sk_buff.nohdr "
"<sk_buff>` (via __skb_header_release()). Any clone created from marked skb "
"will get :c:type:`sk_buff.hdr_len <sk_buff>` populated with the available "
"headroom. If there's the only clone in existence it's able to modify the "
"headroom at will. The sequence of calls inside the transport layer is::"
msgstr ""

#: ../../../networking/skbuff:30: include/linux/skbuff.h:651
msgid ""
"This is not a very generic construct and it depends on the transport layers "
"doing the right thing. In practice there's usually only one payload-only "
"skb. Having multiple payload-only skbs with different lengths of hdr_len is "
"not possible. The payload-only skbs should never leave their owner."
msgstr ""

#: ../../../networking/skbuff.rst:34
msgid "Checksum information"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:44
msgid ""
"The interface for checksum offload between the stack and networking drivers "
"is as follows..."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:50
msgid ""
"Drivers advertise checksum offload capabilities in the features of a device. "
"From the stack's point of view these are capabilities offered by the driver. "
"A driver typically only advertises features that it is capable of offloading "
"to its device."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:55
msgid "Checksum related device features"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:58
msgid "``NETIF_F_HW_CSUM``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:59
msgid ""
"The driver (or its device) is able to compute one IP (one's complement) "
"checksum for any combination of protocols or protocol layering. The checksum "
"is computed and set in a packet per the CHECKSUM_PARTIAL interface (see "
"below)."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:65
msgid "``NETIF_F_IP_CSUM``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:66
msgid ""
"Driver (device) is only able to checksum plain TCP or UDP packets over IPv4. "
"These are specifically unencapsulated packets of the form IPv4|TCP or IPv4|"
"UDP where the Protocol field in the IPv4 header is TCP or UDP. The IPv4 "
"header may contain IP options. This feature cannot be set in features for a "
"device with NETIF_F_HW_CSUM also set. This feature is being DEPRECATED (see "
"below)."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:75
msgid "``NETIF_F_IPV6_CSUM``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:76
msgid ""
"Driver (device) is only able to checksum plain TCP or UDP packets over IPv6. "
"These are specifically unencapsulated packets of the form IPv6|TCP or IPv6|"
"UDP where the Next Header field in the IPv6 header is either TCP or UDP. "
"IPv6 extension headers are not supported with this feature. This feature "
"cannot be set in features for a device with NETIF_F_HW_CSUM also set. This "
"feature is being DEPRECATED (see below)."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:86
msgid "``NETIF_F_RXCSUM``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:87
msgid ""
"Driver (device) performs receive checksum offload. This flag is only used to "
"disable the RX checksum feature for a device. The stack will accept receive "
"checksum indication in packets received on a device regardless of whether "
"NETIF_F_RXCSUM is set."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:96
msgid ""
"Indication of checksum verification is set in :c:type:`sk_buff.ip_summed "
"<sk_buff>`. Possible values are:"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:99
#: include/linux/skbuff.h:190
msgid "``CHECKSUM_NONE``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:101
msgid ""
"Device did not checksum this packet e.g. due to lack of capabilities. The "
"packet contains full (though not verified) checksum in packet but not in skb-"
">csum. Thus, skb->csum is undefined in this case."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:105
#: include/linux/skbuff.h:195
msgid "``CHECKSUM_UNNECESSARY``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:107
msgid ""
"The hardware you're dealing with doesn't calculate the full checksum (as in "
"``CHECKSUM_COMPLETE``), but it does parse headers and verify checksums for "
"specific protocols. For such packets it will set ``CHECKSUM_UNNECESSARY`` if "
"their checksums are okay. :c:type:`sk_buff.csum <sk_buff>` is still "
"undefined in this case though. A driver or device must never modify the "
"checksum field in the packet even if checksum is verified."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:114
msgid "``CHECKSUM_UNNECESSARY`` is applicable to following protocols:"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:116
msgid "TCP: IPv6 and IPv4."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:117
msgid ""
"UDP: IPv4 and IPv6. A device may apply CHECKSUM_UNNECESSARY to a zero UDP "
"checksum for either IPv4 or IPv6, the networking stack may perform further "
"validation in this case."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:120
msgid "GRE: only if the checksum is present in the header."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:121
msgid "SCTP: indicates the CRC in SCTP header has been validated."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:122
msgid "FCOE: indicates the CRC in FC frame has been validated."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:124
msgid ""
":c:type:`sk_buff.csum_level <sk_buff>` indicates the number of consecutive "
"checksums found in the packet minus one that have been verified as "
"``CHECKSUM_UNNECESSARY``. For instance if a device receives an IPv6->UDP-"
">GRE->IPv4->TCP packet and a device is able to verify the checksums for UDP "
"(possibly zero), GRE (checksum flag is set) and TCP, :c:type:`sk_buff."
"csum_level <sk_buff>` would be set to two. If the device were only able to "
"verify the UDP checksum and not GRE, either because it doesn't support GRE "
"checksum or because GRE checksum is bad, skb->csum_level would be set to "
"zero (TCP checksum is not considered in this case)."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:134
#: include/linux/skbuff.h:200
msgid "``CHECKSUM_COMPLETE``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:136
msgid ""
"This is the most generic way. The device supplied checksum of the _whole_ "
"packet as seen by netif_rx() and fills in :c:type:`sk_buff.csum <sk_buff>`. "
"This means the hardware doesn't need to parse L3/L4 headers to implement "
"this."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:140
msgid "Notes:"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:142
msgid ""
"Even if device supports only some protocols, but is able to produce skb-"
">csum, it MUST use CHECKSUM_COMPLETE, not CHECKSUM_UNNECESSARY."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:144
msgid "CHECKSUM_COMPLETE is not applicable to SCTP and FCoE protocols."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:146
#: include/linux/skbuff.h:164
msgid "``CHECKSUM_PARTIAL``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:148
msgid ""
"A checksum is set up to be offloaded to a device as described in the output "
"description for CHECKSUM_PARTIAL. This may occur on a packet received "
"directly from another Linux OS, e.g., a virtualized Linux kernel on the same "
"host, or it may be set in the input path in GRO or remote checksum offload. "
"For the purposes of checksum verification, the checksum referred to by skb-"
">csum_start + skb->csum_offset and any preceding checksums in the packet are "
"considered verified. Any checksums in the packet that are after the checksum "
"being offloaded are not considered to be verified."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:161
msgid ""
"The stack requests checksum offload in the :c:type:`sk_buff.ip_summed "
"<sk_buff>` for a packet. Values are:"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:166
msgid ""
"The driver is required to checksum the packet as seen by hard_start_xmit() "
"from :c:type:`sk_buff.csum_start <sk_buff>` up to the end, and to record/"
"write the checksum at offset :c:type:`sk_buff.csum_start <sk_buff>` + :c:"
"type:`sk_buff.csum_offset <sk_buff>`. A driver may verify that the "
"csum_start and csum_offset values are valid values given the length and "
"offset of the packet, but it should not attempt to validate that the "
"checksum refers to a legitimate transport layer checksum -- it is the "
"purview of the stack to validate that csum_start and csum_offset are set "
"correctly."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:176
msgid ""
"When the stack requests checksum offload for a packet, the driver MUST "
"ensure that the checksum is set correctly. A driver can either offload the "
"checksum calculation to the device, or call skb_checksum_help (in the case "
"that the device does not support offload for a particular checksum)."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:181
msgid ""
"``NETIF_F_IP_CSUM`` and ``NETIF_F_IPV6_CSUM`` are being deprecated in favor "
"of ``NETIF_F_HW_CSUM``. New devices should use ``NETIF_F_HW_CSUM`` to "
"indicate checksum offload capability. skb_csum_hwoffload_help() can be "
"called to resolve ``CHECKSUM_PARTIAL`` based on network device checksumming "
"capabilities: if a packet does not match them, skb_checksum_help() or "
"skb_crc32c_help() (depending on the value of :c:type:`sk_buff.csum_not_inet "
"<sk_buff>`, see :ref:`crc`) is called to resolve the checksum."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:192
msgid ""
"The skb was already checksummed by the protocol, or a checksum is not "
"required."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:197
msgid ""
"This has the same meaning as CHECKSUM_NONE for checksum offload on output."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:202
msgid ""
"Not used in checksum output. If a driver observes a packet with this value "
"set in skbuff, it should treat the packet as if ``CHECKSUM_NONE`` were set."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:213
msgid "``NETIF_F_SCTP_CRC``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:214
msgid ""
"This feature indicates that a device is capable of offloading the SCTP CRC "
"in a packet. To perform this offload the stack will set csum_start and "
"csum_offset accordingly, set ip_summed to ``CHECKSUM_PARTIAL`` and set "
"csum_not_inet to 1, to provide an indication in the skbuff that the "
"``CHECKSUM_PARTIAL`` refers to CRC32c. A driver that supports both IP "
"checksum offload and SCTP CRC32c offload must verify which offload is "
"configured for a packet by testing the value of :c:type:`sk_buff."
"csum_not_inet <sk_buff>`; skb_crc32c_csum_help() is provided to resolve "
"``CHECKSUM_PARTIAL`` on skbs where csum_not_inet is set to 1."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:224
msgid "``NETIF_F_FCOE_CRC``"
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:225
msgid ""
"This feature indicates that a device is capable of offloading the FCOE CRC "
"in a packet. To perform this offload the stack will set ip_summed to "
"``CHECKSUM_PARTIAL`` and set csum_start and csum_offset accordingly. Note "
"that there is no indication in the skbuff that the ``CHECKSUM_PARTIAL`` "
"refers to an FCOE checksum, so a driver that supports both IP checksum "
"offload and FCOE CRC offload must verify which offload is configured for a "
"packet, presumably by inspecting packet headers."
msgstr ""

#: ../../../networking/skbuff:36: include/linux/skbuff.h:236
msgid ""
"In the case of a GSO packet (skb_is_gso() is true), checksum offload is "
"implied by the SKB_GSO_* flags in gso_type. Most obviously, if the gso_type "
"is ``SKB_GSO_TCPV4`` or ``SKB_GSO_TCPV6``, TCP checksum offload as part of "
"the GSO operation is implied. If a checksum is being offloaded with GSO then "
"ip_summed is ``CHECKSUM_PARTIAL``, and both csum_start and csum_offset are "
"set to refer to the outermost checksum being offloaded (two offloaded "
"checksums are possible with UDP encapsulation)."
msgstr ""
