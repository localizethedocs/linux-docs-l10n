# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/multiqueue.rst:5
msgid "HOWTO for multiqueue network device support"
msgstr ""

#: ../../../networking/multiqueue.rst:8
msgid "Section 1: Base driver requirements for implementing multiqueue support"
msgstr ""

#: ../../../networking/multiqueue.rst:11
msgid "Intro: Kernel support for multiqueue devices"
msgstr ""

#: ../../../networking/multiqueue.rst:13
msgid "Kernel support for multiqueue devices is always present."
msgstr ""

#: ../../../networking/multiqueue.rst:15
msgid ""
"Base drivers are required to use the new alloc_etherdev_mq() or "
"alloc_netdev_mq() functions to allocate the subqueues for the device.  The "
"underlying kernel API will take care of the allocation and deallocation of "
"the subqueue memory, as well as netdev configuration of where the queues "
"exist in memory."
msgstr ""

#: ../../../networking/multiqueue.rst:21
msgid ""
"The base driver will also need to manage the queues as it does the global "
"netdev->queue_lock today.  Therefore base drivers should use the "
"netif_{start|stop|wake}_subqueue() functions to manage each queue while the "
"device is still operational.  netdev->queue_lock is still used when the "
"device comes online or when it's completely shut down (unregister_netdev(), "
"etc.)."
msgstr ""

#: ../../../networking/multiqueue.rst:29
msgid "Section 2: Qdisc support for multiqueue devices"
msgstr ""

#: ../../../networking/multiqueue.rst:31
msgid ""
"Currently two qdiscs are optimized for multiqueue devices.  The first is the "
"default pfifo_fast qdisc.  This qdisc supports one qdisc per hardware queue. "
"A new round-robin qdisc, sch_multiq also supports multiple hardware queues. "
"The qdisc is responsible for classifying the skb's and then directing the "
"skb's to bands and queues based on the value in skb->queue_mapping.  Use "
"this field in the base driver to determine which queue to send the skb to."
msgstr ""

#: ../../../networking/multiqueue.rst:38
msgid ""
"sch_multiq has been added for hardware that wishes to avoid head-of-line "
"blocking.  It will cycle though the bands and verify that the hardware queue "
"associated with the band is not stopped prior to dequeuing a packet."
msgstr ""

#: ../../../networking/multiqueue.rst:42
msgid ""
"On qdisc load, the number of bands is based on the number of queues on the "
"hardware.  Once the association is made, any skb with skb->queue_mapping "
"set, will be queued to the band associated with the hardware queue."
msgstr ""

#: ../../../networking/multiqueue.rst:48
msgid "Section 3: Brief howto using MULTIQ for multiqueue devices"
msgstr ""

#: ../../../networking/multiqueue.rst:50
msgid ""
"The userspace command 'tc,' part of the iproute2 package, is used to "
"configure qdiscs.  To add the MULTIQ qdisc to your network device, assuming "
"the device is called eth0, run the following command::"
msgstr ""

#: ../../../networking/multiqueue.rst:56
msgid ""
"The qdisc will allocate the number of bands to equal the number of queues "
"that the device reports, and bring the qdisc online.  Assuming eth0 has 4 Tx "
"queues, the band mapping would look like::"
msgstr ""

#: ../../../networking/multiqueue.rst:65
msgid ""
"Traffic will begin flowing through each queue based on either the "
"simple_tx_hash function or based on netdev->select_queue() if you have it "
"defined."
msgstr ""

#: ../../../networking/multiqueue.rst:68
msgid ""
"The behavior of tc filters remains the same.  However a new tc action, "
"skbedit, has been added.  Assuming you wanted to route all traffic to a "
"specific host, for example 192.168.0.3, through a specific queue you could "
"use this action and establish a filter such as::"
msgstr ""

#: ../../../networking/multiqueue.rst:0
msgid "Author"
msgstr ""

#: ../../../networking/multiqueue.rst:77
msgid "Alexander Duyck <alexander.h.duyck@intel.com>"
msgstr ""

#: ../../../networking/multiqueue.rst:0
msgid "Original Author"
msgstr ""

#: ../../../networking/multiqueue.rst:78
msgid "Peter P. Waskiewicz Jr. <peter.p.waskiewicz.jr@intel.com>"
msgstr ""
